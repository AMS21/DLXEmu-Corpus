_ZN3dlx9enum_nameIN6dlxemu10CodeEditor13SelectionModeEEENSt3__117basic_string_viewIcNS4_11char_traitsIcEEEET_:
  411|  2.78k|    {
  412|  2.78k|        switch (value)
  413|  2.78k|        {
  414|    159|            case dlxemu::CodeEditor::SelectionMode::Line:
  ------------------
  |  Branch (414:13): [True: 159, False: 2.62k]
  ------------------
  415|    159|                return "Line";
  416|  2.00k|            case dlxemu::CodeEditor::SelectionMode::Normal:
  ------------------
  |  Branch (416:13): [True: 2.00k, False: 779]
  ------------------
  417|  2.00k|                return "Normal";
  418|    620|            case dlxemu::CodeEditor::SelectionMode::Word:
  ------------------
  |  Branch (418:13): [True: 620, False: 2.16k]
  ------------------
  419|    620|                return "Word";
  420|       |
  421|      0|            default:
  ------------------
  |  Branch (421:13): [True: 0, False: 2.78k]
  ------------------
  422|      0|                PHI_ASSERT_NOT_REACHED();
  423|  2.78k|        }
  424|  2.78k|    }
_ZN6dlxemu10CodeEditor10UndoRecordC2Ev:
  265|  80.6k|            UndoRecord() = default;

_ZN6dlxemu6WindowC2Ev:
   13|  7.25k|        Window() = default;

_ZN6dlxemu10CodeEditor11CoordinatesC2Ev:
  194|   887k|    {}
_ZN6dlxemu10CodeEditor11CoordinatesC2EN3phi7integerIjEES4_:
  199|   649k|    {}
_ZNK6dlxemu10CodeEditor11CoordinateseqERKS1_:
  203|  9.74k|    {
  204|  9.74k|        return (m_Line == other.m_Line) && (m_Column == other.m_Column);
  ------------------
  |  Branch (204:16): [True: 6.70k, False: 3.03k]
  |  Branch (204:44): [True: 2.85k, False: 3.84k]
  ------------------
  205|  9.74k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesneERKS1_:
  209|  85.5k|    {
  210|  85.5k|        return (m_Line != other.m_Line) || (m_Column != other.m_Column);
  ------------------
  |  Branch (210:16): [True: 12.7k, False: 72.8k]
  |  Branch (210:44): [True: 37.9k, False: 34.9k]
  ------------------
  211|  85.5k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesltERKS1_:
  215|  1.83k|    {
  216|  1.83k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (216:13): [True: 840, False: 997]
  ------------------
  217|    840|        {
  218|    840|            return m_Line < other.m_Line;
  219|    840|        }
  220|       |
  221|    997|        return m_Column < other.m_Column;
  222|  1.83k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgtERKS1_:
  226|   122k|    {
  227|   122k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (227:13): [True: 12.6k, False: 109k]
  ------------------
  228|  12.6k|        {
  229|  12.6k|            return m_Line > other.m_Line;
  230|  12.6k|        }
  231|       |
  232|   109k|        return m_Column > other.m_Column;
  233|   122k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesleERKS1_:
  237|  34.2k|    {
  238|  34.2k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (238:13): [True: 6.11k, False: 28.1k]
  ------------------
  239|  6.11k|        {
  240|  6.11k|            return m_Line < other.m_Line;
  241|  6.11k|        }
  242|       |
  243|  28.1k|        return m_Column <= other.m_Column;
  244|  34.2k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgeERKS1_:
  248|  16.8k|    {
  249|  16.8k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (249:13): [True: 414, False: 16.4k]
  ------------------
  250|    414|        {
  251|    414|            return m_Line > other.m_Line;
  252|    414|        }
  253|       |
  254|  16.4k|        return m_Column >= other.m_Column;
  255|  16.8k|    }
_ZN6dlxemu10CodeEditor5GlyphC2EhNS0_12PaletteIndexE:
  262|  74.3k|    {}
_ZN6dlxemu10CodeEditorC2EPNS_8EmulatorE:
  290|  14.5k|    {
  291|  14.5k|        Colorize();
  292|  14.5k|        m_Lines.push_back(Line());
  293|  14.5k|    }
_ZN6dlxemu10CodeEditorD2Ev:
  296|  14.5k|    {
  297|  14.5k|        VerifyInternalState();
  298|  14.5k|    }
_ZN6dlxemu10CodeEditor15SetErrorMarkersERKNSt3__13mapIjNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS1_4lessIjEENS6_INS1_4pairIKjS8_EEEEEE:
  313|     13|    {
  314|       |        // Reject if any marker are invalid
  315|     13|        for (auto&& marker : markers)
  ------------------
  |  Branch (315:28): [True: 0, False: 13]
  ------------------
  316|      0|        {
  317|      0|            const phi::u32 line_number = marker.first;
  318|       |
  319|      0|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (319:17): [True: 0, False: 0]
  |  Branch (319:17): [True: 0, False: 0]
  |  Branch (319:38): [True: 0, False: 0]
  ------------------
  320|      0|            {
  321|      0|                return;
  322|      0|            }
  323|      0|        }
  324|       |
  325|     13|        m_ErrorMarkers = markers;
  326|     13|    }
_ZN6dlxemu10CodeEditor14AddErrorMarkerEN3phi7integerIjEERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE:
  329|  4.74k|    {
  330|  4.74k|        if (line_number > m_Lines.size() || line_number == 0u)
  ------------------
  |  Branch (330:13): [True: 0, False: 4.74k]
  |  Branch (330:13): [True: 0, False: 4.74k]
  |  Branch (330:45): [True: 0, False: 4.74k]
  ------------------
  331|      0|        {
  332|      0|            return;
  333|      0|        }
  334|       |
  335|  4.74k|        if (m_ErrorMarkers.contains(line_number.unsafe()))
  ------------------
  |  Branch (335:13): [True: 1.37k, False: 3.36k]
  ------------------
  336|  1.37k|        {
  337|  1.37k|            m_ErrorMarkers[line_number.unsafe()] += '\n' + message;
  338|  1.37k|        }
  339|  3.36k|        else
  340|  3.36k|        {
  341|  3.36k|            m_ErrorMarkers[line_number.unsafe()] = message;
  342|  3.36k|        }
  343|  4.74k|    }
_ZN6dlxemu10CodeEditor17ClearErrorMarkersEv:
  346|  8.91k|    {
  347|  8.91k|        m_ErrorMarkers.clear();
  348|  8.91k|    }
_ZN6dlxemu10CodeEditor14SetBreakpointsERKNSt3__113unordered_setIjNS1_4hashIjEENS1_8equal_toIjEENS1_9allocatorIjEEEE:
  361|  1.43k|    {
  362|       |        // Reject aif any lines are invalid
  363|  1.43k|        for (phi::u32 line_number : markers)
  ------------------
  |  Branch (363:35): [True: 1.42k, False: 111]
  ------------------
  364|  1.42k|        {
  365|  1.42k|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (365:17): [True: 53, False: 1.37k]
  |  Branch (365:17): [True: 1.32k, False: 103]
  |  Branch (365:38): [True: 1.27k, False: 103]
  ------------------
  366|  1.32k|            {
  367|  1.32k|                return;
  368|  1.32k|            }
  369|  1.42k|        }
  370|       |
  371|    111|        m_Breakpoints = markers;
  372|    111|    }
_ZN6dlxemu10CodeEditor16ClearBreakPointsEv:
  411|    168|    {
  412|    168|        m_Breakpoints.clear();
  413|    168|    }
_ZN6dlxemu10CodeEditor6RenderERK6ImVec2N3phi7booleanE:
  426|  55.4k|    {
  427|       |        // Verify that ImGui is correctly initialzied
  428|  55.4k|        PHI_ASSERT(GImGui && GImGui->Initialized, "ImGui was not initialized!");
  429|       |
  430|  55.4k|        m_CursorPositionChanged = false;
  431|       |
  432|  55.4k|        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::ColorConvertU32ToFloat4(GetPaletteForIndex(
  433|  55.4k|                                                        PaletteIndex::Background)));
  434|  55.4k|        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
  435|       |
  436|  55.4k|        static constexpr const float min_size = 0.0f;
  437|  55.4k|        static constexpr const float max_size =
  438|  55.4k|                static_cast<float>(std::numeric_limits<int>::max()) * 0.95f;
  439|       |
  440|       |        // Properly sanitize size
  441|  55.4k|        ImVec2 sanitized_size;
  442|  55.4k|        if (phi::is_nan(size.x) || std::isinf(size.x))
  ------------------
  |  Branch (442:13): [True: 957, False: 54.4k]
  |  Branch (442:36): [True: 2, False: 54.4k]
  ------------------
  443|    959|        {
  444|    959|            sanitized_size.x = min_size;
  445|    959|        }
  446|  54.4k|        else
  447|  54.4k|        {
  448|  54.4k|            sanitized_size.x = phi::clamp(size.x, min_size, max_size);
  449|  54.4k|        }
  450|       |
  451|  55.4k|        if (phi::is_nan(size.y) || std::isinf(size.y))
  ------------------
  |  Branch (451:13): [True: 2.11k, False: 53.2k]
  |  Branch (451:36): [True: 2, False: 53.2k]
  ------------------
  452|  2.11k|        {
  453|  2.11k|            sanitized_size.y = min_size;
  454|  2.11k|        }
  455|  53.2k|        else
  456|  53.2k|        {
  457|  53.2k|            sanitized_size.y = phi::clamp(size.y, min_size, max_size);
  458|  53.2k|        }
  459|       |
  460|  55.4k|        if (ImGui::Begin("Code Editor"))
  ------------------
  |  Branch (460:13): [True: 11.3k, False: 44.0k]
  ------------------
  461|  11.3k|        {
  462|  11.3k|            ImGui::BeginChild("Code Editor", sanitized_size, border.unsafe(),
  463|  11.3k|                              ImGuiWindowFlags_HorizontalScrollbar |
  464|  11.3k|                                      ImGuiWindowFlags_AlwaysHorizontalScrollbar |
  465|  11.3k|                                      ImGuiWindowFlags_NoMove);
  466|       |
  467|       |            // Need to calculate char advance before any inputs which use the values
  468|  11.3k|            ComputeCharAdvance();
  469|       |
  470|  11.3k|            HandleKeyboardInputs();
  471|  11.3k|            ImGui::PushAllowKeyboardFocus(true);
  472|       |
  473|  11.3k|            HandleMouseInputs();
  474|       |
  475|  11.3k|            if (m_TextChanged)
  ------------------
  |  Branch (475:17): [True: 2.70k, False: 8.69k]
  ------------------
  476|  2.70k|            {
  477|  2.70k|                m_FullText = GetText();
  478|       |
  479|  2.70k|                m_Emulator->ParseProgram(m_FullText);
  480|       |
  481|  2.70k|                ColorizeInternal();
  482|       |
  483|  2.70k|                ClearErrorMarkers();
  484|       |
  485|       |                // Add error markers
  486|  2.70k|                for (const dlx::ParseError& err : m_Emulator->m_DLXProgram.m_ParseErrors)
  ------------------
  |  Branch (486:49): [True: 4.74k, False: 2.70k]
  ------------------
  487|  4.74k|                {
  488|  4.74k|                    AddErrorMarker(static_cast<phi::uint32_t>(err.GetLineNumber()),
  489|  4.74k|                                   err.ConstructMessage());
  490|  4.74k|                }
  491|       |
  492|  2.70k|                m_TextChanged = false;
  493|  2.70k|            }
  494|       |
  495|  11.3k|            InternalRender();
  496|       |
  497|  11.3k|            ImGui::PopAllowKeyboardFocus();
  498|       |
  499|  11.3k|            ImGui::EndChild();
  500|  11.3k|        }
  501|  55.4k|        ImGui::End();
  502|       |
  503|  55.4k|        ImGui::PopStyleVar();
  504|  55.4k|        ImGui::PopStyleColor();
  505|  55.4k|    }
_ZNK6dlxemu10CodeEditor7GetTextEv:
  541|  2.80k|    {
  542|  2.80k|        const phi::u32 max_line = GetMaxLineNumber();
  543|       |
  544|  2.80k|        return GetText(Coordinates(0u, 0u), Coordinates(max_line, GetLineMaxColumn(max_line)));
  545|  2.80k|    }
_ZN6dlxemu10CodeEditor9ClearTextEv:
  548|     78|    {
  549|     78|        PHI_ASSERT(!m_Lines.empty());
  550|       |
  551|     78|        if (IsReadOnly())
  ------------------
  |  Branch (551:13): [True: 11, False: 67]
  ------------------
  552|     11|        {
  553|     11|            return;
  554|     11|        }
  555|       |
  556|       |        // No text to clear
  557|     67|        if (m_Lines.size() == 1u && m_Lines[0u].empty())
  ------------------
  |  Branch (557:13): [True: 44, False: 23]
  |  Branch (557:37): [True: 27, False: 17]
  ------------------
  558|     27|        {
  559|     27|            return;
  560|     27|        }
  561|       |
  562|     40|        UndoRecord undo;
  563|     40|        undo.StoreBeforeState(this);
  564|       |
  565|     40|        undo.m_Removed      = GetText();
  566|     40|        undo.m_RemovedStart = Coordinates(0u, 0u);
  567|     40|        phi::u32 max_line   = GetMaxLineNumber();
  568|     40|        undo.m_RemovedEnd   = Coordinates(max_line, GetLineMaxColumn(max_line));
  569|       |
  570|     40|        m_Lines.clear();
  571|     40|        m_Lines.emplace_back(Line{});
  572|     40|        ResetState();
  573|       |
  574|     40|        undo.StoreAfterState(this);
  575|     40|        AddUndo(undo);
  576|     40|    }
_ZN6dlxemu10CodeEditor12SetTextLinesERKNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE:
  579|    128|    {
  580|    128|        m_Lines.clear();
  581|    128|        ResetState();
  582|       |
  583|    128|        if (lines.empty())
  ------------------
  |  Branch (583:13): [True: 128, False: 0]
  ------------------
  584|    128|        {
  585|    128|            m_Lines.emplace_back(Line());
  586|    128|        }
  587|      0|        else
  588|      0|        {
  589|      0|            m_Lines.resize(lines.size());
  590|       |
  591|      0|            phi::usize line_number{0u};
  592|      0|            for (phi::usize index = 0u; index < lines.size(); ++index, ++line_number)
  ------------------
  |  Branch (592:41): [True: 0, False: 0]
  ------------------
  593|      0|            {
  594|      0|                const std::string& line = lines[index.unsafe()];
  595|       |
  596|      0|                m_Lines[line_number.unsafe()].reserve(line.size());
  597|      0|                for (char character : line)
  ------------------
  |  Branch (597:37): [True: 0, False: 0]
  ------------------
  598|      0|                {
  599|      0|                    if (character == '\n')
  ------------------
  |  Branch (599:25): [True: 0, False: 0]
  ------------------
  600|      0|                    {
  601|       |                        // Hang on an extra line at the end
  602|      0|                        m_Lines.emplace_back(Line{});
  603|       |
  604|       |                        // Increase line number
  605|      0|                        line_number += 1u;
  606|      0|                    }
  607|      0|                    else
  608|      0|                    {
  609|      0|                        m_Lines[line_number.unsafe()].emplace_back(
  610|      0|                                Glyph(static_cast<Char>(character), PaletteIndex::Default));
  611|      0|                    }
  612|      0|                }
  613|      0|            }
  614|      0|        }
  615|       |
  616|    128|        m_TextChanged = true;
  617|    128|        m_ScrollToTop = true;
  618|       |
  619|    128|        m_UndoBuffer.clear();
  620|    128|        m_UndoIndex = 0u;
  621|       |
  622|    128|        Colorize();
  623|    128|    }
_ZNK6dlxemu10CodeEditor12GetTextLinesEv:
  626|    129|    {
  627|    129|        std::vector<std::string> result;
  628|       |
  629|    129|        result.reserve(m_Lines.size());
  630|       |
  631|    129|        for (const Line& line : m_Lines)
  ------------------
  |  Branch (631:31): [True: 427, False: 129]
  ------------------
  632|    427|        {
  633|    427|            std::string text;
  634|       |
  635|    427|            text.resize(line.size());
  636|       |
  637|  1.79k|            for (size_t i = 0; i < line.size(); ++i)
  ------------------
  |  Branch (637:32): [True: 1.37k, False: 427]
  ------------------
  638|  1.37k|            {
  639|  1.37k|                text[i] = static_cast<char>(line[i].m_Char);
  640|  1.37k|            }
  641|       |
  642|    427|            result.emplace_back(phi::move(text));
  643|    427|        }
  644|       |
  645|    129|        return result;
  646|    129|    }
_ZNK6dlxemu10CodeEditor15GetSelectedTextEv:
  649|  3.10k|    {
  650|  3.10k|        return GetText(m_State.m_SelectionStart, m_State.m_SelectionEnd);
  651|  3.10k|    }
_ZNK6dlxemu10CodeEditor18GetCurrentLineTextEv:
  654|     35|    {
  655|     35|        const phi::u32 line_length = GetLineMaxColumn(m_State.m_CursorPosition.m_Line);
  656|       |
  657|     35|        return GetText(Coordinates(m_State.m_CursorPosition.m_Line, 0u),
  658|     35|                       Coordinates(m_State.m_CursorPosition.m_Line, line_length));
  659|     35|    }
_ZN6dlxemu10CodeEditor11SetReadOnlyEN3phi7booleanE:
  682|  1.28k|    {
  683|  1.28k|        m_ReadOnly = value;
  684|  1.28k|    }
_ZNK6dlxemu10CodeEditor10IsReadOnlyEv:
  692|  86.6k|    {
  693|  86.6k|        return m_ReadOnly;
  694|  86.6k|    }
_ZNK6dlxemu10CodeEditor17GetCursorPositionEv:
  722|  89.2k|    {
  723|  89.2k|        return GetActualCursorCoordinates();
  724|  89.2k|    }
_ZN6dlxemu10CodeEditor17SetCursorPositionERKNS0_11CoordinatesE:
  727|  46.6k|    {
  728|       |        // Sanitize
  729|  46.6k|        const Coordinates new_pos = SanitizeCoordinates(position);
  730|       |
  731|  46.6k|        if (m_State.m_CursorPosition != new_pos)
  ------------------
  |  Branch (731:13): [True: 43.2k, False: 3.37k]
  ------------------
  732|  43.2k|        {
  733|  43.2k|            m_State.m_CursorPosition = new_pos;
  734|  43.2k|            m_CursorPositionChanged  = true;
  735|  43.2k|            EnsureCursorVisible();
  736|  43.2k|        }
  737|  46.6k|    }
_ZN6dlxemu10CodeEditor18SetShowWhitespacesEN3phi7booleanE:
  740|    670|    {
  741|    670|        m_ShowWhitespaces = value;
  742|    670|    }
_ZN6dlxemu10CodeEditor10SetTabSizeEN3phi7integerIhEE:
  755|  1.13k|    {
  756|  1.13k|        new_tab_size = phi::clamp(new_tab_size, MinTabSize, MaxTabSize);
  757|       |
  758|  1.13k|        if (new_tab_size != m_TabSize)
  ------------------
  |  Branch (758:13): [True: 331, False: 800]
  ------------------
  759|    331|        {
  760|       |            // Save old character indexes
  761|    331|            const phi::u32 cursor_char_index          = GetCharacterIndex(m_State.m_CursorPosition);
  762|    331|            const phi::u32 selection_start_char_index = GetCharacterIndex(m_State.m_SelectionStart);
  763|    331|            const phi::u32 selection_end_char_index   = GetCharacterIndex(m_State.m_SelectionEnd);
  764|       |
  765|       |            // Update tab size
  766|    331|            m_TabSize = new_tab_size;
  767|       |
  768|       |            // Set new character indexes
  769|    331|            m_State.m_CursorPosition.m_Column =
  770|    331|                    GetCharacterColumn(m_State.m_CursorPosition.m_Line, cursor_char_index);
  771|    331|            m_State.m_SelectionStart.m_Column =
  772|    331|                    GetCharacterColumn(m_State.m_SelectionStart.m_Line, selection_start_char_index);
  773|    331|            m_State.m_SelectionEnd.m_Column =
  774|    331|                    GetCharacterColumn(m_State.m_SelectionEnd.m_Line, selection_end_char_index);
  775|    331|        }
  776|  1.13k|    }
_ZN6dlxemu10CodeEditor14EnterCharacterEtN3phi7booleanE:
  784|  44.0k|    {
  785|  44.0k|        if (!IsReadOnly() && character != '\0' && IsValidUTF8Sequence(character))
  ------------------
  |  Branch (785:13): [True: 43.0k, False: 1.03k]
  |  Branch (785:13): [True: 40.4k, False: 3.57k]
  |  Branch (785:30): [True: 40.5k, False: 2.51k]
  |  Branch (785:51): [True: 40.4k, False: 27]
  ------------------
  786|  40.4k|        {
  787|  40.4k|            EnterCharacterImpl(character, shift);
  788|  40.4k|        }
  789|  44.0k|    }
_ZN6dlxemu10CodeEditor9BackspaceEv:
  792|  1.42k|    {
  793|  1.42k|        if (!IsReadOnly())
  ------------------
  |  Branch (793:13): [True: 1.14k, False: 273]
  ------------------
  794|  1.14k|        {
  795|  1.14k|            BackspaceImpl();
  796|  1.14k|        }
  797|  1.42k|    }
_ZN6dlxemu10CodeEditor6MoveUpEN3phi7integerIjEENS1_7booleanE:
  824|  1.75k|    {
  825|  1.75k|        if (amount == 0u)
  ------------------
  |  Branch (825:13): [True: 442, False: 1.30k]
  ------------------
  826|    442|        {
  827|    442|            return;
  828|    442|        }
  829|       |
  830|  1.30k|        const Coordinates old_pos = m_State.m_CursorPosition;
  831|       |
  832|       |        // Move cursor to the beginning of the first line
  833|  1.30k|        if (amount > old_pos.m_Line)
  ------------------
  |  Branch (833:13): [True: 1.30k, False: 6]
  ------------------
  834|  1.30k|        {
  835|  1.30k|            m_State.m_CursorPosition.m_Line   = 0u;
  836|  1.30k|            m_State.m_CursorPosition.m_Column = 0u;
  837|  1.30k|        }
  838|      6|        else
  839|      6|        {
  840|      6|            PHI_ASSERT(amount <= m_State.m_CursorPosition.m_Line);
  841|      6|            m_State.m_CursorPosition.m_Line -= amount;
  842|      6|        }
  843|       |
  844|  1.30k|        FixSelectionAfterMove(select, old_pos);
  845|  1.30k|    }
_ZN6dlxemu10CodeEditor8MoveDownEN3phi7integerIjEENS1_7booleanE:
  848|  1.32k|    {
  849|  1.32k|        if (amount == 0u)
  ------------------
  |  Branch (849:13): [True: 19, False: 1.30k]
  ------------------
  850|     19|        {
  851|     19|            return;
  852|     19|        }
  853|       |
  854|  1.30k|        const Coordinates old_pos  = m_State.m_CursorPosition;
  855|  1.30k|        const phi::u32    max_line = GetMaxLineNumber();
  856|       |
  857|  1.30k|        PHI_ASSERT(old_pos.m_Line <= max_line);
  858|       |
  859|       |        // Move cursor to the end of the line after we reached the bottom
  860|  1.30k|        if (amount > max_line - old_pos.m_Line)
  ------------------
  |  Branch (860:13): [True: 1.30k, False: 2]
  ------------------
  861|  1.30k|        {
  862|  1.30k|            m_State.m_CursorPosition.m_Line   = max_line;
  863|  1.30k|            m_State.m_CursorPosition.m_Column = GetLineMaxColumn(max_line);
  864|  1.30k|        }
  865|      2|        else
  866|      2|        {
  867|      2|            m_State.m_CursorPosition.m_Line += amount;
  868|      2|        }
  869|       |
  870|  1.30k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line <= max_line);
  871|       |
  872|  1.30k|        FixSelectionAfterMove(select, old_pos);
  873|  1.30k|    }
_ZN6dlxemu10CodeEditor8MoveLeftEN3phi7integerIjEENS1_7booleanES4_:
  876|  1.95k|    {
  877|  1.95k|        PHI_ASSERT(!m_Lines.empty());
  878|       |
  879|  1.95k|        if (amount == 0u)
  ------------------
  |  Branch (879:13): [True: 372, False: 1.57k]
  ------------------
  880|    372|        {
  881|    372|            return;
  882|    372|        }
  883|       |
  884|  1.57k|        const Coordinates old_pos = m_State.m_CursorPosition;
  885|  1.57k|        m_State.m_CursorPosition  = GetActualCursorCoordinates();
  886|  1.57k|        phi::u32 line             = m_State.m_CursorPosition.m_Line;
  887|  1.57k|        phi::u32 cindex           = GetCharacterIndex(m_State.m_CursorPosition);
  888|       |
  889|  5.46k|        while (amount > 0u)
  ------------------
  |  Branch (889:16): [True: 3.88k, False: 1.57k]
  ------------------
  890|  3.88k|        {
  891|  3.88k|            amount -= 1u;
  892|       |
  893|  3.88k|            if (cindex == 0u)
  ------------------
  |  Branch (893:17): [True: 2.18k, False: 1.69k]
  ------------------
  894|  2.18k|            {
  895|  2.18k|                if (line == 0u)
  ------------------
  |  Branch (895:21): [True: 1.57k, False: 612]
  ------------------
  896|  1.57k|                {
  897|       |                    // We're already on the last line so we can't move further left
  898|  1.57k|                    amount = 0u;
  899|  1.57k|                }
  900|    612|                else
  901|    612|                {
  902|    612|                    line -= 1u;
  903|    612|                    cindex = static_cast<phi::uint32_t>(m_Lines[line.unsafe()].size());
  904|    612|                }
  905|  2.18k|            }
  906|  1.69k|            else
  907|  1.69k|            {
  908|  1.69k|                --cindex;
  909|  1.69k|                if (cindex > 0u && m_Lines.size() > line)
  ------------------
  |  Branch (909:21): [True: 1.49k, False: 199]
  |  Branch (909:21): [True: 1.49k, False: 199]
  |  Branch (909:36): [True: 1.49k, False: 0]
  ------------------
  910|  1.49k|                {
  911|  2.80k|                    while (cindex > 0u &&
  ------------------
  |  Branch (911:28): [True: 2.52k, False: 287]
  |  Branch (911:28): [True: 1.31k, False: 1.49k]
  ------------------
  912|  2.80k|                           IsUTFSequence(m_Lines[line.unsafe()][cindex.unsafe()].m_Char))
  ------------------
  |  Branch (912:28): [True: 1.31k, False: 1.20k]
  ------------------
  913|  1.31k|                    {
  914|  1.31k|                        --cindex;
  915|  1.31k|                    }
  916|  1.49k|                }
  917|  1.69k|            }
  918|       |
  919|  3.88k|            m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  920|  3.88k|            if (word_mode)
  ------------------
  |  Branch (920:17): [True: 3.84k, False: 34]
  ------------------
  921|  3.84k|            {
  922|  3.84k|                m_State.m_CursorPosition = FindWordStart(m_State.m_CursorPosition);
  923|  3.84k|                cindex                   = GetCharacterIndex(m_State.m_CursorPosition);
  924|  3.84k|            }
  925|  3.88k|        }
  926|       |
  927|  1.57k|        m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  928|  1.57k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
  929|       |
  930|  1.57k|        FixSelectionAfterMove(select, old_pos);
  931|  1.57k|    }
_ZN6dlxemu10CodeEditor9MoveRightEN3phi7integerIjEENS1_7booleanES4_:
  935|    947|    {
  936|    947|        const Coordinates old_pos = m_State.m_CursorPosition;
  937|       |
  938|    947|        if (old_pos.m_Line >= m_Lines.size() || amount == 0u)
  ------------------
  |  Branch (938:13): [True: 0, False: 947]
  |  Branch (938:13): [True: 115, False: 832]
  |  Branch (938:49): [True: 115, False: 832]
  ------------------
  939|    115|        {
  940|    115|            return;
  941|    115|        }
  942|       |
  943|    832|        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
  944|  3.42k|        while (amount > 0u)
  ------------------
  |  Branch (944:16): [True: 3.41k, False: 8]
  ------------------
  945|  3.41k|        {
  946|  3.41k|            amount -= 1u;
  947|       |
  948|  3.41k|            const phi::u32 lindex = m_State.m_CursorPosition.m_Line;
  949|  3.41k|            PHI_ASSERT(lindex < m_Lines.size());
  950|  3.41k|            const Line& line = m_Lines[lindex.unsafe()];
  951|       |
  952|  3.41k|            if (cindex >= line.size())
  ------------------
  |  Branch (952:17): [True: 908, False: 2.50k]
  ------------------
  953|    908|            {
  954|    908|                if (m_State.m_CursorPosition.m_Line < GetMaxLineNumber())
  ------------------
  |  Branch (954:21): [True: 84, False: 824]
  ------------------
  955|     84|                {
  956|     84|                    m_State.m_CursorPosition.m_Line =
  957|     84|                            phi::clamp(m_State.m_CursorPosition.m_Line.unsafe() + 1u, 0u,
  958|     84|                                       GetMaxLineNumber().unsafe());
  959|     84|                    m_State.m_CursorPosition.m_Column = 0u;
  960|     84|                }
  961|    824|                else
  962|    824|                {
  963|    824|                    return;
  964|    824|                }
  965|    908|            }
  966|  2.50k|            else
  967|  2.50k|            {
  968|  2.50k|                PHI_ASSERT(cindex < line.size());
  969|  2.50k|                cindex += UTF8CharLength(line[cindex.unsafe()].m_Char);
  970|  2.50k|                m_State.m_CursorPosition = Coordinates(lindex, GetCharacterColumn(lindex, cindex));
  971|       |
  972|  2.50k|                if (word_mode)
  ------------------
  |  Branch (972:21): [True: 2.50k, False: 0]
  ------------------
  973|  2.50k|                {
  974|  2.50k|                    m_State.m_CursorPosition = FindNextWord(m_State.m_CursorPosition);
  975|  2.50k|                }
  976|  2.50k|            }
  977|  3.41k|        }
  978|       |
  979|      8|        FixSelectionAfterMove(select, old_pos);
  980|      8|    }
_ZN6dlxemu10CodeEditor7MoveTopEN3phi7booleanE:
  983|  1.09k|    {
  984|  1.09k|        const Coordinates old_pos = m_State.m_CursorPosition;
  985|  1.09k|        SetCursorPosition(Coordinates(0u, 0u));
  986|       |
  987|  1.09k|        if (select)
  ------------------
  |  Branch (987:13): [True: 1.09k, False: 0]
  ------------------
  988|  1.09k|        {
  989|  1.09k|            m_InteractiveEnd   = old_pos;
  990|  1.09k|            m_InteractiveStart = m_State.m_CursorPosition;
  991|  1.09k|        }
  992|      0|        else
  993|      0|        {
  994|      0|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
  995|      0|        }
  996|       |
  997|  1.09k|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
  998|  1.09k|        EnsureCursorVisible();
  999|  1.09k|    }
_ZN6dlxemu10CodeEditor10MoveBottomEN3phi7booleanE:
 1002|     48|    {
 1003|     48|        const Coordinates old_pos = GetCursorPosition();
 1004|       |
 1005|     48|        const phi::u32 end_line = GetMaxLineNumber();
 1006|     48|        Coordinates    new_pos  = Coordinates(end_line, GetLineMaxColumn(end_line));
 1007|       |
 1008|     48|        SetCursorPosition(new_pos);
 1009|     48|        if (select)
  ------------------
  |  Branch (1009:13): [True: 45, False: 3]
  ------------------
 1010|     45|        {
 1011|     45|            m_InteractiveStart = old_pos;
 1012|     45|            m_InteractiveEnd   = new_pos;
 1013|     45|        }
 1014|      3|        else
 1015|      3|        {
 1016|      3|            m_InteractiveStart = m_InteractiveEnd = new_pos;
 1017|      3|        }
 1018|       |
 1019|     48|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
 1020|     48|        EnsureCursorVisible();
 1021|     48|    }
_ZN6dlxemu10CodeEditor8MoveHomeEN3phi7booleanE:
 1024|    225|    {
 1025|    225|        const Coordinates old_pos = m_State.m_CursorPosition;
 1026|    225|        SetCursorPosition(Coordinates(m_State.m_CursorPosition.m_Line, 0u));
 1027|       |
 1028|    225|        FixSelectionAfterMove(select, old_pos);
 1029|    225|    }
_ZN6dlxemu10CodeEditor7MoveEndEN3phi7booleanE:
 1032|    351|    {
 1033|    351|        Coordinates old_pos = m_State.m_CursorPosition;
 1034|    351|        SetCursorPosition(
 1035|    351|                Coordinates(m_State.m_CursorPosition.m_Line, GetLineMaxColumn(old_pos.m_Line)));
 1036|       |
 1037|    351|        FixSelectionAfterMove(select, old_pos);
 1038|    351|    }
_ZN6dlxemu10CodeEditor17SetSelectionStartERKNS0_11CoordinatesE:
 1041|     43|    {
 1042|     43|        m_State.m_SelectionStart = SanitizeCoordinates(position);
 1043|     43|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1043:13): [True: 14, False: 29]
  ------------------
 1044|     14|        {
 1045|     14|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1046|     14|        }
 1047|     43|    }
_ZN6dlxemu10CodeEditor15SetSelectionEndERKNS0_11CoordinatesE:
 1050|  2.12k|    {
 1051|  2.12k|        m_State.m_SelectionEnd = SanitizeCoordinates(position);
 1052|  2.12k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1052:13): [True: 2, False: 2.12k]
  ------------------
 1053|      2|        {
 1054|      2|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1055|      2|        }
 1056|  2.12k|    }
_ZN6dlxemu10CodeEditor12SetSelectionERKNS0_11CoordinatesES3_NS0_13SelectionModeE:
 1062|  21.7k|    {
 1063|  21.7k|        Coordinates old_sel_start = m_State.m_SelectionStart;
 1064|  21.7k|        Coordinates old_sel_end   = m_State.m_SelectionEnd;
 1065|       |
 1066|  21.7k|        m_State.m_SelectionStart = SanitizeCoordinates(start);
 1067|  21.7k|        m_State.m_SelectionEnd   = SanitizeCoordinates(end);
 1068|  21.7k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1068:13): [True: 507, False: 21.2k]
  ------------------
 1069|    507|        {
 1070|    507|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1071|    507|        }
 1072|       |
 1073|  21.7k|        switch (mode)
 1074|  21.7k|        {
 1075|  20.9k|            case CodeEditor::SelectionMode::Normal:
  ------------------
  |  Branch (1075:13): [True: 20.9k, False: 779]
  ------------------
 1076|  20.9k|                break;
 1077|    620|            case CodeEditor::SelectionMode::Word: {
  ------------------
  |  Branch (1077:13): [True: 620, False: 21.1k]
  ------------------
 1078|    620|                m_State.m_SelectionStart = FindWordStart(m_State.m_SelectionStart);
 1079|    620|                if (!IsOnWordBoundary(m_State.m_SelectionEnd))
  ------------------
  |  Branch (1079:21): [True: 0, False: 620]
  ------------------
 1080|      0|                {
 1081|      0|                    m_State.m_SelectionEnd = FindWordEnd(FindWordStart(m_State.m_SelectionEnd));
 1082|      0|                }
 1083|    620|                break;
 1084|      0|            }
 1085|    159|            case CodeEditor::SelectionMode::Line: {
  ------------------
  |  Branch (1085:13): [True: 159, False: 21.5k]
  ------------------
 1086|    159|                const phi::u32 line_no   = m_State.m_SelectionEnd.m_Line;
 1087|    159|                m_State.m_SelectionStart = Coordinates(m_State.m_SelectionStart.m_Line, 0u);
 1088|    159|                m_State.m_SelectionEnd   = Coordinates(line_no, GetLineMaxColumn(line_no));
 1089|    159|                break;
 1090|      0|            }
 1091|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
 1092|      0|            default:
  ------------------
  |  Branch (1092:13): [True: 0, False: 21.7k]
  ------------------
 1093|      0|                PHI_ASSERT_NOT_REACHED();
 1094|  21.7k|#endif
 1095|  21.7k|        }
 1096|       |
 1097|  21.7k|        if (m_State.m_SelectionStart != old_sel_start || m_State.m_SelectionEnd != old_sel_end)
  ------------------
  |  Branch (1097:13): [True: 4.46k, False: 17.2k]
  |  Branch (1097:13): [True: 7.43k, False: 14.2k]
  |  Branch (1097:58): [True: 2.97k, False: 14.2k]
  ------------------
 1098|  7.43k|        {
 1099|  7.43k|            m_CursorPositionChanged = true;
 1100|  7.43k|        }
 1101|  21.7k|    }
_ZN6dlxemu10CodeEditor21SelectWordUnderCursorEv:
 1106|    495|    {
 1107|    495|        Coordinates coords = GetCursorPosition();
 1108|    495|        SetSelection(FindWordStart(coords), FindWordEnd(coords));
 1109|    495|    }
_ZN6dlxemu10CodeEditor9SelectAllEv:
 1112|    404|    {
 1113|    404|        SetSelection(Coordinates(0u, 0u),
 1114|    404|                     Coordinates(static_cast<phi::uint32_t>(m_Lines.size()), 0u));
 1115|    404|    }
_ZN6dlxemu10CodeEditor14ClearSelectionEv:
 1118|  9.19k|    {
 1119|  9.19k|        SetSelection(Coordinates(0u, 0u), Coordinates(0u, 0u));
 1120|  9.19k|    }
_ZNK6dlxemu10CodeEditor12HasSelectionEv:
 1123|  62.4k|    {
 1124|  62.4k|        return m_State.m_SelectionEnd > m_State.m_SelectionStart;
 1125|  62.4k|    }
_ZNK6dlxemu10CodeEditor17GetSelectionStartEv:
 1128|  83.6k|    {
 1129|  83.6k|        return m_State.m_SelectionStart;
 1130|  83.6k|    }
_ZNK6dlxemu10CodeEditor15GetSelectionEndEv:
 1133|  83.6k|    {
 1134|  83.6k|        return m_State.m_SelectionEnd;
 1135|  83.6k|    }
_ZN6dlxemu10CodeEditor6DeleteEv:
 1220|    317|    {
 1221|    317|        PHI_ASSERT(!m_Lines.empty());
 1222|       |
 1223|    317|        if (m_ReadOnly)
  ------------------
  |  Branch (1223:13): [True: 18, False: 299]
  ------------------
 1224|     18|        {
 1225|     18|            return;
 1226|     18|        }
 1227|       |
 1228|    299|        UndoRecord undo;
 1229|    299|        undo.StoreBeforeState(this);
 1230|       |
 1231|    299|        if (HasSelection())
  ------------------
  |  Branch (1231:13): [True: 8, False: 291]
  ------------------
 1232|      8|        {
 1233|      8|            undo.m_Removed      = GetSelectedText();
 1234|      8|            undo.m_RemovedStart = m_State.m_SelectionStart;
 1235|      8|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1236|       |
 1237|      8|            DeleteSelection();
 1238|      8|        }
 1239|    291|        else
 1240|    291|        {
 1241|    291|            Coordinates pos = GetActualCursorCoordinates();
 1242|    291|            SetCursorPosition(pos);
 1243|    291|            PHI_ASSERT(pos.m_Line < m_Lines.size());
 1244|    291|            Line& line = m_Lines[pos.m_Line.unsafe()];
 1245|       |
 1246|    291|            if (pos.m_Column == GetLineMaxColumn(pos.m_Line))
  ------------------
  |  Branch (1246:17): [True: 27, False: 264]
  ------------------
 1247|     27|            {
 1248|     27|                if (pos.m_Line == GetMaxLineNumber())
  ------------------
  |  Branch (1248:21): [True: 14, False: 13]
  ------------------
 1249|     14|                {
 1250|     14|                    return;
 1251|     14|                }
 1252|       |
 1253|     13|                undo.m_Removed      = '\n';
 1254|     13|                undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 1255|     13|                Advance(undo.m_RemovedEnd);
 1256|       |
 1257|     13|                PHI_ASSERT(pos.m_Line + 1u < m_Lines.size());
 1258|     13|                Line& next_line = m_Lines[pos.m_Line.unsafe() + 1];
 1259|     13|                line.insert(line.end(), next_line.begin(), next_line.end());
 1260|       |
 1261|     13|                PHI_ASSERT(pos.m_Line <= m_Lines.size());
 1262|     13|                RemoveLine(pos.m_Line + 1u);
 1263|     13|            }
 1264|    264|            else
 1265|    264|            {
 1266|       |                // Nothing todo when line is empty
 1267|    264|                if (line.empty())
  ------------------
  |  Branch (1267:21): [True: 0, False: 264]
  ------------------
 1268|      0|                {
 1269|      0|                    return;
 1270|      0|                }
 1271|       |
 1272|    264|                const phi::u32 cindex = GetCharacterIndex(pos);
 1273|    264|                PHI_ASSERT(cindex < line.size());
 1274|       |
 1275|    264|                const Coordinates current_cursor_pos = GetActualCursorCoordinates();
 1276|    264|                undo.m_RemovedStart                  = current_cursor_pos;
 1277|    264|                undo.m_RemovedEnd                    = current_cursor_pos;
 1278|    264|                undo.m_RemovedEnd.m_Column++;
 1279|    264|                undo.m_Removed = GetText(undo.m_RemovedStart, undo.m_RemovedEnd);
 1280|       |
 1281|    264|                phi::u8_fast length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1282|    715|                while (length > 0u && cindex < line.size())
  ------------------
  |  Branch (1282:24): [True: 451, False: 264]
  |  Branch (1282:24): [True: 451, False: 264]
  |  Branch (1282:39): [True: 451, False: 0]
  ------------------
 1283|    451|                {
 1284|    451|                    line.erase(line.begin() + cindex.unsafe());
 1285|       |
 1286|       |                    // Correct selection state
 1287|    451|                    if (m_State.m_SelectionStart.m_Line == current_cursor_pos.m_Line &&
  ------------------
  |  Branch (1287:25): [True: 427, False: 24]
  |  Branch (1287:25): [True: 23, False: 428]
  ------------------
 1288|    451|                        m_State.m_SelectionStart.m_Column >= cindex &&
  ------------------
  |  Branch (1288:25): [True: 396, False: 31]
  ------------------
 1289|    451|                        m_State.m_SelectionStart.m_Column > 0u)
  ------------------
  |  Branch (1289:25): [True: 23, False: 373]
  ------------------
 1290|     23|                    {
 1291|     23|                        m_State.m_SelectionStart.m_Column -= 1u;
 1292|     23|                    }
 1293|    451|                    if (m_State.m_SelectionEnd.m_Line == current_cursor_pos.m_Line &&
  ------------------
  |  Branch (1293:25): [True: 427, False: 24]
  |  Branch (1293:25): [True: 23, False: 428]
  ------------------
 1294|    451|                        m_State.m_SelectionEnd.m_Column >= cindex &&
  ------------------
  |  Branch (1294:25): [True: 396, False: 31]
  ------------------
 1295|    451|                        m_State.m_SelectionEnd.m_Column > 0u)
  ------------------
  |  Branch (1295:25): [True: 23, False: 373]
  ------------------
 1296|     23|                    {
 1297|     23|                        m_State.m_SelectionEnd.m_Column -= 1u;
 1298|     23|                    }
 1299|       |
 1300|    451|                    length--;
 1301|    451|                }
 1302|    264|            }
 1303|       |
 1304|    277|            m_TextChanged = true;
 1305|       |
 1306|    277|            Colorize(pos.m_Line, 1);
 1307|    277|        }
 1308|       |
 1309|    285|        undo.StoreAfterState(this);
 1310|    285|        AddUndo(undo);
 1311|    285|    }
_ZNK6dlxemu10CodeEditor7CanUndoEv:
 1314|  9.00k|    {
 1315|  9.00k|        return !m_ReadOnly && m_UndoIndex != 0u;
  ------------------
  |  Branch (1315:16): [True: 8.83k, False: 161]
  |  Branch (1315:31): [True: 6.74k, False: 2.09k]
  ------------------
 1316|  9.00k|    }
_ZN6dlxemu10CodeEditor4UndoEN3phi7integerIjEE:
 1319|  5.47k|    {
 1320|  9.00k|        while (CanUndo() && steps > 0u)
  ------------------
  |  Branch (1320:16): [True: 6.74k, False: 2.25k]
  |  Branch (1320:16): [True: 3.52k, False: 5.47k]
  |  Branch (1320:29): [True: 3.52k, False: 3.22k]
  ------------------
 1321|  3.52k|        {
 1322|  3.52k|            m_UndoIndex -= 1u;
 1323|  3.52k|            m_UndoBuffer[m_UndoIndex.unsafe()].Undo(this);
 1324|  3.52k|            steps -= 1u;
 1325|  3.52k|        }
 1326|  5.47k|    }
_ZNK6dlxemu10CodeEditor7CanRedoEv:
 1329|     99|    {
 1330|     99|        return !m_ReadOnly && m_UndoIndex < m_UndoBuffer.size();
  ------------------
  |  Branch (1330:16): [True: 79, False: 20]
  |  Branch (1330:31): [True: 40, False: 39]
  ------------------
 1331|     99|    }
_ZN6dlxemu10CodeEditor4RedoEN3phi7integerIjEE:
 1334|     66|    {
 1335|     99|        while (CanRedo() && steps > 0u)
  ------------------
  |  Branch (1335:16): [True: 40, False: 59]
  |  Branch (1335:16): [True: 33, False: 66]
  |  Branch (1335:29): [True: 33, False: 7]
  ------------------
 1336|     33|        {
 1337|     33|            m_UndoBuffer[m_UndoIndex.unsafe()].Redo(this);
 1338|     33|            m_UndoIndex += 1u;
 1339|     33|            steps -= 1u;
 1340|     33|        }
 1341|     66|    }
_ZN6dlxemu10CodeEditor13UpdatePaletteEv:
 1492|  7.25k|    {
 1493|  7.25k|        PHI_ASSERT(GImGui && GImGui->Initialized);
 1494|       |
 1495|       |        // Update palette with the current alpha from style
 1496|   108k|        for (phi::usize i = 0u; i < phi::to_underlying(PaletteIndex::Max); ++i)
  ------------------
  |  Branch (1496:33): [True: 101k, False: 7.25k]
  ------------------
 1497|   101k|        {
 1498|   101k|            ImVec4 color = ImGui::ColorConvertU32ToFloat4(m_PaletteBase[i]);
 1499|   101k|            color.w *= ImGui::GetStyle().Alpha;
 1500|   101k|            m_Palette[i] = ImGui::ColorConvertFloat4ToU32(color);
 1501|   101k|        }
 1502|  7.25k|    }
_ZNK6dlxemu10CodeEditor19VerifyInternalStateEv:
 1505|  16.8k|    {
 1506|       |        // Lines should never be empty
 1507|  16.8k|        PHI_ASSERT(!m_Lines.empty());
 1508|       |
 1509|       |        // Verify Selection is still in a valid state
 1510|  16.8k|        PHI_ASSERT(m_State.m_SelectionEnd >= m_State.m_SelectionStart);
 1511|  16.8k|        PHI_ASSERT(m_State.m_SelectionStart.m_Line < m_Lines.size());
 1512|  16.8k|        PHI_ASSERT(m_State.m_SelectionStart.m_Column >= 0u);
 1513|  16.8k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Line < m_Lines.size());
 1514|  16.8k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Column >= 0u);
 1515|       |
 1516|       |        // Verify cursor position
 1517|  16.8k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line >= 0u);
 1518|  16.8k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 1519|  16.8k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
 1520|       |
 1521|       |        // This should also always be true. But its implementation is way to slow when fuzzing
 1522|       |#if defined(DLXEMU_VERIFY_COLUMN)
 1523|       |        PHI_ASSERT(m_State.m_SelectionStart.m_Column <=
 1524|       |                   GetLineMaxColumn(m_State.m_SelectionStart.m_Line));
 1525|       |        PHI_ASSERT(m_State.m_SelectionEnd.m_Column <=
 1526|       |                   GetLineMaxColumn(m_State.m_SelectionEnd.m_Line));
 1527|       |#endif
 1528|       |
 1529|       |        // Verify that all breakpoints are on existing lines
 1530|  16.8k|        for (phi::u32 break_point : m_Breakpoints)
  ------------------
  |  Branch (1530:35): [True: 85, False: 16.8k]
  ------------------
 1531|     85|        {
 1532|     85|            PHI_ASSERT(break_point != 0u);
 1533|     85|            PHI_ASSERT(break_point <= m_Lines.size());
 1534|     85|        }
 1535|       |
 1536|       |        // Verify that all error markers are on existing lines
 1537|  16.8k|        for (auto&& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (1537:34): [True: 1.99k, False: 16.8k]
  ------------------
 1538|  1.99k|        {
 1539|  1.99k|            const phi::u32 line_number = error_marker.first;
 1540|       |
 1541|  1.99k|            PHI_ASSERT(line_number != 0u);
 1542|  1.99k|            PHI_ASSERT(line_number <= m_Lines.size());
 1543|  1.99k|        }
 1544|  16.8k|    }
_ZN6dlxemu10CodeEditor14GetDarkPaletteEv:
 1547|  14.5k|    {
 1548|  14.5k|        constexpr const static Palette palette = {{
 1549|  14.5k|                0xff7f7f7f, // Default
 1550|  14.5k|                0xffd69c56, // OpCode
 1551|  14.5k|                0xff00ff00, // Register
 1552|  14.5k|                0xff7070e0, // IntegerLiteral
 1553|  14.5k|                0xff206020, // Comment
 1554|  14.5k|                0xff101010, // Background
 1555|  14.5k|                0xffe0e0e0, // Cursor
 1556|  14.5k|                0x80a06020, // Selection
 1557|  14.5k|                0x800020ff, // ErrorMarker
 1558|  14.5k|                0x40f08000, // Breakpoint
 1559|  14.5k|                0xff707000, // Line number
 1560|  14.5k|                0x40000000, // Current line fill
 1561|  14.5k|                0x40808080, // Current line fill (inactive)
 1562|  14.5k|                0x40a0a0a0, // Current line edge
 1563|  14.5k|        }};
 1564|       |
 1565|  14.5k|        return palette;
 1566|  14.5k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4UndoEPS0_:
 1629|  3.52k|    {
 1630|  3.52k|        PHI_ASSERT(editor != nullptr);
 1631|       |
 1632|  3.52k|        if (!m_Added.empty())
  ------------------
  |  Branch (1632:13): [True: 2.93k, False: 593]
  ------------------
 1633|  2.93k|        {
 1634|  2.93k|            editor->DeleteRange(m_AddedStart, m_AddedEnd);
 1635|  2.93k|            editor->Colorize(m_AddedStart.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1636|  2.93k|        }
 1637|       |
 1638|  3.52k|        if (!m_Removed.empty())
  ------------------
  |  Branch (1638:13): [True: 1.64k, False: 1.88k]
  ------------------
 1639|  1.64k|        {
 1640|  1.64k|            Coordinates start = m_RemovedStart;
 1641|  1.64k|            editor->InsertTextAt(start, m_Removed.c_str());
 1642|  1.64k|            editor->Colorize(start.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1643|  1.64k|        }
 1644|       |
 1645|  3.52k|        ApplyBeforeState(editor);
 1646|  3.52k|        editor->EnsureCursorVisible();
 1647|  3.52k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4RedoEPS0_:
 1650|     33|    {
 1651|     33|        PHI_ASSERT(editor != nullptr);
 1652|       |
 1653|     33|        if (!m_Removed.empty())
  ------------------
  |  Branch (1653:13): [True: 18, False: 15]
  ------------------
 1654|     18|        {
 1655|     18|            editor->DeleteRange(m_RemovedStart, m_RemovedEnd);
 1656|     18|            editor->Colorize(m_RemovedStart.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1657|     18|        }
 1658|       |
 1659|     33|        if (!m_Added.empty())
  ------------------
  |  Branch (1659:13): [True: 30, False: 3]
  ------------------
 1660|     30|        {
 1661|     30|            Coordinates start = m_AddedStart;
 1662|     30|            editor->InsertTextAt(start, m_Added.c_str());
 1663|     30|            editor->Colorize(start.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1664|     30|        }
 1665|       |
 1666|     33|        ApplyAfterState(editor);
 1667|     33|        editor->EnsureCursorVisible();
 1668|     33|    }
_ZN6dlxemu10CodeEditor10UndoRecord16StoreBeforeStateEPS0_:
 1671|  42.0k|    {
 1672|  42.0k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1673|  42.0k|        const Coordinates selection_start = editor->GetSelectionStart();
 1674|  42.0k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1675|       |
 1676|  42.0k|        m_Before.m_CursorPosition = {cursor_position.m_Line,
 1677|  42.0k|                                     editor->GetCharacterIndex(cursor_position)};
 1678|  42.0k|        m_Before.m_SelectionStart = {selection_start.m_Line,
 1679|  42.0k|                                     editor->GetCharacterIndex(selection_start)};
 1680|  42.0k|        m_Before.m_SelectionEnd = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1681|  42.0k|    }
_ZN6dlxemu10CodeEditor10UndoRecord15StoreAfterStateEPS0_:
 1684|  41.5k|    {
 1685|  41.5k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1686|  41.5k|        const Coordinates selection_start = editor->GetSelectionStart();
 1687|  41.5k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1688|       |
 1689|  41.5k|        m_After.m_CursorPosition = {cursor_position.m_Line,
 1690|  41.5k|                                    editor->GetCharacterIndex(cursor_position)};
 1691|  41.5k|        m_After.m_SelectionStart = {selection_start.m_Line,
 1692|  41.5k|                                    editor->GetCharacterIndex(selection_start)};
 1693|  41.5k|        m_After.m_SelectionEnd   = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1694|  41.5k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord16ApplyBeforeStateEPS0_:
 1697|  3.52k|    {
 1698|  3.52k|        Coordinates cursor_position = m_Before.m_CursorPosition;
 1699|  3.52k|        cursor_position.m_Column =
 1700|  3.52k|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1701|  3.52k|        Coordinates selection_start = m_Before.m_SelectionStart;
 1702|  3.52k|        selection_start.m_Column =
 1703|  3.52k|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1704|  3.52k|        Coordinates selection_end = m_Before.m_SelectionEnd;
 1705|  3.52k|        selection_end.m_Column =
 1706|  3.52k|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1707|       |
 1708|  3.52k|        editor->m_State.m_CursorPosition = cursor_position;
 1709|  3.52k|        editor->m_State.m_SelectionStart = selection_start;
 1710|  3.52k|        editor->m_State.m_SelectionEnd   = selection_end;
 1711|  3.52k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord15ApplyAfterStateEPS0_:
 1714|     33|    {
 1715|     33|        Coordinates cursor_position = m_After.m_CursorPosition;
 1716|     33|        cursor_position.m_Column =
 1717|     33|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1718|     33|        Coordinates selection_start = m_After.m_SelectionStart;
 1719|     33|        selection_start.m_Column =
 1720|     33|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1721|     33|        Coordinates selection_end = m_After.m_SelectionEnd;
 1722|     33|        selection_end.m_Column =
 1723|     33|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1724|       |
 1725|     33|        editor->m_State.m_CursorPosition = cursor_position;
 1726|     33|        editor->m_State.m_SelectionStart = selection_start;
 1727|     33|        editor->m_State.m_SelectionEnd   = selection_end;
 1728|     33|    }
_ZN6dlxemu10CodeEditor8ColorizeEN3phi7integerIjEENS2_IlEE:
 1733|  63.1k|    {
 1734|       |        // TODO: This is quite unreadable
 1735|  63.1k|        const phi::u32 to_line =
 1736|  63.1k|                count == -1 ? static_cast<phi::uint32_t>(m_Lines.size()) :
  ------------------
  |  Branch (1736:17): [True: 14.6k, False: 48.5k]
  ------------------
 1737|  63.1k|                              phi::min(static_cast<phi::uint32_t>(m_Lines.size()),
 1738|  48.5k|                                       from_line + static_cast<phi::uint32_t>(count.unsafe()));
 1739|       |
 1740|  63.1k|        m_ColorRangeMin = phi::min(m_ColorRangeMin, from_line);
 1741|  63.1k|        m_ColorRangeMax = phi::max(m_ColorRangeMax, to_line);
 1742|  63.1k|        m_ColorRangeMin = phi::max(0u, m_ColorRangeMin);
 1743|  63.1k|        m_ColorRangeMax = phi::max(m_ColorRangeMin, m_ColorRangeMax);
 1744|  63.1k|    }
_ZNK6dlxemu10CodeEditor23TextDistanceToLineStartERKNS0_11CoordinatesE:
 1747|  18.2k|    {
 1748|  18.2k|        PHI_ASSERT(from.m_Line < m_Lines.size());
 1749|       |
 1750|  18.2k|        const Line& line     = m_Lines[from.m_Line.unsafe()];
 1751|  18.2k|        float       distance = 0.0f;
 1752|  18.2k|        float       space_size =
 1753|  18.2k|                ImGui::GetFont()
 1754|  18.2k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 1755|  18.2k|                        .x;
 1756|  18.2k|        const phi::u32 col_index = GetCharacterIndex(from);
 1757|  41.7k|        for (phi::usize it{0u}; it < line.size() && it < col_index;)
  ------------------
  |  Branch (1757:33): [True: 23.8k, False: 17.9k]
  |  Branch (1757:33): [True: 23.5k, False: 18.2k]
  |  Branch (1757:53): [True: 23.5k, False: 355]
  ------------------
 1758|  23.5k|        {
 1759|  23.5k|            if (line[it.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (1759:17): [True: 2.45k, False: 21.0k]
  ------------------
 1760|  2.45k|            {
 1761|  2.45k|                distance = (1.0f + std::floor((1.0f + distance) /
 1762|  2.45k|                                              (float(m_TabSize.unsafe()) * space_size))) *
 1763|  2.45k|                           (float(m_TabSize.unsafe()) * space_size);
 1764|  2.45k|                ++it;
 1765|  2.45k|            }
 1766|  21.0k|            else
 1767|  21.0k|            {
 1768|  21.0k|                phi::u8_fast        length = UTF8CharLength(line[it.unsafe()].m_Char);
 1769|  21.0k|                phi::array<char, 7> temp_c_string;
 1770|  21.0k|                phi::usize          index = 0u;
 1771|  62.1k|                for (; index < 6u && length > 0u && it < line.size(); ++index, ++it, --length)
  ------------------
  |  Branch (1771:24): [True: 62.1k, False: 0]
  |  Branch (1771:24): [True: 41.0k, False: 21.0k]
  |  Branch (1771:38): [True: 41.0k, False: 21.0k]
  |  Branch (1771:53): [True: 41.0k, False: 0]
  ------------------
 1772|  41.0k|                {
 1773|  41.0k|                    temp_c_string[index] = static_cast<char>(line[it.unsafe()].m_Char);
 1774|  41.0k|                }
 1775|       |
 1776|  21.0k|                temp_c_string[index] = '\0';
 1777|  21.0k|                distance += ImGui::GetFont()
 1778|  21.0k|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 1779|  21.0k|                                                    temp_c_string.data(), nullptr, nullptr)
 1780|  21.0k|                                    .x;
 1781|  21.0k|            }
 1782|  23.5k|        }
 1783|       |
 1784|  18.2k|        return distance;
 1785|  18.2k|    }
_ZN6dlxemu10CodeEditor19EnsureCursorVisibleEv:
 1788|  53.8k|    {
 1789|  53.8k|        m_ScrollToCursor = true;
 1790|  53.8k|    }
_ZN6dlxemu10CodeEditor14ScrollToCursorEv:
 1793|  3.03k|    {
 1794|  3.03k|        PHI_ASSERT(m_ScrollToCursor);
 1795|       |
 1796|  3.03k|        float scroll_x = ImGui::GetScrollX();
 1797|  3.03k|        float scroll_y = ImGui::GetScrollY();
 1798|       |
 1799|  3.03k|        float height = ImGui::GetWindowHeight();
 1800|  3.03k|        float width  = ImGui::GetWindowWidth();
 1801|       |
 1802|  3.03k|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 1803|  3.03k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 1804|  3.03k|        phi::u32 top = 1u + static_cast<phi::uint32_t>(std::ceil(scroll_y / m_CharAdvance.y));
 1805|  3.03k|        phi::u32 bottom =
 1806|  3.03k|                static_cast<phi::uint32_t>(std::ceil((scroll_y + height) / m_CharAdvance.y));
 1807|       |
 1808|  3.03k|        phi::u32 left = static_cast<phi::uint32_t>(std::ceil(scroll_x / m_CharAdvance.x));
 1809|  3.03k|        phi::u32 right =
 1810|  3.03k|                static_cast<phi::uint32_t>(std::ceil((scroll_x + width) / m_CharAdvance.x));
 1811|       |
 1812|  3.03k|        Coordinates pos = GetActualCursorCoordinates();
 1813|  3.03k|        float       len = TextDistanceToLineStart(pos);
 1814|       |
 1815|       |        // TODO: The 4 here seems like it could very well be a constant
 1816|       |
 1817|  3.03k|        if (pos.m_Line < top)
  ------------------
  |  Branch (1817:13): [True: 2.25k, False: 779]
  ------------------
 1818|  2.25k|        {
 1819|  2.25k|            ImGui::SetScrollY(phi::max(0.0f, static_cast<float>(pos.m_Line.unsafe()) - 1.0f) *
 1820|  2.25k|                              m_CharAdvance.y);
 1821|  2.25k|        }
 1822|  3.03k|        if (pos.m_Line > bottom.unsafe() - 4u)
  ------------------
  |  Branch (1822:13): [True: 26, False: 3.01k]
  ------------------
 1823|     26|        {
 1824|     26|            ImGui::SetScrollY(phi::max(
 1825|     26|                    0.0f,
 1826|     26|                    static_cast<float>((pos.m_Line + 4u).unsafe()) * m_CharAdvance.y - height));
 1827|     26|        }
 1828|  3.03k|        if (len + m_TextStart < static_cast<float>((left + 4u).unsafe()))
  ------------------
  |  Branch (1828:13): [True: 0, False: 3.03k]
  ------------------
 1829|      0|        {
 1830|      0|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart - 4.0f));
 1831|      0|        }
 1832|  3.03k|        if (len + m_TextStart > static_cast<float>(right.unsafe()) - 4.0f)
  ------------------
  |  Branch (1832:13): [True: 2.07k, False: 964]
  ------------------
 1833|  2.07k|        {
 1834|  2.07k|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart + 4.0f - width));
 1835|  2.07k|        }
 1836|  3.03k|    }
_ZNK6dlxemu10CodeEditor11GetPageSizeEv:
 1839|      6|    {
 1840|      6|        const float height = ImGui::GetWindowHeight() - 20.0f;
 1841|       |
 1842|      6|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 1843|      6|        const float page_size = std::floor(height / m_CharAdvance.y);
 1844|       |
 1845|      6|        return static_cast<phi::uint32_t>(phi::max(page_size, 5.0f));
 1846|      6|    }
_ZNK6dlxemu10CodeEditor7GetTextERKNS0_11CoordinatesES3_:
 1850|  7.20k|    {
 1851|  7.20k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1852|  7.20k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1853|  7.20k|        PHI_ASSERT(start <= end);
 1854|       |
 1855|  7.20k|        std::string result;
 1856|       |
 1857|  7.20k|        phi::u32   lstart = start.m_Line;
 1858|  7.20k|        phi::u32   lend   = end.m_Line;
 1859|  7.20k|        phi::u32   istart = GetCharacterIndex(start);
 1860|  7.20k|        phi::u32   iend   = phi::min(GetCharacterIndex(end),
 1861|  7.20k|                                     static_cast<phi::uint32_t>(m_Lines[end.m_Line.unsafe()].size()));
 1862|  7.20k|        phi::usize size   = 0u;
 1863|       |
 1864|  23.6k|        for (phi::u32 i = lstart; i <= lend; ++i)
  ------------------
  |  Branch (1864:35): [True: 16.4k, False: 7.20k]
  ------------------
 1865|  16.4k|        {
 1866|  16.4k|            PHI_ASSERT(i < m_Lines.size());
 1867|  16.4k|            size += m_Lines[i.unsafe()].size();
 1868|  16.4k|        }
 1869|       |
 1870|  7.20k|        result.reserve((size + size / 8u).unsafe());
 1871|       |
 1872|  68.9k|        while (istart < iend || lstart < lend)
  ------------------
  |  Branch (1872:16): [True: 37.3k, False: 31.5k]
  |  Branch (1872:16): [True: 61.7k, False: 7.20k]
  |  Branch (1872:33): [True: 24.3k, False: 7.20k]
  ------------------
 1873|  61.7k|        {
 1874|  61.7k|            PHI_ASSERT(lstart < m_Lines.size());
 1875|       |
 1876|  61.7k|            const Line& line = m_Lines[lstart.unsafe()];
 1877|  61.7k|            if (istart < line.size())
  ------------------
  |  Branch (1877:17): [True: 52.4k, False: 9.24k]
  ------------------
 1878|  52.4k|            {
 1879|  52.4k|                result += static_cast<char>(line[istart.unsafe()].m_Char);
 1880|  52.4k|                istart++;
 1881|  52.4k|            }
 1882|  9.24k|            else
 1883|  9.24k|            {
 1884|  9.24k|                istart = 0u;
 1885|  9.24k|                ++lstart;
 1886|       |
 1887|  9.24k|                if (lstart != m_Lines.size())
  ------------------
  |  Branch (1887:21): [True: 9.24k, False: 0]
  ------------------
 1888|  9.24k|                {
 1889|  9.24k|                    result += '\n';
 1890|  9.24k|                }
 1891|  9.24k|            }
 1892|  61.7k|        }
 1893|       |
 1894|  7.20k|        return result;
 1895|  7.20k|    }
_ZNK6dlxemu10CodeEditor26GetActualCursorCoordinatesEv:
 1899|   176k|    {
 1900|   176k|        return SanitizeCoordinates(m_State.m_CursorPosition);
 1901|   176k|    }
_ZNK6dlxemu10CodeEditor19SanitizeCoordinatesERKNS0_11CoordinatesE:
 1905|   272k|    {
 1906|   272k|        phi::u32 line   = value.m_Line;
 1907|   272k|        phi::u32 column = value.m_Column;
 1908|       |
 1909|   272k|        if (line >= m_Lines.size())
  ------------------
  |  Branch (1909:13): [True: 9.18k, False: 263k]
  ------------------
 1910|  9.18k|        {
 1911|  9.18k|            PHI_ASSERT(!m_Lines.empty());
 1912|       |
 1913|  9.18k|            line   = GetMaxLineNumber();
 1914|  9.18k|            column = GetLineMaxColumn(line);
 1915|       |
 1916|  9.18k|            return {line, column};
 1917|  9.18k|        }
 1918|       |
 1919|   263k|        PHI_ASSERT(!m_Lines.empty());
 1920|   263k|        PHI_ASSERT(line < m_Lines.size());
 1921|       |
 1922|       |        // Sanitize column
 1923|   263k|        const Line& current_line = m_Lines[line.unsafe()];
 1924|   263k|        phi::u32    new_column   = 0u;
 1925|  1.28M|        for (phi::u32 char_index{0u}; char_index < current_line.size();)
  ------------------
  |  Branch (1925:39): [True: 1.06M, False: 220k]
  ------------------
 1926|  1.06M|        {
 1927|  1.06M|            if (new_column >= column)
  ------------------
  |  Branch (1927:17): [True: 42.6k, False: 1.02M]
  ------------------
 1928|  42.6k|            {
 1929|  42.6k|                break;
 1930|  42.6k|            }
 1931|       |
 1932|  1.02M|            const char current_char = static_cast<char>(current_line[char_index.unsafe()].m_Char);
 1933|  1.02M|            if (current_char == '\t')
  ------------------
  |  Branch (1933:17): [True: 110k, False: 911k]
  ------------------
 1934|   110k|            {
 1935|   110k|                new_column += GetTabSizeAt(new_column);
 1936|   110k|            }
 1937|   911k|            else
 1938|   911k|            {
 1939|   911k|                ++new_column;
 1940|   911k|            }
 1941|       |
 1942|  1.02M|            char_index += UTF8CharLength(current_char);
 1943|  1.02M|        }
 1944|   263k|        PHI_ASSERT(new_column <= GetLineMaxColumn(line));
 1945|       |
 1946|   263k|        column = new_column;
 1947|       |
 1948|   263k|        return {line, column};
 1949|   272k|    }
_ZNK6dlxemu10CodeEditor7AdvanceERNS0_11CoordinatesE:
 1952|    199|    {
 1953|    199|        if (coordinates.m_Line >= m_Lines.size())
  ------------------
  |  Branch (1953:13): [True: 0, False: 199]
  ------------------
 1954|      0|        {
 1955|      0|            return;
 1956|      0|        }
 1957|       |
 1958|    199|        const Line& line   = m_Lines[coordinates.m_Line.unsafe()];
 1959|    199|        phi::u32    cindex = GetCharacterIndex(coordinates);
 1960|       |
 1961|    199|        if (cindex + 1u < line.size())
  ------------------
  |  Branch (1961:13): [True: 0, False: 199]
  ------------------
 1962|      0|        {
 1963|      0|            PHI_ASSERT(cindex < line.size());
 1964|      0|            phi::u8_fast delta = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1965|      0|            cindex = phi::min(cindex + delta, static_cast<phi::uint32_t>(line.size() - 1u));
 1966|      0|        }
 1967|    199|        else
 1968|    199|        {
 1969|    199|            ++coordinates.m_Line;
 1970|    199|            cindex = 0u;
 1971|    199|        }
 1972|    199|        coordinates.m_Column = GetCharacterColumn(coordinates.m_Line, cindex);
 1973|    199|    }
_ZN6dlxemu10CodeEditor11DeleteRangeERKNS0_11CoordinatesES3_:
 1976|  5.87k|    {
 1977|  5.87k|        PHI_ASSERT(end > start);
 1978|  5.87k|        PHI_ASSERT(!m_ReadOnly);
 1979|  5.87k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1980|  5.87k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1981|       |
 1982|  5.87k|        const phi::u32 start_index = GetCharacterIndex(start);
 1983|  5.87k|        const phi::u32 end_index   = GetCharacterIndex(end);
 1984|       |
 1985|  5.87k|        if (start.m_Line == end.m_Line)
  ------------------
  |  Branch (1985:13): [True: 2.89k, False: 2.98k]
  ------------------
 1986|  2.89k|        {
 1987|  2.89k|            Line&          line       = m_Lines[start.m_Line.unsafe()];
 1988|  2.89k|            const phi::u32 max_column = GetLineMaxColumn(start.m_Line);
 1989|       |
 1990|  2.89k|            if (end.m_Column >= max_column)
  ------------------
  |  Branch (1990:17): [True: 2.71k, False: 179]
  ------------------
 1991|  2.71k|            {
 1992|  2.71k|                line.erase(line.begin() + start_index.unsafe(), line.end());
 1993|       |
 1994|       |                // Fix selection
 1995|  2.71k|                if (m_State.m_SelectionStart.m_Column > start_index)
  ------------------
  |  Branch (1995:21): [True: 589, False: 2.12k]
  ------------------
 1996|    589|                {
 1997|    589|                    m_State.m_SelectionStart.m_Column = start_index;
 1998|    589|                }
 1999|  2.71k|                if (m_State.m_SelectionEnd.m_Column > start_index)
  ------------------
  |  Branch (1999:21): [True: 1.33k, False: 1.38k]
  ------------------
 2000|  1.33k|                {
 2001|  1.33k|                    m_State.m_SelectionEnd.m_Column = start_index;
 2002|  1.33k|                }
 2003|  2.71k|            }
 2004|    179|            else
 2005|    179|            {
 2006|    179|                const phi::u32 start_column = GetCharacterColumn(start.m_Line, start_index);
 2007|    179|                const phi::u32 end_column   = GetCharacterColumn(end.m_Line, end_index);
 2008|       |
 2009|    179|                line.erase(line.begin() + start_index.unsafe(), line.begin() + end_index.unsafe());
 2010|       |
 2011|       |                // Fix selection
 2012|    179|                if (m_State.m_SelectionStart.m_Column > start_column)
  ------------------
  |  Branch (2012:21): [True: 20, False: 159]
  ------------------
 2013|     20|                {
 2014|     20|                    if (m_State.m_SelectionStart.m_Column <= end_column)
  ------------------
  |  Branch (2014:25): [True: 11, False: 9]
  ------------------
 2015|     11|                    {
 2016|     11|                        m_State.m_SelectionStart.m_Column = start_column;
 2017|     11|                    }
 2018|      9|                    else
 2019|      9|                    {
 2020|      9|                        m_State.m_SelectionStart.m_Column -= (end_column - start_column);
 2021|      9|                    }
 2022|     20|                }
 2023|    179|                if (m_State.m_SelectionEnd.m_Column > start_column)
  ------------------
  |  Branch (2023:21): [True: 109, False: 70]
  ------------------
 2024|    109|                {
 2025|    109|                    if (m_State.m_SelectionEnd.m_Column <= end_column)
  ------------------
  |  Branch (2025:25): [True: 90, False: 19]
  ------------------
 2026|     90|                    {
 2027|     90|                        m_State.m_SelectionEnd.m_Column = start_column;
 2028|     90|                    }
 2029|     19|                    else
 2030|     19|                    {
 2031|     19|                        m_State.m_SelectionEnd.m_Column -= (end_column - start_column);
 2032|     19|                    }
 2033|    109|                }
 2034|    179|            }
 2035|  2.89k|        }
 2036|  2.98k|        else
 2037|  2.98k|        {
 2038|  2.98k|            Line& first_line = m_Lines[start.m_Line.unsafe()];
 2039|  2.98k|            Line& last_line  = m_Lines[end.m_Line.unsafe()];
 2040|       |
 2041|  2.98k|            first_line.erase(first_line.begin() + start_index.unsafe(), first_line.end());
 2042|  2.98k|            last_line.erase(last_line.begin(), last_line.begin() + end_index.unsafe());
 2043|       |
 2044|  2.98k|            if (start.m_Line < end.m_Line)
  ------------------
  |  Branch (2044:17): [True: 2.98k, False: 0]
  ------------------
 2045|  2.98k|            {
 2046|  2.98k|                first_line.insert(first_line.end(), last_line.begin(), last_line.end());
 2047|  2.98k|                RemoveLine(start.m_Line + 1u, end.m_Line + 1u);
 2048|  2.98k|            }
 2049|  2.98k|        }
 2050|       |
 2051|  5.87k|        m_TextChanged = true;
 2052|  5.87k|    }
_ZN6dlxemu10CodeEditor12InsertTextAtERNS0_11CoordinatesEPKc:
 2055|  1.67k|    {
 2056|  1.67k|        PHI_ASSERT(!m_ReadOnly);
 2057|  1.67k|        PHI_ASSERT(where.m_Line < m_Lines.size());
 2058|       |
 2059|  1.67k|        phi::u32 cindex      = GetCharacterIndex(where);
 2060|  1.67k|        phi::u32 total_lines = 0u;
 2061|  12.4k|        while (*value != '\0')
  ------------------
  |  Branch (2061:16): [True: 10.7k, False: 1.67k]
  ------------------
 2062|  10.7k|        {
 2063|  10.7k|            PHI_ASSERT(!m_Lines.empty());
 2064|       |
 2065|  10.7k|            if (*value == '\n')
  ------------------
  |  Branch (2065:17): [True: 2.87k, False: 7.90k]
  ------------------
 2066|  2.87k|            {
 2067|  2.87k|                if (cindex < m_Lines[where.m_Line.unsafe()].size())
  ------------------
  |  Branch (2067:21): [True: 48, False: 2.83k]
  ------------------
 2068|     48|                {
 2069|     48|                    Line& new_line = InsertLine(where.m_Line + 1u);
 2070|     48|                    Line& line     = m_Lines[where.m_Line.unsafe()];
 2071|     48|                    new_line.insert(new_line.begin(), line.begin() + cindex.unsafe(), line.end());
 2072|     48|                    line.erase(line.begin() + cindex.unsafe(), line.end());
 2073|     48|                }
 2074|  2.83k|                else
 2075|  2.83k|                {
 2076|  2.83k|                    InsertLine(where.m_Line + 1u);
 2077|  2.83k|                }
 2078|       |
 2079|  2.87k|                ++where.m_Line;
 2080|  2.87k|                where.m_Column = 0u;
 2081|  2.87k|                cindex         = 0u;
 2082|  2.87k|                ++total_lines;
 2083|  2.87k|                ++value;
 2084|  2.87k|            }
 2085|  7.90k|            else if (*value == '\t')
  ------------------
  |  Branch (2085:22): [True: 2.36k, False: 5.53k]
  ------------------
 2086|  2.36k|            {
 2087|  2.36k|                Line& line = m_Lines[where.m_Line.unsafe()];
 2088|       |
 2089|  2.36k|                line.insert(line.begin() + cindex.unsafe(),
 2090|  2.36k|                            Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2091|  2.36k|                cindex += 1u;
 2092|       |
 2093|  2.36k|                where.m_Column += GetTabSizeAt(where.m_Column);
 2094|  2.36k|            }
 2095|  5.53k|            else
 2096|  5.53k|            {
 2097|  5.53k|                Line& line = m_Lines[where.m_Line.unsafe()];
 2098|       |
 2099|  16.0k|                for (phi::u8_fast length = UTF8CharLength(*value); length > 0u && *value != '\0';
  ------------------
  |  Branch (2099:68): [True: 10.5k, False: 5.53k]
  |  Branch (2099:68): [True: 10.5k, False: 5.53k]
  |  Branch (2099:83): [True: 10.5k, False: 0]
  ------------------
 2100|  10.5k|                     ++cindex, --length)
 2101|  10.5k|                {
 2102|  10.5k|                    line.insert(line.begin() + cindex.unsafe(),
 2103|  10.5k|                                Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2104|  10.5k|                }
 2105|       |
 2106|  5.53k|                ++where.m_Column;
 2107|  5.53k|            }
 2108|       |
 2109|  10.7k|            m_TextChanged = true;
 2110|  10.7k|        }
 2111|       |
 2112|  1.67k|        return total_lines;
 2113|  1.67k|    }
_ZN6dlxemu10CodeEditor7AddUndoERNS0_10UndoRecordE:
 2116|  41.5k|    {
 2117|  41.5k|        PHI_ASSERT(!m_ReadOnly);
 2118|       |
 2119|       |#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2120|       |        VerifyInternalState();
 2121|       |        // Reject empty undos
 2122|       |        PHI_ASSERT(!(value.m_Added.empty() && value.m_Removed.empty()));
 2123|       |        // Start and end are valid
 2124|       |        PHI_ASSERT(value.m_AddedStart <= value.m_AddedEnd);
 2125|       |        PHI_ASSERT(value.m_RemovedStart <= value.m_RemovedEnd);
 2126|       |#endif
 2127|       |
 2128|  41.5k|        m_UndoBuffer.resize((m_UndoIndex + 1u).unsafe());
 2129|  41.5k|        m_UndoBuffer.back() = value;
 2130|  41.5k|        ++m_UndoIndex;
 2131|       |
 2132|       |#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2133|       |        VerifyInternalState();
 2134|       |
 2135|       |        PHI_ASSERT(CanUndo());
 2136|       |
 2137|       |        const std::string text_before          = GetText();
 2138|       |        EditorState       state_before         = m_State;
 2139|       |        state_before.m_CursorPosition.m_Column = GetCharacterIndex(state_before.m_CursorPosition);
 2140|       |        state_before.m_SelectionStart.m_Column = GetCharacterIndex(state_before.m_SelectionStart);
 2141|       |        state_before.m_SelectionEnd.m_Column   = GetCharacterIndex(state_before.m_SelectionEnd);
 2142|       |
 2143|       |        // Test the undo
 2144|       |        Undo();
 2145|       |        VerifyInternalState();
 2146|       |
 2147|       |        const std::string text_after_undo  = GetText();
 2148|       |        EditorState       state_after_undo = m_State;
 2149|       |        state_after_undo.m_CursorPosition.m_Column =
 2150|       |                GetCharacterIndex(state_after_undo.m_CursorPosition);
 2151|       |        state_after_undo.m_SelectionStart.m_Column =
 2152|       |                GetCharacterIndex(state_after_undo.m_SelectionStart);
 2153|       |        state_after_undo.m_SelectionEnd.m_Column =
 2154|       |                GetCharacterIndex(state_after_undo.m_SelectionEnd);
 2155|       |
 2156|       |        PHI_ASSERT(CanRedo());
 2157|       |
 2158|       |        // Test the redo
 2159|       |        Redo();
 2160|       |        VerifyInternalState();
 2161|       |
 2162|       |        const std::string text_after          = GetText();
 2163|       |        EditorState       state_after         = m_State;
 2164|       |        state_after.m_CursorPosition.m_Column = GetCharacterIndex(state_after.m_CursorPosition);
 2165|       |        state_after.m_SelectionStart.m_Column = GetCharacterIndex(state_after.m_SelectionStart);
 2166|       |        state_after.m_SelectionEnd.m_Column   = GetCharacterIndex(state_after.m_SelectionEnd);
 2167|       |
 2168|       |        PHI_ASSERT(text_before == text_after);
 2169|       |        PHI_ASSERT(state_before == state_after);
 2170|       |#endif
 2171|  41.5k|    }
_ZNK6dlxemu10CodeEditor22ScreenPosToCoordinatesERK6ImVec2:
 2175|  2.12k|    {
 2176|  2.12k|        const ImVec2 origin = ImGui::GetCursorScreenPos();
 2177|  2.12k|        const ImVec2 local(position.x - origin.x, position.y - origin.y);
 2178|       |
 2179|  2.12k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 2180|  2.12k|        const phi::u32 line_no =
 2181|  2.12k|                phi::max(0u, static_cast<phi::int32_t>(std::floor(local.y / m_CharAdvance.y)));
 2182|       |
 2183|  2.12k|        phi::u32 column_coord = 0u;
 2184|       |
 2185|  2.12k|        if (line_no >= 0u && line_no < m_Lines.size())
  ------------------
  |  Branch (2185:13): [True: 2.12k, False: 0]
  |  Branch (2185:13): [True: 278, False: 1.84k]
  |  Branch (2185:30): [True: 278, False: 1.84k]
  ------------------
 2186|    278|        {
 2187|    278|            const Line& line = m_Lines[line_no.unsafe()];
 2188|       |
 2189|    278|            phi::u32 column_index = 0u;
 2190|    278|            float    column_x     = 0.0f;
 2191|       |
 2192|    352|            while (column_index < line.size())
  ------------------
  |  Branch (2192:20): [True: 111, False: 241]
  ------------------
 2193|    111|            {
 2194|    111|                float column_width = 0.0f;
 2195|       |
 2196|    111|                if (line[column_index.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2196:21): [True: 3, False: 108]
  ------------------
 2197|      3|                {
 2198|      3|                    float space_size =
 2199|      3|                            ImGui::GetFont()
 2200|      3|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ")
 2201|      3|                                    .x;
 2202|      3|                    float old_x = column_x;
 2203|      3|                    float new_column_x =
 2204|      3|                            (1.0f + std::floor((1.0f + column_x) /
 2205|      3|                                               (float(m_TabSize.unsafe()) * space_size))) *
 2206|      3|                            (float(m_TabSize.unsafe()) * space_size);
 2207|      3|                    column_width = new_column_x - old_x;
 2208|       |
 2209|      3|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2209:25): [True: 1, False: 2]
  ------------------
 2210|      1|                    {
 2211|      1|                        break;
 2212|      1|                    }
 2213|       |
 2214|      2|                    column_x = new_column_x;
 2215|      2|                    column_coord =
 2216|      2|                            (column_coord.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2217|      2|                            m_TabSize.unsafe();
 2218|      2|                    column_index += 1u;
 2219|      2|                }
 2220|    108|                else
 2221|    108|                {
 2222|    108|                    phi::array<char, 7u> buffer;
 2223|    108|                    phi::usize           index = 0u;
 2224|       |
 2225|    108|                    for (phi::u8_fast length = UTF8CharLength(line[column_index.unsafe()].m_Char);
 2226|    354|                         index < 6u && length > 0u; ++index, ++column_index, --length)
  ------------------
  |  Branch (2226:26): [True: 354, False: 0]
  |  Branch (2226:26): [True: 246, False: 108]
  |  Branch (2226:40): [True: 246, False: 108]
  ------------------
 2227|    246|                    {
 2228|    246|                        buffer[index] = static_cast<char>(line[column_index.unsafe()].m_Char);
 2229|    246|                    }
 2230|       |
 2231|    108|                    buffer[index] = '\0';
 2232|    108|                    column_width  = ImGui::GetFont()
 2233|    108|                                           ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 2234|    108|                                                           buffer.data())
 2235|    108|                                           .x;
 2236|    108|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2236:25): [True: 36, False: 72]
  ------------------
 2237|     36|                    {
 2238|     36|                        break;
 2239|     36|                    }
 2240|     72|                    column_x += column_width;
 2241|     72|                    column_coord++;
 2242|     72|                }
 2243|    111|            }
 2244|    278|        }
 2245|       |
 2246|  2.12k|        return SanitizeCoordinates(Coordinates(line_no, column_coord));
 2247|  2.12k|    }
_ZNK6dlxemu10CodeEditor13FindWordStartERKNS0_11CoordinatesE:
 2251|  7.08k|    {
 2252|  7.08k|        if (from.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2252:13): [True: 0, False: 7.08k]
  ------------------
 2253|      0|        {
 2254|      0|            return from;
 2255|      0|        }
 2256|       |
 2257|  7.08k|        const Line& line   = m_Lines[from.m_Line.unsafe()];
 2258|  7.08k|        phi::u32    cindex = GetCharacterIndex(from);
 2259|       |
 2260|  7.08k|        if (cindex >= line.size())
  ------------------
  |  Branch (2260:13): [True: 3.62k, False: 3.46k]
  ------------------
 2261|  3.62k|        {
 2262|  3.62k|            return from;
 2263|  3.62k|        }
 2264|       |
 2265|  4.17k|        while (cindex > 0u && phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2265:16): [True: 1.80k, False: 2.36k]
  |  Branch (2265:16): [True: 707, False: 3.46k]
  |  Branch (2265:31): [True: 707, False: 1.09k]
  ------------------
 2266|    707|        {
 2267|    707|            --cindex;
 2268|    707|        }
 2269|       |
 2270|  3.46k|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2271|  8.62k|        while (cindex > 0u)
  ------------------
  |  Branch (2271:16): [True: 5.39k, False: 3.23k]
  ------------------
 2272|  5.39k|        {
 2273|  5.39k|            Glyph glyph = line[cindex.unsafe()];
 2274|  5.39k|            if (!IsUTFSequence(glyph.m_Char))
  ------------------
  |  Branch (2274:17): [True: 2.94k, False: 2.44k]
  ------------------
 2275|  2.94k|            {
 2276|  2.94k|                if (glyph.m_Char <= 32 && phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2276:21): [True: 739, False: 2.20k]
  |  Branch (2276:21): [True: 231, False: 2.71k]
  |  Branch (2276:43): [True: 231, False: 508]
  ------------------
 2277|    231|                {
 2278|    231|                    cindex += 1u;
 2279|    231|                    break;
 2280|    231|                }
 2281|       |
 2282|  2.71k|                if (cstart != line[phi::size_t(cindex.unsafe() - 1u)].m_ColorIndex)
  ------------------
  |  Branch (2282:21): [True: 3, False: 2.71k]
  ------------------
 2283|      3|                {
 2284|      3|                    break;
 2285|      3|                }
 2286|  2.71k|            }
 2287|       |
 2288|  5.15k|            cindex -= 1u;
 2289|  5.15k|        }
 2290|       |
 2291|  3.46k|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2292|  7.08k|    }
_ZNK6dlxemu10CodeEditor11FindWordEndERKNS0_11CoordinatesE:
 2296|  2.62k|    {
 2297|  2.62k|        Coordinates at = from;
 2298|  2.62k|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2298:13): [True: 0, False: 2.62k]
  ------------------
 2299|      0|        {
 2300|      0|            return at;
 2301|      0|        }
 2302|       |
 2303|  2.62k|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2304|  2.62k|        phi::u32    cindex = GetCharacterIndex(at);
 2305|       |
 2306|  2.62k|        if (cindex >= line.size())
  ------------------
  |  Branch (2306:13): [True: 2.31k, False: 301]
  ------------------
 2307|  2.31k|        {
 2308|  2.31k|            return at;
 2309|  2.31k|        }
 2310|       |
 2311|    301|        const phi::boolean prevspace =
 2312|    301|                phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char));
 2313|    301|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2314|  1.21k|        while (cindex < line.size())
  ------------------
  |  Branch (2314:16): [True: 1.07k, False: 145]
  ------------------
 2315|  1.07k|        {
 2316|  1.07k|            const Glyph glyph = line[cindex.unsafe()];
 2317|       |
 2318|  1.07k|            if (cstart != line[cindex.unsafe()].m_ColorIndex)
  ------------------
  |  Branch (2318:17): [True: 37, False: 1.03k]
  ------------------
 2319|     37|            {
 2320|     37|                break;
 2321|     37|            }
 2322|       |
 2323|  1.03k|            if (prevspace != phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2323:17): [True: 119, False: 918]
  ------------------
 2324|    119|            {
 2325|    119|                if (phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2325:21): [True: 94, False: 25]
  ------------------
 2326|     94|                {
 2327|    251|                    while (cindex < line.size() &&
  ------------------
  |  Branch (2327:28): [True: 186, False: 65]
  |  Branch (2327:28): [True: 157, False: 94]
  ------------------
 2328|    251|                           phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2328:28): [True: 157, False: 29]
  ------------------
 2329|    157|                    {
 2330|    157|                        cindex += 1u;
 2331|    157|                    }
 2332|     94|                }
 2333|    119|                break;
 2334|    119|            }
 2335|       |
 2336|    918|            cindex += UTF8CharLength(glyph.m_Char);
 2337|    918|        }
 2338|       |
 2339|    301|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2340|  2.62k|    }
_ZNK6dlxemu10CodeEditor12FindNextWordERKNS0_11CoordinatesE:
 2344|  2.50k|    {
 2345|  2.50k|        Coordinates at = from;
 2346|  2.50k|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2346:13): [True: 0, False: 2.50k]
  ------------------
 2347|      0|        {
 2348|      0|            return at;
 2349|      0|        }
 2350|       |
 2351|       |        // skip to the next non-word character
 2352|  2.50k|        phi::u32     cindex  = GetCharacterIndex(from);
 2353|  2.50k|        phi::boolean is_word = false;
 2354|  2.50k|        phi::boolean skip    = false;
 2355|  2.50k|        if (cindex < m_Lines[at.m_Line.unsafe()].size())
  ------------------
  |  Branch (2355:13): [True: 2.14k, False: 364]
  ------------------
 2356|  2.14k|        {
 2357|  2.14k|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2358|  2.14k|            is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2359|  2.14k|            skip    = is_word;
 2360|  2.14k|        }
 2361|       |
 2362|  27.8k|        while (!is_word || skip)
  ------------------
  |  Branch (2362:16): [True: 27.4k, False: 376]
  |  Branch (2362:16): [True: 27.8k, False: 0]
  |  Branch (2362:28): [True: 376, False: 0]
  ------------------
 2363|  27.8k|        {
 2364|  27.8k|            if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2364:17): [True: 1.60k, False: 26.2k]
  ------------------
 2365|  1.60k|            {
 2366|  1.60k|                const phi::u32 line_number = GetMaxLineNumber();
 2367|       |
 2368|  1.60k|                return {line_number, GetLineMaxColumn(line_number)};
 2369|  1.60k|            }
 2370|       |
 2371|  26.2k|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2372|  26.2k|            if (cindex < line.size())
  ------------------
  |  Branch (2372:17): [True: 24.5k, False: 1.65k]
  ------------------
 2373|  24.5k|            {
 2374|  24.5k|                is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2375|       |
 2376|  24.5k|                if (is_word && !skip)
  ------------------
  |  Branch (2376:21): [True: 1.09k, False: 23.4k]
  |  Branch (2376:21): [True: 906, False: 23.6k]
  |  Branch (2376:32): [True: 906, False: 191]
  ------------------
 2377|    906|                {
 2378|    906|                    return {at.m_Line, GetCharacterColumn(at.m_Line, cindex)};
 2379|    906|                }
 2380|       |
 2381|  23.6k|                if (!is_word)
  ------------------
  |  Branch (2381:21): [True: 23.4k, False: 191]
  ------------------
 2382|  23.4k|                {
 2383|  23.4k|                    skip = false;
 2384|  23.4k|                }
 2385|       |
 2386|  23.6k|                cindex++;
 2387|  23.6k|            }
 2388|  1.65k|            else
 2389|  1.65k|            {
 2390|  1.65k|                cindex = 0u;
 2391|  1.65k|                at.m_Line += 1u;
 2392|  1.65k|                skip    = false;
 2393|  1.65k|                is_word = false;
 2394|  1.65k|            }
 2395|  26.2k|        }
 2396|       |
 2397|      0|        return at;
 2398|  2.50k|    }
_ZNK6dlxemu10CodeEditor9GetWordAtERKNS0_11CoordinatesE:
 2407|  2.12k|    {
 2408|  2.12k|        PHI_ASSERT(coords.m_Line < m_Lines.size());
 2409|       |
 2410|  2.12k|        Coordinates start = FindWordStart(coords);
 2411|  2.12k|        Coordinates end   = FindWordEnd(coords);
 2412|       |
 2413|  2.12k|        phi::u32 istart = GetCharacterIndex(start);
 2414|  2.12k|        phi::u32 iend   = GetCharacterIndex(end);
 2415|       |
 2416|  2.12k|        std::string result;
 2417|       |
 2418|  2.23k|        for (phi::u32 iterator = istart; iterator < iend; ++iterator)
  ------------------
  |  Branch (2418:42): [True: 105, False: 2.12k]
  ------------------
 2419|    105|        {
 2420|    105|            const Line& line = m_Lines[coords.m_Line.unsafe()];
 2421|       |
 2422|    105|            PHI_ASSERT(iterator < line.size());
 2423|    105|            result.push_back(static_cast<char>(line[iterator.unsafe()].m_Char));
 2424|    105|        }
 2425|       |
 2426|  2.12k|        return result;
 2427|  2.12k|    }
_ZNK6dlxemu10CodeEditor17GetCharacterIndexERKNS0_11CoordinatesE:
 2431|   362k|    {
 2432|   362k|        PHI_ASSERT(coordinates.m_Line < m_Lines.size());
 2433|       |
 2434|   362k|        const Line& line  = m_Lines[coordinates.m_Line.unsafe()];
 2435|   362k|        phi::u32    index = 0u;
 2436|  1.25M|        for (phi::u32 column{0u}; index < line.size() && column < coordinates.m_Column;)
  ------------------
  |  Branch (2436:35): [True: 1.04M, False: 211k]
  |  Branch (2436:35): [True: 892k, False: 362k]
  |  Branch (2436:58): [True: 892k, False: 151k]
  ------------------
 2437|   892k|        {
 2438|   892k|            PHI_ASSERT(index < line.size());
 2439|   892k|            const Char character = line[index.unsafe()].m_Char;
 2440|       |
 2441|   892k|            if (character == '\t')
  ------------------
  |  Branch (2441:17): [True: 78.0k, False: 814k]
  ------------------
 2442|  78.0k|            {
 2443|  78.0k|                column = (column / m_TabSize) * m_TabSize + m_TabSize;
 2444|  78.0k|            }
 2445|   814k|            else
 2446|   814k|            {
 2447|   814k|                ++column;
 2448|   814k|            }
 2449|       |
 2450|   892k|            index += UTF8CharLength(character);
 2451|   892k|        }
 2452|       |
 2453|   362k|        return index;
 2454|   362k|    }
_ZNK6dlxemu10CodeEditor18GetCharacterColumnEN3phi7integerIjEES3_:
 2458|  65.8k|    {
 2459|  65.8k|        PHI_ASSERT(line_number < m_Lines.size());
 2460|       |
 2461|  65.8k|        const Line& line   = m_Lines[line_number.unsafe()];
 2462|  65.8k|        phi::u32    column = 0u;
 2463|  65.8k|        phi::u32    i      = 0u;
 2464|       |
 2465|   334k|        while (i < index && i < line.size())
  ------------------
  |  Branch (2465:16): [True: 268k, False: 65.8k]
  |  Branch (2465:16): [True: 268k, False: 65.8k]
  |  Branch (2465:29): [True: 268k, False: 0]
  ------------------
 2466|   268k|        {
 2467|   268k|            char character = static_cast<char>(line[static_cast<phi::size_t>(i.unsafe())].m_Char);
 2468|   268k|            i += UTF8CharLength(character);
 2469|   268k|            if (character == '\t')
  ------------------
  |  Branch (2469:17): [True: 31.2k, False: 237k]
  ------------------
 2470|  31.2k|            {
 2471|  31.2k|                column = (column.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2472|  31.2k|                         m_TabSize.unsafe();
 2473|  31.2k|            }
 2474|   237k|            else
 2475|   237k|            {
 2476|   237k|                column++;
 2477|   237k|            }
 2478|   268k|        }
 2479|       |
 2480|  65.8k|        return column;
 2481|  65.8k|    }
_ZNK6dlxemu10CodeEditor16GetLineMaxColumnEN3phi7integerIjEE:
 2503|   310k|    {
 2504|   310k|        if (line_number >= m_Lines.size())
  ------------------
  |  Branch (2504:13): [True: 0, False: 310k]
  ------------------
 2505|      0|        {
 2506|      0|            return 0u;
 2507|      0|        }
 2508|       |
 2509|   310k|        const Line& line = m_Lines[line_number.unsafe()];
 2510|   310k|        phi::u32    col  = 0u;
 2511|       |
 2512|  1.70M|        for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (2512:32): [True: 1.39M, False: 310k]
  ------------------
 2513|  1.39M|        {
 2514|  1.39M|            char character = static_cast<char>(line[i.unsafe()].m_Char);
 2515|  1.39M|            if (character == '\t')
  ------------------
  |  Branch (2515:17): [True: 129k, False: 1.26M]
  ------------------
 2516|   129k|            {
 2517|   129k|                col = (col / m_TabSize) * m_TabSize + m_TabSize;
 2518|   129k|            }
 2519|  1.26M|            else
 2520|  1.26M|            {
 2521|  1.26M|                col++;
 2522|  1.26M|            }
 2523|       |
 2524|  1.39M|            i += UTF8CharLength(character);
 2525|  1.39M|        }
 2526|       |
 2527|   310k|        return col;
 2528|   310k|    }
_ZNK6dlxemu10CodeEditor16GetMaxLineNumberEv:
 2531|  27.3k|    {
 2532|  27.3k|        PHI_ASSERT(!m_Lines.empty());
 2533|       |
 2534|  27.3k|        return static_cast<phi::uint32_t>(m_Lines.size() - 1u);
 2535|  27.3k|    }
_ZNK6dlxemu10CodeEditor16IsOnWordBoundaryERKNS0_11CoordinatesE:
 2539|    620|    {
 2540|    620|        if (at.m_Line >= m_Lines.size() || at.m_Column == 0u)
  ------------------
  |  Branch (2540:13): [True: 0, False: 620]
  |  Branch (2540:13): [True: 38, False: 582]
  |  Branch (2540:44): [True: 38, False: 582]
  ------------------
 2541|     38|        {
 2542|     38|            return true;
 2543|     38|        }
 2544|       |
 2545|    582|        PHI_ASSERT(at.m_Line < m_Lines.size());
 2546|    582|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2547|    582|        phi::u32    cindex = GetCharacterIndex(at);
 2548|    582|        if (cindex >= line.size())
  ------------------
  |  Branch (2548:13): [True: 582, False: 0]
  ------------------
 2549|    582|        {
 2550|    582|            return true;
 2551|    582|        }
 2552|       |
 2553|      0|        if (m_ColorizerEnabled)
  ------------------
  |  Branch (2553:13): [True: 0, False: 0]
  ------------------
 2554|      0|        {
 2555|      0|            return line[cindex.unsafe()].m_ColorIndex != line[cindex.unsafe() - 1u].m_ColorIndex;
 2556|      0|        }
 2557|       |
 2558|      0|        PHI_ASSERT(cindex < line.size());
 2559|      0|        return phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)) !=
 2560|      0|               phi::is_space(static_cast<char>(line[(cindex - 1u).unsafe()].m_Char));
 2561|      0|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEES3_:
 2564|  2.98k|    {
 2565|  2.98k|        PHI_ASSERT(!m_ReadOnly);
 2566|  2.98k|        PHI_ASSERT(end >= start);
 2567|  2.98k|        PHI_ASSERT(m_Lines.size() > (end - start));
 2568|       |
 2569|       |        // Remove error markers
 2570|  2.98k|        ErrorMarkers etmp;
 2571|  2.98k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2571:33): [True: 73, False: 2.98k]
  ------------------
 2572|     73|        {
 2573|     73|            if (marker.first >= start && marker.first <= end)
  ------------------
  |  Branch (2573:17): [True: 56, False: 17]
  |  Branch (2573:17): [True: 55, False: 18]
  |  Branch (2573:42): [True: 55, False: 1]
  ------------------
 2574|     55|            {
 2575|     55|                continue;
 2576|     55|            }
 2577|       |
 2578|     18|            ErrorMarkers::value_type error_marker(
 2579|     18|                    marker.first >= start ? phi::max(marker.first - (end - start + 1u), 1u) :
  ------------------
  |  Branch (2579:21): [True: 1, False: 17]
  ------------------
 2580|     18|                                            marker.first,
 2581|     18|                    marker.second);
 2582|       |
 2583|     18|            etmp.insert(error_marker);
 2584|     18|        }
 2585|  2.98k|        m_ErrorMarkers = phi::move(etmp);
 2586|       |
 2587|       |        // Remove breakpoints
 2588|  2.98k|        Breakpoints btmp;
 2589|  2.98k|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2589:37): [True: 13, False: 2.98k]
  ------------------
 2590|     13|        {
 2591|     13|            if (line_number >= start && line_number <= end)
  ------------------
  |  Branch (2591:17): [True: 12, False: 1]
  |  Branch (2591:17): [True: 3, False: 10]
  |  Branch (2591:41): [True: 3, False: 9]
  ------------------
 2592|      3|            {
 2593|      3|                continue;
 2594|      3|            }
 2595|     10|            btmp.insert(line_number >= start ?
  ------------------
  |  Branch (2595:25): [True: 9, False: 1]
  ------------------
 2596|      9|                                phi::max(line_number - (end - start + 1u).unsafe(), 1u) :
 2597|     10|                                line_number);
 2598|     10|        }
 2599|  2.98k|        m_Breakpoints = phi::move(btmp);
 2600|       |
 2601|  2.98k|        m_Lines.erase(m_Lines.begin() + start.unsafe(), m_Lines.begin() + end.unsafe());
 2602|  2.98k|        PHI_ASSERT(!m_Lines.empty());
 2603|       |
 2604|       |        // Fix selection state
 2605|  2.98k|        if (m_State.m_SelectionStart.m_Line >= start)
  ------------------
  |  Branch (2605:13): [True: 197, False: 2.78k]
  ------------------
 2606|    197|        {
 2607|    197|            if (m_State.m_SelectionStart.m_Line < end - start)
  ------------------
  |  Branch (2607:17): [True: 0, False: 197]
  ------------------
 2608|      0|            {
 2609|      0|                m_State.m_SelectionStart.m_Line = 0u;
 2610|      0|            }
 2611|    197|            else
 2612|    197|            {
 2613|    197|                m_State.m_SelectionStart.m_Line -= end - start;
 2614|    197|            }
 2615|    197|        }
 2616|  2.98k|        if (m_State.m_SelectionEnd.m_Line >= start)
  ------------------
  |  Branch (2616:13): [True: 2.40k, False: 581]
  ------------------
 2617|  2.40k|        {
 2618|  2.40k|            if (m_State.m_SelectionEnd.m_Line < end - start)
  ------------------
  |  Branch (2618:17): [True: 0, False: 2.40k]
  ------------------
 2619|      0|            {
 2620|      0|                m_State.m_SelectionEnd.m_Line = 0u;
 2621|      0|            }
 2622|  2.40k|            else
 2623|  2.40k|            {
 2624|  2.40k|                m_State.m_SelectionEnd.m_Line -= end - start;
 2625|  2.40k|            }
 2626|  2.40k|        }
 2627|  2.98k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (2627:13): [True: 229, False: 2.75k]
  ------------------
 2628|    229|        {
 2629|    229|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 2630|    229|        }
 2631|       |
 2632|  2.98k|        m_TextChanged = true;
 2633|  2.98k|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEE:
 2636|    199|    {
 2637|    199|        PHI_ASSERT(!m_ReadOnly);
 2638|    199|        PHI_ASSERT(m_Lines.size() > 1u);
 2639|       |
 2640|       |        // Clear error markers on that line
 2641|    199|        ErrorMarkers etmp;
 2642|    199|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2642:33): [True: 36, False: 199]
  ------------------
 2643|     36|        {
 2644|     36|            ErrorMarkers::value_type error_marker(
 2645|     36|                    marker.first > index ? phi::max(marker.first - 1u, 1u) : marker.first,
  ------------------
  |  Branch (2645:21): [True: 0, False: 36]
  ------------------
 2646|     36|                    marker.second);
 2647|     36|            if ((error_marker.first - 1u) == index)
  ------------------
  |  Branch (2647:17): [True: 0, False: 36]
  ------------------
 2648|      0|            {
 2649|      0|                continue;
 2650|      0|            }
 2651|     36|            etmp.insert(error_marker);
 2652|     36|        }
 2653|    199|        m_ErrorMarkers = phi::move(etmp);
 2654|       |
 2655|       |        // Remove breakpoints on that line
 2656|    199|        Breakpoints btmp;
 2657|    199|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2657:37): [True: 1, False: 199]
  ------------------
 2658|      1|        {
 2659|      1|            if (line_number == index)
  ------------------
  |  Branch (2659:17): [True: 0, False: 1]
  ------------------
 2660|      0|            {
 2661|      0|                continue;
 2662|      0|            }
 2663|       |
 2664|      1|            btmp.insert(line_number >= index ? phi::max(line_number - 1u, 1u) : line_number);
  ------------------
  |  Branch (2664:25): [True: 1, False: 0]
  ------------------
 2665|      1|        }
 2666|    199|        m_Breakpoints = phi::move(btmp);
 2667|       |
 2668|       |        // Fix selection
 2669|    199|        if (m_State.m_SelectionStart.m_Line >= index)
  ------------------
  |  Branch (2669:13): [True: 101, False: 98]
  ------------------
 2670|    101|        {
 2671|    101|            m_State.m_SelectionStart.m_Line--;
 2672|    101|        }
 2673|    199|        if (m_State.m_SelectionEnd.m_Line >= index)
  ------------------
  |  Branch (2673:13): [True: 101, False: 98]
  ------------------
 2674|    101|        {
 2675|    101|            m_State.m_SelectionEnd.m_Line--;
 2676|    101|        }
 2677|       |
 2678|    199|        m_Lines.erase(m_Lines.begin() + index.unsafe());
 2679|    199|        PHI_ASSERT(!m_Lines.empty());
 2680|       |
 2681|    199|        m_TextChanged = true;
 2682|    199|    }
_ZN6dlxemu10CodeEditor10InsertLineEN3phi7integerIjEE:
 2685|  12.0k|    {
 2686|  12.0k|        PHI_ASSERT(!m_ReadOnly);
 2687|       |
 2688|  12.0k|        Line& result = *m_Lines.insert(m_Lines.begin() + index.unsafe(), Line());
 2689|       |
 2690|  12.0k|        ErrorMarkers etmp;
 2691|  12.0k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2691:33): [True: 925, False: 12.0k]
  ------------------
 2692|    925|        {
 2693|    925|            etmp.insert(ErrorMarkers::value_type(
 2694|    925|                    marker.first >= index ? marker.first + 1u : marker.first, marker.second));
  ------------------
  |  Branch (2694:21): [True: 415, False: 510]
  ------------------
 2695|    925|        }
 2696|  12.0k|        m_ErrorMarkers = phi::move(etmp);
 2697|       |
 2698|  12.0k|        Breakpoints btmp;
 2699|  12.0k|        for (const phi::u32 line_number : m_Breakpoints)
  ------------------
  |  Branch (2699:41): [True: 228, False: 12.0k]
  ------------------
 2700|    228|        {
 2701|    228|            btmp.insert(line_number >= index ? line_number.unsafe() + 1u : line_number.unsafe());
  ------------------
  |  Branch (2701:25): [True: 198, False: 30]
  ------------------
 2702|    228|        }
 2703|  12.0k|        m_Breakpoints = phi::move(btmp);
 2704|       |
 2705|  12.0k|        return result;
 2706|  12.0k|    }
_ZN6dlxemu10CodeEditor18EnterCharacterImplEtN3phi7booleanE:
 2709|  40.5k|    {
 2710|  40.5k|        PHI_ASSERT(!m_ReadOnly);
 2711|  40.5k|        PHI_ASSERT(IsValidUTF8Sequence(character));
 2712|  40.5k|        PHI_ASSERT(character != '\0');
 2713|       |
 2714|  40.5k|        UndoRecord undo;
 2715|  40.5k|        undo.StoreBeforeState(this);
 2716|       |
 2717|  40.5k|        if (HasSelection())
  ------------------
  |  Branch (2717:13): [True: 3.37k, False: 37.2k]
  ------------------
 2718|  3.37k|        {
 2719|       |            // Do indenting
 2720|  3.37k|            if (character == '\t' &&
  ------------------
  |  Branch (2720:17): [True: 680, False: 2.69k]
  |  Branch (2720:17): [True: 679, False: 2.69k]
  ------------------
 2721|  3.37k|                (m_State.m_SelectionStart.m_Column == 0u ||
  ------------------
  |  Branch (2721:18): [True: 538, False: 142]
  ------------------
 2722|    680|                 m_State.m_SelectionStart.m_Line != m_State.m_SelectionEnd.m_Line))
  ------------------
  |  Branch (2722:18): [True: 141, False: 1]
  ------------------
 2723|    679|            {
 2724|    679|                Coordinates start        = m_State.m_SelectionStart;
 2725|    679|                Coordinates end          = m_State.m_SelectionEnd;
 2726|    679|                Coordinates original_end = end;
 2727|       |
 2728|    679|                PHI_ASSERT(start < end);
 2729|    679|                start.m_Column = 0u;
 2730|       |                //          end.mColumn = end.mLine < mLines.size() ? mLines[end.mLine].size() : 0;
 2731|    679|                if (end.m_Column == 0u && end.m_Line > 0u)
  ------------------
  |  Branch (2731:21): [True: 287, False: 392]
  |  Branch (2731:21): [True: 287, False: 392]
  |  Branch (2731:43): [True: 287, False: 0]
  ------------------
 2732|    287|                {
 2733|    287|                    --end.m_Line;
 2734|    287|                }
 2735|    679|                if (end.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2735:21): [True: 0, False: 679]
  ------------------
 2736|      0|                {
 2737|      0|                    PHI_ASSERT(!m_Lines.empty());
 2738|      0|                    end.m_Line = GetMaxLineNumber();
 2739|      0|                }
 2740|    679|                end.m_Column = GetLineMaxColumn(end.m_Line);
 2741|       |
 2742|       |                //if (end.mColumn >= GetLineMaxColumn(end.mLine))
 2743|       |                //  end.mColumn = GetLineMaxColumn(end.mLine) - 1;
 2744|       |
 2745|    679|                undo.m_RemovedStart = start;
 2746|    679|                undo.m_RemovedEnd   = end;
 2747|    679|                undo.m_Removed      = GetText(start, end);
 2748|       |
 2749|    679|                phi::boolean modified = false;
 2750|       |
 2751|  2.68k|                for (phi::u32 line_index = start.m_Line; line_index <= end.m_Line; ++line_index)
  ------------------
  |  Branch (2751:58): [True: 2.00k, False: 679]
  ------------------
 2752|  2.00k|                {
 2753|  2.00k|                    PHI_ASSERT(line_index < m_Lines.size());
 2754|  2.00k|                    Line& line = m_Lines[line_index.unsafe()];
 2755|  2.00k|                    if (shift)
  ------------------
  |  Branch (2755:25): [True: 2.00k, False: 1]
  ------------------
 2756|  2.00k|                    {
 2757|       |                        // Remove idention
 2758|  2.00k|                        if (line.empty())
  ------------------
  |  Branch (2758:29): [True: 515, False: 1.49k]
  ------------------
 2759|    515|                        {
 2760|       |                            // Skip already empty lines
 2761|    515|                            continue;
 2762|    515|                        }
 2763|       |
 2764|  1.49k|                        if (line.front().m_Char == '\t')
  ------------------
  |  Branch (2764:29): [True: 448, False: 1.04k]
  ------------------
 2765|    448|                        {
 2766|    448|                            line.erase(line.begin());
 2767|    448|                            modified = true;
 2768|    448|                        }
 2769|  1.04k|                        else
 2770|  1.04k|                        {
 2771|  1.04k|                            for (phi::u32 j = 0u;
 2772|  1.88k|                                 j < m_TabSize && !line.empty() && line.front().m_Char == ' '; ++j)
  ------------------
  |  Branch (2772:34): [True: 1.87k, False: 6]
  |  Branch (2772:34): [True: 837, False: 1.04k]
  |  Branch (2772:51): [True: 1.71k, False: 158]
  |  Branch (2772:68): [True: 837, False: 881]
  ------------------
 2773|    837|                            {
 2774|    837|                                line.erase(line.begin());
 2775|    837|                                modified = true;
 2776|    837|                            }
 2777|  1.04k|                        }
 2778|  1.49k|                    }
 2779|      1|                    else
 2780|      1|                    {
 2781|      1|                        PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
 2782|      1|                        PHI_ASSERT(!line.empty());
 2783|      1|                        PHI_ASSERT(line.data() != nullptr);
 2784|       |
 2785|       |                        // Add indention
 2786|      1|                        line.insert(line.begin(), Glyph('\t', PaletteIndex::Background));
 2787|      1|                        modified = true;
 2788|       |
 2789|      1|                        PHI_GCC_SUPPRESS_WARNING_POP()
 2790|      1|                    }
 2791|  2.00k|                }
 2792|       |
 2793|    679|                if (modified)
  ------------------
  |  Branch (2793:21): [True: 318, False: 361]
  ------------------
 2794|    318|                {
 2795|    318|                    start = Coordinates(start.m_Line, GetCharacterColumn(start.m_Line, 0u));
 2796|    318|                    Coordinates range_end;
 2797|       |
 2798|    318|                    if (original_end.m_Column != 0u)
  ------------------
  |  Branch (2798:25): [True: 274, False: 44]
  ------------------
 2799|    274|                    {
 2800|    274|                        end          = Coordinates(end.m_Line, GetLineMaxColumn(end.m_Line));
 2801|    274|                        range_end    = end;
 2802|    274|                        undo.m_Added = GetText(start, end);
 2803|    274|                    }
 2804|     44|                    else
 2805|     44|                    {
 2806|     44|                        end       = Coordinates(original_end.m_Line, 0u);
 2807|     44|                        range_end = Coordinates(end.m_Line - 1u, GetLineMaxColumn(end.m_Line - 1u));
 2808|     44|                        undo.m_Added = GetText(start, range_end);
 2809|     44|                    }
 2810|       |
 2811|    318|                    undo.m_AddedStart        = start;
 2812|    318|                    undo.m_AddedEnd          = range_end;
 2813|    318|                    m_State.m_SelectionStart = start;
 2814|    318|                    m_State.m_SelectionEnd   = end;
 2815|       |
 2816|    318|                    undo.StoreAfterState(this);
 2817|    318|                    AddUndo(undo);
 2818|       |
 2819|    318|                    m_TextChanged = true;
 2820|       |
 2821|    318|                    EnsureCursorVisible();
 2822|    318|                }
 2823|       |
 2824|    679|                return;
 2825|    679|            } // c == '\t'
 2826|  2.69k|            else
 2827|  2.69k|            {
 2828|  2.69k|                undo.m_Removed      = GetSelectedText();
 2829|  2.69k|                undo.m_RemovedStart = m_State.m_SelectionStart;
 2830|  2.69k|                undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2831|  2.69k|                DeleteSelection();
 2832|  2.69k|            }
 2833|  3.37k|        } // HasSelection
 2834|       |
 2835|  39.9k|        Coordinates coord = GetActualCursorCoordinates();
 2836|  39.9k|        undo.m_AddedStart = coord;
 2837|       |
 2838|  39.9k|        PHI_ASSERT(!m_Lines.empty());
 2839|       |
 2840|  39.9k|        if (character == '\n')
  ------------------
  |  Branch (2840:13): [True: 9.14k, False: 30.7k]
  ------------------
 2841|  9.14k|        {
 2842|  9.14k|            InsertLine(coord.m_Line + 1u);
 2843|  9.14k|            undo.m_Added = static_cast<char>(character);
 2844|       |
 2845|  9.14k|            PHI_ASSERT(coord.m_Line < m_Lines.size() - 1u);
 2846|  9.14k|            Line& line     = m_Lines[coord.m_Line.unsafe()];
 2847|  9.14k|            Line& new_line = m_Lines[coord.m_Line.unsafe() + 1u];
 2848|       |
 2849|  16.7k|            for (phi::u32 it{0u}; it < line.size() && it < coord.m_Column &&
  ------------------
  |  Branch (2849:35): [True: 12.4k, False: 4.32k]
  |  Branch (2849:35): [True: 7.61k, False: 9.14k]
  |  Branch (2849:55): [True: 12.1k, False: 237]
  ------------------
 2850|  16.7k|                                  phi::is_blank(static_cast<char>(line[it.unsafe()].m_Char));
  ------------------
  |  Branch (2850:35): [True: 7.61k, False: 4.58k]
  ------------------
 2851|  9.14k|                 ++it)
 2852|  7.61k|            {
 2853|  7.61k|                new_line.push_back(line[it.unsafe()]);
 2854|  7.61k|                undo.m_Added += static_cast<char>(line[it.unsafe()].m_Char);
 2855|  7.61k|            }
 2856|       |
 2857|  9.14k|            const phi::usize whitespace_size = new_line.size();
 2858|  9.14k|            const phi::u32   cindex          = GetCharacterIndex(coord);
 2859|  9.14k|            new_line.insert(new_line.end(), line.begin() + cindex.unsafe(), line.end());
 2860|  9.14k|            line.erase(line.begin() + cindex.unsafe(),
 2861|  9.14k|                       line.begin() + static_cast<phi::int32_t>(line.size()));
 2862|       |
 2863|  9.14k|            SetCursorPosition(Coordinates(
 2864|  9.14k|                    coord.m_Line + 1u,
 2865|  9.14k|                    GetCharacterColumn(coord.m_Line.unsafe() + 1u,
 2866|  9.14k|                                       static_cast<phi::uint32_t>(whitespace_size.unsafe()))));
 2867|       |
 2868|       |            // Fix selection
 2869|  9.14k|            if (!HasSelection())
  ------------------
  |  Branch (2869:17): [True: 9.14k, False: 0]
  ------------------
 2870|  9.14k|            {
 2871|  9.14k|                ClearSelection();
 2872|  9.14k|            }
 2873|  9.14k|        }
 2874|  30.7k|        else
 2875|  30.7k|        {
 2876|  30.7k|            phi::array<char, 5u> buffer{};
 2877|  30.7k|            const phi::u8_fast   length = ImTextCharToUtf8(buffer, character);
 2878|       |
 2879|       |            // We require a valid ut8 sequence
 2880|  30.7k|            PHI_ASSERT(length > 0u);
 2881|       |
 2882|  30.7k|            PHI_ASSERT(coord.m_Line < m_Lines.size());
 2883|  30.7k|            Line&    line   = m_Lines[static_cast<phi::size_t>(coord.m_Line.unsafe())];
 2884|  30.7k|            phi::u32 cindex = GetCharacterIndex(coord);
 2885|       |
 2886|  30.7k|            if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (2886:17): [True: 0, False: 30.7k]
  |  Branch (2886:17): [True: 0, False: 30.7k]
  |  Branch (2886:32): [True: 0, False: 0]
  ------------------
 2887|      0|            {
 2888|      0|                phi::u8_fast char_length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 2889|       |
 2890|      0|                undo.m_RemovedStart = m_State.m_CursorPosition;
 2891|      0|                undo.m_RemovedEnd   = Coordinates(
 2892|      0|                        coord.m_Line, GetCharacterColumn(coord.m_Line, cindex + char_length));
 2893|       |
 2894|      0|                for (; char_length > 0u && cindex < line.size(); --char_length)
  ------------------
  |  Branch (2894:24): [True: 0, False: 0]
  |  Branch (2894:24): [True: 0, False: 0]
  |  Branch (2894:44): [True: 0, False: 0]
  ------------------
 2895|      0|                {
 2896|      0|                    undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 2897|      0|                    line.erase(line.begin() + cindex.unsafe());
 2898|      0|                }
 2899|      0|            }
 2900|       |
 2901|  92.2k|            for (char* pointer = buffer.data(); *pointer != '\0'; ++pointer, ++cindex)
  ------------------
  |  Branch (2901:49): [True: 61.4k, False: 30.7k]
  ------------------
 2902|  61.4k|            {
 2903|  61.4k|                line.insert(line.begin() + cindex.unsafe(),
 2904|  61.4k|                            Glyph(static_cast<phi::uint8_t>(*pointer), PaletteIndex::Default));
 2905|  61.4k|            }
 2906|  30.7k|            undo.m_Added = std::string_view{buffer.data(), length.unsafe()};
 2907|       |
 2908|  30.7k|            SetCursorPosition(Coordinates(coord.m_Line, GetCharacterColumn(coord.m_Line, cindex)));
 2909|  30.7k|        }
 2910|       |
 2911|  39.9k|        m_TextChanged = true;
 2912|       |
 2913|  39.9k|        undo.m_AddedEnd = GetActualCursorCoordinates();
 2914|  39.9k|        undo.StoreAfterState(this);
 2915|       |
 2916|  39.9k|        AddUndo(undo);
 2917|       |
 2918|  39.9k|        Colorize(coord.m_Line, 1u);
 2919|  39.9k|    }
_ZN6dlxemu10CodeEditor13BackspaceImplEv:
 2922|  1.14k|    {
 2923|  1.14k|        PHI_ASSERT(!m_ReadOnly);
 2924|  1.14k|        PHI_ASSERT(!m_Lines.empty());
 2925|       |
 2926|  1.14k|        UndoRecord undo;
 2927|  1.14k|        undo.StoreBeforeState(this);
 2928|       |
 2929|  1.14k|        if (HasSelection())
  ------------------
  |  Branch (2929:13): [True: 221, False: 927]
  ------------------
 2930|    221|        {
 2931|    221|            undo.m_Removed      = GetSelectedText();
 2932|    221|            undo.m_RemovedStart = m_State.m_SelectionStart;
 2933|    221|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2934|       |
 2935|    221|            DeleteSelection();
 2936|    221|        }
 2937|    927|        else
 2938|    927|        {
 2939|    927|            Coordinates pos = GetActualCursorCoordinates();
 2940|    927|            SetCursorPosition(pos);
 2941|       |
 2942|    927|            if (m_State.m_CursorPosition.m_Column == 0u)
  ------------------
  |  Branch (2942:17): [True: 350, False: 577]
  ------------------
 2943|    350|            {
 2944|    350|                if (m_State.m_CursorPosition.m_Line == 0u)
  ------------------
  |  Branch (2944:21): [True: 164, False: 186]
  ------------------
 2945|    164|                {
 2946|    164|                    return;
 2947|    164|                }
 2948|       |
 2949|    186|                undo.m_Removed      = '\n';
 2950|    186|                undo.m_RemovedStart = undo.m_RemovedEnd =
 2951|    186|                        Coordinates(pos.m_Line - 1u, GetLineMaxColumn(pos.m_Line - 1u));
 2952|    186|                Advance(undo.m_RemovedEnd);
 2953|       |
 2954|    186|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2955|    186|                Line& line      = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2956|    186|                Line& prev_line = m_Lines[m_State.m_CursorPosition.m_Line.unsafe() - 1u];
 2957|       |
 2958|    186|                const phi::u32 prev_size = GetLineMaxColumn(m_State.m_CursorPosition.m_Line - 1u);
 2959|    186|                prev_line.insert(prev_line.end(), line.begin(), line.end());
 2960|       |
 2961|    186|                ErrorMarkers etmp;
 2962|    186|                for (auto& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (2962:41): [True: 41, False: 186]
  ------------------
 2963|     41|                {
 2964|     41|                    const phi::u32 error_marker_line = error_marker.first;
 2965|       |
 2966|     41|                    etmp.insert(ErrorMarkers::value_type(
 2967|     41|                            (error_marker_line - 1u) == m_State.m_CursorPosition.m_Line ?
  ------------------
  |  Branch (2967:29): [True: 10, False: 31]
  ------------------
 2968|     10|                                    error_marker_line - 1u :
 2969|     41|                                    error_marker_line,
 2970|     41|                            error_marker.second));
 2971|     41|                }
 2972|    186|                m_ErrorMarkers = phi::move(etmp);
 2973|       |
 2974|    186|                RemoveLine(m_State.m_CursorPosition.m_Line);
 2975|    186|                --m_State.m_CursorPosition.m_Line;
 2976|    186|                m_State.m_CursorPosition.m_Column = prev_size;
 2977|    186|            }
 2978|    577|            else
 2979|    577|            {
 2980|    577|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2981|    577|                Line&    line   = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2982|    577|                phi::u32 cindex = GetCharacterIndex(pos) - 1u;
 2983|       |
 2984|    577|                if (line[cindex.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2984:21): [True: 366, False: 211]
  ------------------
 2985|    366|                {
 2986|    366|                    undo.m_RemovedStart.m_Line = GetActualCursorCoordinates().m_Line;
 2987|    366|                    undo.m_RemovedEnd          = GetActualCursorCoordinates();
 2988|    366|                    undo.m_Removed             = '\t';
 2989|       |
 2990|    366|                    line.erase(line.begin() + cindex.unsafe());
 2991|       |
 2992|       |                    // Move cursor back
 2993|    366|                    m_State.m_CursorPosition.m_Column = GetCharacterColumn(pos.m_Line, cindex);
 2994|    366|                    undo.m_RemovedStart.m_Column      = GetCharacterColumn(pos.m_Line, cindex);
 2995|    366|                }
 2996|    211|                else
 2997|    211|                {
 2998|    211|                    phi::u32 cend = cindex + 1u;
 2999|    540|                    while (cindex > 0u && IsUTFSequence(line[cindex.unsafe()].m_Char))
  ------------------
  |  Branch (2999:28): [True: 397, False: 143]
  |  Branch (2999:28): [True: 329, False: 211]
  |  Branch (2999:43): [True: 329, False: 68]
  ------------------
 3000|    329|                    {
 3001|    329|                        --cindex;
 3002|    329|                    }
 3003|       |
 3004|    211|                    undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 3005|    211|                    --undo.m_RemovedStart.m_Column;
 3006|    211|                    --m_State.m_CursorPosition.m_Column;
 3007|       |
 3008|    751|                    for (; cindex < line.size() && cend > cindex; --cend)
  ------------------
  |  Branch (3008:28): [True: 564, False: 187]
  |  Branch (3008:28): [True: 540, False: 211]
  |  Branch (3008:52): [True: 540, False: 24]
  ------------------
 3009|    540|                    {
 3010|    540|                        undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 3011|    540|                        line.erase(line.begin() + cindex.unsafe());
 3012|    540|                    }
 3013|    211|                }
 3014|    577|            }
 3015|       |
 3016|    763|            m_TextChanged = true;
 3017|       |
 3018|    763|            EnsureCursorVisible();
 3019|    763|            Colorize(m_State.m_CursorPosition.m_Line, 1);
 3020|    763|        }
 3021|       |
 3022|       |        // Correct selection
 3023|    984|        m_State.m_SelectionStart = SanitizeCoordinates(m_State.m_SelectionStart);
 3024|    984|        m_State.m_SelectionEnd   = SanitizeCoordinates(m_State.m_SelectionEnd);
 3025|       |
 3026|    984|        undo.StoreAfterState(this);
 3027|    984|        AddUndo(undo);
 3028|    984|    }
_ZN6dlxemu10CodeEditor15DeleteSelectionEv:
 3031|  2.92k|    {
 3032|  2.92k|        if (m_State.m_SelectionEnd == m_State.m_SelectionStart)
  ------------------
  |  Branch (3032:13): [True: 0, False: 2.92k]
  ------------------
 3033|      0|        {
 3034|      0|            return;
 3035|      0|        }
 3036|       |
 3037|  2.92k|        DeleteRange(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 3038|       |
 3039|  2.92k|        SetSelection(m_State.m_SelectionStart, m_State.m_SelectionStart);
 3040|  2.92k|        SetCursorPosition(m_State.m_SelectionStart);
 3041|  2.92k|        Colorize(m_State.m_SelectionStart.m_Line, 1);
 3042|  2.92k|        m_TextChanged = true;
 3043|  2.92k|    }
_ZNK6dlxemu10CodeEditor13GetGlyphColorERKNS0_5GlyphE:
 3046|  18.2k|    {
 3047|  18.2k|        if (!m_ColorizerEnabled)
  ------------------
  |  Branch (3047:13): [True: 0, False: 18.2k]
  ------------------
 3048|      0|        {
 3049|      0|            return GetPaletteForIndex(PaletteIndex::Default);
 3050|      0|        }
 3051|       |
 3052|  18.2k|        return GetPaletteForIndex(glyph.m_ColorIndex);
 3053|  18.2k|    }
_ZN6dlxemu10CodeEditor20HandleKeyboardInputsEv:
 3056|  11.3k|    {
 3057|  11.3k|        if (!ImGui::IsWindowFocused())
  ------------------
  |  Branch (3057:13): [True: 7.24k, False: 4.15k]
  ------------------
 3058|  7.24k|        {
 3059|  7.24k|            return;
 3060|  7.24k|        }
 3061|       |
 3062|  4.15k|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3063|  4.15k|        const phi::boolean shift    = imgui_io.KeyShift;
 3064|  4.15k|        const phi::boolean ctrl =
 3065|  4.15k|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3065:17): [True: 0, False: 4.15k]
  ------------------
 3066|  4.15k|        const phi::boolean alt =
 3067|  4.15k|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3067:17): [True: 0, False: 4.15k]
  ------------------
 3068|       |
 3069|  4.15k|        if (ImGui::IsWindowHovered())
  ------------------
  |  Branch (3069:13): [True: 0, False: 4.15k]
  ------------------
 3070|      0|        {
 3071|      0|            ImGui::SetMouseCursor(ImGuiMouseCursor_TextInput);
 3072|      0|        }
 3073|       |        //ImGui::CaptureKeyboardFromApp(true);
 3074|       |
 3075|  4.15k|        imgui_io.WantCaptureKeyboard = true;
 3076|  4.15k|        imgui_io.WantTextInput       = true;
 3077|       |
 3078|  4.15k|        if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Z))
  ------------------
  |  Branch (3078:13): [True: 3.69k, False: 456]
  |  Branch (3078:13): [True: 0, False: 4.15k]
  |  Branch (3078:30): [True: 241, False: 3.45k]
  |  Branch (3078:38): [True: 151, False: 90]
  |  Branch (3078:48): [True: 151, False: 0]
  |  Branch (3078:56): [True: 0, False: 151]
  ------------------
 3079|      0|        {
 3080|      0|            Undo();
 3081|      0|        }
 3082|  4.15k|        else if (!IsReadOnly() && !ctrl && !shift && alt && ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3082:18): [True: 3.69k, False: 456]
  |  Branch (3082:18): [True: 0, False: 4.15k]
  |  Branch (3082:35): [True: 3.45k, False: 241]
  |  Branch (3082:44): [True: 3.40k, False: 48]
  |  Branch (3082:54): [True: 15, False: 3.39k]
  |  Branch (3082:61): [True: 0, False: 15]
  ------------------
 3083|      0|        {
 3084|      0|            Undo();
 3085|      0|        }
 3086|  4.15k|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Y))
  ------------------
  |  Branch (3086:18): [True: 3.69k, False: 456]
  |  Branch (3086:18): [True: 0, False: 4.15k]
  |  Branch (3086:35): [True: 241, False: 3.45k]
  |  Branch (3086:43): [True: 151, False: 90]
  |  Branch (3086:53): [True: 151, False: 0]
  |  Branch (3086:61): [True: 0, False: 151]
  ------------------
 3087|      0|        {
 3088|      0|            Redo();
 3089|      0|        }
 3090|  4.15k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_UpArrow))
  ------------------
  |  Branch (3090:18): [True: 3.89k, False: 259]
  |  Branch (3090:18): [True: 2, False: 4.14k]
  |  Branch (3090:27): [True: 3.87k, False: 16]
  |  Branch (3090:35): [True: 2, False: 3.87k]
  ------------------
 3091|      2|        {
 3092|      2|            MoveUp(1u, shift);
 3093|      2|        }
 3094|  4.14k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_DownArrow))
  ------------------
  |  Branch (3094:18): [True: 3.89k, False: 259]
  |  Branch (3094:18): [True: 3, False: 4.14k]
  |  Branch (3094:27): [True: 3.87k, False: 16]
  |  Branch (3094:35): [True: 3, False: 3.87k]
  ------------------
 3095|      3|        {
 3096|      3|            MoveDown(1u, shift);
 3097|      3|        }
 3098|  4.14k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_LeftArrow))
  ------------------
  |  Branch (3098:18): [True: 4.13k, False: 16]
  |  Branch (3098:18): [True: 38, False: 4.10k]
  |  Branch (3098:26): [True: 38, False: 4.09k]
  ------------------
 3099|     38|        {
 3100|     38|            MoveLeft(1u, shift, ctrl);
 3101|     38|        }
 3102|  4.10k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_RightArrow))
  ------------------
  |  Branch (3102:18): [True: 4.09k, False: 16]
  |  Branch (3102:18): [True: 11, False: 4.09k]
  |  Branch (3102:26): [True: 11, False: 4.08k]
  ------------------
 3103|     11|        {
 3104|     11|            MoveRight(1u, shift, ctrl);
 3105|     11|        }
 3106|  4.09k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageUp))
  ------------------
  |  Branch (3106:18): [True: 4.08k, False: 16]
  |  Branch (3106:18): [True: 5, False: 4.09k]
  |  Branch (3106:26): [True: 5, False: 4.07k]
  ------------------
 3107|      5|        {
 3108|      5|            const phi::u32 page_size = GetPageSize();
 3109|      5|            MoveUp(page_size - 4u, shift);
 3110|      5|        }
 3111|  4.09k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageDown))
  ------------------
  |  Branch (3111:18): [True: 4.07k, False: 16]
  |  Branch (3111:18): [True: 1, False: 4.09k]
  |  Branch (3111:26): [True: 1, False: 4.07k]
  ------------------
 3112|      1|        {
 3113|      1|            const phi::u32 page_size = GetPageSize();
 3114|      1|            MoveDown(page_size - 4u, shift);
 3115|      1|        }
 3116|  4.09k|        else if (!alt && ctrl && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3116:18): [True: 4.07k, False: 16]
  |  Branch (3116:18): [True: 0, False: 4.09k]
  |  Branch (3116:26): [True: 253, False: 3.82k]
  |  Branch (3116:34): [True: 0, False: 253]
  ------------------
 3117|      0|        {
 3118|      0|            MoveTop(shift);
 3119|      0|        }
 3120|  4.09k|        else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3120:18): [True: 253, False: 3.83k]
  |  Branch (3120:18): [True: 3, False: 4.08k]
  |  Branch (3120:26): [True: 253, False: 0]
  |  Branch (3120:34): [True: 3, False: 250]
  ------------------
 3121|      3|        {
 3122|      3|            MoveBottom(shift);
 3123|      3|        }
 3124|  4.08k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3124:18): [True: 3.83k, False: 250]
  |  Branch (3124:18): [True: 1, False: 4.08k]
  |  Branch (3124:27): [True: 3.82k, False: 16]
  |  Branch (3124:35): [True: 1, False: 3.82k]
  ------------------
 3125|      1|        {
 3126|      1|            MoveHome(shift);
 3127|      1|        }
 3128|  4.08k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3128:18): [True: 3.83k, False: 250]
  |  Branch (3128:18): [True: 5, False: 4.08k]
  |  Branch (3128:27): [True: 3.82k, False: 16]
  |  Branch (3128:35): [True: 5, False: 3.81k]
  ------------------
 3129|      5|        {
 3130|      5|            MoveEnd(shift);
 3131|      5|        }
 3132|  4.08k|        else if (!IsReadOnly() && !ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3132:18): [True: 3.64k, False: 433]
  |  Branch (3132:18): [True: 4, False: 4.07k]
  |  Branch (3132:35): [True: 3.41k, False: 236]
  |  Branch (3132:44): [True: 3.36k, False: 48]
  |  Branch (3132:54): [True: 3.35k, False: 15]
  |  Branch (3132:62): [True: 4, False: 3.34k]
  ------------------
 3133|      4|        {
 3134|      4|            Delete();
 3135|      4|        }
 3136|  4.07k|        else if (!IsReadOnly() && !ctrl && !shift && !alt &&
  ------------------
  |  Branch (3136:18): [True: 3.64k, False: 433]
  |  Branch (3136:18): [True: 0, False: 4.07k]
  |  Branch (3136:35): [True: 3.40k, False: 236]
  |  Branch (3136:44): [True: 3.36k, False: 48]
  |  Branch (3136:54): [True: 3.34k, False: 15]
  ------------------
 3137|  4.07k|                 ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3137:18): [True: 0, False: 3.34k]
  ------------------
 3138|      0|        {
 3139|      0|            BackspaceImpl();
 3140|      0|        }
 3141|  4.07k|        else if (!ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3141:18): [True: 3.82k, False: 250]
  |  Branch (3141:18): [True: 1, False: 4.07k]
  |  Branch (3141:27): [True: 3.78k, False: 48]
  |  Branch (3141:37): [True: 3.76k, False: 16]
  |  Branch (3141:45): [True: 1, False: 3.76k]
  ------------------
 3142|      1|        {
 3143|      1|            m_Overwrite = !m_Overwrite;
 3144|      1|        }
 3145|  4.07k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3145:18): [True: 250, False: 3.82k]
  |  Branch (3145:18): [True: 0, False: 4.07k]
  |  Branch (3145:26): [True: 160, False: 90]
  |  Branch (3145:36): [True: 160, False: 0]
  |  Branch (3145:44): [True: 0, False: 160]
  ------------------
 3146|      0|        {
 3147|      0|            Copy();
 3148|      0|        }
 3149|  4.07k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_C))
  ------------------
  |  Branch (3149:18): [True: 250, False: 3.82k]
  |  Branch (3149:18): [True: 0, False: 4.07k]
  |  Branch (3149:26): [True: 160, False: 90]
  |  Branch (3149:36): [True: 160, False: 0]
  |  Branch (3149:44): [True: 0, False: 160]
  ------------------
 3150|      0|        {
 3151|      0|            Copy();
 3152|      0|        }
 3153|  4.07k|        else if (!IsReadOnly() && !ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3153:18): [True: 3.64k, False: 432]
  |  Branch (3153:18): [True: 0, False: 4.07k]
  |  Branch (3153:35): [True: 3.40k, False: 236]
  |  Branch (3153:44): [True: 48, False: 3.36k]
  |  Branch (3153:53): [True: 48, False: 0]
  |  Branch (3153:61): [True: 0, False: 48]
  ------------------
 3154|      0|        {
 3155|      0|            Paste();
 3156|      0|        }
 3157|  4.07k|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_V))
  ------------------
  |  Branch (3157:18): [True: 3.64k, False: 432]
  |  Branch (3157:18): [True: 0, False: 4.07k]
  |  Branch (3157:35): [True: 236, False: 3.40k]
  |  Branch (3157:43): [True: 146, False: 90]
  |  Branch (3157:53): [True: 146, False: 0]
  |  Branch (3157:61): [True: 0, False: 146]
  ------------------
 3158|      0|        {
 3159|      0|            Paste();
 3160|      0|        }
 3161|  4.07k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_X))
  ------------------
  |  Branch (3161:18): [True: 250, False: 3.82k]
  |  Branch (3161:18): [True: 0, False: 4.07k]
  |  Branch (3161:26): [True: 160, False: 90]
  |  Branch (3161:36): [True: 160, False: 0]
  |  Branch (3161:44): [True: 0, False: 160]
  ------------------
 3162|      0|        {
 3163|      0|            Cut();
 3164|      0|        }
 3165|  4.07k|        else if (!ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3165:18): [True: 3.82k, False: 250]
  |  Branch (3165:18): [True: 0, False: 4.07k]
  |  Branch (3165:27): [True: 48, False: 3.77k]
  |  Branch (3165:36): [True: 48, False: 0]
  |  Branch (3165:44): [True: 0, False: 48]
  ------------------
 3166|      0|        {
 3167|      0|            Cut();
 3168|      0|        }
 3169|  4.07k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_A))
  ------------------
  |  Branch (3169:18): [True: 250, False: 3.82k]
  |  Branch (3169:18): [True: 0, False: 4.07k]
  |  Branch (3169:26): [True: 160, False: 90]
  |  Branch (3169:36): [True: 160, False: 0]
  |  Branch (3169:44): [True: 0, False: 160]
  ------------------
 3170|      0|        {
 3171|      0|            SelectAll();
 3172|      0|        }
 3173|  4.07k|        else if (!IsReadOnly() && !ctrl && !alt &&
  ------------------
  |  Branch (3173:18): [True: 3.64k, False: 432]
  |  Branch (3173:18): [True: 1, False: 4.07k]
  |  Branch (3173:35): [True: 3.40k, False: 236]
  |  Branch (3173:44): [True: 3.39k, False: 15]
  ------------------
 3174|  4.07k|                 (ImGui::IsKeyPressed(ImGuiKey_Enter) || ImGui::IsKeyPressed(ImGuiKey_KeypadEnter)))
  ------------------
  |  Branch (3174:19): [True: 1, False: 3.39k]
  |  Branch (3174:58): [True: 0, False: 3.39k]
  ------------------
 3175|      1|        {
 3176|      1|            EnterCharacterImpl('\n', shift);
 3177|      1|        }
 3178|  4.07k|        else if (!IsReadOnly() && !ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Tab))
  ------------------
  |  Branch (3178:18): [True: 3.64k, False: 432]
  |  Branch (3178:18): [True: 15, False: 4.06k]
  |  Branch (3178:35): [True: 3.40k, False: 236]
  |  Branch (3178:44): [True: 3.39k, False: 15]
  |  Branch (3178:52): [True: 15, False: 3.37k]
  ------------------
 3179|     15|        {
 3180|     15|            EnterCharacterImpl('\t', shift);
 3181|     15|        }
 3182|       |
 3183|  4.15k|        if (!IsReadOnly() && !imgui_io.InputQueueCharacters.empty())
  ------------------
  |  Branch (3183:13): [True: 3.69k, False: 456]
  |  Branch (3183:13): [True: 31, False: 4.12k]
  |  Branch (3183:30): [True: 31, False: 3.66k]
  ------------------
 3184|     31|        {
 3185|    122|            for (phi::i32 i{0}; i < imgui_io.InputQueueCharacters.Size; ++i)
  ------------------
  |  Branch (3185:33): [True: 91, False: 31]
  ------------------
 3186|     91|            {
 3187|     91|                ImWchar input_char = imgui_io.InputQueueCharacters[i.unsafe()];
 3188|     91|                if (input_char != '\0' && IsValidUTF8Sequence(input_char))
  ------------------
  |  Branch (3188:21): [True: 91, False: 0]
  |  Branch (3188:21): [True: 88, False: 3]
  |  Branch (3188:43): [True: 88, False: 3]
  ------------------
 3189|     88|                {
 3190|     88|                    EnterCharacterImpl(input_char, shift);
 3191|     88|                }
 3192|     91|            }
 3193|       |
 3194|     31|            imgui_io.InputQueueCharacters.resize(0);
 3195|     31|        }
 3196|  4.15k|    }
_ZN6dlxemu10CodeEditor17HandleMouseInputsEv:
 3199|  11.3k|    {
 3200|       |        // Do nothing if our window is not hovered
 3201|  11.3k|        if (!ImGui::IsWindowHovered())
  ------------------
  |  Branch (3201:13): [True: 11.3k, False: 3]
  ------------------
 3202|  11.3k|        {
 3203|  11.3k|            return;
 3204|  11.3k|        }
 3205|       |
 3206|      3|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3207|      3|        const phi::boolean shift    = imgui_io.KeyShift;
 3208|      3|        const phi::boolean ctrl =
 3209|      3|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3209:17): [True: 0, False: 3]
  ------------------
 3210|      3|        const phi::boolean alt =
 3211|      3|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3211:17): [True: 0, False: 3]
  ------------------
 3212|       |
 3213|      3|        if (shift || alt)
  ------------------
  |  Branch (3213:13): [True: 0, False: 3]
  |  Branch (3213:22): [True: 0, False: 3]
  ------------------
 3214|      0|        {
 3215|      0|            return;
 3216|      0|        }
 3217|       |
 3218|       |        // TODO: Maybe theres a smarter way here than suppressing the warning and comparing m_LastClick != -1.0f?
 3219|      3|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3220|       |
 3221|      3|        const phi::boolean click        = ImGui::IsMouseClicked(ImGuiMouseButton_Left);
 3222|      3|        const phi::boolean double_click = ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left);
 3223|      3|        const double       time         = ImGui::GetTime();
 3224|      3|        const phi::boolean triple_click =
 3225|      3|                click && !double_click &&
  ------------------
  |  Branch (3225:17): [True: 0, False: 3]
  |  Branch (3225:26): [True: 0, False: 0]
  ------------------
 3226|      3|                (m_LastClick != -1.0f &&
  ------------------
  |  Branch (3226:18): [True: 0, False: 0]
  ------------------
 3227|      0|                 (static_cast<float>(time) - m_LastClick) < imgui_io.MouseDoubleClickTime);
  ------------------
  |  Branch (3227:18): [True: 0, False: 0]
  ------------------
 3228|       |
 3229|      3|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_POP()
 3230|       |
 3231|       |        /*
 3232|       |            Left mouse button triple click
 3233|       |        */
 3234|       |
 3235|      3|        if (triple_click)
  ------------------
  |  Branch (3235:13): [True: 0, False: 3]
  ------------------
 3236|      0|        {
 3237|      0|            if (!ctrl)
  ------------------
  |  Branch (3237:17): [True: 0, False: 0]
  ------------------
 3238|      0|            {
 3239|      0|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3240|      0|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3241|      0|                m_SelectionMode = SelectionMode::Line;
 3242|      0|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3243|      0|            }
 3244|       |
 3245|      0|            m_LastClick = -1.0f;
 3246|      0|        }
 3247|       |
 3248|       |        /*
 3249|       |            Left mouse button double click
 3250|       |        */
 3251|       |
 3252|      3|        else if (double_click)
  ------------------
  |  Branch (3252:18): [True: 0, False: 3]
  ------------------
 3253|      0|        {
 3254|      0|            if (!ctrl)
  ------------------
  |  Branch (3254:17): [True: 0, False: 0]
  ------------------
 3255|      0|            {
 3256|      0|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3257|      0|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3258|      0|                if (m_SelectionMode == SelectionMode::Line)
  ------------------
  |  Branch (3258:21): [True: 0, False: 0]
  ------------------
 3259|      0|                {
 3260|      0|                    m_SelectionMode = SelectionMode::Normal;
 3261|      0|                }
 3262|      0|                else
 3263|      0|                {
 3264|      0|                    m_SelectionMode = SelectionMode::Word;
 3265|      0|                }
 3266|      0|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3267|      0|            }
 3268|       |
 3269|      0|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3270|      0|        }
 3271|       |
 3272|       |        /*
 3273|       |            Left mouse button click
 3274|       |        */
 3275|       |
 3276|      3|        else if (click)
  ------------------
  |  Branch (3276:18): [True: 0, False: 3]
  ------------------
 3277|      0|        {
 3278|      0|            m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3279|      0|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3280|      0|            if (ctrl)
  ------------------
  |  Branch (3280:17): [True: 0, False: 0]
  ------------------
 3281|      0|            {
 3282|      0|                m_SelectionMode = SelectionMode::Word;
 3283|      0|            }
 3284|      0|            else
 3285|      0|            {
 3286|      0|                m_SelectionMode = SelectionMode::Normal;
 3287|      0|            }
 3288|      0|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3289|       |
 3290|      0|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3291|      0|        }
 3292|       |        // Mouse left button dragging (=> update selection)
 3293|      3|        else if (ImGui::IsMouseDragging(ImGuiMouseButton_Left) &&
  ------------------
  |  Branch (3293:18): [True: 0, False: 3]
  ------------------
 3294|      3|                 ImGui::IsMouseDown(ImGuiMouseButton_Left))
  ------------------
  |  Branch (3294:18): [True: 0, False: 0]
  ------------------
 3295|      0|        {
 3296|      0|            imgui_io.WantCaptureMouse = true;
 3297|      0|            m_State.m_CursorPosition  = m_InteractiveEnd =
 3298|      0|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3299|      0|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3300|      0|        }
 3301|      3|    }
_ZN6dlxemu10CodeEditor14InternalRenderEv:
 3305|  11.3k|    {
 3306|  11.3k|        PHI_ASSERT(m_LineBuffer.empty());
 3307|       |
 3308|  11.3k|        const ImVec2 content_size = ImGui::GetWindowContentRegionMax();
 3309|  11.3k|        ImDrawList*  draw_list    = ImGui::GetWindowDrawList();
 3310|  11.3k|        float        longest      = m_TextStart;
 3311|       |
 3312|  11.3k|        if (m_ScrollToTop)
  ------------------
  |  Branch (3312:13): [True: 1, False: 11.3k]
  ------------------
 3313|      1|        {
 3314|      1|            m_ScrollToTop = false;
 3315|      1|            ImGui::SetScrollY(0.f);
 3316|      1|        }
 3317|       |
 3318|  11.3k|        const ImVec2 cursor_screen_pos = ImGui::GetCursorScreenPos();
 3319|  11.3k|        const float  scroll_x          = ImGui::GetScrollX();
 3320|  11.3k|        const float  scroll_y          = ImGui::GetScrollY();
 3321|       |
 3322|  11.3k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3323|  11.3k|        phi::u32       line_no = static_cast<phi::uint32_t>(std::floor(scroll_y / m_CharAdvance.y));
 3324|  11.3k|        const phi::u32 global_line_max = static_cast<phi::uint32_t>(m_Lines.size());
 3325|       |
 3326|       |        // TODO: This is very unreadable
 3327|  11.3k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3328|  11.3k|        const phi::u32 line_max = static_cast<phi::uint32_t>(phi::clamp(
 3329|  11.3k|                GetMaxLineNumber().unsafe(), 0u,
 3330|  11.3k|                line_no.unsafe() + static_cast<phi::int32_t>(std::floor(
 3331|  11.3k|                                           (scroll_y + content_size.y) / m_CharAdvance.y))));
 3332|       |
 3333|       |        // Deduce m_TextStart by evaluating mLines size (global lineMax) plus two spaces as text width
 3334|  11.3k|        phi::array<char, 16u> buffer;
 3335|  11.3k|        snprintf(buffer.data(), buffer.size().unsafe(), " %u ", global_line_max.unsafe());
 3336|  11.3k|        m_TextStart = ImGui::GetFont()
 3337|  11.3k|                              ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3338|  11.3k|                                              nullptr, nullptr)
 3339|  11.3k|                              .x +
 3340|  11.3k|                      LeftMargin;
 3341|       |
 3342|  11.3k|        PHI_ASSERT(!m_Lines.empty());
 3343|  11.3k|        float space_size =
 3344|  11.3k|                ImGui::GetFont()
 3345|  11.3k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 3346|  11.3k|                        .x;
 3347|       |
 3348|  24.9k|        while (line_no <= line_max)
  ------------------
  |  Branch (3348:16): [True: 13.5k, False: 11.3k]
  ------------------
 3349|  13.5k|        {
 3350|  13.5k|            const ImVec2 line_start_screen_pos = ImVec2(
 3351|  13.5k|                    cursor_screen_pos.x,
 3352|  13.5k|                    cursor_screen_pos.y + static_cast<float>(line_no.unsafe()) * m_CharAdvance.y);
 3353|  13.5k|            const ImVec2 text_screen_pos =
 3354|  13.5k|                    ImVec2(line_start_screen_pos.x + m_TextStart, line_start_screen_pos.y);
 3355|       |
 3356|  13.5k|            PHI_ASSERT(line_no < m_Lines.size());
 3357|  13.5k|            const Line& line = m_Lines[line_no.unsafe()];
 3358|       |
 3359|  13.5k|            longest               = phi::max(m_TextStart + TextDistanceToLineStart(Coordinates(
 3360|  13.5k|                                                     line_no, GetLineMaxColumn(line_no))),
 3361|  13.5k|                                             longest);
 3362|  13.5k|            phi::u32    column_no = 0u;
 3363|  13.5k|            Coordinates line_start_coord(line_no, 0u);
 3364|  13.5k|            Coordinates line_end_coord(line_no, GetLineMaxColumn(line_no));
 3365|       |
 3366|       |            // Draw selection for the current line
 3367|  13.5k|            float sstart = -1.0f;
 3368|  13.5k|            float ssend  = -1.0f;
 3369|       |
 3370|  13.5k|            PHI_ASSERT(m_State.m_SelectionStart <= m_State.m_SelectionEnd);
 3371|  13.5k|            if (m_State.m_SelectionStart <= line_end_coord)
  ------------------
  |  Branch (3371:17): [True: 13.4k, False: 124]
  ------------------
 3372|  13.4k|            {
 3373|  13.4k|                sstart = m_State.m_SelectionStart > line_start_coord ?
  ------------------
  |  Branch (3373:26): [True: 537, False: 12.8k]
  ------------------
 3374|    537|                                 TextDistanceToLineStart(m_State.m_SelectionStart) :
 3375|  13.4k|                                 0.0f;
 3376|  13.4k|            }
 3377|       |
 3378|  13.5k|            if (m_State.m_SelectionEnd > line_start_coord)
  ------------------
  |  Branch (3378:17): [True: 1.15k, False: 12.3k]
  ------------------
 3379|  1.15k|            {
 3380|  1.15k|                ssend = TextDistanceToLineStart(m_State.m_SelectionEnd < line_end_coord ?
  ------------------
  |  Branch (3380:49): [True: 116, False: 1.04k]
  ------------------
 3381|    116|                                                        m_State.m_SelectionEnd :
 3382|  1.15k|                                                        line_end_coord);
 3383|  1.15k|            }
 3384|       |
 3385|  13.5k|            if (m_State.m_SelectionEnd.m_Line > line_no)
  ------------------
  |  Branch (3385:17): [True: 279, False: 13.2k]
  ------------------
 3386|    279|            {
 3387|    279|                ssend += m_CharAdvance.x;
 3388|    279|            }
 3389|       |
 3390|  13.5k|            PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3391|       |
 3392|  13.5k|            if (sstart != -1.0f && ssend != -1.0f && sstart < ssend)
  ------------------
  |  Branch (3392:17): [True: 13.4k, False: 124]
  |  Branch (3392:36): [True: 1.03k, False: 12.3k]
  |  Branch (3392:54): [True: 518, False: 516]
  ------------------
 3393|    518|            {
 3394|    518|                const ImVec2 vstart(line_start_screen_pos.x + m_TextStart + sstart,
 3395|    518|                                    line_start_screen_pos.y);
 3396|    518|                const ImVec2 vend(line_start_screen_pos.x + m_TextStart + ssend,
 3397|    518|                                  line_start_screen_pos.y + m_CharAdvance.y);
 3398|       |
 3399|    518|                draw_list->AddRectFilled(vstart, vend, GetPaletteForIndex(PaletteIndex::Selection));
 3400|    518|            }
 3401|       |
 3402|  13.5k|            PHI_GCC_SUPPRESS_WARNING_POP()
 3403|       |
 3404|       |            // Draw breakpoints
 3405|  13.5k|            const ImVec2 start =
 3406|  13.5k|                    ImVec2(line_start_screen_pos.x + scroll_x, line_start_screen_pos.y);
 3407|       |
 3408|  13.5k|            if (m_Breakpoints.contains(line_no.unsafe() + 1u))
  ------------------
  |  Branch (3408:17): [True: 44, False: 13.4k]
  ------------------
 3409|     44|            {
 3410|     44|                const ImVec2 end =
 3411|     44|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3412|     44|                               line_start_screen_pos.y + m_CharAdvance.y);
 3413|       |
 3414|     44|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::Breakpoint));
 3415|     44|            }
 3416|       |
 3417|       |            // Draw error markers
 3418|  13.5k|            auto error_it = m_ErrorMarkers.find(line_no.unsafe() + 1u);
 3419|  13.5k|            if (error_it != m_ErrorMarkers.end())
  ------------------
  |  Branch (3419:17): [True: 4.54k, False: 8.97k]
  ------------------
 3420|  4.54k|            {
 3421|  4.54k|                const ImVec2 end =
 3422|  4.54k|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3423|  4.54k|                               line_start_screen_pos.y + m_CharAdvance.y);
 3424|  4.54k|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::ErrorMarker));
 3425|       |
 3426|  4.54k|                if (GImGui->HoveredWindow == ImGui::GetCurrentWindow() &&
  ------------------
  |  Branch (3426:21): [True: 0, False: 4.54k]
  ------------------
 3427|  4.54k|                    ImGui::IsMouseHoveringRect(line_start_screen_pos, end))
  ------------------
  |  Branch (3427:21): [True: 0, False: 0]
  ------------------
 3428|      0|                {
 3429|      0|                    ImGui::BeginTooltip();
 3430|      0|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.2f, 0.2f, 1.0f));
 3431|      0|                    ImGui::Text("Error at line %u:", error_it->first);
 3432|      0|                    ImGui::PopStyleColor();
 3433|      0|                    ImGui::Separator();
 3434|      0|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.2f, 1.0f));
 3435|      0|                    ImGui::Text("%s", error_it->second.c_str());
 3436|      0|                    ImGui::PopStyleColor();
 3437|      0|                    ImGui::EndTooltip();
 3438|      0|                }
 3439|  4.54k|            }
 3440|       |
 3441|       |            // Highlight PC line
 3442|  13.5k|            const phi::u64 current_execution_line_number = m_Emulator->GetExecutingLineNumber();
 3443|  13.5k|            if (line_no + 1u == current_execution_line_number)
  ------------------
  |  Branch (3443:17): [True: 0, False: 13.5k]
  ------------------
 3444|      0|            {
 3445|      0|                const ImVec2 end =
 3446|      0|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3447|      0|                               line_start_screen_pos.y + m_CharAdvance.y);
 3448|       |                // TODO: Don't hardcode color
 3449|      0|                draw_list->AddRectFilled(start, end, 0x40ffff00);
 3450|      0|            }
 3451|       |
 3452|       |            // Draw line number (right aligned)
 3453|  13.5k|            snprintf(buffer.data(), buffer.size().unsafe(), "%u  ", line_no.unsafe() + 1u);
 3454|       |
 3455|  13.5k|            const float line_no_width =
 3456|  13.5k|                    ImGui::GetFont()
 3457|  13.5k|                            ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3458|  13.5k|                                            nullptr, nullptr)
 3459|  13.5k|                            .x;
 3460|  13.5k|            draw_list->AddText(ImVec2(line_start_screen_pos.x + m_TextStart - line_no_width,
 3461|  13.5k|                                      line_start_screen_pos.y),
 3462|  13.5k|                               GetPaletteForIndex(PaletteIndex::LineNumber), buffer.data());
 3463|       |
 3464|  13.5k|            if (m_State.m_CursorPosition.m_Line == line_no)
  ------------------
  |  Branch (3464:17): [True: 11.2k, False: 2.27k]
  ------------------
 3465|  11.2k|            {
 3466|  11.2k|                const phi::boolean focused = ImGui::IsWindowFocused();
 3467|       |
 3468|       |                // Highlight the current line (where the cursor is)
 3469|  11.2k|                if (!HasSelection())
  ------------------
  |  Branch (3469:21): [True: 10.8k, False: 388]
  ------------------
 3470|  10.8k|                {
 3471|  10.8k|                    const ImVec2 end =
 3472|  10.8k|                            ImVec2(start.x + content_size.x + scroll_x, start.y + m_CharAdvance.y);
 3473|  10.8k|                    draw_list->AddRectFilled(
 3474|  10.8k|                            start, end,
 3475|  10.8k|                            GetPaletteForIndex(focused ? PaletteIndex::CurrentLineFill :
  ------------------
  |  Branch (3475:48): [True: 3.84k, False: 7.01k]
  ------------------
 3476|  10.8k|                                                         PaletteIndex::CurrentLineFillInactive));
 3477|  10.8k|                    draw_list->AddRect(start, end,
 3478|  10.8k|                                       GetPaletteForIndex(PaletteIndex::CurrentLineEdge), 1.0f);
 3479|  10.8k|                }
 3480|       |
 3481|       |                // Render the cursor
 3482|  11.2k|                if (focused)
  ------------------
  |  Branch (3482:21): [True: 4.10k, False: 7.14k]
  ------------------
 3483|  4.10k|                {
 3484|  4.10k|                    phi::uint64_t time_end = static_cast<phi::uint64_t>(
 3485|  4.10k|                            std::chrono::duration_cast<std::chrono::milliseconds>(
 3486|  4.10k|                                    std::chrono::system_clock::now().time_since_epoch())
 3487|  4.10k|                                    .count());
 3488|  4.10k|                    phi::uint64_t elapsed = time_end - m_StartTime;
 3489|  4.10k|                    if (elapsed > 400)
  ------------------
  |  Branch (3489:25): [True: 0, False: 4.10k]
  ------------------
 3490|      0|                    {
 3491|      0|                        float    width  = 1.0f;
 3492|      0|                        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
 3493|      0|                        float    cx     = TextDistanceToLineStart(m_State.m_CursorPosition);
 3494|       |
 3495|      0|                        if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (3495:29): [True: 0, False: 0]
  |  Branch (3495:29): [True: 0, False: 0]
  |  Branch (3495:44): [True: 0, False: 0]
  ------------------
 3496|      0|                        {
 3497|      0|                            char character = static_cast<char>(line[cindex.unsafe()].m_Char);
 3498|      0|                            if (character == '\t')
  ------------------
  |  Branch (3498:33): [True: 0, False: 0]
  ------------------
 3499|      0|                            {
 3500|      0|                                float x = (1.0f +
 3501|      0|                                           std::floor((1.0f + cx) /
 3502|      0|                                                      (float(m_TabSize.unsafe()) * space_size))) *
 3503|      0|                                          (float(m_TabSize.unsafe()) * space_size);
 3504|      0|                                width = x - cx;
 3505|      0|                            }
 3506|      0|                            else
 3507|      0|                            {
 3508|      0|                                phi::array<char, 2u> buffer2;
 3509|      0|                                buffer2[0u] = static_cast<char>(line[cindex.unsafe()].m_Char);
 3510|      0|                                buffer2[1u] = '\0';
 3511|      0|                                width       = ImGui::GetFont()
 3512|      0|                                                ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX,
 3513|      0|                                                                -1.0f, buffer2.data())
 3514|      0|                                                .x;
 3515|      0|                            }
 3516|      0|                        }
 3517|      0|                        const ImVec2 cstart(text_screen_pos.x + cx, line_start_screen_pos.y);
 3518|      0|                        const ImVec2 cend(text_screen_pos.x + cx + width,
 3519|      0|                                          line_start_screen_pos.y + m_CharAdvance.y);
 3520|      0|                        draw_list->AddRectFilled(cstart, cend,
 3521|      0|                                                 GetPaletteForIndex(PaletteIndex::Cursor));
 3522|      0|                        if (elapsed > 800)
  ------------------
  |  Branch (3522:29): [True: 0, False: 0]
  ------------------
 3523|      0|                        {
 3524|      0|                            m_StartTime = time_end;
 3525|      0|                        }
 3526|      0|                    }
 3527|  4.10k|                }
 3528|  11.2k|            }
 3529|       |
 3530|       |            // Render colorized text
 3531|  13.5k|            ImU32  prev_color = line.empty() ? GetPaletteForIndex(PaletteIndex::Default) :
  ------------------
  |  Branch (3531:33): [True: 7.91k, False: 5.61k]
  ------------------
 3532|  13.5k|                                               GetGlyphColor(line[0]);
 3533|  13.5k|            ImVec2 buffer_offset;
 3534|       |
 3535|  26.2k|            for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (3535:36): [True: 12.6k, False: 13.5k]
  ------------------
 3536|  12.6k|            {
 3537|  12.6k|                const CodeEditor::Glyph& glyph = line[i.unsafe()];
 3538|  12.6k|                const ImU32              color = GetGlyphColor(glyph);
 3539|       |
 3540|  12.6k|                if ((color != prev_color || glyph.m_Char == '\t' || glyph.m_Char == ' ') &&
  ------------------
  |  Branch (3540:22): [True: 347, False: 12.3k]
  |  Branch (3540:45): [True: 1.35k, False: 10.9k]
  |  Branch (3540:69): [True: 701, False: 10.2k]
  ------------------
 3541|  12.6k|                    !m_LineBuffer.empty())
  ------------------
  |  Branch (3541:21): [True: 723, False: 1.67k]
  ------------------
 3542|    723|                {
 3543|    723|                    const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3544|    723|                                            text_screen_pos.y + buffer_offset.y);
 3545|    723|                    draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3546|    723|                    const ImVec2 text_size =
 3547|    723|                            ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 3548|    723|                                                            m_LineBuffer.c_str(), nullptr, nullptr);
 3549|    723|                    buffer_offset.x += text_size.x;
 3550|    723|                    m_LineBuffer.clear();
 3551|    723|                }
 3552|  12.6k|                prev_color = color;
 3553|       |
 3554|  12.6k|                if (glyph.m_Char == '\t')
  ------------------
  |  Branch (3554:21): [True: 1.39k, False: 11.2k]
  ------------------
 3555|  1.39k|                {
 3556|  1.39k|                    const float old_x = buffer_offset.x;
 3557|  1.39k|                    buffer_offset.x =
 3558|  1.39k|                            (1.0f + std::floor((1.0f + buffer_offset.x) /
 3559|  1.39k|                                               (float(m_TabSize.unsafe()) * space_size))) *
 3560|  1.39k|                            (float(m_TabSize.unsafe()) * space_size);
 3561|  1.39k|                    ++i;
 3562|       |
 3563|  1.39k|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3563:25): [True: 149, False: 1.24k]
  ------------------
 3564|    149|                    {
 3565|    149|                        const float font_size =
 3566|    149|                                ImGui::GetFont()
 3567|    149|                                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#",
 3568|    149|                                                        nullptr, nullptr)
 3569|    149|                                        .x;
 3570|       |
 3571|    149|                        const float  s  = ImGui::GetFontSize();
 3572|    149|                        const float  x1 = text_screen_pos.x + old_x + 1.0f;
 3573|    149|                        const float  x2 = text_screen_pos.x + buffer_offset.x - 1.0f;
 3574|    149|                        const float  y  = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3575|    149|                        const ImVec2 p1(x1, y);
 3576|    149|                        const ImVec2 p2(x2, y);
 3577|    149|                        const ImVec2 p3(x2 - font_size * 0.2f, y - font_size * 0.2f);
 3578|    149|                        const ImVec2 p4(x2 - font_size * 0.2f, y + font_size * 0.2f);
 3579|       |
 3580|    149|                        PHI_MSVC_SUPPRESS_WARNING_WITH_PUSH(5264) // Unused const variable
 3581|       |
 3582|    149|                        static constexpr const ImU32 whitespace_color{0x90909090};
 3583|       |
 3584|    149|                        PHI_MSVC_SUPPRESS_WARNING_POP()
 3585|       |
 3586|    149|                        draw_list->AddLine(p1, p2, whitespace_color);
 3587|    149|                        draw_list->AddLine(p2, p3, whitespace_color);
 3588|    149|                        draw_list->AddLine(p2, p4, whitespace_color);
 3589|    149|                    }
 3590|  1.39k|                }
 3591|  11.2k|                else if (glyph.m_Char == ' ')
  ------------------
  |  Branch (3591:26): [True: 709, False: 10.5k]
  ------------------
 3592|    709|                {
 3593|    709|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3593:25): [True: 48, False: 661]
  ------------------
 3594|     48|                    {
 3595|     48|                        const float s = ImGui::GetFontSize();
 3596|     48|                        const float x = text_screen_pos.x + buffer_offset.x + space_size * 0.5f;
 3597|     48|                        const float y = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3598|     48|                        draw_list->AddCircleFilled(ImVec2(x, y), 1.5f, 0x80808080, 4);
 3599|     48|                    }
 3600|    709|                    buffer_offset.x += space_size;
 3601|    709|                    i++;
 3602|    709|                }
 3603|  10.5k|                else
 3604|  10.5k|                {
 3605|  32.2k|                    for (phi::u8_fast length = UTF8CharLength(glyph.m_Char); length > 0u;
  ------------------
  |  Branch (3605:78): [True: 21.6k, False: 10.5k]
  ------------------
 3606|  21.6k|                         ++i, --length)
 3607|  21.6k|                    {
 3608|  21.6k|                        m_LineBuffer.push_back(static_cast<char>(line[i.unsafe()].m_Char));
 3609|  21.6k|                    }
 3610|  10.5k|                }
 3611|  12.6k|                ++column_no;
 3612|  12.6k|            }
 3613|  13.5k|            if (!m_LineBuffer.empty())
  ------------------
  |  Branch (3613:17): [True: 4.70k, False: 8.82k]
  ------------------
 3614|  4.70k|            {
 3615|  4.70k|                const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3616|  4.70k|                                        text_screen_pos.y + buffer_offset.y);
 3617|  4.70k|                draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3618|  4.70k|                m_LineBuffer.clear();
 3619|  4.70k|            }
 3620|       |
 3621|  13.5k|            ++line_no;
 3622|  13.5k|        }
 3623|       |
 3624|       |        // Draw a tooltip on known identifiers/preprocessor symbols
 3625|  11.3k|        if (ImGui::IsMousePosValid())
  ------------------
  |  Branch (3625:13): [True: 2.12k, False: 9.26k]
  ------------------
 3626|  2.12k|        {
 3627|  2.12k|            std::string id = GetWordAt(ScreenPosToCoordinates(ImGui::GetMousePos()));
 3628|  2.12k|            if (!id.empty())
  ------------------
  |  Branch (3628:17): [True: 37, False: 2.08k]
  ------------------
 3629|     37|            {
 3630|       |                /*
 3631|       |                    auto it = m_LanguageDefinition.mIdentifiers.find(id);
 3632|       |                    if (it != m_LanguageDefinition.mIdentifiers.end())
 3633|       |                    {
 3634|       |                        ImGui::BeginTooltip();
 3635|       |                        ImGui::TextUnformatted(it->second.m_Declaration.c_str());
 3636|       |                        ImGui::EndTooltip();
 3637|       |                    }
 3638|       |                    else
 3639|       |                    {
 3640|       |                        auto pi = m_LanguageDefinition.mPreprocIdentifiers.find(id);
 3641|       |                        if (pi != m_LanguageDefinition.mPreprocIdentifiers.end())
 3642|       |                        {
 3643|       |                            ImGui::BeginTooltip();
 3644|       |                            ImGui::TextUnformatted(pi->second.m_Declaration.c_str());
 3645|       |                            ImGui::EndTooltip();
 3646|       |                        }
 3647|       |                    }
 3648|       |                    */
 3649|     37|            }
 3650|  2.12k|        }
 3651|       |
 3652|  11.3k|        ImGui::Dummy(ImVec2((longest + 2), static_cast<float>(m_Lines.size()) * m_CharAdvance.y));
 3653|       |
 3654|  11.3k|        if (m_ScrollToCursor)
  ------------------
  |  Branch (3654:13): [True: 3.03k, False: 8.35k]
  ------------------
 3655|  3.03k|        {
 3656|  3.03k|            ScrollToCursor();
 3657|  3.03k|            ImGui::SetWindowFocus();
 3658|  3.03k|            m_ScrollToCursor = false;
 3659|  3.03k|        }
 3660|  11.3k|    }
_ZN6dlxemu10CodeEditor13ColorizeTokenERKN3dlx5TokenE:
 3663|  6.58k|    {
 3664|  6.58k|        PaletteIndex palette_index{PaletteIndex::Default};
 3665|       |
 3666|       |        // Determine palette color
 3667|  6.58k|        switch (token.GetType())
 3668|  6.58k|        {
 3669|    131|            case dlx::Token::Type::Comment:
  ------------------
  |  Branch (3669:13): [True: 131, False: 6.45k]
  ------------------
 3670|    131|                palette_index = PaletteIndex::Comment;
 3671|    131|                break;
 3672|     15|            case dlx::Token::Type::ImmediateInteger:
  ------------------
  |  Branch (3672:13): [True: 15, False: 6.57k]
  ------------------
 3673|    128|            case dlx::Token::Type::IntegerLiteral:
  ------------------
  |  Branch (3673:13): [True: 113, False: 6.47k]
  ------------------
 3674|    128|                palette_index = PaletteIndex::IntegerLiteral;
 3675|    128|                break;
 3676|    174|            case dlx::Token::Type::OpCode:
  ------------------
  |  Branch (3676:13): [True: 174, False: 6.41k]
  ------------------
 3677|    174|                palette_index = PaletteIndex::OpCode;
 3678|    174|                break;
 3679|      0|            case dlx::Token::Type::RegisterFloat:
  ------------------
  |  Branch (3679:13): [True: 0, False: 6.58k]
  ------------------
 3680|      9|            case dlx::Token::Type::RegisterInt:
  ------------------
  |  Branch (3680:13): [True: 9, False: 6.57k]
  ------------------
 3681|      9|            case dlx::Token::Type::RegisterStatus:
  ------------------
  |  Branch (3681:13): [True: 0, False: 6.58k]
  ------------------
 3682|      9|                palette_index = PaletteIndex::Register;
 3683|      9|                break;
 3684|  1.64k|            case dlx::Token::Type::NewLine:
  ------------------
  |  Branch (3684:13): [True: 1.64k, False: 4.94k]
  ------------------
 3685|  1.64k|                return;
 3686|  4.49k|            default:
  ------------------
  |  Branch (3686:13): [True: 4.49k, False: 2.08k]
  ------------------
 3687|  4.49k|                break;
 3688|  6.58k|        }
 3689|       |
 3690|  4.94k|        PHI_ASSERT(token.GetLineNumber() - 1u < m_Lines.size());
 3691|  4.94k|        Line& line = m_Lines[(token.GetLineNumber() - 1u).unsafe()];
 3692|       |
 3693|  4.94k|        for (phi::u64 index{token.GetColumn() - 1u};
 3694|  20.4k|             index < token.GetColumn() + token.GetLength() - 1u; ++index)
  ------------------
  |  Branch (3694:14): [True: 15.5k, False: 4.94k]
  ------------------
 3695|  15.5k|        {
 3696|  15.5k|            PHI_ASSERT(index < line.size());
 3697|  15.5k|            line[index.unsafe()].m_ColorIndex = palette_index;
 3698|  15.5k|        }
 3699|  4.94k|    }
_ZN6dlxemu10CodeEditor16ColorizeInternalEv:
 3702|  2.70k|    {
 3703|  2.70k|        const dlx::ParsedProgram& program = m_Emulator->GetProgram();
 3704|       |
 3705|  2.70k|        for (const dlx::Token& token : program.m_Tokens)
  ------------------
  |  Branch (3705:38): [True: 6.58k, False: 2.70k]
  ------------------
 3706|  6.58k|        {
 3707|  6.58k|            ColorizeToken(token);
 3708|  6.58k|        }
 3709|  2.70k|    }
_ZN6dlxemu10CodeEditor10ResetStateEv:
 3712|    168|    {
 3713|    168|        m_State.m_CursorPosition = Coordinates(0u, 0u);
 3714|    168|        m_State.m_SelectionStart = Coordinates(0u, 0u);
 3715|    168|        m_State.m_SelectionEnd   = Coordinates(0u, 0u);
 3716|       |
 3717|       |        // Clear breakpoints and markers
 3718|    168|        ClearBreakPoints();
 3719|    168|        ClearErrorMarkers();
 3720|    168|    }
_ZN6dlxemu10CodeEditor21FixSelectionAfterMoveEN3phi7booleanENS0_11CoordinatesE:
 3723|  4.77k|    {
 3724|  4.77k|        if (select)
  ------------------
  |  Branch (3724:13): [True: 4.72k, False: 55]
  ------------------
 3725|  4.72k|        {
 3726|  4.72k|            if (old_pos == m_InteractiveStart)
  ------------------
  |  Branch (3726:17): [True: 2.62k, False: 2.09k]
  ------------------
 3727|  2.62k|            {
 3728|  2.62k|                m_InteractiveStart = m_State.m_CursorPosition;
 3729|  2.62k|            }
 3730|  2.09k|            else if (old_pos == m_InteractiveEnd)
  ------------------
  |  Branch (3730:22): [True: 232, False: 1.86k]
  ------------------
 3731|    232|            {
 3732|    232|                m_InteractiveEnd = m_State.m_CursorPosition;
 3733|    232|            }
 3734|  1.86k|            else
 3735|  1.86k|            {
 3736|  1.86k|                m_InteractiveStart = m_State.m_CursorPosition;
 3737|  1.86k|                m_InteractiveEnd   = old_pos;
 3738|  1.86k|            }
 3739|  4.72k|        }
 3740|     55|        else
 3741|     55|        {
 3742|     55|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
 3743|     55|        }
 3744|       |
 3745|  4.77k|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
 3746|  4.77k|        EnsureCursorVisible();
 3747|  4.77k|    }
_ZNK6dlxemu10CodeEditor12GetTabSizeAtEN3phi7integerIjEE:
 3750|   113k|    {
 3751|   113k|        return static_cast<phi::uint_fast8_t>(m_TabSize.unsafe() -
 3752|   113k|                                              (column.unsafe() % m_TabSize.unsafe()));
 3753|   113k|    }
_ZNK6dlxemu10CodeEditor18GetPaletteForIndexENS0_12PaletteIndexE:
 3756|   121k|    {
 3757|   121k|        PHI_ASSERT(index != PaletteIndex::Max);
 3758|       |
 3759|   121k|        const phi::size_t int_value = static_cast<phi::size_t>(index);
 3760|   121k|        PHI_ASSERT(int_value < m_Palette.size());
 3761|       |
 3762|   121k|        return m_Palette[int_value];
 3763|   121k|    }
_ZN6dlxemu10CodeEditor18ComputeCharAdvanceEv:
 3766|  11.3k|    {
 3767|       |        // Compute m_CharAdvance regarding to scaled font size (Ctrl + mouse wheel)
 3768|  11.3k|        const float font_size =
 3769|  11.3k|                ImGui::GetFont()
 3770|  11.3k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#", nullptr, nullptr)
 3771|  11.3k|                        .x;
 3772|  11.3k|        m_CharAdvance = ImVec2(font_size, ImGui::GetTextLineHeightWithSpacing() * m_LineSpacing);
 3773|       |
 3774|  11.3k|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 3775|  11.3k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3776|  11.3k|    }
CodeEditor.cpp:_ZL19IsValidUTF8SequenceN3phi7integerIjEE:
  184|  81.1k|{
  185|  81.1k|    return !(character >= 0xdc00u && character < 0xe000u);
  ------------------
  |  Branch (185:14): [True: 12.2k, False: 68.9k]
  |  Branch (185:38): [True: 30, False: 12.2k]
  ------------------
  186|  81.1k|}
CodeEditor.cpp:_ZL13IsUTFSequenceh:
   93|  8.30k|{
   94|  8.30k|    return IsUTFSequence(static_cast<char>(character));
   95|  8.30k|}
CodeEditor.cpp:_ZL13IsUTFSequencec:
   88|  8.30k|{
   89|  8.30k|    return (character & 0xC0) == 0x80;
   90|  8.30k|}
CodeEditor.cpp:_ZL14UTF8CharLengthh:
  132|   927k|{
  133|   927k|    return UTF8CharLength(static_cast<char>(characater));
  134|   927k|}
CodeEditor.cpp:_ZL14UTF8CharLengthc:
  102|  3.62M|{
  103|  3.62M|    if ((characater & 0xFE) == 0xFC)
  ------------------
  |  Branch (103:9): [True: 0, False: 3.62M]
  ------------------
  104|      0|    {
  105|      0|        return 6_u8;
  106|      0|    }
  107|       |
  108|  3.62M|    if ((characater & 0xFC) == 0xF8)
  ------------------
  |  Branch (108:9): [True: 0, False: 3.62M]
  ------------------
  109|      0|    {
  110|      0|        return 5_u8;
  111|      0|    }
  112|       |
  113|  3.62M|    if ((characater & 0xF8) == 0xF0)
  ------------------
  |  Branch (113:9): [True: 34.2k, False: 3.58M]
  ------------------
  114|  34.2k|    {
  115|  34.2k|        return 4_u8;
  116|  34.2k|    }
  117|       |
  118|  3.58M|    if ((characater & 0xF0) == 0xE0)
  ------------------
  |  Branch (118:9): [True: 948k, False: 2.64M]
  ------------------
  119|   948k|    {
  120|   948k|        return 3_u8;
  121|   948k|    }
  122|       |
  123|  2.64M|    if ((characater & 0xE0) == 0xC0)
  ------------------
  |  Branch (123:9): [True: 1.06M, False: 1.57M]
  ------------------
  124|  1.06M|    {
  125|  1.06M|        return 2_u8;
  126|  1.06M|    }
  127|       |
  128|  1.57M|    return 1_u8;
  129|  2.64M|}
CodeEditor.cpp:_ZL16ImTextCharToUtf8RN3phi5arrayIcLm5EEENS_7integerIjEE:
  139|  30.7k|{
  140|  30.7k|    if (character < 0x80u)
  ------------------
  |  Branch (140:9): [True: 11.8k, False: 18.8k]
  ------------------
  141|  11.8k|    {
  142|  11.8k|        buffer[0u] = static_cast<char>(character.unsafe());
  143|  11.8k|        buffer[1u] = '\0';
  144|  11.8k|        return 1_u8;
  145|  11.8k|    }
  146|  18.8k|    if (character < 0x800u)
  ------------------
  |  Branch (146:9): [True: 8.26k, False: 10.6k]
  ------------------
  147|  8.26k|    {
  148|  8.26k|        buffer[0u] = static_cast<char>(0xc0 + (character.unsafe() >> 6));
  149|  8.26k|        buffer[1u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  150|  8.26k|        buffer[2u] = '\0';
  151|       |
  152|  8.26k|        return 2_u8;
  153|  8.26k|    }
  154|  10.6k|    if (character >= 0xdc00u && character < 0xe000u)
  ------------------
  |  Branch (154:9): [True: 6.11k, False: 4.50k]
  |  Branch (154:9): [True: 0, False: 10.6k]
  |  Branch (154:33): [True: 0, False: 6.11k]
  ------------------
  155|      0|    {
  156|      0|        buffer[0u] = '\0';
  157|      0|        return 0_u8;
  158|      0|    }
  159|       |
  160|  10.6k|    if (character >= 0xd800u && character < 0xdc00u)
  ------------------
  |  Branch (160:9): [True: 7.30k, False: 3.31k]
  |  Branch (160:9): [True: 1.19k, False: 9.43k]
  |  Branch (160:33): [True: 1.19k, False: 6.11k]
  ------------------
  161|  1.19k|    {
  162|  1.19k|        buffer[0u] = static_cast<char>(0xf0 + (character.unsafe() >> 18));
  163|  1.19k|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 12) & 0x3f));
  164|  1.19k|        buffer[2u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  165|  1.19k|        buffer[3u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  166|  1.19k|        buffer[4u] = '\0';
  167|       |
  168|  1.19k|        return 4_u8;
  169|  1.19k|    }
  170|       |    //else if (character < 0x10000)
  171|  9.43k|    {
  172|  9.43k|        PHI_ASSERT(character.unsafe() < 0x10000);
  173|       |
  174|  9.43k|        buffer[0u] = static_cast<char>(0xe0 + (character.unsafe() >> 12));
  175|  9.43k|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  176|  9.43k|        buffer[2u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  177|  9.43k|        buffer[3u] = '\0';
  178|       |
  179|  9.43k|        return 3_u8;
  180|  10.6k|    }
  181|  10.6k|}

_ZN6dlxemu8EmulatorC2Ev:
   43|  7.25k|    {}
_ZNK6dlxemu8Emulator10GetProgramEv:
  174|  2.70k|    {
  175|  2.70k|        return m_DLXProgram;
  176|  2.70k|    }
_ZN6dlxemu8Emulator12ParseProgramENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
  179|  2.70k|    {
  180|  2.70k|        m_DLXProgram = dlx::Parser::Parse(source);
  181|       |
  182|  2.70k|        if (m_DLXProgram.m_ParseErrors.empty())
  ------------------
  |  Branch (182:13): [True: 284, False: 2.41k]
  ------------------
  183|    284|        {
  184|    284|            m_Processor.LoadProgram(m_DLXProgram);
  185|    284|        }
  186|  2.70k|    }
_ZNK6dlxemu8Emulator22GetExecutingLineNumberEv:
  218|  13.5k|    {
  219|  13.5k|        if (m_DLXProgram.IsValid() && !m_Processor.IsHalted() &&
  ------------------
  |  Branch (219:13): [True: 7, False: 13.5k]
  |  Branch (219:13): [True: 0, False: 13.5k]
  |  Branch (219:39): [True: 7, False: 0]
  ------------------
  220|  13.5k|            m_CurrentExecutionMode != ExecutionMode::None)
  ------------------
  |  Branch (220:13): [True: 0, False: 7]
  ------------------
  221|      0|        {
  222|      0|            PHI_ASSERT(m_Processor.GetProgramCounter() < m_DLXProgram.m_Instructions.size());
  223|       |
  224|      0|            const auto& current_instruction =
  225|      0|                    m_DLXProgram.m_Instructions.at(m_Processor.GetProgramCounter().unsafe());
  226|       |
  227|      0|            return current_instruction.GetSourceLine();
  228|      0|        }
  229|       |
  230|       |        // Not valid
  231|  13.5k|        return 0u;
  232|  13.5k|    }

_ZN6dlxemu12MemoryViewerC2EPNS_8EmulatorE:
   13|  7.25k|    {}

_ZN6dlxemu14RegisterViewerC2EPNS_8EmulatorE:
   19|  7.25k|    {}

_ZN6dlxemu6WindowD2Ev:
   37|  7.25k|    {
   38|  7.25k|        Shutdown();
   39|  7.25k|    }
_ZN6dlxemu6Window8ShutdownEv:
  106|  7.25k|    {
  107|  7.25k|        if (imgui_initialized)
  ------------------
  |  Branch (107:13): [True: 0, False: 7.25k]
  ------------------
  108|      0|        {
  109|      0|            ShutdownImGui();
  110|      0|        }
  111|       |
  112|  7.25k|        if (m_Window != nullptr)
  ------------------
  |  Branch (112:13): [True: 0, False: 7.25k]
  ------------------
  113|      0|        {
  114|      0|            glfwDestroyWindow(m_Window);
  115|      0|        }
  116|       |
  117|  7.25k|        if (glfw_initialized)
  ------------------
  |  Branch (117:13): [True: 0, False: 7.25k]
  ------------------
  118|      0|        {
  119|      0|            glfwTerminate();
  120|      0|        }
  121|  7.25k|    }

_ZNK3dlx15InstructionInfo15GetArgumentTypeEN3phi7integerIhEE:
  168|    531|        {
  169|    531|            PHI_ASSERT(index < 3u);
  170|       |
  171|    531|            switch (index.unsafe())
  172|    531|            {
  173|    209|                case 0:
  ------------------
  |  Branch (173:17): [True: 209, False: 322]
  ------------------
  174|    209|                    return m_Arg1Type;
  175|       |
  176|    161|                case 1:
  ------------------
  |  Branch (176:17): [True: 161, False: 370]
  ------------------
  177|    161|                    return m_Arg2Type;
  178|       |
  179|    161|                case 2:
  ------------------
  |  Branch (179:17): [True: 161, False: 370]
  ------------------
  180|    161|                    return m_Arg3Type;
  181|       |
  182|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  183|      0|                default:
  ------------------
  |  Branch (183:17): [True: 0, False: 531]
  ------------------
  184|      0|                    PHI_ASSERT_NOT_REACHED();
  185|      0|                    return m_Arg1Type;
  186|    531|#endif
  187|    531|            }
  188|    531|        }
_ZNK3dlx15InstructionInfo28GetNumberOfRequiredArgumentsEv:
  194|    161|        {
  195|    161|            phi::u8 number_of_argument_required = static_cast<std::uint8_t>(0u);
  196|       |
  197|       |            // Count the number of argument we need
  198|    161|            if (m_Arg1Type != ArgumentType::None)
  ------------------
  |  Branch (198:17): [True: 161, False: 0]
  ------------------
  199|    161|            {
  200|    161|                number_of_argument_required += static_cast<std::uint8_t>(1u);
  201|    161|            }
  202|    161|            if (m_Arg2Type != ArgumentType::None)
  ------------------
  |  Branch (202:17): [True: 15, False: 146]
  ------------------
  203|     15|            {
  204|     15|                number_of_argument_required += static_cast<std::uint8_t>(1u);
  205|     15|            }
  206|    161|            if (m_Arg3Type != ArgumentType::None)
  ------------------
  |  Branch (206:17): [True: 0, False: 161]
  ------------------
  207|      0|            {
  208|      0|                number_of_argument_required += static_cast<std::uint8_t>(1u);
  209|      0|            }
  210|       |
  211|    161|            return number_of_argument_required;
  212|    161|        }
_ZNK3dlx15InstructionInfo11GetExecutorEv:
  220|    161|        {
  221|    161|            return m_Executor;
  222|    161|        }
_ZN3dlxanENS_12ArgumentTypeES0_:
   37|     38|    {
   38|     38|        using underlying_t = phi::underlying_type_t<ArgumentType>;
   39|       |
   40|     38|        return static_cast<ArgumentType>(static_cast<underlying_t>(lhs) &
   41|     38|                                         static_cast<underlying_t>(rhs));
   42|     38|    }
_ZN3dlx20ArgumentTypeIncludesENS_12ArgumentTypeES0_:
   54|     38|    {
   55|     38|        using underlying_t = std::underlying_type_t<ArgumentType>;
   56|       |
   57|     38|        return static_cast<underlying_t>(type & test) != 0;
   58|     38|    }
_ZN3dlx9enum_nameINS_12ArgumentTypeEEENSt3__117basic_string_viewIcNS2_11char_traitsIcEEEET_:
   65|     20|    {
   66|     20|        switch (phi::to_underlying(value))
   67|     20|        {
   68|      0|#define DLX_ENUM_ARGUMENT_TYPE_IMPL(name, enum_value)                                              \
   69|      0|    case enum_value:                                                                               \
   70|      0|        return #name;
   71|       |
   72|      0|            DLX_ENUM_ARGUMENT_TYPE
  ------------------
  |  |   21|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(Unknown, 0)                                                        \
  |  |  ------------------
  |  |  |  |   69|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (69:5): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |   70|      0|        return #name;
  |  |  ------------------
  |  |   22|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(None, 1)                                                           \
  |  |  ------------------
  |  |  |  |   69|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (69:5): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |   70|      0|        return #name;
  |  |  ------------------
  |  |   23|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(IntRegister, 2)                                                    \
  |  |  ------------------
  |  |  |  |   69|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (69:5): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |   70|      0|        return #name;
  |  |  ------------------
  |  |   24|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(FloatRegister, 4)                                                  \
  |  |  ------------------
  |  |  |  |   69|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (69:5): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |   70|      0|        return #name;
  |  |  ------------------
  |  |   25|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(ImmediateInteger, 8)                                               \
  |  |  ------------------
  |  |  |  |   69|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (69:5): [True: 0, False: 20]
  |  |  |  |  ------------------
  |  |  |  |   70|      0|        return #name;
  |  |  ------------------
  |  |   26|     10|    DLX_ENUM_ARGUMENT_TYPE_IMPL(Label, 16)                                                         \
  |  |  ------------------
  |  |  |  |   69|     10|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (69:5): [True: 10, False: 10]
  |  |  |  |  ------------------
  |  |  |  |   70|     10|        return #name;
  |  |  ------------------
  |  |   27|     10|    DLX_ENUM_ARGUMENT_TYPE_IMPL(AddressDisplacement, 32)
  |  |  ------------------
  |  |  |  |   69|      3|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (69:5): [True: 3, False: 17]
  |  |  |  |  ------------------
  |  |  |  |   70|      3|        return #name;
  |  |  ------------------
  ------------------
   73|       |
   74|      0|#undef DLX_ENUM_ARGUMENT_TYPE_IMPL
   75|       |
   76|       |            // Explicitly handle the combine cases
   77|      7|            case phi::to_underlying(ArgumentType::ImmediateInteger |
  ------------------
  |  Branch (77:13): [True: 7, False: 13]
  ------------------
   78|      7|                                    ArgumentType::AddressDisplacement):
   79|      7|                return "ImmediateInteger/AddressDisplacement";
   80|       |
   81|      0|            default:
  ------------------
  |  Branch (81:13): [True: 0, False: 20]
  ------------------
   82|      0|                PHI_ASSERT_NOT_REACHED();
   83|     20|        }
   84|     20|    }

_ZN3dlx11MemoryBlock10MemoryByteC2Ev:
   17|  7.25M|            {}

_ZN3dlx20IsReservedIdentifierENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
   31|    191|    {
   32|    191|        if (StringToIntRegister(token) != IntRegisterID::None)
  ------------------
  |  Branch (32:13): [True: 2, False: 189]
  ------------------
   33|      2|        {
   34|      2|            return true;
   35|      2|        }
   36|       |
   37|    189|        if (StringToFloatRegister(token) != FloatRegisterID::None)
  ------------------
  |  Branch (37:13): [True: 0, False: 189]
  ------------------
   38|      0|        {
   39|      0|            return true;
   40|      0|        }
   41|       |
   42|    189|        if (StringToOpCode(token) != OpCode::NONE)
  ------------------
  |  Branch (42:13): [True: 2, False: 187]
  ------------------
   43|      2|        {
   44|      2|            return true;
   45|      2|        }
   46|       |
   47|    187|        if (IsFPSR(token))
  ------------------
  |  Branch (47:13): [True: 0, False: 187]
  ------------------
   48|      0|        {
   49|      0|            return true;
   50|      0|        }
   51|       |
   52|    187|        return false;
   53|    187|    }
_ZN3dlx17IsValidIdentifierENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
   56|    187|    {
   57|    187|        if (token.empty())
  ------------------
  |  Branch (57:13): [True: 0, False: 187]
  ------------------
   58|      0|        {
   59|      0|            return false;
   60|      0|        }
   61|       |
   62|    187|        const char first_char = token.at(0);
   63|       |
   64|    187|        if (token.length() == 1u)
  ------------------
  |  Branch (64:13): [True: 109, False: 78]
  ------------------
   65|    109|        {
   66|    109|            return phi::is_alpha(first_char);
   67|    109|        }
   68|       |
   69|     78|        phi::boolean just_under_scores = (first_char == '_');
   70|     78|        if (!(phi::is_alpha(first_char) || (first_char == '_')))
  ------------------
  |  Branch (70:13): [True: 39, False: 39]
  |  Branch (70:15): [True: 39, False: 39]
  |  Branch (70:44): [True: 0, False: 39]
  ------------------
   71|     39|        {
   72|     39|            return false;
   73|     39|        }
   74|       |
   75|     96|        for (std::size_t index{1u}; index < token.length(); ++index)
  ------------------
  |  Branch (75:37): [True: 79, False: 17]
  ------------------
   76|     79|        {
   77|     79|            const char c{token.at(index)};
   78|       |
   79|     79|            if (phi::is_alpha_numeric(c))
  ------------------
  |  Branch (79:17): [True: 57, False: 22]
  ------------------
   80|     57|            {
   81|     57|                just_under_scores = false;
   82|     57|            }
   83|     22|            else if (c == '_')
  ------------------
  |  Branch (83:22): [True: 0, False: 22]
  ------------------
   84|      0|            {
   85|      0|                continue;
   86|      0|            }
   87|     22|            else
   88|     22|            {
   89|     22|                return false;
   90|     22|            }
   91|     79|        }
   92|       |
   93|     17|        return !just_under_scores;
   94|     39|    }
_ZN3dlx11ParseNumberENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
  100|  3.95k|    {
  101|  3.95k|        if (token.empty())
  ------------------
  |  Branch (101:13): [True: 0, False: 3.95k]
  ------------------
  102|      0|        {
  103|      0|            return {};
  104|      0|        }
  105|       |
  106|  3.95k|        if (token.length() == 1)
  ------------------
  |  Branch (106:13): [True: 521, False: 3.43k]
  ------------------
  107|    521|        {
  108|    521|            if (phi::is_digit(token.at(0)))
  ------------------
  |  Branch (108:17): [True: 76, False: 445]
  ------------------
  109|     76|            {
  110|     76|                return static_cast<std::int16_t>(token.at(0) - '0');
  111|     76|            }
  112|       |
  113|    445|            return {};
  114|    521|        }
  115|       |
  116|       |        // Disallow trailing seperators
  117|  3.43k|        if (token.at(token.size() - 1) == '\'')
  ------------------
  |  Branch (117:13): [True: 8, False: 3.43k]
  ------------------
  118|      8|        {
  119|      8|            return {};
  120|      8|        }
  121|       |
  122|  3.43k|        std::int32_t number{0};
  123|  3.43k|        phi::boolean is_negative{false};
  124|  3.43k|        phi::boolean starts_with_zero{false};
  125|  3.43k|        phi::boolean parsing_binary{false};
  126|  3.43k|        phi::boolean parsing_octal{false};
  127|  3.43k|        phi::boolean parsing_hexadecimal{false};
  128|  3.43k|        phi::boolean parsed_something{false};
  129|  3.43k|        phi::boolean parsed_separator{false};
  130|       |
  131|       |        // TODO: Move x'th character checks out of the for loop
  132|       |
  133|  3.67k|        for (std::size_t index{0u}; index < token.length(); ++index)
  ------------------
  |  Branch (133:37): [True: 3.64k, False: 37]
  ------------------
  134|  3.64k|        {
  135|  3.64k|            const char c{token.at(index)};
  136|       |
  137|       |            // First character
  138|  3.64k|            if (index == 0u)
  ------------------
  |  Branch (138:17): [True: 3.43k, False: 210]
  ------------------
  139|  3.43k|            {
  140|  3.43k|                if (c == '+')
  ------------------
  |  Branch (140:21): [True: 10, False: 3.42k]
  ------------------
  141|     10|                {
  142|     10|                    continue;
  143|     10|                }
  144|       |
  145|  3.42k|                if (c == '-')
  ------------------
  |  Branch (145:21): [True: 22, False: 3.39k]
  ------------------
  146|     22|                {
  147|     22|                    is_negative = true;
  148|     22|                    continue;
  149|     22|                }
  150|       |
  151|  3.39k|                if (c == '0')
  ------------------
  |  Branch (151:21): [True: 103, False: 3.29k]
  ------------------
  152|    103|                {
  153|    103|                    starts_with_zero = true;
  154|    103|                    continue;
  155|    103|                }
  156|       |
  157|  3.29k|                if (c == '\'')
  ------------------
  |  Branch (157:21): [True: 12, False: 3.28k]
  ------------------
  158|     12|                {
  159|     12|                    return {};
  160|     12|                }
  161|  3.29k|            }
  162|       |
  163|       |            // Second character
  164|  3.49k|            if (index == 1u)
  ------------------
  |  Branch (164:17): [True: 164, False: 3.32k]
  ------------------
  165|    164|            {
  166|    164|                if (starts_with_zero)
  ------------------
  |  Branch (166:21): [True: 103, False: 61]
  ------------------
  167|    103|                {
  168|       |                    // Binary
  169|    103|                    if (c == 'b' || c == 'B')
  ------------------
  |  Branch (169:25): [True: 0, False: 103]
  |  Branch (169:37): [True: 2, False: 101]
  ------------------
  170|      2|                    {
  171|      2|                        parsing_binary = true;
  172|      2|                        continue;
  173|      2|                    }
  174|       |
  175|       |                    // Hexadecimal
  176|    101|                    if (c == 'x' || c == 'X')
  ------------------
  |  Branch (176:25): [True: 0, False: 101]
  |  Branch (176:37): [True: 0, False: 101]
  ------------------
  177|      0|                    {
  178|      0|                        parsing_hexadecimal = true;
  179|      0|                        continue;
  180|      0|                    }
  181|       |
  182|       |                    // Octal
  183|    101|                    parsing_octal = true;
  184|    101|                }
  185|    164|            }
  186|       |
  187|       |            // Handle seperators
  188|  3.49k|            if (c == '\'')
  ------------------
  |  Branch (188:17): [True: 3, False: 3.48k]
  ------------------
  189|      3|            {
  190|      3|                if (parsed_separator)
  ------------------
  |  Branch (190:21): [True: 0, False: 3]
  ------------------
  191|      0|                {
  192|      0|                    return {};
  193|      0|                }
  194|       |
  195|      3|                parsed_separator = true;
  196|      3|                continue;
  197|      3|            }
  198|       |
  199|       |            // Check for over/underflow
  200|  3.48k|            if (is_negative && (-number < std::numeric_limits<std::int16_t>::min()))
  ------------------
  |  Branch (200:17): [True: 23, False: 3.46k]
  |  Branch (200:32): [True: 0, False: 23]
  ------------------
  201|      0|            {
  202|       |                // Would underflow
  203|      0|                return {};
  204|      0|            }
  205|  3.48k|            if (!is_negative && (number > std::numeric_limits<std::int16_t>::max()))
  ------------------
  |  Branch (205:17): [True: 3.46k, False: 23]
  |  Branch (205:17): [True: 0, False: 3.48k]
  |  Branch (205:33): [True: 0, False: 3.46k]
  ------------------
  206|      0|            {
  207|       |                // Would overflow
  208|      0|                return {};
  209|      0|            }
  210|       |
  211|  3.48k|            parsed_separator = false;
  212|  3.48k|            parsed_something = true;
  213|       |
  214|  3.48k|            if (parsing_binary)
  ------------------
  |  Branch (214:17): [True: 2, False: 3.48k]
  ------------------
  215|      2|            {
  216|      2|                if (!phi::is_binary_digit(c))
  ------------------
  |  Branch (216:21): [True: 2, False: 0]
  ------------------
  217|      2|                {
  218|      2|                    return {};
  219|      2|                }
  220|       |
  221|      0|                number <<= 1;
  222|      0|                number |= (c - '0');
  223|      0|            }
  224|  3.48k|            else if (parsing_octal)
  ------------------
  |  Branch (224:22): [True: 130, False: 3.35k]
  ------------------
  225|    130|            {
  226|    130|                if (!phi::is_octal_digit(c))
  ------------------
  |  Branch (226:21): [True: 78, False: 52]
  ------------------
  227|     78|                {
  228|     78|                    return {};
  229|     78|                }
  230|       |
  231|     52|                number <<= 3;
  232|     52|                number |= (c - '0');
  233|     52|            }
  234|  3.35k|            else if (parsing_hexadecimal)
  ------------------
  |  Branch (234:22): [True: 0, False: 3.35k]
  ------------------
  235|      0|            {
  236|      0|                if (!phi::is_hex_digit(c))
  ------------------
  |  Branch (236:21): [True: 0, False: 0]
  ------------------
  237|      0|                {
  238|      0|                    return {};
  239|      0|                }
  240|       |
  241|      0|                number <<= 4;
  242|      0|                number |= phi::hex_digit_value(c).unsafe();
  243|      0|            }
  244|  3.35k|            else
  245|  3.35k|            {
  246|  3.35k|                if (!phi::is_digit(c))
  ------------------
  |  Branch (246:21): [True: 3.29k, False: 61]
  ------------------
  247|  3.29k|                {
  248|  3.29k|                    return {};
  249|  3.29k|                }
  250|       |
  251|       |                // Disallow leading zeros
  252|     61|                if (number == 0 && c == '0')
  ------------------
  |  Branch (252:21): [True: 38, False: 23]
  |  Branch (252:36): [True: 6, False: 32]
  ------------------
  253|      6|                {
  254|      6|                    return {};
  255|      6|                }
  256|       |
  257|     55|                number *= 10;
  258|     55|                number += (c - '0');
  259|     55|            }
  260|  3.48k|        }
  261|       |
  262|     37|        if (parsed_something)
  ------------------
  |  Branch (262:13): [True: 37, False: 0]
  ------------------
  263|     37|        {
  264|       |            // Check for over/underflow
  265|     37|            if (is_negative && (-number < std::numeric_limits<std::int16_t>::min()))
  ------------------
  |  Branch (265:17): [True: 3, False: 34]
  |  Branch (265:32): [True: 0, False: 3]
  ------------------
  266|      0|            {
  267|       |                // Would underflow
  268|      0|                return {};
  269|      0|            }
  270|     37|            if (!is_negative && (number > std::numeric_limits<std::int16_t>::max()))
  ------------------
  |  Branch (270:17): [True: 34, False: 3]
  |  Branch (270:17): [True: 0, False: 37]
  |  Branch (270:33): [True: 0, False: 34]
  ------------------
  271|      0|            {
  272|       |                // Would overflow
  273|      0|                return {};
  274|      0|            }
  275|       |
  276|     37|            if (is_negative)
  ------------------
  |  Branch (276:17): [True: 3, False: 34]
  ------------------
  277|      3|            {
  278|      3|                return static_cast<std::int16_t>(-number);
  279|      3|            }
  280|       |
  281|     34|            return static_cast<std::int16_t>(number);
  282|     37|        }
  283|       |
  284|      0|        return {};
  285|     37|    }

_ZN3dlx9enum_nameINS_5Token4TypeEEENSt3__117basic_string_viewIcNS3_11char_traitsIcEEEET_:
   85|  2.15k|    {
   86|  2.15k|        switch (value)
   87|  2.15k|        {
   88|      0|#define DLX_ENUM_TOKEN_TYPE_IMPL(name)                                                             \
   89|      0|    case Token::Type::name:                                                                        \
   90|      0|        return #name;
   91|       |
   92|      0|            DLX_ENUM_TOKEN_TYPE
  ------------------
  |  |   14|      9|    DLX_ENUM_TOKEN_TYPE_IMPL(Comment)                                                              \
  |  |  ------------------
  |  |  |  |   89|      9|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 9, False: 2.14k]
  |  |  |  |  ------------------
  |  |  |  |   90|      9|        return #name;
  |  |  ------------------
  |  |   15|      9|    DLX_ENUM_TOKEN_TYPE_IMPL(OpCode)                                                               \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 2.15k]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   16|     99|    DLX_ENUM_TOKEN_TYPE_IMPL(LabelIdentifier)                                                      \
  |  |  ------------------
  |  |  |  |   89|     99|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 99, False: 2.05k]
  |  |  |  |  ------------------
  |  |  |  |   90|     99|        return #name;
  |  |  ------------------
  |  |   17|     99|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterInt)                                                          \
  |  |  ------------------
  |  |  |  |   89|      9|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 9, False: 2.14k]
  |  |  |  |  ------------------
  |  |  |  |   90|      9|        return #name;
  |  |  ------------------
  |  |   18|      9|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterFloat)                                                        \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 2.15k]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   19|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterStatus)                                                       \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 2.15k]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   20|     54|    DLX_ENUM_TOKEN_TYPE_IMPL(Comma)                                                                \
  |  |  ------------------
  |  |  |  |   89|     54|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 54, False: 2.09k]
  |  |  |  |  ------------------
  |  |  |  |   90|     54|        return #name;
  |  |  ------------------
  |  |   21|     62|    DLX_ENUM_TOKEN_TYPE_IMPL(Colon)                                                                \
  |  |  ------------------
  |  |  |  |   89|     62|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 62, False: 2.09k]
  |  |  |  |  ------------------
  |  |  |  |   90|     62|        return #name;
  |  |  ------------------
  |  |   22|     62|    DLX_ENUM_TOKEN_TYPE_IMPL(OpenBracket)                                                          \
  |  |  ------------------
  |  |  |  |   89|     10|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 10, False: 2.14k]
  |  |  |  |  ------------------
  |  |  |  |   90|     10|        return #name;
  |  |  ------------------
  |  |   23|    708|    DLX_ENUM_TOKEN_TYPE_IMPL(ClosingBracket)                                                       \
  |  |  ------------------
  |  |  |  |   89|    708|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 708, False: 1.44k]
  |  |  |  |  ------------------
  |  |  |  |   90|    708|        return #name;
  |  |  ------------------
  |  |   24|    708|    DLX_ENUM_TOKEN_TYPE_IMPL(NewLine)                                                              \
  |  |  ------------------
  |  |  |  |   89|    180|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 180, False: 1.97k]
  |  |  |  |  ------------------
  |  |  |  |   90|    180|        return #name;
  |  |  ------------------
  |  |   25|    180|    DLX_ENUM_TOKEN_TYPE_IMPL(ImmediateInteger)                                                     \
  |  |  ------------------
  |  |  |  |   89|     15|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 15, False: 2.13k]
  |  |  |  |  ------------------
  |  |  |  |   90|     15|        return #name;
  |  |  ------------------
  |  |   26|    110|    DLX_ENUM_TOKEN_TYPE_IMPL(IntegerLiteral)                                                       \
  |  |  ------------------
  |  |  |  |   89|    110|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 110, False: 2.04k]
  |  |  |  |  ------------------
  |  |  |  |   90|    110|        return #name;
  |  |  ------------------
  |  |   27|    896|    DLX_ENUM_TOKEN_TYPE_IMPL(Unknown)
  |  |  ------------------
  |  |  |  |   89|    896|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 896, False: 1.25k]
  |  |  |  |  ------------------
  |  |  |  |   90|    896|        return #name;
  |  |  ------------------
  ------------------
   93|       |
   94|      0|#undef DLX_ENUM_TOKEN_TYPE_IMPL
   95|       |
   96|      0|            default:
  ------------------
  |  Branch (96:13): [True: 0, False: 2.15k]
  ------------------
   97|      0|                PHI_ASSERT_NOT_REACHED();
   98|  2.15k|        }
   99|  2.15k|    }

Parser.cpp:_ZNK3dlx11TokenStream19find_first_token_ifIZNS_6Parser5ParseERS0_E3$_0EEPKNS_5TokenET_:
   58|      9|        {
   59|       |#if defined(PHI_DEBUG)
   60|       |            PHI_ASSERT(m_Finialized);
   61|       |#endif
   62|       |
   63|      9|            for (const Token& token : m_Tokens)
  ------------------
  |  Branch (63:37): [True: 9, False: 0]
  ------------------
   64|      9|            {
   65|      9|                if (pred(token))
  ------------------
  |  Branch (65:21): [True: 9, False: 0]
  ------------------
   66|      9|                {
   67|      9|                    return &token;
   68|      9|                }
   69|      9|            }
   70|       |
   71|      0|            return nullptr;
   72|      9|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5Token4TypeENSt3__117basic_string_viewIcNS4_11char_traitsIcEEEERN3phi7integerImEESC_EEEvDpOT_:
   24|  1.70k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finialized);
   27|       |#endif
   28|       |
   29|  1.70k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|  1.70k|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5TokenEEEEvDpOT_:
   24|  4.09k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finialized);
   27|       |#endif
   28|       |
   29|  4.09k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|  4.09k|        }
_ZN3dlx11TokenStream12emplace_backIJRNS_5Token4TypeENSt3__117basic_string_viewIcNS5_11char_traitsIcEEEERN3phi7integerImEESD_EEEvDpOT_:
   24|    788|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finialized);
   27|       |#endif
   28|       |
   29|    788|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|    788|        }

_ZN3dlx11InstructionC2ERKNS_15InstructionInfoEN3phi7integerImEE:
   18|    161|    {}
_ZN3dlx11Instruction11SetArgumentEN3phi7integerIhEENS_19InstructionArgumentE:
   23|     10|    {
   24|     10|        PHI_ASSERT(argument_number < 3u);
   25|       |
   26|     10|        switch (argument_number.unsafe())
   27|     10|        {
   28|     10|            case 0u:
  ------------------
  |  Branch (28:13): [True: 10, False: 0]
  ------------------
   29|     10|                m_Arg1 = argument;
   30|     10|                break;
   31|      0|            case 1u:
  ------------------
  |  Branch (31:13): [True: 0, False: 10]
  ------------------
   32|      0|                m_Arg2 = argument;
   33|      0|                break;
   34|      0|            case 2u:
  ------------------
  |  Branch (34:13): [True: 0, False: 10]
  ------------------
   35|      0|                m_Arg3 = argument;
   36|      0|                break;
   37|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
   38|      0|            default:
  ------------------
  |  Branch (38:13): [True: 0, False: 10]
  ------------------
   39|      0|                PHI_ASSERT_NOT_REACHED();
   40|     10|#endif
   41|     10|        }
   42|     10|    }

_ZN3dlx19InstructionArgumentC2Ev:
   23|    493|    {}
_ZN3dlx33ConstructInstructionArgumentLabelENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
  210|     10|    {
  211|     10|        InstructionArgument arg;
  212|     10|        arg.m_Type           = ArgumentType::Label;
  213|     10|        arg.label.label_name = label_name;
  214|     10|        return arg;
  215|     10|    }

_ZN3dlx20LookUpIntructionInfoENS_6OpCodeE:
  452|    161|    {
  453|    161|        return instruction_table.at(static_cast<std::size_t>(instruction));
  454|    161|    }

_ZN3dlx11IntRegisterC2Ev:
   13|   232k|    {}
_ZN3dlx11IntRegister11SetReadOnlyEN3phi7booleanE:
   41|  7.25k|    {
   42|  7.25k|        m_IsReadOnly = read_only;
   43|  7.25k|    }

_ZN3dlx11MemoryBlockC2EN3phi7integerImEES3_:
   14|  7.25k|    {
   15|  7.25k|        m_Values.resize(starting_size.unsafe());
   16|  7.25k|    }

_ZN3dlx14StringToOpCodeENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
   23|  4.01k|    {
   24|  4.01k|        switch (token.length())
   25|  4.01k|        {
   26|       |            // 1 character OpCodes
   27|    556|            case 1: {
  ------------------
  |  Branch (27:13): [True: 556, False: 3.45k]
  ------------------
   28|    556|                char c1 = token[0];
   29|    556|                if (ice(c1, 'J'))
  ------------------
  |  Branch (29:21): [True: 158, False: 398]
  ------------------
   30|    158|                {
   31|    158|                    return OpCode::J;
   32|    158|                }
   33|    398|                break;
   34|    556|            }
   35|       |
   36|       |            // 2 character OpCodes
   37|  1.00k|            case 2: {
  ------------------
  |  Branch (37:13): [True: 1.00k, False: 3.00k]
  ------------------
   38|  1.00k|                char c1 = token[0];
   39|  1.00k|                char c2 = token[1];
   40|       |
   41|  1.00k|                switch (c1)
  ------------------
  |  Branch (41:25): [True: 916, False: 88]
  ------------------
   42|  1.00k|                {
   43|     20|                    case 'J':
  ------------------
  |  Branch (43:21): [True: 20, False: 984]
  ------------------
   44|     41|                    case 'j':
  ------------------
  |  Branch (44:21): [True: 21, False: 983]
  ------------------
   45|     41|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (45:29): [True: 3, False: 38]
  ------------------
   46|      3|                        {
   47|      3|                            return OpCode::JR;
   48|      3|                        }
   49|     38|                        break;
   50|       |
   51|     38|                    case 'L':
  ------------------
  |  Branch (51:21): [True: 14, False: 990]
  ------------------
   52|     14|                    case 'l':
  ------------------
  |  Branch (52:21): [True: 0, False: 1.00k]
  ------------------
   53|     14|                        switch (c2)
  ------------------
  |  Branch (53:33): [True: 12, False: 2]
  ------------------
   54|     14|                        {
   55|      1|                            case 'B':
  ------------------
  |  Branch (55:29): [True: 1, False: 13]
  ------------------
   56|      2|                            case 'b':
  ------------------
  |  Branch (56:29): [True: 1, False: 13]
  ------------------
   57|      2|                                return OpCode::LB;
   58|      0|                            case 'D':
  ------------------
  |  Branch (58:29): [True: 0, False: 14]
  ------------------
   59|      0|                            case 'd':
  ------------------
  |  Branch (59:29): [True: 0, False: 14]
  ------------------
   60|      0|                                return OpCode::LD;
   61|      0|                            case 'F':
  ------------------
  |  Branch (61:29): [True: 0, False: 14]
  ------------------
   62|      0|                            case 'f':
  ------------------
  |  Branch (62:29): [True: 0, False: 14]
  ------------------
   63|      0|                                return OpCode::LF;
   64|      0|                            case 'H':
  ------------------
  |  Branch (64:29): [True: 0, False: 14]
  ------------------
   65|      0|                            case 'h':
  ------------------
  |  Branch (65:29): [True: 0, False: 14]
  ------------------
   66|      0|                                return OpCode::LH;
   67|      0|                            case 'W':
  ------------------
  |  Branch (67:29): [True: 0, False: 14]
  ------------------
   68|      0|                            case 'w':
  ------------------
  |  Branch (68:29): [True: 0, False: 14]
  ------------------
   69|      0|                                return OpCode::LW;
   70|     14|                        }
   71|     12|                        break;
   72|     12|                    case 'O':
  ------------------
  |  Branch (72:21): [True: 1, False: 1.00k]
  ------------------
   73|     13|                    case 'o':
  ------------------
  |  Branch (73:21): [True: 12, False: 992]
  ------------------
   74|     13|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (74:29): [True: 0, False: 13]
  ------------------
   75|      0|                        {
   76|      0|                            return OpCode::OR;
   77|      0|                        }
   78|     13|                        break;
   79|     13|                    case 'S':
  ------------------
  |  Branch (79:21): [True: 12, False: 992]
  ------------------
   80|     20|                    case 's':
  ------------------
  |  Branch (80:21): [True: 8, False: 996]
  ------------------
   81|     20|                        switch (c2)
  ------------------
  |  Branch (81:33): [True: 7, False: 13]
  ------------------
   82|     20|                        {
   83|      1|                            case 'B':
  ------------------
  |  Branch (83:29): [True: 1, False: 19]
  ------------------
   84|      1|                            case 'b':
  ------------------
  |  Branch (84:29): [True: 0, False: 20]
  ------------------
   85|      1|                                return OpCode::SB;
   86|      1|                            case 'D':
  ------------------
  |  Branch (86:29): [True: 1, False: 19]
  ------------------
   87|      1|                            case 'd':
  ------------------
  |  Branch (87:29): [True: 0, False: 20]
  ------------------
   88|      1|                                return OpCode::SD;
   89|     11|                            case 'F':
  ------------------
  |  Branch (89:29): [True: 11, False: 9]
  ------------------
   90|     11|                            case 'f':
  ------------------
  |  Branch (90:29): [True: 0, False: 20]
  ------------------
   91|     11|                                return OpCode::SF;
   92|      0|                            case 'H':
  ------------------
  |  Branch (92:29): [True: 0, False: 20]
  ------------------
   93|      0|                            case 'h':
  ------------------
  |  Branch (93:29): [True: 0, False: 20]
  ------------------
   94|      0|                                return OpCode::SH;
   95|      0|                            case 'w':
  ------------------
  |  Branch (95:29): [True: 0, False: 20]
  ------------------
   96|      0|                            case 'W':
  ------------------
  |  Branch (96:29): [True: 0, False: 20]
  ------------------
   97|      0|                                return OpCode::SW;
   98|     20|                        }
   99|      7|                        break;
  100|  1.00k|                }
  101|    986|                break;
  102|  1.00k|            }
  103|       |
  104|       |            // 3 character OpCodes
  105|    986|            case 3: {
  ------------------
  |  Branch (105:13): [True: 775, False: 3.23k]
  ------------------
  106|    775|                char c1 = token[0];
  107|    775|                char c2 = token[1];
  108|    775|                char c3 = token[2];
  109|       |
  110|    775|                switch (c1)
  ------------------
  |  Branch (110:25): [True: 671, False: 104]
  ------------------
  111|    775|                {
  112|      3|                    case 'A':
  ------------------
  |  Branch (112:21): [True: 3, False: 772]
  ------------------
  113|      4|                    case 'a':
  ------------------
  |  Branch (113:21): [True: 1, False: 774]
  ------------------
  114|      4|                        if (ice(c2, 'D') && ice(c3, 'D'))
  ------------------
  |  Branch (114:29): [True: 0, False: 4]
  |  Branch (114:29): [True: 0, False: 4]
  |  Branch (114:45): [True: 0, False: 0]
  ------------------
  115|      0|                        {
  116|      0|                            return OpCode::ADD;
  117|      0|                        }
  118|      4|                        else if (ice(c2, 'N') && ice(c3, 'D'))
  ------------------
  |  Branch (118:34): [True: 0, False: 4]
  |  Branch (118:34): [True: 0, False: 4]
  |  Branch (118:50): [True: 0, False: 0]
  ------------------
  119|      0|                        {
  120|      0|                            return OpCode::AND;
  121|      0|                        }
  122|      4|                        break;
  123|       |
  124|     16|                    case 'D':
  ------------------
  |  Branch (124:21): [True: 16, False: 759]
  ------------------
  125|     16|                    case 'd':
  ------------------
  |  Branch (125:21): [True: 0, False: 775]
  ------------------
  126|     16|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (126:29): [True: 0, False: 16]
  |  Branch (126:29): [True: 0, False: 16]
  |  Branch (126:45): [True: 0, False: 0]
  ------------------
  127|      0|                        {
  128|      0|                            return OpCode::DIV;
  129|      0|                        }
  130|     16|                        break;
  131|       |
  132|     16|                    case 'E':
  ------------------
  |  Branch (132:21): [True: 4, False: 771]
  ------------------
  133|      4|                    case 'e':
  ------------------
  |  Branch (133:21): [True: 0, False: 775]
  ------------------
  134|      4|                        if (ice(c2, 'Q'))
  ------------------
  |  Branch (134:29): [True: 0, False: 4]
  ------------------
  135|      0|                        {
  136|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (136:33): [True: 0, False: 0]
  ------------------
  137|      0|                            {
  138|      0|                                return OpCode::EQD;
  139|      0|                            }
  140|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (140:38): [True: 0, False: 0]
  ------------------
  141|      0|                            {
  142|      0|                                return OpCode::EQF;
  143|      0|                            }
  144|      0|                        }
  145|      4|                        break;
  146|       |
  147|      4|                    case 'G':
  ------------------
  |  Branch (147:21): [True: 0, False: 775]
  ------------------
  148|      7|                    case 'g':
  ------------------
  |  Branch (148:21): [True: 7, False: 768]
  ------------------
  149|      7|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (149:29): [True: 0, False: 7]
  ------------------
  150|      0|                        {
  151|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (151:33): [True: 0, False: 0]
  ------------------
  152|      0|                            {
  153|      0|                                return OpCode::GED;
  154|      0|                            }
  155|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (155:38): [True: 0, False: 0]
  ------------------
  156|      0|                            {
  157|      0|                                return OpCode::GEF;
  158|      0|                            }
  159|      0|                        }
  160|      7|                        else if (ice(c2, 'T'))
  ------------------
  |  Branch (160:34): [True: 0, False: 7]
  ------------------
  161|      0|                        {
  162|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (162:33): [True: 0, False: 0]
  ------------------
  163|      0|                            {
  164|      0|                                return OpCode::GTD;
  165|      0|                            }
  166|      0|                            if (ice(c3, 'F'))
  ------------------
  |  Branch (166:33): [True: 0, False: 0]
  ------------------
  167|      0|                            {
  168|      0|                                return OpCode::GTF;
  169|      0|                            }
  170|      0|                        }
  171|      7|                        break;
  172|       |
  173|     11|                    case 'J':
  ------------------
  |  Branch (173:21): [True: 11, False: 764]
  ------------------
  174|     21|                    case 'j':
  ------------------
  |  Branch (174:21): [True: 10, False: 765]
  ------------------
  175|     21|                        if (ice(c2, 'A') && ice(c3, 'L'))
  ------------------
  |  Branch (175:29): [True: 0, False: 21]
  |  Branch (175:29): [True: 0, False: 21]
  |  Branch (175:45): [True: 0, False: 0]
  ------------------
  176|      0|                        {
  177|      0|                            return OpCode::JAL;
  178|      0|                        }
  179|     21|                        break;
  180|       |
  181|     21|                    case 'L':
  ------------------
  |  Branch (181:21): [True: 19, False: 756]
  ------------------
  182|     22|                    case 'l':
  ------------------
  |  Branch (182:21): [True: 3, False: 772]
  ------------------
  183|     22|                        switch (c2)
  ------------------
  |  Branch (183:33): [True: 22, False: 0]
  ------------------
  184|     22|                        {
  185|      0|                            case 'B':
  ------------------
  |  Branch (185:29): [True: 0, False: 22]
  ------------------
  186|      0|                            case 'b':
  ------------------
  |  Branch (186:29): [True: 0, False: 22]
  ------------------
  187|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (187:37): [True: 0, False: 0]
  ------------------
  188|      0|                                {
  189|      0|                                    return OpCode::LBU;
  190|      0|                                }
  191|      0|                                break;
  192|       |
  193|      0|                            case 'E':
  ------------------
  |  Branch (193:29): [True: 0, False: 22]
  ------------------
  194|      0|                            case 'e':
  ------------------
  |  Branch (194:29): [True: 0, False: 22]
  ------------------
  195|      0|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (195:37): [True: 0, False: 0]
  ------------------
  196|      0|                                {
  197|      0|                                    return OpCode::LED;
  198|      0|                                }
  199|      0|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (199:42): [True: 0, False: 0]
  ------------------
  200|      0|                                {
  201|      0|                                    return OpCode::LEF;
  202|      0|                                }
  203|      0|                                break;
  204|       |
  205|      0|                            case 'H':
  ------------------
  |  Branch (205:29): [True: 0, False: 22]
  ------------------
  206|      0|                            case 'h':
  ------------------
  |  Branch (206:29): [True: 0, False: 22]
  ------------------
  207|      0|                                if (ice(c3, 'I'))
  ------------------
  |  Branch (207:37): [True: 0, False: 0]
  ------------------
  208|      0|                                {
  209|      0|                                    return OpCode::LHI;
  210|      0|                                }
  211|      0|                                else if (ice(c3, 'U'))
  ------------------
  |  Branch (211:42): [True: 0, False: 0]
  ------------------
  212|      0|                                {
  213|      0|                                    return OpCode::LHU;
  214|      0|                                }
  215|      0|                                break;
  216|       |
  217|      0|                            case 'T':
  ------------------
  |  Branch (217:29): [True: 0, False: 22]
  ------------------
  218|      0|                            case 't':
  ------------------
  |  Branch (218:29): [True: 0, False: 22]
  ------------------
  219|      0|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (219:37): [True: 0, False: 0]
  ------------------
  220|      0|                                {
  221|      0|                                    return OpCode::LTD;
  222|      0|                                }
  223|      0|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (223:42): [True: 0, False: 0]
  ------------------
  224|      0|                                {
  225|      0|                                    return OpCode::LTF;
  226|      0|                                }
  227|      0|                                break;
  228|       |
  229|      0|                            case 'W':
  ------------------
  |  Branch (229:29): [True: 0, False: 22]
  ------------------
  230|      0|                            case 'w':
  ------------------
  |  Branch (230:29): [True: 0, False: 22]
  ------------------
  231|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (231:37): [True: 0, False: 0]
  ------------------
  232|      0|                                {
  233|      0|                                    return OpCode::LWU;
  234|      0|                                }
  235|      0|                                break;
  236|     22|                        }
  237|     22|                        break;
  238|       |
  239|     22|                    case 'N':
  ------------------
  |  Branch (239:21): [True: 0, False: 775]
  ------------------
  240|      2|                    case 'n':
  ------------------
  |  Branch (240:21): [True: 2, False: 773]
  ------------------
  241|      2|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (241:29): [True: 0, False: 2]
  ------------------
  242|      0|                        {
  243|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (243:33): [True: 0, False: 0]
  ------------------
  244|      0|                            {
  245|      0|                                return OpCode::NED;
  246|      0|                            }
  247|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (247:38): [True: 0, False: 0]
  ------------------
  248|      0|                            {
  249|      0|                                return OpCode::NEF;
  250|      0|                            }
  251|      0|                        }
  252|      2|                        else if (ice(c2, 'O') && ice(c3, 'P'))
  ------------------
  |  Branch (252:34): [True: 1, False: 1]
  |  Branch (252:34): [True: 0, False: 2]
  |  Branch (252:50): [True: 0, False: 1]
  ------------------
  253|      0|                        {
  254|      0|                            return OpCode::NOP;
  255|      0|                        }
  256|       |
  257|      2|                        break;
  258|       |
  259|      3|                    case 'O':
  ------------------
  |  Branch (259:21): [True: 3, False: 772]
  ------------------
  260|      4|                    case 'o':
  ------------------
  |  Branch (260:21): [True: 1, False: 774]
  ------------------
  261|      4|                        if (ice(c2, 'R') && ice(c3, 'I'))
  ------------------
  |  Branch (261:29): [True: 0, False: 4]
  |  Branch (261:29): [True: 0, False: 4]
  |  Branch (261:45): [True: 0, False: 0]
  ------------------
  262|      0|                        {
  263|      0|                            return OpCode::ORI;
  264|      0|                        }
  265|      4|                        break;
  266|       |
  267|      6|                    case 'S':
  ------------------
  |  Branch (267:21): [True: 6, False: 769]
  ------------------
  268|     15|                    case 's':
  ------------------
  |  Branch (268:21): [True: 9, False: 766]
  ------------------
  269|     15|                        switch (c2)
  ------------------
  |  Branch (269:33): [True: 12, False: 3]
  ------------------
  270|     15|                        {
  271|      1|                            case 'B':
  ------------------
  |  Branch (271:29): [True: 1, False: 14]
  ------------------
  272|      1|                            case 'b':
  ------------------
  |  Branch (272:29): [True: 0, False: 15]
  ------------------
  273|      1|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (273:37): [True: 0, False: 1]
  ------------------
  274|      0|                                {
  275|      0|                                    return OpCode::SBU;
  276|      0|                                }
  277|      1|                                break;
  278|       |
  279|      1|                            case 'E':
  ------------------
  |  Branch (279:29): [True: 0, False: 15]
  ------------------
  280|      0|                            case 'e':
  ------------------
  |  Branch (280:29): [True: 0, False: 15]
  ------------------
  281|      0|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (281:37): [True: 0, False: 0]
  ------------------
  282|      0|                                {
  283|      0|                                    return OpCode::SEQ;
  284|      0|                                }
  285|      0|                                break;
  286|       |
  287|      0|                            case 'G':
  ------------------
  |  Branch (287:29): [True: 0, False: 15]
  ------------------
  288|      0|                            case 'g':
  ------------------
  |  Branch (288:29): [True: 0, False: 15]
  ------------------
  289|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (289:37): [True: 0, False: 0]
  ------------------
  290|      0|                                {
  291|      0|                                    return OpCode::SGE;
  292|      0|                                }
  293|      0|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (293:42): [True: 0, False: 0]
  ------------------
  294|      0|                                {
  295|      0|                                    return OpCode::SGT;
  296|      0|                                }
  297|      0|                                break;
  298|       |
  299|      0|                            case 'H':
  ------------------
  |  Branch (299:29): [True: 0, False: 15]
  ------------------
  300|      1|                            case 'h':
  ------------------
  |  Branch (300:29): [True: 1, False: 14]
  ------------------
  301|      1|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (301:37): [True: 0, False: 1]
  ------------------
  302|      0|                                {
  303|      0|                                    return OpCode::SHU;
  304|      0|                                }
  305|      1|                                break;
  306|       |
  307|      1|                            case 'L':
  ------------------
  |  Branch (307:29): [True: 0, False: 15]
  ------------------
  308|      0|                            case 'l':
  ------------------
  |  Branch (308:29): [True: 0, False: 15]
  ------------------
  309|      0|                                switch (c3)
  ------------------
  |  Branch (309:41): [True: 0, False: 0]
  ------------------
  310|      0|                                {
  311|      0|                                    case 'A':
  ------------------
  |  Branch (311:37): [True: 0, False: 0]
  ------------------
  312|      0|                                    case 'a':
  ------------------
  |  Branch (312:37): [True: 0, False: 0]
  ------------------
  313|      0|                                        return OpCode::SLA;
  314|       |
  315|      0|                                    case 'E':
  ------------------
  |  Branch (315:37): [True: 0, False: 0]
  ------------------
  316|      0|                                    case 'e':
  ------------------
  |  Branch (316:37): [True: 0, False: 0]
  ------------------
  317|      0|                                        return OpCode::SLE;
  318|       |
  319|      0|                                    case 'L':
  ------------------
  |  Branch (319:37): [True: 0, False: 0]
  ------------------
  320|      0|                                    case 'l':
  ------------------
  |  Branch (320:37): [True: 0, False: 0]
  ------------------
  321|      0|                                        return OpCode::SLL;
  322|       |
  323|      0|                                    case 'T':
  ------------------
  |  Branch (323:37): [True: 0, False: 0]
  ------------------
  324|      0|                                    case 't':
  ------------------
  |  Branch (324:37): [True: 0, False: 0]
  ------------------
  325|      0|                                        return OpCode::SLT;
  326|      0|                                }
  327|      0|                                break;
  328|       |
  329|      0|                            case 'N':
  ------------------
  |  Branch (329:29): [True: 0, False: 15]
  ------------------
  330|      0|                            case 'n':
  ------------------
  |  Branch (330:29): [True: 0, False: 15]
  ------------------
  331|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (331:37): [True: 0, False: 0]
  ------------------
  332|      0|                                {
  333|      0|                                    return OpCode::SNE;
  334|      0|                                }
  335|      0|                                break;
  336|       |
  337|      1|                            case 'R':
  ------------------
  |  Branch (337:29): [True: 1, False: 14]
  ------------------
  338|      1|                            case 'r':
  ------------------
  |  Branch (338:29): [True: 0, False: 15]
  ------------------
  339|      1|                                if (ice(c3, 'A'))
  ------------------
  |  Branch (339:37): [True: 0, False: 1]
  ------------------
  340|      0|                                {
  341|      0|                                    return OpCode::SRA;
  342|      0|                                }
  343|      1|                                else if (ice(c3, 'L'))
  ------------------
  |  Branch (343:42): [True: 0, False: 1]
  ------------------
  344|      0|                                {
  345|      0|                                    return OpCode::SRL;
  346|      0|                                }
  347|      1|                                break;
  348|       |
  349|      1|                            case 'U':
  ------------------
  |  Branch (349:29): [True: 0, False: 15]
  ------------------
  350|      0|                            case 'u':
  ------------------
  |  Branch (350:29): [True: 0, False: 15]
  ------------------
  351|      0|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (351:37): [True: 0, False: 0]
  ------------------
  352|      0|                                {
  353|      0|                                    return OpCode::SUB;
  354|      0|                                }
  355|      0|                                break;
  356|       |
  357|      0|                            case 'W':
  ------------------
  |  Branch (357:29): [True: 0, False: 15]
  ------------------
  358|      0|                            case 'w':
  ------------------
  |  Branch (358:29): [True: 0, False: 15]
  ------------------
  359|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (359:37): [True: 0, False: 0]
  ------------------
  360|      0|                                {
  361|      0|                                    return OpCode::SWU;
  362|      0|                                }
  363|      0|                                break;
  364|     15|                        }
  365|       |
  366|     19|                    case 'X':
  ------------------
  |  Branch (366:21): [True: 4, False: 771]
  ------------------
  367|     24|                    case 'x':
  ------------------
  |  Branch (367:21): [True: 5, False: 770]
  ------------------
  368|     24|                        if (ice(c2, 'O') && ice(c3, 'R'))
  ------------------
  |  Branch (368:29): [True: 1, False: 23]
  |  Branch (368:29): [True: 0, False: 24]
  |  Branch (368:45): [True: 0, False: 1]
  ------------------
  369|      0|                        {
  370|      0|                            return OpCode::XOR;
  371|      0|                        }
  372|     24|                        break;
  373|    775|                }
  374|    775|                break;
  375|    775|            }
  376|       |
  377|       |            // 4 character OpCodes
  378|    873|            case 4: {
  ------------------
  |  Branch (378:13): [True: 873, False: 3.13k]
  ------------------
  379|    873|                char c1 = token[0];
  380|    873|                char c2 = token[1];
  381|    873|                char c3 = token[2];
  382|    873|                char c4 = token[3];
  383|       |
  384|    873|                switch (c1)
  ------------------
  |  Branch (384:25): [True: 757, False: 116]
  ------------------
  385|    873|                {
  386|     15|                    case 'A':
  ------------------
  |  Branch (386:21): [True: 15, False: 858]
  ------------------
  387|     18|                    case 'a':
  ------------------
  |  Branch (387:21): [True: 3, False: 870]
  ------------------
  388|     18|                        switch (c2)
  ------------------
  |  Branch (388:33): [True: 18, False: 0]
  ------------------
  389|     18|                        {
  390|      0|                            case 'D':
  ------------------
  |  Branch (390:29): [True: 0, False: 18]
  ------------------
  391|      0|                            case 'd':
  ------------------
  |  Branch (391:29): [True: 0, False: 18]
  ------------------
  392|      0|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (392:37): [True: 0, False: 0]
  ------------------
  393|      0|                                {
  394|      0|                                    switch (c4)
  ------------------
  |  Branch (394:45): [True: 0, False: 0]
  ------------------
  395|      0|                                    {
  396|      0|                                        case 'D':
  ------------------
  |  Branch (396:41): [True: 0, False: 0]
  ------------------
  397|      0|                                        case 'd':
  ------------------
  |  Branch (397:41): [True: 0, False: 0]
  ------------------
  398|      0|                                            return OpCode::ADDD;
  399|       |
  400|      0|                                        case 'F':
  ------------------
  |  Branch (400:41): [True: 0, False: 0]
  ------------------
  401|      0|                                        case 'f':
  ------------------
  |  Branch (401:41): [True: 0, False: 0]
  ------------------
  402|      0|                                            return OpCode::ADDF;
  403|       |
  404|      0|                                        case 'I':
  ------------------
  |  Branch (404:41): [True: 0, False: 0]
  ------------------
  405|      0|                                        case 'i':
  ------------------
  |  Branch (405:41): [True: 0, False: 0]
  ------------------
  406|      0|                                            return OpCode::ADDI;
  407|       |
  408|      0|                                        case 'U':
  ------------------
  |  Branch (408:41): [True: 0, False: 0]
  ------------------
  409|      0|                                        case 'u':
  ------------------
  |  Branch (409:41): [True: 0, False: 0]
  ------------------
  410|      0|                                            return OpCode::ADDU;
  411|      0|                                    }
  412|      0|                                }
  413|      0|                                break;
  414|       |
  415|      0|                            case 'N':
  ------------------
  |  Branch (415:29): [True: 0, False: 18]
  ------------------
  416|      0|                            case 'n':
  ------------------
  |  Branch (416:29): [True: 0, False: 18]
  ------------------
  417|      0|                                if (ice(c3, 'D') && ice(c4, 'I'))
  ------------------
  |  Branch (417:37): [True: 0, False: 0]
  |  Branch (417:37): [True: 0, False: 0]
  |  Branch (417:53): [True: 0, False: 0]
  ------------------
  418|      0|                                {
  419|      0|                                    return OpCode::ANDI;
  420|      0|                                }
  421|       |
  422|      0|                                break;
  423|     18|                        }
  424|     18|                        break;
  425|       |
  426|     18|                    case 'B':
  ------------------
  |  Branch (426:21): [True: 16, False: 857]
  ------------------
  427|     24|                    case 'b':
  ------------------
  |  Branch (427:21): [True: 8, False: 865]
  ------------------
  428|     24|                        switch (c2)
  ------------------
  |  Branch (428:33): [True: 24, False: 0]
  ------------------
  429|     24|                        {
  430|      0|                            case 'E':
  ------------------
  |  Branch (430:29): [True: 0, False: 24]
  ------------------
  431|      0|                            case 'e':
  ------------------
  |  Branch (431:29): [True: 0, False: 24]
  ------------------
  432|      0|                                if (ice(c3, 'Q') && ice(c4, 'Z'))
  ------------------
  |  Branch (432:37): [True: 0, False: 0]
  |  Branch (432:37): [True: 0, False: 0]
  |  Branch (432:53): [True: 0, False: 0]
  ------------------
  433|      0|                                {
  434|      0|                                    return OpCode::BEQZ;
  435|      0|                                }
  436|      0|                                break;
  437|       |
  438|      0|                            case 'F':
  ------------------
  |  Branch (438:29): [True: 0, False: 24]
  ------------------
  439|      0|                            case 'f':
  ------------------
  |  Branch (439:29): [True: 0, False: 24]
  ------------------
  440|      0|                                if (ice(c3, 'P'))
  ------------------
  |  Branch (440:37): [True: 0, False: 0]
  ------------------
  441|      0|                                {
  442|      0|                                    if (ice(c4, 'F'))
  ------------------
  |  Branch (442:41): [True: 0, False: 0]
  ------------------
  443|      0|                                    {
  444|      0|                                        return OpCode::BFPF;
  445|      0|                                    }
  446|      0|                                    else if (ice(c4, 'T'))
  ------------------
  |  Branch (446:46): [True: 0, False: 0]
  ------------------
  447|      0|                                    {
  448|      0|                                        return OpCode::BFPT;
  449|      0|                                    }
  450|      0|                                }
  451|      0|                                break;
  452|       |
  453|      0|                            case 'N':
  ------------------
  |  Branch (453:29): [True: 0, False: 24]
  ------------------
  454|      0|                            case 'n':
  ------------------
  |  Branch (454:29): [True: 0, False: 24]
  ------------------
  455|      0|                                if (ice(c3, 'E') && ice(c4, 'Z'))
  ------------------
  |  Branch (455:37): [True: 0, False: 0]
  |  Branch (455:37): [True: 0, False: 0]
  |  Branch (455:53): [True: 0, False: 0]
  ------------------
  456|      0|                                {
  457|      0|                                    return OpCode::BNEZ;
  458|      0|                                }
  459|     24|                        }
  460|     24|                        break;
  461|       |
  462|     24|                    case 'D':
  ------------------
  |  Branch (462:21): [True: 10, False: 863]
  ------------------
  463|     13|                    case 'd':
  ------------------
  |  Branch (463:21): [True: 3, False: 870]
  ------------------
  464|     13|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (464:29): [True: 0, False: 13]
  |  Branch (464:29): [True: 0, False: 13]
  |  Branch (464:45): [True: 0, False: 0]
  ------------------
  465|      0|                        {
  466|      0|                            switch (c4)
  ------------------
  |  Branch (466:37): [True: 0, False: 0]
  ------------------
  467|      0|                            {
  468|      0|                                case 'D':
  ------------------
  |  Branch (468:33): [True: 0, False: 0]
  ------------------
  469|      0|                                case 'd':
  ------------------
  |  Branch (469:33): [True: 0, False: 0]
  ------------------
  470|      0|                                    return OpCode::DIVD;
  471|       |
  472|      0|                                case 'F':
  ------------------
  |  Branch (472:33): [True: 0, False: 0]
  ------------------
  473|      0|                                case 'f':
  ------------------
  |  Branch (473:33): [True: 0, False: 0]
  ------------------
  474|      0|                                    return OpCode::DIVF;
  475|       |
  476|      0|                                case 'I':
  ------------------
  |  Branch (476:33): [True: 0, False: 0]
  ------------------
  477|      0|                                case 'i':
  ------------------
  |  Branch (477:33): [True: 0, False: 0]
  ------------------
  478|      0|                                    return OpCode::DIVI;
  479|       |
  480|      0|                                case 'U':
  ------------------
  |  Branch (480:33): [True: 0, False: 0]
  ------------------
  481|      0|                                case 'u':
  ------------------
  |  Branch (481:33): [True: 0, False: 0]
  ------------------
  482|      0|                                    return OpCode::DIVU;
  483|      0|                            }
  484|      0|                        }
  485|     13|                        break;
  486|       |
  487|     13|                    case 'H':
  ------------------
  |  Branch (487:21): [True: 1, False: 872]
  ------------------
  488|      1|                    case 'h':
  ------------------
  |  Branch (488:21): [True: 0, False: 873]
  ------------------
  489|      1|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (489:29): [True: 0, False: 1]
  |  Branch (489:29): [True: 0, False: 1]
  |  Branch (489:45): [True: 0, False: 0]
  |  Branch (489:61): [True: 0, False: 0]
  ------------------
  490|      0|                        {
  491|      0|                            return OpCode::HALT;
  492|      0|                        }
  493|      1|                        break;
  494|       |
  495|      6|                    case 'J':
  ------------------
  |  Branch (495:21): [True: 6, False: 867]
  ------------------
  496|     25|                    case 'j':
  ------------------
  |  Branch (496:21): [True: 19, False: 854]
  ------------------
  497|     25|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'R'))
  ------------------
  |  Branch (497:29): [True: 0, False: 25]
  |  Branch (497:29): [True: 0, False: 25]
  |  Branch (497:45): [True: 0, False: 0]
  |  Branch (497:61): [True: 0, False: 0]
  ------------------
  498|      0|                        {
  499|      0|                            return OpCode::JALR;
  500|      0|                        }
  501|     25|                        break;
  502|       |
  503|     25|                    case 'M':
  ------------------
  |  Branch (503:21): [True: 10, False: 863]
  ------------------
  504|     11|                    case 'm':
  ------------------
  |  Branch (504:21): [True: 1, False: 872]
  ------------------
  505|     11|                        if (ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (505:29): [True: 0, False: 11]
  |  Branch (505:29): [True: 0, False: 11]
  |  Branch (505:45): [True: 0, False: 0]
  ------------------
  506|      0|                        {
  507|      0|                            if (ice(c4, 'D'))
  ------------------
  |  Branch (507:33): [True: 0, False: 0]
  ------------------
  508|      0|                            {
  509|      0|                                return OpCode::MOVD;
  510|      0|                            }
  511|      0|                            else if (ice(c4, 'F'))
  ------------------
  |  Branch (511:38): [True: 0, False: 0]
  ------------------
  512|      0|                            {
  513|      0|                                return OpCode::MOVF;
  514|      0|                            }
  515|      0|                        }
  516|     11|                        else if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (516:34): [True: 0, False: 11]
  |  Branch (516:34): [True: 0, False: 11]
  |  Branch (516:50): [True: 0, False: 0]
  |  Branch (516:66): [True: 0, False: 0]
  ------------------
  517|      0|                        {
  518|      0|                            return OpCode::MULT;
  519|      0|                        }
  520|     11|                        break;
  521|       |
  522|     11|                    case 'S':
  ------------------
  |  Branch (522:21): [True: 11, False: 862]
  ------------------
  523|     20|                    case 's':
  ------------------
  |  Branch (523:21): [True: 9, False: 864]
  ------------------
  524|     20|                        switch (c2)
  ------------------
  |  Branch (524:33): [True: 19, False: 1]
  ------------------
  525|     20|                        {
  526|      0|                            case 'E':
  ------------------
  |  Branch (526:29): [True: 0, False: 20]
  ------------------
  527|      0|                            case 'e':
  ------------------
  |  Branch (527:29): [True: 0, False: 20]
  ------------------
  528|      0|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (528:37): [True: 0, False: 0]
  ------------------
  529|      0|                                {
  530|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (530:41): [True: 0, False: 0]
  ------------------
  531|      0|                                    {
  532|      0|                                        return OpCode::SEQI;
  533|      0|                                    }
  534|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (534:46): [True: 0, False: 0]
  ------------------
  535|      0|                                    {
  536|      0|                                        return OpCode::SEQU;
  537|      0|                                    }
  538|      0|                                }
  539|      0|                                break;
  540|       |
  541|      0|                            case 'G':
  ------------------
  |  Branch (541:29): [True: 0, False: 20]
  ------------------
  542|      0|                            case 'g':
  ------------------
  |  Branch (542:29): [True: 0, False: 20]
  ------------------
  543|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (543:37): [True: 0, False: 0]
  ------------------
  544|      0|                                {
  545|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (545:41): [True: 0, False: 0]
  ------------------
  546|      0|                                    {
  547|      0|                                        return OpCode::SGEI;
  548|      0|                                    }
  549|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (549:46): [True: 0, False: 0]
  ------------------
  550|      0|                                    {
  551|      0|                                        return OpCode::SGEU;
  552|      0|                                    }
  553|      0|                                }
  554|      0|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (554:42): [True: 0, False: 0]
  ------------------
  555|      0|                                {
  556|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (556:41): [True: 0, False: 0]
  ------------------
  557|      0|                                    {
  558|      0|                                        return OpCode::SGTI;
  559|      0|                                    }
  560|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (560:46): [True: 0, False: 0]
  ------------------
  561|      0|                                    {
  562|      0|                                        return OpCode::SGTU;
  563|      0|                                    }
  564|      0|                                }
  565|      0|                                break;
  566|       |
  567|      0|                            case 'L':
  ------------------
  |  Branch (567:29): [True: 0, False: 20]
  ------------------
  568|      0|                            case 'l':
  ------------------
  |  Branch (568:29): [True: 0, False: 20]
  ------------------
  569|      0|                                switch (c3)
  ------------------
  |  Branch (569:41): [True: 0, False: 0]
  ------------------
  570|      0|                                {
  571|      0|                                    case 'A':
  ------------------
  |  Branch (571:37): [True: 0, False: 0]
  ------------------
  572|      0|                                    case 'a':
  ------------------
  |  Branch (572:37): [True: 0, False: 0]
  ------------------
  573|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (573:45): [True: 0, False: 0]
  ------------------
  574|      0|                                        {
  575|      0|                                            return OpCode::SLAI;
  576|      0|                                        }
  577|      0|                                        break;
  578|       |
  579|      0|                                    case 'E':
  ------------------
  |  Branch (579:37): [True: 0, False: 0]
  ------------------
  580|      0|                                    case 'e':
  ------------------
  |  Branch (580:37): [True: 0, False: 0]
  ------------------
  581|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (581:45): [True: 0, False: 0]
  ------------------
  582|      0|                                        {
  583|      0|                                            return OpCode::SLEI;
  584|      0|                                        }
  585|      0|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (585:50): [True: 0, False: 0]
  ------------------
  586|      0|                                        {
  587|      0|                                            return OpCode::SLEU;
  588|      0|                                        }
  589|      0|                                        break;
  590|       |
  591|      0|                                    case 'L':
  ------------------
  |  Branch (591:37): [True: 0, False: 0]
  ------------------
  592|      0|                                    case 'l':
  ------------------
  |  Branch (592:37): [True: 0, False: 0]
  ------------------
  593|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (593:45): [True: 0, False: 0]
  ------------------
  594|      0|                                        {
  595|      0|                                            return OpCode::SLLI;
  596|      0|                                        }
  597|      0|                                        break;
  598|       |
  599|      0|                                    case 'T':
  ------------------
  |  Branch (599:37): [True: 0, False: 0]
  ------------------
  600|      0|                                    case 't':
  ------------------
  |  Branch (600:37): [True: 0, False: 0]
  ------------------
  601|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (601:45): [True: 0, False: 0]
  ------------------
  602|      0|                                        {
  603|      0|                                            return OpCode::SLTI;
  604|      0|                                        }
  605|      0|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (605:50): [True: 0, False: 0]
  ------------------
  606|      0|                                        {
  607|      0|                                            return OpCode::SLTU;
  608|      0|                                        }
  609|      0|                                        break;
  610|      0|                                }
  611|       |
  612|      0|                            case 'N':
  ------------------
  |  Branch (612:29): [True: 0, False: 20]
  ------------------
  613|      0|                            case 'n':
  ------------------
  |  Branch (613:29): [True: 0, False: 20]
  ------------------
  614|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (614:37): [True: 0, False: 0]
  ------------------
  615|      0|                                {
  616|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (616:41): [True: 0, False: 0]
  ------------------
  617|      0|                                    {
  618|      0|                                        return OpCode::SNEI;
  619|      0|                                    }
  620|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (620:46): [True: 0, False: 0]
  ------------------
  621|      0|                                    {
  622|      0|                                        return OpCode::SNEU;
  623|      0|                                    }
  624|      0|                                }
  625|      0|                                break;
  626|       |
  627|      1|                            case 'R':
  ------------------
  |  Branch (627:29): [True: 1, False: 19]
  ------------------
  628|      1|                            case 'r':
  ------------------
  |  Branch (628:29): [True: 0, False: 20]
  ------------------
  629|      1|                                if (ice(c3, 'A') && ice(c4, 'I'))
  ------------------
  |  Branch (629:37): [True: 0, False: 1]
  |  Branch (629:37): [True: 0, False: 1]
  |  Branch (629:53): [True: 0, False: 0]
  ------------------
  630|      0|                                {
  631|      0|                                    return OpCode::SRAI;
  632|      0|                                }
  633|      1|                                else if (ice(c3, 'L') && ice(c4, 'I'))
  ------------------
  |  Branch (633:42): [True: 0, False: 1]
  |  Branch (633:42): [True: 0, False: 1]
  |  Branch (633:58): [True: 0, False: 0]
  ------------------
  634|      0|                                {
  635|      0|                                    return OpCode::SRLI;
  636|      0|                                }
  637|      1|                                break;
  638|       |
  639|      1|                            case 'U':
  ------------------
  |  Branch (639:29): [True: 0, False: 20]
  ------------------
  640|      0|                            case 'u':
  ------------------
  |  Branch (640:29): [True: 0, False: 20]
  ------------------
  641|      0|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (641:37): [True: 0, False: 0]
  ------------------
  642|      0|                                {
  643|      0|                                    switch (c4)
  ------------------
  |  Branch (643:45): [True: 0, False: 0]
  ------------------
  644|      0|                                    {
  645|      0|                                        case 'D':
  ------------------
  |  Branch (645:41): [True: 0, False: 0]
  ------------------
  646|      0|                                        case 'd':
  ------------------
  |  Branch (646:41): [True: 0, False: 0]
  ------------------
  647|      0|                                            return OpCode::SUBD;
  648|       |
  649|      0|                                        case 'F':
  ------------------
  |  Branch (649:41): [True: 0, False: 0]
  ------------------
  650|      0|                                        case 'f':
  ------------------
  |  Branch (650:41): [True: 0, False: 0]
  ------------------
  651|      0|                                            return OpCode::SUBF;
  652|       |
  653|      0|                                        case 'I':
  ------------------
  |  Branch (653:41): [True: 0, False: 0]
  ------------------
  654|      0|                                        case 'i':
  ------------------
  |  Branch (654:41): [True: 0, False: 0]
  ------------------
  655|      0|                                            return OpCode::SUBI;
  656|       |
  657|      0|                                        case 'U':
  ------------------
  |  Branch (657:41): [True: 0, False: 0]
  ------------------
  658|      0|                                        case 'u':
  ------------------
  |  Branch (658:41): [True: 0, False: 0]
  ------------------
  659|      0|                                            return OpCode::SUBU;
  660|      0|                                    }
  661|      0|                                }
  662|      0|                                break;
  663|     20|                        }
  664|     20|                        break;
  665|       |
  666|     20|                    case 'T':
  ------------------
  |  Branch (666:21): [True: 1, False: 872]
  ------------------
  667|      1|                    case 't':
  ------------------
  |  Branch (667:21): [True: 0, False: 873]
  ------------------
  668|      1|                        if (ice(c2, 'R') && ice(c3, 'A') && ice(c4, 'P'))
  ------------------
  |  Branch (668:29): [True: 0, False: 1]
  |  Branch (668:29): [True: 0, False: 1]
  |  Branch (668:45): [True: 0, False: 0]
  |  Branch (668:61): [True: 0, False: 0]
  ------------------
  669|      0|                        {
  670|      0|                            return OpCode::TRAP;
  671|      0|                        }
  672|      1|                        break;
  673|      2|                    case 'X':
  ------------------
  |  Branch (673:21): [True: 2, False: 871]
  ------------------
  674|      3|                    case 'x':
  ------------------
  |  Branch (674:21): [True: 1, False: 872]
  ------------------
  675|      3|                        if (ice(c2, 'O') && ice(c3, 'R') && ice(c4, 'I'))
  ------------------
  |  Branch (675:29): [True: 1, False: 2]
  |  Branch (675:29): [True: 0, False: 3]
  |  Branch (675:45): [True: 0, False: 1]
  |  Branch (675:61): [True: 0, False: 0]
  ------------------
  676|      0|                        {
  677|      0|                            return OpCode::XORI;
  678|      0|                        }
  679|      3|                        break;
  680|    873|                }
  681|    873|                break;
  682|    873|            }
  683|       |
  684|       |            // 5 character OpCodes
  685|    873|            case 5: {
  ------------------
  |  Branch (685:13): [True: 209, False: 3.80k]
  ------------------
  686|    209|                char c1 = token[0];
  687|    209|                char c2 = token[1];
  688|    209|                char c3 = token[2];
  689|    209|                char c4 = token[3];
  690|    209|                char c5 = token[4];
  691|       |
  692|    209|                switch (c1)
  ------------------
  |  Branch (692:25): [True: 148, False: 61]
  ------------------
  693|    209|                {
  694|     11|                    case 'A':
  ------------------
  |  Branch (694:21): [True: 11, False: 198]
  ------------------
  695|     12|                    case 'a':
  ------------------
  |  Branch (695:21): [True: 1, False: 208]
  ------------------
  696|     12|                        if (ice(c2, 'D') && ice(c3, 'D') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (696:29): [True: 0, False: 12]
  |  Branch (696:29): [True: 0, False: 12]
  |  Branch (696:45): [True: 0, False: 0]
  |  Branch (696:61): [True: 0, False: 0]
  |  Branch (696:77): [True: 0, False: 0]
  ------------------
  697|      0|                        {
  698|      0|                            return OpCode::ADDUI;
  699|      0|                        }
  700|     12|                        break;
  701|       |
  702|     12|                    case 'D':
  ------------------
  |  Branch (702:21): [True: 12, False: 197]
  ------------------
  703|     13|                    case 'd':
  ------------------
  |  Branch (703:21): [True: 1, False: 208]
  ------------------
  704|     13|                        if (ice(c2, 'I') && ice(c3, 'V') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (704:29): [True: 0, False: 13]
  |  Branch (704:29): [True: 0, False: 13]
  |  Branch (704:45): [True: 0, False: 0]
  |  Branch (704:61): [True: 0, False: 0]
  |  Branch (704:77): [True: 0, False: 0]
  ------------------
  705|      0|                        {
  706|      0|                            return OpCode::DIVUI;
  707|      0|                        }
  708|     13|                        break;
  709|       |
  710|     13|                    case 'M':
  ------------------
  |  Branch (710:21): [True: 13, False: 196]
  ------------------
  711|     25|                    case 'm':
  ------------------
  |  Branch (711:21): [True: 12, False: 197]
  ------------------
  712|     25|                        if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (712:29): [True: 0, False: 25]
  |  Branch (712:29): [True: 0, False: 25]
  |  Branch (712:45): [True: 0, False: 0]
  |  Branch (712:61): [True: 0, False: 0]
  ------------------
  713|      0|                        {
  714|      0|                            switch (c5)
  ------------------
  |  Branch (714:37): [True: 0, False: 0]
  ------------------
  715|      0|                            {
  716|      0|                                case 'D':
  ------------------
  |  Branch (716:33): [True: 0, False: 0]
  ------------------
  717|      0|                                case 'd':
  ------------------
  |  Branch (717:33): [True: 0, False: 0]
  ------------------
  718|      0|                                    return OpCode::MULTD;
  719|       |
  720|      0|                                case 'F':
  ------------------
  |  Branch (720:33): [True: 0, False: 0]
  ------------------
  721|      0|                                case 'f':
  ------------------
  |  Branch (721:33): [True: 0, False: 0]
  ------------------
  722|      0|                                    return OpCode::MULTF;
  723|       |
  724|      0|                                case 'I':
  ------------------
  |  Branch (724:33): [True: 0, False: 0]
  ------------------
  725|      0|                                case 'i':
  ------------------
  |  Branch (725:33): [True: 0, False: 0]
  ------------------
  726|      0|                                    return OpCode::MULTI;
  727|       |
  728|      0|                                case 'U':
  ------------------
  |  Branch (728:33): [True: 0, False: 0]
  ------------------
  729|      0|                                case 'u':
  ------------------
  |  Branch (729:33): [True: 0, False: 0]
  ------------------
  730|      0|                                    return OpCode::MULTU;
  731|      0|                            }
  732|      0|                        }
  733|     25|                        break;
  734|       |
  735|     25|                    case 'S':
  ------------------
  |  Branch (735:21): [True: 8, False: 201]
  ------------------
  736|     11|                    case 's':
  ------------------
  |  Branch (736:21): [True: 3, False: 206]
  ------------------
  737|     11|                        switch (c2)
  ------------------
  |  Branch (737:33): [True: 11, False: 0]
  ------------------
  738|     11|                        {
  739|      0|                            case 'E':
  ------------------
  |  Branch (739:29): [True: 0, False: 11]
  ------------------
  740|      0|                            case 'e':
  ------------------
  |  Branch (740:29): [True: 0, False: 11]
  ------------------
  741|      0|                                if (ice(c3, 'Q') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (741:37): [True: 0, False: 0]
  |  Branch (741:37): [True: 0, False: 0]
  |  Branch (741:53): [True: 0, False: 0]
  |  Branch (741:69): [True: 0, False: 0]
  ------------------
  742|      0|                                {
  743|      0|                                    return OpCode::SEQUI;
  744|      0|                                }
  745|      0|                                break;
  746|       |
  747|      0|                            case 'G':
  ------------------
  |  Branch (747:29): [True: 0, False: 11]
  ------------------
  748|      0|                            case 'g':
  ------------------
  |  Branch (748:29): [True: 0, False: 11]
  ------------------
  749|      0|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (749:37): [True: 0, False: 0]
  |  Branch (749:37): [True: 0, False: 0]
  |  Branch (749:53): [True: 0, False: 0]
  |  Branch (749:69): [True: 0, False: 0]
  ------------------
  750|      0|                                {
  751|      0|                                    return OpCode::SGEUI;
  752|      0|                                }
  753|      0|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (753:42): [True: 0, False: 0]
  |  Branch (753:42): [True: 0, False: 0]
  |  Branch (753:58): [True: 0, False: 0]
  |  Branch (753:74): [True: 0, False: 0]
  ------------------
  754|      0|                                {
  755|      0|                                    return OpCode::SGTUI;
  756|      0|                                }
  757|      0|                                break;
  758|       |
  759|      0|                            case 'L':
  ------------------
  |  Branch (759:29): [True: 0, False: 11]
  ------------------
  760|      0|                            case 'l':
  ------------------
  |  Branch (760:29): [True: 0, False: 11]
  ------------------
  761|      0|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (761:37): [True: 0, False: 0]
  |  Branch (761:37): [True: 0, False: 0]
  |  Branch (761:53): [True: 0, False: 0]
  |  Branch (761:69): [True: 0, False: 0]
  ------------------
  762|      0|                                {
  763|      0|                                    return OpCode::SLEUI;
  764|      0|                                }
  765|      0|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (765:42): [True: 0, False: 0]
  |  Branch (765:42): [True: 0, False: 0]
  |  Branch (765:58): [True: 0, False: 0]
  |  Branch (765:74): [True: 0, False: 0]
  ------------------
  766|      0|                                {
  767|      0|                                    return OpCode::SLTUI;
  768|      0|                                }
  769|      0|                                break;
  770|       |
  771|      0|                            case 'N':
  ------------------
  |  Branch (771:29): [True: 0, False: 11]
  ------------------
  772|      0|                            case 'n':
  ------------------
  |  Branch (772:29): [True: 0, False: 11]
  ------------------
  773|      0|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (773:37): [True: 0, False: 0]
  |  Branch (773:37): [True: 0, False: 0]
  |  Branch (773:53): [True: 0, False: 0]
  |  Branch (773:69): [True: 0, False: 0]
  ------------------
  774|      0|                                {
  775|      0|                                    return OpCode::SNEUI;
  776|      0|                                }
  777|      0|                                break;
  778|       |
  779|      0|                            case 'U':
  ------------------
  |  Branch (779:29): [True: 0, False: 11]
  ------------------
  780|      0|                            case 'u':
  ------------------
  |  Branch (780:29): [True: 0, False: 11]
  ------------------
  781|      0|                                if (ice(c3, 'B') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (781:37): [True: 0, False: 0]
  |  Branch (781:37): [True: 0, False: 0]
  |  Branch (781:53): [True: 0, False: 0]
  |  Branch (781:69): [True: 0, False: 0]
  ------------------
  782|      0|                                {
  783|      0|                                    return OpCode::SUBUI;
  784|      0|                                }
  785|      0|                                break;
  786|     11|                        }
  787|       |
  788|     11|                        break;
  789|    209|                }
  790|       |
  791|    209|                break;
  792|    209|            }
  793|       |
  794|       |            // 6 character OpCodes
  795|    263|            case 6: {
  ------------------
  |  Branch (795:13): [True: 263, False: 3.74k]
  ------------------
  796|    263|                char c1 = token[0];
  797|    263|                char c2 = token[1];
  798|    263|                char c3 = token[2];
  799|    263|                char c4 = token[3];
  800|    263|                char c5 = token[4];
  801|    263|                char c6 = token[5];
  802|       |
  803|    263|                if (ice(c1, 'C') && ice(c2, 'V') && ice(c3, 'T'))
  ------------------
  |  Branch (803:21): [True: 0, False: 263]
  |  Branch (803:21): [True: 0, False: 263]
  |  Branch (803:37): [True: 0, False: 0]
  |  Branch (803:53): [True: 0, False: 0]
  ------------------
  804|      0|                {
  805|      0|                    switch (c4)
  ------------------
  |  Branch (805:29): [True: 0, False: 0]
  ------------------
  806|      0|                    {
  807|      0|                        case 'D':
  ------------------
  |  Branch (807:25): [True: 0, False: 0]
  ------------------
  808|      0|                        case 'd':
  ------------------
  |  Branch (808:25): [True: 0, False: 0]
  ------------------
  809|      0|                            if (c5 == '2')
  ------------------
  |  Branch (809:33): [True: 0, False: 0]
  ------------------
  810|      0|                            {
  811|      0|                                if (ice(c6, 'F'))
  ------------------
  |  Branch (811:37): [True: 0, False: 0]
  ------------------
  812|      0|                                {
  813|      0|                                    return OpCode::CVTD2F;
  814|      0|                                }
  815|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (815:42): [True: 0, False: 0]
  ------------------
  816|      0|                                {
  817|      0|                                    return OpCode::CVTD2I;
  818|      0|                                }
  819|      0|                            }
  820|      0|                            break;
  821|       |
  822|      0|                        case 'F':
  ------------------
  |  Branch (822:25): [True: 0, False: 0]
  ------------------
  823|      0|                        case 'f':
  ------------------
  |  Branch (823:25): [True: 0, False: 0]
  ------------------
  824|      0|                            if (c5 == '2')
  ------------------
  |  Branch (824:33): [True: 0, False: 0]
  ------------------
  825|      0|                            {
  826|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (826:37): [True: 0, False: 0]
  ------------------
  827|      0|                                {
  828|      0|                                    return OpCode::CVTF2D;
  829|      0|                                }
  830|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (830:42): [True: 0, False: 0]
  ------------------
  831|      0|                                {
  832|      0|                                    return OpCode::CVTF2I;
  833|      0|                                }
  834|      0|                            }
  835|      0|                            break;
  836|       |
  837|      0|                        case 'I':
  ------------------
  |  Branch (837:25): [True: 0, False: 0]
  ------------------
  838|      0|                        case 'i':
  ------------------
  |  Branch (838:25): [True: 0, False: 0]
  ------------------
  839|      0|                            if (c5 == '2')
  ------------------
  |  Branch (839:33): [True: 0, False: 0]
  ------------------
  840|      0|                            {
  841|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (841:37): [True: 0, False: 0]
  ------------------
  842|      0|                                {
  843|      0|                                    return OpCode::CVTI2D;
  844|      0|                                }
  845|      0|                                else if (ice(c6, 'F'))
  ------------------
  |  Branch (845:42): [True: 0, False: 0]
  ------------------
  846|      0|                                {
  847|      0|                                    return OpCode::CVTI2F;
  848|      0|                                }
  849|      0|                            }
  850|      0|                    }
  851|      0|                }
  852|    263|                else if (ice(c1, 'M') && ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T') &&
  ------------------
  |  Branch (852:26): [True: 26, False: 237]
  |  Branch (852:26): [True: 0, False: 263]
  |  Branch (852:42): [True: 0, False: 26]
  |  Branch (852:58): [True: 0, False: 0]
  |  Branch (852:74): [True: 0, False: 0]
  ------------------
  853|    263|                         ice(c5, 'U') && ice(c6, 'I'))
  ------------------
  |  Branch (853:26): [True: 0, False: 0]
  |  Branch (853:42): [True: 0, False: 0]
  ------------------
  854|      0|                {
  855|      0|                    return OpCode::MULTUI;
  856|      0|                }
  857|    263|                break;
  858|    263|            }
  859|       |
  860|       |            // 7 character OpCodes
  861|    263|            case 7: {
  ------------------
  |  Branch (861:13): [True: 108, False: 3.90k]
  ------------------
  862|    108|                char c1 = token[0];
  863|    108|                char c2 = token[1];
  864|    108|                char c3 = token[2];
  865|    108|                char c4 = token[3];
  866|    108|                char c5 = token[4];
  867|    108|                char c6 = token[5];
  868|    108|                char c7 = token[6];
  869|       |
  870|    108|                if (ice(c1, 'M') && ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (870:21): [True: 24, False: 84]
  |  Branch (870:21): [True: 0, False: 108]
  |  Branch (870:37): [True: 0, False: 24]
  |  Branch (870:53): [True: 0, False: 0]
  ------------------
  871|      0|                {
  872|      0|                    if (ice(c4, 'I') && c5 == '2' && ice(c6, 'F') && ice(c7, 'P'))
  ------------------
  |  Branch (872:25): [True: 0, False: 0]
  |  Branch (872:25): [True: 0, False: 0]
  |  Branch (872:41): [True: 0, False: 0]
  |  Branch (872:54): [True: 0, False: 0]
  |  Branch (872:70): [True: 0, False: 0]
  ------------------
  873|      0|                    {
  874|      0|                        return OpCode::MOVI2FP;
  875|      0|                    }
  876|      0|                    else if (ice(c4, 'F') && ice(c5, 'P') && c6 == '2' && ice(c7, 'I'))
  ------------------
  |  Branch (876:30): [True: 0, False: 0]
  |  Branch (876:30): [True: 0, False: 0]
  |  Branch (876:46): [True: 0, False: 0]
  |  Branch (876:62): [True: 0, False: 0]
  |  Branch (876:75): [True: 0, False: 0]
  ------------------
  877|      0|                    {
  878|      0|                        return OpCode::MOVFP2I;
  879|      0|                    }
  880|      0|                }
  881|    108|                break;
  882|    108|            }
  883|       |
  884|    223|            default: {
  ------------------
  |  Branch (884:13): [True: 223, False: 3.78k]
  ------------------
  885|    223|                break;
  886|    108|            }
  887|  4.01k|        }
  888|       |
  889|       |        // None found
  890|  3.83k|        return OpCode::NONE;
  891|  4.01k|    }
_ZN3dlx3iceEcc:
   17|  1.51k|    {
   18|  1.51k|        constexpr const char diff = 'a' - 'A';
   19|  1.51k|        return (c == t) || (c == t + diff);
  ------------------
  |  Branch (19:16): [True: 166, False: 1.34k]
  |  Branch (19:28): [True: 48, False: 1.29k]
  ------------------
   20|  1.51k|    }

_ZN3dlx10ParseErrorC2Ev:
   20|  4.74k|    {}
_ZNK3dlx10ParseError13GetLineNumberEv:
   28|  4.74k|    {
   29|  4.74k|        return m_LineNumber;
   30|  4.74k|    }
_ZNK3dlx10ParseError16ConstructMessageEv:
   44|  4.74k|    {
   45|  4.74k|        switch (m_Type)
   46|  4.74k|        {
   47|     10|            case Type::UnexpectedArgumentType: {
  ------------------
  |  Branch (47:13): [True: 10, False: 4.73k]
  ------------------
   48|     10|                const UnexpectedArgumentType& detail = GetUnexpectedArgumentType();
   49|       |
   50|     10|                return fmt::format("Expected {:s} but got {:s}",
   51|     10|                                   dlx::enum_name(detail.expected_type),
   52|     10|                                   dlx::enum_name(detail.actual_type));
   53|      0|            }
   54|       |
   55|      0|            case Type::InvalidNumber: {
  ------------------
  |  Branch (55:13): [True: 0, False: 4.74k]
  ------------------
   56|      0|                const InvalidNumber& detail = GetInvalidNumber();
   57|       |
   58|      0|                return fmt::format("'{:s}' is not a valid number", detail.text);
   59|      0|            }
   60|       |
   61|      0|            case Type::TooFewArgumentsAddressDisplacement: {
  ------------------
  |  Branch (61:13): [True: 0, False: 4.74k]
  ------------------
   62|      0|                return fmt::format("Not enough arguments left to parse address displacement");
   63|      0|            }
   64|       |
   65|  1.07k|            case Type::UnexpectedToken: {
  ------------------
  |  Branch (65:13): [True: 1.07k, False: 3.66k]
  ------------------
   66|  1.07k|                const UnexpectedToken& detail = GetUnexpectedToken();
   67|       |
   68|  1.07k|                return fmt::format("Expected token of type {:s} but got {:s}",
   69|  1.07k|                                   dlx::enum_name(detail.expected_type),
   70|  1.07k|                                   dlx::enum_name(detail.actual_type));
   71|      0|            }
   72|       |
   73|      4|            case Type::ReserverdIdentifier: {
  ------------------
  |  Branch (73:13): [True: 4, False: 4.74k]
  ------------------
   74|      4|                const ReservedIdentifier& detail = GetReserverIdentifier();
   75|       |
   76|      4|                return fmt::format("'{:s}' is a reserved identifier", detail.identifier);
   77|      0|            }
   78|       |
   79|  3.46k|            case Type::InvalidLabelIdentifier: {
  ------------------
  |  Branch (79:13): [True: 3.46k, False: 1.27k]
  ------------------
   80|  3.46k|                const InvalidLabelIdentifier& detail = GetInvalidLabelIdentifier();
   81|       |
   82|  3.46k|                return fmt::format("'{:s}' is not a valid label identifier", detail.identifer);
   83|      0|            }
   84|       |
   85|      9|            case Type::LabelAlreadyDefined: {
  ------------------
  |  Branch (85:13): [True: 9, False: 4.73k]
  ------------------
   86|      9|                const LabelAlreadyDefined& detail = GetLabelAlreadyDefined();
   87|       |
   88|      9|                return fmt::format("Label '{:s}' was already defined at {:d}:{:d}",
   89|      9|                                   detail.label_name, detail.at_line, detail.at_column);
   90|      0|            }
   91|       |
   92|     13|            case Type::OneInstructionPerLine: {
  ------------------
  |  Branch (92:13): [True: 13, False: 4.73k]
  ------------------
   93|     13|                return fmt::format("You may only place one instruction per line");
   94|      0|            }
   95|       |
   96|    113|            case Type::TooFewArgument: {
  ------------------
  |  Branch (96:13): [True: 113, False: 4.63k]
  ------------------
   97|    113|                const TooFewArguments& detail = GetTooFewArguments();
   98|       |
   99|    113|                return fmt::format(
  100|    113|                        "Not enough arguments provided. Required {:d}, provided only {:d}",
  101|    113|                        detail.required, detail.provided);
  102|      0|            }
  103|       |
  104|     52|            case Type::EmptyLabel: {
  ------------------
  |  Branch (104:13): [True: 52, False: 4.69k]
  ------------------
  105|     52|                const EmptyLabel& detail = GetEmptyLabel();
  106|       |
  107|     52|                return fmt::format("Label '{:s}' does not have any instruction", detail.label_name);
  108|      0|            }
  109|       |
  110|      0|            case Type::TooManyComma: {
  ------------------
  |  Branch (110:13): [True: 0, False: 4.74k]
  ------------------
  111|      0|                return fmt::format("Only one comma is allowed");
  112|      0|            }
  113|       |
  114|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  115|      0|            default:
  ------------------
  |  Branch (115:13): [True: 0, False: 4.74k]
  ------------------
  116|      0|                PHI_ASSERT_NOT_REACHED();
  117|  4.74k|#endif
  118|  4.74k|        }
  119|  4.74k|    }
_ZNK3dlx10ParseError25GetUnexpectedArgumentTypeEv:
  126|     10|    {
  127|     10|        PHI_ASSERT(m_Type == Type::UnexpectedArgumentType);
  128|       |
  129|     10|        return unexpected_argument_type;
  130|     10|    }
_ZNK3dlx10ParseError18GetUnexpectedTokenEv:
  142|  1.07k|    {
  143|  1.07k|        PHI_ASSERT(m_Type == Type::UnexpectedToken);
  144|       |
  145|  1.07k|        return unexpected_token;
  146|  1.07k|    }
_ZNK3dlx10ParseError21GetReserverIdentifierEv:
  150|      4|    {
  151|      4|        PHI_ASSERT(m_Type == Type::ReserverdIdentifier);
  152|       |
  153|      4|        return reserved_identifier;
  154|      4|    }
_ZNK3dlx10ParseError25GetInvalidLabelIdentifierEv:
  158|  3.46k|    {
  159|  3.46k|        PHI_ASSERT(m_Type == Type::InvalidLabelIdentifier);
  160|       |
  161|  3.46k|        return invalid_label_identifier;
  162|  3.46k|    }
_ZNK3dlx10ParseError22GetLabelAlreadyDefinedEv:
  166|      9|    {
  167|      9|        PHI_ASSERT(m_Type == Type::LabelAlreadyDefined);
  168|       |
  169|      9|        return label_already_defined;
  170|      9|    }
_ZNK3dlx10ParseError18GetTooFewArgumentsEv:
  174|    113|    {
  175|    113|        PHI_ASSERT(m_Type == Type::TooFewArgument);
  176|       |
  177|    113|        return too_few_arguments;
  178|    113|    }
_ZNK3dlx10ParseError13GetEmptyLabelEv:
  181|     52|    {
  182|     52|        PHI_ASSERT(m_Type == Type::EmptyLabel);
  183|       |
  184|     52|        return empty_label;
  185|     52|    }
_ZN3dlx41ConstructUnexpectedArgumentTypeParseErrorEmmNS_12ArgumentTypeES0_:
  192|     10|    {
  193|     10|        ParseError err;
  194|       |
  195|     10|        err.m_Type                                 = ParseError::Type::UnexpectedArgumentType;
  196|     10|        err.m_LineNumber                           = line_number;
  197|     10|        err.m_Column                               = column;
  198|     10|        err.unexpected_argument_type.expected_type = expected_type;
  199|     10|        err.unexpected_argument_type.actual_type   = actual_type;
  200|       |
  201|     10|        return err;
  202|     10|    }
_ZN3dlx41ConstructUnexpectedArgumentTypeParseErrorERKNS_5TokenENS_12ArgumentTypeES3_:
  206|     10|    {
  207|     10|        return ConstructUnexpectedArgumentTypeParseError(token.GetLineNumber().unsafe(),
  208|     10|                                                         token.GetColumn().unsafe(), expected_type,
  209|     10|                                                         actual_type);
  210|     10|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorEmmNS_5Token4TypeES1_:
  254|  1.07k|    {
  255|  1.07k|        ParseError err;
  256|       |
  257|  1.07k|        err.m_Type                         = ParseError::Type::UnexpectedToken;
  258|  1.07k|        err.m_LineNumber                   = line_number;
  259|  1.07k|        err.m_Column                       = column;
  260|  1.07k|        err.unexpected_token.expected_type = expected_type;
  261|  1.07k|        err.unexpected_token.actual_type   = actual_type;
  262|       |
  263|  1.07k|        return err;
  264|  1.07k|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorERKNS_5TokenENS0_4TypeE:
  268|  1.07k|    {
  269|  1.07k|        return ConstructUnexpectedTokenParseError(token.GetLineNumber().unsafe(),
  270|  1.07k|                                                  token.GetColumn().unsafe(), expected_type,
  271|  1.07k|                                                  token.GetType());
  272|  1.07k|    }
_ZN3dlx36ConstructReservedIdentiferParseErrorEmmNSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
  276|      4|    {
  277|      4|        ParseError err;
  278|       |
  279|      4|        err.m_Type                         = ParseError::Type::ReserverdIdentifier;
  280|      4|        err.m_LineNumber                   = line_number;
  281|      4|        err.m_Column                       = column;
  282|      4|        err.reserved_identifier.identifier = identifier;
  283|       |
  284|      4|        return err;
  285|      4|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorEmmNSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
  295|  3.46k|    {
  296|  3.46k|        ParseError err;
  297|       |
  298|  3.46k|        err.m_Type                             = ParseError::Type::InvalidLabelIdentifier;
  299|  3.46k|        err.m_LineNumber                       = line_number;
  300|  3.46k|        err.m_Column                           = column;
  301|  3.46k|        err.invalid_label_identifier.identifer = identifier;
  302|       |
  303|  3.46k|        return err;
  304|  3.46k|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorERKNS_5TokenE:
  308|  3.46k|    {
  309|  3.46k|        return ConstructInvalidLabelIdentifierParseError(
  310|  3.46k|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText());
  311|  3.46k|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorEmmNSt3__117basic_string_viewIcNS0_11char_traitsIcEEEEmm:
  316|      9|    {
  317|      9|        ParseError err;
  318|       |
  319|      9|        err.m_Type                           = ParseError::Type::LabelAlreadyDefined;
  320|      9|        err.m_LineNumber                     = line_number;
  321|      9|        err.m_Column                         = column;
  322|      9|        err.label_already_defined.label_name = label_name;
  323|      9|        err.label_already_defined.at_line    = at_line;
  324|      9|        err.label_already_defined.at_column  = at_column;
  325|       |
  326|      9|        return err;
  327|      9|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorERKNS_5TokenES2_:
  331|      9|    {
  332|      9|        return ConstructLabelAlreadyDefinedParseError(
  333|      9|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText(),
  334|      9|                first_definition.GetLineNumber().unsafe(), first_definition.GetColumn().unsafe());
  335|      9|    }
_ZN3dlx40ConstructOneInstructionPerLineParseErrorEmm:
  339|     13|    {
  340|     13|        ParseError err;
  341|       |
  342|     13|        err.m_Type       = ParseError::Type::OneInstructionPerLine;
  343|     13|        err.m_LineNumber = line_number;
  344|     13|        err.m_Column     = column;
  345|       |
  346|     13|        return err;
  347|     13|    }
_ZN3dlx40ConstructOneInstructionPerLineParseErrorERKNS_5TokenE:
  351|     13|    {
  352|     13|        return ConstructOneInstructionPerLineParseError(token.GetLineNumber().unsafe(),
  353|     13|                                                        token.GetColumn().unsafe());
  354|     13|    }
_ZN3dlx34ConstructTooFewArgumentsParseErrorEmmhh:
  359|    113|    {
  360|    113|        ParseError err;
  361|       |
  362|    113|        err.m_Type                     = ParseError::Type::TooFewArgument;
  363|    113|        err.m_LineNumber               = line_number;
  364|    113|        err.m_Column                   = column;
  365|    113|        err.too_few_arguments.required = required;
  366|    113|        err.too_few_arguments.provided = provided;
  367|       |
  368|    113|        return err;
  369|    113|    }
_ZN3dlx34ConstructTooFewArgumentsParseErrorERKNS_5TokenEhh:
  373|    113|    {
  374|    113|        return ConstructTooFewArgumentsParseError(token.GetLineNumber().unsafe(),
  375|    113|                                                  token.GetColumn().unsafe(), required, provided);
  376|    113|    }
_ZN3dlx29ConstructEmptyLabelParseErrorEmmNSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
  380|     52|    {
  381|     52|        ParseError err;
  382|       |
  383|     52|        err.m_Type                 = ParseError::Type::EmptyLabel;
  384|     52|        err.m_LineNumber           = line_number;
  385|     52|        err.m_Column               = column;
  386|     52|        err.empty_label.label_name = label_name;
  387|       |
  388|     52|        return err;
  389|     52|    }
_ZN3dlx29ConstructEmptyLabelParseErrorERKNS_5TokenE:
  392|     52|    {
  393|     52|        return ConstructEmptyLabelParseError(
  394|     52|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(),
  395|     52|                (token.GetText().back() == ':') ?
  ------------------
  |  Branch (395:17): [True: 32, False: 20]
  ------------------
  396|     32|                        token.GetText().substr(0, token.GetText().size() - 1) :
  397|     52|                        token.GetText());
  398|     52|    }

_ZN3dlx13ParsedProgram13AddParseErrorEONS_10ParseErrorE:
   18|  4.74k|    {
   19|  4.74k|        m_ParseErrors.emplace_back(phi::move(error));
   20|  4.74k|    }
_ZNK3dlx13ParsedProgram7IsValidEv:
   23|  13.5k|    {
   24|  13.5k|        return m_ParseErrors.empty() && !m_Instructions.empty();
  ------------------
  |  Branch (24:16): [True: 7.78k, False: 5.74k]
  |  Branch (24:41): [True: 7, False: 7.77k]
  ------------------
   25|  13.5k|    }

_ZN3dlx6Parser5ParseERNS_11TokenStreamE:
  181|  2.70k|    {
  182|  2.70k|        ParsedProgram program;
  183|       |
  184|  2.70k|        program.m_Tokens = tokens;
  185|       |
  186|  2.70k|        phi::boolean line_has_instruction{false};
  187|  2.70k|        phi::usize   label_count{0u};
  188|       |
  189|  9.12k|        while (tokens.has_more())
  ------------------
  |  Branch (189:16): [True: 6.42k, False: 2.70k]
  ------------------
  190|  6.42k|        {
  191|  6.42k|            const Token& current_token = tokens.consume();
  192|       |
  193|       |            //DLX_INFO("Parsing '{}'", current_token.DebugInfo());
  194|       |
  195|  6.42k|            switch (current_token.GetType())
  196|  6.42k|            {
  197|       |                // Ignore comments
  198|    122|                case Token::Type::Comment:
  ------------------
  |  Branch (198:17): [True: 122, False: 6.30k]
  ------------------
  199|       |                    //DLX_DEBUG("Ignoring comment");
  200|    122|                    break;
  201|       |
  202|  1.54k|                case Token::Type::NewLine:
  ------------------
  |  Branch (202:17): [True: 1.54k, False: 4.87k]
  ------------------
  203|       |                    //DLX_DEBUG("Ignoring newline");
  204|  1.54k|                    line_has_instruction = false;
  205|  1.54k|                    break;
  206|       |
  207|  3.61k|                case Token::Type::LabelIdentifier: {
  ------------------
  |  Branch (207:17): [True: 3.61k, False: 2.81k]
  ------------------
  208|  3.61k|                    if (line_has_instruction)
  ------------------
  |  Branch (208:25): [True: 99, False: 3.51k]
  ------------------
  209|     99|                    {
  210|     99|                        program.AddParseError(ConstructUnexpectedTokenParseError(
  211|     99|                                current_token, Token::Type::NewLine));
  212|     99|                        break;
  213|     99|                    }
  214|       |
  215|       |                    // Handle jump labels
  216|       |                    // Check if the last character of the identifier is a colon
  217|  3.51k|                    if (current_token.GetText().back() != ':')
  ------------------
  |  Branch (217:25): [True: 3.35k, False: 163]
  ------------------
  218|  3.35k|                    {
  219|  3.35k|                        program.AddParseError(
  220|  3.35k|                                ConstructInvalidLabelIdentifierParseError(current_token));
  221|  3.35k|                        break;
  222|  3.35k|                    }
  223|       |
  224|    163|                    std::string_view label_name = current_token.GetText();
  225|    163|                    label_name.remove_suffix(1);
  226|       |
  227|    163|                    if (IsReservedIdentifier(label_name))
  ------------------
  |  Branch (227:25): [True: 4, False: 159]
  ------------------
  228|      4|                    {
  229|      4|                        program.AddParseError(ConstructReservedIdentiferParseError(
  230|      4|                                current_token.GetLineNumber().unsafe(),
  231|      4|                                current_token.GetColumn().unsafe(), label_name));
  232|      4|                        break;
  233|      4|                    }
  234|       |
  235|    159|                    if (!IsValidIdentifier(label_name))
  ------------------
  |  Branch (235:25): [True: 98, False: 61]
  ------------------
  236|     98|                    {
  237|     98|                        program.AddParseError(
  238|     98|                                ConstructInvalidLabelIdentifierParseError(current_token));
  239|     98|                        break;
  240|     98|                    }
  241|       |
  242|       |                    // Check if label was already defined
  243|     61|                    if (program.m_JumpData.find(label_name) != program.m_JumpData.end())
  ------------------
  |  Branch (243:25): [True: 9, False: 52]
  ------------------
  244|      9|                    {
  245|       |                        // Find first defintions of label
  246|      9|                        const Token* first_label_definition =
  247|      9|                                tokens.find_first_token_if([&](const Token& t) {
  248|      9|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  249|      9|                                    {
  250|      9|                                        std::string_view token_label_name = t.GetText();
  251|      9|                                        token_label_name.remove_suffix(1);
  252|       |
  253|      9|                                        if (token_label_name == label_name)
  254|      9|                                        {
  255|      9|                                            return true;
  256|      9|                                        }
  257|      9|                                    }
  258|       |
  259|      9|                                    return false;
  260|      9|                                });
  261|       |
  262|      9|                        PHI_ASSERT(first_label_definition);
  263|       |
  264|      9|                        program.AddParseError(ConstructLabelAlreadyDefinedParseError(
  265|      9|                                current_token, *first_label_definition));
  266|      9|                        break;
  267|      9|                    }
  268|       |
  269|     52|                    program.m_JumpData[label_name] =
  270|     52|                            static_cast<std::uint32_t>(program.m_Instructions.size());
  271|     52|                    label_count += 1u;
  272|       |
  273|       |                    //DLX_INFO("Added jump label {} -> {}", label_name,
  274|       |                    //             program.m_Instructions.size());
  275|       |
  276|     52|                    break;
  277|     61|                }
  278|       |
  279|    174|                case Token::Type::OpCode: {
  ------------------
  |  Branch (279:17): [True: 174, False: 6.24k]
  ------------------
  280|    174|                    if (line_has_instruction)
  ------------------
  |  Branch (280:25): [True: 13, False: 161]
  ------------------
  281|     13|                    {
  282|     13|                        program.AddParseError(
  283|     13|                                ConstructOneInstructionPerLineParseError(current_token));
  284|     13|                        break;
  285|     13|                    }
  286|       |
  287|    161|                    label_count = 0u;
  288|       |
  289|       |                    // Handle normal instructions
  290|    161|                    PHI_ASSERT(current_token.HasHint());
  291|    161|                    OpCode opcode = static_cast<OpCode>(current_token.GetHint());
  292|       |
  293|       |                    //DLX_INFO("Instruction opcode: {}", dlx::enum_name(opcode));
  294|       |
  295|    161|                    const InstructionInfo& info = LookUpIntructionInfo(opcode);
  296|       |
  297|       |                    // Make sure we got no problems here
  298|    161|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  299|    161|                    PHI_ASSERT(info.GetArgumentType(1_u8) != ArgumentType::Unknown);
  300|    161|                    PHI_ASSERT(info.GetArgumentType(2_u8) != ArgumentType::Unknown);
  301|    161|                    PHI_ASSERT(info.GetExecutor());
  302|       |
  303|    161|                    const phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  304|       |                    //DLX_INFO("Instruction requires {} arguments",
  305|       |                    //             number_of_argument_required.unsafe());
  306|       |
  307|       |                    // Create instruction
  308|    161|                    Instruction  instruction(info, current_token.GetLineNumber());
  309|    161|                    phi::boolean consumed_comma{false};
  310|       |
  311|       |                    // Parse arguments
  312|    187|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  ------------------
  |  Branch (312:54): [True: 177, False: 10]
  ------------------
  313|    177|                    {
  314|       |                        // Get next token
  315|    177|                        if (!tokens.has_more())
  ------------------
  |  Branch (315:29): [True: 13, False: 164]
  ------------------
  316|     13|                        {
  317|     13|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  318|     13|                                    current_token, number_of_argument_required.unsafe(),
  319|     13|                                    argument_num.unsafe()));
  320|     13|                            break;
  321|     13|                        }
  322|       |
  323|    164|                        const Token& token = tokens.consume();
  324|       |
  325|       |                        // Skip commas
  326|    164|                        if (token.GetType() == Token::Type::Comma)
  ------------------
  |  Branch (326:29): [True: 16, False: 148]
  ------------------
  327|     16|                        {
  328|     16|                            if (consumed_comma)
  ------------------
  |  Branch (328:33): [True: 0, False: 16]
  ------------------
  329|      0|                            {
  330|      0|                                program.AddParseError(ConstructTooManyCommaParseError(token));
  331|      0|                            }
  332|       |
  333|     16|                            consumed_comma = true;
  334|       |                            //DLX_DEBUG("Skipping comma");
  335|     16|                            continue;
  336|     16|                        }
  337|       |
  338|    148|                        if (token.GetType() == Token::Type::NewLine)
  ------------------
  |  Branch (338:29): [True: 100, False: 48]
  ------------------
  339|    100|                        {
  340|    100|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  341|    100|                                    token, number_of_argument_required.unsafe(),
  342|    100|                                    argument_num.unsafe()));
  343|    100|                            break;
  344|    100|                        }
  345|       |
  346|     48|                        phi::optional<InstructionArgument> optional_parsed_argument =
  347|     48|                                parse_instruction_argument(
  348|     48|                                        token, info.GetArgumentType(argument_num), tokens, program);
  349|     48|                        if (!optional_parsed_argument.has_value())
  ------------------
  |  Branch (349:29): [True: 38, False: 10]
  ------------------
  350|     38|                        {
  351|       |                            // The parse_instruction_argument function should already have added a parse error with more detail
  352|     38|                            break;
  353|     38|                        }
  354|       |
  355|       |                        // Successfully parsed one argument
  356|     10|                        InstructionArgument parsed_argument = optional_parsed_argument.value();
  357|       |
  358|     10|                        instruction.SetArgument(argument_num, parsed_argument);
  359|     10|                        argument_num++;
  360|     10|                        consumed_comma = false;
  361|       |
  362|       |                        //DLX_INFO("Successfully parsed argument {}", argument_num.unsafe());
  363|     10|                    }
  364|       |
  365|       |                    //DLX_INFO("Successfully parsed instruction '{}'",
  366|       |                    //            instruction.DebugInfo());
  367|    161|                    program.m_Instructions.emplace_back(instruction);
  368|    161|                    line_has_instruction = true;
  369|    161|                    break;
  370|    174|                }
  371|       |
  372|    967|                default:
  ------------------
  |  Branch (372:17): [True: 967, False: 5.45k]
  ------------------
  373|    967|                    Token::Type expected_token_type = Token::Type::Unknown;
  374|    967|                    if (line_has_instruction)
  ------------------
  |  Branch (374:25): [True: 81, False: 886]
  ------------------
  375|     81|                    {
  376|     81|                        expected_token_type = Token::Type::NewLine;
  377|     81|                    }
  378|       |
  379|    967|                    program.AddParseError(
  380|    967|                            ConstructUnexpectedTokenParseError(current_token, expected_token_type));
  381|    967|                    break;
  382|  6.42k|            }
  383|  6.42k|        }
  384|       |
  385|       |        // Check for empty labels
  386|  2.70k|        if (label_count > 0u)
  ------------------
  |  Branch (386:13): [True: 51, False: 2.65k]
  ------------------
  387|     51|        {
  388|    105|            for (auto it = tokens.rbegin(); label_count > 0u; ++it)
  ------------------
  |  Branch (388:45): [True: 54, False: 51]
  ------------------
  389|     54|            {
  390|     54|                PHI_ASSERT(it != tokens.rend(), "Iterator should never reach the end");
  391|       |
  392|     54|                const Token& token = *it;
  393|     54|                if (token.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (393:21): [True: 52, False: 2]
  ------------------
  394|     52|                {
  395|     52|                    program.AddParseError(ConstructEmptyLabelParseError(token));
  396|     52|                    --label_count;
  397|     52|                }
  398|     54|            }
  399|     51|        }
  400|       |
  401|  2.70k|        return program;
  402|  2.70k|    }
_ZN3dlx6Parser5ParseENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
  405|  2.70k|    {
  406|  2.70k|        TokenStream tokens = Tokenize(source);
  407|  2.70k|        return Parse(tokens);
  408|  2.70k|    }
Parser.cpp:_ZN3dlxL26parse_instruction_argumentERKNS_5TokenENS_12ArgumentTypeERNS_11TokenStreamERNS_13ParsedProgramE:
   33|     48|    {
   34|       |        // DLX_INFO("Parsing argument with token '{}' and expected type '{}'", token.DebugInfo(),
   35|       |        //              dlx::enum_name(expected_argument_type));
   36|       |
   37|     48|        switch (token.GetType())
   38|     48|        {
   39|      3|            case Token::Type::IntegerLiteral: {
  ------------------
  |  Branch (39:13): [True: 3, False: 45]
  ------------------
   40|      3|                if (!ArgumentTypeIncludes(expected_argument_type,
  ------------------
  |  Branch (40:21): [True: 3, False: 0]
  ------------------
   41|      3|                                          ArgumentType::AddressDisplacement))
   42|      3|                {
   43|      3|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
   44|      3|                            token, expected_argument_type, ArgumentType::AddressDisplacement));
   45|       |
   46|      3|                    return {};
   47|      3|                }
   48|       |
   49|       |                // Get address displacement
   50|      0|                PHI_ASSERT(token.HasHint());
   51|       |
   52|      0|                std::int16_t value = static_cast<std::int16_t>(token.GetHint());
   53|       |
   54|      0|                if (!tokens.has_x_more(3u))
  ------------------
  |  Branch (54:21): [True: 0, False: 0]
  ------------------
   55|      0|                {
   56|      0|                    program.AddParseError(
   57|      0|                            ConstructTooFewArgumentsAddressDisplacementParseError(token));
   58|      0|                    return {};
   59|      0|                }
   60|       |
   61|      0|                auto         it           = tokens.current_position();
   62|      0|                const Token& first_token  = tokens.consume();
   63|      0|                const Token& second_token = tokens.consume();
   64|      0|                const Token& third_token  = tokens.consume();
   65|       |
   66|      0|                if (first_token.GetType() != Token::Type::OpenBracket)
  ------------------
  |  Branch (66:21): [True: 0, False: 0]
  ------------------
   67|      0|                {
   68|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   69|      0|                            first_token, Token::Type::OpenBracket));
   70|      0|                    return {};
   71|      0|                }
   72|       |
   73|       |                // Second token is the register
   74|      0|                if (second_token.GetType() != Token::Type::RegisterInt)
  ------------------
  |  Branch (74:21): [True: 0, False: 0]
  ------------------
   75|      0|                {
   76|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   77|      0|                            second_token, Token::Type::RegisterInt));
   78|      0|                    return {};
   79|      0|                }
   80|       |
   81|      0|                if (third_token.GetType() != Token::Type::ClosingBracket)
  ------------------
  |  Branch (81:21): [True: 0, False: 0]
  ------------------
   82|      0|                {
   83|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   84|      0|                            third_token, Token::Type::ClosingBracket));
   85|      0|                    return {};
   86|      0|                }
   87|       |
   88|       |                // Consume the 3 tokens
   89|      0|                tokens.set_position(it + 3u);
   90|       |
   91|       |                //DLX_INFO("Parsed address displacement with '{}' displacement and Register '{}'",
   92|       |                //             value, dlx::enum_name(reg_id));
   93|       |
   94|      0|                return ConstructInstructionArgumentAddressDisplacement(
   95|      0|                        static_cast<IntRegisterID>(second_token.GetHint()), value);
   96|      0|            }
   97|      0|            case Token::Type::RegisterInt: {
  ------------------
  |  Branch (97:13): [True: 0, False: 48]
  ------------------
   98|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::IntRegister))
  ------------------
  |  Branch (98:21): [True: 0, False: 0]
  ------------------
   99|      0|                {
  100|      0|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  101|      0|                            token, expected_argument_type, ArgumentType::IntRegister));
  102|      0|                    return {};
  103|      0|                }
  104|       |
  105|       |                //DLX_INFO("Parsed identifier as int register {}",
  106|       |                //             dlx::enum_name(reg_id));
  107|       |
  108|      0|                return ConstructInstructionArgumentRegisterInt(
  109|      0|                        static_cast<IntRegisterID>(token.GetHint()));
  110|      0|            }
  111|      0|            case Token::Type::RegisterFloat: {
  ------------------
  |  Branch (111:13): [True: 0, False: 48]
  ------------------
  112|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::FloatRegister))
  ------------------
  |  Branch (112:21): [True: 0, False: 0]
  ------------------
  113|      0|                {
  114|      0|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  115|      0|                            token, expected_argument_type, ArgumentType::FloatRegister));
  116|      0|                    return {};
  117|      0|                }
  118|       |
  119|       |                //DLX_INFO("Parsed identifier as float register {}",
  120|       |                //             dlx::enum_name(float_reg_id));
  121|       |
  122|      0|                return ConstructInstructionArgumentRegisterFloat(
  123|      0|                        static_cast<FloatRegisterID>(token.GetHint()));
  124|      0|            }
  125|      0|            case Token::Type::RegisterStatus: {
  ------------------
  |  Branch (125:13): [True: 0, False: 48]
  ------------------
  126|      0|                program.AddParseError(ConstructReservedIdentiferParseError(token));
  127|       |
  128|      0|                return {};
  129|      0|            }
  130|     35|            case Token::Type::LabelIdentifier: {
  ------------------
  |  Branch (130:13): [True: 35, False: 13]
  ------------------
  131|       |                // Parse as Label
  132|     35|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::Label))
  ------------------
  |  Branch (132:21): [True: 7, False: 28]
  ------------------
  133|      7|                {
  134|      7|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  135|      7|                            token, expected_argument_type, ArgumentType::Label));
  136|      7|                    return {};
  137|      7|                }
  138|       |
  139|     28|                if (IsReservedIdentifier(token.GetText()))
  ------------------
  |  Branch (139:21): [True: 0, False: 28]
  ------------------
  140|      0|                {
  141|      0|                    program.AddParseError(ConstructReservedIdentiferParseError(token));
  142|      0|                    return {};
  143|      0|                }
  144|       |
  145|     28|                if (!IsValidIdentifier(token.GetText()))
  ------------------
  |  Branch (145:21): [True: 18, False: 10]
  ------------------
  146|     18|                {
  147|     18|                    program.AddParseError(ConstructInvalidLabelIdentifierParseError(token));
  148|     18|                    return {};
  149|     18|                }
  150|       |
  151|       |                //DLX_INFO("Parsed Label identifier as '{}'", token.GetText());
  152|       |
  153|     10|                return ConstructInstructionArgumentLabel(token.GetText());
  154|     28|            }
  155|      0|            case Token::Type::ImmediateInteger: {
  ------------------
  |  Branch (155:13): [True: 0, False: 48]
  ------------------
  156|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::ImmediateInteger))
  ------------------
  |  Branch (156:21): [True: 0, False: 0]
  ------------------
  157|      0|                {
  158|      0|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  159|      0|                            token, expected_argument_type, ArgumentType::ImmediateInteger));
  160|      0|                    return {};
  161|      0|                }
  162|       |
  163|      0|                if (token.HasHint())
  ------------------
  |  Branch (163:21): [True: 0, False: 0]
  ------------------
  164|      0|                {
  165|      0|                    return ConstructInstructionArgumentImmediateValue(
  166|      0|                            static_cast<std::int16_t>(token.GetHint()));
  167|      0|                }
  168|       |
  169|      0|                program.AddParseError(ConstructInvalidNumberParseError(token));
  170|      0|                return {};
  171|      0|            }
  172|       |
  173|     10|            default:
  ------------------
  |  Branch (173:13): [True: 10, False: 38]
  ------------------
  174|     10|                program.AddParseError(
  175|     10|                        ConstructUnexpectedTokenParseError(token, Token::Type::Unknown));
  176|     10|                return {};
  177|     48|        }
  178|     48|    }
Parser.cpp:_ZZN3dlx6Parser5ParseERNS_11TokenStreamEENK3$_0clERKNS_5TokenE:
  247|      9|                                tokens.find_first_token_if([&](const Token& t) {
  248|      9|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (248:41): [True: 9, False: 0]
  ------------------
  249|      9|                                    {
  250|      9|                                        std::string_view token_label_name = t.GetText();
  251|      9|                                        token_label_name.remove_suffix(1);
  252|       |
  253|      9|                                        if (token_label_name == label_name)
  ------------------
  |  Branch (253:45): [True: 9, False: 0]
  ------------------
  254|      9|                                        {
  255|      9|                                            return true;
  256|      9|                                        }
  257|      9|                                    }
  258|       |
  259|      0|                                    return false;
  260|      9|                                });

_ZN3dlx9ProcessorC2Ev:
   63|  7.25k|    {
   64|       |        // Mark R0 as ready only
   65|  7.25k|        m_IntRegisters[0].SetReadOnly(true);
   66|  7.25k|    }
_ZN3dlx9Processor11LoadProgramERNS_13ParsedProgramE:
  352|    284|    {
  353|    284|        if (!program.m_ParseErrors.empty())
  ------------------
  |  Branch (353:13): [True: 0, False: 284]
  ------------------
  354|      0|        {
  355|      0|            DLX_WARN("Trying to load program with parsing errors");
  ------------------
  |  |    8|      0|#define DLX_WARN(...)     PHI_EMPTY_MACRO()
  ------------------
  356|      0|            return false;
  357|      0|        }
  358|       |
  359|    284|        m_CurrentProgram = &program;
  360|       |
  361|    284|        m_ProgramCounter               = 0u;
  362|    284|        m_Halted                       = false;
  363|    284|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  364|    284|        m_LastRaisedException          = Exception::None;
  365|    284|        m_CurrentStepCount             = 0u;
  366|       |
  367|    284|        return true;
  368|    284|    }
_ZNK3dlx9Processor8IsHaltedEv:
  547|      7|    {
  548|      7|        return m_Halted;
  549|      7|    }

_ZN3dlx19StringToIntRegisterENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
   13|  4.02k|    {
   14|  4.02k|        if (token.length() == 2)
  ------------------
  |  Branch (14:13): [True: 1.01k, False: 3.00k]
  ------------------
   15|  1.01k|        {
   16|  1.01k|            char first_char = token[0];
   17|  1.01k|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (17:17): [True: 71, False: 944]
  |  Branch (17:38): [True: 1, False: 943]
  ------------------
   18|     72|            {
   19|     72|                char second_char = token[1];
   20|     72|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (20:21): [True: 69, False: 3]
  |  Branch (20:43): [True: 11, False: 58]
  ------------------
   21|     11|                {
   22|     11|                    return static_cast<IntRegisterID>(second_char - '0');
   23|     11|                }
   24|     72|            }
   25|  1.01k|        }
   26|  3.00k|        else if (token.length() == 3)
  ------------------
  |  Branch (26:18): [True: 775, False: 2.23k]
  ------------------
   27|    775|        {
   28|    775|            char first_char = token[0];
   29|    775|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (29:17): [True: 18, False: 757]
  |  Branch (29:38): [True: 3, False: 754]
  ------------------
   30|     21|            {
   31|     21|                char second_char = token[1];
   32|     21|                char third_char  = token[2];
   33|       |
   34|     21|                switch (second_char)
   35|     21|                {
   36|      1|                    case '1': {
  ------------------
  |  Branch (36:21): [True: 1, False: 20]
  ------------------
   37|      1|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (37:29): [True: 1, False: 0]
  |  Branch (37:50): [True: 0, False: 1]
  ------------------
   38|      0|                        {
   39|      0|                            return static_cast<IntRegisterID>(third_char - '0' + 10);
   40|      0|                        }
   41|      1|                        break;
   42|      1|                    }
   43|      2|                    case '2': {
  ------------------
  |  Branch (43:21): [True: 2, False: 19]
  ------------------
   44|      2|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (44:29): [True: 2, False: 0]
  |  Branch (44:50): [True: 0, False: 2]
  ------------------
   45|      0|                        {
   46|      0|                            return static_cast<IntRegisterID>(third_char - '0' + 20);
   47|      0|                        }
   48|      2|                        break;
   49|      2|                    }
   50|      2|                    case '3': {
  ------------------
  |  Branch (50:21): [True: 1, False: 20]
  ------------------
   51|      1|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (51:29): [True: 0, False: 1]
  |  Branch (51:50): [True: 0, False: 1]
  ------------------
   52|      0|                        {
   53|      0|                            return static_cast<IntRegisterID>(third_char - '0' + 30);
   54|      0|                        }
   55|      1|                        break;
   56|      1|                    }
   57|     17|                    default: {
  ------------------
  |  Branch (57:21): [True: 17, False: 4]
  ------------------
   58|     17|                        break;
   59|      1|                    }
   60|     21|                }
   61|     21|            }
   62|    775|        }
   63|       |
   64|  4.01k|        return IntRegisterID::None;
   65|  4.02k|    }
_ZN3dlx21StringToFloatRegisterENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
   68|  4.01k|    {
   69|  4.01k|        if (token.length() == 2)
  ------------------
  |  Branch (69:13): [True: 1.00k, False: 3.00k]
  ------------------
   70|  1.00k|        {
   71|  1.00k|            char first_char = token[0];
   72|  1.00k|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (72:17): [True: 3, False: 1.00k]
  |  Branch (72:38): [True: 1, False: 1.00k]
  ------------------
   73|      4|            {
   74|      4|                char second_char = token[1];
   75|      4|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (75:21): [True: 1, False: 3]
  |  Branch (75:43): [True: 0, False: 1]
  ------------------
   76|      0|                {
   77|      0|                    return static_cast<FloatRegisterID>(second_char - '0');
   78|      0|                }
   79|      4|            }
   80|  1.00k|        }
   81|  3.00k|        else if (token.length() == 3)
  ------------------
  |  Branch (81:18): [True: 775, False: 2.23k]
  ------------------
   82|    775|        {
   83|    775|            char first_char = token[0];
   84|    775|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (84:17): [True: 11, False: 764]
  |  Branch (84:38): [True: 1, False: 763]
  ------------------
   85|     12|            {
   86|     12|                char second_char = token[1];
   87|     12|                char third_char  = token[2];
   88|       |
   89|     12|                switch (second_char)
   90|     12|                {
   91|      0|                    case '1': {
  ------------------
  |  Branch (91:21): [True: 0, False: 12]
  ------------------
   92|      0|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (92:29): [True: 0, False: 0]
  |  Branch (92:50): [True: 0, False: 0]
  ------------------
   93|      0|                        {
   94|      0|                            return static_cast<FloatRegisterID>(third_char - '0' + 10);
   95|      0|                        }
   96|      0|                        break;
   97|      0|                    }
   98|      0|                    case '2': {
  ------------------
  |  Branch (98:21): [True: 0, False: 12]
  ------------------
   99|      0|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (99:29): [True: 0, False: 0]
  |  Branch (99:50): [True: 0, False: 0]
  ------------------
  100|      0|                        {
  101|      0|                            return static_cast<FloatRegisterID>(third_char - '0' + 20);
  102|      0|                        }
  103|      0|                        break;
  104|      0|                    }
  105|      0|                    case '3': {
  ------------------
  |  Branch (105:21): [True: 0, False: 12]
  ------------------
  106|      0|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (106:29): [True: 0, False: 0]
  |  Branch (106:50): [True: 0, False: 0]
  ------------------
  107|      0|                        {
  108|      0|                            return static_cast<FloatRegisterID>(third_char - '0' + 30);
  109|      0|                        }
  110|      0|                        break;
  111|      0|                    }
  112|     12|                    default: {
  ------------------
  |  Branch (112:21): [True: 12, False: 0]
  ------------------
  113|     12|                        break;
  114|      0|                    }
  115|     12|                }
  116|     12|            }
  117|    775|        }
  118|       |
  119|  4.01k|        return FloatRegisterID::None;
  120|  4.01k|    }
_ZN3dlx6IsFPSRENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
  123|  4.01k|    {
  124|  4.01k|        if (token.length() == 4)
  ------------------
  |  Branch (124:13): [True: 873, False: 3.14k]
  ------------------
  125|    873|        {
  126|    873|            char c1 = token[0];
  127|    873|            char c2 = token[1];
  128|    873|            char c3 = token[2];
  129|    873|            char c4 = token[3];
  130|       |
  131|    873|            return (c1 == 'F' || c1 == 'f') && (c2 == 'P' || c2 == 'p') &&
  ------------------
  |  Branch (131:21): [True: 3, False: 870]
  |  Branch (131:34): [True: 3, False: 867]
  |  Branch (131:49): [True: 0, False: 6]
  |  Branch (131:62): [True: 1, False: 5]
  ------------------
  132|    873|                   (c3 == 'S' || c3 == 's') && (c4 == 'R' || c4 == 'r');
  ------------------
  |  Branch (132:21): [True: 0, False: 1]
  |  Branch (132:34): [True: 0, False: 1]
  |  Branch (132:49): [True: 0, False: 0]
  |  Branch (132:62): [True: 0, False: 0]
  ------------------
  133|    873|        }
  134|       |
  135|  3.14k|        return false;
  136|  4.01k|    }

_ZN3dlx5TokenC2ENS0_4TypeENSt3__117basic_string_viewIcNS2_11char_traitsIcEEEEN3phi7integerImEES9_:
   27|  6.29k|    {}
_ZN3dlx5TokenC2ENS0_4TypeENSt3__117basic_string_viewIcNS2_11char_traitsIcEEEEN3phi7integerImEES9_j:
   37|    296|    {}
_ZNK3dlx5Token7GetTypeEv:
   40|  14.5k|    {
   41|  14.5k|        return m_Type;
   42|  14.5k|    }
_ZNK3dlx5Token13GetLineNumberEv:
   50|  14.7k|    {
   51|  14.7k|        return m_LineNumber;
   52|  14.7k|    }
_ZNK3dlx5Token9GetColumnEv:
   55|  30.1k|    {
   56|  30.1k|        return m_Column;
   57|  30.1k|    }
_ZNK3dlx5Token9GetLengthEv:
   60|  20.4k|    {
   61|  20.4k|        return m_Text.length();
   62|  20.4k|    }
_ZNK3dlx5Token7GetTextEv:
   65|  7.36k|    {
   66|  7.36k|        return m_Text;
   67|  7.36k|    }
_ZNK3dlx5Token7HasHintEv:
   79|    161|    {
   80|    161|        return m_HasHint;
   81|    161|    }
_ZNK3dlx5Token7GetHintEv:
   84|    161|    {
   85|    161|        PHI_ASSERT(m_Type == Type::RegisterInt || m_Type == Type::RegisterFloat ||
   86|    161|                   m_Type == Type::IntegerLiteral || m_Type == Type::OpCode ||
   87|    161|                   m_Type == Type::ImmediateInteger);
   88|    161|        PHI_ASSERT(m_HasHint);
   89|       |
   90|    161|        return m_Hint;
   91|    161|    }

_ZN3dlx11TokenStream8finalizeEv:
   29|  2.70k|    {
   30|       |#if defined(PHI_DEBUG)
   31|       |        PHI_ASSERT(!m_Finialized);
   32|       |#endif
   33|       |
   34|  2.70k|        m_Iterator = m_Tokens.begin();
   35|       |#if defined(PHI_DEBUG)
   36|       |        m_Finialized = true;
   37|       |#endif
   38|  2.70k|    }
_ZNK3dlx11TokenStream8has_moreEv:
   64|  9.30k|    {
   65|  9.30k|        return m_Iterator != m_Tokens.end();
   66|  9.30k|    }
_ZNK3dlx11TokenStream11reached_endEv:
   69|  6.58k|    {
   70|  6.58k|        return m_Iterator == m_Tokens.end();
   71|  6.58k|    }
_ZN3dlx11TokenStream7consumeEv:
   84|  6.58k|    {
   85|  6.58k|        PHI_ASSERT(!reached_end());
   86|       |#if defined(PHI_DEBUG)
   87|       |        PHI_ASSERT(m_Finialized);
   88|       |#endif
   89|       |
   90|  6.58k|        return *m_Iterator++;
   91|  6.58k|    }
_ZNK3dlx11TokenStream5beginEv:
  182|  2.70k|    {
  183|       |#if defined(PHI_DEBUG)
  184|       |        //PHI_ASSERT(m_Finialized);
  185|       |#endif
  186|       |
  187|  2.70k|        return m_Tokens.begin();
  188|  2.70k|    }
_ZNK3dlx11TokenStream3endEv:
  200|  2.70k|    {
  201|       |#if defined(PHI_DEBUG)
  202|       |        //PHI_ASSERT(m_Finialized);
  203|       |#endif
  204|       |
  205|  2.70k|        return m_Tokens.end();
  206|  2.70k|    }
_ZNK3dlx11TokenStream6rbeginEv:
  218|     51|    {
  219|       |#if defined(PHI_DEBUG)
  220|       |        //PHI_ASSERT(m_Finialized);
  221|       |#endif
  222|       |
  223|     51|        return m_Tokens.rbegin();
  224|     51|    }
_ZNK3dlx11TokenStream4rendEv:
  227|     54|    {
  228|       |#if defined(PHI_DEBUG)
  229|       |        //PHI_ASSERT(m_Finialized);
  230|       |#endif
  231|       |
  232|     54|        return m_Tokens.rend();
  233|     54|    }

_ZN3dlx8TokenizeENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
   62|  2.70k|    {
   63|  2.70k|        TokenStream tokens;
   64|       |
   65|  2.70k|        std::string_view current_token;
   66|       |
   67|  2.70k|        phi::u64 current_line_number{1u};
   68|  2.70k|        phi::u64 current_column{1u};
   69|  2.70k|        phi::u64 token_begin{0u};
   70|       |
   71|  2.70k|        phi::boolean parsing_comment{false};
   72|       |
   73|  21.4k|        for (phi::usize i{0u}; i < source.length(); ++i)
  ------------------
  |  Branch (73:32): [True: 18.7k, False: 2.70k]
  ------------------
   74|  18.7k|        {
   75|  18.7k|            const char c{source.at(i.unsafe())};
   76|       |
   77|  18.7k|            if (c == '\n')
  ------------------
  |  Branch (77:17): [True: 1.64k, False: 17.0k]
  ------------------
   78|  1.64k|            {
   79|  1.64k|                if (current_token.empty())
  ------------------
  |  Branch (79:21): [True: 657, False: 990]
  ------------------
   80|    657|                {
   81|       |                    // Skip empty lines
   82|    657|                    tokens.emplace_back(Token::Type::NewLine, source.substr(i.unsafe(), 1u),
   83|    657|                                        current_line_number, current_column);
   84|       |
   85|    657|                    parsing_comment = false;
   86|    657|                    current_line_number += 1u;
   87|    657|                    current_column = 1u;
   88|    657|                    continue;
   89|    657|                }
   90|       |
   91|       |                // Otherwise a new line separates tokens
   92|    990|                tokens.emplace_back(
   93|    990|                        ParseToken(source.substr(token_begin.unsafe(), current_token.length()),
   94|    990|                                   current_line_number, current_column - current_token.length()));
   95|       |
   96|    990|                tokens.emplace_back(Token::Type::NewLine, source.substr(i.unsafe(), 1),
   97|    990|                                    current_line_number, current_column);
   98|       |
   99|    990|                current_token   = std::string_view{};
  100|    990|                parsing_comment = false;
  101|    990|                current_line_number += 1u;
  102|    990|                current_column = 0u;
  103|    990|            }
  104|       |            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  105|  17.0k|            else if (c == '/' || c == ';')
  ------------------
  |  Branch (105:22): [True: 133, False: 16.9k]
  |  Branch (105:34): [True: 18, False: 16.9k]
  ------------------
  106|    151|            {
  107|    151|                if (current_token.empty())
  ------------------
  |  Branch (107:21): [True: 73, False: 78]
  ------------------
  108|     73|                {
  109|     73|                    token_begin = i;
  110|     73|                }
  111|     78|                else if (!parsing_comment)
  ------------------
  |  Branch (111:26): [True: 58, False: 20]
  ------------------
  112|     58|                {
  113|     58|                    tokens.emplace_back(ParseToken(
  114|     58|                            source.substr(token_begin.unsafe(), current_token.length()),
  115|     58|                            current_line_number, current_column - current_token.length()));
  116|     58|                    token_begin   = i;
  117|     58|                    current_token = std::string_view{};
  118|     58|                }
  119|       |
  120|    151|                parsing_comment = true;
  121|    151|                current_token   = source.substr(token_begin.unsafe(), current_token.length() + 1);
  122|    151|            }
  123|  16.9k|            else if (parsing_comment)
  ------------------
  |  Branch (123:22): [True: 193, False: 16.7k]
  ------------------
  124|    193|            {
  125|       |                // simply append the character
  126|    193|                current_token = source.substr(token_begin.unsafe(), current_token.length() + 1);
  127|    193|            }
  128|  16.7k|            else
  129|  16.7k|            {
  130|       |                // Not parsing a comment
  131|  16.7k|                switch (c)
  132|  16.7k|                {
  133|    473|                    case ' ':
  ------------------
  |  Branch (133:21): [True: 473, False: 16.2k]
  ------------------
  134|  1.46k|                    case '\t':
  ------------------
  |  Branch (134:21): [True: 992, False: 15.7k]
  ------------------
  135|  1.53k|                    case '\v':
  ------------------
  |  Branch (135:21): [True: 69, False: 16.6k]
  ------------------
  136|  1.53k|                        if (current_token.empty())
  ------------------
  |  Branch (136:29): [True: 1.20k, False: 325]
  ------------------
  137|  1.20k|                        {
  138|  1.20k|                            current_column += 1u;
  139|       |                            // We haven't found any usable character for the current token so just skip the whitespace.
  140|  1.20k|                            continue;
  141|  1.20k|                        }
  142|       |
  143|       |                        // Otherwise a whitespace separates tokens
  144|    325|                        tokens.emplace_back(ParseToken(
  145|    325|                                source.substr(token_begin.unsafe(), current_token.length()),
  146|    325|                                current_line_number, current_column - current_token.length()));
  147|    325|                        current_token = std::string_view{};
  148|    325|                        break;
  149|    225|                    case ':':
  ------------------
  |  Branch (149:21): [True: 225, False: 16.5k]
  ------------------
  150|       |                        // Need to parse label names together with their colon
  151|    225|                        if (!current_token.empty())
  ------------------
  |  Branch (151:29): [True: 163, False: 62]
  ------------------
  152|    163|                        {
  153|    163|                            current_token =
  154|    163|                                    source.substr(token_begin.unsafe(), current_token.length() + 1);
  155|    163|                            tokens.emplace_back(ParseToken(
  156|    163|                                    source.substr(token_begin.unsafe(), current_token.length()),
  157|    163|                                    current_line_number,
  158|    163|                                    current_column + 1u - current_token.length()));
  159|       |
  160|    163|                            current_token = std::string_view{};
  161|    163|                        }
  162|     62|                        else
  163|     62|                        {
  164|       |                            // Orphan colon
  165|     62|                            token_begin = i;
  166|       |
  167|     62|                            tokens.emplace_back(Token::Type::Colon,
  168|     62|                                                source.substr(token_begin.unsafe(), 1),
  169|     62|                                                current_line_number, current_column);
  170|     62|                        }
  171|    225|                        break;
  172|     70|                    case ',':
  ------------------
  |  Branch (172:21): [True: 70, False: 16.6k]
  ------------------
  173|     80|                    case '(':
  ------------------
  |  Branch (173:21): [True: 10, False: 16.7k]
  ------------------
  174|    788|                    case ')':
  ------------------
  |  Branch (174:21): [True: 708, False: 16.0k]
  ------------------
  175|    788|                        if (!current_token.empty())
  ------------------
  |  Branch (175:29): [True: 583, False: 205]
  ------------------
  176|    583|                        {
  177|    583|                            tokens.emplace_back(ParseToken(
  178|    583|                                    source.substr(token_begin.unsafe(), current_token.length()),
  179|    583|                                    current_line_number, current_column - current_token.length()));
  180|       |
  181|    583|                            current_token = std::string_view{};
  182|    583|                        }
  183|       |
  184|    788|                        Token::Type type;
  185|    788|                        switch (c)
  186|    788|                        {
  187|     70|                            case ',':
  ------------------
  |  Branch (187:29): [True: 70, False: 718]
  ------------------
  188|     70|                                type = Token::Type::Comma;
  189|     70|                                break;
  190|     10|                            case '(':
  ------------------
  |  Branch (190:29): [True: 10, False: 778]
  ------------------
  191|     10|                                type = Token::Type::OpenBracket;
  192|     10|                                break;
  193|    708|                            case ')':
  ------------------
  |  Branch (193:29): [True: 708, False: 80]
  ------------------
  194|    708|                                type = Token::Type::ClosingBracket;
  195|    708|                                break;
  196|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  197|      0|                            default:
  ------------------
  |  Branch (197:29): [True: 0, False: 788]
  ------------------
  198|      0|                                PHI_ASSERT_NOT_REACHED();
  199|      0|                                break;
  200|    788|#endif
  201|    788|                        }
  202|       |
  203|    788|                        token_begin = i;
  204|       |
  205|    788|                        tokens.emplace_back(type, source.substr(token_begin.unsafe(), 1),
  206|    788|                                            current_line_number, current_column);
  207|    788|                        break;
  208|       |
  209|  14.1k|                    default:
  ------------------
  |  Branch (209:21): [True: 14.1k, False: 2.54k]
  ------------------
  210|  14.1k|                        if (current_token.empty())
  ------------------
  |  Branch (210:29): [True: 3.95k, False: 10.2k]
  ------------------
  211|  3.95k|                        {
  212|  3.95k|                            token_begin = i;
  213|  3.95k|                        }
  214|       |
  215|       |                        // simply append the character
  216|  14.1k|                        current_token =
  217|  14.1k|                                source.substr(token_begin.unsafe(), current_token.length() + 1);
  218|  16.7k|                }
  219|  16.7k|            }
  220|       |
  221|  16.8k|            current_column += 1u;
  222|  16.8k|        }
  223|       |
  224|       |        // Checked the entire string. Parse whats left if anything
  225|  2.70k|        if (!current_token.empty())
  ------------------
  |  Branch (225:13): [True: 1.97k, False: 731]
  ------------------
  226|  1.97k|        {
  227|  1.97k|            tokens.emplace_back(
  228|  1.97k|                    ParseToken(source.substr(token_begin.unsafe(), current_token.length()),
  229|  1.97k|                               current_line_number, current_column - current_token.length()));
  230|  1.97k|        }
  231|       |
  232|       |        // Finialize token stream
  233|  2.70k|        tokens.finalize();
  234|       |
  235|  2.70k|        return tokens;
  236|  2.70k|    }
Tokenize.cpp:_ZN3dlxL10ParseTokenENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEEN3phi7integerImEES7_:
   10|  4.09k|    {
   11|  4.09k|        if (token.at(0) == '#' && token.size() > 1)
  ------------------
  |  Branch (11:13): [True: 23, False: 4.06k]
  |  Branch (11:35): [True: 15, False: 8]
  ------------------
   12|     15|        {
   13|     15|            auto number = ParseNumber(token.substr(1u));
   14|       |
   15|     15|            if (number)
  ------------------
  |  Branch (15:17): [True: 0, False: 15]
  ------------------
   16|      0|            {
   17|      0|                return {Token::Type::ImmediateInteger, token, line_number, column,
   18|      0|                        static_cast<std::uint32_t>(number.value().unsafe())};
   19|      0|            }
   20|       |
   21|     15|            return {Token::Type::ImmediateInteger, token, line_number, column};
   22|     15|        }
   23|       |
   24|  4.07k|        if (token.at(0) == '/' || token.at(0) == ';')
  ------------------
  |  Branch (24:13): [True: 113, False: 3.96k]
  |  Branch (24:35): [True: 18, False: 3.94k]
  ------------------
   25|    131|        {
   26|    131|            return {Token::Type::Comment, token, line_number, column};
   27|    131|        }
   28|       |
   29|  3.94k|        if (phi::optional<phi::i16> number = ParseNumber(token); number.has_value())
  ------------------
  |  Branch (29:66): [True: 113, False: 3.83k]
  ------------------
   30|    113|        {
   31|    113|            return {Token::Type::IntegerLiteral, token, line_number, column,
   32|    113|                    static_cast<std::uint32_t>(number->unsafe())};
   33|    113|        }
   34|       |
   35|  3.83k|        if (IsFPSR(token))
  ------------------
  |  Branch (35:13): [True: 0, False: 3.83k]
  ------------------
   36|      0|        {
   37|      0|            return {Token::Type::RegisterStatus, token, line_number, column};
   38|      0|        }
   39|       |
   40|  3.83k|        if (IntRegisterID id = StringToIntRegister(token); id != IntRegisterID::None)
  ------------------
  |  Branch (40:60): [True: 9, False: 3.82k]
  ------------------
   41|      9|        {
   42|      9|            return {Token::Type::RegisterInt, token, line_number, column,
   43|      9|                    static_cast<std::uint32_t>(id)};
   44|      9|        }
   45|       |
   46|  3.82k|        if (FloatRegisterID id = StringToFloatRegister(token); id != FloatRegisterID::None)
  ------------------
  |  Branch (46:64): [True: 0, False: 3.82k]
  ------------------
   47|      0|        {
   48|      0|            return {Token::Type::RegisterFloat, token, line_number, column,
   49|      0|                    static_cast<std::uint32_t>(id)};
   50|      0|        }
   51|       |
   52|  3.82k|        if (OpCode opcode = StringToOpCode(token); opcode != OpCode::NONE)
  ------------------
  |  Branch (52:52): [True: 174, False: 3.64k]
  ------------------
   53|    174|        {
   54|    174|            return {Token::Type::OpCode, token, line_number, column,
   55|    174|                    static_cast<std::uint32_t>(opcode)};
   56|    174|        }
   57|       |
   58|  3.64k|        return {Token::Type::LabelIdentifier, token, line_number, column};
   59|  3.82k|    }

_ZN3fmt2v96detail6bufferIcE10try_resizeEm:
  932|   201k|  FMT_CONSTEXPR20 void try_resize(size_t count) {
  933|   201k|    try_reserve(count);
  934|   201k|    size_ = count <= capacity_ ? count : capacity_;
  ------------------
  |  Branch (934:13): [True: 201k, False: 0]
  ------------------
  935|   201k|  }
_ZN3fmt2v96detail11to_unsignedIiEENSt3__113make_unsignedIT_E4typeES5_:
  406|  70.0M|    typename std::make_unsigned<Int>::type {
  407|  70.0M|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  365|   140M|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (365:37): [Folded - Ignored]
  |  |  |  Branch (365:37): [True: 70.0M, False: 0]
  |  |  ------------------
  ------------------
  408|  70.0M|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  409|  70.0M|}
_ZN3fmt2v96detail13ignore_unusedIJbA15_cEEEvDpRKT_:
  341|  72.5M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt2v917basic_string_viewIcE4sizeEv:
  473|  1.79M|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail13ignore_unusedIJbA1_cEEEvDpRKT_:
  341|  12.4M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt2v96detail6bufferIcE4sizeEv:
  916|   454k|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail6bufferIcEC2EPcmm:
  888|   369k|      : ptr_(p), size_(sz), capacity_(cap) {}
_ZN3fmt2v96detail6bufferIcE3setEPcm:
  894|   369k|  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  895|   369k|    ptr_ = buf_data;
  896|   369k|    capacity_ = buf_capacity;
  897|   369k|  }
_ZNK3fmt2v96detail6bufferIcE8capacityEv:
  919|  84.7k|  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
_ZN3fmt2v96detail6bufferIcE4dataEv:
  922|   846k|  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
_ZN3fmt2v96detail22code_point_length_implEc:
 2307|  77.5k|FMT_CONSTEXPR inline auto code_point_length_impl(char c) -> int {
 2308|  77.5k|  return "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\0\2\2\2\2\3\3\4"
 2309|  77.5k|      [static_cast<unsigned char>(c) >> 3];
 2310|  77.5k|}
_ZN3fmt2v96detail6bufferIcE9push_backERKc:
  945|   515k|  FMT_CONSTEXPR20 void push_back(const T& value) {
  946|   515k|    try_reserve(size_ + 1);
  947|   515k|    ptr_[size_++] = value;
  948|   515k|  }
_ZNK3fmt2v917basic_string_viewIcE5beginEv:
  475|   743k|  constexpr auto begin() const noexcept -> iterator { return data_; }
_ZNK3fmt2v917basic_string_viewIcE3endEv:
  476|   743k|  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
_ZN3fmt2v917basic_string_viewIcEC2EPKc:
  456|   118k|                  : std::char_traits<Char>::length(s)) {}
_ZN3fmt2v96detail10locale_refC2Ev:
 1730|   371k|  constexpr FMT_INLINE locale_ref() : locale_(nullptr) {}
_ZNK3fmt2v919basic_format_stringIcJEEcvNS0_17basic_string_viewIcEEEv:
 3175|  31.7k|  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
_ZN3fmt2v916make_format_argsINS0_20basic_format_contextINS0_8appenderEcEEJEEENS0_16format_arg_storeIT_JDpNSt3__19remove_cvINS7_16remove_referenceIT0_E4typeEE4typeEEEEDpOSA_:
 1932|  31.7k|    -> format_arg_store<Context, remove_cvref_t<Args>...> {
 1933|  31.7k|  return {FMT_FORWARD(args)...};
 1934|  31.7k|}
_ZN3fmt2v916format_arg_storeINS0_20basic_format_contextINS0_8appenderEcEEJEEC2IJEEEDpOT_:
 1917|  31.7k|            FMT_FORWARD(args))...} {
 1918|  31.7k|    detail::init_named_args(data_.named_args(), 0, 0, args...);
 1919|  31.7k|  }
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EEC2IJEEEDpRKT_:
 1189|  31.7k|  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1283|   523k|  constexpr FMT_INLINE value() : no_value() {}
_ZN3fmt2v99monostateC2Ev:
  324|   523k|  constexpr monostate() {}
_ZN3fmt2v96detail15init_named_argsIJEEEvDniiDpRKT_:
 1222|  31.7k|                                              const Args&...) {}
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EE10named_argsEv:
 1191|  31.7k|  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
 1192|  31.7k|    return nullptr;
 1193|  31.7k|  }
_ZN3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEC2IJEEERKNS0_16format_arg_storeIS4_JDpT_EEE:
 2015|  31.7k|                          store.data_.args()) {}
_ZNK3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EE4argsEv:
 1190|  31.7k|  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
_ZN3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEC2EyPKNS0_6detail5valueIS4_EE:
 1999|   253k|      : desc_(desc), values_(values) {}
_ZNK3fmt2v917basic_string_viewIcE4dataEv:
  470|   797k|  constexpr auto data() const noexcept -> const Char* { return data_; }
_ZN3fmt2v917basic_string_viewIcEC2EPKcm:
  441|  1.03M|      : data_(s), size_(count) {}
_ZN3fmt2v96detail13ignore_unusedIJbA18_cEEEvDpRKT_:
  341|  5.95M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt2v96detail11to_unsignedIlEENSt3__113make_unsignedIT_E4typeES5_:
  406|  2.41M|    typename std::make_unsigned<Int>::type {
  407|  2.41M|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  365|  4.82M|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (365:37): [Folded - Ignored]
  |  |  |  Branch (365:37): [True: 2.41M, False: 0]
  |  |  ------------------
  ------------------
  408|  2.41M|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  409|  2.41M|}
_ZN3fmt2v96detail6bufferIcE11try_reserveEm:
  941|  1.80M|  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
  942|  1.80M|    if (new_capacity > capacity_) grow(new_capacity);
  ------------------
  |  Branch (942:9): [True: 0, False: 1.80M]
  ------------------
  943|  1.80M|  }
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE3getEi:
 2037|   491k|  FMT_CONSTEXPR auto get(int id) const -> format_arg {
 2038|   491k|    format_arg arg;
 2039|   491k|    if (!is_packed()) {
  ------------------
  |  Branch (2039:9): [True: 0, False: 491k]
  ------------------
 2040|      0|      if (id < max_size()) arg = args_[id];
  ------------------
  |  Branch (2040:11): [True: 0, False: 0]
  ------------------
 2041|      0|      return arg;
 2042|      0|    }
 2043|   491k|    if (id >= detail::max_packed_args) return arg;
  ------------------
  |  Branch (2043:9): [True: 0, False: 491k]
  ------------------
 2044|   491k|    arg.type_ = type(id);
 2045|   491k|    if (arg.type_ == detail::type::none_type) return arg;
  ------------------
  |  Branch (2045:9): [True: 0, False: 491k]
  ------------------
 2046|   491k|    arg.value_ = values_[id];
 2047|   491k|    return arg;
 2048|   491k|  }
_ZN3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1616|   491k|  constexpr basic_format_arg() : type_(detail::type::none_type) {}
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE9is_packedEv:
 1984|   491k|  constexpr auto is_packed() const -> bool {
 1985|   491k|    return (desc_ & detail::is_unpacked_bit) == 0;
 1986|   491k|  }
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE4typeEi:
 1991|   491k|  FMT_CONSTEXPR auto type(int index) const -> detail::type {
 1992|   491k|    int shift = index * detail::packed_arg_bits;
 1993|   491k|    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
 1994|   491k|    return static_cast<detail::type>((desc_ >> shift) & mask);
 1995|   491k|  }
_ZNK3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEcvbEv:
 1618|   491k|  constexpr explicit operator bool() const noexcept {
 1619|   491k|    return type_ != detail::type::none_type;
 1620|   491k|  }
_ZN3fmt2v916visit_format_argINS0_6detail21default_arg_formatterIcEENS0_20basic_format_contextINS0_8appenderEcEEEEDTclfp_Li0EEEOT_RKNS0_16basic_format_argIT0_EE:
 1639|  7.21k|    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
 1640|  7.21k|  switch (arg.type_) {
  ------------------
  |  Branch (1640:11): [True: 0, False: 7.21k]
  ------------------
 1641|      0|  case detail::type::none_type:
  ------------------
  |  Branch (1641:3): [True: 0, False: 7.21k]
  ------------------
 1642|      0|    break;
 1643|  5.89k|  case detail::type::int_type:
  ------------------
  |  Branch (1643:3): [True: 5.89k, False: 1.32k]
  ------------------
 1644|  5.89k|    return vis(arg.value_.int_value);
 1645|  1.32k|  case detail::type::uint_type:
  ------------------
  |  Branch (1645:3): [True: 1.32k, False: 5.89k]
  ------------------
 1646|  1.32k|    return vis(arg.value_.uint_value);
 1647|      0|  case detail::type::long_long_type:
  ------------------
  |  Branch (1647:3): [True: 0, False: 7.21k]
  ------------------
 1648|      0|    return vis(arg.value_.long_long_value);
 1649|      0|  case detail::type::ulong_long_type:
  ------------------
  |  Branch (1649:3): [True: 0, False: 7.21k]
  ------------------
 1650|      0|    return vis(arg.value_.ulong_long_value);
 1651|      0|  case detail::type::int128_type:
  ------------------
  |  Branch (1651:3): [True: 0, False: 7.21k]
  ------------------
 1652|      0|    return vis(detail::convert_for_visit(arg.value_.int128_value));
 1653|      0|  case detail::type::uint128_type:
  ------------------
  |  Branch (1653:3): [True: 0, False: 7.21k]
  ------------------
 1654|      0|    return vis(detail::convert_for_visit(arg.value_.uint128_value));
 1655|      0|  case detail::type::bool_type:
  ------------------
  |  Branch (1655:3): [True: 0, False: 7.21k]
  ------------------
 1656|      0|    return vis(arg.value_.bool_value);
 1657|      0|  case detail::type::char_type:
  ------------------
  |  Branch (1657:3): [True: 0, False: 7.21k]
  ------------------
 1658|      0|    return vis(arg.value_.char_value);
 1659|      0|  case detail::type::float_type:
  ------------------
  |  Branch (1659:3): [True: 0, False: 7.21k]
  ------------------
 1660|      0|    return vis(arg.value_.float_value);
 1661|      0|  case detail::type::double_type:
  ------------------
  |  Branch (1661:3): [True: 0, False: 7.21k]
  ------------------
 1662|      0|    return vis(arg.value_.double_value);
 1663|      0|  case detail::type::long_double_type:
  ------------------
  |  Branch (1663:3): [True: 0, False: 7.21k]
  ------------------
 1664|      0|    return vis(arg.value_.long_double_value);
 1665|      0|  case detail::type::cstring_type:
  ------------------
  |  Branch (1665:3): [True: 0, False: 7.21k]
  ------------------
 1666|      0|    return vis(arg.value_.string.data);
 1667|      0|  case detail::type::string_type:
  ------------------
  |  Branch (1667:3): [True: 0, False: 7.21k]
  ------------------
 1668|      0|    using sv = basic_string_view<typename Context::char_type>;
 1669|      0|    return vis(sv(arg.value_.string.data, arg.value_.string.size));
 1670|      0|  case detail::type::pointer_type:
  ------------------
  |  Branch (1670:3): [True: 0, False: 7.21k]
  ------------------
 1671|      0|    return vis(arg.value_.pointer);
 1672|      0|  case detail::type::custom_type:
  ------------------
  |  Branch (1672:3): [True: 0, False: 7.21k]
  ------------------
 1673|      0|    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
 1674|  7.21k|  }
 1675|      0|  return vis(monostate());
 1676|  7.21k|}
_ZN3fmt2v96detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EE:
  844|  1.29M|    -> Container& {
  845|  1.29M|  using base = std::back_insert_iterator<Container>;
  846|  1.29M|  struct accessor : base {
  847|  1.29M|    accessor(base b) : base(b) {}
  848|  1.29M|    using base::container;
  849|  1.29M|  };
  850|  1.29M|  return *accessor(it).container;
  851|  1.29M|}
_ZZN3fmt2v96detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EEEN8accessorC2ENS8_IS4_EE:
  847|  1.29M|    accessor(base b) : base(b) {}
_ZN3fmt2v96detail13ignore_unusedIJbA20_cEEEvDpRKT_:
  341|  42.5k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt2v98appenderppEi:
 1572|   515k|  auto operator++(int) noexcept -> appender { return *this; }
_ZN3fmt2v96detail8copy_strIcPcEENS0_8appenderET0_S5_S4_:
 1681|  35.3k|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1682|  35.3k|  get_container(out).append(begin, end);
 1683|  35.3k|  return out;
 1684|  35.3k|}
_ZN3fmt2v96detail10make_valueINS0_20basic_format_contextINS0_8appenderEcEERiEENS1_5valueIT_EEOT0_:
 1749|  2.79k|FMT_CONSTEXPR FMT_INLINE auto make_value(T&& val) -> value<Context> {
 1750|  2.79k|  const auto& arg = arg_mapper<Context>().map(FMT_FORWARD(val));
  ------------------
  |  |  202|  2.79k|#define FMT_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
  ------------------
 1751|       |
 1752|  2.79k|  constexpr bool formattable_char =
 1753|  2.79k|      !std::is_same<decltype(arg), const unformattable_char&>::value;
 1754|  2.79k|  static_assert(formattable_char, "Mixing character types is disallowed.");
 1755|       |
 1756|  2.79k|  constexpr bool formattable_const =
 1757|  2.79k|      !std::is_same<decltype(arg), const unformattable_const&>::value;
 1758|  2.79k|  static_assert(formattable_const, "Cannot format a const argument.");
 1759|       |
 1760|       |  // Formatting of arbitrary pointers is disallowed. If you want to output
 1761|       |  // a pointer cast it to "void *" or "const void *". In particular, this
 1762|       |  // forbids formatting of "[const] volatile char *" which is printed as bool
 1763|       |  // by iostreams.
 1764|  2.79k|  constexpr bool formattable_pointer =
 1765|  2.79k|      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
 1766|  2.79k|  static_assert(formattable_pointer,
 1767|  2.79k|                "Formatting of non-void pointers is disallowed.");
 1768|       |
 1769|  2.79k|  constexpr bool formattable =
 1770|  2.79k|      !std::is_same<decltype(arg), const unformattable&>::value;
 1771|  2.79k|  static_assert(
 1772|  2.79k|      formattable,
 1773|  2.79k|      "Cannot format an argument. To make type T formattable provide a "
 1774|  2.79k|      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
 1775|  2.79k|  return {arg};
 1776|  2.79k|}
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEi:
 1376|  5.89k|  FMT_CONSTEXPR FMT_INLINE auto map(int val) -> int { return val; }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ei:
 1284|  5.89k|  constexpr FMT_INLINE value(int val) : int_value(val) {}
_ZNK3fmt2v96detail6fill_tIcE4sizeEv:
 2115|   452k|  constexpr auto size() const -> size_t { return size_; }
_ZNK3fmt2v96detail6fill_tIcE4dataEv:
 2116|  3.60k|  constexpr auto data() const -> const Char* { return data_; }
_ZN3fmt2v96detail8copy_strIcPKcEENS0_8appenderET0_S6_S5_:
 1681|  1.17M|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1682|  1.17M|  get_container(out).append(begin, end);
 1683|  1.17M|  return out;
 1684|  1.17M|}
_ZN3fmt2v918basic_format_specsIcEC2Ev:
 2166|   484k|        localized(false) {}
_ZN3fmt2v96detail11const_checkIbEET_S3_:
  354|   119k|template <typename T> constexpr FMT_INLINE auto const_check(T value) -> T {
  355|   119k|  return value;
  356|   119k|}
_ZN3fmt2v96detail6fill_tIcEixEm:
 2118|  77.5k|  FMT_CONSTEXPR auto operator[](size_t index) -> Char& { return data_[index]; }
_ZN3fmt2v96detail21parse_float_type_specINS1_13error_handlerEcEENS1_11float_specsERKNS0_18basic_format_specsIT0_EEOT_:
 2800|   119k|    -> float_specs {
 2801|   119k|  auto result = float_specs();
 2802|   119k|  result.showpoint = specs.alt;
 2803|   119k|  result.locale = specs.localized;
 2804|   119k|  switch (specs.type) {
 2805|      0|  case presentation_type::none:
  ------------------
  |  Branch (2805:3): [True: 0, False: 119k]
  ------------------
 2806|      0|    result.format = float_format::general;
 2807|      0|    break;
 2808|      0|  case presentation_type::general_upper:
  ------------------
  |  Branch (2808:3): [True: 0, False: 119k]
  ------------------
 2809|      0|    result.upper = true;
 2810|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  165|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2811|      0|  case presentation_type::general_lower:
  ------------------
  |  Branch (2811:3): [True: 0, False: 119k]
  ------------------
 2812|      0|    result.format = float_format::general;
 2813|      0|    break;
 2814|      0|  case presentation_type::exp_upper:
  ------------------
  |  Branch (2814:3): [True: 0, False: 119k]
  ------------------
 2815|      0|    result.upper = true;
 2816|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  165|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2817|      0|  case presentation_type::exp_lower:
  ------------------
  |  Branch (2817:3): [True: 0, False: 119k]
  ------------------
 2818|      0|    result.format = float_format::exp;
 2819|      0|    result.showpoint |= specs.precision != 0;
 2820|      0|    break;
 2821|      0|  case presentation_type::fixed_upper:
  ------------------
  |  Branch (2821:3): [True: 0, False: 119k]
  ------------------
 2822|      0|    result.upper = true;
 2823|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  165|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2824|   119k|  case presentation_type::fixed_lower:
  ------------------
  |  Branch (2824:3): [True: 119k, False: 0]
  ------------------
 2825|   119k|    result.format = float_format::fixed;
 2826|   119k|    result.showpoint |= specs.precision != 0;
 2827|   119k|    break;
 2828|      0|  case presentation_type::hexfloat_upper:
  ------------------
  |  Branch (2828:3): [True: 0, False: 119k]
  ------------------
 2829|      0|    result.upper = true;
 2830|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  165|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2831|      0|  case presentation_type::hexfloat_lower:
  ------------------
  |  Branch (2831:3): [True: 0, False: 119k]
  ------------------
 2832|      0|    result.format = float_format::hex;
 2833|      0|    break;
 2834|      0|  default:
  ------------------
  |  Branch (2834:3): [True: 0, False: 119k]
  ------------------
 2835|      0|    eh.on_error("invalid type specifier");
 2836|      0|    break;
 2837|   119k|  }
 2838|   119k|  return result;
 2839|   119k|}
_ZN3fmt2v96detail6bufferIjEC2EPjmm:
  888|   427k|      : ptr_(p), size_(sz), capacity_(cap) {}
_ZN3fmt2v96detail6bufferIjE3setEPjm:
  894|   427k|  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  895|   427k|    ptr_ = buf_data;
  896|   427k|    capacity_ = buf_capacity;
  897|   427k|  }
_ZNK3fmt2v96detail6bufferIjE8capacityEv:
  919|   201k|  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
_ZN3fmt2v96detail6bufferIjE4dataEv:
  922|   671k|  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
_ZNK3fmt2v96detail6bufferIjE4sizeEv:
  916|  62.8M|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail6bufferIjEixImEERjT_:
  953|  9.38M|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  954|  9.38M|    return ptr_[index];
  955|  9.38M|  }
_ZN3fmt2v96detail6bufferIjE10try_resizeEm:
  932|  6.66M|  FMT_CONSTEXPR20 void try_resize(size_t count) {
  933|  6.66M|    try_reserve(count);
  934|  6.66M|    size_ = count <= capacity_ ? count : capacity_;
  ------------------
  |  Branch (934:13): [True: 6.66M, False: 0]
  ------------------
  935|  6.66M|  }
_ZN3fmt2v96detail6bufferIjE11try_reserveEm:
  941|  7.05M|  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
  942|  7.05M|    if (new_capacity > capacity_) grow(new_capacity);
  ------------------
  |  Branch (942:9): [True: 0, False: 7.05M]
  ------------------
  943|  7.05M|  }
_ZN3fmt2v96detail6bufferIjE9push_backERKj:
  945|   390k|  FMT_CONSTEXPR20 void push_back(const T& value) {
  946|   390k|    try_reserve(size_ + 1);
  947|   390k|    ptr_[size_++] = value;
  948|   390k|  }
_ZN3fmt2v96detail8copy_strIjPjS3_EET1_T0_S5_S4_:
  855|   201k|    -> OutputIt {
  856|   428k|  while (begin != end) *out++ = static_cast<Char>(*begin++);
  ------------------
  |  Branch (856:10): [True: 226k, False: 201k]
  ------------------
  857|   201k|  return out;
  858|   201k|}
_ZN3fmt2v96detail6bufferIjEixIiEERjT_:
  953|   686k|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  954|   686k|    return ptr_[index];
  955|   686k|  }
_ZN3fmt2v96detail6bufferIjEixIjEERjT_:
  953|  41.7M|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  954|  41.7M|    return ptr_[index];
  955|  41.7M|  }
_ZNK3fmt2v96detail6bufferIjE4dataEv:
  925|  2.18k|  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }
_ZNK3fmt2v96detail6bufferIjEixIjEERKjT_:
  957|  20.9M|  FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
  958|  20.9M|    return ptr_[index];
  959|  20.9M|  }
_ZNK3fmt2v96detail6bufferIjEixImEERKjT_:
  957|  17.9M|  FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
  958|  17.9M|    return ptr_[index];
  959|  17.9M|  }
_ZN3fmt2v96detail6bufferIcEixIiEERcT_:
  953|  1.66M|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  954|  1.66M|    return ptr_[index];
  955|  1.66M|  }
_ZN3fmt2v926basic_format_parse_contextIcNS0_6detail13error_handlerEEC2ENS0_17basic_string_viewIcEES3_i:
  677|   253k|      : ErrorHandler(eh), format_str_(format_str), next_arg_id_(next_arg_id) {}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcEC2ES2_NS0_17basic_format_argsIS3_EENS0_6detail10locale_refE:
 1829|   253k|      : out_(out), args_(ctx_args), loc_(loc) {}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE3outEv:
 1846|  1.23M|  FMT_CONSTEXPR auto out() -> iterator { return out_; }
_ZN3fmt2v96detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS5_cEE5valueENS0_8appenderENSC_20back_insert_iteratorIS6_EEE4typeES5_EEEENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_:
 2683|   253k|    basic_string_view<Char> format_str, Handler&& handler) {
 2684|       |  // Workaround a name-lookup bug in MSVC's modules implementation.
 2685|   253k|  using detail::find;
 2686|       |
 2687|   253k|  auto begin = format_str.data();
 2688|   253k|  auto end = begin + format_str.size();
 2689|   253k|  if (end - begin < 32) {
  ------------------
  |  Branch (2689:7): [True: 176k, False: 76.5k]
  ------------------
 2690|       |    // Use a simple loop instead of memchr for small strings.
 2691|   176k|    const Char* p = begin;
 2692|  2.80M|    while (p != end) {
  ------------------
  |  Branch (2692:12): [True: 2.62M, False: 176k]
  ------------------
 2693|  2.62M|      auto c = *p++;
 2694|  2.62M|      if (c == '{') {
  ------------------
  |  Branch (2694:11): [True: 276k, False: 2.35M]
  ------------------
 2695|   276k|        handler.on_text(begin, p - 1);
 2696|   276k|        begin = p = parse_replacement_field(p - 1, end, handler);
 2697|  2.35M|      } else if (c == '}') {
  ------------------
  |  Branch (2697:18): [True: 0, False: 2.35M]
  ------------------
 2698|      0|        if (p == end || *p != '}')
  ------------------
  |  Branch (2698:13): [True: 0, False: 0]
  |  Branch (2698:25): [True: 0, False: 0]
  ------------------
 2699|      0|          return handler.on_error("unmatched '}' in format string");
 2700|      0|        handler.on_text(begin, p);
 2701|      0|        begin = ++p;
 2702|      0|      }
 2703|  2.62M|    }
 2704|   176k|    handler.on_text(begin, end);
 2705|   176k|    return;
 2706|   176k|  }
 2707|  76.5k|  struct writer {
 2708|  76.5k|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2709|  76.5k|      if (from == to) return;
 2710|  76.5k|      for (;;) {
 2711|  76.5k|        const Char* p = nullptr;
 2712|  76.5k|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
 2713|  76.5k|          return handler_.on_text(from, to);
 2714|  76.5k|        ++p;
 2715|  76.5k|        if (p == to || *p != '}')
 2716|  76.5k|          return handler_.on_error("unmatched '}' in format string");
 2717|  76.5k|        handler_.on_text(from, p);
 2718|  76.5k|        from = p + 1;
 2719|  76.5k|      }
 2720|  76.5k|    }
 2721|  76.5k|    Handler& handler_;
 2722|  76.5k|  } write = {handler};
 2723|   291k|  while (begin != end) {
  ------------------
  |  Branch (2723:10): [True: 289k, False: 1.19k]
  ------------------
 2724|       |    // Doing two passes with memchr (one for '{' and another for '}') is up to
 2725|       |    // 2.5x faster than the naive one-pass implementation on big format strings.
 2726|   289k|    const Char* p = begin;
 2727|   289k|    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
  ------------------
  |  Branch (2727:9): [True: 289k, False: 0]
  |  Branch (2727:26): [True: 75.3k, False: 214k]
  ------------------
 2728|  75.3k|      return write(begin, end);
 2729|   214k|    write(begin, p);
 2730|   214k|    begin = parse_replacement_field(p, end, handler);
 2731|   214k|  }
 2732|  76.5k|}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE10advance_toES2_:
 1849|  1.23M|  void advance_to(iterator it) {
 1850|  1.23M|    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
  ------------------
  |  Branch (1850:9): [Folded - Ignored]
  ------------------
 1851|  1.23M|  }
_ZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS5_cEE5valueENS0_8appenderENSC_20back_insert_iteratorIS6_EEE4typeES5_EEEENS1_10locale_refEE14format_handlerEEPKS5_SP_SP_OT0_:
 2643|   491k|                                           Handler&& handler) -> const Char* {
 2644|   491k|  struct id_adapter {
 2645|   491k|    Handler& handler;
 2646|   491k|    int arg_id;
 2647|       |
 2648|   491k|    FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
 2649|   491k|    FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
 2650|   491k|    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
 2651|   491k|      arg_id = handler.on_arg_id(id);
 2652|   491k|    }
 2653|   491k|    FMT_CONSTEXPR void on_error(const char* message) {
 2654|   491k|      if (message) handler.on_error(message);
 2655|   491k|    }
 2656|   491k|  };
 2657|       |
 2658|   491k|  ++begin;
 2659|   491k|  if (begin == end) return handler.on_error("invalid format string"), end;
  ------------------
  |  Branch (2659:7): [True: 0, False: 491k]
  ------------------
 2660|   491k|  if (*begin == '}') {
  ------------------
  |  Branch (2660:7): [True: 7.21k, False: 484k]
  ------------------
 2661|  7.21k|    handler.on_replacement_field(handler.on_arg_id(), begin);
 2662|   484k|  } else if (*begin == '{') {
  ------------------
  |  Branch (2662:14): [True: 0, False: 484k]
  ------------------
 2663|      0|    handler.on_text(begin, begin + 1);
 2664|   484k|  } else {
 2665|   484k|    auto adapter = id_adapter{handler, 0};
 2666|   484k|    begin = parse_arg_id(begin, end, adapter);
 2667|   484k|    Char c = begin != end ? *begin : Char();
  ------------------
  |  Branch (2667:14): [True: 484k, False: 0]
  ------------------
 2668|   484k|    if (c == '}') {
  ------------------
  |  Branch (2668:9): [True: 0, False: 484k]
  ------------------
 2669|      0|      handler.on_replacement_field(adapter.arg_id, begin);
 2670|   484k|    } else if (c == ':') {
  ------------------
  |  Branch (2670:16): [True: 484k, False: 0]
  ------------------
 2671|   484k|      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
 2672|   484k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (2672:11): [True: 0, False: 484k]
  |  Branch (2672:27): [True: 0, False: 484k]
  ------------------
 2673|      0|        return handler.on_error("unknown format specifier"), end;
 2674|   484k|    } else {
 2675|      0|      return handler.on_error("missing '}' in format string"), end;
 2676|      0|    }
 2677|   484k|  }
 2678|   491k|  return begin + 1;
 2679|   491k|}
_ZNK3fmt2v920basic_format_contextINS0_8appenderEcE3argEi:
 1831|   491k|  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
_ZNK3fmt2v920basic_format_contextINS0_8appenderEcE4argsEv:
 1838|  7.21k|  auto args() const -> const basic_format_args<basic_format_context>& {
 1839|  7.21k|    return args_;
 1840|  7.21k|  }
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE6localeEv:
 1853|   491k|  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
_ZN3fmt2v926basic_format_parse_contextIcNS0_6detail13error_handlerEE11next_arg_idEv:
  701|   424k|  FMT_CONSTEXPR auto next_arg_id() -> int {
  702|   424k|    if (next_arg_id_ < 0) {
  ------------------
  |  Branch (702:9): [True: 0, False: 424k]
  ------------------
  703|      0|      on_error("cannot switch from manual to automatic argument indexing");
  704|      0|      return 0;
  705|      0|    }
  706|   424k|    int id = next_arg_id_++;
  707|   424k|    do_check_arg_id(id);
  708|   424k|    return id;
  709|   424k|  }
_ZN3fmt2v926basic_format_parse_contextIcNS0_6detail13error_handlerEE15do_check_arg_idEi:
  778|   491k|basic_format_parse_context<Char, ErrorHandler>::do_check_arg_id(int id) {
  779|       |  // Argument id is only checked at compile-time during parsing because
  780|       |  // formatting has its own validation.
  781|   491k|  if (detail::is_constant_evaluated() &&
  ------------------
  |  Branch (781:7): [Folded - Ignored]
  ------------------
  782|   491k|      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   32|      0|#  define FMT_GCC_VERSION 0
  ------------------
                    (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   32|      0|#  define FMT_GCC_VERSION 0
  ------------------
  |  Branch (782:8): [Folded - Ignored]
  |  Branch (782:28): [Folded - Ignored]
  ------------------
  783|      0|    using context = detail::compile_parse_context<Char, ErrorHandler>;
  784|      0|    if (id >= static_cast<context*>(this)->num_args())
  ------------------
  |  Branch (784:9): [True: 0, False: 0]
  ------------------
  785|      0|      on_error("argument not found");
  786|      0|  }
  787|   491k|}
_ZN3fmt2v96detail12parse_arg_idIcRZNS1_23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS6_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS6_cEE5valueENS0_8appenderENSD_20back_insert_iteratorIS7_EEE4typeES6_EEEENS1_10locale_refEE14format_handlerEEPKS6_SQ_SQ_OT0_E10id_adapterEESQ_SQ_SQ_SS_:
 2443|   484k|                                           IDHandler&& handler) -> const Char* {
 2444|   484k|  Char c = *begin;
 2445|   484k|  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
  ------------------
  |  Branch (2445:7): [True: 484k, False: 0]
  |  Branch (2445:19): [True: 67.0k, False: 416k]
  ------------------
 2446|   416k|  handler();
 2447|   416k|  return begin;
 2448|   484k|}
_ZN3fmt2v96detail15do_parse_arg_idIcRZNS1_23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS6_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS6_cEE5valueENS0_8appenderENSD_20back_insert_iteratorIS7_EEE4typeES6_EEEENS1_10locale_refEE14format_handlerEEPKS6_SQ_SQ_OT0_E10id_adapterEESQ_SQ_SQ_SS_:
 2413|  67.0k|                                   IDHandler&& handler) -> const Char* {
 2414|  67.0k|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  365|  67.0k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2415|  67.0k|  Char c = *begin;
 2416|  67.0k|  if (c >= '0' && c <= '9') {
  ------------------
  |  Branch (2416:7): [True: 67.0k, False: 0]
  |  Branch (2416:19): [True: 67.0k, False: 0]
  ------------------
 2417|  67.0k|    int index = 0;
 2418|  67.0k|    if (c != '0')
  ------------------
  |  Branch (2418:9): [True: 33.5k, False: 33.5k]
  ------------------
 2419|  33.5k|      index =
 2420|  33.5k|          parse_nonnegative_int(begin, end, (std::numeric_limits<int>::max)());
 2421|  33.5k|    else
 2422|  33.5k|      ++begin;
 2423|  67.0k|    if (begin == end || (*begin != '}' && *begin != ':'))
  ------------------
  |  Branch (2423:9): [True: 0, False: 67.0k]
  |  Branch (2423:26): [True: 67.0k, False: 0]
  |  Branch (2423:43): [True: 0, False: 67.0k]
  ------------------
 2424|      0|      handler.on_error("invalid format string");
 2425|  67.0k|    else
 2426|  67.0k|      handler(index);
 2427|  67.0k|    return begin;
 2428|  67.0k|  }
 2429|      0|  if (!is_name_start(c)) {
  ------------------
  |  Branch (2429:7): [True: 0, False: 0]
  ------------------
 2430|      0|    handler.on_error("invalid format string");
 2431|      0|    return begin;
 2432|      0|  }
 2433|      0|  auto it = begin;
 2434|      0|  do {
 2435|      0|    ++it;
 2436|      0|  } while (it != end && (is_name_start(c = *it) || ('0' <= c && c <= '9')));
  ------------------
  |  Branch (2436:12): [True: 0, False: 0]
  |  Branch (2436:26): [True: 0, False: 0]
  |  Branch (2436:53): [True: 0, False: 0]
  |  Branch (2436:65): [True: 0, False: 0]
  ------------------
 2437|      0|  handler(basic_string_view<Char>(begin, to_unsigned(it - begin)));
 2438|      0|  return it;
 2439|      0|}
_ZN3fmt2v96detail21parse_nonnegative_intIcEEiRPKT_S5_i:
 2344|   111k|                                         int error_value) noexcept -> int {
 2345|   111k|  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
  ------------------
  |  |  365|   444k|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (365:37): [True: 111k, False: 0]
  |  |  |  Branch (365:37): [True: 111k, False: 0]
  |  |  |  Branch (365:37): [True: 111k, False: 0]
  |  |  ------------------
  ------------------
 2346|   111k|  unsigned value = 0, prev = 0;
 2347|   111k|  auto p = begin;
 2348|   111k|  do {
 2349|   111k|    prev = value;
 2350|   111k|    value = value * 10 + unsigned(*p - '0');
 2351|   111k|    ++p;
 2352|   111k|  } while (p != end && '0' <= *p && *p <= '9');
  ------------------
  |  Branch (2352:12): [True: 111k, False: 0]
  |  Branch (2352:24): [True: 111k, False: 0]
  |  Branch (2352:37): [True: 0, False: 111k]
  ------------------
 2353|   111k|  auto num_digits = p - begin;
 2354|   111k|  begin = p;
 2355|   111k|  if (num_digits <= std::numeric_limits<int>::digits10)
  ------------------
  |  Branch (2355:7): [True: 111k, False: 0]
  ------------------
 2356|   111k|    return static_cast<int>(value);
 2357|       |  // Check for overflow.
 2358|      0|  const unsigned max = to_unsigned((std::numeric_limits<int>::max)());
 2359|      0|  return num_digits == std::numeric_limits<int>::digits10 + 1 &&
  ------------------
  |  Branch (2359:10): [True: 0, False: 0]
  ------------------
 2360|      0|                 prev * 10ull + unsigned(p[-1] - '0') <= max
  ------------------
  |  Branch (2360:18): [True: 0, False: 0]
  ------------------
 2361|      0|             ? static_cast<int>(value)
 2362|      0|             : error_value;
 2363|   111k|}
_ZZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS5_cEE5valueENS0_8appenderENSC_20back_insert_iteratorIS6_EEE4typeES5_EEEENS1_10locale_refEE14format_handlerEEPKS5_SP_SP_OT0_EN10id_adapterclEi:
 2649|  67.0k|    FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
_ZN3fmt2v926basic_format_parse_contextIcNS0_6detail13error_handlerEE12check_arg_idEi:
  715|  67.0k|  FMT_CONSTEXPR void check_arg_id(int id) {
  716|  67.0k|    if (next_arg_id_ > 0) {
  ------------------
  |  Branch (716:9): [True: 0, False: 67.0k]
  ------------------
  717|      0|      on_error("cannot switch from automatic to manual argument indexing");
  718|      0|      return;
  719|      0|    }
  720|  67.0k|    next_arg_id_ = -1;
  721|  67.0k|    do_check_arg_id(id);
  722|  67.0k|  }
_ZZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS5_cEE5valueENS0_8appenderENSC_20back_insert_iteratorIS6_EEE4typeES5_EEEENS1_10locale_refEE14format_handlerEEPKS5_SP_SP_OT0_EN10id_adapterclEv:
 2648|   416k|    FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
_ZNK3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEE4typeEv:
 1622|   968k|  auto type() const -> detail::type { return type_; }
_ZN3fmt2v96detail12specs_setterIcEC2ERNS0_18basic_format_specsIcEE:
 2218|   484k|      : specs_(specs) {}
_ZN3fmt2v96detail13specs_checkerINS1_13specs_handlerIcEEEC2ERKS4_NS1_4typeE:
 2879|   484k|      : Handler(handler), arg_type_(arg_type) {}
_ZN3fmt2v96detail18parse_format_specsIcRNS1_13specs_checkerINS1_13specs_handlerIcEEEEEEPKT_SA_SA_OT0_:
 2572|   484k|    -> const Char* {
 2573|   484k|  if (1 < end - begin && begin[1] == '}' && is_ascii_letter(*begin) &&
  ------------------
  |  Branch (2573:7): [True: 484k, False: 0]
  |  Branch (2573:26): [True: 406k, False: 77.5k]
  |  Branch (2573:45): [True: 406k, False: 0]
  ------------------
 2574|   484k|      *begin != 'L') {
  ------------------
  |  Branch (2574:7): [True: 406k, False: 0]
  ------------------
 2575|   406k|    presentation_type type = parse_presentation_type(*begin++);
 2576|   406k|    if (type == presentation_type::none)
  ------------------
  |  Branch (2576:9): [True: 0, False: 406k]
  ------------------
 2577|      0|      handler.on_error("invalid type specifier");
 2578|   406k|    handler.on_type(type);
 2579|   406k|    return begin;
 2580|   406k|  }
 2581|       |
 2582|  77.5k|  if (begin == end) return begin;
  ------------------
  |  Branch (2582:7): [True: 0, False: 77.5k]
  ------------------
 2583|       |
 2584|  77.5k|  begin = parse_align(begin, end, handler);
 2585|  77.5k|  if (begin == end) return begin;
  ------------------
  |  Branch (2585:7): [True: 0, False: 77.5k]
  ------------------
 2586|       |
 2587|       |  // Parse sign.
 2588|  77.5k|  switch (to_ascii(*begin)) {
 2589|      0|  case '+':
  ------------------
  |  Branch (2589:3): [True: 0, False: 77.5k]
  ------------------
 2590|      0|    handler.on_sign(sign::plus);
 2591|      0|    ++begin;
 2592|      0|    break;
 2593|      0|  case '-':
  ------------------
  |  Branch (2593:3): [True: 0, False: 77.5k]
  ------------------
 2594|      0|    handler.on_sign(sign::minus);
 2595|      0|    ++begin;
 2596|      0|    break;
 2597|      0|  case ' ':
  ------------------
  |  Branch (2597:3): [True: 0, False: 77.5k]
  ------------------
 2598|      0|    handler.on_sign(sign::space);
 2599|      0|    ++begin;
 2600|      0|    break;
 2601|  77.5k|  default:
  ------------------
  |  Branch (2601:3): [True: 77.5k, False: 0]
  ------------------
 2602|  77.5k|    break;
 2603|  77.5k|  }
 2604|  77.5k|  if (begin == end) return begin;
  ------------------
  |  Branch (2604:7): [True: 0, False: 77.5k]
  ------------------
 2605|       |
 2606|  77.5k|  if (*begin == '#') {
  ------------------
  |  Branch (2606:7): [True: 0, False: 77.5k]
  ------------------
 2607|      0|    handler.on_hash();
 2608|      0|    if (++begin == end) return begin;
  ------------------
  |  Branch (2608:9): [True: 0, False: 0]
  ------------------
 2609|      0|  }
 2610|       |
 2611|       |  // Parse zero flag.
 2612|  77.5k|  if (*begin == '0') {
  ------------------
  |  Branch (2612:7): [True: 77.5k, False: 0]
  ------------------
 2613|  77.5k|    handler.on_zero();
 2614|  77.5k|    if (++begin == end) return begin;
  ------------------
  |  Branch (2614:9): [True: 0, False: 77.5k]
  ------------------
 2615|  77.5k|  }
 2616|       |
 2617|  77.5k|  begin = parse_width(begin, end, handler);
 2618|  77.5k|  if (begin == end) return begin;
  ------------------
  |  Branch (2618:7): [True: 0, False: 77.5k]
  ------------------
 2619|       |
 2620|       |  // Parse precision.
 2621|  77.5k|  if (*begin == '.') {
  ------------------
  |  Branch (2621:7): [True: 0, False: 77.5k]
  ------------------
 2622|      0|    begin = parse_precision(begin, end, handler);
 2623|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2623:9): [True: 0, False: 0]
  ------------------
 2624|      0|  }
 2625|       |
 2626|  77.5k|  if (*begin == 'L') {
  ------------------
  |  Branch (2626:7): [True: 0, False: 77.5k]
  ------------------
 2627|      0|    handler.on_localized();
 2628|      0|    ++begin;
 2629|      0|  }
 2630|       |
 2631|       |  // Parse type.
 2632|  77.5k|  if (begin != end && *begin != '}') {
  ------------------
  |  Branch (2632:7): [True: 77.5k, False: 0]
  |  Branch (2632:23): [True: 77.5k, False: 0]
  ------------------
 2633|  77.5k|    presentation_type type = parse_presentation_type(*begin++);
 2634|  77.5k|    if (type == presentation_type::none)
  ------------------
  |  Branch (2634:9): [True: 0, False: 77.5k]
  ------------------
 2635|      0|      handler.on_error("invalid type specifier");
 2636|  77.5k|    handler.on_type(type);
 2637|  77.5k|  }
 2638|  77.5k|  return begin;
 2639|  77.5k|}
_ZN3fmt2v96detail15is_ascii_letterIcEEbT_:
 2293|   406k|template <typename Char> constexpr bool is_ascii_letter(Char c) {
 2294|   406k|  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
  ------------------
  |  Branch (2294:11): [True: 406k, False: 0]
  |  Branch (2294:23): [True: 406k, False: 0]
  |  Branch (2294:37): [True: 0, False: 0]
  |  Branch (2294:49): [True: 0, False: 0]
  ------------------
 2295|   406k|}
_ZN3fmt2v96detail23parse_presentation_typeIcEENS0_17presentation_typeET_:
 2523|   484k|FMT_CONSTEXPR auto parse_presentation_type(Char type) -> presentation_type {
 2524|   484k|  switch (to_ascii(type)) {
 2525|  35.3k|  case 'd':
  ------------------
  |  Branch (2525:3): [True: 35.3k, False: 448k]
  ------------------
 2526|  35.3k|    return presentation_type::dec;
 2527|      0|  case 'o':
  ------------------
  |  Branch (2527:3): [True: 0, False: 484k]
  ------------------
 2528|      0|    return presentation_type::oct;
 2529|      0|  case 'x':
  ------------------
  |  Branch (2529:3): [True: 0, False: 484k]
  ------------------
 2530|      0|    return presentation_type::hex_lower;
 2531|  77.5k|  case 'X':
  ------------------
  |  Branch (2531:3): [True: 77.5k, False: 406k]
  ------------------
 2532|  77.5k|    return presentation_type::hex_upper;
 2533|      0|  case 'b':
  ------------------
  |  Branch (2533:3): [True: 0, False: 484k]
  ------------------
 2534|      0|    return presentation_type::bin_lower;
 2535|      0|  case 'B':
  ------------------
  |  Branch (2535:3): [True: 0, False: 484k]
  ------------------
 2536|      0|    return presentation_type::bin_upper;
 2537|      0|  case 'a':
  ------------------
  |  Branch (2537:3): [True: 0, False: 484k]
  ------------------
 2538|      0|    return presentation_type::hexfloat_lower;
 2539|      0|  case 'A':
  ------------------
  |  Branch (2539:3): [True: 0, False: 484k]
  ------------------
 2540|      0|    return presentation_type::hexfloat_upper;
 2541|      0|  case 'e':
  ------------------
  |  Branch (2541:3): [True: 0, False: 484k]
  ------------------
 2542|      0|    return presentation_type::exp_lower;
 2543|      0|  case 'E':
  ------------------
  |  Branch (2543:3): [True: 0, False: 484k]
  ------------------
 2544|      0|    return presentation_type::exp_upper;
 2545|   119k|  case 'f':
  ------------------
  |  Branch (2545:3): [True: 119k, False: 364k]
  ------------------
 2546|   119k|    return presentation_type::fixed_lower;
 2547|      0|  case 'F':
  ------------------
  |  Branch (2547:3): [True: 0, False: 484k]
  ------------------
 2548|      0|    return presentation_type::fixed_upper;
 2549|      0|  case 'g':
  ------------------
  |  Branch (2549:3): [True: 0, False: 484k]
  ------------------
 2550|      0|    return presentation_type::general_lower;
 2551|      0|  case 'G':
  ------------------
  |  Branch (2551:3): [True: 0, False: 484k]
  ------------------
 2552|      0|    return presentation_type::general_upper;
 2553|      0|  case 'c':
  ------------------
  |  Branch (2553:3): [True: 0, False: 484k]
  ------------------
 2554|      0|    return presentation_type::chr;
 2555|   251k|  case 's':
  ------------------
  |  Branch (2555:3): [True: 251k, False: 232k]
  ------------------
 2556|   251k|    return presentation_type::string;
 2557|      0|  case 'p':
  ------------------
  |  Branch (2557:3): [True: 0, False: 484k]
  ------------------
 2558|      0|    return presentation_type::pointer;
 2559|      0|  case '?':
  ------------------
  |  Branch (2559:3): [True: 0, False: 484k]
  ------------------
 2560|      0|    return presentation_type::debug;
 2561|      0|  default:
  ------------------
  |  Branch (2561:3): [True: 0, False: 484k]
  ------------------
 2562|      0|    return presentation_type::none;
 2563|   484k|  }
 2564|   484k|}
_ZN3fmt2v96detail12specs_setterIcE7on_typeENS0_17presentation_typeE:
 2239|   484k|  FMT_CONSTEXPR void on_type(presentation_type type) { specs_.type = type; }
_ZN3fmt2v96detail11parse_alignIcRNS1_13specs_checkerINS1_13specs_handlerIcEEEEEEPKT_SA_SA_OT0_:
 2368|  77.5k|                               Handler&& handler) -> const Char* {
 2369|  77.5k|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  365|  77.5k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2370|  77.5k|  auto align = align::none;
 2371|  77.5k|  auto p = begin + code_point_length(begin);
 2372|  77.5k|  if (end - p <= 0) p = begin;
  ------------------
  |  Branch (2372:7): [True: 0, False: 77.5k]
  ------------------
 2373|   155k|  for (;;) {
 2374|   155k|    switch (to_ascii(*p)) {
 2375|      0|    case '<':
  ------------------
  |  Branch (2375:5): [True: 0, False: 155k]
  ------------------
 2376|      0|      align = align::left;
 2377|      0|      break;
 2378|      0|    case '>':
  ------------------
  |  Branch (2378:5): [True: 0, False: 155k]
  ------------------
 2379|      0|      align = align::right;
 2380|      0|      break;
 2381|      0|    case '^':
  ------------------
  |  Branch (2381:5): [True: 0, False: 155k]
  ------------------
 2382|      0|      align = align::center;
 2383|      0|      break;
 2384|   155k|    default:
  ------------------
  |  Branch (2384:5): [True: 155k, False: 0]
  ------------------
 2385|   155k|      break;
 2386|   155k|    }
 2387|   155k|    if (align != align::none) {
  ------------------
  |  Branch (2387:9): [True: 0, False: 155k]
  ------------------
 2388|      0|      if (p != begin) {
  ------------------
  |  Branch (2388:11): [True: 0, False: 0]
  ------------------
 2389|      0|        auto c = *begin;
 2390|      0|        if (c == '{')
  ------------------
  |  Branch (2390:13): [True: 0, False: 0]
  ------------------
 2391|      0|          return handler.on_error("invalid fill character '{'"), begin;
 2392|      0|        if (c == '}') return begin;
  ------------------
  |  Branch (2392:13): [True: 0, False: 0]
  ------------------
 2393|      0|        handler.on_fill(basic_string_view<Char>(begin, to_unsigned(p - begin)));
 2394|      0|        begin = p + 1;
 2395|      0|      } else
 2396|      0|        ++begin;
 2397|      0|      handler.on_align(align);
 2398|      0|      break;
 2399|   155k|    } else if (p == begin) {
  ------------------
  |  Branch (2399:16): [True: 77.5k, False: 77.5k]
  ------------------
 2400|  77.5k|      break;
 2401|  77.5k|    }
 2402|  77.5k|    p = begin;
 2403|  77.5k|  }
 2404|  77.5k|  return begin;
 2405|  77.5k|}
_ZN3fmt2v96detail17code_point_lengthIcEEiPKT_:
 2313|  77.5k|FMT_CONSTEXPR auto code_point_length(const Char* begin) -> int {
 2314|  77.5k|  if (const_check(sizeof(Char) != 1)) return 1;
  ------------------
  |  Branch (2314:7): [Folded - Ignored]
  ------------------
 2315|  77.5k|  int len = code_point_length_impl(static_cast<char>(*begin));
 2316|       |
 2317|       |  // Compute the pointer to the next character early so that the next
 2318|       |  // iteration can start working on the next character. Neither Clang
 2319|       |  // nor GCC figure out this reordering on their own.
 2320|  77.5k|  return len + !len;
 2321|  77.5k|}
_ZN3fmt2v96detail13specs_checkerINS1_13specs_handlerIcEEE24require_numeric_argumentEv:
 2872|  77.5k|  FMT_CONSTEXPR void require_numeric_argument() {
 2873|  77.5k|    if (!is_arithmetic_type(arg_type_))
  ------------------
  |  Branch (2873:9): [True: 0, False: 77.5k]
  ------------------
 2874|      0|      this->on_error("format specifier requires numeric argument");
 2875|  77.5k|  }
_ZN3fmt2v96detail18is_arithmetic_typeENS1_4typeE:
  636|  77.5k|constexpr bool is_arithmetic_type(type t) {
  637|  77.5k|  return t > type::none_type && t <= type::last_numeric_type;
  ------------------
  |  Branch (637:10): [True: 77.5k, False: 0]
  |  Branch (637:33): [True: 77.5k, False: 0]
  ------------------
  638|  77.5k|}
_ZN3fmt2v96detail8to_asciiIcLi0EEET_S3_:
 2299|   716k|constexpr auto to_ascii(Char c) -> Char {
 2300|   716k|  return c;
 2301|   716k|}
_ZN3fmt2v96detail13specs_checkerINS1_13specs_handlerIcEEE7on_zeroEv:
 2906|  77.5k|  FMT_CONSTEXPR void on_zero() {
 2907|  77.5k|    require_numeric_argument();
 2908|  77.5k|    Handler::on_zero();
 2909|  77.5k|  }
_ZN3fmt2v96detail12specs_setterIcE7on_zeroEv:
 2228|  77.5k|  FMT_CONSTEXPR void on_zero() {
 2229|  77.5k|    if (specs_.align == align::none) specs_.align = align::numeric;
  ------------------
  |  Branch (2229:9): [True: 77.5k, False: 0]
  ------------------
 2230|  77.5k|    specs_.fill[0] = Char('0');
 2231|  77.5k|  }
_ZN3fmt2v96detail11parse_widthIcRNS1_13specs_checkerINS1_13specs_handlerIcEEEEEEPKT_SA_SA_OT0_:
 2452|  77.5k|                               Handler&& handler) -> const Char* {
 2453|  77.5k|  using detail::auto_id;
 2454|  77.5k|  struct width_adapter {
 2455|  77.5k|    Handler& handler;
 2456|       |
 2457|  77.5k|    FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
 2458|  77.5k|    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
 2459|  77.5k|    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
 2460|  77.5k|      handler.on_dynamic_width(id);
 2461|  77.5k|    }
 2462|  77.5k|    FMT_CONSTEXPR void on_error(const char* message) {
 2463|  77.5k|      if (message) handler.on_error(message);
 2464|  77.5k|    }
 2465|  77.5k|  };
 2466|       |
 2467|  77.5k|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  365|  77.5k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2468|  77.5k|  if ('0' <= *begin && *begin <= '9') {
  ------------------
  |  Branch (2468:7): [True: 77.5k, False: 0]
  |  Branch (2468:24): [True: 77.5k, False: 0]
  ------------------
 2469|  77.5k|    int width = parse_nonnegative_int(begin, end, -1);
 2470|  77.5k|    if (width != -1)
  ------------------
  |  Branch (2470:9): [True: 77.5k, False: 0]
  ------------------
 2471|  77.5k|      handler.on_width(width);
 2472|      0|    else
 2473|      0|      handler.on_error("number is too big");
 2474|  77.5k|  } else if (*begin == '{') {
  ------------------
  |  Branch (2474:14): [True: 0, False: 0]
  ------------------
 2475|      0|    ++begin;
 2476|      0|    if (begin != end) begin = parse_arg_id(begin, end, width_adapter{handler});
  ------------------
  |  Branch (2476:9): [True: 0, False: 0]
  ------------------
 2477|      0|    if (begin == end || *begin != '}')
  ------------------
  |  Branch (2477:9): [True: 0, False: 0]
  |  Branch (2477:25): [True: 0, False: 0]
  ------------------
 2478|      0|      return handler.on_error("invalid format string"), begin;
 2479|      0|    ++begin;
 2480|      0|  }
 2481|  77.5k|  return begin;
 2482|  77.5k|}
_ZN3fmt2v96detail12specs_setterIcE8on_widthEi:
 2233|  77.5k|  FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
_ZN3fmt2v916visit_format_argIRNS0_6detail13arg_formatterIcEENS0_20basic_format_contextINS0_8appenderEcEEEEDTclfp_Li0EEEOT_RKNS0_16basic_format_argIT0_EE:
 1639|   484k|    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
 1640|   484k|  switch (arg.type_) {
  ------------------
  |  Branch (1640:11): [True: 0, False: 484k]
  ------------------
 1641|      0|  case detail::type::none_type:
  ------------------
  |  Branch (1641:3): [True: 0, False: 484k]
  ------------------
 1642|      0|    break;
 1643|      0|  case detail::type::int_type:
  ------------------
  |  Branch (1643:3): [True: 0, False: 484k]
  ------------------
 1644|      0|    return vis(arg.value_.int_value);
 1645|   111k|  case detail::type::uint_type:
  ------------------
  |  Branch (1645:3): [True: 111k, False: 372k]
  ------------------
 1646|   111k|    return vis(arg.value_.uint_value);
 1647|      0|  case detail::type::long_long_type:
  ------------------
  |  Branch (1647:3): [True: 0, False: 484k]
  ------------------
 1648|      0|    return vis(arg.value_.long_long_value);
 1649|  1.59k|  case detail::type::ulong_long_type:
  ------------------
  |  Branch (1649:3): [True: 1.59k, False: 482k]
  ------------------
 1650|  1.59k|    return vis(arg.value_.ulong_long_value);
 1651|      0|  case detail::type::int128_type:
  ------------------
  |  Branch (1651:3): [True: 0, False: 484k]
  ------------------
 1652|      0|    return vis(detail::convert_for_visit(arg.value_.int128_value));
 1653|      0|  case detail::type::uint128_type:
  ------------------
  |  Branch (1653:3): [True: 0, False: 484k]
  ------------------
 1654|      0|    return vis(detail::convert_for_visit(arg.value_.uint128_value));
 1655|      0|  case detail::type::bool_type:
  ------------------
  |  Branch (1655:3): [True: 0, False: 484k]
  ------------------
 1656|      0|    return vis(arg.value_.bool_value);
 1657|      0|  case detail::type::char_type:
  ------------------
  |  Branch (1657:3): [True: 0, False: 484k]
  ------------------
 1658|      0|    return vis(arg.value_.char_value);
 1659|   119k|  case detail::type::float_type:
  ------------------
  |  Branch (1659:3): [True: 119k, False: 364k]
  ------------------
 1660|   119k|    return vis(arg.value_.float_value);
 1661|      0|  case detail::type::double_type:
  ------------------
  |  Branch (1661:3): [True: 0, False: 484k]
  ------------------
 1662|      0|    return vis(arg.value_.double_value);
 1663|      0|  case detail::type::long_double_type:
  ------------------
  |  Branch (1663:3): [True: 0, False: 484k]
  ------------------
 1664|      0|    return vis(arg.value_.long_double_value);
 1665|   118k|  case detail::type::cstring_type:
  ------------------
  |  Branch (1665:3): [True: 118k, False: 366k]
  ------------------
 1666|   118k|    return vis(arg.value_.string.data);
 1667|   133k|  case detail::type::string_type:
  ------------------
  |  Branch (1667:3): [True: 133k, False: 350k]
  ------------------
 1668|   133k|    using sv = basic_string_view<typename Context::char_type>;
 1669|   133k|    return vis(sv(arg.value_.string.data, arg.value_.string.size));
 1670|      0|  case detail::type::pointer_type:
  ------------------
  |  Branch (1670:3): [True: 0, False: 484k]
  ------------------
 1671|      0|    return vis(arg.value_.pointer);
 1672|      0|  case detail::type::custom_type:
  ------------------
  |  Branch (1672:3): [True: 0, False: 484k]
  ------------------
 1673|      0|    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
 1674|   484k|  }
 1675|      0|  return vis(monostate());
 1676|   484k|}
_ZN3fmt2v96detail10make_valueINS0_20basic_format_contextINS0_8appenderEcEERjEENS1_5valueIT_EEOT0_:
 1749|  76.9k|FMT_CONSTEXPR FMT_INLINE auto make_value(T&& val) -> value<Context> {
 1750|  76.9k|  const auto& arg = arg_mapper<Context>().map(FMT_FORWARD(val));
  ------------------
  |  |  202|  76.9k|#define FMT_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
  ------------------
 1751|       |
 1752|  76.9k|  constexpr bool formattable_char =
 1753|  76.9k|      !std::is_same<decltype(arg), const unformattable_char&>::value;
 1754|  76.9k|  static_assert(formattable_char, "Mixing character types is disallowed.");
 1755|       |
 1756|  76.9k|  constexpr bool formattable_const =
 1757|  76.9k|      !std::is_same<decltype(arg), const unformattable_const&>::value;
 1758|  76.9k|  static_assert(formattable_const, "Cannot format a const argument.");
 1759|       |
 1760|       |  // Formatting of arbitrary pointers is disallowed. If you want to output
 1761|       |  // a pointer cast it to "void *" or "const void *". In particular, this
 1762|       |  // forbids formatting of "[const] volatile char *" which is printed as bool
 1763|       |  // by iostreams.
 1764|  76.9k|  constexpr bool formattable_pointer =
 1765|  76.9k|      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
 1766|  76.9k|  static_assert(formattable_pointer,
 1767|  76.9k|                "Formatting of non-void pointers is disallowed.");
 1768|       |
 1769|  76.9k|  constexpr bool formattable =
 1770|  76.9k|      !std::is_same<decltype(arg), const unformattable&>::value;
 1771|  76.9k|  static_assert(
 1772|  76.9k|      formattable,
 1773|  76.9k|      "Cannot format an argument. To make type T formattable provide a "
 1774|  76.9k|      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
 1775|  76.9k|  return {arg};
 1776|  76.9k|}
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEj:
 1377|   109k|  FMT_CONSTEXPR FMT_INLINE auto map(unsigned val) -> unsigned { return val; }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ej:
 1285|   112k|  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ey:
 1287|  1.59k|  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
_ZN3fmt2v96detail10make_valueINS0_20basic_format_contextINS0_8appenderEcEERfEENS1_5valueIT_EEOT0_:
 1749|   119k|FMT_CONSTEXPR FMT_INLINE auto make_value(T&& val) -> value<Context> {
 1750|   119k|  const auto& arg = arg_mapper<Context>().map(FMT_FORWARD(val));
  ------------------
  |  |  202|   119k|#define FMT_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
  ------------------
 1751|       |
 1752|   119k|  constexpr bool formattable_char =
 1753|   119k|      !std::is_same<decltype(arg), const unformattable_char&>::value;
 1754|   119k|  static_assert(formattable_char, "Mixing character types is disallowed.");
 1755|       |
 1756|   119k|  constexpr bool formattable_const =
 1757|   119k|      !std::is_same<decltype(arg), const unformattable_const&>::value;
 1758|   119k|  static_assert(formattable_const, "Cannot format a const argument.");
 1759|       |
 1760|       |  // Formatting of arbitrary pointers is disallowed. If you want to output
 1761|       |  // a pointer cast it to "void *" or "const void *". In particular, this
 1762|       |  // forbids formatting of "[const] volatile char *" which is printed as bool
 1763|       |  // by iostreams.
 1764|   119k|  constexpr bool formattable_pointer =
 1765|   119k|      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
 1766|   119k|  static_assert(formattable_pointer,
 1767|   119k|                "Formatting of non-void pointers is disallowed.");
 1768|       |
 1769|   119k|  constexpr bool formattable =
 1770|   119k|      !std::is_same<decltype(arg), const unformattable&>::value;
 1771|   119k|  static_assert(
 1772|   119k|      formattable,
 1773|   119k|      "Cannot format an argument. To make type T formattable provide a "
 1774|   119k|      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
 1775|   119k|  return {arg};
 1776|   119k|}
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEf:
 1412|   119k|  FMT_CONSTEXPR FMT_INLINE auto map(float val) -> float { return val; }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ef:
 1290|   119k|  constexpr FMT_INLINE value(float val) : float_value(val) {}
_ZN3fmt2v96detail23check_cstring_type_specINS1_13error_handlerEEEbNS0_17presentation_typeEOT_:
 2843|   118k|                                           ErrorHandler&& eh = {}) -> bool {
 2844|   118k|  if (type == presentation_type::none || type == presentation_type::string ||
  ------------------
  |  Branch (2844:7): [True: 0, False: 118k]
  |  Branch (2844:42): [True: 118k, False: 0]
  ------------------
 2845|   118k|      type == presentation_type::debug)
  ------------------
  |  Branch (2845:7): [True: 0, False: 0]
  ------------------
 2846|   118k|    return true;
 2847|      0|  if (type != presentation_type::pointer) eh.on_error("invalid type specifier");
  ------------------
  |  Branch (2847:7): [True: 0, False: 0]
  ------------------
 2848|      0|  return false;
 2849|   118k|}
_ZN3fmt2v96detail22check_string_type_specINS1_13error_handlerEEEvNS0_17presentation_typeEOT_:
 2853|   251k|                                          ErrorHandler&& eh = {}) {
 2854|   251k|  if (type != presentation_type::none && type != presentation_type::string &&
  ------------------
  |  Branch (2854:7): [True: 251k, False: 0]
  |  Branch (2854:42): [True: 0, False: 251k]
  ------------------
 2855|   251k|      type != presentation_type::debug)
  ------------------
  |  Branch (2855:7): [True: 0, False: 0]
  ------------------
 2856|      0|    eh.on_error("invalid type specifier");
 2857|   251k|}
_ZN3fmt2v96detail4findILb0EcPKcEEbT1_S5_T0_RS5_:
 2334|   579k|                              const char*& out) -> bool {
 2335|   579k|  out = static_cast<const char*>(
 2336|   579k|      std::memchr(first, value, to_unsigned(last - first)));
 2337|   579k|  return out != nullptr;
 2338|   579k|}
_ZZN3fmt2v96detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS5_cEE5valueENS0_8appenderENSC_20back_insert_iteratorIS6_EEE4typeES5_EEEENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_EN6writerclEPKcST_:
 2708|   289k|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2709|   289k|      if (from == to) return;
  ------------------
  |  Branch (2709:11): [True: 0, False: 289k]
  ------------------
 2710|   289k|      for (;;) {
 2711|   289k|        const Char* p = nullptr;
 2712|   289k|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
  ------------------
  |  Branch (2712:13): [True: 289k, False: 0]
  ------------------
 2713|   289k|          return handler_.on_text(from, to);
 2714|      0|        ++p;
 2715|      0|        if (p == to || *p != '}')
  ------------------
  |  Branch (2715:13): [True: 0, False: 0]
  |  Branch (2715:24): [True: 0, False: 0]
  ------------------
 2716|      0|          return handler_.on_error("unmatched '}' in format string");
 2717|      0|        handler_.on_text(from, p);
 2718|      0|        from = p + 1;
 2719|      0|      }
 2720|   289k|    }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2ENS0_17basic_string_viewIcEE:
 1299|   133k|  FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
 1300|   133k|    string.data = val.data();
 1301|   133k|    string.size = val.size();
 1302|   133k|  }
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEPKc:
 1421|   118k|  FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
 1422|   118k|    return val;
 1423|   118k|  }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2EPKc:
 1295|   118k|  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
 1296|   118k|    string.data = val;
 1297|   118k|    if (is_constant_evaluated()) string.size = {};
  ------------------
  |  Branch (1297:9): [Folded - Ignored]
  ------------------
 1298|   118k|  }
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EEC2IJS7_S7_EEEDpRKT_:
 1189|   136k|  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EE10named_argsEv:
 1191|   136k|  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
 1192|   136k|    return nullptr;
 1193|   136k|  }
_ZNK3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EE4argsEv:
 1190|   136k|  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
_ZN3fmt2v96detail8make_argILb1ENS0_20basic_format_contextINS0_8appenderEcEELNS1_4typeE1ERiLi0EEENS1_5valueIT0_EEOT2_:
 1791|  2.79k|FMT_CONSTEXPR FMT_INLINE auto make_arg(T&& val) -> value<Context> {
 1792|  2.79k|  return make_value<Context>(val);
 1793|  2.79k|}
_ZNK3fmt2v96detail6bufferIcE4dataEv:
  925|  93.2k|  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }

_ZN3fmt2v97vformatENS0_17basic_string_viewIcEENS0_17basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEE:
 1488|  93.2k|FMT_FUNC std::string vformat(string_view fmt, format_args args) {
 1489|       |  // Don't optimize the "{}" case to keep the binary size small and because it
 1490|       |  // can be better optimized in fmt::format anyway.
 1491|  93.2k|  auto buffer = memory_buffer();
 1492|  93.2k|  detail::vformat_to(buffer, fmt, args);
 1493|  93.2k|  return to_string(buffer);
 1494|  93.2k|}
_ZN3fmt2v96detail5printEP8_IO_FILENS0_17basic_string_viewIcEE:
 1521|   159k|FMT_FUNC void print(std::FILE* f, string_view text) {
 1522|       |#ifdef _WIN32
 1523|       |  if (write_console(f, text)) return;
 1524|       |#endif
 1525|   159k|  detail::fwrite_fully(text.data(), 1, text.size(), f);
 1526|   159k|}
_ZN3fmt2v96vprintEP8_IO_FILENS0_17basic_string_viewIcEENS0_17basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEE:
 1529|   159k|FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
 1530|   159k|  memory_buffer buffer;
 1531|   159k|  detail::vformat_to(buffer, format_str, args);
 1532|   159k|  detail::print(f, {buffer.data(), buffer.size()});
 1533|   159k|}
_ZN3fmt2v96detail12fwrite_fullyEPKvmmP8_IO_FILE:
   81|   159k|                         FILE* stream) {
   82|   159k|  size_t written = std::fwrite(ptr, size, count, stream);
   83|   159k|  if (written < count)
  ------------------
  |  Branch (83:7): [True: 0, False: 159k]
  ------------------
   84|      0|    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
  ------------------
  |  |  100|      0|      do {                             \
  |  |  101|      0|        FMT_ASSERT(false, (x).what()); \
  |  |  ------------------
  |  |  |  |  365|      0|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  102|      0|      } while (false)
  |  |  ------------------
  |  |  |  Branch (102:16): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|   159k|}

_ZN3fmt2v96detail6bufferIcE6appendIcEEvPKT_S7_:
  807|  1.20M|void buffer<T>::append(const U* begin, const U* end) {
  808|  2.29M|  while (begin != end) {
  ------------------
  |  Branch (808:10): [True: 1.08M, False: 1.20M]
  ------------------
  809|  1.08M|    auto count = to_unsigned(end - begin);
  810|  1.08M|    try_reserve(size_ + count);
  811|  1.08M|    auto free_cap = capacity_ - size_;
  812|  1.08M|    if (free_cap < count) count = free_cap;
  ------------------
  |  Branch (812:9): [True: 0, False: 1.08M]
  ------------------
  813|  1.08M|    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
  814|  1.08M|    size_ += count;
  815|  1.08M|    begin += count;
  816|  1.08M|  }
  817|  1.20M|}
_ZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS4_cEE5valueENS0_8appenderENSB_20back_insert_iteratorIS5_EEE4typeES4_EEEENS1_10locale_refE:
 4180|   253k|                locale_ref loc) {
 4181|       |  // workaround for msvc bug regarding name-lookup in module
 4182|       |  // link names into function scope
 4183|   253k|  using detail::arg_formatter;
 4184|   253k|  using detail::buffer_appender;
 4185|   253k|  using detail::custom_formatter;
 4186|   253k|  using detail::default_arg_formatter;
 4187|   253k|  using detail::get_arg;
 4188|   253k|  using detail::locale_ref;
 4189|   253k|  using detail::parse_format_specs;
 4190|   253k|  using detail::specs_checker;
 4191|   253k|  using detail::specs_handler;
 4192|   253k|  using detail::to_unsigned;
 4193|   253k|  using detail::type;
 4194|   253k|  using detail::write;
 4195|   253k|  auto out = buffer_appender<Char>(buf);
 4196|   253k|  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
  ------------------
  |  Branch (4196:7): [True: 0, False: 253k]
  |  Branch (4196:26): [True: 0, False: 0]
  ------------------
 4197|      0|    auto arg = args.get(0);
 4198|      0|    if (!arg) error_handler().on_error("argument not found");
  ------------------
  |  Branch (4198:9): [True: 0, False: 0]
  ------------------
 4199|      0|    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
 4200|      0|    return;
 4201|      0|  }
 4202|       |
 4203|   253k|  struct format_handler : error_handler {
 4204|   253k|    basic_format_parse_context<Char> parse_context;
 4205|   253k|    buffer_context<Char> context;
 4206|       |
 4207|   253k|    format_handler(buffer_appender<Char> p_out, basic_string_view<Char> str,
 4208|   253k|                   basic_format_args<buffer_context<Char>> p_args,
 4209|   253k|                   locale_ref p_loc)
 4210|   253k|        : parse_context(str), context(p_out, p_args, p_loc) {}
 4211|       |
 4212|   253k|    void on_text(const Char* begin, const Char* end) {
 4213|   253k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4214|   253k|      context.advance_to(write<Char>(context.out(), text));
 4215|   253k|    }
 4216|       |
 4217|   253k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4218|   253k|      return parse_context.next_arg_id();
 4219|   253k|    }
 4220|   253k|    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
 4221|   253k|      return parse_context.check_arg_id(id), id;
 4222|   253k|    }
 4223|   253k|    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
 4224|   253k|      int arg_id = context.arg_id(id);
 4225|   253k|      if (arg_id < 0) on_error("argument not found");
 4226|   253k|      return arg_id;
 4227|   253k|    }
 4228|       |
 4229|   253k|    FMT_INLINE void on_replacement_field(int id, const Char*) {
 4230|   253k|      auto arg = get_arg(context, id);
 4231|   253k|      context.advance_to(visit_format_arg(
 4232|   253k|          default_arg_formatter<Char>{context.out(), context.args(),
 4233|   253k|                                      context.locale()},
 4234|   253k|          arg));
 4235|   253k|    }
 4236|       |
 4237|   253k|    auto on_format_specs(int id, const Char* begin, const Char* end)
 4238|   253k|        -> const Char* {
 4239|   253k|      auto arg = get_arg(context, id);
 4240|   253k|      if (arg.type() == type::custom_type) {
 4241|   253k|        parse_context.advance_to(parse_context.begin() +
 4242|   253k|                                 (begin - &*parse_context.begin()));
 4243|   253k|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4244|   253k|        return parse_context.begin();
 4245|   253k|      }
 4246|   253k|      auto specs = basic_format_specs<Char>();
 4247|   253k|      specs_checker<specs_handler<Char>> handler(
 4248|   253k|          specs_handler<Char>(specs, parse_context, context), arg.type());
 4249|   253k|      begin = parse_format_specs(begin, end, handler);
 4250|   253k|      if (begin == end || *begin != '}')
 4251|   253k|        on_error("missing '}' in format string");
 4252|   253k|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4253|   253k|      context.advance_to(visit_format_arg(f, arg));
 4254|   253k|      return begin;
 4255|   253k|    }
 4256|   253k|  };
 4257|   253k|  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
 4258|   253k|}
_ZN3fmt2v96detail11is_negativeIiLi0EEEbT_:
 1070|  5.89k|constexpr auto is_negative(T value) -> bool {
 1071|  5.89k|  return value < 0;
 1072|  5.89k|}
_ZN3fmt2v96detail12count_digitsEj:
 1214|   193k|FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
 1215|   193k|#ifdef FMT_BUILTIN_CLZ
 1216|   193k|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1216:7): [Folded - Ignored]
  ------------------
 1217|   193k|    return do_count_digits(n);
 1218|   193k|  }
 1219|      0|#endif
 1220|      0|  return count_digits_fallback(n);
 1221|   193k|}
_ZN3fmt2v96detail15do_count_digitsEj:
 1191|   193k|FMT_INLINE auto do_count_digits(uint32_t n) -> int {
 1192|       |// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
 1193|       |// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
 1195|   193k|  static constexpr uint64_t table[] = {
 1196|   193k|      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1197|   193k|      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1198|   193k|      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1199|   193k|      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1200|   193k|      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1201|   193k|      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1202|   193k|      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1203|   193k|      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1204|   193k|      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1205|   193k|      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1206|       |      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1194|   193k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1207|   193k|  };
 1208|   193k|  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
  ------------------
  |  |  145|   193k|#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
  ------------------
 1209|   193k|  return static_cast<int>((n + inc) >> 32);
 1210|   193k|}
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEEC2ERKS4_:
  876|   369k|      : alloc_(alloc) {
  877|   369k|    this->set(store_, SIZE);
  878|   369k|    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  ------------------
  |  Branch (878:9): [Folded - Ignored]
  ------------------
  879|   369k|  }
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEED2Ev:
  880|   369k|  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEE10deallocateEv:
  862|   369k|  FMT_CONSTEXPR20 void deallocate() {
  863|   369k|    T* data = this->data();
  864|   369k|    if (data != store_) alloc_.deallocate(data, this->capacity());
  ------------------
  |  Branch (864:9): [True: 0, False: 369k]
  ------------------
  865|   369k|  }
_ZN3fmt2v96detail8bit_castIjfLi0EEET_RKT0_:
  298|  56.3k|FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
  299|  56.3k|#ifdef __cpp_lib_bit_cast
  300|  56.3k|  if (is_constant_evaluated()) return std::bit_cast<To>(from);
  ------------------
  |  Branch (300:7): [Folded - Ignored]
  ------------------
  301|  56.3k|#endif
  302|  56.3k|  auto to = To();
  303|       |  // The cast suppresses a bogus -Wclass-memaccess on GCC.
  304|  56.3k|  std::memcpy(static_cast<void*>(&to), &from, sizeof(to));
  305|  56.3k|  return to;
  306|  56.3k|}
_ZN3fmt2v96detail13exponent_maskIfEENS1_9dragonbox10float_infoIT_vE12carrier_uintEv:
 1425|  56.3k|    typename dragonbox::float_info<Float>::carrier_uint {
 1426|  56.3k|  using float_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1427|  56.3k|  return ((float_uint(1) << dragonbox::float_info<Float>::exponent_bits) - 1)
 1428|  56.3k|         << num_significand_bits<Float>();
 1429|  56.3k|}
_ZN3fmt2v96detail20num_significand_bitsIfEEiv:
 1416|  56.3k|template <typename Float> constexpr int num_significand_bits() {
 1417|       |  // std::numeric_limits may not support __float128.
 1418|  56.3k|  return is_float128<Float>() ? 112
  ------------------
  |  Branch (1418:10): [Folded - Ignored]
  ------------------
 1419|  56.3k|                              : (std::numeric_limits<Float>::digits -
 1420|  56.3k|                                 (has_implicit_bit<Float>() ? 1 : 0));
  ------------------
  |  Branch (1420:35): [Folded - Ignored]
  ------------------
 1421|  56.3k|}
_ZN3fmt2v96detail13exponent_biasIfEEiv:
 1430|  56.3k|template <typename Float> constexpr auto exponent_bias() -> int {
 1431|       |  // std::numeric_limits may not support __float128.
 1432|  56.3k|  return is_float128<Float>() ? 16383
  ------------------
  |  Branch (1432:10): [Folded - Ignored]
  ------------------
 1433|  56.3k|                              : std::numeric_limits<Float>::max_exponent - 1;
 1434|  56.3k|}
_ZN3fmt2v96detail8bit_castImdLi0EEET_RKT0_:
  298|   111k|FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
  299|   111k|#ifdef __cpp_lib_bit_cast
  300|   111k|  if (is_constant_evaluated()) return std::bit_cast<To>(from);
  ------------------
  |  Branch (300:7): [Folded - Ignored]
  ------------------
  301|   111k|#endif
  302|   111k|  auto to = To();
  303|       |  // The cast suppresses a bogus -Wclass-memaccess on GCC.
  304|   111k|  std::memcpy(static_cast<void*>(&to), &from, sizeof(to));
  305|   111k|  return to;
  306|   111k|}
_ZN3fmt2v96detail13exponent_maskIdEENS1_9dragonbox10float_infoIT_vE12carrier_uintEv:
 1425|   111k|    typename dragonbox::float_info<Float>::carrier_uint {
 1426|   111k|  using float_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1427|   111k|  return ((float_uint(1) << dragonbox::float_info<Float>::exponent_bits) - 1)
 1428|   111k|         << num_significand_bits<Float>();
 1429|   111k|}
_ZN3fmt2v96detail20num_significand_bitsIdEEiv:
 1416|   111k|template <typename Float> constexpr int num_significand_bits() {
 1417|       |  // std::numeric_limits may not support __float128.
 1418|   111k|  return is_float128<Float>() ? 112
  ------------------
  |  Branch (1418:10): [Folded - Ignored]
  ------------------
 1419|   111k|                              : (std::numeric_limits<Float>::digits -
 1420|   111k|                                 (has_implicit_bit<Float>() ? 1 : 0));
  ------------------
  |  Branch (1420:35): [Folded - Ignored]
  ------------------
 1421|   111k|}
_ZN3fmt2v96detail13exponent_biasIdEEiv:
 1430|   111k|template <typename Float> constexpr auto exponent_bias() -> int {
 1431|       |  // std::numeric_limits may not support __float128.
 1432|   111k|  return is_float128<Float>() ? 16383
  ------------------
  |  Branch (1432:10): [Folded - Ignored]
  ------------------
 1433|   111k|                              : std::numeric_limits<Float>::max_exponent - 1;
 1434|   111k|}
_ZN3fmt2v96detail12make_checkedIcEEPT_S4_m:
  516|  1.08M|template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
  517|  1.08M|  return p;
  518|  1.08M|}
_ZN3fmt2v96detail21default_arg_formatterIcEclIiEENS0_8appenderET_:
 3500|  5.89k|  template <typename T> auto operator()(T value) -> iterator {
 3501|  5.89k|    return write<Char>(out, value);
 3502|  5.89k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEiLi0EEET0_S4_T1_:
 2255|  5.89k|FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
 2256|  5.89k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2257|  5.89k|  bool negative = is_negative(value);
 2258|       |  // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.
 2259|  5.89k|  if (negative) abs_value = ~abs_value + 1;
  ------------------
  |  Branch (2259:7): [True: 0, False: 5.89k]
  ------------------
 2260|  5.89k|  int num_digits = count_digits(abs_value);
 2261|  5.89k|  auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
  ------------------
  |  Branch (2261:16): [True: 0, False: 5.89k]
  ------------------
 2262|  5.89k|  auto it = reserve(out, size);
 2263|  5.89k|  if (auto ptr = to_pointer<Char>(it, size)) {
  ------------------
  |  Branch (2263:12): [True: 5.89k, False: 0]
  ------------------
 2264|  5.89k|    if (negative) *ptr++ = static_cast<Char>('-');
  ------------------
  |  Branch (2264:9): [True: 0, False: 5.89k]
  ------------------
 2265|  5.89k|    format_decimal<Char>(ptr, abs_value, num_digits);
 2266|  5.89k|    return out;
 2267|  5.89k|  }
 2268|      0|  if (negative) *it++ = static_cast<Char>('-');
  ------------------
  |  Branch (2268:7): [True: 0, False: 0]
  ------------------
 2269|      0|  it = format_decimal<Char>(it, abs_value, num_digits).end;
 2270|      0|  return base_iterator(out, it);
 2271|  5.89k|}
_ZN3fmt2v96detail7reserveINS0_8appenderEEERT_S5_m:
  544|  1.23M|constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
  545|  1.23M|  return it;
  546|  1.23M|}
_ZN3fmt2v96detail10to_pointerIcEEPT_NSt3__111conditionalIXsr3std7is_sameIS3_cEE5valueENS0_8appenderENS5_20back_insert_iteratorINS1_6bufferIS3_EEEEE4typeEm:
  556|  84.7k|template <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {
  557|  84.7k|  buffer<T>& buf = get_container(it);
  558|  84.7k|  auto size = buf.size();
  559|  84.7k|  if (buf.capacity() < size + n) return nullptr;
  ------------------
  |  Branch (559:7): [True: 0, False: 84.7k]
  ------------------
  560|  84.7k|  buf.try_resize(size + n);
  561|  84.7k|  return buf.data() + size;
  562|  84.7k|}
_ZN3fmt2v96detail14format_decimalIcjEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1284|  40.9k|    -> format_decimal_result<Char*> {
 1285|  40.9k|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  365|  40.9k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 1286|  40.9k|  out += size;
 1287|  40.9k|  Char* end = out;
 1288|   124k|  while (value >= 100) {
  ------------------
  |  Branch (1288:10): [True: 84.0k, False: 40.9k]
  ------------------
 1289|       |    // Integer division is slow so do it for a group of two digits instead
 1290|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1291|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1292|  84.0k|    out -= 2;
 1293|  84.0k|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1294|  84.0k|    value /= 100;
 1295|  84.0k|  }
 1296|  40.9k|  if (value < 10) {
  ------------------
  |  Branch (1296:7): [True: 22.7k, False: 18.2k]
  ------------------
 1297|  22.7k|    *--out = static_cast<Char>('0' + value);
 1298|  22.7k|    return {out, end};
 1299|  22.7k|  }
 1300|  18.2k|  out -= 2;
 1301|  18.2k|  copy2(out, digits2(static_cast<size_t>(value)));
 1302|  18.2k|  return {out, end};
 1303|  40.9k|}
_ZN3fmt2v96detail5copy2IcEEvPT_PKc:
 1265|   102k|FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
 1266|   102k|  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
  ------------------
  |  Branch (1266:7): [Folded - Ignored]
  |  Branch (1266:35): [Folded - Ignored]
  ------------------
 1267|   102k|    memcpy(dst, src, 2);
 1268|   102k|    return;
 1269|   102k|  }
 1270|      0|  *dst++ = static_cast<Char>(*src++);
 1271|      0|  *dst = static_cast<Char>(*src);
 1272|      0|}
_ZN3fmt2v96detail7digits2Em:
 1102|   102k|constexpr const char* digits2(size_t value) {
 1103|       |  // GCC generates slightly better code when value is pointer-size.
 1104|   102k|  return &"0001020304050607080910111213141516171819"
 1105|   102k|         "2021222324252627282930313233343536373839"
 1106|   102k|         "4041424344454647484950515253545556575859"
 1107|   102k|         "6061626364656667686970717273747576777879"
 1108|   102k|         "8081828384858687888990919293949596979899"[value * 2];
 1109|   102k|}
_ZN3fmt2v96detail14format_decimalIcjNS0_8appenderELi0EEENS1_21format_decimal_resultIT1_EES5_T0_i:
 1308|  33.7k|    -> format_decimal_result<Iterator> {
 1309|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1310|  33.7k|  Char buffer[digits10<UInt>() + 1] = {};
 1311|  33.7k|  auto end = format_decimal(buffer, value, size).end;
 1312|  33.7k|  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
 1313|  33.7k|}
_ZN3fmt2v96detail17copy_str_noinlineIcPcNS0_8appenderEEET1_T0_S6_S5_:
  601|  35.3k|                                                  OutputIt out) -> OutputIt {
  602|  35.3k|  return copy_str<OutChar>(begin, end, out);
  603|  35.3k|}
_ZN3fmt2v96detail13base_iteratorINS0_8appenderEEET_S4_S4_:
  572|  1.22M|constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
  573|  1.22M|  return it;
  574|  1.22M|}
_ZN3fmt2v96detail21default_arg_formatterIcEclIjEENS0_8appenderET_:
 3500|  1.32k|  template <typename T> auto operator()(T value) -> iterator {
 3501|  1.32k|    return write<Char>(out, value);
 3502|  1.32k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEjLi0EEET0_S4_T1_:
 2255|  1.32k|FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
 2256|  1.32k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2257|  1.32k|  bool negative = is_negative(value);
 2258|       |  // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.
 2259|  1.32k|  if (negative) abs_value = ~abs_value + 1;
  ------------------
  |  Branch (2259:7): [True: 0, False: 1.32k]
  ------------------
 2260|  1.32k|  int num_digits = count_digits(abs_value);
 2261|  1.32k|  auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
  ------------------
  |  Branch (2261:16): [True: 0, False: 1.32k]
  ------------------
 2262|  1.32k|  auto it = reserve(out, size);
 2263|  1.32k|  if (auto ptr = to_pointer<Char>(it, size)) {
  ------------------
  |  Branch (2263:12): [True: 1.32k, False: 0]
  ------------------
 2264|  1.32k|    if (negative) *ptr++ = static_cast<Char>('-');
  ------------------
  |  Branch (2264:9): [True: 0, False: 1.32k]
  ------------------
 2265|  1.32k|    format_decimal<Char>(ptr, abs_value, num_digits);
 2266|  1.32k|    return out;
 2267|  1.32k|  }
 2268|      0|  if (negative) *it++ = static_cast<Char>('-');
  ------------------
  |  Branch (2268:7): [True: 0, False: 0]
  ------------------
 2269|      0|  it = format_decimal<Char>(it, abs_value, num_digits).end;
 2270|      0|  return base_iterator(out, it);
 2271|  1.32k|}
_ZN3fmt2v96detail11is_negativeIjLi0EEEbT_:
 1074|   112k|constexpr auto is_negative(T) -> bool {
 1075|   112k|  return false;
 1076|   112k|}
_ZN3fmt2v96detail12count_digitsEm:
 1162|  3.18k|FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
 1163|  3.18k|#ifdef FMT_BUILTIN_CLZLL
 1164|  3.18k|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1164:7): [Folded - Ignored]
  ------------------
 1165|  3.18k|    return do_count_digits(n);
 1166|  3.18k|  }
 1167|      0|#endif
 1168|      0|  return count_digits_fallback(n);
 1169|  3.18k|}
_ZN3fmt2v96detail15do_count_digitsEm:
 1142|  3.18k|inline auto do_count_digits(uint64_t n) -> int {
 1143|       |  // This has comparable performance to the version by Kendall Willets
 1144|       |  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
 1145|       |  // but uses smaller tables.
 1146|       |  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
 1147|  3.18k|  static constexpr uint8_t bsr2log10[] = {
 1148|  3.18k|      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
 1149|  3.18k|      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
 1150|  3.18k|      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
 1151|  3.18k|      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
 1152|  3.18k|  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
  ------------------
  |  |  148|  3.18k|#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
  ------------------
 1153|  3.18k|  static constexpr const uint64_t zero_or_powers_of_10[] = {
 1154|  3.18k|      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1097|  3.18k|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1098|  3.18k|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1099|  3.18k|      (factor)*1000000000
  ------------------
                    0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1097|  3.18k|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1098|  3.18k|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1099|  3.18k|      (factor)*1000000000
  ------------------
 1155|  3.18k|      10000000000000000000ULL};
 1156|  3.18k|  return t - (n < zero_or_powers_of_10[t]);
 1157|  3.18k|}
_ZN3fmt2v96detail14format_decimalIcmEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1284|  1.59k|    -> format_decimal_result<Char*> {
 1285|  1.59k|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  365|  1.59k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 1286|  1.59k|  out += size;
 1287|  1.59k|  Char* end = out;
 1288|  1.59k|  while (value >= 100) {
  ------------------
  |  Branch (1288:10): [True: 0, False: 1.59k]
  ------------------
 1289|       |    // Integer division is slow so do it for a group of two digits instead
 1290|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1291|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1292|      0|    out -= 2;
 1293|      0|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1294|      0|    value /= 100;
 1295|      0|  }
 1296|  1.59k|  if (value < 10) {
  ------------------
  |  Branch (1296:7): [True: 1.59k, False: 0]
  ------------------
 1297|  1.59k|    *--out = static_cast<Char>('0' + value);
 1298|  1.59k|    return {out, end};
 1299|  1.59k|  }
 1300|      0|  out -= 2;
 1301|      0|  copy2(out, digits2(static_cast<size_t>(value)));
 1302|      0|  return {out, end};
 1303|  1.59k|}
_ZN3fmt2v96detail14format_decimalIcmNS0_8appenderELi0EEENS1_21format_decimal_resultIT1_EES5_T0_i:
 1308|  1.59k|    -> format_decimal_result<Iterator> {
 1309|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1310|  1.59k|  Char buffer[digits10<UInt>() + 1] = {};
 1311|  1.59k|  auto end = format_decimal(buffer, value, size).end;
 1312|  1.59k|  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
 1313|  1.59k|}
_ZN3fmt2v96detail11is_negativeIyLi0EEEbT_:
 1074|  1.59k|constexpr auto is_negative(T) -> bool {
 1075|  1.59k|  return false;
 1076|  1.59k|}
_ZN3fmt2v96detail18write_int_noinlineIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refE:
 2147|   111k|    locale_ref loc) -> OutputIt {
 2148|   111k|  return write_int(out, arg, specs, loc);
 2149|   111k|}
_ZN3fmt2v96detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refE:
 2091|   111k|                                        locale_ref) -> OutputIt {
 2092|   111k|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2093|   111k|  auto abs_value = arg.abs_value;
 2094|   111k|  auto prefix = arg.prefix;
 2095|   111k|  switch (specs.type) {
 2096|      0|  case presentation_type::none:
  ------------------
  |  Branch (2096:3): [True: 0, False: 111k]
  ------------------
 2097|  33.7k|  case presentation_type::dec: {
  ------------------
  |  Branch (2097:3): [True: 33.7k, False: 77.5k]
  ------------------
 2098|  33.7k|    auto num_digits = count_digits(abs_value);
 2099|  33.7k|    return write_int(
 2100|  33.7k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2101|  33.7k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2102|  33.7k|        });
 2103|      0|  }
 2104|      0|  case presentation_type::hex_lower:
  ------------------
  |  Branch (2104:3): [True: 0, False: 111k]
  ------------------
 2105|  77.5k|  case presentation_type::hex_upper: {
  ------------------
  |  Branch (2105:3): [True: 77.5k, False: 33.7k]
  ------------------
 2106|  77.5k|    bool upper = specs.type == presentation_type::hex_upper;
 2107|  77.5k|    if (specs.alt)
  ------------------
  |  Branch (2107:9): [True: 0, False: 77.5k]
  ------------------
 2108|      0|      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2108:38): [True: 0, False: 0]
  ------------------
 2109|  77.5k|    int num_digits = count_digits<4>(abs_value);
 2110|  77.5k|    return write_int(
 2111|  77.5k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2112|  77.5k|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2113|  77.5k|        });
 2114|      0|  }
 2115|      0|  case presentation_type::bin_lower:
  ------------------
  |  Branch (2115:3): [True: 0, False: 111k]
  ------------------
 2116|      0|  case presentation_type::bin_upper: {
  ------------------
  |  Branch (2116:3): [True: 0, False: 111k]
  ------------------
 2117|      0|    bool upper = specs.type == presentation_type::bin_upper;
 2118|      0|    if (specs.alt)
  ------------------
  |  Branch (2118:9): [True: 0, False: 0]
  ------------------
 2119|      0|      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2119:38): [True: 0, False: 0]
  ------------------
 2120|      0|    int num_digits = count_digits<1>(abs_value);
 2121|      0|    return write_int(out, num_digits, prefix, specs,
 2122|      0|                     [=](reserve_iterator<OutputIt> it) {
 2123|      0|                       return format_uint<1, Char>(it, abs_value, num_digits);
 2124|      0|                     });
 2125|      0|  }
 2126|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2126:3): [True: 0, False: 111k]
  ------------------
 2127|      0|    int num_digits = count_digits<3>(abs_value);
 2128|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2129|       |    // is not greater than the number of digits.
 2130|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2130:9): [True: 0, False: 0]
  |  Branch (2130:22): [True: 0, False: 0]
  |  Branch (2130:55): [True: 0, False: 0]
  ------------------
 2131|      0|      prefix_append(prefix, '0');
 2132|      0|    return write_int(out, num_digits, prefix, specs,
 2133|      0|                     [=](reserve_iterator<OutputIt> it) {
 2134|      0|                       return format_uint<3, Char>(it, abs_value, num_digits);
 2135|      0|                     });
 2136|      0|  }
 2137|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2137:3): [True: 0, False: 111k]
  ------------------
 2138|      0|    return write_char(out, static_cast<Char>(abs_value), specs);
 2139|      0|  default:
  ------------------
  |  Branch (2139:3): [True: 0, False: 111k]
  ------------------
 2140|      0|    throw_format_error("invalid type specifier");
 2141|   111k|  }
 2142|      0|  return out;
 2143|   111k|}
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_jEET0_S5_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEEUlS3_E_EESA_SA_ijRKNS9_IS5_EES7_:
 1926|  33.7k|                                        W write_digits) -> OutputIt {
 1927|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1928|  33.7k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1928:7): [True: 33.7k, False: 0]
  ------------------
 1929|  33.7k|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1930|  33.7k|    if (prefix != 0) {
  ------------------
  |  Branch (1930:9): [True: 0, False: 33.7k]
  ------------------
 1931|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1931:44): [True: 0, False: 0]
  ------------------
 1932|      0|        *it++ = static_cast<Char>(p & 0xff);
 1933|      0|    }
 1934|  33.7k|    return base_iterator(out, write_digits(it));
 1935|  33.7k|  }
 1936|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1937|      0|  return write_padded<align::right>(
 1938|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1939|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1940|      0|          *it++ = static_cast<Char>(p & 0xff);
 1941|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1942|      0|        return write_digits(it);
 1943|      0|      });
 1944|  33.7k|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEENKUlS3_E_clES3_:
 2100|  33.7k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2101|  33.7k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2102|  33.7k|        });
_ZN3fmt2v96detail14write_int_dataIcEC2EijRKNS0_18basic_format_specsIcEE:
 1904|  77.5k|      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
 1905|  77.5k|    if (specs.align == align::numeric) {
  ------------------
  |  Branch (1905:9): [True: 77.5k, False: 0]
  ------------------
 1906|  77.5k|      auto width = to_unsigned(specs.width);
 1907|  77.5k|      if (width > size) {
  ------------------
  |  Branch (1907:11): [True: 27.5k, False: 50.0k]
  ------------------
 1908|  27.5k|        padding = width - size;
 1909|  27.5k|        size = width;
 1910|  27.5k|      }
 1911|  77.5k|    } else if (specs.precision > num_digits) {
  ------------------
  |  Branch (1911:16): [True: 0, False: 0]
  ------------------
 1912|      0|      size = (prefix >> 24) + to_unsigned(specs.precision);
 1913|      0|      padding = to_unsigned(specs.precision - num_digits);
 1914|      0|    }
 1915|  77.5k|  }
_ZN3fmt2v96detail6fill_nINS0_8appenderEmcEET_S4_T0_RKT1_:
  580|  77.5k|    -> OutputIt {
  581|   105k|  for (Size i = 0; i < count; ++i) *out++ = value;
  ------------------
  |  Branch (581:20): [True: 27.5k, False: 77.5k]
  ------------------
  582|  77.5k|  return out;
  583|  77.5k|}
_ZN3fmt2v96detail12count_digitsILi4EjEEiT0_:
 1173|  77.5k|FMT_CONSTEXPR auto count_digits(UInt n) -> int {
 1174|  77.5k|#ifdef FMT_BUILTIN_CLZ
 1175|  77.5k|  if (!is_constant_evaluated() && num_bits<UInt>() == 32)
  ------------------
  |  Branch (1175:7): [Folded - Ignored]
  |  Branch (1175:35): [Folded - Ignored]
  ------------------
 1176|  77.5k|    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
  ------------------
  |  |  145|  77.5k|#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
  ------------------
 1177|      0|#endif
 1178|       |  // Lambda avoids unreachable code warnings from NVHPC.
 1179|      0|  return [](UInt m) {
 1180|      0|    int num_digits = 0;
 1181|      0|    do {
 1182|      0|      ++num_digits;
 1183|      0|    } while ((m >>= BITS) != 0);
 1184|      0|    return num_digits;
 1185|      0|  }(n);
 1186|  77.5k|}
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_jEET0_S5_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEEUlS3_E0_EESA_SA_ijRKNS9_IS5_EES7_:
 1926|  77.5k|                                        W write_digits) -> OutputIt {
 1927|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1928|  77.5k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1928:7): [True: 0, False: 77.5k]
  ------------------
 1929|      0|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1930|      0|    if (prefix != 0) {
  ------------------
  |  Branch (1930:9): [True: 0, False: 0]
  ------------------
 1931|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1931:44): [True: 0, False: 0]
  ------------------
 1932|      0|        *it++ = static_cast<Char>(p & 0xff);
 1933|      0|    }
 1934|      0|    return base_iterator(out, write_digits(it));
 1935|      0|  }
 1936|  77.5k|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1937|  77.5k|  return write_padded<align::right>(
 1938|  77.5k|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1939|  77.5k|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1940|  77.5k|          *it++ = static_cast<Char>(p & 0xff);
 1941|  77.5k|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1942|  77.5k|        return write_digits(it);
 1943|  77.5k|      });
 1944|  77.5k|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEENKUlS3_E0_clES3_:
 2111|  77.5k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2112|  77.5k|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2113|  77.5k|        });
_ZN3fmt2v96detail11format_uintILj4EcNS0_8appenderEjEET1_S4_T2_ib:
 1331|  77.5k|    -> It {
 1332|  77.5k|  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
  ------------------
  |  Branch (1332:12): [True: 77.5k, False: 0]
  ------------------
 1333|  77.5k|    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
 1334|  77.5k|    return out;
 1335|  77.5k|  }
 1336|       |  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
 1337|      0|  char buffer[num_bits<UInt>() / BASE_BITS + 1];
 1338|      0|  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
 1339|      0|  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
 1340|  77.5k|}
_ZN3fmt2v96detail11format_uintILj4EcjEEPT0_S4_T1_ib:
 1317|  77.5k|                               bool upper = false) -> Char* {
 1318|  77.5k|  buffer += num_digits;
 1319|  77.5k|  Char* end = buffer;
 1320|   268k|  do {
 1321|   268k|    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
  ------------------
  |  Branch (1321:26): [True: 268k, False: 0]
  ------------------
 1322|   268k|    unsigned digit = static_cast<unsigned>(value & ((1 << BASE_BITS) - 1));
 1323|   268k|    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
  ------------------
  |  Branch (1323:35): [Folded - Ignored]
  ------------------
 1324|   268k|                                                : digits[digit]);
 1325|   268k|  } while ((value >>= BASE_BITS) != 0);
  ------------------
  |  Branch (1325:12): [True: 190k, False: 77.5k]
  ------------------
 1326|  77.5k|  return end;
 1327|  77.5k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcZNS1_9write_intIS5_cZNS1_9write_intIcS5_jEET0_S8_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEEUlS5_E0_EESD_SD_ijRKNSC_IS8_EESA_EUlS5_E_EES8_S8_RKNSC_ISA_EEmOT2_:
 1688|  77.5k|                            size_t size, F&& f) -> OutputIt {
 1689|  77.5k|  return write_padded<align>(out, specs, size, size, f);
 1690|  77.5k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcRZNS1_9write_intIS5_cZNS1_9write_intIcS5_jEET0_S8_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEEUlS5_E0_EESD_SD_ijRKNSC_IS8_EESA_EUlS5_E_EES8_S8_RKNSC_ISA_EEmmOT2_:
 1669|  77.5k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1670|  77.5k|  static_assert(align == align::left || align == align::right, "");
 1671|  77.5k|  unsigned spec_width = to_unsigned(specs.width);
 1672|  77.5k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1672:20): [True: 0, False: 77.5k]
  ------------------
 1673|       |  // Shifts are encoded as string literals because static constexpr is not
 1674|       |  // supported in constexpr functions.
 1675|  77.5k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1675:18): [Folded - Ignored]
  ------------------
 1676|  77.5k|  size_t left_padding = padding >> shifts[specs.align];
 1677|  77.5k|  size_t right_padding = padding - left_padding;
 1678|  77.5k|  auto it = reserve(out, size + padding * specs.fill.size());
 1679|  77.5k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1679:7): [True: 0, False: 77.5k]
  ------------------
 1680|  77.5k|  it = f(it);
 1681|  77.5k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1681:7): [True: 0, False: 77.5k]
  ------------------
 1682|  77.5k|  return base_iterator(out, it);
 1683|  77.5k|}
_ZZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_jEET0_S5_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEEUlS3_E0_EESA_SA_ijRKNS9_IS5_EES7_ENKUlS3_E_clES3_:
 1938|  77.5k|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1939|  77.5k|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1939:46): [True: 0, False: 77.5k]
  ------------------
 1940|      0|          *it++ = static_cast<Char>(p & 0xff);
 1941|  77.5k|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1942|  77.5k|        return write_digits(it);
 1943|  77.5k|      });
_ZN3fmt2v96detail27is_supported_floating_pointIfEEbT_:
 1079|   119k|FMT_CONSTEXPR auto is_supported_floating_point(T) -> bool {
 1080|   119k|  if (std::is_same<T, float>()) return FMT_USE_FLOAT;
  ------------------
  |  |  184|   119k|#  define FMT_USE_FLOAT 1
  ------------------
  |  Branch (1080:7): [Folded - Ignored]
  ------------------
 1081|      0|  if (std::is_same<T, double>()) return FMT_USE_DOUBLE;
  ------------------
  |  |  187|      0|#  define FMT_USE_DOUBLE 1
  ------------------
  |  Branch (1081:7): [Folded - Ignored]
  ------------------
 1082|      0|  if (std::is_same<T, long double>()) return FMT_USE_LONG_DOUBLE;
  ------------------
  |  |  190|      0|#  define FMT_USE_LONG_DOUBLE 1
  ------------------
  |  Branch (1082:7): [Folded - Ignored]
  ------------------
 1083|      0|  return true;
 1084|      0|}
_ZN3fmt2v96detail7signbitIfLi0EEEbT_:
 2557|   119k|FMT_INLINE FMT_CONSTEXPR bool signbit(T value) {
 2558|   119k|  if (is_constant_evaluated()) {
  ------------------
  |  Branch (2558:7): [Folded - Ignored]
  ------------------
 2559|      0|#ifdef __cpp_if_constexpr
 2560|      0|    if constexpr (std::numeric_limits<double>::is_iec559) {
  ------------------
  |  Branch (2560:19): [Folded - Ignored]
  ------------------
 2561|      0|      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
 2562|      0|      return (bits >> (num_bits<uint64_t>() - 1)) != 0;
 2563|      0|    }
 2564|      0|#endif
 2565|      0|  }
 2566|   119k|  return std::signbit(static_cast<double>(value));
 2567|   119k|}
_ZN3fmt2v96detail15write_nonfiniteIcNS0_8appenderEEET0_S4_bNS0_18basic_format_specsIT_EERKNS1_11float_specsE:
 2276|  3.60k|                                     const float_specs& fspecs) -> OutputIt {
 2277|  3.60k|  auto str =
 2278|  3.60k|      isnan ? (fspecs.upper ? "NAN" : "nan") : (fspecs.upper ? "INF" : "inf");
  ------------------
  |  Branch (2278:7): [True: 3.59k, False: 5]
  |  Branch (2278:16): [True: 0, False: 3.59k]
  |  Branch (2278:49): [True: 0, False: 5]
  ------------------
 2279|  3.60k|  constexpr size_t str_size = 3;
 2280|  3.60k|  auto sign = fspecs.sign;
 2281|  3.60k|  auto size = str_size + (sign ? 1 : 0);
  ------------------
  |  Branch (2281:27): [True: 3.59k, False: 7]
  ------------------
 2282|       |  // Replace '0'-padding with space for non-finite values.
 2283|  3.60k|  const bool is_zero_fill =
 2284|  3.60k|      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');
  ------------------
  |  Branch (2284:7): [True: 3.60k, False: 0]
  |  Branch (2284:33): [True: 0, False: 3.60k]
  ------------------
 2285|  3.60k|  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');
  ------------------
  |  Branch (2285:7): [True: 0, False: 3.60k]
  ------------------
 2286|  3.60k|  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
 2287|  3.60k|    if (sign) *it++ = detail::sign<Char>(sign);
 2288|  3.60k|    return copy_str<Char>(str, str + str_size, it);
 2289|  3.60k|  });
 2290|  3.60k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcZNS1_15write_nonfiniteIcS5_EET0_S7_bNS0_18basic_format_specsIT_EERKNS1_11float_specsEEUlS5_E_EES7_S7_RKNS8_IT1_EEmOT2_:
 1688|  3.60k|                            size_t size, F&& f) -> OutputIt {
 1689|  3.60k|  return write_padded<align>(out, specs, size, size, f);
 1690|  3.60k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcRZNS1_15write_nonfiniteIcS5_EET0_S7_bNS0_18basic_format_specsIT_EERKNS1_11float_specsEEUlS5_E_EES7_S7_RKNS8_IT1_EEmmOT2_:
 1669|  3.60k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1670|  3.60k|  static_assert(align == align::left || align == align::right, "");
 1671|  3.60k|  unsigned spec_width = to_unsigned(specs.width);
 1672|  3.60k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1672:20): [True: 0, False: 3.60k]
  ------------------
 1673|       |  // Shifts are encoded as string literals because static constexpr is not
 1674|       |  // supported in constexpr functions.
 1675|  3.60k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1675:18): [Folded - Ignored]
  ------------------
 1676|  3.60k|  size_t left_padding = padding >> shifts[specs.align];
 1677|  3.60k|  size_t right_padding = padding - left_padding;
 1678|  3.60k|  auto it = reserve(out, size + padding * specs.fill.size());
 1679|  3.60k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1679:7): [True: 0, False: 3.60k]
  ------------------
 1680|  3.60k|  it = f(it);
 1681|  3.60k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1681:7): [True: 0, False: 3.60k]
  ------------------
 1682|  3.60k|  return base_iterator(out, it);
 1683|  3.60k|}
_ZZN3fmt2v96detail15write_nonfiniteIcNS0_8appenderEEET0_S4_bNS0_18basic_format_specsIT_EERKNS1_11float_specsEENKUlS3_E_clES3_:
 2286|  3.60k|  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
 2287|  3.60k|    if (sign) *it++ = detail::sign<Char>(sign);
  ------------------
  |  Branch (2287:9): [True: 3.59k, False: 7]
  ------------------
 2288|  3.60k|    return copy_str<Char>(str, str + str_size, it);
 2289|  3.60k|  });
_ZN3fmt2v96detail4signIcNS0_4sign4typeEEET_T0_:
 1112|  31.4k|template <typename Char, typename Sign> constexpr Char sign(Sign s) {
 1113|  31.4k|#if !FMT_GCC_VERSION || FMT_GCC_VERSION >= 604
 1114|  31.4k|  static_assert(std::is_same<Sign, sign_t>::value, "");
 1115|  31.4k|#endif
 1116|  31.4k|  return static_cast<Char>("\0-+ "[s]);
 1117|  31.4k|}
_ZN3fmt2v96detail6fill_nINS0_8appenderEicEET_S4_T0_RKT1_:
  580|  56.3k|    -> OutputIt {
  581|   340k|  for (Size i = 0; i < count; ++i) *out++ = value;
  ------------------
  |  Branch (581:20): [True: 283k, False: 56.3k]
  ------------------
  582|  56.3k|  return out;
  583|  56.3k|}
_ZN3fmt2v96detail14digit_groupingIcEC2ENS1_10locale_refEb:
 1968|  59.9k|  explicit digit_grouping(locale_ref loc, bool localized = true) {
 1969|  59.9k|    if (!localized) return;
  ------------------
  |  Branch (1969:9): [True: 59.9k, False: 0]
  ------------------
 1970|      0|    auto sep = thousands_sep<Char>(loc);
 1971|      0|    grouping_ = sep.grouping;
 1972|      0|    if (sep.thousands_sep) thousands_sep_.assign(1, sep.thousands_sep);
  ------------------
  |  Branch (1972:9): [True: 0, False: 0]
  ------------------
 1973|      0|  }
_ZNK3fmt2v96detail14digit_groupingIcE16count_separatorsEi:
 1979|  59.9k|  int count_separators(int num_digits) const {
 1980|  59.9k|    int count = 0;
 1981|  59.9k|    auto state = initial_state();
 1982|  59.9k|    while (num_digits > next(state)) ++count;
  ------------------
  |  Branch (1982:12): [True: 0, False: 59.9k]
  ------------------
 1983|  59.9k|    return count;
 1984|  59.9k|  }
_ZNK3fmt2v96detail14digit_groupingIcE13initial_stateEv:
 1955|  59.9k|  next_state initial_state() const { return {grouping_.begin(), 0}; }
_ZNK3fmt2v96detail14digit_groupingIcE4nextERNS3_10next_stateE:
 1958|  59.9k|  int next(next_state& state) const {
 1959|  59.9k|    if (thousands_sep_.empty()) return max_value<int>();
  ------------------
  |  Branch (1959:9): [True: 59.9k, False: 0]
  ------------------
 1960|      0|    if (state.group == grouping_.end()) return state.pos += grouping_.back();
  ------------------
  |  Branch (1960:9): [True: 0, False: 0]
  ------------------
 1961|      0|    if (*state.group <= 0 || *state.group == max_value<char>())
  ------------------
  |  Branch (1961:9): [True: 0, False: 0]
  |  Branch (1961:30): [True: 0, False: 0]
  ------------------
 1962|      0|      return max_value<int>();
 1963|      0|    state.pos += *state.group++;
 1964|      0|    return state.pos;
 1965|      0|  }
_ZN3fmt2v96detail9max_valueIiEET_v:
  446|   119k|template <typename T> constexpr auto max_value() -> T {
  447|   119k|  return (std::numeric_limits<T>::max)();
  448|   119k|}
_ZNK3fmt2v96detail14digit_groupingIcE13has_separatorEv:
 1977|  59.9k|  bool has_separator() const { return !thousands_sep_.empty(); }
_ZN3fmt2v96detail6fill_nIciEEPT_S4_T0_c:
  585|  5.03k|FMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {
  586|  5.03k|  if (is_constant_evaluated()) {
  ------------------
  |  Branch (586:7): [Folded - Ignored]
  ------------------
  587|      0|    return fill_n<T*, Size, T>(out, count, value);
  588|      0|  }
  589|  5.03k|  std::memset(out, value, to_unsigned(count));
  590|  5.03k|  return out + count;
  591|  5.03k|}
_ZN3fmt2v96detail8basic_fpIoEC2Ev:
 1466|  56.3k|  constexpr basic_fp() : f(0), e(0) {}
_ZN3fmt2v96detail8basic_fpIoE6assignIfLi0EEEbT_:
 1474|  56.3k|  FMT_CONSTEXPR auto assign(Float n) -> bool {
 1475|  56.3k|    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
 1476|       |    // Assume Float is in the format [sign][exponent][significand].
 1477|  56.3k|    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1478|  56.3k|    const auto num_float_significand_bits =
 1479|  56.3k|        detail::num_significand_bits<Float>();
 1480|  56.3k|    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
 1481|  56.3k|    const auto significand_mask = implicit_bit - 1;
 1482|  56.3k|    auto u = bit_cast<carrier_uint>(n);
 1483|  56.3k|    f = static_cast<F>(u & significand_mask);
 1484|  56.3k|    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
 1485|  56.3k|                                     num_float_significand_bits);
 1486|       |    // The predecessor is closer if n is a normalized power of 2 (f == 0)
 1487|       |    // other than the smallest normalized number (biased_e > 1).
 1488|  56.3k|    auto is_predecessor_closer = f == 0 && biased_e > 1;
  ------------------
  |  Branch (1488:34): [True: 4.88k, False: 51.5k]
  |  Branch (1488:44): [True: 4.88k, False: 0]
  ------------------
 1489|  56.3k|    if (biased_e == 0)
  ------------------
  |  Branch (1489:9): [True: 0, False: 56.3k]
  ------------------
 1490|      0|      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
 1491|  56.3k|    else if (has_implicit_bit<Float>())
  ------------------
  |  Branch (1491:14): [Folded - Ignored]
  ------------------
 1492|  56.3k|      f += static_cast<F>(implicit_bit);
 1493|  56.3k|    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
 1494|  56.3k|    if (!has_implicit_bit<Float>()) ++e;
  ------------------
  |  Branch (1494:9): [Folded - Ignored]
  ------------------
 1495|  56.3k|    return is_predecessor_closer;
 1496|  56.3k|  }
_ZN3fmt2v96detail13format_dragonENS1_8basic_fpIoEEjiRNS1_6bufferIcEERi:
 3009|  56.3k|                                          buffer<char>& buf, int& exp10) {
 3010|  56.3k|  bigint numerator;    // 2 * R in (FPP)^2.
 3011|  56.3k|  bigint denominator;  // 2 * S in (FPP)^2.
 3012|       |  // lower and upper are differences between value and corresponding boundaries.
 3013|  56.3k|  bigint lower;             // (M^- in (FPP)^2).
 3014|  56.3k|  bigint upper_store;       // upper's value if different from lower.
 3015|  56.3k|  bigint* upper = nullptr;  // (M^+ in (FPP)^2).
 3016|       |  // Shift numerator and denominator by an extra bit or two (if lower boundary
 3017|       |  // is closer) to make lower and upper integers. This eliminates multiplication
 3018|       |  // by 2 during later computations.
 3019|  56.3k|  bool is_predecessor_closer = (flags & dragon::predecessor_closer) != 0;
 3020|  56.3k|  int shift = is_predecessor_closer ? 2 : 1;
  ------------------
  |  Branch (3020:15): [True: 4.88k, False: 51.5k]
  ------------------
 3021|  56.3k|  if (value.e >= 0) {
  ------------------
  |  Branch (3021:7): [True: 45.1k, False: 11.2k]
  ------------------
 3022|  45.1k|    numerator = value.f;
 3023|  45.1k|    numerator <<= value.e + shift;
 3024|  45.1k|    lower = 1;
 3025|  45.1k|    lower <<= value.e;
 3026|  45.1k|    if (is_predecessor_closer) {
  ------------------
  |  Branch (3026:9): [True: 1.03k, False: 44.1k]
  ------------------
 3027|  1.03k|      upper_store = 1;
 3028|  1.03k|      upper_store <<= value.e + 1;
 3029|  1.03k|      upper = &upper_store;
 3030|  1.03k|    }
 3031|  45.1k|    denominator.assign_pow10(exp10);
 3032|  45.1k|    denominator <<= shift;
 3033|  45.1k|  } else if (exp10 < 0) {
  ------------------
  |  Branch (3033:14): [True: 1.10k, False: 10.1k]
  ------------------
 3034|  1.10k|    numerator.assign_pow10(-exp10);
 3035|  1.10k|    lower.assign(numerator);
 3036|  1.10k|    if (is_predecessor_closer) {
  ------------------
  |  Branch (3036:9): [True: 1.07k, False: 33]
  ------------------
 3037|  1.07k|      upper_store.assign(numerator);
 3038|  1.07k|      upper_store <<= 1;
 3039|  1.07k|      upper = &upper_store;
 3040|  1.07k|    }
 3041|  1.10k|    numerator *= value.f;
 3042|  1.10k|    numerator <<= shift;
 3043|  1.10k|    denominator = 1;
 3044|  1.10k|    denominator <<= shift - value.e;
 3045|  10.1k|  } else {
 3046|  10.1k|    numerator = value.f;
 3047|  10.1k|    numerator <<= shift;
 3048|  10.1k|    denominator.assign_pow10(exp10);
 3049|  10.1k|    denominator <<= shift - value.e;
 3050|  10.1k|    lower = 1;
 3051|  10.1k|    if (is_predecessor_closer) {
  ------------------
  |  Branch (3051:9): [True: 2.77k, False: 7.37k]
  ------------------
 3052|  2.77k|      upper_store = 1ULL << 1;
 3053|  2.77k|      upper = &upper_store;
 3054|  2.77k|    }
 3055|  10.1k|  }
 3056|  56.3k|  int even = static_cast<int>((value.f & 1) == 0);
 3057|  56.3k|  if (!upper) upper = &lower;
  ------------------
  |  Branch (3057:7): [True: 51.5k, False: 4.88k]
  ------------------
 3058|  56.3k|  if ((flags & dragon::fixup) != 0) {
  ------------------
  |  Branch (3058:7): [True: 0, False: 56.3k]
  ------------------
 3059|      0|    if (add_compare(numerator, *upper, denominator) + even <= 0) {
  ------------------
  |  Branch (3059:9): [True: 0, False: 0]
  ------------------
 3060|      0|      --exp10;
 3061|      0|      numerator *= 10;
 3062|      0|      if (num_digits < 0) {
  ------------------
  |  Branch (3062:11): [True: 0, False: 0]
  ------------------
 3063|      0|        lower *= 10;
 3064|      0|        if (upper != &lower) *upper *= 10;
  ------------------
  |  Branch (3064:13): [True: 0, False: 0]
  ------------------
 3065|      0|      }
 3066|      0|    }
 3067|      0|    if ((flags & dragon::fixed) != 0) adjust_precision(num_digits, exp10 + 1);
  ------------------
  |  Branch (3067:9): [True: 0, False: 0]
  ------------------
 3068|      0|  }
 3069|       |  // Invariant: value == (numerator / denominator) * pow(10, exp10).
 3070|  56.3k|  if (num_digits < 0) {
  ------------------
  |  Branch (3070:7): [True: 0, False: 56.3k]
  ------------------
 3071|       |    // Generate the shortest representation.
 3072|      0|    num_digits = 0;
 3073|      0|    char* data = buf.data();
 3074|      0|    for (;;) {
 3075|      0|      int digit = numerator.divmod_assign(denominator);
 3076|      0|      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.
 3077|       |      // numerator + upper >[=] pow10:
 3078|      0|      bool high = add_compare(numerator, *upper, denominator) + even > 0;
 3079|      0|      data[num_digits++] = static_cast<char>('0' + digit);
 3080|      0|      if (low || high) {
  ------------------
  |  Branch (3080:11): [True: 0, False: 0]
  |  Branch (3080:18): [True: 0, False: 0]
  ------------------
 3081|      0|        if (!low) {
  ------------------
  |  Branch (3081:13): [True: 0, False: 0]
  ------------------
 3082|      0|          ++data[num_digits - 1];
 3083|      0|        } else if (high) {
  ------------------
  |  Branch (3083:20): [True: 0, False: 0]
  ------------------
 3084|      0|          int result = add_compare(numerator, numerator, denominator);
 3085|       |          // Round half to even.
 3086|      0|          if (result > 0 || (result == 0 && (digit % 2) != 0))
  ------------------
  |  Branch (3086:15): [True: 0, False: 0]
  |  Branch (3086:30): [True: 0, False: 0]
  |  Branch (3086:45): [True: 0, False: 0]
  ------------------
 3087|      0|            ++data[num_digits - 1];
 3088|      0|        }
 3089|      0|        buf.try_resize(to_unsigned(num_digits));
 3090|      0|        exp10 -= num_digits - 1;
 3091|      0|        return;
 3092|      0|      }
 3093|      0|      numerator *= 10;
 3094|      0|      lower *= 10;
 3095|      0|      if (upper != &lower) *upper *= 10;
  ------------------
  |  Branch (3095:11): [True: 0, False: 0]
  ------------------
 3096|      0|    }
 3097|      0|  }
 3098|       |  // Generate the given number of digits.
 3099|  56.3k|  exp10 -= num_digits - 1;
 3100|  56.3k|  if (num_digits == 0) {
  ------------------
  |  Branch (3100:7): [True: 0, False: 56.3k]
  ------------------
 3101|      0|    denominator *= 10;
 3102|      0|    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
  ------------------
  |  Branch (3102:18): [True: 0, False: 0]
  ------------------
 3103|      0|    buf.push_back(digit);
 3104|      0|    return;
 3105|      0|  }
 3106|  56.3k|  buf.try_resize(to_unsigned(num_digits));
 3107|  1.66M|  for (int i = 0; i < num_digits - 1; ++i) {
  ------------------
  |  Branch (3107:19): [True: 1.60M, False: 56.3k]
  ------------------
 3108|  1.60M|    int digit = numerator.divmod_assign(denominator);
 3109|  1.60M|    buf[i] = static_cast<char>('0' + digit);
 3110|  1.60M|    numerator *= 10;
 3111|  1.60M|  }
 3112|  56.3k|  int digit = numerator.divmod_assign(denominator);
 3113|  56.3k|  auto result = add_compare(numerator, numerator, denominator);
 3114|  56.3k|  if (result > 0 || (result == 0 && (digit % 2) != 0)) {
  ------------------
  |  Branch (3114:7): [True: 0, False: 56.3k]
  |  Branch (3114:22): [True: 1.13k, False: 55.2k]
  |  Branch (3114:37): [True: 1.06k, False: 79]
  ------------------
 3115|  1.06k|    if (digit == 9) {
  ------------------
  |  Branch (3115:9): [True: 0, False: 1.06k]
  ------------------
 3116|      0|      const auto overflow = '0' + 10;
 3117|      0|      buf[num_digits - 1] = overflow;
 3118|       |      // Propagate the carry.
 3119|      0|      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
  ------------------
  |  Branch (3119:36): [True: 0, False: 0]
  |  Branch (3119:45): [True: 0, False: 0]
  ------------------
 3120|      0|        buf[i] = '0';
 3121|      0|        ++buf[i - 1];
 3122|      0|      }
 3123|      0|      if (buf[0] == overflow) {
  ------------------
  |  Branch (3123:11): [True: 0, False: 0]
  ------------------
 3124|      0|        buf[0] = '1';
 3125|      0|        ++exp10;
 3126|      0|      }
 3127|      0|      return;
 3128|      0|    }
 3129|  1.06k|    ++digit;
 3130|  1.06k|  }
 3131|  56.3k|  buf[num_digits - 1] = static_cast<char>('0' + digit);
 3132|  56.3k|}
_ZN3fmt2v96detail6bigintC2Ev:
 2834|   225k|  FMT_CONSTEXPR20 bigint() : exp_(0) {}
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEEC2ERKS4_:
  876|   225k|      : alloc_(alloc) {
  877|   225k|    this->set(store_, SIZE);
  878|   225k|    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  ------------------
  |  Branch (878:9): [Folded - Ignored]
  ------------------
  879|   225k|  }
_ZN3fmt2v96detail12make_checkedIjEEPT_S4_m:
  516|   203k|template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
  517|   203k|  return p;
  518|   203k|}
_ZN3fmt2v96detail6bigintaSIoEEvT_:
 2848|  55.2k|  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
 2849|  55.2k|    FMT_ASSERT(n > 0, "");
  ------------------
  |  |  365|  55.2k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2850|  55.2k|    assign(uint64_or_128_t<Int>(n));
 2851|  55.2k|  }
_ZN3fmt2v96detail6bigint6assignIoLi0EEEvT_:
 2823|  55.2k|  FMT_CONSTEXPR20 void assign(UInt n) {
 2824|  55.2k|    size_t num_bigits = 0;
 2825|  55.2k|    do {
 2826|  55.2k|      bigits_[num_bigits++] = static_cast<bigit>(n);
 2827|  55.2k|      n >>= bigit_bits;
 2828|  55.2k|    } while (n != 0);
  ------------------
  |  Branch (2828:14): [True: 0, False: 55.2k]
  ------------------
 2829|  55.2k|    bigits_.resize(num_bigits);
 2830|  55.2k|    exp_ = 0;
 2831|  55.2k|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEE6resizeEm:
  932|  6.66M|  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }
_ZN3fmt2v96detail6bigintlSEi:
 2857|   216k|  FMT_NOINLINE FMT_CONSTEXPR20 bigint& operator<<=(int shift) {
 2858|   216k|    FMT_ASSERT(shift >= 0, "");
  ------------------
  |  |  365|   216k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2859|   216k|    exp_ += shift / bigit_bits;
 2860|   216k|    shift %= bigit_bits;
 2861|   216k|    if (shift == 0) return *this;
  ------------------
  |  Branch (2861:9): [True: 393, False: 215k]
  ------------------
 2862|   215k|    bigit carry = 0;
 2863|   578k|    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
  ------------------
  |  Branch (2863:44): [True: 362k, False: 215k]
  ------------------
 2864|   362k|      bigit c = bigits_[i] >> (bigit_bits - shift);
 2865|   362k|      bigits_[i] = (bigits_[i] << shift) + carry;
 2866|   362k|      carry = c;
 2867|   362k|    }
 2868|   215k|    if (carry != 0) bigits_.push_back(carry);
  ------------------
  |  Branch (2868:9): [True: 47.9k, False: 167k]
  ------------------
 2869|   215k|    return *this;
 2870|   216k|  }
_ZN3fmt2v96detail6bigintaSIiEEvT_:
 2848|   113k|  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
 2849|   113k|    FMT_ASSERT(n > 0, "");
  ------------------
  |  |  365|   113k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2850|   113k|    assign(uint64_or_128_t<Int>(n));
 2851|   113k|  }
_ZN3fmt2v96detail6bigint6assignImLi0EEEvT_:
 2823|   116k|  FMT_CONSTEXPR20 void assign(UInt n) {
 2824|   116k|    size_t num_bigits = 0;
 2825|   116k|    do {
 2826|   116k|      bigits_[num_bigits++] = static_cast<bigit>(n);
 2827|   116k|      n >>= bigit_bits;
 2828|   116k|    } while (n != 0);
  ------------------
  |  Branch (2828:14): [True: 0, False: 116k]
  ------------------
 2829|   116k|    bigits_.resize(num_bigits);
 2830|   116k|    exp_ = 0;
 2831|   116k|  }
_ZN3fmt2v96detail6bigint12assign_pow10Ei:
 2921|  56.3k|  FMT_CONSTEXPR20 void assign_pow10(int exp) {
 2922|  56.3k|    FMT_ASSERT(exp >= 0, "");
  ------------------
  |  |  365|  56.3k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2923|  56.3k|    if (exp == 0) return *this = 1;
  ------------------
  |  Branch (2923:9): [True: 222, False: 56.1k]
  ------------------
 2924|       |    // Find the top bit.
 2925|  56.1k|    int bitmask = 1;
 2926|   314k|    while (exp >= bitmask) bitmask <<= 1;
  ------------------
  |  Branch (2926:12): [True: 257k, False: 56.1k]
  ------------------
 2927|  56.1k|    bitmask >>= 1;
 2928|       |    // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by
 2929|       |    // repeated squaring and multiplication.
 2930|  56.1k|    *this = 5;
 2931|  56.1k|    bitmask >>= 1;
 2932|   257k|    while (bitmask != 0) {
  ------------------
  |  Branch (2932:12): [True: 201k, False: 56.1k]
  ------------------
 2933|   201k|      square();
 2934|   201k|      if ((exp & bitmask) != 0) *this *= 5;
  ------------------
  |  Branch (2934:11): [True: 64.6k, False: 137k]
  ------------------
 2935|   201k|      bitmask >>= 1;
 2936|   201k|    }
 2937|  56.1k|    *this <<= exp;  // Multiply by pow(2, exp) by shifting.
 2938|  56.1k|  }
_ZN3fmt2v96detail6bigint6squareEv:
 2940|   201k|  FMT_CONSTEXPR20 void square() {
 2941|   201k|    int num_bigits = static_cast<int>(bigits_.size());
 2942|   201k|    int num_result_bigits = 2 * num_bigits;
 2943|   201k|    basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
 2944|   201k|    bigits_.resize(to_unsigned(num_result_bigits));
 2945|   201k|    auto sum = uint128_t();
 2946|   428k|    for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
  ------------------
  |  Branch (2946:31): [True: 226k, False: 201k]
  ------------------
 2947|       |      // Compute bigit at position bigit_index of the result by adding
 2948|       |      // cross-product terms n[i] * n[j] such that i + j == bigit_index.
 2949|   477k|      for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
  ------------------
  |  Branch (2949:40): [True: 251k, False: 226k]
  ------------------
 2950|       |        // Most terms are multiplied twice which can be optimized in the future.
 2951|   251k|        sum += static_cast<double_bigit>(n[i]) * n[j];
 2952|   251k|      }
 2953|   226k|      (*this)[bigit_index] = static_cast<bigit>(sum);
 2954|   226k|      sum >>= num_bits<bigit>();  // Compute the carry.
 2955|   226k|    }
 2956|       |    // Do the same for the top half.
 2957|   428k|    for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
  ------------------
  |  Branch (2957:40): [True: 226k, False: 201k]
  ------------------
 2958|   226k|         ++bigit_index) {
 2959|   251k|      for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
  ------------------
  |  Branch (2959:57): [True: 24.6k, False: 226k]
  ------------------
 2960|  24.6k|        sum += static_cast<double_bigit>(n[i++]) * n[j--];
 2961|   226k|      (*this)[bigit_index] = static_cast<bigit>(sum);
 2962|   226k|      sum >>= num_bits<bigit>();
 2963|   226k|    }
 2964|   201k|    remove_leading_zeros();
 2965|   201k|    exp_ *= 2;
 2966|   201k|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEEC2EOS5_:
  909|   201k|  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other) noexcept {
  910|   201k|    move(other);
  911|   201k|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEE4moveERS5_:
  884|   201k|  FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
  885|   201k|    alloc_ = std::move(other.alloc_);
  886|   201k|    T* data = other.data();
  887|   201k|    size_t size = other.size(), capacity = other.capacity();
  888|   201k|    if (data == other.store_) {
  ------------------
  |  Branch (888:9): [True: 201k, False: 0]
  ------------------
  889|   201k|      this->set(store_, capacity);
  890|   201k|      detail::copy_str<T>(other.store_, other.store_ + size,
  891|   201k|                          detail::make_checked(store_, capacity));
  892|   201k|    } else {
  893|      0|      this->set(data, capacity);
  894|       |      // Set pointer to the inline array so that delete is not called
  895|       |      // when deallocating.
  896|      0|      other.set(other.store_, 0);
  897|      0|      other.clear();
  898|      0|    }
  899|   201k|    this->resize(size);
  900|   201k|  }
_ZN3fmt2v96detail6bigintixEi:
 2757|  41.7M|  FMT_CONSTEXPR20 bigit& operator[](int index) {
 2758|  41.7M|    return bigits_[to_unsigned(index)];
 2759|  41.7M|  }
_ZN3fmt2v96detail8num_bitsIjEEiv:
  449|   452k|template <typename T> constexpr auto num_bits() -> int {
  450|   452k|  return std::numeric_limits<T>::digits;
  451|   452k|}
_ZN3fmt2v96detail6bigint20remove_leading_zerosEv:
 2771|  6.04M|  FMT_CONSTEXPR20 void remove_leading_zeros() {
 2772|  6.04M|    int num_bigits = static_cast<int>(bigits_.size()) - 1;
 2773|  6.64M|    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
  ------------------
  |  Branch (2773:12): [True: 6.26M, False: 377k]
  |  Branch (2773:30): [True: 596k, False: 5.66M]
  ------------------
 2774|  6.04M|    bigits_.resize(to_unsigned(num_bigits + 1));
 2775|  6.04M|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEED2Ev:
  880|   427k|  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEE10deallocateEv:
  862|   427k|  FMT_CONSTEXPR20 void deallocate() {
  863|   427k|    T* data = this->data();
  864|   427k|    if (data != store_) alloc_.deallocate(data, this->capacity());
  ------------------
  |  Branch (864:9): [True: 0, False: 427k]
  ------------------
  865|   427k|  }
_ZN3fmt2v96detail6bigint6assignERKS2_:
 2840|  2.18k|  FMT_CONSTEXPR20 void assign(const bigint& other) {
 2841|  2.18k|    auto size = other.bigits_.size();
 2842|  2.18k|    bigits_.resize(size);
 2843|  2.18k|    auto data = other.bigits_.data();
 2844|  2.18k|    std::copy(data, data + size, make_checked(bigits_.data(), size));
 2845|  2.18k|    exp_ = other.exp_;
 2846|  2.18k|  }
_ZN3fmt2v96detail6bigintmLIoEERS2_T_:
 2872|  1.10k|  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
 2873|  1.10k|    FMT_ASSERT(value > 0, "");
  ------------------
  |  |  365|  1.10k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2874|  1.10k|    multiply(uint32_or_64_or_128_t<Int>(value));
 2875|  1.10k|    return *this;
 2876|  1.10k|  }
_ZN3fmt2v96detail6bigint8multiplyIoLi0EEEvT_:
 2802|  1.10k|  FMT_CONSTEXPR20 void multiply(UInt value) {
 2803|  1.10k|    using half_uint =
 2804|  1.10k|        conditional_t<std::is_same<UInt, uint128_t>::value, uint64_t, uint32_t>;
 2805|  1.10k|    const int shift = num_bits<half_uint>() - bigit_bits;
 2806|  1.10k|    const UInt lower = static_cast<half_uint>(value);
 2807|  1.10k|    const UInt upper = value >> num_bits<half_uint>();
 2808|  1.10k|    UInt carry = 0;
 2809|  2.21k|    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
  ------------------
  |  Branch (2809:44): [True: 1.10k, False: 1.10k]
  ------------------
 2810|  1.10k|      UInt result = lower * bigits_[i] + static_cast<bigit>(carry);
 2811|  1.10k|      carry = (upper * bigits_[i] << shift) + (result >> bigit_bits) +
 2812|  1.10k|              (carry >> bigit_bits);
 2813|  1.10k|      bigits_[i] = static_cast<bigit>(result);
 2814|  1.10k|    }
 2815|  1.11k|    while (carry != 0) {
  ------------------
  |  Branch (2815:12): [True: 11, False: 1.10k]
  ------------------
 2816|     11|      bigits_.push_back(static_cast<bigit>(carry));
 2817|     11|      carry >>= bigit_bits;
 2818|     11|    }
 2819|  1.10k|  }
_ZN3fmt2v96detail8num_bitsImEEiv:
  449|  1.10k|template <typename T> constexpr auto num_bits() -> int {
  450|  1.10k|  return std::numeric_limits<T>::digits;
  451|  1.10k|}
_ZN3fmt2v96detail6bigintaSIyEEvT_:
 2848|  2.77k|  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
 2849|  2.77k|    FMT_ASSERT(n > 0, "");
  ------------------
  |  |  365|  2.77k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2850|  2.77k|    assign(uint64_or_128_t<Int>(n));
 2851|  2.77k|  }
_ZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_:
 2896|  56.3k|                                         const bigint& rhs) {
 2897|  56.3k|    auto minimum = [](int a, int b) { return a < b ? a : b; };
 2898|  56.3k|    auto maximum = [](int a, int b) { return a > b ? a : b; };
 2899|  56.3k|    int max_lhs_bigits = maximum(lhs1.num_bigits(), lhs2.num_bigits());
 2900|  56.3k|    int num_rhs_bigits = rhs.num_bigits();
 2901|  56.3k|    if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
  ------------------
  |  Branch (2901:9): [True: 35.6k, False: 20.7k]
  ------------------
 2902|  20.7k|    if (max_lhs_bigits > num_rhs_bigits) return 1;
  ------------------
  |  Branch (2902:9): [True: 0, False: 20.7k]
  ------------------
 2903|  20.7k|    auto get_bigit = [](const bigint& n, int i) -> bigit {
 2904|  20.7k|      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
 2905|  20.7k|    };
 2906|  20.7k|    double_bigit borrow = 0;
 2907|  20.7k|    int min_exp = minimum(minimum(lhs1.exp_, lhs2.exp_), rhs.exp_);
 2908|  21.9k|    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
  ------------------
  |  Branch (2908:38): [True: 20.7k, False: 1.13k]
  ------------------
 2909|  20.7k|      double_bigit sum =
 2910|  20.7k|          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
 2911|  20.7k|      bigit rhs_bigit = get_bigit(rhs, i);
 2912|  20.7k|      if (sum > rhs_bigit + borrow) return 1;
  ------------------
  |  Branch (2912:11): [True: 0, False: 20.7k]
  ------------------
 2913|  20.7k|      borrow = rhs_bigit + borrow - sum;
 2914|  20.7k|      if (borrow > 1) return -1;
  ------------------
  |  Branch (2914:11): [True: 19.6k, False: 1.15k]
  ------------------
 2915|  1.15k|      borrow <<= bigit_bits;
 2916|  1.15k|    }
 2917|  1.13k|    return borrow != 0 ? -1 : 0;
  ------------------
  |  Branch (2917:12): [True: 0, False: 1.13k]
  ------------------
 2918|  20.7k|  }
_ZZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_ENKUliiE0_clEii:
 2898|  56.3k|    auto maximum = [](int a, int b) { return a > b ? a : b; };
  ------------------
  |  Branch (2898:46): [True: 0, False: 56.3k]
  ------------------
_ZNK3fmt2v96detail6bigint10num_bigitsEv:
 2853|  26.9M|  FMT_CONSTEXPR20 int num_bigits() const {
 2854|  26.9M|    return static_cast<int>(bigits_.size()) + exp_;
 2855|  26.9M|  }
_ZZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_ENKUliiE_clEii:
 2897|  41.5k|    auto minimum = [](int a, int b) { return a < b ? a : b; };
  ------------------
  |  Branch (2897:46): [True: 11, False: 41.5k]
  ------------------
_ZZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_ENKUlS4_iE_clES4_i:
 2903|  62.3k|    auto get_bigit = [](const bigint& n, int i) -> bigit {
 2904|  62.3k|      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
  ------------------
  |  Branch (2904:14): [True: 62.3k, False: 11]
  |  Branch (2904:29): [True: 44.4k, False: 17.8k]
  ------------------
 2905|  62.3k|    };
_ZNK3fmt2v96detail6bigintixEi:
 2754|  20.9M|  FMT_CONSTEXPR20 bigit operator[](int index) const {
 2755|  20.9M|    return bigits_[to_unsigned(index)];
 2756|  20.9M|  }
_ZN3fmt2v96detail6bigintmLIiEERS2_T_:
 2872|  1.67M|  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
 2873|  1.67M|    FMT_ASSERT(value > 0, "");
  ------------------
  |  |  365|  1.67M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2874|  1.67M|    multiply(uint32_or_64_or_128_t<Int>(value));
 2875|  1.67M|    return *this;
 2876|  1.67M|  }
_ZN3fmt2v96detail6bigint8multiplyEj:
 2789|  1.67M|  FMT_CONSTEXPR20 void multiply(uint32_t value) {
 2790|  1.67M|    const double_bigit wide_value = value;
 2791|  1.67M|    bigit carry = 0;
 2792|  5.73M|    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
  ------------------
  |  Branch (2792:44): [True: 4.06M, False: 1.67M]
  ------------------
 2793|  4.06M|      double_bigit result = bigits_[i] * wide_value + carry;
 2794|  4.06M|      bigits_[i] = static_cast<bigit>(result);
 2795|  4.06M|      carry = static_cast<bigit>(result >> bigit_bits);
 2796|  4.06M|    }
 2797|  1.67M|    if (carry != 0) bigits_.push_back(carry);
  ------------------
  |  Branch (2797:9): [True: 342k, False: 1.33M]
  ------------------
 2798|  1.67M|  }
_ZN3fmt2v96detail16adjust_precisionERii:
 2641|   111k|inline FMT_CONSTEXPR20 void adjust_precision(int& precision, int exp10) {
 2642|       |  // Adjust fixed precision by exponent because it is relative to decimal
 2643|       |  // point.
 2644|   111k|  if (exp10 > 0 && precision > max_value<int>() - exp10)
  ------------------
  |  Branch (2644:7): [True: 59.9k, False: 51.3k]
  |  Branch (2644:20): [True: 0, False: 59.9k]
  ------------------
 2645|      0|    FMT_THROW(format_error("number is too big"));
  ------------------
  |  |  100|      0|      do {                             \
  |  |  101|      0|        FMT_ASSERT(false, (x).what()); \
  |  |  ------------------
  |  |  |  |  365|      0|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  102|      0|      } while (false)
  |  |  ------------------
  |  |  |  Branch (102:16): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2646|   111k|  precision += exp10;
 2647|   111k|}
_ZN3fmt2v96detail6bigint13divmod_assignERKS2_:
 2983|  1.66M|  FMT_CONSTEXPR20 int divmod_assign(const bigint& divisor) {
 2984|  1.66M|    FMT_ASSERT(this != &divisor, "");
  ------------------
  |  |  365|  1.66M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2985|  1.66M|    if (compare(*this, divisor) < 0) return 0;
  ------------------
  |  Branch (2985:9): [True: 440k, False: 1.22M]
  ------------------
 2986|  1.22M|    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
  ------------------
  |  |  365|  1.22M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2987|  1.22M|    align(divisor);
 2988|  1.22M|    int quotient = 0;
 2989|  5.84M|    do {
 2990|  5.84M|      subtract_aligned(divisor);
 2991|  5.84M|      ++quotient;
 2992|  5.84M|    } while (compare(*this, divisor) >= 0);
  ------------------
  |  Branch (2992:14): [True: 4.61M, False: 1.22M]
  ------------------
 2993|  1.22M|    return quotient;
 2994|  1.66M|  }
_ZN3fmt2v96detail6bigint5alignERKS2_:
 2970|  1.22M|  FMT_CONSTEXPR20 void align(const bigint& other) {
 2971|  1.22M|    int exp_difference = exp_ - other.exp_;
 2972|  1.22M|    if (exp_difference <= 0) return;
  ------------------
  |  Branch (2972:9): [True: 1.18M, False: 40.1k]
  ------------------
 2973|  40.1k|    int num_bigits = static_cast<int>(bigits_.size());
 2974|  40.1k|    bigits_.resize(to_unsigned(num_bigits + exp_difference));
 2975|   107k|    for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
  ------------------
  |  Branch (2975:58): [True: 67.4k, False: 40.1k]
  ------------------
 2976|  67.4k|      bigits_[j] = bigits_[i];
 2977|  40.1k|    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
 2978|  40.1k|    exp_ -= exp_difference;
 2979|  40.1k|  }
_ZN3fmt2v96detail6bigint16subtract_alignedERKS2_:
 2778|  5.84M|  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {
 2779|  5.84M|    FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
  ------------------
  |  |  365|  5.84M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2780|  5.84M|    FMT_ASSERT(compare(*this, other) >= 0, "");
  ------------------
  |  |  365|  5.84M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2781|  5.84M|    bigit borrow = 0;
 2782|  5.84M|    int i = other.exp_ - exp_;
 2783|  22.5M|    for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
  ------------------
  |  Branch (2783:50): [True: 16.6M, False: 5.84M]
  ------------------
 2784|  16.6M|      subtract_bigits(i, other.bigits_[j], borrow);
 2785|  6.64M|    while (borrow > 0) subtract_bigits(i, 0, borrow);
  ------------------
  |  Branch (2785:12): [True: 803k, False: 5.84M]
  ------------------
 2786|  5.84M|    remove_leading_zeros();
 2787|  5.84M|  }
_ZN3fmt2v96detail6bigint15subtract_bigitsEijRj:
 2765|  17.4M|  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {
 2766|  17.4M|    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
 2767|  17.4M|    (*this)[index] = static_cast<bigit>(result);
 2768|  17.4M|    borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
 2769|  17.4M|  }
_ZN3fmt2v96detail7compareERKNS1_6bigintES4_:
 2878|  13.3M|  friend FMT_CONSTEXPR20 int compare(const bigint& lhs, const bigint& rhs) {
 2879|  13.3M|    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
 2880|  13.3M|    if (num_lhs_bigits != num_rhs_bigits)
  ------------------
  |  Branch (2880:9): [True: 3.10M, False: 10.2M]
  ------------------
 2881|  3.10M|      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
  ------------------
  |  Branch (2881:14): [True: 2.74M, False: 354k]
  ------------------
 2882|  10.2M|    int i = static_cast<int>(lhs.bigits_.size()) - 1;
 2883|  10.2M|    int j = static_cast<int>(rhs.bigits_.size()) - 1;
 2884|  10.2M|    int end = i - j;
 2885|  10.2M|    if (end < 0) end = 0;
  ------------------
  |  Branch (2885:9): [True: 28.8k, False: 10.2M]
  ------------------
 2886|  10.5M|    for (; i >= end; --i, --j) {
  ------------------
  |  Branch (2886:12): [True: 10.4M, False: 110k]
  ------------------
 2887|  10.4M|      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
 2888|  10.4M|      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
  ------------------
  |  Branch (2888:11): [True: 10.1M, False: 319k]
  |  Branch (2888:42): [True: 8.82M, False: 1.30M]
  ------------------
 2889|  10.4M|    }
 2890|   110k|    if (i != j) return i > j ? 1 : -1;
  ------------------
  |  Branch (2890:9): [True: 88, False: 110k]
  |  Branch (2890:24): [True: 88, False: 0]
  ------------------
 2891|   110k|    return 0;
 2892|   110k|  }
_ZN3fmt2v96detail11write_floatINS0_8appenderENS1_14big_decimal_fpEcEET_S5_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refE:
 2520|   116k|    -> OutputIt {
 2521|   116k|  if (is_constant_evaluated()) {
  ------------------
  |  Branch (2521:7): [Folded - Ignored]
  ------------------
 2522|      0|    return do_write_float<OutputIt, DecimalFP, Char,
 2523|      0|                          fallback_digit_grouping<Char>>(out, f, specs, fspecs,
 2524|      0|                                                         loc);
 2525|   116k|  } else {
 2526|   116k|    return do_write_float(out, f, specs, fspecs, loc);
 2527|   116k|  }
 2528|   116k|}
_ZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refE:
 2401|   116k|    -> OutputIt {
 2402|   116k|  auto significand = f.significand;
 2403|   116k|  int significand_size = get_significand_size(f);
 2404|   116k|  const Char zero = static_cast<Char>('0');
 2405|   116k|  auto sign = fspecs.sign;
 2406|   116k|  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
  ------------------
  |  Branch (2406:50): [True: 27.8k, False: 88.4k]
  ------------------
 2407|   116k|  using iterator = reserve_iterator<OutputIt>;
 2408|       |
 2409|   116k|  Char decimal_point =
 2410|   116k|      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');
  ------------------
  |  Branch (2410:7): [True: 0, False: 116k]
  ------------------
 2411|       |
 2412|   116k|  int output_exp = f.exponent + significand_size - 1;
 2413|   116k|  auto use_exp_format = [=]() {
 2414|   116k|    if (fspecs.format == float_format::exp) return true;
 2415|   116k|    if (fspecs.format != float_format::general) return false;
 2416|       |    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
 2417|       |    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
 2418|   116k|    const int exp_lower = -4, exp_upper = 16;
 2419|   116k|    return output_exp < exp_lower ||
 2420|   116k|           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
 2421|   116k|  };
 2422|   116k|  if (use_exp_format()) {
  ------------------
  |  Branch (2422:7): [True: 0, False: 116k]
  ------------------
 2423|      0|    int num_zeros = 0;
 2424|      0|    if (fspecs.showpoint) {
  ------------------
  |  Branch (2424:9): [True: 0, False: 0]
  ------------------
 2425|      0|      num_zeros = fspecs.precision - significand_size;
 2426|      0|      if (num_zeros < 0) num_zeros = 0;
  ------------------
  |  Branch (2426:11): [True: 0, False: 0]
  ------------------
 2427|      0|      size += to_unsigned(num_zeros);
 2428|      0|    } else if (significand_size == 1) {
  ------------------
  |  Branch (2428:16): [True: 0, False: 0]
  ------------------
 2429|      0|      decimal_point = Char();
 2430|      0|    }
 2431|      0|    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;
  ------------------
  |  Branch (2431:27): [True: 0, False: 0]
  ------------------
 2432|      0|    int exp_digits = 2;
 2433|      0|    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;
  ------------------
  |  Branch (2433:9): [True: 0, False: 0]
  |  Branch (2433:45): [True: 0, False: 0]
  ------------------
 2434|       |
 2435|      0|    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
  ------------------
  |  Branch (2435:26): [True: 0, False: 0]
  ------------------
 2436|      0|    char exp_char = fspecs.upper ? 'E' : 'e';
  ------------------
  |  Branch (2436:21): [True: 0, False: 0]
  ------------------
 2437|      0|    auto write = [=](iterator it) {
 2438|      0|      if (sign) *it++ = detail::sign<Char>(sign);
 2439|       |      // Insert a decimal point after the first digit and add an exponent.
 2440|      0|      it = write_significand(it, significand, significand_size, 1,
 2441|      0|                             decimal_point);
 2442|      0|      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);
 2443|      0|      *it++ = static_cast<Char>(exp_char);
 2444|      0|      return write_exponent<Char>(output_exp, it);
 2445|      0|    };
 2446|      0|    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
  ------------------
  |  Branch (2446:12): [True: 0, False: 0]
  ------------------
 2447|      0|                           : base_iterator(out, write(reserve(out, size)));
 2448|      0|  }
 2449|       |
 2450|   116k|  int exp = f.exponent + significand_size;
 2451|   116k|  if (f.exponent >= 0) {
  ------------------
  |  Branch (2451:7): [True: 0, False: 116k]
  ------------------
 2452|       |    // 1234e5 -> 123400000[.0+]
 2453|      0|    size += to_unsigned(f.exponent);
 2454|      0|    int num_zeros = fspecs.precision - exp;
 2455|      0|    abort_fuzzing_if(num_zeros > 5000);
 2456|      0|    if (fspecs.showpoint) {
  ------------------
  |  Branch (2456:9): [True: 0, False: 0]
  ------------------
 2457|      0|      ++size;
 2458|      0|      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;
  ------------------
  |  Branch (2458:11): [True: 0, False: 0]
  |  Branch (2458:29): [True: 0, False: 0]
  ------------------
 2459|      0|      if (num_zeros > 0) size += to_unsigned(num_zeros);
  ------------------
  |  Branch (2459:11): [True: 0, False: 0]
  ------------------
 2460|      0|    }
 2461|      0|    auto grouping = Grouping(loc, fspecs.locale);
 2462|      0|    size += to_unsigned(grouping.count_separators(exp));
 2463|      0|    return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2464|      0|      if (sign) *it++ = detail::sign<Char>(sign);
 2465|      0|      it = write_significand<Char>(it, significand, significand_size,
 2466|      0|                                   f.exponent, grouping);
 2467|      0|      if (!fspecs.showpoint) return it;
 2468|      0|      *it++ = decimal_point;
 2469|      0|      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
 2470|      0|    });
 2471|   116k|  } else if (exp > 0) {
  ------------------
  |  Branch (2471:14): [True: 59.9k, False: 56.3k]
  ------------------
 2472|       |    // 1234e-2 -> 12.34[0+]
 2473|  59.9k|    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
  ------------------
  |  Branch (2473:21): [True: 59.9k, False: 0]
  ------------------
 2474|  59.9k|    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
  ------------------
  |  Branch (2474:29): [True: 0, False: 59.9k]
  ------------------
 2475|  59.9k|    auto grouping = Grouping(loc, fspecs.locale);
 2476|  59.9k|    size += to_unsigned(grouping.count_separators(significand_size));
 2477|  59.9k|    return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2478|  59.9k|      if (sign) *it++ = detail::sign<Char>(sign);
 2479|  59.9k|      it = write_significand(it, significand, significand_size, exp,
 2480|  59.9k|                             decimal_point, grouping);
 2481|  59.9k|      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
 2482|  59.9k|    });
 2483|  59.9k|  }
 2484|       |  // 1234e-6 -> 0.001234
 2485|  56.3k|  int num_zeros = -exp;
 2486|  56.3k|  if (significand_size == 0 && fspecs.precision >= 0 &&
  ------------------
  |  Branch (2486:7): [True: 44.6k, False: 11.7k]
  |  Branch (2486:32): [True: 44.6k, False: 0]
  ------------------
 2487|  56.3k|      fspecs.precision < num_zeros) {
  ------------------
  |  Branch (2487:7): [True: 44.6k, False: 0]
  ------------------
 2488|  44.6k|    num_zeros = fspecs.precision;
 2489|  44.6k|  }
 2490|  56.3k|  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
  ------------------
  |  Branch (2490:17): [True: 51.2k, False: 5.09k]
  |  Branch (2490:35): [True: 5.09k, False: 0]
  |  Branch (2490:60): [True: 0, False: 0]
  ------------------
 2491|  56.3k|  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
  ------------------
  |  Branch (2491:16): [True: 56.3k, False: 0]
  ------------------
 2492|  56.3k|  return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2493|  56.3k|    if (sign) *it++ = detail::sign<Char>(sign);
 2494|  56.3k|    *it++ = zero;
 2495|  56.3k|    if (!pointy) return it;
 2496|  56.3k|    *it++ = decimal_point;
 2497|  56.3k|    it = detail::fill_n(it, num_zeros, zero);
 2498|  56.3k|    return write_significand<Char>(it, significand, significand_size);
 2499|  56.3k|  });
 2500|   116k|}
_ZN3fmt2v96detail20get_significand_sizeERKNS1_14big_decimal_fpE:
 2299|   116k|constexpr auto get_significand_size(const big_decimal_fp& f) -> int {
 2300|   116k|  return f.significand_size;
 2301|   116k|}
_ZZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refEENKUlvE_clEv:
 2413|   116k|  auto use_exp_format = [=]() {
 2414|   116k|    if (fspecs.format == float_format::exp) return true;
  ------------------
  |  Branch (2414:9): [True: 0, False: 116k]
  ------------------
 2415|   116k|    if (fspecs.format != float_format::general) return false;
  ------------------
  |  Branch (2415:9): [True: 116k, False: 0]
  ------------------
 2416|       |    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
 2417|       |    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
 2418|      0|    const int exp_lower = -4, exp_upper = 16;
 2419|      0|    return output_exp < exp_lower ||
  ------------------
  |  Branch (2419:12): [True: 0, False: 0]
  ------------------
 2420|      0|           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
  ------------------
  |  Branch (2420:12): [True: 0, False: 0]
  |  Branch (2420:27): [True: 0, False: 0]
  ------------------
 2421|   116k|  };
_ZN3fmt2v96detail17write_significandINS0_8appenderEcEET_S4_PKciiT0_:
 2369|  59.9k|                                     Char decimal_point) -> OutputIt {
 2370|  59.9k|  out = detail::copy_str_noinline<Char>(significand,
 2371|  59.9k|                                        significand + integral_size, out);
 2372|  59.9k|  if (!decimal_point) return out;
  ------------------
  |  Branch (2372:7): [True: 0, False: 59.9k]
  ------------------
 2373|  59.9k|  *out++ = decimal_point;
 2374|  59.9k|  return detail::copy_str_noinline<Char>(significand + integral_size,
 2375|  59.9k|                                         significand + significand_size, out);
 2376|  59.9k|}
_ZN3fmt2v96detail17copy_str_noinlineIcPKcNS0_8appenderEEET1_T0_S7_S6_:
  601|   863k|                                                  OutputIt out) -> OutputIt {
  602|   863k|  return copy_str<OutChar>(begin, end, out);
  603|   863k|}
_ZN3fmt2v96detail17write_significandIcNS0_8appenderEEET0_S4_PKci:
 2309|  56.3k|                                 int significand_size) -> OutputIt {
 2310|  56.3k|  return copy_str<Char>(significand, significand + significand_size, out);
 2311|  56.3k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E1_EESB_SB_SI_mOT2_:
 1688|  59.9k|                            size_t size, F&& f) -> OutputIt {
 1689|  59.9k|  return write_padded<align>(out, specs, size, size, f);
 1690|  59.9k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcRZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E1_EESB_SB_SI_mmOT2_:
 1669|  59.9k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1670|  59.9k|  static_assert(align == align::left || align == align::right, "");
 1671|  59.9k|  unsigned spec_width = to_unsigned(specs.width);
 1672|  59.9k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1672:20): [True: 0, False: 59.9k]
  ------------------
 1673|       |  // Shifts are encoded as string literals because static constexpr is not
 1674|       |  // supported in constexpr functions.
 1675|  59.9k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1675:18): [Folded - Ignored]
  ------------------
 1676|  59.9k|  size_t left_padding = padding >> shifts[specs.align];
 1677|  59.9k|  size_t right_padding = padding - left_padding;
 1678|  59.9k|  auto it = reserve(out, size + padding * specs.fill.size());
 1679|  59.9k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1679:7): [True: 0, False: 59.9k]
  ------------------
 1680|  59.9k|  it = f(it);
 1681|  59.9k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1681:7): [True: 0, False: 59.9k]
  ------------------
 1682|  59.9k|  return base_iterator(out, it);
 1683|  59.9k|}
_ZZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refEENKUlS3_E1_clES3_:
 2477|  59.9k|    return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2478|  59.9k|      if (sign) *it++ = detail::sign<Char>(sign);
  ------------------
  |  Branch (2478:11): [True: 19.2k, False: 40.7k]
  ------------------
 2479|  59.9k|      it = write_significand(it, significand, significand_size, exp,
 2480|  59.9k|                             decimal_point, grouping);
 2481|  59.9k|      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
  ------------------
  |  Branch (2481:14): [True: 0, False: 59.9k]
  ------------------
 2482|  59.9k|    });
_ZN3fmt2v96detail17write_significandINS0_8appenderEcPKcNS1_14digit_groupingIcEEEET_S8_T1_iiT0_RKT2_:
 2382|  59.9k|                                       const Grouping& grouping) -> OutputIt {
 2383|  59.9k|  if (!grouping.has_separator()) {
  ------------------
  |  Branch (2383:7): [True: 59.9k, False: 0]
  ------------------
 2384|  59.9k|    return write_significand(out, significand, significand_size, integral_size,
 2385|  59.9k|                             decimal_point);
 2386|  59.9k|  }
 2387|      0|  auto buffer = basic_memory_buffer<Char>();
 2388|      0|  write_significand(buffer_appender<Char>(buffer), significand,
 2389|      0|                    significand_size, integral_size, decimal_point);
 2390|      0|  grouping.apply(
 2391|      0|      out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));
 2392|      0|  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,
 2393|      0|                                         buffer.end(), out);
 2394|  59.9k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E2_EESB_SB_SI_mOT2_:
 1688|  56.3k|                            size_t size, F&& f) -> OutputIt {
 1689|  56.3k|  return write_padded<align>(out, specs, size, size, f);
 1690|  56.3k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcRZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E2_EESB_SB_SI_mmOT2_:
 1669|  56.3k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1670|  56.3k|  static_assert(align == align::left || align == align::right, "");
 1671|  56.3k|  unsigned spec_width = to_unsigned(specs.width);
 1672|  56.3k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1672:20): [True: 0, False: 56.3k]
  ------------------
 1673|       |  // Shifts are encoded as string literals because static constexpr is not
 1674|       |  // supported in constexpr functions.
 1675|  56.3k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1675:18): [Folded - Ignored]
  ------------------
 1676|  56.3k|  size_t left_padding = padding >> shifts[specs.align];
 1677|  56.3k|  size_t right_padding = padding - left_padding;
 1678|  56.3k|  auto it = reserve(out, size + padding * specs.fill.size());
 1679|  56.3k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1679:7): [True: 0, False: 56.3k]
  ------------------
 1680|  56.3k|  it = f(it);
 1681|  56.3k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1681:7): [True: 0, False: 56.3k]
  ------------------
 1682|  56.3k|  return base_iterator(out, it);
 1683|  56.3k|}
_ZZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_18basic_format_specsIT1_EENS1_11float_specsENS1_10locale_refEENKUlS3_E2_clES3_:
 2492|  56.3k|  return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2493|  56.3k|    if (sign) *it++ = detail::sign<Char>(sign);
  ------------------
  |  Branch (2493:9): [True: 8.65k, False: 47.7k]
  ------------------
 2494|  56.3k|    *it++ = zero;
 2495|  56.3k|    if (!pointy) return it;
  ------------------
  |  Branch (2495:9): [True: 0, False: 56.3k]
  ------------------
 2496|  56.3k|    *it++ = decimal_point;
 2497|  56.3k|    it = detail::fill_n(it, num_zeros, zero);
 2498|  56.3k|    return write_significand<Char>(it, significand, significand_size);
 2499|  56.3k|  });
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EE:
 3403|   743k|    -> OutputIt {
 3404|   743k|  auto it = reserve(out, value.size());
 3405|   743k|  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
 3406|   743k|  return base_iterator(out, it);
 3407|   743k|}
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS4_cEE5valueENS0_8appenderENSB_20back_insert_iteratorIS5_EEE4typeES4_EEEENS1_10locale_refEEN14format_handler7on_textEPKcSN_:
 4212|   743k|    void on_text(const Char* begin, const Char* end) {
 4213|   743k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4214|   743k|      context.advance_to(write<Char>(context.out(), text));
 4215|   743k|    }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS4_cEE5valueENS0_8appenderENSB_20back_insert_iteratorIS5_EEE4typeES4_EEEENS1_10locale_refEEN14format_handler20on_replacement_fieldEiPKc:
 4229|  7.21k|    FMT_INLINE void on_replacement_field(int id, const Char*) {
 4230|  7.21k|      auto arg = get_arg(context, id);
 4231|  7.21k|      context.advance_to(visit_format_arg(
 4232|  7.21k|          default_arg_formatter<Char>{context.out(), context.args(),
 4233|  7.21k|                                      context.locale()},
 4234|  7.21k|          arg));
 4235|  7.21k|    }
_ZN3fmt2v96detail7get_argINS0_20basic_format_contextINS0_8appenderEcEEiEENT_10format_argERS6_T0_:
 3591|   491k|    typename Context::format_arg {
 3592|   491k|  auto arg = ctx.arg(id);
 3593|   491k|  if (!arg) ctx.on_error("argument not found");
  ------------------
  |  Branch (3593:7): [True: 0, False: 491k]
  ------------------
 3594|   491k|  return arg;
 3595|   491k|}
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS4_cEE5valueENS0_8appenderENSB_20back_insert_iteratorIS5_EEE4typeES4_EEEENS1_10locale_refEEN14format_handler9on_arg_idEv:
 4217|   424k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4218|   424k|      return parse_context.next_arg_id();
 4219|   424k|    }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS4_cEE5valueENS0_8appenderENSB_20back_insert_iteratorIS5_EEE4typeES4_EEEENS1_10locale_refEEN14format_handler9on_arg_idEi:
 4220|  67.0k|    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
 4221|  67.0k|      return parse_context.check_arg_id(id), id;
 4222|  67.0k|    }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS4_cEE5valueENS0_8appenderENSB_20back_insert_iteratorIS5_EEE4typeES4_EEEENS1_10locale_refEEN14format_handler15on_format_specsEiPKcSN_:
 4238|   484k|        -> const Char* {
 4239|   484k|      auto arg = get_arg(context, id);
 4240|   484k|      if (arg.type() == type::custom_type) {
  ------------------
  |  Branch (4240:11): [True: 0, False: 484k]
  ------------------
 4241|      0|        parse_context.advance_to(parse_context.begin() +
 4242|      0|                                 (begin - &*parse_context.begin()));
 4243|      0|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4244|      0|        return parse_context.begin();
 4245|      0|      }
 4246|   484k|      auto specs = basic_format_specs<Char>();
 4247|   484k|      specs_checker<specs_handler<Char>> handler(
 4248|   484k|          specs_handler<Char>(specs, parse_context, context), arg.type());
 4249|   484k|      begin = parse_format_specs(begin, end, handler);
 4250|   484k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (4250:11): [True: 0, False: 484k]
  |  Branch (4250:27): [True: 0, False: 484k]
  ------------------
 4251|      0|        on_error("missing '}' in format string");
 4252|   484k|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4253|   484k|      context.advance_to(visit_format_arg(f, arg));
 4254|   484k|      return begin;
 4255|   484k|    }
_ZN3fmt2v96detail13specs_handlerIcEC2ERNS0_18basic_format_specsIcEERNS0_26basic_format_parse_contextIcNS1_13error_handlerEEERNS0_20basic_format_contextINS0_8appenderEcEE:
 3624|   484k|      : specs_setter<Char>(specs), parse_context_(parse_ctx), context_(ctx) {}
_ZN3fmt2v96detail13arg_formatterIcEclIjEENS0_8appenderET_:
 3520|   111k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3521|   111k|    return detail::write(out, value, specs, locale);
 3522|   111k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEjLi0EEET0_S4_T1_RKNS0_18basic_format_specsIT_EENS1_10locale_refE:
 2156|   111k|                                    locale_ref loc) -> OutputIt {
 2157|   111k|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2157:7): [True: 0, False: 111k]
  |  Branch (2157:26): [True: 0, False: 0]
  ------------------
 2158|   111k|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2159|   111k|                            loc);
 2160|   111k|}
_ZN3fmt2v96detail18make_write_int_argIjEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2053|   111k|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2054|   111k|  auto prefix = 0u;
 2055|   111k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2056|   111k|  if (is_negative(value)) {
  ------------------
  |  Branch (2056:7): [True: 0, False: 111k]
  ------------------
 2057|      0|    prefix = 0x01000000 | '-';
 2058|      0|    abs_value = 0 - abs_value;
 2059|   111k|  } else {
 2060|   111k|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2061|   111k|                                            0x1000000u | ' '};
 2062|   111k|    prefix = prefixes[sign];
 2063|   111k|  }
 2064|   111k|  return {abs_value, prefix};
 2065|   111k|}
_ZN3fmt2v96detail18write_int_noinlineIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refE:
 2147|  1.59k|    locale_ref loc) -> OutputIt {
 2148|  1.59k|  return write_int(out, arg, specs, loc);
 2149|  1.59k|}
_ZN3fmt2v96detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refE:
 2091|  1.59k|                                        locale_ref) -> OutputIt {
 2092|  1.59k|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2093|  1.59k|  auto abs_value = arg.abs_value;
 2094|  1.59k|  auto prefix = arg.prefix;
 2095|  1.59k|  switch (specs.type) {
 2096|      0|  case presentation_type::none:
  ------------------
  |  Branch (2096:3): [True: 0, False: 1.59k]
  ------------------
 2097|  1.59k|  case presentation_type::dec: {
  ------------------
  |  Branch (2097:3): [True: 1.59k, False: 0]
  ------------------
 2098|  1.59k|    auto num_digits = count_digits(abs_value);
 2099|  1.59k|    return write_int(
 2100|  1.59k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2101|  1.59k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2102|  1.59k|        });
 2103|      0|  }
 2104|      0|  case presentation_type::hex_lower:
  ------------------
  |  Branch (2104:3): [True: 0, False: 1.59k]
  ------------------
 2105|      0|  case presentation_type::hex_upper: {
  ------------------
  |  Branch (2105:3): [True: 0, False: 1.59k]
  ------------------
 2106|      0|    bool upper = specs.type == presentation_type::hex_upper;
 2107|      0|    if (specs.alt)
  ------------------
  |  Branch (2107:9): [True: 0, False: 0]
  ------------------
 2108|      0|      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2108:38): [True: 0, False: 0]
  ------------------
 2109|      0|    int num_digits = count_digits<4>(abs_value);
 2110|      0|    return write_int(
 2111|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2112|      0|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2113|      0|        });
 2114|      0|  }
 2115|      0|  case presentation_type::bin_lower:
  ------------------
  |  Branch (2115:3): [True: 0, False: 1.59k]
  ------------------
 2116|      0|  case presentation_type::bin_upper: {
  ------------------
  |  Branch (2116:3): [True: 0, False: 1.59k]
  ------------------
 2117|      0|    bool upper = specs.type == presentation_type::bin_upper;
 2118|      0|    if (specs.alt)
  ------------------
  |  Branch (2118:9): [True: 0, False: 0]
  ------------------
 2119|      0|      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2119:38): [True: 0, False: 0]
  ------------------
 2120|      0|    int num_digits = count_digits<1>(abs_value);
 2121|      0|    return write_int(out, num_digits, prefix, specs,
 2122|      0|                     [=](reserve_iterator<OutputIt> it) {
 2123|      0|                       return format_uint<1, Char>(it, abs_value, num_digits);
 2124|      0|                     });
 2125|      0|  }
 2126|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2126:3): [True: 0, False: 1.59k]
  ------------------
 2127|      0|    int num_digits = count_digits<3>(abs_value);
 2128|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2129|       |    // is not greater than the number of digits.
 2130|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2130:9): [True: 0, False: 0]
  |  Branch (2130:22): [True: 0, False: 0]
  |  Branch (2130:55): [True: 0, False: 0]
  ------------------
 2131|      0|      prefix_append(prefix, '0');
 2132|      0|    return write_int(out, num_digits, prefix, specs,
 2133|      0|                     [=](reserve_iterator<OutputIt> it) {
 2134|      0|                       return format_uint<3, Char>(it, abs_value, num_digits);
 2135|      0|                     });
 2136|      0|  }
 2137|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2137:3): [True: 0, False: 1.59k]
  ------------------
 2138|      0|    return write_char(out, static_cast<Char>(abs_value), specs);
 2139|      0|  default:
  ------------------
  |  Branch (2139:3): [True: 0, False: 1.59k]
  ------------------
 2140|      0|    throw_format_error("invalid type specifier");
 2141|  1.59k|  }
 2142|      0|  return out;
 2143|  1.59k|}
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_mEET0_S5_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEEUlS3_E_EESA_SA_ijRKNS9_IS5_EES7_:
 1926|  1.59k|                                        W write_digits) -> OutputIt {
 1927|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1928|  1.59k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1928:7): [True: 1.59k, False: 0]
  ------------------
 1929|  1.59k|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1930|  1.59k|    if (prefix != 0) {
  ------------------
  |  Branch (1930:9): [True: 0, False: 1.59k]
  ------------------
 1931|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1931:44): [True: 0, False: 0]
  ------------------
 1932|      0|        *it++ = static_cast<Char>(p & 0xff);
 1933|      0|    }
 1934|  1.59k|    return base_iterator(out, write_digits(it));
 1935|  1.59k|  }
 1936|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1937|      0|  return write_padded<align::right>(
 1938|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1939|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1940|      0|          *it++ = static_cast<Char>(p & 0xff);
 1941|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1942|      0|        return write_digits(it);
 1943|      0|      });
 1944|  1.59k|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_18basic_format_specsIT_EENS1_10locale_refEENKUlS3_E_clES3_:
 2100|  1.59k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2101|  1.59k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2102|  1.59k|        });
_ZN3fmt2v96detail13arg_formatterIcEclIyEENS0_8appenderET_:
 3520|  1.59k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3521|  1.59k|    return detail::write(out, value, specs, locale);
 3522|  1.59k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEyLi0EEET0_S4_T1_RKNS0_18basic_format_specsIT_EENS1_10locale_refE:
 2156|  1.59k|                                    locale_ref loc) -> OutputIt {
 2157|  1.59k|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2157:7): [True: 0, False: 1.59k]
  |  Branch (2157:26): [True: 0, False: 0]
  ------------------
 2158|  1.59k|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2159|  1.59k|                            loc);
 2160|  1.59k|}
_ZN3fmt2v96detail18make_write_int_argIyEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2053|  1.59k|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2054|  1.59k|  auto prefix = 0u;
 2055|  1.59k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2056|  1.59k|  if (is_negative(value)) {
  ------------------
  |  Branch (2056:7): [True: 0, False: 1.59k]
  ------------------
 2057|      0|    prefix = 0x01000000 | '-';
 2058|      0|    abs_value = 0 - abs_value;
 2059|  1.59k|  } else {
 2060|  1.59k|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2061|  1.59k|                                            0x1000000u | ' '};
 2062|  1.59k|    prefix = prefixes[sign];
 2063|  1.59k|  }
 2064|  1.59k|  return {abs_value, prefix};
 2065|  1.59k|}
_ZN3fmt2v96detail13arg_formatterIcEclIfEENS0_8appenderET_:
 3520|   119k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3521|   119k|    return detail::write(out, value, specs, locale);
 3522|   119k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEfLi0EEET0_S4_T1_NS0_18basic_format_specsIT_EENS1_10locale_refE:
 3356|   119k|    -> OutputIt {
 3357|   119k|  if (const_check(!is_supported_floating_point(value))) return out;
  ------------------
  |  Branch (3357:7): [True: 0, False: 119k]
  ------------------
 3358|   119k|  return specs.localized && write_loc(out, value, specs, loc)
  ------------------
  |  Branch (3358:10): [True: 0, False: 119k]
  |  Branch (3358:29): [True: 0, False: 0]
  ------------------
 3359|   119k|             ? out
 3360|   119k|             : write_float(out, value, specs, loc);
 3361|   119k|}
_ZN3fmt2v96detail11write_floatIcNS0_8appenderEfEET0_S4_T1_NS0_18basic_format_specsIT_EENS1_10locale_refE:
 3306|   119k|    -> OutputIt {
 3307|   119k|  float_specs fspecs = parse_float_type_spec(specs);
 3308|   119k|  fspecs.sign = specs.sign;
 3309|   119k|  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
  ------------------
  |  Branch (3309:7): [True: 31.4k, False: 88.5k]
  ------------------
 3310|  31.4k|    fspecs.sign = sign::minus;
 3311|  31.4k|    value = -value;
 3312|  88.5k|  } else if (fspecs.sign == sign::minus) {
  ------------------
  |  Branch (3312:14): [True: 0, False: 88.5k]
  ------------------
 3313|      0|    fspecs.sign = sign::none;
 3314|      0|  }
 3315|       |
 3316|   119k|  if (!detail::isfinite(value))
  ------------------
  |  Branch (3316:7): [True: 3.60k, False: 116k]
  ------------------
 3317|  3.60k|    return write_nonfinite(out, detail::isnan(value), specs, fspecs);
 3318|       |
 3319|   116k|  if (specs.align == align::numeric && fspecs.sign) {
  ------------------
  |  Branch (3319:7): [True: 0, False: 116k]
  |  Branch (3319:40): [True: 0, False: 0]
  ------------------
 3320|      0|    auto it = reserve(out, 1);
 3321|      0|    *it++ = detail::sign<Char>(fspecs.sign);
 3322|      0|    out = base_iterator(out, it);
 3323|      0|    fspecs.sign = sign::none;
 3324|      0|    if (specs.width != 0) --specs.width;
  ------------------
  |  Branch (3324:9): [True: 0, False: 0]
  ------------------
 3325|      0|  }
 3326|       |
 3327|   116k|  memory_buffer buffer;
 3328|   116k|  if (fspecs.format == float_format::hex) {
  ------------------
  |  Branch (3328:7): [True: 0, False: 116k]
  ------------------
 3329|      0|    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
  ------------------
  |  Branch (3329:9): [True: 0, False: 0]
  ------------------
 3330|      0|    format_hexfloat(convert_float(value), specs.precision, fspecs, buffer);
 3331|      0|    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
 3332|      0|                                     specs);
 3333|      0|  }
 3334|   116k|  int precision = specs.precision >= 0 || specs.type == presentation_type::none
  ------------------
  |  Branch (3334:19): [True: 0, False: 116k]
  |  Branch (3334:43): [True: 0, False: 116k]
  ------------------
 3335|   116k|                      ? specs.precision
 3336|   116k|                      : 6;
 3337|   116k|  if (fspecs.format == float_format::exp) {
  ------------------
  |  Branch (3337:7): [True: 0, False: 116k]
  ------------------
 3338|      0|    if (precision == max_value<int>())
  ------------------
  |  Branch (3338:9): [True: 0, False: 0]
  ------------------
 3339|      0|      throw_format_error("number is too big");
 3340|      0|    else
 3341|      0|      ++precision;
 3342|   116k|  } else if (fspecs.format != float_format::fixed && precision == 0) {
  ------------------
  |  Branch (3342:14): [True: 0, False: 116k]
  |  Branch (3342:54): [True: 0, False: 0]
  ------------------
 3343|      0|    precision = 1;
 3344|      0|  }
 3345|   116k|  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
  ------------------
  |  Branch (3345:7): [Folded - Ignored]
  ------------------
 3346|   116k|  int exp = format_float(convert_float(value), precision, fspecs, buffer);
 3347|   116k|  fspecs.precision = precision;
 3348|   116k|  auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
 3349|   116k|  return write_float(out, f, specs, fspecs, loc);
 3350|   116k|}
_ZN3fmt2v96detail8isfiniteIfLi0EEEbT_:
 2543|   119k|FMT_CONSTEXPR20 bool isfinite(T value) {
 2544|   119k|  constexpr T inf = T(std::numeric_limits<double>::infinity());
 2545|   119k|  if (is_constant_evaluated())
  ------------------
  |  Branch (2545:7): [Folded - Ignored]
  ------------------
 2546|      0|    return !detail::isnan(value) && value < inf && value > -inf;
  ------------------
  |  Branch (2546:12): [True: 0, False: 0]
  |  Branch (2546:37): [True: 0, False: 0]
  |  Branch (2546:52): [True: 0, False: 0]
  ------------------
 2547|   119k|  return std::isfinite(value);
 2548|   119k|}
_ZN3fmt2v96detail5isnanIfEEbT_:
 2530|  3.60k|template <typename T> constexpr bool isnan(T value) {
 2531|  3.60k|  return !(value >= value);  // std::isnan doesn't support __float128.
 2532|  3.60k|}
_ZN3fmt2v96detail13convert_floatIfEENSt3__111conditionalIXoosr3std7is_sameIT_fEE5valueeqsr3std14numeric_limitsIS5_EE6digitsL_ZNS3_14numeric_limitsIdE6digitsEEEdS5_E4typeES5_:
 1647|   116k|constexpr auto convert_float(T value) -> convert_float_result<T> {
 1648|   116k|  return static_cast<convert_float_result<T>>(value);
 1649|   116k|}
_ZN3fmt2v96detail12format_floatIdEEiT_iNS1_11float_specsERNS1_6bufferIcEE:
 3218|   116k|                                  buffer<char>& buf) -> int {
 3219|       |  // float is passed as double to reduce the number of instantiations.
 3220|   116k|  static_assert(!std::is_same<Float, float>::value, "");
 3221|   116k|  FMT_ASSERT(value >= 0, "value is negative");
  ------------------
  |  |  365|   116k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 3222|   116k|  auto converted_value = convert_float(value);
 3223|       |
 3224|   116k|  const bool fixed = specs.format == float_format::fixed;
 3225|   116k|  if (value <= 0) {  // <= instead of == to silence a warning.
  ------------------
  |  Branch (3225:7): [True: 5.03k, False: 111k]
  ------------------
 3226|  5.03k|    if (precision <= 0 || !fixed) {
  ------------------
  |  Branch (3226:9): [True: 0, False: 5.03k]
  |  Branch (3226:27): [True: 0, False: 5.03k]
  ------------------
 3227|      0|      buf.push_back('0');
 3228|      0|      return 0;
 3229|      0|    }
 3230|  5.03k|    buf.try_resize(to_unsigned(precision));
 3231|  5.03k|    fill_n(buf.data(), precision, '0');
 3232|  5.03k|    return -precision;
 3233|  5.03k|  }
 3234|       |
 3235|   111k|  int exp = 0;
 3236|   111k|  bool use_dragon = true;
 3237|   111k|  unsigned dragon_flags = 0;
 3238|   111k|  if (!is_fast_float<Float>()) {
  ------------------
  |  Branch (3238:7): [Folded - Ignored]
  ------------------
 3239|      0|    const auto inv_log2_10 = 0.3010299956639812;  // 1 / log2(10)
 3240|      0|    using info = dragonbox::float_info<decltype(converted_value)>;
 3241|      0|    const auto f = basic_fp<typename info::carrier_uint>(converted_value);
 3242|       |    // Compute exp, an approximate power of 10, such that
 3243|       |    //   10^(exp - 1) <= value < 10^exp or 10^exp <= value < 10^(exp + 1).
 3244|       |    // This is based on log10(value) == log2(value) / log2(10) and approximation
 3245|       |    // of log2(value) by e + num_fraction_bits idea from double-conversion.
 3246|      0|    exp = static_cast<int>(
 3247|      0|        std::ceil((f.e + count_digits<1>(f.f) - 1) * inv_log2_10 - 1e-10));
 3248|      0|    dragon_flags = dragon::fixup;
 3249|   111k|  } else if (!is_constant_evaluated() && precision < 0) {
  ------------------
  |  Branch (3249:14): [Folded - Ignored]
  |  Branch (3249:42): [True: 0, False: 111k]
  ------------------
 3250|       |    // Use Dragonbox for the shortest format.
 3251|      0|    if (specs.binary32) {
  ------------------
  |  Branch (3251:9): [True: 0, False: 0]
  ------------------
 3252|      0|      auto dec = dragonbox::to_decimal(static_cast<float>(value));
 3253|      0|      write<char>(buffer_appender<char>(buf), dec.significand);
 3254|      0|      return dec.exponent;
 3255|      0|    }
 3256|      0|    auto dec = dragonbox::to_decimal(static_cast<double>(value));
 3257|      0|    write<char>(buffer_appender<char>(buf), dec.significand);
 3258|      0|    return dec.exponent;
 3259|   111k|  } else {
 3260|       |    // Use Grisu + Dragon4 for the given precision:
 3261|       |    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.
 3262|   111k|    const int min_exp = -60;  // alpha in Grisu.
 3263|   111k|    int cached_exp10 = 0;     // K in Grisu.
 3264|   111k|    fp normalized = normalize(fp(converted_value));
 3265|   111k|    const auto cached_pow = get_cached_power(
 3266|   111k|        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);
 3267|   111k|    normalized = normalized * cached_pow;
 3268|   111k|    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
 3269|   111k|    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&
  ------------------
  |  Branch (3269:9): [True: 54.9k, False: 56.3k]
  ------------------
 3270|   111k|        !is_constant_evaluated()) {
  ------------------
  |  Branch (3270:9): [Folded - Ignored]
  ------------------
 3271|  54.9k|      exp += handler.exp10;
 3272|  54.9k|      buf.try_resize(to_unsigned(handler.size));
 3273|  54.9k|      use_dragon = false;
 3274|  56.3k|    } else {
 3275|  56.3k|      exp += handler.size - cached_exp10 - 1;
 3276|  56.3k|      precision = handler.precision;
 3277|  56.3k|    }
 3278|   111k|  }
 3279|   111k|  if (use_dragon) {
  ------------------
  |  Branch (3279:7): [True: 56.3k, False: 54.9k]
  ------------------
 3280|  56.3k|    auto f = basic_fp<uint128_t>();
 3281|  56.3k|    bool is_predecessor_closer = specs.binary32
  ------------------
  |  Branch (3281:34): [True: 56.3k, False: 0]
  ------------------
 3282|  56.3k|                                     ? f.assign(static_cast<float>(value))
 3283|  56.3k|                                     : f.assign(converted_value);
 3284|  56.3k|    if (is_predecessor_closer) dragon_flags |= dragon::predecessor_closer;
  ------------------
  |  Branch (3284:9): [True: 4.88k, False: 51.5k]
  ------------------
 3285|  56.3k|    if (fixed) dragon_flags |= dragon::fixed;
  ------------------
  |  Branch (3285:9): [True: 56.3k, False: 0]
  ------------------
 3286|       |    // Limit precision to the maximum possible number of significant digits in
 3287|       |    // an IEEE754 double because we don't need to generate zeros.
 3288|  56.3k|    const int max_double_digits = 767;
 3289|  56.3k|    if (precision > max_double_digits) precision = max_double_digits;
  ------------------
  |  Branch (3289:9): [True: 0, False: 56.3k]
  ------------------
 3290|  56.3k|    format_dragon(f, dragon_flags, precision, buf, exp);
 3291|  56.3k|  }
 3292|   111k|  if (!fixed && !specs.showpoint) {
  ------------------
  |  Branch (3292:7): [True: 0, False: 111k]
  |  Branch (3292:17): [True: 0, False: 0]
  ------------------
 3293|       |    // Remove trailing zeros.
 3294|      0|    auto num_digits = buf.size();
 3295|      0|    while (num_digits > 0 && buf[num_digits - 1] == '0') {
  ------------------
  |  Branch (3295:12): [True: 0, False: 0]
  |  Branch (3295:30): [True: 0, False: 0]
  ------------------
 3296|      0|      --num_digits;
 3297|      0|      ++exp;
 3298|      0|    }
 3299|      0|    buf.try_resize(num_digits);
 3300|      0|  }
 3301|   111k|  return exp;
 3302|   111k|}
_ZN3fmt2v96detail13convert_floatIdEENSt3__111conditionalIXoosr3std7is_sameIT_fEE5valueeqsr3std14numeric_limitsIS5_EE6digitsL_ZNS3_14numeric_limitsIdE6digitsEEEdS5_E4typeES5_:
 1647|   116k|constexpr auto convert_float(T value) -> convert_float_result<T> {
 1648|   116k|  return static_cast<convert_float_result<T>>(value);
 1649|   116k|}
_ZN3fmt2v96detail9normalizeILi0EyEENS1_8basic_fpIT0_EES5_:
 1509|   111k|FMT_CONSTEXPR basic_fp<F> normalize(basic_fp<F> value) {
 1510|       |  // Handle subnormals.
 1511|   111k|  const auto implicit_bit = F(1) << num_significand_bits<double>();
 1512|   111k|  const auto shifted_implicit_bit = implicit_bit << SHIFT;
 1513|   111k|  while ((value.f & shifted_implicit_bit) == 0) {
  ------------------
  |  Branch (1513:10): [True: 0, False: 111k]
  ------------------
 1514|      0|    value.f <<= 1;
 1515|      0|    --value.e;
 1516|      0|  }
 1517|       |  // Subtract 1 to account for hidden bit.
 1518|   111k|  const auto offset = basic_fp<F>::num_significand_bits -
 1519|   111k|                      num_significand_bits<double>() - SHIFT - 1;
 1520|   111k|  value.f <<= offset;
 1521|   111k|  value.e -= offset;
 1522|   111k|  return value;
 1523|   111k|}
_ZN3fmt2v96detail8basic_fpIyEC2IdEET_:
 1470|   111k|  template <typename Float> FMT_CONSTEXPR basic_fp(Float n) { assign(n); }
_ZN3fmt2v96detail8basic_fpIyE6assignIdLi0EEEbT_:
 1474|   111k|  FMT_CONSTEXPR auto assign(Float n) -> bool {
 1475|   111k|    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
 1476|       |    // Assume Float is in the format [sign][exponent][significand].
 1477|   111k|    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1478|   111k|    const auto num_float_significand_bits =
 1479|   111k|        detail::num_significand_bits<Float>();
 1480|   111k|    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
 1481|   111k|    const auto significand_mask = implicit_bit - 1;
 1482|   111k|    auto u = bit_cast<carrier_uint>(n);
 1483|   111k|    f = static_cast<F>(u & significand_mask);
 1484|   111k|    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
 1485|   111k|                                     num_float_significand_bits);
 1486|       |    // The predecessor is closer if n is a normalized power of 2 (f == 0)
 1487|       |    // other than the smallest normalized number (biased_e > 1).
 1488|   111k|    auto is_predecessor_closer = f == 0 && biased_e > 1;
  ------------------
  |  Branch (1488:34): [True: 22.1k, False: 89.1k]
  |  Branch (1488:44): [True: 22.1k, False: 0]
  ------------------
 1489|   111k|    if (biased_e == 0)
  ------------------
  |  Branch (1489:9): [True: 0, False: 111k]
  ------------------
 1490|      0|      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
 1491|   111k|    else if (has_implicit_bit<Float>())
  ------------------
  |  Branch (1491:14): [Folded - Ignored]
  ------------------
 1492|   111k|      f += static_cast<F>(implicit_bit);
 1493|   111k|    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
 1494|   111k|    if (!has_implicit_bit<Float>()) ++e;
  ------------------
  |  Branch (1494:9): [Folded - Ignored]
  ------------------
 1495|   111k|    return is_predecessor_closer;
 1496|   111k|  }
_ZN3fmt2v96detail16get_cached_powerEiRi:
 1618|   111k|                                         int& pow10_exponent) {
 1619|   111k|  const int shift = 32;
 1620|       |  // log10(2) = 0x0.4d104d427de7fbcc...
 1621|   111k|  const int64_t significand = 0x4d104d427de7fbcc;
 1622|   111k|  int index = static_cast<int>(
 1623|   111k|      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +
 1624|   111k|       ((int64_t(1) << shift) - 1))  // ceil
 1625|   111k|      >> 32                          // arithmetic shift
 1626|   111k|  );
 1627|       |  // Decimal exponent of the first (smallest) cached power of 10.
 1628|   111k|  const int first_dec_exp = -348;
 1629|       |  // Difference between 2 consecutive decimal exponents in cached powers of 10.
 1630|   111k|  const int dec_exp_step = 8;
 1631|   111k|  index = (index - first_dec_exp - 1) / dec_exp_step + 1;
 1632|   111k|  pow10_exponent = first_dec_exp + index * dec_exp_step;
 1633|       |  // Using *(x + index) instead of x[index] avoids an issue with some compilers
 1634|       |  // using the EDG frontend (e.g. nvhpc/22.3 in C++17 mode).
 1635|   111k|  return {*(data::pow10_significands + index),
 1636|   111k|          *(data::pow10_exponents + index)};
 1637|   111k|}
_ZN3fmt2v96detail8basic_fpIyEC2Emi:
 1467|   333k|  constexpr basic_fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
_ZN3fmt2v96detailmlENS1_8basic_fpIyEES3_:
 1543|   111k|FMT_CONSTEXPR inline fp operator*(fp x, fp y) {
 1544|   111k|  return {multiply(x.f, y.f), x.e + y.e + 64};
 1545|   111k|}
_ZN3fmt2v96detail8multiplyEmm:
 1526|   111k|FMT_CONSTEXPR inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
 1527|   111k|#if FMT_USE_INT128
 1528|   111k|  auto product = static_cast<__uint128_t>(lhs) * rhs;
 1529|   111k|  auto f = static_cast<uint64_t>(product >> 64);
 1530|   111k|  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
  ------------------
  |  Branch (1530:10): [True: 46.7k, False: 64.6k]
  ------------------
 1531|       |#else
 1532|       |  // Multiply 32-bit parts of significands.
 1533|       |  uint64_t mask = (1ULL << 32) - 1;
 1534|       |  uint64_t a = lhs >> 32, b = lhs & mask;
 1535|       |  uint64_t c = rhs >> 32, d = rhs & mask;
 1536|       |  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
 1537|       |  // Compute mid 64-bit of result and round.
 1538|       |  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
 1539|       |  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
 1540|       |#endif
 1541|   111k|}
_ZN3fmt2v96detail16grisu_gen_digitsENS1_8basic_fpIyEEmRiRNS1_18gen_digits_handlerE:
 2655|   111k|    -> digits::result {
 2656|   111k|  const fp one(1ULL << -value.e, value.e);
 2657|       |  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
 2658|       |  // zero because it contains a product of two 64-bit numbers with MSB set (due
 2659|       |  // to normalization) - 1, shifted right by at most 60 bits.
 2660|   111k|  auto integral = static_cast<uint32_t>(value.f >> -one.e);
 2661|   111k|  FMT_ASSERT(integral != 0, "");
  ------------------
  |  |  365|   111k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2662|   111k|  FMT_ASSERT(integral == value.f >> -one.e, "");
  ------------------
  |  |  365|   111k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2663|       |  // The fractional part of scaled value (p2 in Grisu) c = value % one.
 2664|   111k|  uint64_t fractional = value.f & (one.f - 1);
 2665|   111k|  exp = count_digits(integral);  // kappa in Grisu.
 2666|       |  // Non-fixed formats require at least one digit and no precision adjustment.
 2667|   111k|  if (handler.fixed) {
  ------------------
  |  Branch (2667:7): [True: 111k, False: 0]
  ------------------
 2668|   111k|    adjust_precision(handler.precision, exp + handler.exp10);
 2669|       |    // Check if precision is satisfied just by leading zeros, e.g.
 2670|       |    // format("{:.2f}", 0.001) gives "0.00" without generating any digits.
 2671|   111k|    if (handler.precision <= 0) {
  ------------------
  |  Branch (2671:9): [True: 44.7k, False: 66.5k]
  ------------------
 2672|  44.7k|      if (handler.precision < 0) return digits::done;
  ------------------
  |  Branch (2672:11): [True: 44.6k, False: 66]
  ------------------
 2673|       |      // Divide by 10 to prevent overflow.
 2674|     66|      uint64_t divisor = data::power_of_10_64[exp - 1] << -one.e;
 2675|     66|      auto dir = get_round_direction(divisor, value.f / 10, error * 10);
 2676|     66|      if (dir == round_direction::unknown) return digits::error;
  ------------------
  |  Branch (2676:11): [True: 0, False: 66]
  ------------------
 2677|     66|      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';
  ------------------
  |  Branch (2677:37): [True: 54, False: 12]
  ------------------
 2678|     66|      return digits::done;
 2679|     66|    }
 2680|   111k|  }
 2681|       |  // Generate digits for the integral part. This can produce up to 10 digits.
 2682|   392k|  do {
 2683|   392k|    uint32_t digit = 0;
 2684|   392k|    auto divmod_integral = [&](uint32_t divisor) {
 2685|   392k|      digit = integral / divisor;
 2686|   392k|      integral %= divisor;
 2687|   392k|    };
 2688|       |    // This optimization by Milo Yip reduces the number of integer divisions by
 2689|       |    // one per iteration.
 2690|   392k|    switch (exp) {
 2691|      0|    case 10:
  ------------------
  |  Branch (2691:5): [True: 0, False: 392k]
  ------------------
 2692|      0|      divmod_integral(1000000000);
 2693|      0|      break;
 2694|  16.1k|    case 9:
  ------------------
  |  Branch (2694:5): [True: 16.1k, False: 376k]
  ------------------
 2695|  16.1k|      divmod_integral(100000000);
 2696|  16.1k|      break;
 2697|  22.0k|    case 8:
  ------------------
  |  Branch (2697:5): [True: 22.0k, False: 370k]
  ------------------
 2698|  22.0k|      divmod_integral(10000000);
 2699|  22.0k|      break;
 2700|  32.4k|    case 7:
  ------------------
  |  Branch (2700:5): [True: 32.4k, False: 359k]
  ------------------
 2701|  32.4k|      divmod_integral(1000000);
 2702|  32.4k|      break;
 2703|  37.9k|    case 6:
  ------------------
  |  Branch (2703:5): [True: 37.9k, False: 354k]
  ------------------
 2704|  37.9k|      divmod_integral(100000);
 2705|  37.9k|      break;
 2706|  48.7k|    case 5:
  ------------------
  |  Branch (2706:5): [True: 48.7k, False: 343k]
  ------------------
 2707|  48.7k|      divmod_integral(10000);
 2708|  48.7k|      break;
 2709|  49.3k|    case 4:
  ------------------
  |  Branch (2709:5): [True: 49.3k, False: 343k]
  ------------------
 2710|  49.3k|      divmod_integral(1000);
 2711|  49.3k|      break;
 2712|  61.3k|    case 3:
  ------------------
  |  Branch (2712:5): [True: 61.3k, False: 331k]
  ------------------
 2713|  61.3k|      divmod_integral(100);
 2714|  61.3k|      break;
 2715|  62.1k|    case 2:
  ------------------
  |  Branch (2715:5): [True: 62.1k, False: 330k]
  ------------------
 2716|  62.1k|      divmod_integral(10);
 2717|  62.1k|      break;
 2718|  62.3k|    case 1:
  ------------------
  |  Branch (2718:5): [True: 62.3k, False: 330k]
  ------------------
 2719|  62.3k|      digit = integral;
 2720|  62.3k|      integral = 0;
 2721|  62.3k|      break;
 2722|      0|    default:
  ------------------
  |  Branch (2722:5): [True: 0, False: 392k]
  ------------------
 2723|      0|      FMT_ASSERT(false, "invalid number of digits");
  ------------------
  |  |  365|      0|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2724|   392k|    }
 2725|   392k|    --exp;
 2726|   392k|    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
 2727|   392k|    auto result = handler.on_digit(static_cast<char>('0' + digit),
 2728|   392k|                                   data::power_of_10_64[exp] << -one.e,
 2729|   392k|                                   remainder, error, true);
 2730|   392k|    if (result != digits::more) return result;
  ------------------
  |  Branch (2730:9): [True: 4.24k, False: 388k]
  ------------------
 2731|   392k|  } while (exp > 0);
  ------------------
  |  Branch (2731:12): [True: 325k, False: 62.3k]
  ------------------
 2732|       |  // Generate digits for the fractional part.
 2733|   621k|  for (;;) {
 2734|   621k|    fractional *= 10;
 2735|   621k|    error *= 10;
 2736|   621k|    char digit = static_cast<char>('0' + (fractional >> -one.e));
 2737|   621k|    fractional &= one.f - 1;
 2738|   621k|    --exp;
 2739|   621k|    auto result = handler.on_digit(digit, one.f, fractional, error, false);
 2740|   621k|    if (result != digits::more) return result;
  ------------------
  |  Branch (2740:9): [True: 62.3k, False: 558k]
  ------------------
 2741|   621k|  }
 2742|  62.3k|}
_ZN3fmt2v96detail19get_round_directionEmmm:
 2577|  11.4k|                                                         uint64_t error) {
 2578|  11.4k|  FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
  ------------------
  |  |  365|  11.4k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2579|  11.4k|  FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
  ------------------
  |  |  365|  11.4k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2580|  11.4k|  FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
  ------------------
  |  |  365|  11.4k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2581|       |  // Round down if (remainder + error) * 2 <= divisor.
 2582|  11.4k|  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
  ------------------
  |  Branch (2582:7): [True: 7.27k, False: 4.13k]
  |  Branch (2582:43): [True: 6.14k, False: 1.12k]
  ------------------
 2583|  6.14k|    return round_direction::down;
 2584|       |  // Round up if (remainder - error) * 2 >= divisor.
 2585|  5.26k|  if (remainder >= error &&
  ------------------
  |  Branch (2585:7): [True: 5.26k, False: 0]
  ------------------
 2586|  5.26k|      remainder - error >= divisor - (remainder - error)) {
  ------------------
  |  Branch (2586:7): [True: 4.12k, False: 1.13k]
  ------------------
 2587|  4.12k|    return round_direction::up;
 2588|  4.12k|  }
 2589|  1.13k|  return round_direction::unknown;
 2590|  5.26k|}
_ZZN3fmt2v96detail16grisu_gen_digitsENS1_8basic_fpIyEEmRiRNS1_18gen_digits_handlerEENKUljE_clEj:
 2684|   330k|    auto divmod_integral = [&](uint32_t divisor) {
 2685|   330k|      digit = integral / divisor;
 2686|   330k|      integral %= divisor;
 2687|   330k|    };
_ZN3fmt2v96detail18gen_digits_handler8on_digitEcmmmb:
 2609|  1.01M|                                        bool integral) {
 2610|  1.01M|    FMT_ASSERT(remainder < divisor, "");
  ------------------
  |  |  365|  1.01M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2611|  1.01M|    buf[size++] = digit;
 2612|  1.01M|    if (!integral && error >= remainder) return digits::error;
  ------------------
  |  Branch (2612:9): [True: 621k, False: 392k]
  |  Branch (2612:22): [True: 55.2k, False: 565k]
  ------------------
 2613|   958k|    if (size < precision) return digits::more;
  ------------------
  |  Branch (2613:9): [True: 947k, False: 11.3k]
  ------------------
 2614|  11.3k|    if (!integral) {
  ------------------
  |  Branch (2614:9): [True: 7.10k, False: 4.24k]
  ------------------
 2615|       |      // Check if error * 2 < divisor with overflow prevention.
 2616|       |      // The check is not needed for the integral part because error = 1
 2617|       |      // and divisor > (1 << 32) there.
 2618|  7.10k|      if (error >= divisor || error >= divisor - error) return digits::error;
  ------------------
  |  Branch (2618:11): [True: 0, False: 7.10k]
  |  Branch (2618:31): [True: 5, False: 7.10k]
  ------------------
 2619|  7.10k|    } else {
 2620|  4.24k|      FMT_ASSERT(error == 1 && divisor > 2, "");
  ------------------
  |  |  365|  8.48k|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (365:37): [True: 4.24k, False: 0]
  |  |  |  Branch (365:37): [True: 4.24k, False: 0]
  |  |  ------------------
  ------------------
 2621|  4.24k|    }
 2622|  11.3k|    auto dir = get_round_direction(divisor, remainder, error);
 2623|  11.3k|    if (dir != round_direction::up)
  ------------------
  |  Branch (2623:9): [True: 7.27k, False: 4.07k]
  ------------------
 2624|  7.27k|      return dir == round_direction::down ? digits::done : digits::error;
  ------------------
  |  Branch (2624:14): [True: 6.13k, False: 1.13k]
  ------------------
 2625|  4.07k|    ++buf[size - 1];
 2626|  18.4k|    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
  ------------------
  |  Branch (2626:28): [True: 18.4k, False: 74]
  |  Branch (2626:37): [True: 14.4k, False: 3.99k]
  ------------------
 2627|  14.4k|      buf[i] = '0';
 2628|  14.4k|      ++buf[i - 1];
 2629|  14.4k|    }
 2630|  4.07k|    if (buf[0] > '9') {
  ------------------
  |  Branch (2630:9): [True: 7, False: 4.06k]
  ------------------
 2631|      7|      buf[0] = '1';
 2632|      7|      if (fixed)
  ------------------
  |  Branch (2632:11): [True: 7, False: 0]
  ------------------
 2633|      7|        buf[size++] = '0';
 2634|      0|      else
 2635|      0|        ++exp10;
 2636|      7|    }
 2637|  4.07k|    return digits::done;
 2638|  11.3k|  }
_ZN3fmt2v96detail13arg_formatterIcEclIPKcEENS0_8appenderET_:
 3520|   118k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3521|   118k|    return detail::write(out, value, specs, locale);
 3522|   118k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_PKT_RKNS0_18basic_format_specsIS5_EENS1_10locale_refE:
 2245|   118k|    -> OutputIt {
 2246|   118k|  return check_cstring_type_spec(specs.type)
  ------------------
  |  Branch (2246:10): [True: 118k, False: 0]
  ------------------
 2247|   118k|             ? write(out, basic_string_view<Char>(s), specs, {})
 2248|   118k|             : write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
 2249|   118k|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewINS0_13type_identityIT_E4typeEEERKNS0_18basic_format_specsIS7_EENS1_10locale_refE:
 2238|   251k|    -> OutputIt {
 2239|   251k|  check_string_type_spec(specs.type);
 2240|   251k|  return write(out, s, specs);
 2241|   251k|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_18basic_format_specsIS6_EE:
 2215|   251k|                         const basic_format_specs<Char>& specs) -> OutputIt {
 2216|   251k|  auto data = s.data();
 2217|   251k|  auto size = s.size();
 2218|   251k|  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
  ------------------
  |  Branch (2218:7): [True: 0, False: 251k]
  |  Branch (2218:31): [True: 0, False: 0]
  ------------------
 2219|      0|    size = code_point_index(s, to_unsigned(specs.precision));
 2220|   251k|  bool is_debug = specs.type == presentation_type::debug;
 2221|   251k|  size_t width = 0;
 2222|   251k|  if (specs.width != 0) {
  ------------------
  |  Branch (2222:7): [True: 0, False: 251k]
  ------------------
 2223|      0|    if (is_debug)
  ------------------
  |  Branch (2223:9): [True: 0, False: 0]
  ------------------
 2224|      0|      width = write_escaped_string(counting_iterator{}, s).count();
 2225|      0|    else
 2226|      0|      width = compute_width(basic_string_view<Char>(data, size));
 2227|      0|  }
 2228|   251k|  return write_padded(out, specs, size, width,
 2229|   251k|                      [=](reserve_iterator<OutputIt> it) {
 2230|   251k|                        if (is_debug) return write_escaped_string(it, s);
 2231|   251k|                        return copy_str<Char>(data, data + size, it);
 2232|   251k|                      });
 2233|   251k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcZNS1_5writeIcS5_EET0_S7_NS0_17basic_string_viewIT_EERKNS0_18basic_format_specsIS9_EEEUlS5_E_EES7_S7_RKNSB_IT1_EEmmOT2_:
 1669|   251k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1670|   251k|  static_assert(align == align::left || align == align::right, "");
 1671|   251k|  unsigned spec_width = to_unsigned(specs.width);
 1672|   251k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1672:20): [True: 0, False: 251k]
  ------------------
 1673|       |  // Shifts are encoded as string literals because static constexpr is not
 1674|       |  // supported in constexpr functions.
 1675|   251k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1675:18): [Folded - Ignored]
  ------------------
 1676|   251k|  size_t left_padding = padding >> shifts[specs.align];
 1677|   251k|  size_t right_padding = padding - left_padding;
 1678|   251k|  auto it = reserve(out, size + padding * specs.fill.size());
 1679|   251k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1679:7): [True: 0, False: 251k]
  ------------------
 1680|   251k|  it = f(it);
 1681|   251k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1681:7): [True: 0, False: 251k]
  ------------------
 1682|   251k|  return base_iterator(out, it);
 1683|   251k|}
_ZZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_18basic_format_specsIS6_EEENKUlS3_E_clES3_:
 2229|   251k|                      [=](reserve_iterator<OutputIt> it) {
 2230|   251k|                        if (is_debug) return write_escaped_string(it, s);
  ------------------
  |  Branch (2230:29): [True: 0, False: 251k]
  ------------------
 2231|   251k|                        return copy_str<Char>(data, data + size, it);
 2232|   251k|                      });
_ZN3fmt2v96detail13arg_formatterIcEclINS0_17basic_string_viewIcEEEENS0_8appenderET_:
 3520|   133k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3521|   133k|    return detail::write(out, value, specs, locale);
 3522|   133k|  }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS0_17basic_format_argsINS0_20basic_format_contextINSt3__111conditionalIXsr3std7is_sameIS4_cEE5valueENS0_8appenderENSB_20back_insert_iteratorIS5_EEE4typeES4_EEEENS1_10locale_refEEN14format_handlerC2ESD_NS7_IcEENS9_INSA_ISD_cEEEESK_:
 4210|   253k|        : parse_context(str), context(p_out, p_args, p_loc) {}
_ZN3fmt2v99to_stringIcLm500EEENSt3__112basic_stringIT_NS2_11char_traitsIS4_EENS2_9allocatorIS4_EEEERKNS0_19basic_memory_bufferIS4_XT0_ES8_EE:
 4169|  93.2k|    -> std::basic_string<Char> {
 4170|  93.2k|  auto size = buf.size();
 4171|  93.2k|  detail::assume(size < std::basic_string<Char>().max_size());
 4172|  93.2k|  return std::basic_string<Char>(buf.data(), size);
 4173|  93.2k|}
_ZN3fmt2v96detail6assumeEb:
  485|  93.2k|FMT_INLINE void assume(bool condition) {
  486|  93.2k|  (void)condition;
  487|  93.2k|#if FMT_HAS_BUILTIN(__builtin_assume) && !FMT_ICC_VERSION
  488|  93.2k|  __builtin_assume(condition);
  489|  93.2k|#endif
  490|  93.2k|}

_ZN10ImGuiStyleC2Ev:
 1112|      1|{
 1113|      1|    Alpha                   = 1.0f;             // Global alpha applies to everything in Dear ImGui.
 1114|      1|    DisabledAlpha           = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
 1115|      1|    WindowPadding           = ImVec2(8,8);      // Padding within a window
 1116|      1|    WindowRounding          = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
 1117|      1|    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1118|      1|    WindowMinSize           = ImVec2(32,32);    // Minimum window size
 1119|      1|    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
 1120|      1|    WindowMenuButtonPosition= ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
 1121|      1|    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
 1122|      1|    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1123|      1|    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
 1124|      1|    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1125|      1|    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
 1126|      1|    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
 1127|      1|    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
 1128|      1|    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
 1129|      1|    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
 1130|      1|    CellPadding             = ImVec2(4,2);      // Padding within a table cell
 1131|      1|    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
 1132|      1|    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
 1133|      1|    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
 1134|      1|    ScrollbarSize           = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
 1135|      1|    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
 1136|      1|    GrabMinSize             = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar
 1137|      1|    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
 1138|      1|    LogSliderDeadzone       = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
 1139|      1|    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
 1140|      1|    TabBorderSize           = 0.0f;             // Thickness of border around tabs.
 1141|      1|    TabMinWidthForCloseButton = 0.0f;           // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
 1142|      1|    ColorButtonPosition     = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
 1143|      1|    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
 1144|      1|    SelectableTextAlign     = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
 1145|      1|    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
 1146|      1|    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
 1147|      1|    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
 1148|      1|    AntiAliasedLines        = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
 1149|      1|    AntiAliasedLinesUseTex  = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
 1150|      1|    AntiAliasedFill         = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
 1151|      1|    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
 1152|      1|    CircleTessellationMaxError = 0.30f;         // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
 1153|       |
 1154|       |    // Default theme
 1155|      1|    ImGui::StyleColorsDark(this);
 1156|      1|}
_ZN7ImGuiIOC2Ev:
 1188|      1|{
 1189|       |    // Most fields are initialized with zero
 1190|      1|    memset(this, 0, sizeof(*this));
 1191|      1|    IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);
  ------------------
  |  |  236|      1|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
 1192|       |
 1193|       |    // Settings
 1194|      1|    ConfigFlags = ImGuiConfigFlags_None;
 1195|      1|    BackendFlags = ImGuiBackendFlags_None;
 1196|      1|    DisplaySize = ImVec2(-1.0f, -1.0f);
 1197|      1|    DeltaTime = 1.0f / 60.0f;
 1198|      1|    IniSavingRate = 5.0f;
 1199|      1|    IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
 1200|      1|    LogFilename = "imgui_log.txt";
 1201|      1|    MouseDoubleClickTime = 0.30f;
 1202|      1|    MouseDoubleClickMaxDist = 6.0f;
 1203|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1204|       |    for (int i = 0; i < ImGuiKey_COUNT; i++)
 1205|       |        KeyMap[i] = -1;
 1206|       |#endif
 1207|      1|    KeyRepeatDelay = 0.275f;
 1208|      1|    KeyRepeatRate = 0.050f;
 1209|      1|    HoverDelayNormal = 0.30f;
 1210|      1|    HoverDelayShort = 0.10f;
 1211|      1|    UserData = NULL;
 1212|       |
 1213|      1|    Fonts = NULL;
 1214|      1|    FontGlobalScale = 1.0f;
 1215|      1|    FontDefault = NULL;
 1216|      1|    FontAllowUserScaling = false;
 1217|      1|    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
 1218|       |
 1219|       |    // Docking options (when ImGuiConfigFlags_DockingEnable is set)
 1220|      1|    ConfigDockingNoSplit = false;
 1221|      1|    ConfigDockingWithShift = false;
 1222|      1|    ConfigDockingAlwaysTabBar = false;
 1223|      1|    ConfigDockingTransparentPayload = false;
 1224|       |
 1225|       |    // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
 1226|      1|    ConfigViewportsNoAutoMerge = false;
 1227|      1|    ConfigViewportsNoTaskBarIcon = false;
 1228|      1|    ConfigViewportsNoDecoration = true;
 1229|      1|    ConfigViewportsNoDefaultParent = false;
 1230|       |
 1231|       |    // Miscellaneous options
 1232|      1|    MouseDrawCursor = false;
 1233|       |#ifdef __APPLE__
 1234|       |    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
 1235|       |#else
 1236|      1|    ConfigMacOSXBehaviors = false;
 1237|      1|#endif
 1238|      1|    ConfigInputTrickleEventQueue = true;
 1239|      1|    ConfigInputTextCursorBlink = true;
 1240|      1|    ConfigInputTextEnterKeepActive = false;
 1241|      1|    ConfigDragClickToInputText = false;
 1242|      1|    ConfigWindowsResizeFromEdges = true;
 1243|      1|    ConfigWindowsMoveFromTitleBarOnly = false;
 1244|      1|    ConfigMemoryCompactTimer = 60.0f;
 1245|       |
 1246|       |    // Platform Functions
 1247|      1|    BackendPlatformName = BackendRendererName = NULL;
 1248|      1|    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
 1249|      1|    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
 1250|      1|    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
 1251|      1|    ClipboardUserData = NULL;
 1252|      1|    SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;
 1253|       |
 1254|       |    // Input (NB: we already have memset zero the entire structure!)
 1255|      1|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1256|      1|    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
 1257|      1|    MouseDragThreshold = 6.0f;
 1258|      6|    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
  ------------------
  |  |   87|      6|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1258:21): [True: 5, False: 1]
  ------------------
 1259|    141|    for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
  ------------------
  |  |   87|    141|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1259:21): [True: 140, False: 1]
  ------------------
 1260|      1|    AppAcceptingEvents = true;
 1261|      1|    BackendUsingLegacyKeyArrays = (ImS8)-1;
 1262|      1|    BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
 1263|      1|}
_ZN7ImGuiIO17AddInputCharacterEj:
 1270|  1.20k|{
 1271|  1.20k|    ImGuiContext& g = *GImGui;
 1272|  1.20k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  1.20k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1273|  1.20k|    if (c == 0 || !AppAcceptingEvents)
  ------------------
  |  Branch (1273:9): [True: 53, False: 1.15k]
  |  Branch (1273:19): [True: 0, False: 1.15k]
  ------------------
 1274|     53|        return;
 1275|       |
 1276|  1.15k|    ImGuiInputEvent e;
 1277|  1.15k|    e.Type = ImGuiInputEventType_Text;
 1278|  1.15k|    e.Source = ImGuiInputSource_Keyboard;
 1279|  1.15k|    e.Text.Char = c;
 1280|  1.15k|    g.InputEventsQueue.push_back(e);
 1281|  1.15k|}
_ZN7ImGuiIO22AddInputCharacterUTF16Et:
 1286|    788|{
 1287|    788|    if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
  ------------------
  |  Branch (1287:10): [True: 126, False: 662]
  |  Branch (1287:20): [True: 98, False: 28]
  |  Branch (1287:49): [True: 0, False: 690]
  ------------------
 1288|     98|        return;
 1289|       |
 1290|    690|    if ((c & 0xFC00) == 0xD800) // High surrogate, must save
  ------------------
  |  Branch (1290:9): [True: 79, False: 611]
  ------------------
 1291|     79|    {
 1292|     79|        if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1292:13): [True: 35, False: 44]
  ------------------
 1293|     35|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2314|     35|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1294|     79|        InputQueueSurrogate = c;
 1295|     79|        return;
 1296|     79|    }
 1297|       |
 1298|    611|    ImWchar cp = c;
 1299|    611|    if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1299:9): [True: 31, False: 580]
  ------------------
 1300|     31|    {
 1301|     31|        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
  ------------------
  |  Branch (1301:13): [True: 30, False: 1]
  ------------------
 1302|     30|        {
 1303|     30|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2314|     30|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1304|     30|        }
 1305|      1|        else
 1306|      1|        {
 1307|      1|#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF
 1308|      1|            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
  ------------------
  |  | 2314|      1|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1309|       |#else
 1310|       |            cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
 1311|       |#endif
 1312|      1|        }
 1313|       |
 1314|     31|        InputQueueSurrogate = 0;
 1315|     31|    }
 1316|    611|    AddInputCharacter((unsigned)cp);
 1317|    611|}
_ZN7ImGuiIO20ClearInputCharactersEv:
 1334|  7.25k|{
 1335|  7.25k|    InputQueueCharacters.resize(0);
 1336|  7.25k|}
_ZN7ImGuiIO14ClearInputKeysEv:
 1340|  7.25k|{
 1341|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1342|       |    memset(KeysDown, 0, sizeof(KeysDown));
 1343|       |#endif
 1344|  1.02M|    for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++)
  ------------------
  |  |   87|  1.02M|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1344:21): [True: 1.01M, False: 7.25k]
  ------------------
 1345|  1.01M|    {
 1346|  1.01M|        KeysData[n].Down             = false;
 1347|  1.01M|        KeysData[n].DownDuration     = -1.0f;
 1348|  1.01M|        KeysData[n].DownDurationPrev = -1.0f;
 1349|  1.01M|    }
 1350|  7.25k|    KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
 1351|  7.25k|    KeyMods = ImGuiMod_None;
 1352|  7.25k|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1353|  43.5k|    for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)
  ------------------
  |  |   87|  43.5k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1353:21): [True: 36.2k, False: 7.25k]
  ------------------
 1354|  36.2k|    {
 1355|  36.2k|        MouseDown[n] = false;
 1356|  36.2k|        MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
 1357|  36.2k|    }
 1358|  7.25k|    MouseWheel = MouseWheelH = 0.0f;
 1359|  7.25k|}
_ZN7ImGuiIO17AddKeyAnalogEventE8ImGuiKeybf:
 1383|  3.10k|{
 1384|       |    //if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
 1385|  3.10k|    if (key == ImGuiKey_None || !AppAcceptingEvents)
  ------------------
  |  Branch (1385:9): [True: 0, False: 3.10k]
  |  Branch (1385:33): [True: 0, False: 3.10k]
  ------------------
 1386|      0|        return;
 1387|  3.10k|    ImGuiContext& g = *GImGui;
 1388|  3.10k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  3.10k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1389|  3.10k|    IM_ASSERT(ImGui::IsNamedKeyOrModKey(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
  ------------------
  |  |   23|  3.10k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1390|  3.10k|    IM_ASSERT(!ImGui::IsAliasKey(key)); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.
  ------------------
  |  |   23|  3.10k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1391|  3.10k|    IM_ASSERT(key != ImGuiMod_Shortcut); // We could easily support the translation here but it seems saner to not accept it (TestEngine perform a translation itself)
  ------------------
  |  |   23|  3.10k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1392|       |
 1393|       |    // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
 1394|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1395|       |    IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1396|       |    if (BackendUsingLegacyKeyArrays == -1)
 1397|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 1398|       |            IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1399|       |    BackendUsingLegacyKeyArrays = 0;
 1400|       |#endif
 1401|  3.10k|    if (ImGui::IsGamepadKey(key))
  ------------------
  |  Branch (1401:9): [True: 23, False: 3.08k]
  ------------------
 1402|     23|        BackendUsingLegacyNavInputArray = false;
 1403|       |
 1404|       |    // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
 1405|  3.10k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_Key, (int)key);
 1406|  3.10k|    const ImGuiKeyData* key_data = ImGui::GetKeyData(key);
 1407|  3.10k|    const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
  ------------------
  |  Branch (1407:34): [True: 255, False: 2.84k]
  ------------------
 1408|  3.10k|    const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
  ------------------
  |  Branch (1408:37): [True: 255, False: 2.84k]
  ------------------
 1409|  3.10k|    if (latest_key_down == down && latest_key_analog == analog_value)
  ------------------
  |  Branch (1409:9): [True: 636, False: 2.46k]
  |  Branch (1409:36): [True: 492, False: 144]
  ------------------
 1410|    492|        return;
 1411|       |
 1412|       |    // Add event
 1413|  2.61k|    ImGuiInputEvent e;
 1414|  2.61k|    e.Type = ImGuiInputEventType_Key;
 1415|  2.61k|    e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
  ------------------
  |  Branch (1415:16): [True: 23, False: 2.58k]
  ------------------
 1416|  2.61k|    e.Key.Key = key;
 1417|  2.61k|    e.Key.Down = down;
 1418|  2.61k|    e.Key.AnalogValue = analog_value;
 1419|  2.61k|    g.InputEventsQueue.push_back(e);
 1420|  2.61k|}
_ZN7ImGuiIO11AddKeyEventE8ImGuiKeyb:
 1423|    178|{
 1424|    178|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1424:9): [True: 0, False: 178]
  ------------------
 1425|      0|        return;
 1426|    178|    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
  ------------------
  |  Branch (1426:34): [True: 178, False: 0]
  ------------------
 1427|    178|}
_ZN7ImGuiIO16AddMousePosEventEff:
 1462|  1.79k|{
 1463|  1.79k|    ImGuiContext& g = *GImGui;
 1464|  1.79k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  1.79k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1465|  1.79k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1465:9): [True: 0, False: 1.79k]
  ------------------
 1466|      0|        return;
 1467|       |
 1468|       |    // Apply same flooring as UpdateMouseInputs()
 1469|  1.79k|    ImVec2 pos((x > -FLT_MAX) ? ImFloorSigned(x) : x, (y > -FLT_MAX) ? ImFloorSigned(y) : y);
  ------------------
  |  Branch (1469:16): [True: 1.71k, False: 78]
  |  Branch (1469:55): [True: 1.66k, False: 129]
  ------------------
 1470|       |
 1471|       |    // Filter duplicate
 1472|  1.79k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_MousePos);
 1473|  1.79k|    const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
  ------------------
  |  Branch (1473:31): [True: 231, False: 1.56k]
  ------------------
 1474|  1.79k|    if (latest_pos.x == pos.x && latest_pos.y == pos.y)
  ------------------
  |  Branch (1474:9): [True: 346, False: 1.44k]
  |  Branch (1474:34): [True: 150, False: 196]
  ------------------
 1475|    150|        return;
 1476|       |
 1477|  1.64k|    ImGuiInputEvent e;
 1478|  1.64k|    e.Type = ImGuiInputEventType_MousePos;
 1479|  1.64k|    e.Source = ImGuiInputSource_Mouse;
 1480|  1.64k|    e.MousePos.PosX = pos.x;
 1481|  1.64k|    e.MousePos.PosY = pos.y;
 1482|  1.64k|    g.InputEventsQueue.push_back(e);
 1483|  1.64k|}
_ZN7ImGuiIO19AddMouseButtonEventEib:
 1486|  2.79k|{
 1487|  2.79k|    ImGuiContext& g = *GImGui;
 1488|  2.79k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  2.79k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1489|  2.79k|    IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  2.79k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1490|  2.79k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1490:9): [True: 0, False: 2.79k]
  ------------------
 1491|      0|        return;
 1492|       |
 1493|       |    // Filter duplicate
 1494|  2.79k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_MouseButton, (int)mouse_button);
 1495|  2.79k|    const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
  ------------------
  |  Branch (1495:37): [True: 395, False: 2.39k]
  ------------------
 1496|  2.79k|    if (latest_button_down == down)
  ------------------
  |  Branch (1496:9): [True: 1.31k, False: 1.47k]
  ------------------
 1497|  1.31k|        return;
 1498|       |
 1499|  1.47k|    ImGuiInputEvent e;
 1500|  1.47k|    e.Type = ImGuiInputEventType_MouseButton;
 1501|  1.47k|    e.Source = ImGuiInputSource_Mouse;
 1502|  1.47k|    e.MouseButton.Button = mouse_button;
 1503|  1.47k|    e.MouseButton.Down = down;
 1504|  1.47k|    g.InputEventsQueue.push_back(e);
 1505|  1.47k|}
_ZN7ImGuiIO18AddMouseWheelEventEff:
 1509|  1.31k|{
 1510|  1.31k|    ImGuiContext& g = *GImGui;
 1511|  1.31k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  1.31k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1512|       |
 1513|       |    // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
 1514|  1.31k|    if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
  ------------------
  |  Branch (1514:9): [True: 0, False: 1.31k]
  |  Branch (1514:33): [True: 72, False: 1.24k]
  |  Branch (1514:52): [True: 11, False: 61]
  ------------------
 1515|     11|        return;
 1516|       |
 1517|  1.30k|    ImGuiInputEvent e;
 1518|  1.30k|    e.Type = ImGuiInputEventType_MouseWheel;
 1519|  1.30k|    e.Source = ImGuiInputSource_Mouse;
 1520|  1.30k|    e.MouseWheel.WheelX = wheel_x;
 1521|  1.30k|    e.MouseWheel.WheelY = wheel_y;
 1522|  1.30k|    g.InputEventsQueue.push_back(e);
 1523|  1.30k|}
_ZN7ImGuiIO13AddFocusEventEb:
 1547|    240|{
 1548|    240|    ImGuiContext& g = *GImGui;
 1549|    240|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|    240|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1550|       |
 1551|       |    // Filter duplicate
 1552|    240|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_Focus);
 1553|    240|    const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
  ------------------
  |  Branch (1553:33): [True: 0, False: 240]
  ------------------
 1554|    240|    if (latest_focused == focused)
  ------------------
  |  Branch (1554:9): [True: 240, False: 0]
  ------------------
 1555|    240|        return;
 1556|       |
 1557|      0|    ImGuiInputEvent e;
 1558|      0|    e.Type = ImGuiInputEventType_Focus;
 1559|      0|    e.AppFocused.Focused = focused;
 1560|      0|    g.InputEventsQueue.push_back(e);
 1561|      0|}
_Z9ImStrncpyPcPKcm:
 1703|     16|{
 1704|     16|    if (count < 1)
  ------------------
  |  Branch (1704:9): [True: 0, False: 16]
  ------------------
 1705|      0|        return;
 1706|     16|    if (count > 1)
  ------------------
  |  Branch (1706:9): [True: 16, False: 0]
  ------------------
 1707|     16|        strncpy(dst, src, count - 1);
 1708|     16|    dst[count - 1] = 0;
 1709|     16|}
_Z8ImStrdupPKc:
 1712|      4|{
 1713|      4|    size_t len = strlen(str);
 1714|      4|    void* buf = IM_ALLOC(len + 1);
  ------------------
  |  | 1860|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 1715|      4|    return (char*)memcpy(buf, (const void*)str, len + 1);
 1716|      4|}
_Z14ImFormatStringPcmPKcz:
 1828|      1|{
 1829|      1|    va_list args;
 1830|      1|    va_start(args, fmt);
 1831|       |#ifdef IMGUI_USE_STB_SPRINTF
 1832|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 1833|       |#else
 1834|      1|    int w = vsnprintf(buf, buf_size, fmt, args);
 1835|      1|#endif
 1836|      1|    va_end(args);
 1837|      1|    if (buf == NULL)
  ------------------
  |  Branch (1837:9): [True: 0, False: 1]
  ------------------
 1838|      0|        return w;
 1839|      1|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (1839:9): [True: 0, False: 1]
  |  Branch (1839:20): [True: 0, False: 1]
  ------------------
 1840|      0|        w = (int)buf_size - 1;
 1841|      1|    buf[w] = 0;
 1842|      1|    return w;
 1843|      1|}
_Z15ImFormatStringVPcmPKcP13__va_list_tag:
 1846|  11.3k|{
 1847|       |#ifdef IMGUI_USE_STB_SPRINTF
 1848|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 1849|       |#else
 1850|  11.3k|    int w = vsnprintf(buf, buf_size, fmt, args);
 1851|  11.3k|#endif
 1852|  11.3k|    if (buf == NULL)
  ------------------
  |  Branch (1852:9): [True: 0, False: 11.3k]
  ------------------
 1853|      0|        return w;
 1854|  11.3k|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (1854:9): [True: 0, False: 11.3k]
  |  Branch (1854:20): [True: 0, False: 11.3k]
  ------------------
 1855|      0|        w = (int)buf_size - 1;
 1856|  11.3k|    buf[w] = 0;
 1857|  11.3k|    return w;
 1858|  11.3k|}
_Z26ImFormatStringToTempBufferPPKcS1_S0_z:
 1862|  11.3k|{
 1863|  11.3k|    ImGuiContext& g = *GImGui;
 1864|  11.3k|    va_list args;
 1865|  11.3k|    va_start(args, fmt);
 1866|  11.3k|    int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
 1867|  11.3k|    *out_buf = g.TempBuffer.Data;
 1868|  11.3k|    if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }
  ------------------
  |  Branch (1868:9): [True: 0, False: 11.3k]
  ------------------
 1869|  11.3k|    va_end(args);
 1870|  11.3k|}
_Z10ImHashDataPKvmj:
 1907|  11.3k|{
 1908|  11.3k|    ImU32 crc = ~seed;
 1909|  11.3k|    const unsigned char* data = (const unsigned char*)data_p;
 1910|  11.3k|    const ImU32* crc32_lut = GCrc32LookupTable;
 1911|  56.9k|    while (data_size-- != 0)
  ------------------
  |  Branch (1911:12): [True: 45.5k, False: 11.3k]
  ------------------
 1912|  45.5k|        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
 1913|  11.3k|    return ~crc;
 1914|  11.3k|}
_Z9ImHashStrPKcmj:
 1923|   303k|{
 1924|   303k|    seed = ~seed;
 1925|   303k|    ImU32 crc = seed;
 1926|   303k|    const unsigned char* data = (const unsigned char*)data_p;
 1927|   303k|    const ImU32* crc32_lut = GCrc32LookupTable;
 1928|   303k|    if (data_size != 0)
  ------------------
  |  Branch (1928:9): [True: 0, False: 303k]
  ------------------
 1929|      0|    {
 1930|      0|        while (data_size-- != 0)
  ------------------
  |  Branch (1930:16): [True: 0, False: 0]
  ------------------
 1931|      0|        {
 1932|      0|            unsigned char c = *data++;
 1933|      0|            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (1933:17): [True: 0, False: 0]
  |  Branch (1933:29): [True: 0, False: 0]
  |  Branch (1933:47): [True: 0, False: 0]
  |  Branch (1933:65): [True: 0, False: 0]
  ------------------
 1934|      0|                crc = seed;
 1935|      0|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 1936|      0|        }
 1937|      0|    }
 1938|   303k|    else
 1939|   303k|    {
 1940|  3.78M|        while (unsigned char c = *data++)
  ------------------
  |  Branch (1940:30): [True: 3.48M, False: 303k]
  ------------------
 1941|  3.48M|        {
 1942|  3.48M|            if (c == '#' && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (1942:17): [True: 291k, False: 3.19M]
  |  Branch (1942:29): [True: 75.9k, False: 215k]
  |  Branch (1942:47): [True: 10.2k, False: 65.7k]
  ------------------
 1943|  10.2k|                crc = seed;
 1944|  3.48M|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 1945|  3.48M|        }
 1946|   303k|    }
 1947|   303k|    return ~crc;
 1948|   303k|}
_Z18ImTextCharFromUtf8PjPKcS1_:
 2031|  12.5k|{
 2032|  12.5k|    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
 2033|  12.5k|    static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
 2034|  12.5k|    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
 2035|  12.5k|    static const int shiftc[] = { 0, 18, 12, 6, 0 };
 2036|  12.5k|    static const int shifte[] = { 0, 6, 4, 2, 0 };
 2037|  12.5k|    int len = lengths[*(const unsigned char*)in_text >> 3];
 2038|  12.5k|    int wanted = len + !len;
 2039|       |
 2040|  12.5k|    if (in_text_end == NULL)
  ------------------
  |  Branch (2040:9): [True: 0, False: 12.5k]
  ------------------
 2041|      0|        in_text_end = in_text + wanted; // Max length, nulls will be taken into account.
 2042|       |
 2043|       |    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
 2044|       |    // so it is fast even with excessive branching.
 2045|  12.5k|    unsigned char s[4];
 2046|  12.5k|    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
  ------------------
  |  Branch (2046:12): [True: 12.5k, False: 0]
  ------------------
 2047|  12.5k|    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
  ------------------
  |  Branch (2047:12): [True: 12.5k, False: 0]
  ------------------
 2048|  12.5k|    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
  ------------------
  |  Branch (2048:12): [True: 7.64k, False: 4.93k]
  ------------------
 2049|  12.5k|    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;
  ------------------
  |  Branch (2049:12): [True: 1.72k, False: 10.8k]
  ------------------
 2050|       |
 2051|       |    // Assume a four-byte character and load four bytes. Unused bits are shifted out.
 2052|  12.5k|    *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
 2053|  12.5k|    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
 2054|  12.5k|    *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
 2055|  12.5k|    *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
 2056|  12.5k|    *out_char >>= shiftc[len];
 2057|       |
 2058|       |    // Accumulate the various error conditions.
 2059|  12.5k|    int e = 0;
 2060|  12.5k|    e  = (*out_char < mins[len]) << 6; // non-canonical encoding
 2061|  12.5k|    e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
 2062|  12.5k|    e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
  ------------------
  |  | 2318|  12.5k|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
 2063|  12.5k|    e |= (s[1] & 0xc0) >> 2;
 2064|  12.5k|    e |= (s[2] & 0xc0) >> 4;
 2065|  12.5k|    e |= (s[3]       ) >> 6;
 2066|  12.5k|    e ^= 0x2a; // top two bits of each tail byte correct?
 2067|  12.5k|    e >>= shifte[len];
 2068|       |
 2069|  12.5k|    if (e)
  ------------------
  |  Branch (2069:9): [True: 1.47k, False: 11.1k]
  ------------------
 2070|  1.47k|    {
 2071|       |        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
 2072|       |        // One byte is consumed in case of invalid first byte of in_text.
 2073|       |        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
 2074|       |        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
 2075|  1.47k|        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
 2076|  1.47k|        *out_char = IM_UNICODE_CODEPOINT_INVALID;
  ------------------
  |  | 2314|  1.47k|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 2077|  1.47k|    }
 2078|       |
 2079|  12.5k|    return wanted;
 2080|  12.5k|}
_ZN5ImGui23ColorConvertU32ToFloat4Ej:
 2218|   157k|{
 2219|   157k|    float s = 1.0f / 255.0f;
 2220|   157k|    return ImVec4(
 2221|   157k|        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2483|   157k|#define IM_COL32_R_SHIFT    0
  ------------------
 2222|   157k|        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2484|   157k|#define IM_COL32_G_SHIFT    8
  ------------------
 2223|   157k|        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2485|   157k|#define IM_COL32_B_SHIFT    16
  ------------------
 2224|   157k|        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
  ------------------
  |  | 2486|   157k|#define IM_COL32_A_SHIFT    24
  ------------------
 2225|   157k|}
_ZN5ImGui23ColorConvertFloat4ToU32ERK6ImVec4:
 2228|   885k|{
 2229|   885k|    ImU32 out;
 2230|   885k|    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  |  265|   885k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  | 2483|   885k|#define IM_COL32_R_SHIFT    0
  ------------------
 2231|   885k|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  |  265|   885k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  | 2484|   885k|#define IM_COL32_G_SHIFT    8
  ------------------
 2232|   885k|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  |  265|   885k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  | 2485|   885k|#define IM_COL32_B_SHIFT    16
  ------------------
 2233|   885k|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  |  265|   885k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  | 2486|   885k|#define IM_COL32_A_SHIFT    24
  ------------------
 2234|   885k|    return out;
 2235|   885k|}
_ZNK12ImGuiStorage10GetVoidPtrEj:
 2354|   132k|{
 2355|   132k|    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
 2356|   132k|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2356:9): [True: 1, False: 132k]
  |  Branch (2356:29): [True: 4, False: 132k]
  ------------------
 2357|      5|        return NULL;
 2358|   132k|    return it->val_p;
 2359|   132k|}
_ZN12ImGuiStorage10SetVoidPtrEjPv:
 2420|      4|{
 2421|      4|    ImGuiStoragePair* it = LowerBound(Data, key);
 2422|      4|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2422:9): [True: 1, False: 3]
  |  Branch (2422:29): [True: 3, False: 0]
  ------------------
 2423|      4|    {
 2424|      4|        Data.insert(it, ImGuiStoragePair(key, val));
 2425|      4|        return;
 2426|      4|    }
 2427|      0|    it->val_p = val;
 2428|      0|}
_ZN5ImGui8GetStyleEv:
 2957|   101k|{
 2958|   101k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|   101k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2959|   101k|    return GImGui->Style;
 2960|   101k|}
_ZN5ImGui11GetColorU32Eif:
 2963|   783k|{
 2964|   783k|    ImGuiStyle& style = GImGui->Style;
 2965|   783k|    ImVec4 c = style.Colors[idx];
 2966|   783k|    c.w *= style.Alpha * alpha_mul;
 2967|   783k|    return ColorConvertFloat4ToU32(c);
 2968|   783k|}
_ZN5ImGui14PushStyleColorEiRK6ImVec4:
 3006|  55.4k|{
 3007|  55.4k|    ImGuiContext& g = *GImGui;
 3008|  55.4k|    ImGuiColorMod backup;
 3009|  55.4k|    backup.Col = idx;
 3010|  55.4k|    backup.BackupValue = g.Style.Colors[idx];
 3011|  55.4k|    g.ColorStack.push_back(backup);
 3012|  55.4k|    g.Style.Colors[idx] = col;
 3013|  55.4k|}
_ZN5ImGui13PopStyleColorEi:
 3016|  55.4k|{
 3017|  55.4k|    ImGuiContext& g = *GImGui;
 3018|  55.4k|    if (g.ColorStack.Size < count)
  ------------------
  |  Branch (3018:9): [True: 0, False: 55.4k]
  ------------------
 3019|      0|    {
 3020|      0|        IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
  ------------------
  |  |  250|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3021|      0|        count = g.ColorStack.Size;
 3022|      0|    }
 3023|   110k|    while (count > 0)
  ------------------
  |  Branch (3023:12): [True: 55.4k, False: 55.4k]
  ------------------
 3024|  55.4k|    {
 3025|  55.4k|        ImGuiColorMod& backup = g.ColorStack.back();
 3026|  55.4k|        g.Style.Colors[backup.Col] = backup.BackupValue;
 3027|  55.4k|        g.ColorStack.pop_back();
 3028|  55.4k|        count--;
 3029|  55.4k|    }
 3030|  55.4k|}
_ZN5ImGui12PushStyleVarEiRK6ImVec2:
 3096|  65.6k|{
 3097|  65.6k|    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
 3098|  65.6k|    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
  ------------------
  |  Branch (3098:9): [True: 65.6k, False: 0]
  |  Branch (3098:50): [True: 65.6k, False: 0]
  ------------------
 3099|  65.6k|    {
 3100|  65.6k|        ImGuiContext& g = *GImGui;
 3101|  65.6k|        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
 3102|  65.6k|        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
 3103|  65.6k|        *pvar = val;
 3104|  65.6k|        return;
 3105|  65.6k|    }
 3106|      0|    IM_ASSERT(0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3107|      0|}
_ZN5ImGui11PopStyleVarEi:
 3110|  65.6k|{
 3111|  65.6k|    ImGuiContext& g = *GImGui;
 3112|  65.6k|    if (g.StyleVarStack.Size < count)
  ------------------
  |  Branch (3112:9): [True: 0, False: 65.6k]
  ------------------
 3113|      0|    {
 3114|      0|        IM_ASSERT_USER_ERROR(g.StyleVarStack.Size > count, "Calling PopStyleVar() too many times: stack underflow.");
  ------------------
  |  |  250|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3115|      0|        count = g.StyleVarStack.Size;
 3116|      0|    }
 3117|   131k|    while (count > 0)
  ------------------
  |  Branch (3117:12): [True: 65.6k, False: 65.6k]
  ------------------
 3118|  65.6k|    {
 3119|       |        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
 3120|  65.6k|        ImGuiStyleMod& backup = g.StyleVarStack.back();
 3121|  65.6k|        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
 3122|  65.6k|        void* data = info->GetVarPtr(&g.Style);
 3123|  65.6k|        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
  ------------------
  |  Branch (3123:13): [True: 65.6k, False: 0]
  |  Branch (3123:50): [True: 0, False: 65.6k]
  ------------------
 3124|  65.6k|        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
  ------------------
  |  Branch (3124:18): [True: 65.6k, False: 0]
  |  Branch (3124:55): [True: 65.6k, False: 0]
  ------------------
 3125|  65.6k|        g.StyleVarStack.pop_back();
 3126|  65.6k|        count--;
 3127|  65.6k|    }
 3128|  65.6k|}
_ZN5ImGui19FindRenderedTextEndEPKcS1_:
 3204|   252k|{
 3205|   252k|    const char* text_display_end = text;
 3206|   252k|    if (!text_end)
  ------------------
  |  Branch (3206:9): [True: 252k, False: 0]
  ------------------
 3207|   252k|        text_end = (const char*)-1;
 3208|       |
 3209|  2.36M|    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
  ------------------
  |  Branch (3209:12): [True: 2.36M, False: 0]
  |  Branch (3209:43): [True: 2.22M, False: 141k]
  |  Branch (3209:73): [True: 2.11M, False: 110k]
  |  Branch (3209:103): [True: 0, False: 110k]
  ------------------
 3210|  2.11M|        text_display_end++;
 3211|   252k|    return text_display_end;
 3212|   252k|}
_ZN5ImGui19RenderTextClippedExEP10ImDrawListRK6ImVec2S4_PKcS6_PS3_S4_PK6ImRect:
 3261|   121k|{
 3262|       |    // Perform CPU side clipping for single clipped element to avoid using scissor state
 3263|   121k|    ImVec2 pos = pos_min;
 3264|   121k|    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);
  ------------------
  |  Branch (3264:30): [True: 121k, False: 0]
  ------------------
 3265|       |
 3266|   121k|    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
  ------------------
  |  Branch (3266:30): [True: 121k, False: 0]
  ------------------
 3267|   121k|    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
  ------------------
  |  Branch (3267:30): [True: 121k, False: 0]
  ------------------
 3268|   121k|    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
  ------------------
  |  Branch (3268:26): [True: 55.4k, False: 65.6k]
  |  Branch (3268:66): [True: 0, False: 65.6k]
  ------------------
 3269|   121k|    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
  ------------------
  |  Branch (3269:9): [True: 121k, False: 0]
  ------------------
 3270|   121k|        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);
  ------------------
  |  Branch (3270:26): [True: 0, False: 121k]
  |  Branch (3270:51): [True: 0, False: 121k]
  ------------------
 3271|       |
 3272|       |    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
 3273|   121k|    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
  ------------------
  |  Branch (3273:9): [True: 0, False: 121k]
  ------------------
 3274|   121k|    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
  ------------------
  |  Branch (3274:9): [True: 110k, False: 10.2k]
  ------------------
 3275|       |
 3276|       |    // Render
 3277|   121k|    if (need_clipping)
  ------------------
  |  Branch (3277:9): [True: 55.4k, False: 65.6k]
  ------------------
 3278|  55.4k|    {
 3279|  55.4k|        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
 3280|  55.4k|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
 3281|  55.4k|    }
 3282|  65.6k|    else
 3283|  65.6k|    {
 3284|  65.6k|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
 3285|  65.6k|    }
 3286|   121k|}
_ZN5ImGui17RenderTextClippedERK6ImVec2S2_PKcS4_PS1_S2_PK6ImRect:
 3289|   121k|{
 3290|       |    // Hide anything after a '##' string
 3291|   121k|    const char* text_display_end = FindRenderedTextEnd(text, text_end);
 3292|   121k|    const int text_len = (int)(text_display_end - text);
 3293|   121k|    if (text_len == 0)
  ------------------
  |  Branch (3293:9): [True: 0, False: 121k]
  ------------------
 3294|      0|        return;
 3295|       |
 3296|   121k|    ImGuiContext& g = *GImGui;
 3297|   121k|    ImGuiWindow* window = g.CurrentWindow;
 3298|   121k|    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
 3299|   121k|    if (g.LogEnabled)
  ------------------
  |  Branch (3299:9): [True: 0, False: 121k]
  ------------------
 3300|      0|        LogRenderedText(&pos_min, text, text_display_end);
 3301|   121k|}
_ZN5ImGui11RenderFrameE6ImVec2S0_jbf:
 3386|  54.3k|{
 3387|  54.3k|    ImGuiContext& g = *GImGui;
 3388|  54.3k|    ImGuiWindow* window = g.CurrentWindow;
 3389|  54.3k|    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
 3390|  54.3k|    const float border_size = g.Style.FrameBorderSize;
 3391|  54.3k|    if (border && border_size > 0.0f)
  ------------------
  |  Branch (3391:9): [True: 44.0k, False: 10.2k]
  |  Branch (3391:19): [True: 44.0k, False: 0]
  ------------------
 3392|  44.0k|    {
 3393|  44.0k|        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
 3394|  44.0k|        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
 3395|  44.0k|    }
 3396|  54.3k|}
_ZN5ImGui18RenderNavHighlightERK6ImRectji:
 3411|  23.8k|{
 3412|  23.8k|    ImGuiContext& g = *GImGui;
 3413|  23.8k|    if (id != g.NavId)
  ------------------
  |  Branch (3413:9): [True: 19.2k, False: 4.51k]
  ------------------
 3414|  19.2k|        return;
 3415|  4.51k|    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
  ------------------
  |  Branch (3415:9): [True: 566, False: 3.94k]
  |  Branch (3415:34): [True: 566, False: 0]
  ------------------
 3416|    566|        return;
 3417|  3.94k|    ImGuiWindow* window = g.CurrentWindow;
 3418|  3.94k|    if (window->DC.NavHideHighlightOneFrame)
  ------------------
  |  Branch (3418:9): [True: 0, False: 3.94k]
  ------------------
 3419|      0|        return;
 3420|       |
 3421|  3.94k|    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
  ------------------
  |  Branch (3421:22): [True: 0, False: 3.94k]
  ------------------
 3422|  3.94k|    ImRect display_rect = bb;
 3423|  3.94k|    display_rect.ClipWith(window->ClipRect);
 3424|  3.94k|    if (flags & ImGuiNavHighlightFlags_TypeDefault)
  ------------------
  |  Branch (3424:9): [True: 24, False: 3.92k]
  ------------------
 3425|     24|    {
 3426|     24|        const float THICKNESS = 2.0f;
 3427|     24|        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
 3428|     24|        display_rect.Expand(ImVec2(DISTANCE, DISTANCE));
 3429|     24|        bool fully_visible = window->ClipRect.Contains(display_rect);
 3430|     24|        if (!fully_visible)
  ------------------
  |  Branch (3430:13): [True: 20, False: 4]
  ------------------
 3431|     20|            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
 3432|     24|        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, 0, THICKNESS);
 3433|     24|        if (!fully_visible)
  ------------------
  |  Branch (3433:13): [True: 20, False: 4]
  ------------------
 3434|     20|            window->DrawList->PopClipRect();
 3435|     24|    }
 3436|  3.94k|    if (flags & ImGuiNavHighlightFlags_TypeThin)
  ------------------
  |  Branch (3436:9): [True: 3.92k, False: 24]
  ------------------
 3437|  3.92k|    {
 3438|  3.92k|        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, 1.0f);
 3439|  3.92k|    }
 3440|  3.94k|}
_ZN5ImGui17GetCurrentContextEv:
 3476|      1|{
 3477|      1|    return GImGui;
 3478|      1|}
_ZN5ImGui17SetCurrentContextEP12ImGuiContext:
 3481|      1|{
 3482|       |#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
 3483|       |    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
 3484|       |#else
 3485|      1|    GImGui = ctx;
 3486|      1|#endif
 3487|      1|}
_ZN5ImGui13CreateContextEP11ImFontAtlas:
 3505|      1|{
 3506|      1|    ImGuiContext* prev_ctx = GetCurrentContext();
 3507|      1|    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
  ------------------
  |  | 1863|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3508|      1|    SetCurrentContext(ctx);
 3509|      1|    Initialize();
 3510|      1|    if (prev_ctx != NULL)
  ------------------
  |  Branch (3510:9): [True: 0, False: 1]
  ------------------
 3511|      0|        SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
 3512|      1|    return ctx;
 3513|      1|}
_ZN5ImGui10InitializeEv:
 3540|      1|{
 3541|      1|    ImGuiContext& g = *GImGui;
 3542|      1|    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3543|       |
 3544|       |    // Add .ini handle for ImGuiWindow and ImGuiTable types
 3545|      1|    {
 3546|      1|        ImGuiSettingsHandler ini_handler;
 3547|      1|        ini_handler.TypeName = "Window";
 3548|      1|        ini_handler.TypeHash = ImHashStr("Window");
 3549|      1|        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
 3550|      1|        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
 3551|      1|        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
 3552|      1|        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
 3553|      1|        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
 3554|      1|        AddSettingsHandler(&ini_handler);
 3555|      1|    }
 3556|      1|    TableSettingsAddSettingsHandler();
 3557|       |
 3558|       |    // Setup default localization table
 3559|      1|    LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3560|       |
 3561|       |    // Create default viewport
 3562|      1|    ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 1863|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3563|      1|    viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
 3564|      1|    viewport->Idx = 0;
 3565|      1|    viewport->PlatformWindowCreated = true;
 3566|      1|    viewport->Flags = ImGuiViewportFlags_OwnedByApp;
 3567|      1|    g.Viewports.push_back(viewport);
 3568|      1|    g.TempBuffer.resize(1024 * 3 + 1, 0);
 3569|      1|    g.PlatformIO.Viewports.push_back(g.Viewports[0]);
 3570|       |
 3571|      1|#ifdef IMGUI_HAS_DOCK
 3572|       |    // Initialize Docking
 3573|      1|    DockContextInitialize(&g);
 3574|      1|#endif
 3575|       |
 3576|      1|    g.Initialized = true;
 3577|      1|}
_ZN5ImGui16CallContextHooksEP12ImGuiContext20ImGuiContextHookType:
 3686|   332k|{
 3687|   332k|    ImGuiContext& g = *ctx;
 3688|   332k|    for (int n = 0; n < g.Hooks.Size; n++)
  ------------------
  |  Branch (3688:21): [True: 0, False: 332k]
  ------------------
 3689|      0|        if (g.Hooks[n].Type == hook_type)
  ------------------
  |  Branch (3689:13): [True: 0, False: 0]
  ------------------
 3690|      0|            g.Hooks[n].Callback(&g, &g.Hooks[n]);
 3691|   332k|}
_ZN11ImGuiWindowC2EP12ImGuiContextPKc:
 3700|      4|{
 3701|      4|    memset(this, 0, sizeof(*this));
 3702|      4|    Name = ImStrdup(name);
 3703|      4|    NameBufLen = (int)strlen(name) + 1;
 3704|      4|    ID = ImHashStr(name);
 3705|      4|    IDStack.push_back(ID);
 3706|      4|    ViewportAllowPlatformMonitorExtend = -1;
 3707|      4|    ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
 3708|      4|    MoveId = GetID("#MOVE");
 3709|      4|    TabId = GetID("#TAB");
 3710|      4|    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 3711|      4|    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
 3712|      4|    AutoFitFramesX = AutoFitFramesY = -1;
 3713|      4|    AutoPosLastDirection = ImGuiDir_None;
 3714|      4|    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
 3715|      4|    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
 3716|      4|    LastFrameActive = -1;
 3717|      4|    LastFrameJustFocused = -1;
 3718|      4|    LastTimeActive = -1.0f;
 3719|      4|    FontWindowScale = FontDpiScale = 1.0f;
 3720|      4|    SettingsOffset = -1;
 3721|      4|    DockOrder = -1;
 3722|      4|    DrawList = &DrawListInst;
 3723|      4|    DrawList->_Data = &context->DrawListSharedData;
 3724|      4|    DrawList->_OwnerName = Name;
 3725|      4|    IM_PLACEMENT_NEW(&WindowClass) ImGuiWindowClass();
  ------------------
  |  | 1862|      8|#define IM_PLACEMENT_NEW(_PTR)              new(ImNewWrapper(), _PTR)
  ------------------
 3726|      4|}
_ZN11ImGuiWindow5GetIDEPKcS1_:
 3736|   171k|{
 3737|   171k|    ImGuiID seed = IDStack.back();
 3738|   171k|    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
  ------------------
  |  Branch (3738:33): [True: 0, False: 171k]
  ------------------
 3739|   171k|    ImGuiContext& g = *GImGui;
 3740|   171k|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (3740:9): [True: 0, False: 171k]
  ------------------
 3741|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
 3742|   171k|    return id;
 3743|   171k|}
_ZN11ImGuiWindow5GetIDEi:
 3756|  11.3k|{
 3757|  11.3k|    ImGuiID seed = IDStack.back();
 3758|  11.3k|    ImGuiID id = ImHashData(&n, sizeof(n), seed);
 3759|  11.3k|    ImGuiContext& g = *GImGui;
 3760|  11.3k|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (3760:9): [True: 0, False: 11.3k]
  ------------------
 3761|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
 3762|  11.3k|    return id;
 3763|  11.3k|}
_ZN5ImGui31GcCompactTransientWindowBuffersEP11ImGuiWindow:
 3796|      1|{
 3797|      1|    window->MemoryCompacted = true;
 3798|      1|    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
 3799|      1|    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
 3800|      1|    window->IDStack.clear();
 3801|      1|    window->DrawList->_ClearFreeMemory();
 3802|      1|    window->DC.ChildWindows.clear();
 3803|      1|    window->DC.ItemWidthStack.clear();
 3804|      1|    window->DC.TextWrapPosStack.clear();
 3805|      1|}
_ZN5ImGui11SetActiveIDEjP11ImGuiWindow:
 3818|    669|{
 3819|    669|    ImGuiContext& g = *GImGui;
 3820|       |
 3821|       |    // While most behaved code would make an effort to not steal active id during window move/drag operations,
 3822|       |    // we at least need to be resilient to it. Cancelling the move is rather aggressive and users of 'master' branch
 3823|       |    // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
 3824|    669|    if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)
  ------------------
  |  Branch (3824:9): [True: 0, False: 669]
  |  Branch (3824:35): [True: 0, False: 0]
  ------------------
 3825|      0|    {
 3826|      0|        IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
  ------------------
  |  |  226|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (226:50): [True: 0, False: 0]
  |  |  |  Branch (226:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3827|      0|        g.MovingWindow = NULL;
 3828|      0|    }
 3829|       |
 3830|       |    // Set active id
 3831|    669|    g.ActiveIdIsJustActivated = (g.ActiveId != id);
 3832|    669|    if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (3832:9): [True: 145, False: 524]
  ------------------
 3833|    145|    {
 3834|    145|        IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
  ------------------
  |  |  226|    145|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (222:57): [True: 0, False: 0]
  |  |  |  |  |  Branch (222:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (226:50): [True: 0, False: 145]
  |  |  |  Branch (226:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3835|    145|        g.ActiveIdTimer = 0.0f;
 3836|    145|        g.ActiveIdHasBeenPressedBefore = false;
 3837|    145|        g.ActiveIdHasBeenEditedBefore = false;
 3838|    145|        g.ActiveIdMouseButton = -1;
 3839|    145|        if (id != 0)
  ------------------
  |  Branch (3839:13): [True: 76, False: 69]
  ------------------
 3840|     76|        {
 3841|     76|            g.LastActiveId = id;
 3842|     76|            g.LastActiveIdTimer = 0.0f;
 3843|     76|        }
 3844|    145|    }
 3845|    669|    g.ActiveId = id;
 3846|    669|    g.ActiveIdAllowOverlap = false;
 3847|    669|    g.ActiveIdNoClearOnFocusLoss = false;
 3848|    669|    g.ActiveIdWindow = window;
 3849|    669|    g.ActiveIdHasBeenEditedThisFrame = false;
 3850|    669|    if (id)
  ------------------
  |  Branch (3850:9): [True: 76, False: 593]
  ------------------
 3851|     76|    {
 3852|     76|        g.ActiveIdIsAlive = id;
 3853|     76|        g.ActiveIdSource = (g.NavActivateId == id || g.NavActivateInputId == id || g.NavJustMovedToId == id) ? (ImGuiInputSource)ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
  ------------------
  |  Branch (3853:29): [True: 0, False: 76]
  |  Branch (3853:54): [True: 0, False: 76]
  |  Branch (3853:84): [True: 0, False: 76]
  ------------------
 3854|     76|    }
 3855|       |
 3856|       |    // Clear declaration of inputs claimed by the widget
 3857|       |    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
 3858|    669|    g.ActiveIdUsingNavDirMask = 0x00;
 3859|    669|    g.ActiveIdUsingAllKeyboardKeys = false;
 3860|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 3861|       |    g.ActiveIdUsingNavInputMask = 0x00;
 3862|       |#endif
 3863|    669|}
_ZN5ImGui13ClearActiveIDEv:
 3866|    593|{
 3867|    593|    SetActiveID(0, NULL); // g.ActiveId = 0;
 3868|    593|}
_ZN5ImGui12SetHoveredIDEj:
 3871|  1.04k|{
 3872|  1.04k|    ImGuiContext& g = *GImGui;
 3873|  1.04k|    g.HoveredId = id;
 3874|  1.04k|    g.HoveredIdAllowOverlap = false;
 3875|  1.04k|    if (id != 0 && g.HoveredIdPreviousFrame != id)
  ------------------
  |  Branch (3875:9): [True: 1.04k, False: 0]
  |  Branch (3875:20): [True: 112, False: 931]
  ------------------
 3876|    112|        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
 3877|  1.04k|}
_ZN5ImGui11KeepAliveIDEj:
 3888|   150k|{
 3889|   150k|    ImGuiContext& g = *GImGui;
 3890|   150k|    if (g.ActiveId == id)
  ------------------
  |  Branch (3890:9): [True: 280, False: 150k]
  ------------------
 3891|    280|        g.ActiveIdIsAlive = id;
 3892|   150k|    if (g.ActiveIdPreviousFrame == id)
  ------------------
  |  Branch (3892:9): [True: 273, False: 150k]
  ------------------
 3893|    273|        g.ActiveIdPreviousFrameIsAlive = true;
 3894|   150k|}
_ZN5ImGui13ItemHoverableERK6ImRectj:
 4017|   141k|{
 4018|   141k|    ImGuiContext& g = *GImGui;
 4019|   141k|    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
  ------------------
  |  Branch (4019:9): [True: 330, False: 141k]
  |  Branch (4019:29): [True: 330, False: 0]
  |  Branch (4019:50): [True: 330, False: 0]
  ------------------
 4020|    330|        return false;
 4021|       |
 4022|   141k|    ImGuiWindow* window = g.CurrentWindow;
 4023|   141k|    if (g.HoveredWindow != window)
  ------------------
  |  Branch (4023:9): [True: 139k, False: 1.70k]
  ------------------
 4024|   139k|        return false;
 4025|  1.70k|    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (4025:9): [True: 345, False: 1.35k]
  |  Branch (4025:28): [True: 114, False: 231]
  |  Branch (4025:48): [True: 114, False: 0]
  ------------------
 4026|    114|        return false;
 4027|  1.58k|    if (!IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (4027:9): [True: 546, False: 1.04k]
  ------------------
 4028|    546|        return false;
 4029|       |
 4030|       |    // Done with rectangle culling so we can perform heavier checks now.
 4031|  1.04k|    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);
  ------------------
  |  Branch (4031:34): [True: 1.04k, False: 0]
  ------------------
 4032|  1.04k|    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
  ------------------
  |  Branch (4032:9): [True: 1.04k, False: 0]
  |  Branch (4032:66): [True: 0, False: 1.04k]
  ------------------
 4033|      0|    {
 4034|      0|        g.HoveredIdDisabled = true;
 4035|      0|        return false;
 4036|      0|    }
 4037|       |
 4038|       |    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
 4039|       |    // hover test in widgets code. We could also decide to split this function is two.
 4040|  1.04k|    if (id != 0)
  ------------------
  |  Branch (4040:9): [True: 1.04k, False: 0]
  ------------------
 4041|  1.04k|        SetHoveredID(id);
 4042|       |
 4043|       |    // When disabled we'll return false but still set HoveredId
 4044|  1.04k|    if (item_flags & ImGuiItemFlags_Disabled)
  ------------------
  |  Branch (4044:9): [True: 0, False: 1.04k]
  ------------------
 4045|      0|    {
 4046|       |        // Release active id if turning disabled
 4047|      0|        if (g.ActiveId == id)
  ------------------
  |  Branch (4047:13): [True: 0, False: 0]
  ------------------
 4048|      0|            ClearActiveID();
 4049|      0|        g.HoveredIdDisabled = true;
 4050|      0|        return false;
 4051|      0|    }
 4052|       |
 4053|  1.04k|    if (id != 0)
  ------------------
  |  Branch (4053:9): [True: 1.04k, False: 0]
  ------------------
 4054|  1.04k|    {
 4055|       |        // [DEBUG] Item Picker tool!
 4056|       |        // We perform the check here because SetHoveredID() is not frequently called (1~ time a frame), making
 4057|       |        // the cost of this tool near-zero. We can get slightly better call-stack and support picking non-hovered
 4058|       |        // items if we performed the test in ItemAdd(), but that would incur a small runtime cost.
 4059|  1.04k|        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
  ------------------
  |  Branch (4059:13): [True: 0, False: 1.04k]
  |  Branch (4059:40): [True: 0, False: 0]
  ------------------
 4060|      0|            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
  ------------------
  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 4061|  1.04k|        if (g.DebugItemPickerBreakId == id)
  ------------------
  |  Branch (4061:13): [True: 0, False: 1.04k]
  ------------------
 4062|      0|            IM_DEBUG_BREAK();
  ------------------
  |  |  290|      0|#define IM_DEBUG_BREAK()    __builtin_debugtrap()
  ------------------
 4063|  1.04k|    }
 4064|       |
 4065|  1.04k|    if (g.NavDisableMouseHover)
  ------------------
  |  Branch (4065:9): [True: 325, False: 718]
  ------------------
 4066|    325|        return false;
 4067|       |
 4068|    718|    return true;
 4069|  1.04k|}
_ZN5ImGui15SetLastItemDataEjiiRK6ImRect:
 4086|   132k|{
 4087|   132k|    ImGuiContext& g = *GImGui;
 4088|   132k|    g.LastItemData.ID = item_id;
 4089|   132k|    g.LastItemData.InFlags = in_flags;
 4090|   132k|    g.LastItemData.StatusFlags = item_flags;
 4091|   132k|    g.LastItemData.Rect = item_rect;
 4092|   132k|}
_ZN5ImGui8MemAllocEm:
 4120|  1.21k|{
 4121|  1.21k|    if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4121:23): [True: 1.21k, False: 2]
  ------------------
 4122|  1.21k|        ctx->IO.MetricsActiveAllocations++;
 4123|  1.21k|    return (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
 4124|  1.21k|}
_ZN5ImGui7MemFreeEPv:
 4128|  1.16k|{
 4129|  1.16k|    if (ptr)
  ------------------
  |  Branch (4129:9): [True: 1.15k, False: 9]
  ------------------
 4130|  1.15k|        if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4130:27): [True: 1.15k, False: 0]
  ------------------
 4131|  1.15k|            ctx->IO.MetricsActiveAllocations--;
 4132|  1.16k|    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
 4133|  1.16k|}
_ZN5ImGui5GetIOEv:
 4154|   147k|{
 4155|   147k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|   147k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4156|   147k|    return GImGui->IO;
 4157|   147k|}
_ZN5ImGui11GetDrawDataEv:
 4167|  55.4k|{
 4168|  55.4k|    ImGuiContext& g = *GImGui;
 4169|  55.4k|    ImGuiViewportP* viewport = g.Viewports[0];
 4170|  55.4k|    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
  ------------------
  |  Branch (4170:12): [True: 55.4k, False: 0]
  ------------------
 4171|  55.4k|}
_ZN5ImGui7GetTimeEv:
 4174|      3|{
 4175|      3|    return GImGui->Time;
 4176|      3|}
_ZN5ImGui22StartMouseMovingWindowEP11ImGuiWindow:
 4235|     13|{
 4236|       |    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
 4237|       |    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
 4238|       |    // This is because we want ActiveId to be set even when the window is not permitted to move.
 4239|     13|    ImGuiContext& g = *GImGui;
 4240|     13|    FocusWindow(window);
 4241|     13|    SetActiveID(window->MoveId, window);
 4242|     13|    g.NavDisableHighlight = true;
 4243|     13|    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;
 4244|     13|    g.ActiveIdNoClearOnFocusLoss = true;
 4245|     13|    SetActiveIdUsingAllKeyboardKeys();
 4246|       |
 4247|     13|    bool can_move_window = true;
 4248|     13|    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4248:9): [True: 0, False: 13]
  |  Branch (4248:54): [True: 0, False: 13]
  ------------------
 4249|      0|        can_move_window = false;
 4250|     13|    if (ImGuiDockNode* node = window->DockNodeAsHost)
  ------------------
  |  Branch (4250:24): [True: 0, False: 13]
  ------------------
 4251|      0|        if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4251:13): [True: 0, False: 0]
  |  Branch (4251:36): [True: 0, False: 0]
  ------------------
 4252|      0|            can_move_window = false;
 4253|     13|    if (can_move_window)
  ------------------
  |  Branch (4253:9): [True: 13, False: 0]
  ------------------
 4254|     13|        g.MovingWindow = window;
 4255|     13|}
_ZN5ImGui28StartMouseMovingWindowOrNodeEP11ImGuiWindowP13ImGuiDockNodeb:
 4261|      7|{
 4262|      7|    ImGuiContext& g = *GImGui;
 4263|      7|    bool can_undock_node = false;
 4264|      7|    if (node != NULL && node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove) == 0)
  ------------------
  |  Branch (4264:9): [True: 0, False: 7]
  |  Branch (4264:25): [True: 0, False: 0]
  |  Branch (4264:48): [True: 0, False: 0]
  ------------------
 4265|      0|    {
 4266|       |        // Can undock if:
 4267|       |        // - part of a floating node hierarchy with more than one visible node (if only one is visible, we'll just move the whole hierarchy)
 4268|       |        // - part of a dockspace node hierarchy (trivia: undocking from a fixed/central node will create a new node and copy windows)
 4269|      0|        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
 4270|      0|        if (root_node->OnlyNodeWithWindows != node || root_node->CentralNode != NULL)   // -V1051 PVS-Studio thinks node should be root_node and is wrong about that.
  ------------------
  |  Branch (4270:13): [True: 0, False: 0]
  |  Branch (4270:55): [True: 0, False: 0]
  ------------------
 4271|      0|            if (undock_floating_node || root_node->IsDockSpace())
  ------------------
  |  Branch (4271:17): [True: 0, False: 0]
  |  Branch (4271:41): [True: 0, False: 0]
  ------------------
 4272|      0|                can_undock_node = true;
 4273|      0|    }
 4274|       |
 4275|      7|    const bool clicked = IsMouseClicked(0);
 4276|      7|    const bool dragging = IsMouseDragging(0, g.IO.MouseDragThreshold * 1.70f);
 4277|      7|    if (can_undock_node && dragging)
  ------------------
  |  Branch (4277:9): [True: 0, False: 7]
  |  Branch (4277:28): [True: 0, False: 0]
  ------------------
 4278|      0|        DockContextQueueUndockNode(&g, node); // Will lead to DockNodeStartMouseMovingWindow() -> StartMouseMovingWindow() being called next frame
 4279|      7|    else if (!can_undock_node && (clicked || dragging) && g.MovingWindow != window)
  ------------------
  |  Branch (4279:14): [True: 7, False: 0]
  |  Branch (4279:35): [True: 0, False: 7]
  |  Branch (4279:46): [True: 7, False: 0]
  |  Branch (4279:59): [True: 7, False: 0]
  ------------------
 4280|      7|        StartMouseMovingWindow(window);
 4281|      7|}
_ZN5ImGui31UpdateMouseMovingWindowNewFrameEv:
 4289|  55.4k|{
 4290|  55.4k|    ImGuiContext& g = *GImGui;
 4291|  55.4k|    if (g.MovingWindow != NULL)
  ------------------
  |  Branch (4291:9): [True: 24, False: 55.3k]
  ------------------
 4292|     24|    {
 4293|       |        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
 4294|       |        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
 4295|     24|        KeepAliveID(g.ActiveId);
 4296|     24|        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
  ------------------
  |  |   23|     24|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4297|     24|        ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
 4298|       |
 4299|       |        // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
 4300|     24|        const bool window_disappared = ((!moving_window->WasActive && !moving_window->Active) || moving_window->Viewport == NULL);
  ------------------
  |  Branch (4300:42): [True: 0, False: 24]
  |  Branch (4300:71): [True: 0, False: 0]
  |  Branch (4300:98): [True: 0, False: 24]
  ------------------
 4301|     24|        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared)
  ------------------
  |  Branch (4301:13): [True: 11, False: 13]
  |  Branch (4301:34): [True: 11, False: 0]
  |  Branch (4301:69): [True: 11, False: 0]
  ------------------
 4302|     11|        {
 4303|     11|            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
 4304|     11|            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
  ------------------
  |  Branch (4304:17): [True: 1, False: 10]
  |  Branch (4304:50): [True: 6, False: 4]
  ------------------
 4305|      7|            {
 4306|      7|                SetWindowPos(moving_window, pos, ImGuiCond_Always);
 4307|      7|                if (moving_window->ViewportOwned) // Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
  ------------------
  |  Branch (4307:21): [True: 0, False: 7]
  ------------------
 4308|      0|                {
 4309|      0|                    moving_window->Viewport->Pos = pos;
 4310|      0|                    moving_window->Viewport->UpdateWorkRect();
 4311|      0|                }
 4312|      7|            }
 4313|     11|            FocusWindow(g.MovingWindow);
 4314|     11|        }
 4315|     13|        else
 4316|     13|        {
 4317|     13|            if (!window_disappared)
  ------------------
  |  Branch (4317:17): [True: 13, False: 0]
  ------------------
 4318|     13|            {
 4319|       |                // Try to merge the window back into the main viewport.
 4320|       |                // This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
 4321|     13|                if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (4321:21): [True: 0, False: 13]
  ------------------
 4322|      0|                    UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport);
 4323|       |
 4324|       |                // Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
 4325|     13|                if (!IsDragDropPayloadBeingAccepted())
  ------------------
  |  Branch (4325:21): [True: 13, False: 0]
  ------------------
 4326|     13|                    g.MouseViewport = moving_window->Viewport;
 4327|       |
 4328|       |                // Clear the NoInput window flag set by the Viewport system
 4329|     13|                moving_window->Viewport->Flags &= ~ImGuiViewportFlags_NoInputs; // FIXME-VIEWPORT: Test engine managed to crash here because Viewport was NULL.
 4330|     13|            }
 4331|       |
 4332|     13|            g.MovingWindow = NULL;
 4333|     13|            ClearActiveID();
 4334|     13|        }
 4335|     24|    }
 4336|  55.3k|    else
 4337|  55.3k|    {
 4338|       |        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
 4339|  55.3k|        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
  ------------------
  |  Branch (4339:13): [True: 238, False: 55.1k]
  |  Branch (4339:33): [True: 0, False: 238]
  ------------------
 4340|      0|        {
 4341|      0|            KeepAliveID(g.ActiveId);
 4342|      0|            if (!g.IO.MouseDown[0])
  ------------------
  |  Branch (4342:17): [True: 0, False: 0]
  ------------------
 4343|      0|                ClearActiveID();
 4344|      0|        }
 4345|  55.3k|    }
 4346|  55.4k|}
_ZN5ImGui31UpdateMouseMovingWindowEndFrameEv:
 4351|  55.4k|{
 4352|  55.4k|    ImGuiContext& g = *GImGui;
 4353|  55.4k|    if (g.ActiveId != 0 || g.HoveredId != 0)
  ------------------
  |  Branch (4353:9): [True: 312, False: 55.0k]
  |  Branch (4353:28): [True: 749, False: 54.3k]
  ------------------
 4354|  1.06k|        return;
 4355|       |
 4356|       |    // Unless we just made a window/popup appear
 4357|  54.3k|    if (g.NavWindow && g.NavWindow->Appearing)
  ------------------
  |  Branch (4357:9): [True: 8.76k, False: 45.5k]
  |  Branch (4357:24): [True: 1, False: 8.76k]
  ------------------
 4358|      1|        return;
 4359|       |
 4360|       |    // Click on empty space to focus window and start moving
 4361|       |    // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
 4362|  54.3k|    if (g.IO.MouseClicked[0])
  ------------------
  |  Branch (4362:9): [True: 622, False: 53.7k]
  ------------------
 4363|    622|    {
 4364|       |        // Handle the edge case of a popup being closed while clicking in its empty space.
 4365|       |        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
 4366|    622|        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
  ------------------
  |  Branch (4366:36): [True: 6, False: 616]
  ------------------
 4367|    622|        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);
  ------------------
  |  Branch (4367:38): [True: 6, False: 616]
  |  Branch (4367:53): [True: 0, False: 6]
  |  Branch (4367:102): [True: 0, False: 0]
  ------------------
 4368|       |
 4369|    622|        if (root_window != NULL && !is_closed_popup)
  ------------------
  |  Branch (4369:13): [True: 6, False: 616]
  |  Branch (4369:36): [True: 6, False: 0]
  ------------------
 4370|      6|        {
 4371|      6|            StartMouseMovingWindow(g.HoveredWindow); //-V595
 4372|       |
 4373|       |            // Cancel moving if clicked outside of title bar
 4374|      6|            if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
  ------------------
  |  Branch (4374:17): [True: 0, False: 6]
  ------------------
 4375|      0|                if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
  ------------------
  |  Branch (4375:21): [True: 0, False: 0]
  |  Branch (4375:76): [True: 0, False: 0]
  ------------------
 4376|      0|                    if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
  ------------------
  |  Branch (4376:25): [True: 0, False: 0]
  ------------------
 4377|      0|                        g.MovingWindow = NULL;
 4378|       |
 4379|       |            // Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
 4380|      6|            if (g.HoveredIdDisabled)
  ------------------
  |  Branch (4380:17): [True: 0, False: 6]
  ------------------
 4381|      0|                g.MovingWindow = NULL;
 4382|      6|        }
 4383|    616|        else if (root_window == NULL && g.NavWindow != NULL && GetTopMostPopupModal() == NULL)
  ------------------
  |  Branch (4383:18): [True: 616, False: 0]
  |  Branch (4383:41): [True: 121, False: 495]
  |  Branch (4383:64): [True: 121, False: 0]
  ------------------
 4384|    121|        {
 4385|       |            // Clicking on void disable focus
 4386|    121|            FocusWindow(NULL);
 4387|    121|        }
 4388|    622|    }
 4389|       |
 4390|       |    // With right mouse button we close popups without changing focus based on where the mouse is aimed
 4391|       |    // Instead, focus will be restored to the window under the bottom-most closed popup.
 4392|       |    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
 4393|  54.3k|    if (g.IO.MouseClicked[1])
  ------------------
  |  Branch (4393:9): [True: 233, False: 54.1k]
  ------------------
 4394|    233|    {
 4395|       |        // Find the top-most window between HoveredWindow and the top-most Modal Window.
 4396|       |        // This is where we can trim the popup stack.
 4397|    233|        ImGuiWindow* modal = GetTopMostPopupModal();
 4398|    233|        bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
  ------------------
  |  Branch (4398:43): [True: 3, False: 230]
  |  Branch (4398:63): [True: 3, False: 0]
  |  Branch (4398:80): [True: 0, False: 0]
  ------------------
 4399|    233|        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
  ------------------
  |  Branch (4399:31): [True: 3, False: 230]
  ------------------
 4400|    233|    }
 4401|  54.3k|}
_ZN5ImGui34UpdateHoveredWindowAndCaptureFlagsEv:
 4433|  55.4k|{
 4434|  55.4k|    ImGuiContext& g = *GImGui;
 4435|  55.4k|    ImGuiIO& io = g.IO;
 4436|  55.4k|    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));
 4437|       |
 4438|       |    // Find the window hovered by mouse:
 4439|       |    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
 4440|       |    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
 4441|       |    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
 4442|  55.4k|    bool clear_hovered_windows = false;
 4443|  55.4k|    FindHoveredWindow();
 4444|  55.4k|    IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4445|       |
 4446|       |    // Modal windows prevents mouse from hovering behind them.
 4447|  55.4k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
 4448|  55.4k|    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window)) // FIXME-MERGE: RootWindowDockTree ?
  ------------------
  |  Branch (4448:9): [True: 0, False: 55.4k]
  |  Branch (4448:25): [True: 0, False: 0]
  |  Branch (4448:44): [True: 0, False: 0]
  ------------------
 4449|      0|        clear_hovered_windows = true;
 4450|       |
 4451|       |    // Disabled mouse?
 4452|  55.4k|    if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
  ------------------
  |  Branch (4452:9): [True: 0, False: 55.4k]
  ------------------
 4453|      0|        clear_hovered_windows = true;
 4454|       |
 4455|       |    // We track click ownership. When clicked outside of a window the click is owned by the application and
 4456|       |    // won't report hovering nor request capture even while dragging over our windows afterward.
 4457|  55.4k|    const bool has_open_popup = (g.OpenPopupStack.Size > 0);
 4458|  55.4k|    const bool has_open_modal = (modal_window != NULL);
 4459|  55.4k|    int mouse_earliest_down = -1;
 4460|  55.4k|    bool mouse_any_down = false;
 4461|   332k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   87|   332k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4461:21): [True: 277k, False: 55.4k]
  ------------------
 4462|   277k|    {
 4463|   277k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (4463:13): [True: 1.41k, False: 275k]
  ------------------
 4464|  1.41k|        {
 4465|  1.41k|            io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
  ------------------
  |  Branch (4465:36): [True: 153, False: 1.25k]
  |  Branch (4465:65): [True: 0, False: 1.25k]
  ------------------
 4466|  1.41k|            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
  ------------------
  |  Branch (4466:52): [True: 153, False: 1.25k]
  |  Branch (4466:81): [True: 0, False: 1.25k]
  ------------------
 4467|  1.41k|        }
 4468|   277k|        mouse_any_down |= io.MouseDown[i];
 4469|   277k|        if (io.MouseDown[i])
  ------------------
  |  Branch (4469:13): [True: 13.5k, False: 263k]
  ------------------
 4470|  13.5k|            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
  ------------------
  |  Branch (4470:17): [True: 10.2k, False: 3.28k]
  |  Branch (4470:46): [True: 1.54k, False: 1.74k]
  ------------------
 4471|  11.8k|                mouse_earliest_down = i;
 4472|   277k|    }
 4473|  55.4k|    const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
  ------------------
  |  Branch (4473:30): [True: 45.1k, False: 10.2k]
  |  Branch (4473:61): [True: 482, False: 9.79k]
  ------------------
 4474|  55.4k|    const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];
  ------------------
  |  Branch (4474:49): [True: 45.1k, False: 10.2k]
  |  Branch (4474:80): [True: 482, False: 9.79k]
  ------------------
 4475|       |
 4476|       |    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
 4477|       |    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
 4478|  55.4k|    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
  ------------------
  |  Branch (4478:48): [True: 25, False: 55.3k]
  |  Branch (4478:68): [True: 0, False: 25]
  ------------------
 4479|  55.4k|    if (!mouse_avail && !mouse_dragging_extern_payload)
  ------------------
  |  Branch (4479:9): [True: 9.79k, False: 45.6k]
  |  Branch (4479:25): [True: 9.79k, False: 0]
  ------------------
 4480|  9.79k|        clear_hovered_windows = true;
 4481|       |
 4482|  55.4k|    if (clear_hovered_windows)
  ------------------
  |  Branch (4482:9): [True: 9.79k, False: 45.6k]
  ------------------
 4483|  9.79k|        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
 4484|       |
 4485|       |    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
 4486|       |    // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
 4487|  55.4k|    if (g.WantCaptureMouseNextFrame != -1)
  ------------------
  |  Branch (4487:9): [True: 0, False: 55.4k]
  ------------------
 4488|      0|    {
 4489|      0|        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
 4490|      0|    }
 4491|  55.4k|    else
 4492|  55.4k|    {
 4493|  55.4k|        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
  ------------------
  |  Branch (4493:32): [True: 45.6k, False: 9.79k]
  |  Branch (4493:48): [True: 1.11k, False: 44.4k]
  |  Branch (4493:75): [True: 14, False: 44.4k]
  |  Branch (4493:95): [True: 0, False: 54.2k]
  ------------------
 4494|  55.4k|        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
  ------------------
  |  Branch (4494:48): [True: 45.6k, False: 9.79k]
  |  Branch (4494:83): [True: 1.11k, False: 44.4k]
  |  Branch (4494:110): [True: 14, False: 44.4k]
  |  Branch (4494:130): [True: 0, False: 54.2k]
  ------------------
 4495|  55.4k|    }
 4496|       |
 4497|       |    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
 4498|  55.4k|    if (g.WantCaptureKeyboardNextFrame != -1)
  ------------------
  |  Branch (4498:9): [True: 0, False: 55.4k]
  ------------------
 4499|      0|        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
 4500|  55.4k|    else
 4501|  55.4k|        io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
  ------------------
  |  Branch (4501:34): [True: 262, False: 55.1k]
  |  Branch (4501:55): [True: 0, False: 55.1k]
  ------------------
 4502|  55.4k|    if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
  ------------------
  |  Branch (4502:9): [True: 7.83k, False: 47.5k]
  |  Branch (4502:25): [True: 7.83k, False: 0]
  |  Branch (4502:82): [True: 7.83k, False: 0]
  ------------------
 4503|  7.83k|        io.WantCaptureKeyboard = true;
 4504|       |
 4505|       |    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
 4506|  55.4k|    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
  ------------------
  |  Branch (4506:24): [True: 0, False: 55.4k]
  ------------------
 4507|  55.4k|}
_ZN5ImGui8NewFrameEv:
 4510|  55.4k|{
 4511|  55.4k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4512|  55.4k|    ImGuiContext& g = *GImGui;
 4513|       |
 4514|       |    // Remove pending delete hooks before frame start.
 4515|       |    // This deferred removal avoid issues of removal while iterating the hook vector
 4516|  55.4k|    for (int n = g.Hooks.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (4516:36): [True: 0, False: 55.4k]
  ------------------
 4517|      0|        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
  ------------------
  |  Branch (4517:13): [True: 0, False: 0]
  ------------------
 4518|      0|            g.Hooks.erase(&g.Hooks[n]);
 4519|       |
 4520|  55.4k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);
 4521|       |
 4522|       |    // Check and assert for various common IO and Configuration mistakes
 4523|  55.4k|    g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
 4524|  55.4k|    ErrorCheckNewFrameSanityChecks();
 4525|  55.4k|    g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;
 4526|       |
 4527|       |    // Load settings on first frame, save settings when modified (after a delay)
 4528|  55.4k|    UpdateSettings();
 4529|       |
 4530|  55.4k|    g.Time += g.IO.DeltaTime;
 4531|  55.4k|    g.WithinFrameScope = true;
 4532|  55.4k|    g.FrameCount += 1;
 4533|  55.4k|    g.TooltipOverrideCount = 0;
 4534|  55.4k|    g.WindowsActiveCount = 0;
 4535|  55.4k|    g.MenusIdSubmittedThisFrame.resize(0);
 4536|       |
 4537|       |    // Calculate frame-rate for the user, as a purely luxurious feature
 4538|  55.4k|    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
 4539|  55.4k|    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
 4540|  55.4k|    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
  ------------------
  |  |   87|  55.4k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4541|  55.4k|    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
  ------------------
  |  |   87|  55.4k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4542|  55.4k|    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;
  ------------------
  |  Branch (4542:22): [True: 55.4k, False: 0]
  ------------------
 4543|       |
 4544|       |    // Process input queue (trickle as many events as possible), turn events into writes to IO structure
 4545|  55.4k|    g.InputEventsTrail.resize(0);
 4546|  55.4k|    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);
 4547|       |
 4548|       |    // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
 4549|  55.4k|    UpdateViewportsNewFrame();
 4550|       |
 4551|       |    // Setup current font and draw list shared data
 4552|       |    // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
 4553|  55.4k|    g.IO.Fonts->Locked = true;
 4554|  55.4k|    SetCurrentFont(GetDefaultFont());
 4555|  55.4k|    IM_ASSERT(g.Font->IsLoaded());
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4556|  55.4k|    ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
 4557|   110k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (4557:21): [True: 55.4k, False: 55.4k]
  ------------------
 4558|  55.4k|        virtual_space.Add(g.Viewports[n]->GetMainRect());
 4559|  55.4k|    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
 4560|  55.4k|    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
 4561|  55.4k|    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
 4562|  55.4k|    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
 4563|  55.4k|    if (g.Style.AntiAliasedLines)
  ------------------
  |  Branch (4563:9): [True: 55.4k, False: 0]
  ------------------
 4564|  55.4k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
 4565|  55.4k|    if (g.Style.AntiAliasedLinesUseTex && !(g.Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (4565:9): [True: 55.4k, False: 0]
  |  Branch (4565:43): [True: 55.4k, False: 0]
  ------------------
 4566|  55.4k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
 4567|  55.4k|    if (g.Style.AntiAliasedFill)
  ------------------
  |  Branch (4567:9): [True: 55.4k, False: 0]
  ------------------
 4568|  55.4k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
 4569|  55.4k|    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
  ------------------
  |  Branch (4569:9): [True: 0, False: 55.4k]
  ------------------
 4570|      0|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
 4571|       |
 4572|       |    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
 4573|   110k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (4573:21): [True: 55.4k, False: 55.4k]
  ------------------
 4574|  55.4k|    {
 4575|  55.4k|        ImGuiViewportP* viewport = g.Viewports[n];
 4576|  55.4k|        viewport->DrawData = NULL;
 4577|  55.4k|        viewport->DrawDataP.Clear();
 4578|  55.4k|    }
 4579|       |
 4580|       |    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
 4581|  55.4k|    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
  ------------------
  |  Branch (4581:9): [True: 25, False: 55.3k]
  |  Branch (4581:29): [True: 18, False: 7]
  ------------------
 4582|     18|        KeepAliveID(g.DragDropPayload.SourceId);
 4583|       |
 4584|       |    // Update HoveredId data
 4585|  55.4k|    if (!g.HoveredIdPreviousFrame)
  ------------------
  |  Branch (4585:9): [True: 54.3k, False: 1.04k]
  ------------------
 4586|  54.3k|        g.HoveredIdTimer = 0.0f;
 4587|  55.4k|    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
  ------------------
  |  Branch (4587:9): [True: 54.3k, False: 1.04k]
  |  Branch (4587:39): [True: 931, False: 112]
  |  Branch (4587:54): [True: 225, False: 706]
  ------------------
 4588|  54.5k|        g.HoveredIdNotActiveTimer = 0.0f;
 4589|  55.4k|    if (g.HoveredId)
  ------------------
  |  Branch (4589:9): [True: 1.04k, False: 54.3k]
  ------------------
 4590|  1.04k|        g.HoveredIdTimer += g.IO.DeltaTime;
 4591|  55.4k|    if (g.HoveredId && g.ActiveId != g.HoveredId)
  ------------------
  |  Branch (4591:9): [True: 1.04k, False: 54.3k]
  |  Branch (4591:24): [True: 805, False: 238]
  ------------------
 4592|    805|        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
 4593|  55.4k|    g.HoveredIdPreviousFrame = g.HoveredId;
 4594|  55.4k|    g.HoveredId = 0;
 4595|  55.4k|    g.HoveredIdAllowOverlap = false;
 4596|  55.4k|    g.HoveredIdDisabled = false;
 4597|       |
 4598|       |    // Clear ActiveID if the item is not alive anymore.
 4599|       |    // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
 4600|       |    // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
 4601|  55.4k|    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
  ------------------
  |  Branch (4601:9): [True: 262, False: 55.1k]
  |  Branch (4601:28): [True: 0, False: 262]
  |  Branch (4601:63): [True: 0, False: 0]
  ------------------
 4602|      0|    {
 4603|      0|        IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
  ------------------
  |  |  226|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (226:50): [True: 0, False: 0]
  |  |  |  Branch (226:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4604|      0|        ClearActiveID();
 4605|      0|    }
 4606|       |
 4607|       |    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
 4608|  55.4k|    if (g.ActiveId)
  ------------------
  |  Branch (4608:9): [True: 262, False: 55.1k]
  ------------------
 4609|    262|        g.ActiveIdTimer += g.IO.DeltaTime;
 4610|  55.4k|    g.LastActiveIdTimer += g.IO.DeltaTime;
 4611|  55.4k|    g.ActiveIdPreviousFrame = g.ActiveId;
 4612|  55.4k|    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
 4613|  55.4k|    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
 4614|  55.4k|    g.ActiveIdIsAlive = 0;
 4615|  55.4k|    g.ActiveIdHasBeenEditedThisFrame = false;
 4616|  55.4k|    g.ActiveIdPreviousFrameIsAlive = false;
 4617|  55.4k|    g.ActiveIdIsJustActivated = false;
 4618|  55.4k|    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
  ------------------
  |  Branch (4618:9): [True: 0, False: 55.4k]
  |  Branch (4618:31): [True: 0, False: 0]
  ------------------
 4619|      0|        g.TempInputId = 0;
 4620|  55.4k|    if (g.ActiveId == 0)
  ------------------
  |  Branch (4620:9): [True: 55.1k, False: 262]
  ------------------
 4621|  55.1k|    {
 4622|  55.1k|        g.ActiveIdUsingNavDirMask = 0x00;
 4623|  55.1k|        g.ActiveIdUsingAllKeyboardKeys = false;
 4624|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4625|       |        g.ActiveIdUsingNavInputMask = 0x00;
 4626|       |#endif
 4627|  55.1k|    }
 4628|       |
 4629|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4630|       |    if (g.ActiveId == 0)
 4631|       |        g.ActiveIdUsingNavInputMask = 0;
 4632|       |    else if (g.ActiveIdUsingNavInputMask != 0)
 4633|       |    {
 4634|       |        // If your custom widget code used:                 { g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel); }
 4635|       |        // Since IMGUI_VERSION_NUM >= 18804 it should be:   { SetKeyOwner(ImGuiKey_Escape, g.ActiveId); SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId); }
 4636|       |        if (g.ActiveIdUsingNavInputMask & (1 << ImGuiNavInput_Cancel))
 4637|       |            SetKeyOwner(ImGuiKey_Escape, g.ActiveId);
 4638|       |        if (g.ActiveIdUsingNavInputMask & ~(1 << ImGuiNavInput_Cancel))
 4639|       |            IM_ASSERT(0); // Other values unsupported
 4640|       |    }
 4641|       |#endif
 4642|       |
 4643|       |    // Update hover delay for IsItemHovered() with delays and tooltips
 4644|  55.4k|    g.HoverDelayIdPreviousFrame = g.HoverDelayId;
 4645|  55.4k|    if (g.HoverDelayId != 0)
  ------------------
  |  Branch (4645:9): [True: 0, False: 55.4k]
  ------------------
 4646|      0|    {
 4647|       |        //if (g.IO.MouseDelta.x == 0.0f && g.IO.MouseDelta.y == 0.0f) // Need design/flags
 4648|      0|        g.HoverDelayTimer += g.IO.DeltaTime;
 4649|      0|        g.HoverDelayClearTimer = 0.0f;
 4650|      0|        g.HoverDelayId = 0;
 4651|      0|    }
 4652|  55.4k|    else if (g.HoverDelayTimer > 0.0f)
  ------------------
  |  Branch (4652:14): [True: 0, False: 55.4k]
  ------------------
 4653|      0|    {
 4654|       |        // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
 4655|      0|        g.HoverDelayClearTimer += g.IO.DeltaTime;
 4656|      0|        if (g.HoverDelayClearTimer >= ImMax(0.20f, g.IO.DeltaTime * 2.0f)) // ~6 frames at 30 Hz + allow for low framerate
  ------------------
  |  Branch (4656:13): [True: 0, False: 0]
  ------------------
 4657|      0|            g.HoverDelayTimer = g.HoverDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
 4658|      0|    }
 4659|       |
 4660|       |    // Drag and drop
 4661|  55.4k|    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
 4662|  55.4k|    g.DragDropAcceptIdCurr = 0;
 4663|  55.4k|    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
 4664|  55.4k|    g.DragDropWithinSource = false;
 4665|  55.4k|    g.DragDropWithinTarget = false;
 4666|  55.4k|    g.DragDropHoldJustPressedId = 0;
 4667|       |
 4668|       |    // Close popups on focus lost (currently wip/opt-in)
 4669|       |    //if (g.IO.AppFocusLost)
 4670|       |    //    ClosePopupsExceptModals();
 4671|       |
 4672|       |    // Update keyboard input state
 4673|  55.4k|    UpdateKeyboardInputs();
 4674|       |
 4675|       |    //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
 4676|       |    //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
 4677|       |    //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
 4678|       |    //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));
 4679|       |
 4680|       |    // Update gamepad/keyboard navigation
 4681|  55.4k|    NavUpdate();
 4682|       |
 4683|       |    // Update mouse input state
 4684|  55.4k|    UpdateMouseInputs();
 4685|       |
 4686|       |    // Undocking
 4687|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
 4688|  55.4k|    DockContextNewFrameUpdateUndocking(&g);
 4689|       |
 4690|       |    // Find hovered window
 4691|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
 4692|  55.4k|    UpdateHoveredWindowAndCaptureFlags();
 4693|       |
 4694|       |    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
 4695|  55.4k|    UpdateMouseMovingWindowNewFrame();
 4696|       |
 4697|       |    // Background darkening/whitening
 4698|  55.4k|    if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
  ------------------
  |  Branch (4698:9): [True: 0, False: 55.4k]
  |  Branch (4698:44): [True: 12.9k, False: 42.4k]
  |  Branch (4698:76): [True: 9.53k, False: 3.37k]
  ------------------
 4699|  9.53k|        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
 4700|  45.8k|    else
 4701|  45.8k|        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);
 4702|       |
 4703|  55.4k|    g.MouseCursor = ImGuiMouseCursor_Arrow;
 4704|  55.4k|    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
 4705|       |
 4706|       |    // Platform IME data: reset for the frame
 4707|  55.4k|    g.PlatformImeDataPrev = g.PlatformImeData;
 4708|  55.4k|    g.PlatformImeData.WantVisible = false;
 4709|       |
 4710|       |    // Mouse wheel scrolling, scale
 4711|  55.4k|    UpdateMouseWheel();
 4712|       |
 4713|       |    // Mark all windows as not visible and compact unused memory.
 4714|  55.4k|    IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4715|  55.4k|    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
  ------------------
  |  Branch (4715:46): [True: 0, False: 55.4k]
  |  Branch (4715:64): [True: 0, False: 55.4k]
  ------------------
 4716|   274k|    for (int i = 0; i != g.Windows.Size; i++)
  ------------------
  |  Branch (4716:21): [True: 219k, False: 55.4k]
  ------------------
 4717|   219k|    {
 4718|   219k|        ImGuiWindow* window = g.Windows[i];
 4719|   219k|        window->WasActive = window->Active;
 4720|   219k|        window->Active = false;
 4721|   219k|        window->WriteAccessed = false;
 4722|   219k|        window->BeginCountPreviousFrame = window->BeginCount;
 4723|   219k|        window->BeginCount = 0;
 4724|       |
 4725|       |        // Garbage collect transient buffers of recently unused windows
 4726|   219k|        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (4726:13): [True: 141k, False: 77.0k]
  |  Branch (4726:35): [True: 102k, False: 39.0k]
  |  Branch (4726:63): [True: 1, False: 102k]
  ------------------
 4727|      1|            GcCompactTransientWindowBuffers(window);
 4728|   219k|    }
 4729|       |
 4730|       |    // Garbage collect transient buffers of recently unused tables
 4731|  55.4k|    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
  ------------------
  |  Branch (4731:21): [True: 0, False: 55.4k]
  ------------------
 4732|      0|        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
  ------------------
  |  Branch (4732:13): [True: 0, False: 0]
  |  Branch (4732:50): [True: 0, False: 0]
  ------------------
 4733|      0|            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
 4734|  55.4k|    for (int i = 0; i < g.TablesTempData.Size; i++)
  ------------------
  |  Branch (4734:21): [True: 0, False: 55.4k]
  ------------------
 4735|      0|        if (g.TablesTempData[i].LastTimeActive >= 0.0f && g.TablesTempData[i].LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (4735:13): [True: 0, False: 0]
  |  Branch (4735:59): [True: 0, False: 0]
  ------------------
 4736|      0|            TableGcCompactTransientBuffers(&g.TablesTempData[i]);
 4737|  55.4k|    if (g.GcCompactAll)
  ------------------
  |  Branch (4737:9): [True: 0, False: 55.4k]
  ------------------
 4738|      0|        GcCompactTransientMiscBuffers();
 4739|  55.4k|    g.GcCompactAll = false;
 4740|       |
 4741|       |    // Closing the focused window restore focus to the first active root window in descending z-order
 4742|  55.4k|    if (g.NavWindow && !g.NavWindow->WasActive)
  ------------------
  |  Branch (4742:9): [True: 7.83k, False: 47.5k]
  |  Branch (4742:24): [True: 0, False: 7.83k]
  ------------------
 4743|      0|        FocusTopMostWindowUnderOne(NULL, NULL);
 4744|       |
 4745|       |    // No window should be open at the beginning of the frame.
 4746|       |    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
 4747|  55.4k|    g.CurrentWindowStack.resize(0);
 4748|  55.4k|    g.BeginPopupStack.resize(0);
 4749|  55.4k|    g.ItemFlagsStack.resize(0);
 4750|  55.4k|    g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
 4751|  55.4k|    g.GroupStack.resize(0);
 4752|       |
 4753|       |    // Docking
 4754|  55.4k|    DockContextNewFrameUpdateDocking(&g);
 4755|       |
 4756|       |    // [DEBUG] Update debug features
 4757|  55.4k|    UpdateDebugToolItemPicker();
 4758|  55.4k|    UpdateDebugToolStackQueries();
 4759|  55.4k|    if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
  ------------------
  |  Branch (4759:9): [True: 0, False: 55.4k]
  |  Branch (4759:36): [True: 0, False: 0]
  ------------------
 4760|      0|        g.DebugLocateId = 0;
 4761|       |
 4762|       |    // Create implicit/fallback window - which we will only render it if the user has added something to it.
 4763|       |    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
 4764|       |    // This fallback is particularly important as it prevents ImGui:: calls from crashing.
 4765|  55.4k|    g.WithinFrameScopeWithImplicitWindow = true;
 4766|  55.4k|    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
 4767|  55.4k|    Begin("Debug##Default");
 4768|  55.4k|    IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4769|       |
 4770|  55.4k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
 4771|  55.4k|}
_ZN17ImDrawDataBuilder22FlattenIntoSingleLayerEv:
 4864|  55.4k|{
 4865|  55.4k|    int n = Layers[0].Size;
 4866|  55.4k|    int size = n;
 4867|   110k|    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
  ------------------
  |  |   87|   110k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4867:21): [True: 55.4k, False: 55.4k]
  ------------------
 4868|  55.4k|        size += Layers[i].Size;
 4869|  55.4k|    Layers[0].resize(size);
 4870|   110k|    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
  ------------------
  |  |   87|   110k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4870:27): [True: 55.4k, False: 55.4k]
  ------------------
 4871|  55.4k|    {
 4872|  55.4k|        ImVector<ImDrawList*>& layer = Layers[layer_n];
 4873|  55.4k|        if (layer.empty())
  ------------------
  |  Branch (4873:13): [True: 55.4k, False: 0]
  ------------------
 4874|  55.4k|            continue;
 4875|      0|        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
 4876|      0|        n += layer.Size;
 4877|      0|        layer.resize(0);
 4878|      0|    }
 4879|  55.4k|}
_ZN5ImGui12PushClipRectERK6ImVec2S2_b:
 4917|   264k|{
 4918|   264k|    ImGuiWindow* window = GetCurrentWindow();
 4919|   264k|    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
 4920|   264k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 4921|   264k|}
_ZN5ImGui11PopClipRectEv:
 4924|   132k|{
 4925|   132k|    ImGuiWindow* window = GetCurrentWindow();
 4926|   132k|    window->DrawList->PopClipRect();
 4927|   132k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 4928|   132k|}
_ZN5ImGui8EndFrameEv:
 5052|   110k|{
 5053|   110k|    ImGuiContext& g = *GImGui;
 5054|   110k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|   110k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5055|       |
 5056|       |    // Don't process EndFrame() multiple times.
 5057|   110k|    if (g.FrameCountEnded == g.FrameCount)
  ------------------
  |  Branch (5057:9): [True: 55.4k, False: 55.4k]
  ------------------
 5058|  55.4k|        return;
 5059|  55.4k|    IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5060|       |
 5061|  55.4k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);
 5062|       |
 5063|  55.4k|    ErrorCheckEndFrameSanityChecks();
 5064|       |
 5065|       |    // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
 5066|  55.4k|    if (g.IO.SetPlatformImeDataFn && memcmp(&g.PlatformImeData, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
  ------------------
  |  Branch (5066:9): [True: 55.4k, False: 0]
  |  Branch (5066:38): [True: 0, False: 55.4k]
  ------------------
 5067|      0|    {
 5068|      0|        ImGuiViewport* viewport = FindViewportByID(g.PlatformImeViewport);
 5069|      0|        g.IO.SetPlatformImeDataFn(viewport ? viewport : GetMainViewport(), &g.PlatformImeData);
  ------------------
  |  Branch (5069:35): [True: 0, False: 0]
  ------------------
 5070|      0|    }
 5071|       |
 5072|       |    // Hide implicit/fallback "Debug" window if it hasn't been used
 5073|  55.4k|    g.WithinFrameScopeWithImplicitWindow = false;
 5074|  55.4k|    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
  ------------------
  |  Branch (5074:9): [True: 55.4k, False: 0]
  |  Branch (5074:28): [True: 55.4k, False: 0]
  ------------------
 5075|  55.4k|        g.CurrentWindow->Active = false;
 5076|  55.4k|    End();
 5077|       |
 5078|       |    // Update navigation: CTRL+Tab, wrap-around requests
 5079|  55.4k|    NavEndFrame();
 5080|       |
 5081|       |    // Update docking
 5082|  55.4k|    DockContextEndFrame(&g);
 5083|       |
 5084|  55.4k|    SetCurrentViewport(NULL, NULL);
 5085|       |
 5086|       |    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
 5087|  55.4k|    if (g.DragDropActive)
  ------------------
  |  Branch (5087:9): [True: 32, False: 55.3k]
  ------------------
 5088|     32|    {
 5089|     32|        bool is_delivered = g.DragDropPayload.Delivery;
 5090|     32|        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
  ------------------
  |  Branch (5090:27): [True: 7, False: 25]
  |  Branch (5090:85): [True: 7, False: 0]
  |  Branch (5090:157): [True: 0, False: 0]
  ------------------
 5091|     32|        if (is_delivered || is_elapsed)
  ------------------
  |  Branch (5091:13): [True: 0, False: 32]
  |  Branch (5091:29): [True: 7, False: 25]
  ------------------
 5092|      7|            ClearDragDrop();
 5093|     32|    }
 5094|       |
 5095|       |    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
 5096|  55.4k|    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (5096:9): [True: 25, False: 55.3k]
  |  Branch (5096:29): [True: 9, False: 16]
  |  Branch (5096:74): [True: 0, False: 9]
  ------------------
 5097|      0|    {
 5098|      0|        g.DragDropWithinSource = true;
 5099|      0|        SetTooltip("...");
 5100|      0|        g.DragDropWithinSource = false;
 5101|      0|    }
 5102|       |
 5103|       |    // End frame
 5104|  55.4k|    g.WithinFrameScope = false;
 5105|  55.4k|    g.FrameCountEnded = g.FrameCount;
 5106|       |
 5107|       |    // Initiate moving window + handle left-click and right-click focus
 5108|  55.4k|    UpdateMouseMovingWindowEndFrame();
 5109|       |
 5110|       |    // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
 5111|  55.4k|    UpdateViewportsEndFrame();
 5112|       |
 5113|       |    // Sort the window list so that all child windows are after their parent
 5114|       |    // We cannot do that on FocusWindow() because children may not exist yet
 5115|  55.4k|    g.WindowsTempSortBuffer.resize(0);
 5116|  55.4k|    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
 5117|   274k|    for (int i = 0; i != g.Windows.Size; i++)
  ------------------
  |  Branch (5117:21): [True: 219k, False: 55.4k]
  ------------------
 5118|   219k|    {
 5119|   219k|        ImGuiWindow* window = g.Windows[i];
 5120|   219k|        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
  ------------------
  |  Branch (5120:13): [True: 77.0k, False: 141k]
  |  Branch (5120:31): [True: 11.3k, False: 65.6k]
  ------------------
 5121|  11.3k|            continue;
 5122|   207k|        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
 5123|   207k|    }
 5124|       |
 5125|       |    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
 5126|  55.4k|    IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5127|  55.4k|    g.Windows.swap(g.WindowsTempSortBuffer);
 5128|  55.4k|    g.IO.MetricsActiveWindows = g.WindowsActiveCount;
 5129|       |
 5130|       |    // Unlock font atlas
 5131|  55.4k|    g.IO.Fonts->Locked = false;
 5132|       |
 5133|       |    // Clear Input data for next frame
 5134|  55.4k|    g.IO.AppFocusLost = false;
 5135|  55.4k|    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
 5136|  55.4k|    g.IO.InputQueueCharacters.resize(0);
 5137|       |
 5138|  55.4k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
 5139|  55.4k|}
_ZN5ImGui6RenderEv:
 5145|  55.4k|{
 5146|  55.4k|    ImGuiContext& g = *GImGui;
 5147|  55.4k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5148|       |
 5149|  55.4k|    if (g.FrameCountEnded != g.FrameCount)
  ------------------
  |  Branch (5149:9): [True: 55.4k, False: 0]
  ------------------
 5150|  55.4k|        EndFrame();
 5151|  55.4k|    const bool first_render_of_frame = (g.FrameCountRendered != g.FrameCount);
 5152|  55.4k|    g.FrameCountRendered = g.FrameCount;
 5153|  55.4k|    g.IO.MetricsRenderWindows = 0;
 5154|       |
 5155|  55.4k|    CallContextHooks(&g, ImGuiContextHookType_RenderPre);
 5156|       |
 5157|       |    // Add background ImDrawList (for each active viewport)
 5158|   110k|    for (int n = 0; n != g.Viewports.Size; n++)
  ------------------
  |  Branch (5158:21): [True: 55.4k, False: 55.4k]
  ------------------
 5159|  55.4k|    {
 5160|  55.4k|        ImGuiViewportP* viewport = g.Viewports[n];
 5161|  55.4k|        viewport->DrawDataBuilder.Clear();
 5162|  55.4k|        if (viewport->DrawLists[0] != NULL)
  ------------------
  |  Branch (5162:13): [True: 0, False: 55.4k]
  ------------------
 5163|      0|            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
 5164|  55.4k|    }
 5165|       |
 5166|       |    // Add ImDrawList to render
 5167|  55.4k|    ImGuiWindow* windows_to_render_top_most[2];
 5168|  55.4k|    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
  ------------------
  |  Branch (5168:38): [True: 12.9k, False: 42.4k]
  |  Branch (5168:62): [True: 12.9k, False: 0]
  ------------------
 5169|  55.4k|    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
  ------------------
  |  Branch (5169:38): [True: 12.9k, False: 42.4k]
  ------------------
 5170|   274k|    for (int n = 0; n != g.Windows.Size; n++)
  ------------------
  |  Branch (5170:21): [True: 219k, False: 55.4k]
  ------------------
 5171|   219k|    {
 5172|   219k|        ImGuiWindow* window = g.Windows[n];
 5173|   219k|        IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
 5174|   219k|        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
  ------------------
  |  Branch (5174:13): [True: 72.7k, False: 146k]
  |  Branch (5174:49): [True: 65.6k, False: 7.06k]
  |  Branch (5174:104): [True: 52.7k, False: 12.9k]
  |  Branch (5174:147): [True: 42.4k, False: 10.2k]
  ------------------
 5175|  42.4k|            AddRootWindowToDrawData(window);
 5176|   219k|    }
 5177|   166k|    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
  ------------------
  |  |   87|   166k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5177:21): [True: 110k, False: 55.4k]
  ------------------
 5178|   110k|        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
  ------------------
  |  Branch (5178:13): [True: 25.6k, False: 85.1k]
  |  Branch (5178:46): [True: 23.2k, False: 2.43k]
  ------------------
 5179|  23.2k|            AddRootWindowToDrawData(windows_to_render_top_most[n]);
 5180|       |
 5181|       |    // Draw modal/window whitening backgrounds
 5182|  55.4k|    if (first_render_of_frame)
  ------------------
  |  Branch (5182:9): [True: 55.4k, False: 0]
  ------------------
 5183|  55.4k|        RenderDimmedBackgrounds();
 5184|       |
 5185|       |    // Draw software mouse cursor if requested by io.MouseDrawCursor flag
 5186|  55.4k|    if (g.IO.MouseDrawCursor && first_render_of_frame && g.MouseCursor != ImGuiMouseCursor_None)
  ------------------
  |  Branch (5186:9): [True: 0, False: 55.4k]
  |  Branch (5186:33): [True: 0, False: 0]
  |  Branch (5186:58): [True: 0, False: 0]
  ------------------
 5187|      0|        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2491|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2492|      0|#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
  |  |  ------------------
  |  |  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 5188|       |
 5189|       |    // Setup ImDrawData structures for end-user
 5190|  55.4k|    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
 5191|   110k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (5191:21): [True: 55.4k, False: 55.4k]
  ------------------
 5192|  55.4k|    {
 5193|  55.4k|        ImGuiViewportP* viewport = g.Viewports[n];
 5194|  55.4k|        viewport->DrawDataBuilder.FlattenIntoSingleLayer();
 5195|       |
 5196|       |        // Add foreground ImDrawList (for each active viewport)
 5197|  55.4k|        if (viewport->DrawLists[1] != NULL)
  ------------------
  |  Branch (5197:13): [True: 0, False: 55.4k]
  ------------------
 5198|      0|            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
 5199|       |
 5200|  55.4k|        SetupViewportDrawData(viewport, &viewport->DrawDataBuilder.Layers[0]);
 5201|  55.4k|        ImDrawData* draw_data = viewport->DrawData;
 5202|  55.4k|        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
 5203|  55.4k|        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
 5204|  55.4k|    }
 5205|       |
 5206|  55.4k|    CallContextHooks(&g, ImGuiContextHookType_RenderPost);
 5207|  55.4k|}
_ZN5ImGui12CalcTextSizeEPKcS1_bf:
 5212|   121k|{
 5213|   121k|    ImGuiContext& g = *GImGui;
 5214|       |
 5215|   121k|    const char* text_display_end;
 5216|   121k|    if (hide_text_after_double_hash)
  ------------------
  |  Branch (5216:9): [True: 121k, False: 0]
  ------------------
 5217|   121k|        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
 5218|      0|    else
 5219|      0|        text_display_end = text_end;
 5220|       |
 5221|   121k|    ImFont* font = g.Font;
 5222|   121k|    const float font_size = g.FontSize;
 5223|   121k|    if (text == text_display_end)
  ------------------
  |  Branch (5223:9): [True: 0, False: 121k]
  ------------------
 5224|      0|        return ImVec2(0.0f, font_size);
 5225|   121k|    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);
 5226|       |
 5227|       |    // Round
 5228|       |    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
 5229|       |    // FIXME: Investigate using ceilf or e.g.
 5230|       |    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
 5231|       |    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
 5232|   121k|    text_size.x = IM_FLOOR(text_size.x + 0.99999f);
  ------------------
  |  |  266|   121k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5233|       |
 5234|   121k|    return text_size;
 5235|   121k|}
_ZN5ImGui12IsItemActiveEv:
 5305|   110k|{
 5306|   110k|    ImGuiContext& g = *GImGui;
 5307|   110k|    if (g.ActiveId)
  ------------------
  |  Branch (5307:9): [True: 561, False: 110k]
  ------------------
 5308|    561|        return g.ActiveId == g.LastItemData.ID;
 5309|   110k|    return false;
 5310|   110k|}
_ZN5ImGui31SetActiveIdUsingAllKeyboardKeysEv:
 5414|     31|{
 5415|     31|    ImGuiContext& g = *GImGui;
 5416|     31|    IM_ASSERT(g.ActiveId != 0);
  ------------------
  |  |   23|     31|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5417|     31|    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
 5418|     31|    g.ActiveIdUsingAllKeyboardKeys = true;
 5419|     31|    NavMoveRequestCancel();
 5420|     31|}
_ZN5ImGui12BeginChildExEPKcjRK6ImVec2bi:
 5447|  11.3k|{
 5448|  11.3k|    ImGuiContext& g = *GImGui;
 5449|  11.3k|    ImGuiWindow* parent_window = g.CurrentWindow;
 5450|       |
 5451|  11.3k|    flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoDocking;
 5452|  11.3k|    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag
 5453|       |
 5454|       |    // Size
 5455|  11.3k|    const ImVec2 content_avail = GetContentRegionAvail();
 5456|  11.3k|    ImVec2 size = ImFloor(size_arg);
 5457|  11.3k|    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
  ------------------
  |  Branch (5457:34): [True: 7.93k, False: 3.45k]
  |  Branch (5457:83): [True: 8.76k, False: 2.62k]
  ------------------
 5458|  11.3k|    if (size.x <= 0.0f)
  ------------------
  |  Branch (5458:9): [True: 7.93k, False: 3.45k]
  ------------------
 5459|  7.93k|        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too many issues)
 5460|  11.3k|    if (size.y <= 0.0f)
  ------------------
  |  Branch (5460:9): [True: 8.76k, False: 2.62k]
  ------------------
 5461|  8.76k|        size.y = ImMax(content_avail.y + size.y, 4.0f);
 5462|  11.3k|    SetNextWindowSize(size);
 5463|       |
 5464|       |    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
 5465|  11.3k|    const char* temp_window_name;
 5466|  11.3k|    if (name)
  ------------------
  |  Branch (5466:9): [True: 11.3k, False: 0]
  ------------------
 5467|  11.3k|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s_%08X", parent_window->Name, name, id);
 5468|      0|    else
 5469|      0|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%08X", parent_window->Name, id);
 5470|       |
 5471|  11.3k|    const float backup_border_size = g.Style.ChildBorderSize;
 5472|  11.3k|    if (!border)
  ------------------
  |  Branch (5472:9): [True: 0, False: 11.3k]
  ------------------
 5473|      0|        g.Style.ChildBorderSize = 0.0f;
 5474|  11.3k|    bool ret = Begin(temp_window_name, NULL, flags);
 5475|  11.3k|    g.Style.ChildBorderSize = backup_border_size;
 5476|       |
 5477|  11.3k|    ImGuiWindow* child_window = g.CurrentWindow;
 5478|  11.3k|    child_window->ChildId = id;
 5479|  11.3k|    child_window->AutoFitChildAxises = (ImS8)auto_fit_axises;
 5480|       |
 5481|       |    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
 5482|       |    // While this is not really documented/defined, it seems that the expected thing to do.
 5483|  11.3k|    if (child_window->BeginCount == 1)
  ------------------
  |  Branch (5483:9): [True: 11.3k, False: 0]
  ------------------
 5484|  11.3k|        parent_window->DC.CursorPos = child_window->Pos;
 5485|       |
 5486|       |    // Process navigation-in immediately so NavInit can run on first frame
 5487|  11.3k|    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavHasScroll))
  ------------------
  |  Branch (5487:9): [True: 0, False: 11.3k]
  |  Branch (5487:34): [True: 0, False: 0]
  |  Branch (5487:79): [True: 0, False: 0]
  |  Branch (5487:124): [True: 0, False: 0]
  ------------------
 5488|      0|    {
 5489|      0|        FocusWindow(child_window);
 5490|      0|        NavInitWindow(child_window, false);
 5491|      0|        SetActiveID(id + 1, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
 5492|      0|        g.ActiveIdSource = ImGuiInputSource_Nav;
 5493|      0|    }
 5494|  11.3k|    return ret;
 5495|  11.3k|}
_ZN5ImGui10BeginChildEPKcRK6ImVec2bi:
 5498|  11.3k|{
 5499|  11.3k|    ImGuiWindow* window = GetCurrentWindow();
 5500|  11.3k|    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
 5501|  11.3k|}
_ZN5ImGui8EndChildEv:
 5510|  11.3k|{
 5511|  11.3k|    ImGuiContext& g = *GImGui;
 5512|  11.3k|    ImGuiWindow* window = g.CurrentWindow;
 5513|       |
 5514|  11.3k|    IM_ASSERT(g.WithinEndChild == false);
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5515|  11.3k|    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() calls
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5516|       |
 5517|  11.3k|    g.WithinEndChild = true;
 5518|  11.3k|    if (window->BeginCount > 1)
  ------------------
  |  Branch (5518:9): [True: 0, False: 11.3k]
  ------------------
 5519|      0|    {
 5520|      0|        End();
 5521|      0|    }
 5522|  11.3k|    else
 5523|  11.3k|    {
 5524|  11.3k|        ImVec2 sz = window->Size;
 5525|  11.3k|        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
  ------------------
  |  Branch (5525:13): [True: 7.93k, False: 3.45k]
  ------------------
 5526|  7.93k|            sz.x = ImMax(4.0f, sz.x);
 5527|  11.3k|        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
  ------------------
  |  Branch (5527:13): [True: 8.76k, False: 2.62k]
  ------------------
 5528|  8.76k|            sz.y = ImMax(4.0f, sz.y);
 5529|  11.3k|        End();
 5530|       |
 5531|  11.3k|        ImGuiWindow* parent_window = g.CurrentWindow;
 5532|  11.3k|        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
 5533|  11.3k|        ItemSize(sz);
 5534|  11.3k|        if ((window->DC.NavLayersActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
  ------------------
  |  Branch (5534:14): [True: 0, False: 11.3k]
  |  Branch (5534:53): [True: 9.02k, False: 2.36k]
  |  Branch (5534:81): [True: 9.02k, False: 0]
  ------------------
 5535|  9.02k|        {
 5536|  9.02k|            ItemAdd(bb, window->ChildId);
 5537|  9.02k|            RenderNavHighlight(bb, window->ChildId);
 5538|       |
 5539|       |            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
 5540|  9.02k|            if (window->DC.NavLayersActiveMask == 0 && window == g.NavWindow)
  ------------------
  |  Branch (5540:17): [True: 9.02k, False: 0]
  |  Branch (5540:56): [True: 4.48k, False: 4.53k]
  ------------------
 5541|  4.48k|                RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
 5542|  9.02k|        }
 5543|  2.36k|        else
 5544|  2.36k|        {
 5545|       |            // Not navigable into
 5546|  2.36k|            ItemAdd(bb, 0);
 5547|  2.36k|        }
 5548|  11.3k|        if (g.HoveredWindow == window)
  ------------------
  |  Branch (5548:13): [True: 3, False: 11.3k]
  ------------------
 5549|      3|            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
 5550|  11.3k|    }
 5551|  11.3k|    g.WithinEndChild = false;
 5552|  11.3k|    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
 5553|  11.3k|}
_ZN5ImGui14FindWindowByIDEj:
 5584|   132k|{
 5585|   132k|    ImGuiContext& g = *GImGui;
 5586|   132k|    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
 5587|   132k|}
_ZN5ImGui16FindWindowByNameEPKc:
 5590|   132k|{
 5591|   132k|    ImGuiID id = ImHashStr(name);
 5592|   132k|    return FindWindowByID(id);
 5593|   132k|}
_ZN5ImGui30UpdateWindowParentAndRootLinksEP11ImGuiWindowiS1_:
 6306|   132k|{
 6307|   132k|    window->ParentWindow = parent_window;
 6308|   132k|    window->RootWindow = window->RootWindowPopupTree = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
 6309|   132k|    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (6309:9): [True: 11.3k, False: 121k]
  |  Branch (6309:26): [True: 11.3k, False: 0]
  |  Branch (6309:68): [True: 11.3k, False: 0]
  ------------------
 6310|  11.3k|    {
 6311|  11.3k|        window->RootWindowDockTree = parent_window->RootWindowDockTree;
 6312|  11.3k|        if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6312:13): [True: 11.3k, False: 0]
  |  Branch (6312:38): [True: 11.3k, False: 0]
  ------------------
 6313|  11.3k|            window->RootWindow = parent_window->RootWindow;
 6314|  11.3k|    }
 6315|   132k|    if (parent_window && (flags & ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (6315:9): [True: 11.3k, False: 121k]
  |  Branch (6315:26): [True: 0, False: 11.3k]
  ------------------
 6316|      0|        window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
 6317|   132k|    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) // FIXME: simply use _NoTitleBar ?
  ------------------
  |  Branch (6317:9): [True: 11.3k, False: 121k]
  |  Branch (6317:26): [True: 11.3k, False: 0]
  |  Branch (6317:63): [True: 11.3k, False: 0]
  ------------------
 6318|  11.3k|        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
 6319|   132k|    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
  ------------------
  |  Branch (6319:12): [True: 0, False: 132k]
  ------------------
 6320|      0|    {
 6321|      0|        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6322|      0|        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
 6323|      0|    }
 6324|   132k|}
_ZN5ImGui5BeginEPKcPbi:
 6366|   132k|{
 6367|   132k|    ImGuiContext& g = *GImGui;
 6368|   132k|    const ImGuiStyle& style = g.Style;
 6369|   132k|    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6370|   132k|    IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6371|   132k|    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6372|       |
 6373|       |    // Find or create
 6374|   132k|    ImGuiWindow* window = FindWindowByName(name);
 6375|   132k|    const bool window_just_created = (window == NULL);
 6376|   132k|    if (window_just_created)
  ------------------
  |  Branch (6376:9): [True: 4, False: 132k]
  ------------------
 6377|      4|        window = CreateNewWindow(name, flags);
 6378|       |
 6379|       |    // Automatically disable manual moving/resizing when NoInputs is set
 6380|   132k|    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
  ------------------
  |  Branch (6380:9): [True: 10.2k, False: 122k]
  ------------------
 6381|  10.2k|        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
 6382|       |
 6383|   132k|    if (flags & ImGuiWindowFlags_NavFlattened)
  ------------------
  |  Branch (6383:9): [True: 0, False: 132k]
  ------------------
 6384|   132k|        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6385|       |
 6386|   132k|    const int current_frame = g.FrameCount;
 6387|   132k|    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
 6388|   132k|    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);
  ------------------
  |  Branch (6388:33): [True: 65.6k, False: 66.8k]
  |  Branch (6388:67): [True: 55.4k, False: 10.2k]
  ------------------
 6389|       |
 6390|       |    // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
 6391|   132k|    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
 6392|   132k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6392:9): [True: 0, False: 132k]
  ------------------
 6393|      0|    {
 6394|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 6395|      0|        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
 6396|      0|        window_just_activated_by_user |= (window != popup_ref.Window);
 6397|      0|    }
 6398|       |
 6399|       |    // Update Flags, LastFrameActive, BeginOrderXXX fields
 6400|   132k|    const bool window_was_appearing = window->Appearing;
 6401|   132k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6401:9): [True: 132k, False: 0]
  ------------------
 6402|   132k|    {
 6403|   132k|        UpdateWindowInFocusOrderList(window, window_just_created, flags);
 6404|   132k|        window->Appearing = window_just_activated_by_user;
 6405|   132k|        if (window->Appearing)
  ------------------
  |  Branch (6405:13): [True: 208, False: 132k]
  ------------------
 6406|    208|            SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6407|   132k|        window->FlagsPreviousFrame = window->Flags;
 6408|   132k|        window->Flags = (ImGuiWindowFlags)flags;
 6409|   132k|        window->LastFrameActive = current_frame;
 6410|   132k|        window->LastTimeActive = (float)g.Time;
 6411|   132k|        window->BeginOrderWithinParent = 0;
 6412|   132k|        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
 6413|   132k|    }
 6414|      0|    else
 6415|      0|    {
 6416|      0|        flags = window->Flags;
 6417|      0|    }
 6418|       |
 6419|       |    // Docking
 6420|       |    // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
 6421|   132k|    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6422|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
  ------------------
  |  Branch (6422:9): [True: 0, False: 132k]
  ------------------
 6423|      0|        SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
 6424|   132k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6424:9): [True: 132k, False: 0]
  ------------------
 6425|   132k|    {
 6426|   132k|        bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
  ------------------
  |  Branch (6426:31): [True: 0, False: 132k]
  |  Branch (6426:54): [True: 0, False: 132k]
  ------------------
 6427|   132k|        bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
  ------------------
  |  Branch (6427:35): [True: 132k, False: 0]
  |  Branch (6427:53): [True: 0, False: 132k]
  ------------------
 6428|   132k|        bool dock_node_was_visible = window->DockNodeIsVisible;
 6429|   132k|        bool dock_tab_was_visible = window->DockTabIsVisible;
 6430|   132k|        if (has_dock_node || new_auto_dock_node)
  ------------------
  |  Branch (6430:13): [True: 0, False: 132k]
  |  Branch (6430:30): [True: 0, False: 132k]
  ------------------
 6431|      0|        {
 6432|      0|            BeginDocked(window, p_open);
 6433|      0|            flags = window->Flags;
 6434|      0|            if (window->DockIsActive)
  ------------------
  |  Branch (6434:17): [True: 0, False: 0]
  ------------------
 6435|      0|            {
 6436|      0|                IM_ASSERT(window->DockNode != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6437|      0|                g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
 6438|      0|            }
 6439|       |
 6440|       |            // Amend the Appearing flag
 6441|      0|            if (window->DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window->Appearing && !window_was_appearing)
  ------------------
  |  Branch (6441:17): [True: 0, False: 0]
  |  Branch (6441:45): [True: 0, False: 0]
  |  Branch (6441:70): [True: 0, False: 0]
  |  Branch (6441:95): [True: 0, False: 0]
  |  Branch (6441:117): [True: 0, False: 0]
  ------------------
 6442|      0|            {
 6443|      0|                window->Appearing = true;
 6444|      0|                SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6445|      0|            }
 6446|      0|        }
 6447|   132k|        else
 6448|   132k|        {
 6449|   132k|            window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
 6450|   132k|        }
 6451|   132k|    }
 6452|       |
 6453|       |    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
 6454|   132k|    ImGuiWindow* parent_window_in_stack = (window->DockIsActive && window->DockNode->HostWindow) ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
  ------------------
  |  Branch (6454:44): [True: 0, False: 132k]
  |  Branch (6454:68): [True: 0, False: 0]
  |  Branch (6454:131): [True: 65.6k, False: 66.8k]
  ------------------
 6455|   132k|    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
  ------------------
  |  Branch (6455:34): [True: 132k, False: 0]
  |  Branch (6455:62): [True: 11.3k, False: 121k]
  ------------------
 6456|   132k|    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6457|       |
 6458|       |    // We allow window memory to be compacted so recreate the base stack when needed.
 6459|   132k|    if (window->IDStack.Size == 0)
  ------------------
  |  Branch (6459:9): [True: 0, False: 132k]
  ------------------
 6460|      0|        window->IDStack.push_back(window->ID);
 6461|       |
 6462|       |    // Add to stack
 6463|       |    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
 6464|   132k|    g.CurrentWindow = window;
 6465|   132k|    ImGuiWindowStackData window_stack_data;
 6466|   132k|    window_stack_data.Window = window;
 6467|   132k|    window_stack_data.ParentLastItemDataBackup = g.LastItemData;
 6468|   132k|    window_stack_data.StackSizesOnBegin.SetToCurrentState();
 6469|   132k|    g.CurrentWindowStack.push_back(window_stack_data);
 6470|   132k|    if (flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (6470:9): [True: 0, False: 132k]
  ------------------
 6471|      0|        g.BeginMenuCount++;
 6472|       |
 6473|       |    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
 6474|   132k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6474:9): [True: 132k, False: 0]
  ------------------
 6475|   132k|    {
 6476|   132k|        UpdateWindowParentAndRootLinks(window, flags, parent_window);
 6477|   132k|        window->ParentWindowInBeginStack = parent_window_in_stack;
 6478|   132k|    }
 6479|       |
 6480|       |    // Add to focus scope stack
 6481|   132k|    PushFocusScope(window->ID);
 6482|   132k|    window->NavRootFocusScopeId = g.CurrentFocusScopeId;
 6483|   132k|    g.CurrentWindow = NULL;
 6484|       |
 6485|       |    // Add to popup stack
 6486|   132k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6486:9): [True: 0, False: 132k]
  ------------------
 6487|      0|    {
 6488|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 6489|      0|        popup_ref.Window = window;
 6490|      0|        popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
 6491|      0|        g.BeginPopupStack.push_back(popup_ref);
 6492|      0|        window->PopupId = popup_ref.PopupId;
 6493|      0|    }
 6494|       |
 6495|       |    // Process SetNextWindow***() calls
 6496|       |    // (FIXME: Consider splitting the HasXXX flags into X/Y components
 6497|   132k|    bool window_pos_set_by_api = false;
 6498|   132k|    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
 6499|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
  ------------------
  |  Branch (6499:9): [True: 10.2k, False: 122k]
  ------------------
 6500|  10.2k|    {
 6501|  10.2k|        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
 6502|  10.2k|        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
  ------------------
  |  Branch (6502:13): [True: 10.2k, False: 0]
  |  Branch (6502:38): [True: 10.2k, False: 0]
  ------------------
 6503|  10.2k|        {
 6504|       |            // May be processed on the next frame if this is our first frame and we are measuring size
 6505|       |            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
 6506|  10.2k|            window->SetWindowPosVal = g.NextWindowData.PosVal;
 6507|  10.2k|            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
 6508|  10.2k|            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 6509|  10.2k|        }
 6510|      0|        else
 6511|      0|        {
 6512|      0|            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
 6513|      0|        }
 6514|  10.2k|    }
 6515|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
  ------------------
  |  Branch (6515:9): [True: 66.8k, False: 65.6k]
  ------------------
 6516|  66.8k|    {
 6517|  66.8k|        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
  ------------------
  |  Branch (6517:36): [True: 11.3k, False: 55.4k]
  |  Branch (6517:106): [True: 11.3k, False: 0]
  ------------------
 6518|  66.8k|        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
  ------------------
  |  Branch (6518:36): [True: 11.3k, False: 55.4k]
  |  Branch (6518:106): [True: 11.3k, False: 0]
  ------------------
 6519|  66.8k|        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
 6520|  66.8k|    }
 6521|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
  ------------------
  |  Branch (6521:9): [True: 0, False: 132k]
  ------------------
 6522|      0|    {
 6523|      0|        if (g.NextWindowData.ScrollVal.x >= 0.0f)
  ------------------
  |  Branch (6523:13): [True: 0, False: 0]
  ------------------
 6524|      0|        {
 6525|      0|            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
 6526|      0|            window->ScrollTargetCenterRatio.x = 0.0f;
 6527|      0|        }
 6528|      0|        if (g.NextWindowData.ScrollVal.y >= 0.0f)
  ------------------
  |  Branch (6528:13): [True: 0, False: 0]
  ------------------
 6529|      0|        {
 6530|      0|            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
 6531|      0|            window->ScrollTargetCenterRatio.y = 0.0f;
 6532|      0|        }
 6533|      0|    }
 6534|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
  ------------------
  |  Branch (6534:9): [True: 0, False: 132k]
  ------------------
 6535|      0|        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
 6536|   132k|    else if (first_begin_of_the_frame)
  ------------------
  |  Branch (6536:14): [True: 132k, False: 0]
  ------------------
 6537|   132k|        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
 6538|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
  ------------------
  |  Branch (6538:9): [True: 0, False: 132k]
  ------------------
 6539|      0|        window->WindowClass = g.NextWindowData.WindowClass;
 6540|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
  ------------------
  |  Branch (6540:9): [True: 0, False: 132k]
  ------------------
 6541|      0|        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
 6542|   132k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
  ------------------
  |  Branch (6542:9): [True: 0, False: 132k]
  ------------------
 6543|      0|        FocusWindow(window);
 6544|   132k|    if (window->Appearing)
  ------------------
  |  Branch (6544:9): [True: 208, False: 132k]
  ------------------
 6545|    208|        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);
 6546|       |
 6547|       |    // When reusing window again multiple times a frame, just append content (don't need to setup again)
 6548|   132k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6548:9): [True: 132k, False: 0]
  ------------------
 6549|   132k|    {
 6550|       |        // Initialize
 6551|   132k|        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
  ------------------
  |  Branch (6551:46): [True: 11.3k, False: 121k]
  |  Branch (6551:88): [True: 0, False: 11.3k]
  ------------------
 6552|   132k|        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
 6553|   132k|        window->Active = true;
 6554|   132k|        window->HasCloseButton = (p_open != NULL);
 6555|   132k|        window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
 6556|   132k|        window->IDStack.resize(1);
 6557|   132k|        window->DrawList->_ResetForNewFrame();
 6558|   132k|        window->DC.CurrentTableIdx = -1;
 6559|   132k|        if (flags & ImGuiWindowFlags_DockNodeHost)
  ------------------
  |  Branch (6559:13): [True: 0, False: 132k]
  ------------------
 6560|      0|        {
 6561|      0|            window->DrawList->ChannelsSplit(2);
 6562|      0|            window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
  ------------------
  |  | 1556|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 6563|      0|        }
 6564|       |
 6565|       |        // Restore buffer capacity when woken from a compacted state, to avoid
 6566|   132k|        if (window->MemoryCompacted)
  ------------------
  |  Branch (6566:13): [True: 0, False: 132k]
  ------------------
 6567|      0|            GcAwakeTransientWindowBuffers(window);
 6568|       |
 6569|       |        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
 6570|       |        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
 6571|   132k|        bool window_title_visible_elsewhere = false;
 6572|   132k|        if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
  ------------------
  |  Branch (6572:14): [True: 132k, False: 4]
  |  Branch (6572:34): [True: 0, False: 132k]
  |  Branch (6572:73): [True: 0, False: 132k]
  ------------------
 6573|      0|            window_title_visible_elsewhere = true;
 6574|   132k|        else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
  ------------------
  |  Branch (6574:18): [True: 124k, False: 7.66k]
  |  Branch (6574:54): [True: 114k, False: 10.2k]
  ------------------
 6575|   114k|            window_title_visible_elsewhere = true;
 6576|   132k|        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
  ------------------
  |  Branch (6576:13): [True: 114k, False: 17.9k]
  |  Branch (6576:47): [True: 114k, False: 0]
  |  Branch (6576:71): [True: 0, False: 114k]
  ------------------
 6577|      0|        {
 6578|      0|            size_t buf_len = (size_t)window->NameBufLen;
 6579|      0|            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
 6580|      0|            window->NameBufLen = (int)buf_len;
 6581|      0|        }
 6582|       |
 6583|       |        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
 6584|       |
 6585|       |        // Update contents size from last frame for auto-fitting (or use explicit size)
 6586|   132k|        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
 6587|       |
 6588|       |        // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
 6589|       |        // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
 6590|       |        // it has a single usage before this code block and may be set below before it is finally checked.
 6591|   132k|        if (window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (6591:13): [True: 4.32k, False: 128k]
  ------------------
 6592|  4.32k|            window->HiddenFramesCanSkipItems--;
 6593|   132k|        if (window->HiddenFramesCannotSkipItems > 0)
  ------------------
  |  Branch (6593:13): [True: 3, False: 132k]
  ------------------
 6594|      3|            window->HiddenFramesCannotSkipItems--;
 6595|   132k|        if (window->HiddenFramesForRenderOnly > 0)
  ------------------
  |  Branch (6595:13): [True: 0, False: 132k]
  ------------------
 6596|      0|            window->HiddenFramesForRenderOnly--;
 6597|       |
 6598|       |        // Hide new windows for one frame until they calculate their size
 6599|   132k|        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
  ------------------
  |  Branch (6599:13): [True: 4, False: 132k]
  |  Branch (6599:37): [True: 2, False: 2]
  |  Branch (6599:66): [True: 0, False: 2]
  ------------------
 6600|      2|            window->HiddenFramesCannotSkipItems = 1;
 6601|       |
 6602|       |        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
 6603|       |        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
 6604|   132k|        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
  ------------------
  |  Branch (6604:13): [True: 208, False: 132k]
  |  Branch (6604:46): [True: 0, False: 208]
  ------------------
 6605|      0|        {
 6606|      0|            window->HiddenFramesCannotSkipItems = 1;
 6607|      0|            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
  ------------------
  |  Branch (6607:17): [True: 0, False: 0]
  ------------------
 6608|      0|            {
 6609|      0|                if (!window_size_x_set_by_api)
  ------------------
  |  Branch (6609:21): [True: 0, False: 0]
  ------------------
 6610|      0|                    window->Size.x = window->SizeFull.x = 0.f;
 6611|      0|                if (!window_size_y_set_by_api)
  ------------------
  |  Branch (6611:21): [True: 0, False: 0]
  ------------------
 6612|      0|                    window->Size.y = window->SizeFull.y = 0.f;
 6613|      0|                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
 6614|      0|            }
 6615|      0|        }
 6616|       |
 6617|       |        // SELECT VIEWPORT
 6618|       |        // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.
 6619|       |
 6620|   132k|        WindowSelectViewport(window);
 6621|   132k|        SetCurrentViewport(window, window->Viewport);
 6622|   132k|        window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (6622:32): [True: 0, False: 132k]
  ------------------
 6623|   132k|        SetCurrentWindow(window);
 6624|   132k|        flags = window->Flags;
 6625|       |
 6626|       |        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
 6627|       |        // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.
 6628|       |
 6629|   132k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (6629:13): [True: 11.3k, False: 121k]
  ------------------
 6630|  11.3k|            window->WindowBorderSize = style.ChildBorderSize;
 6631|   121k|        else
 6632|   121k|            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
  ------------------
  |  Branch (6632:41): [True: 0, False: 121k]
  |  Branch (6632:106): [True: 0, False: 0]
  ------------------
 6633|   132k|        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
  ------------------
  |  Branch (6633:13): [True: 132k, False: 0]
  |  Branch (6633:38): [True: 11.3k, False: 121k]
  |  Branch (6633:80): [True: 11.3k, False: 0]
  |  Branch (6633:161): [True: 0, False: 11.3k]
  ------------------
 6634|      0|            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
  ------------------
  |  Branch (6634:50): [True: 0, False: 0]
  ------------------
 6635|   132k|        else
 6636|   132k|            window->WindowPadding = style.WindowPadding;
 6637|       |
 6638|       |        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
 6639|   132k|        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
 6640|   132k|        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
 6641|       |
 6642|   132k|        bool use_current_size_for_scrollbar_x = window_just_created;
 6643|   132k|        bool use_current_size_for_scrollbar_y = window_just_created;
 6644|       |
 6645|       |        // Collapse window by double-clicking on title bar
 6646|       |        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
 6647|   132k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
  ------------------
  |  Branch (6647:13): [True: 110k, False: 21.6k]
  |  Branch (6647:55): [True: 110k, False: 0]
  |  Branch (6647:97): [True: 110k, False: 0]
  ------------------
 6648|   110k|        {
 6649|       |            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
 6650|   110k|            ImRect title_bar_rect = window->TitleBarRect();
 6651|   110k|            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseClickedCount[0] == 2)
  ------------------
  |  Branch (6651:17): [True: 1.11k, False: 109k]
  |  Branch (6651:46): [True: 1.11k, False: 0]
  |  Branch (6651:66): [True: 179, False: 931]
  |  Branch (6651:99): [True: 102, False: 77]
  |  Branch (6651:162): [True: 3, False: 99]
  ------------------
 6652|      3|                window->WantCollapseToggle = true;
 6653|   110k|            if (window->WantCollapseToggle)
  ------------------
  |  Branch (6653:17): [True: 3, False: 110k]
  ------------------
 6654|      3|            {
 6655|      3|                window->Collapsed = !window->Collapsed;
 6656|      3|                if (!window->Collapsed)
  ------------------
  |  Branch (6656:21): [True: 1, False: 2]
  ------------------
 6657|      1|                    use_current_size_for_scrollbar_y = true;
 6658|      3|                MarkIniSettingsDirty(window);
 6659|      3|            }
 6660|   110k|        }
 6661|  21.6k|        else
 6662|  21.6k|        {
 6663|  21.6k|            window->Collapsed = false;
 6664|  21.6k|        }
 6665|   132k|        window->WantCollapseToggle = false;
 6666|       |
 6667|       |        // SIZE
 6668|       |
 6669|       |        // Outer Decoration Sizes
 6670|       |        // (we need to clear ScrollbarSize immediatly as CalcWindowAutoFitSize() needs it and can be called from other locations).
 6671|   132k|        const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
 6672|   132k|        window->DecoOuterSizeX1 = 0.0f;
 6673|   132k|        window->DecoOuterSizeX2 = 0.0f;
 6674|   132k|        window->DecoOuterSizeY1 = window->TitleBarHeight() + window->MenuBarHeight();
 6675|   132k|        window->DecoOuterSizeY2 = 0.0f;
 6676|   132k|        window->ScrollbarSizes = ImVec2(0.0f, 0.0f);
 6677|       |
 6678|       |        // Calculate auto-fit size, handle automatic resize
 6679|   132k|        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
 6680|   132k|        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
  ------------------
  |  Branch (6680:13): [True: 10.2k, False: 122k]
  |  Branch (6680:60): [True: 10.2k, False: 0]
  ------------------
 6681|  10.2k|        {
 6682|       |            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
 6683|  10.2k|            if (!window_size_x_set_by_api)
  ------------------
  |  Branch (6683:17): [True: 10.2k, False: 0]
  ------------------
 6684|  10.2k|            {
 6685|  10.2k|                window->SizeFull.x = size_auto_fit.x;
 6686|  10.2k|                use_current_size_for_scrollbar_x = true;
 6687|  10.2k|            }
 6688|  10.2k|            if (!window_size_y_set_by_api)
  ------------------
  |  Branch (6688:17): [True: 10.2k, False: 0]
  ------------------
 6689|  10.2k|            {
 6690|  10.2k|                window->SizeFull.y = size_auto_fit.y;
 6691|  10.2k|                use_current_size_for_scrollbar_y = true;
 6692|  10.2k|            }
 6693|  10.2k|        }
 6694|   122k|        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6694:18): [True: 2, False: 122k]
  |  Branch (6694:48): [True: 0, False: 122k]
  ------------------
 6695|      2|        {
 6696|       |            // Auto-fit may only grow window during the first few frames
 6697|       |            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
 6698|      2|            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
  ------------------
  |  Branch (6698:17): [True: 2, False: 0]
  |  Branch (6698:46): [True: 2, False: 0]
  ------------------
 6699|      2|            {
 6700|      2|                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
  ------------------
  |  Branch (6700:38): [True: 2, False: 0]
  ------------------
 6701|      2|                use_current_size_for_scrollbar_x = true;
 6702|      2|            }
 6703|      2|            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6703:17): [True: 2, False: 0]
  |  Branch (6703:46): [True: 2, False: 0]
  ------------------
 6704|      2|            {
 6705|      2|                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
  ------------------
  |  Branch (6705:38): [True: 2, False: 0]
  ------------------
 6706|      2|                use_current_size_for_scrollbar_y = true;
 6707|      2|            }
 6708|      2|            if (!window->Collapsed)
  ------------------
  |  Branch (6708:17): [True: 2, False: 0]
  ------------------
 6709|      2|                MarkIniSettingsDirty(window);
 6710|      2|        }
 6711|       |
 6712|       |        // Apply minimum/maximum window size constraints and final size
 6713|   132k|        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
 6714|   132k|        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;
  ------------------
  |  Branch (6714:24): [True: 44.0k, False: 88.4k]
  |  Branch (6714:45): [True: 44.0k, False: 0]
  ------------------
 6715|       |
 6716|       |        // POSITION
 6717|       |
 6718|       |        // Popup latch its initial position, will position itself when it appears next frame
 6719|   132k|        if (window_just_activated_by_user)
  ------------------
  |  Branch (6719:13): [True: 208, False: 132k]
  ------------------
 6720|    208|        {
 6721|    208|            window->AutoPosLastDirection = ImGuiDir_None;
 6722|    208|            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
  ------------------
  |  Branch (6722:17): [True: 0, False: 208]
  |  Branch (6722:58): [True: 0, False: 0]
  |  Branch (6722:95): [True: 0, False: 0]
  ------------------
 6723|      0|                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
 6724|    208|        }
 6725|       |
 6726|       |        // Position child window
 6727|   132k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (6727:13): [True: 11.3k, False: 121k]
  ------------------
 6728|  11.3k|        {
 6729|  11.3k|            IM_ASSERT(parent_window && parent_window->Active);
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6730|  11.3k|            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
 6731|  11.3k|            parent_window->DC.ChildWindows.push_back(window);
 6732|  11.3k|            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (6732:17): [True: 11.3k, False: 0]
  |  Branch (6732:54): [True: 11.3k, False: 0]
  |  Branch (6732:80): [True: 11.3k, False: 0]
  ------------------
 6733|  11.3k|                window->Pos = parent_window->DC.CursorPos;
 6734|  11.3k|        }
 6735|       |
 6736|   132k|        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
  ------------------
  |  Branch (6736:45): [True: 10.2k, False: 122k]
  |  Branch (6736:85): [True: 10.2k, False: 1]
  ------------------
 6737|   132k|        if (window_pos_with_pivot)
  ------------------
  |  Branch (6737:13): [True: 10.2k, False: 122k]
  ------------------
 6738|  10.2k|            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
 6739|   122k|        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
  ------------------
  |  Branch (6739:18): [True: 0, False: 122k]
  ------------------
 6740|      0|            window->Pos = FindBestWindowPosForPopup(window);
 6741|   122k|        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
  ------------------
  |  Branch (6741:18): [True: 0, False: 122k]
  |  Branch (6741:59): [True: 0, False: 0]
  |  Branch (6741:85): [True: 0, False: 0]
  ------------------
 6742|      0|            window->Pos = FindBestWindowPosForPopup(window);
 6743|   122k|        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (6743:18): [True: 0, False: 122k]
  |  Branch (6743:61): [True: 0, False: 0]
  |  Branch (6743:87): [True: 0, False: 0]
  ------------------
 6744|      0|            window->Pos = FindBestWindowPosForPopup(window);
 6745|       |
 6746|       |        // Late create viewport if we don't fit within our current host viewport.
 6747|   132k|        if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_Minimized))
  ------------------
  |  Branch (6747:13): [True: 0, False: 132k]
  |  Branch (6747:64): [True: 0, False: 0]
  |  Branch (6747:90): [True: 0, False: 0]
  ------------------
 6748|      0|            if (!window->Viewport->GetMainRect().Contains(window->Rect()))
  ------------------
  |  Branch (6748:17): [True: 0, False: 0]
  ------------------
 6749|      0|            {
 6750|       |                // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
 6751|       |                //ImGuiViewport* old_viewport = window->Viewport;
 6752|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
 6753|       |
 6754|       |                // FIXME-DPI
 6755|       |                //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
 6756|      0|                SetCurrentViewport(window, window->Viewport);
 6757|      0|                window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (6757:40): [True: 0, False: 0]
  ------------------
 6758|      0|                SetCurrentWindow(window);
 6759|      0|            }
 6760|       |
 6761|   132k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6761:13): [True: 0, False: 132k]
  ------------------
 6762|      0|            WindowSyncOwnedViewport(window, parent_window_in_stack);
 6763|       |
 6764|       |        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
 6765|       |        // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
 6766|   132k|        ImRect viewport_rect(window->Viewport->GetMainRect());
 6767|   132k|        ImRect viewport_work_rect(window->Viewport->GetWorkRect());
 6768|   132k|        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
 6769|   132k|        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);
 6770|       |
 6771|       |        // Clamp position/size so window stays visible within its viewport or monitor
 6772|       |        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
 6773|       |        // FIXME: Similar to code in GetWindowAllowedExtentRect()
 6774|   132k|        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (6774:13): [True: 122k, False: 10.2k]
  |  Branch (6774:39): [True: 110k, False: 11.3k]
  ------------------
 6775|   110k|        {
 6776|   110k|            if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
  ------------------
  |  Branch (6776:17): [True: 110k, False: 0]
  |  Branch (6776:43): [True: 110k, False: 0]
  |  Branch (6776:75): [True: 110k, False: 0]
  ------------------
 6777|   110k|            {
 6778|   110k|                ClampWindowPos(window, visibility_rect);
 6779|   110k|            }
 6780|      0|            else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
  ------------------
  |  Branch (6780:22): [True: 0, False: 0]
  |  Branch (6780:47): [True: 0, False: 0]
  ------------------
 6781|      0|            {
 6782|       |                // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
 6783|      0|                const ImGuiPlatformMonitor* monitor = GetViewportPlatformMonitor(window->Viewport);
 6784|      0|                visibility_rect.Min = monitor->WorkPos + visibility_padding;
 6785|      0|                visibility_rect.Max = monitor->WorkPos + monitor->WorkSize - visibility_padding;
 6786|      0|                ClampWindowPos(window, visibility_rect);
 6787|      0|            }
 6788|   110k|        }
 6789|   132k|        window->Pos = ImFloor(window->Pos);
 6790|       |
 6791|       |        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
 6792|       |        // Large values tend to lead to variety of artifacts and are not recommended.
 6793|   132k|        if (window->ViewportOwned || window->DockIsActive)
  ------------------
  |  Branch (6793:13): [True: 0, False: 132k]
  |  Branch (6793:38): [True: 0, False: 132k]
  ------------------
 6794|      0|            window->WindowRounding = 0.0f;
 6795|   132k|        else
 6796|   132k|            window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
  ------------------
  |  Branch (6796:38): [True: 11.3k, False: 121k]
  |  Branch (6796:102): [True: 0, False: 121k]
  |  Branch (6796:138): [True: 0, False: 0]
  ------------------
 6797|       |
 6798|       |        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
 6799|       |        //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
 6800|       |        //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);
 6801|       |
 6802|       |        // Apply window focus (new and reactivated windows are moved to front)
 6803|   132k|        bool want_focus = false;
 6804|   132k|        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
  ------------------
  |  Branch (6804:13): [True: 208, False: 132k]
  |  Branch (6804:46): [True: 4, False: 204]
  ------------------
 6805|      4|        {
 6806|      4|            if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6806:17): [True: 0, False: 4]
  ------------------
 6807|      0|                want_focus = true;
 6808|      4|            else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (6808:23): [True: 0, False: 4]
  |  Branch (6808:47): [True: 2, False: 2]
  |  Branch (6808:95): [True: 2, False: 0]
  ------------------
 6809|      2|                want_focus = true;
 6810|       |
 6811|      4|            ImGuiWindow* modal = GetTopMostPopupModal();
 6812|      4|            if (modal != NULL && !IsWindowWithinBeginStackOf(window, modal))
  ------------------
  |  Branch (6812:17): [True: 0, False: 4]
  |  Branch (6812:34): [True: 0, False: 0]
  ------------------
 6813|      0|            {
 6814|       |                // Avoid focusing a window that is created outside of active modal. This will prevent active modal from being closed.
 6815|       |                // Since window is not focused it would reappear at the same display position like the last time it was visible.
 6816|       |                // In case of completely new windows it would go to the top (over current modal), but input to such window would still be blocked by modal.
 6817|       |                // Position window behind a modal that is not a begin-parent of this window.
 6818|      0|                want_focus = false;
 6819|      0|                if (window == window->RootWindow)
  ------------------
  |  Branch (6819:21): [True: 0, False: 0]
  ------------------
 6820|      0|                {
 6821|      0|                    ImGuiWindow* blocking_modal = FindBlockingModal(window);
 6822|      0|                    IM_ASSERT(blocking_modal != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6823|      0|                    BringWindowToDisplayBehind(window, blocking_modal);
 6824|      0|                }
 6825|      0|            }
 6826|      4|        }
 6827|       |
 6828|       |        // [Test Engine] Register whole window in the item system
 6829|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 6830|       |        if (g.TestEngineHookItems)
 6831|       |        {
 6832|       |            IM_ASSERT(window->IDStack.Size == 1);
 6833|       |            window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
 6834|       |            IMGUI_TEST_ENGINE_ITEM_ADD(window->Rect(), window->ID);
 6835|       |            IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
 6836|       |            window->IDStack.Size = 1;
 6837|       |        }
 6838|       |#endif
 6839|       |
 6840|       |        // Decide if we are going to handle borders and resize grips
 6841|   132k|        const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);
  ------------------
  |  Branch (6841:55): [True: 0, False: 132k]
  |  Branch (6841:81): [True: 132k, False: 0]
  ------------------
 6842|       |
 6843|       |        // Handle manual resize: Resize Grips, Borders, Gamepad
 6844|   132k|        int border_held = -1;
 6845|   132k|        ImU32 resize_grip_col[4] = {};
 6846|   132k|        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
  ------------------
  |  Branch (6846:39): [True: 0, False: 132k]
  ------------------
 6847|   132k|        const float resize_grip_draw_size = IM_FLOOR(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  266|   132k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 6848|   132k|        if (handle_borders_and_resize_grips && !window->Collapsed)
  ------------------
  |  Branch (6848:13): [True: 132k, False: 0]
  |  Branch (6848:48): [True: 88.4k, False: 44.0k]
  ------------------
 6849|  88.4k|            if (UpdateWindowManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
  ------------------
  |  Branch (6849:17): [True: 0, False: 88.4k]
  ------------------
 6850|      0|                use_current_size_for_scrollbar_x = use_current_size_for_scrollbar_y = true;
 6851|   132k|        window->ResizeBorderHeld = (signed char)border_held;
 6852|       |
 6853|       |        // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
 6854|   132k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6854:13): [True: 0, False: 132k]
  ------------------
 6855|      0|        {
 6856|      0|            if (!window->Viewport->PlatformRequestMove)
  ------------------
  |  Branch (6856:17): [True: 0, False: 0]
  ------------------
 6857|      0|                window->Viewport->Pos = window->Pos;
 6858|      0|            if (!window->Viewport->PlatformRequestResize)
  ------------------
  |  Branch (6858:17): [True: 0, False: 0]
  ------------------
 6859|      0|                window->Viewport->Size = window->Size;
 6860|      0|            window->Viewport->UpdateWorkRect();
 6861|      0|            viewport_rect = window->Viewport->GetMainRect();
 6862|      0|        }
 6863|       |
 6864|       |        // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
 6865|   132k|        window->ViewportPos = window->Viewport->Pos;
 6866|       |
 6867|       |        // SCROLLBAR VISIBILITY
 6868|       |
 6869|       |        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
 6870|   132k|        if (!window->Collapsed)
  ------------------
  |  Branch (6870:13): [True: 88.4k, False: 44.0k]
  ------------------
 6871|  88.4k|        {
 6872|       |            // When reading the current size we need to read it after size constraints have been applied.
 6873|       |            // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
 6874|       |            // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
 6875|  88.4k|            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
 6876|  88.4k|            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
 6877|  88.4k|            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
  ------------------
  |  Branch (6877:50): [True: 4, False: 88.4k]
  ------------------
 6878|  88.4k|            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
  ------------------
  |  Branch (6878:43): [True: 10.2k, False: 78.1k]
  ------------------
 6879|  88.4k|            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
  ------------------
  |  Branch (6879:43): [True: 10.2k, False: 78.1k]
  ------------------
 6880|       |            //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
 6881|  88.4k|            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
  ------------------
  |  Branch (6881:34): [True: 0, False: 88.4k]
  |  Branch (6881:89): [True: 16.1k, False: 72.3k]
  |  Branch (6881:148): [True: 16.1k, False: 0]
  ------------------
 6882|  88.4k|            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
  ------------------
  |  Branch (6882:34): [True: 11.3k, False: 77.0k]
  |  Branch (6882:91): [True: 7.32k, False: 69.7k]
  |  Branch (6882:149): [True: 7.31k, False: 69.7k]
  |  Branch (6882:202): [True: 7.32k, False: 0]
  |  Branch (6882:245): [True: 0, False: 7.32k]
  ------------------
 6883|  88.4k|            if (window->ScrollbarX && !window->ScrollbarY)
  ------------------
  |  Branch (6883:17): [True: 11.3k, False: 77.0k]
  |  Branch (6883:39): [True: 2.52k, False: 8.86k]
  ------------------
 6884|  2.52k|                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar);
  ------------------
  |  Branch (6884:38): [True: 0, False: 2.52k]
  |  Branch (6884:97): [True: 0, False: 0]
  ------------------
 6885|  88.4k|            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
  ------------------
  |  Branch (6885:45): [True: 16.1k, False: 72.3k]
  |  Branch (6885:94): [True: 11.3k, False: 77.0k]
  ------------------
 6886|       |
 6887|       |            // Amend the partially filled window->DecorationXXX values.
 6888|  88.4k|            window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
 6889|  88.4k|            window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
 6890|  88.4k|        }
 6891|       |
 6892|       |        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
 6893|       |        // Update various regions. Variables they depend on should be set above in this function.
 6894|       |        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.
 6895|       |
 6896|       |        // Outer rectangle
 6897|       |        // Not affected by window border size. Used by:
 6898|       |        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
 6899|       |        // - Begin() initial clipping rect for drawing window background and borders.
 6900|       |        // - Begin() clipping whole child
 6901|   132k|        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
  ------------------
  |  Branch (6901:35): [True: 11.3k, False: 121k]
  |  Branch (6901:77): [True: 11.3k, False: 0]
  |  Branch (6901:114): [True: 11.3k, False: 0]
  ------------------
 6902|   132k|        const ImRect outer_rect = window->Rect();
 6903|   132k|        const ImRect title_bar_rect = window->TitleBarRect();
 6904|   132k|        window->OuterRectClipped = outer_rect;
 6905|   132k|        if (window->DockIsActive)
  ------------------
  |  Branch (6905:13): [True: 0, False: 132k]
  ------------------
 6906|      0|            window->OuterRectClipped.Min.y += window->TitleBarHeight();
 6907|   132k|        window->OuterRectClipped.ClipWith(host_rect);
 6908|       |
 6909|       |        // Inner rectangle
 6910|       |        // Not affected by window border size. Used by:
 6911|       |        // - InnerClipRect
 6912|       |        // - ScrollToRectEx()
 6913|       |        // - NavUpdatePageUpPageDown()
 6914|       |        // - Scrollbar()
 6915|   132k|        window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
 6916|   132k|        window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
 6917|   132k|        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
 6918|   132k|        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;
 6919|       |
 6920|       |        // Inner clipping rectangle.
 6921|       |        // Will extend a little bit outside the normal work region.
 6922|       |        // This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
 6923|       |        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
 6924|       |        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
 6925|       |        // Affected by window/frame border size. Used by:
 6926|       |        // - Begin() initial clip rect
 6927|   132k|        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
  ------------------
  |  Branch (6927:35): [True: 0, False: 132k]
  |  Branch (6927:73): [True: 110k, False: 21.6k]
  ------------------
 6928|   132k|        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
 6929|   132k|        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
 6930|   132k|        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
 6931|   132k|        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
 6932|   132k|        window->InnerClipRect.ClipWithFull(host_rect);
 6933|       |
 6934|       |        // Default item width. Make it proportional to window size if window manually resizes
 6935|   132k|        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
  ------------------
  |  Branch (6935:13): [True: 131k, False: 723]
  |  Branch (6935:38): [True: 131k, False: 0]
  |  Branch (6935:77): [True: 121k, False: 10.2k]
  ------------------
 6936|   121k|            window->ItemWidthDefault = ImFloor(window->Size.x * 0.65f);
 6937|  11.0k|        else
 6938|  11.0k|            window->ItemWidthDefault = ImFloor(g.FontSize * 16.0f);
 6939|       |
 6940|       |        // SCROLLING
 6941|       |
 6942|       |        // Lock down maximum scrolling
 6943|       |        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
 6944|       |        // for right/bottom aligned items without creating a scrollbar.
 6945|   132k|        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
 6946|   132k|        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());
 6947|       |
 6948|       |        // Apply scrolling
 6949|   132k|        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
 6950|   132k|        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 6951|   132k|        window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;
 6952|       |
 6953|       |        // DRAWING
 6954|       |
 6955|       |        // Setup draw list and outer clipping rectangle
 6956|   132k|        IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6957|   132k|        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
 6958|   132k|        PushClipRect(host_rect.Min, host_rect.Max, false);
 6959|       |
 6960|       |        // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
 6961|       |        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
 6962|       |        // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
 6963|   132k|        const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
  ------------------
  |  Branch (6963:52): [True: 132k, False: 0]
  |  Branch (6963:77): [True: 0, False: 0]
  ------------------
 6964|   132k|        if (is_undocked_or_docked_visible)
  ------------------
  |  Branch (6964:13): [True: 132k, False: 0]
  ------------------
 6965|   132k|        {
 6966|   132k|            bool render_decorations_in_parent = false;
 6967|   132k|            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
  ------------------
  |  Branch (6967:17): [True: 11.3k, False: 121k]
  |  Branch (6967:59): [True: 11.3k, False: 0]
  |  Branch (6967:96): [True: 11.3k, False: 0]
  ------------------
 6968|  11.3k|            {
 6969|       |                // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
 6970|       |                // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
 6971|  11.3k|                ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
  ------------------
  |  Branch (6971:47): [True: 0, False: 11.3k]
  ------------------
 6972|  11.3k|                bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
  ------------------
  |  Branch (6972:51): [True: 0, False: 11.3k]
  ------------------
 6973|  11.3k|                bool parent_is_empty = parent_window->DrawList->VtxBuffer.Size > 0;
 6974|  11.3k|                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && parent_is_empty && !previous_child_overlapping)
  ------------------
  |  Branch (6974:21): [True: 11.3k, False: 0]
  |  Branch (6974:74): [True: 11.3k, False: 0]
  |  Branch (6974:93): [True: 11.3k, False: 0]
  ------------------
 6975|  11.3k|                    render_decorations_in_parent = true;
 6976|  11.3k|            }
 6977|   132k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (6977:17): [True: 11.3k, False: 121k]
  ------------------
 6978|  11.3k|                window->DrawList = parent_window->DrawList;
 6979|       |
 6980|       |            // Handle title bar, scrollbar, resize grips and resize borders
 6981|   132k|            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
  ------------------
  |  Branch (6981:54): [True: 37.5k, False: 94.9k]
  ------------------
 6982|   132k|            const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
  ------------------
  |  Branch (6982:49): [True: 2, False: 132k]
  |  Branch (6982:64): [True: 56.2k, False: 76.2k]
  |  Branch (6982:88): [True: 25.7k, False: 30.5k]
  |  Branch (6982:186): [True: 0, False: 30.5k]
  |  Branch (6982:206): [True: 0, False: 0]
  ------------------
 6983|   132k|            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);
 6984|       |
 6985|   132k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (6985:17): [True: 11.3k, False: 121k]
  ------------------
 6986|  11.3k|                window->DrawList = &window->DrawListInst;
 6987|   132k|        }
 6988|       |
 6989|       |        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)
 6990|       |
 6991|       |        // Work rectangle.
 6992|       |        // Affected by window padding and border size. Used by:
 6993|       |        // - Columns() for right-most edge
 6994|       |        // - TreeNode(), CollapsingHeader() for right-most edge
 6995|       |        // - BeginTabBar() for right-most edge
 6996|   132k|        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
  ------------------
  |  Branch (6996:40): [True: 132k, False: 0]
  |  Branch (6996:83): [True: 11.3k, False: 121k]
  ------------------
 6997|   132k|        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
 6998|   132k|        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (6998:41): [True: 0, False: 132k]
  |  Branch (6998:119): [True: 11.3k, False: 121k]
  ------------------
 6999|   132k|        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (6999:41): [True: 0, False: 132k]
  |  Branch (6999:119): [True: 132k, False: 0]
  ------------------
 7000|   132k|        window->WorkRect.Min.x = ImFloor(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
 7001|   132k|        window->WorkRect.Min.y = ImFloor(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
 7002|   132k|        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
 7003|   132k|        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
 7004|   132k|        window->ParentWorkRect = window->WorkRect;
 7005|       |
 7006|       |        // [LEGACY] Content Region
 7007|       |        // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
 7008|       |        // Used by:
 7009|       |        // - Mouse wheel scrolling + many other things
 7010|   132k|        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
 7011|   132k|        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
 7012|   132k|        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (7012:78): [True: 0, False: 132k]
  ------------------
 7013|   132k|        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (7013:78): [True: 0, False: 132k]
  ------------------
 7014|       |
 7015|       |        // Setup drawing context
 7016|       |        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
 7017|   132k|        window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
 7018|   132k|        window->DC.GroupOffset.x = 0.0f;
 7019|   132k|        window->DC.ColumnsOffset.x = 0.0f;
 7020|       |
 7021|       |        // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
 7022|       |        // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
 7023|   132k|        double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
 7024|   132k|        double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
 7025|   132k|        window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
 7026|   132k|        window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
 7027|   132k|        window->DC.CursorPos = window->DC.CursorStartPos;
 7028|   132k|        window->DC.CursorPosPrevLine = window->DC.CursorPos;
 7029|   132k|        window->DC.CursorMaxPos = window->DC.CursorStartPos;
 7030|   132k|        window->DC.IdealMaxPos = window->DC.CursorStartPos;
 7031|   132k|        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
 7032|   132k|        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
 7033|   132k|        window->DC.IsSameLine = window->DC.IsSetPos = false;
 7034|       |
 7035|   132k|        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 7036|   132k|        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
 7037|   132k|        window->DC.NavLayersActiveMaskNext = 0x00;
 7038|   132k|        window->DC.NavHideHighlightOneFrame = false;
 7039|   132k|        window->DC.NavHasScroll = (window->ScrollMax.y > 0.0f);
 7040|       |
 7041|   132k|        window->DC.MenuBarAppending = false;
 7042|   132k|        window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
 7043|   132k|        window->DC.TreeDepth = 0;
 7044|   132k|        window->DC.TreeJumpToParentOnPopMask = 0x00;
 7045|   132k|        window->DC.ChildWindows.resize(0);
 7046|   132k|        window->DC.StateStorage = &window->StateStorage;
 7047|   132k|        window->DC.CurrentColumns = NULL;
 7048|   132k|        window->DC.LayoutType = ImGuiLayoutType_Vertical;
 7049|   132k|        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
  ------------------
  |  Branch (7049:39): [True: 11.3k, False: 121k]
  ------------------
 7050|       |
 7051|   132k|        window->DC.ItemWidth = window->ItemWidthDefault;
 7052|   132k|        window->DC.TextWrapPos = -1.0f; // disabled
 7053|   132k|        window->DC.ItemWidthStack.resize(0);
 7054|   132k|        window->DC.TextWrapPosStack.resize(0);
 7055|       |
 7056|   132k|        if (window->AutoFitFramesX > 0)
  ------------------
  |  Branch (7056:13): [True: 4, False: 132k]
  ------------------
 7057|      4|            window->AutoFitFramesX--;
 7058|   132k|        if (window->AutoFitFramesY > 0)
  ------------------
  |  Branch (7058:13): [True: 4, False: 132k]
  ------------------
 7059|      4|            window->AutoFitFramesY--;
 7060|       |
 7061|       |        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
 7062|   132k|        if (want_focus)
  ------------------
  |  Branch (7062:13): [True: 2, False: 132k]
  ------------------
 7063|      2|        {
 7064|      2|            FocusWindow(window);
 7065|      2|            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
 7066|      2|        }
 7067|       |
 7068|       |        // Close requested by platform window
 7069|   132k|        if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
  ------------------
  |  Branch (7069:13): [True: 0, False: 132k]
  |  Branch (7069:31): [True: 0, False: 0]
  |  Branch (7069:73): [True: 0, False: 0]
  ------------------
 7070|      0|        {
 7071|      0|            if (!window->DockIsActive || window->DockTabIsVisible)
  ------------------
  |  Branch (7071:17): [True: 0, False: 0]
  |  Branch (7071:42): [True: 0, False: 0]
  ------------------
 7072|      0|            {
 7073|      0|                window->Viewport->PlatformRequestClose = false;
 7074|      0|                g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue.
 7075|      0|                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' PlatformRequestClose\n", window->Name);
  ------------------
  |  |  233|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (233:50): [True: 0, False: 0]
  |  |  |  Branch (233:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7076|      0|                *p_open = false;
 7077|      0|            }
 7078|      0|        }
 7079|       |
 7080|       |        // Title bar
 7081|   132k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (7081:13): [True: 110k, False: 21.6k]
  |  Branch (7081:55): [True: 110k, False: 0]
  ------------------
 7082|   110k|            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);
 7083|       |
 7084|       |        // Clear hit test shape every frame
 7085|   132k|        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
 7086|       |
 7087|       |        // Pressing CTRL+C while holding on a window copy its content to the clipboard
 7088|       |        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
 7089|       |        // Maybe we can support CTRL+C on every element?
 7090|       |        /*
 7091|       |        //if (g.NavWindow == window && g.ActiveId == 0)
 7092|       |        if (g.ActiveId == window->MoveId)
 7093|       |            if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
 7094|       |                LogToClipboard();
 7095|       |        */
 7096|       |
 7097|   132k|        if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
  ------------------
  |  Branch (7097:13): [True: 132k, False: 0]
  ------------------
 7098|   132k|        {
 7099|       |            // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
 7100|       |            // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
 7101|   132k|            if ((g.MovingWindow == window) && (g.IO.ConfigDockingWithShift == g.IO.KeyShift))
  ------------------
  |  Branch (7101:17): [True: 18, False: 132k]
  |  Branch (7101:47): [True: 18, False: 0]
  ------------------
 7102|     18|                if ((window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
  ------------------
  |  Branch (7102:21): [True: 18, False: 0]
  ------------------
 7103|     18|                    BeginDockableDragDropSource(window);
 7104|       |
 7105|       |            // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
 7106|   132k|            if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
  ------------------
  |  Branch (7106:17): [True: 75, False: 132k]
  |  Branch (7106:37): [True: 57, False: 18]
  ------------------
 7107|     57|                if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
  ------------------
  |  Branch (7107:21): [True: 28, False: 29]
  |  Branch (7107:47): [True: 11, False: 18]
  ------------------
 7108|     39|                    if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (7108:25): [True: 39, False: 0]
  |  Branch (7108:67): [True: 39, False: 0]
  ------------------
 7109|     39|                        BeginDockableDragDropTarget(window);
 7110|   132k|        }
 7111|       |
 7112|       |        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
 7113|       |        // This is useful to allow creating context menus on title bar only, etc.
 7114|   132k|        if (window->DockIsActive)
  ------------------
  |  Branch (7114:13): [True: 0, False: 132k]
  ------------------
 7115|      0|            SetLastItemData(window->MoveId, g.CurrentItemFlags, window->DockTabItemStatusFlags, window->DockTabItemRect);
 7116|   132k|        else
 7117|   132k|            SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, title_bar_rect);
  ------------------
  |  Branch (7117:65): [True: 2.53k, False: 129k]
  ------------------
 7118|       |
 7119|       |        // [DEBUG]
 7120|   132k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 7121|   132k|        if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
  ------------------
  |  Branch (7121:13): [True: 0, False: 132k]
  |  Branch (7121:38): [True: 0, False: 0]
  |  Branch (7121:71): [True: 0, False: 0]
  ------------------
 7122|      0|            DebugLocateItemResolveWithLastItem();
 7123|   132k|#endif
 7124|       |
 7125|       |        // [Test Engine] Register title bar / tab
 7126|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 7127|       |        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
 7128|       |            IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.Rect, g.LastItemData.ID);
 7129|       |#endif
 7130|   132k|    }
 7131|      0|    else
 7132|      0|    {
 7133|       |        // Append
 7134|      0|        SetCurrentViewport(window, window->Viewport);
 7135|      0|        SetCurrentWindow(window);
 7136|      0|    }
 7137|       |
 7138|   132k|    if (!(flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (7138:9): [True: 132k, False: 0]
  ------------------
 7139|   132k|        PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);
 7140|       |
 7141|       |    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
 7142|   132k|    window->WriteAccessed = false;
 7143|   132k|    window->BeginCount++;
 7144|   132k|    g.NextWindowData.ClearFlags();
 7145|       |
 7146|       |    // Update visibility
 7147|   132k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (7147:9): [True: 132k, False: 0]
  ------------------
 7148|   132k|    {
 7149|       |        // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
 7150|       |        // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
 7151|       |        // This is analogous to regular windows being hidden from one frame.
 7152|       |        // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
 7153|   132k|        if (window->DockIsActive && !window->DockTabIsVisible)
  ------------------
  |  Branch (7153:13): [True: 0, False: 132k]
  |  Branch (7153:37): [True: 0, False: 0]
  ------------------
 7154|      0|        {
 7155|      0|            if (window->LastFrameJustFocused == g.FrameCount)
  ------------------
  |  Branch (7155:17): [True: 0, False: 0]
  ------------------
 7156|      0|                window->HiddenFramesCannotSkipItems = 1;
 7157|      0|            else
 7158|      0|                window->HiddenFramesCanSkipItems = 1;
 7159|      0|        }
 7160|       |
 7161|   132k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (7161:13): [True: 11.3k, False: 121k]
  ------------------
 7162|  11.3k|        {
 7163|       |            // Child window can be out of sight and have "negative" clip windows.
 7164|       |            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
 7165|  11.3k|            IM_ASSERT((flags& ImGuiWindowFlags_NoTitleBar) != 0 || (window->DockIsActive));
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7166|  11.3k|            if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0) // FIXME: Doesn't make sense for ChildWindow??
  ------------------
  |  Branch (7166:17): [True: 11.3k, False: 0]
  |  Branch (7166:65): [True: 11.3k, False: 0]
  |  Branch (7166:96): [True: 11.3k, False: 0]
  ------------------
 7167|  11.3k|            {
 7168|  11.3k|                const bool nav_request = (flags & ImGuiWindowFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
  ------------------
  |  Branch (7168:42): [True: 0, False: 11.3k]
  |  Branch (7168:86): [True: 0, False: 0]
  |  Branch (7168:105): [True: 0, False: 0]
  |  Branch (7168:120): [True: 0, False: 0]
  ------------------
 7169|  11.3k|                if (!g.LogEnabled && !nav_request)
  ------------------
  |  Branch (7169:21): [True: 11.3k, False: 0]
  |  Branch (7169:38): [True: 11.3k, False: 0]
  ------------------
 7170|  11.3k|                    if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
  ------------------
  |  Branch (7170:25): [True: 4.32k, False: 7.06k]
  |  Branch (7170:93): [True: 2, False: 7.06k]
  ------------------
 7171|  4.32k|                        window->HiddenFramesCanSkipItems = 1;
 7172|  11.3k|            }
 7173|       |
 7174|       |            // Hide along with parent or if parent is collapsed
 7175|  11.3k|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
  ------------------
  |  Branch (7175:17): [True: 11.3k, False: 0]
  |  Branch (7175:35): [True: 0, False: 11.3k]
  |  Branch (7175:63): [True: 0, False: 11.3k]
  ------------------
 7176|      0|                window->HiddenFramesCanSkipItems = 1;
 7177|  11.3k|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
  ------------------
  |  Branch (7177:17): [True: 11.3k, False: 0]
  |  Branch (7177:35): [True: 0, False: 11.3k]
  |  Branch (7177:63): [True: 1, False: 11.3k]
  ------------------
 7178|      1|                window->HiddenFramesCannotSkipItems = 1;
 7179|  11.3k|        }
 7180|       |
 7181|       |        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
 7182|   132k|        if (style.Alpha <= 0.0f)
  ------------------
  |  Branch (7182:13): [True: 0, False: 132k]
  ------------------
 7183|      0|            window->HiddenFramesCanSkipItems = 1;
 7184|       |
 7185|       |        // Update the Hidden flag
 7186|   132k|        bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
  ------------------
  |  Branch (7186:31): [True: 4.32k, False: 128k]
  |  Branch (7186:73): [True: 3, False: 128k]
  ------------------
 7187|   132k|        window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);
  ------------------
  |  Branch (7187:26): [True: 4.33k, False: 128k]
  |  Branch (7187:44): [True: 0, False: 128k]
  ------------------
 7188|       |
 7189|       |        // Disable inputs for requested number of frames
 7190|   132k|        if (window->DisableInputsFrames > 0)
  ------------------
  |  Branch (7190:13): [True: 0, False: 132k]
  ------------------
 7191|      0|        {
 7192|      0|            window->DisableInputsFrames--;
 7193|      0|            window->Flags |= ImGuiWindowFlags_NoInputs;
 7194|      0|        }
 7195|       |
 7196|       |        // Update the SkipItems flag, used to early out of all items functions (no layout required)
 7197|   132k|        bool skip_items = false;
 7198|   132k|        if (window->Collapsed || !window->Active || hidden_regular)
  ------------------
  |  Branch (7198:13): [True: 44.0k, False: 88.4k]
  |  Branch (7198:34): [True: 0, False: 88.4k]
  |  Branch (7198:53): [True: 4.33k, False: 84.1k]
  ------------------
 7199|  48.3k|            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
  ------------------
  |  Branch (7199:17): [True: 48.3k, False: 2]
  |  Branch (7199:48): [True: 48.3k, False: 0]
  |  Branch (7199:79): [True: 48.3k, False: 1]
  ------------------
 7200|  48.3k|                skip_items = true;
 7201|   132k|        window->SkipItems = skip_items;
 7202|       |
 7203|       |        // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
 7204|   132k|        if (window->SkipItems)
  ------------------
  |  Branch (7204:13): [True: 48.3k, False: 84.1k]
  ------------------
 7205|  48.3k|            window->DC.NavLayersActiveMaskNext = window->DC.NavLayersActiveMask;
 7206|       |
 7207|       |        // Sanity check: there are two spots which can set Appearing = true
 7208|       |        // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
 7209|       |        // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
 7210|   132k|        if (window->SkipItems && !window->Appearing)
  ------------------
  |  Branch (7210:13): [True: 48.3k, False: 84.1k]
  |  Branch (7210:34): [True: 48.3k, False: 0]
  ------------------
 7211|   132k|            IM_ASSERT(window->Appearing == false); // Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7212|   132k|    }
 7213|       |
 7214|   132k|    return !window->SkipItems;
 7215|   132k|}
_ZN5ImGui3EndEv:
 7218|   132k|{
 7219|   132k|    ImGuiContext& g = *GImGui;
 7220|   132k|    ImGuiWindow* window = g.CurrentWindow;
 7221|       |
 7222|       |    // Error checking: verify that user hasn't called End() too many times!
 7223|   132k|    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
  ------------------
  |  Branch (7223:9): [True: 65.6k, False: 66.8k]
  |  Branch (7223:43): [True: 0, False: 65.6k]
  ------------------
 7224|      0|    {
 7225|      0|        IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
  ------------------
  |  |  250|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7226|      0|        return;
 7227|      0|    }
 7228|   132k|    IM_ASSERT(g.CurrentWindowStack.Size > 0);
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7229|       |
 7230|       |    // Error checking: verify that user doesn't directly call End() on a child window.
 7231|   132k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
  ------------------
  |  Branch (7231:9): [True: 11.3k, False: 121k]
  |  Branch (7231:59): [True: 11.3k, False: 0]
  |  Branch (7231:111): [True: 11.3k, False: 0]
  ------------------
 7232|   132k|        IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");
  ------------------
  |  |  250|   132k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7233|       |
 7234|       |    // Close anything that is open
 7235|   132k|    if (window->DC.CurrentColumns)
  ------------------
  |  Branch (7235:9): [True: 0, False: 132k]
  ------------------
 7236|      0|        EndColumns();
 7237|   132k|    if (!(window->Flags & ImGuiWindowFlags_DockNodeHost))   // Pop inner window clip rectangle
  ------------------
  |  Branch (7237:9): [True: 132k, False: 0]
  ------------------
 7238|   132k|        PopClipRect();
 7239|   132k|    PopFocusScope();
 7240|       |
 7241|       |    // Stop logging
 7242|   132k|    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
  ------------------
  |  Branch (7242:9): [True: 121k, False: 11.3k]
  ------------------
 7243|   121k|        LogFinish();
 7244|       |
 7245|   132k|    if (window->DC.IsSetPos)
  ------------------
  |  Branch (7245:9): [True: 0, False: 132k]
  ------------------
 7246|      0|        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
 7247|       |
 7248|       |    // Docking: report contents sizes to parent to allow for auto-resize
 7249|   132k|    if (window->DockNode && window->DockTabIsVisible)
  ------------------
  |  Branch (7249:9): [True: 0, False: 132k]
  |  Branch (7249:29): [True: 0, False: 0]
  ------------------
 7250|      0|        if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
  ------------------
  |  Branch (7250:26): [True: 0, False: 0]
  ------------------
 7251|      0|            host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;
 7252|       |
 7253|       |    // Pop from window stack
 7254|   132k|    g.LastItemData = g.CurrentWindowStack.back().ParentLastItemDataBackup;
 7255|   132k|    if (window->Flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (7255:9): [True: 0, False: 132k]
  ------------------
 7256|      0|        g.BeginMenuCount--;
 7257|   132k|    if (window->Flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (7257:9): [True: 0, False: 132k]
  ------------------
 7258|      0|        g.BeginPopupStack.pop_back();
 7259|   132k|    g.CurrentWindowStack.back().StackSizesOnBegin.CompareWithCurrentState();
 7260|   132k|    g.CurrentWindowStack.pop_back();
 7261|   132k|    SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
  ------------------
  |  Branch (7261:22): [True: 65.6k, False: 66.8k]
  ------------------
 7262|   132k|    if (g.CurrentWindow)
  ------------------
  |  Branch (7262:9): [True: 66.8k, False: 65.6k]
  ------------------
 7263|  66.8k|        SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
 7264|   132k|}
_ZN5ImGui23BringWindowToFocusFrontEP11ImGuiWindow:
 7267|  3.65k|{
 7268|  3.65k|    ImGuiContext& g = *GImGui;
 7269|  3.65k|    IM_ASSERT(window == window->RootWindow);
  ------------------
  |  |   23|  3.65k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7270|       |
 7271|  3.65k|    const int cur_order = window->FocusOrder;
 7272|  3.65k|    IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
  ------------------
  |  |   23|  3.65k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7273|  3.65k|    if (g.WindowsFocusOrder.back() == window)
  ------------------
  |  Branch (7273:9): [True: 3.65k, False: 1]
  ------------------
 7274|  3.65k|        return;
 7275|       |
 7276|      1|    const int new_order = g.WindowsFocusOrder.Size - 1;
 7277|      2|    for (int n = cur_order; n < new_order; n++)
  ------------------
  |  Branch (7277:29): [True: 1, False: 1]
  ------------------
 7278|      1|    {
 7279|      1|        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
 7280|      1|        g.WindowsFocusOrder[n]->FocusOrder--;
 7281|      1|        IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7282|      1|    }
 7283|      1|    g.WindowsFocusOrder[new_order] = window;
 7284|      1|    window->FocusOrder = (short)new_order;
 7285|      1|}
_ZN5ImGui25BringWindowToDisplayFrontEP11ImGuiWindow:
 7288|  3.65k|{
 7289|  3.65k|    ImGuiContext& g = *GImGui;
 7290|  3.65k|    ImGuiWindow* current_front_window = g.Windows.back();
 7291|  3.65k|    if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
  ------------------
  |  Branch (7291:9): [True: 3, False: 3.65k]
  |  Branch (7291:43): [True: 3.65k, False: 1]
  ------------------
 7292|  3.65k|        return;
 7293|      2|    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
  ------------------
  |  Branch (7293:38): [True: 2, False: 0]
  ------------------
 7294|      2|        if (g.Windows[i] == window)
  ------------------
  |  Branch (7294:13): [True: 1, False: 1]
  ------------------
 7295|      1|        {
 7296|      1|            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
 7297|      1|            g.Windows[g.Windows.Size - 1] = window;
 7298|      1|            break;
 7299|      1|        }
 7300|      1|}
_ZN5ImGui11FocusWindowEP11ImGuiWindow:
 7346|  11.0k|{
 7347|  11.0k|    ImGuiContext& g = *GImGui;
 7348|       |
 7349|  11.0k|    if (g.NavWindow != window)
  ------------------
  |  Branch (7349:9): [True: 3.86k, False: 7.16k]
  ------------------
 7350|  3.86k|    {
 7351|  3.86k|        SetNavWindow(window);
 7352|  3.86k|        if (window && g.NavDisableMouseHover)
  ------------------
  |  Branch (7352:13): [True: 1.91k, False: 1.95k]
  |  Branch (7352:23): [True: 909, False: 1.00k]
  ------------------
 7353|    909|            g.NavMousePosDirty = true;
 7354|  3.86k|        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
  ------------------
  |  Branch (7354:19): [True: 1.91k, False: 1.95k]
  ------------------
 7355|  3.86k|        g.NavLayer = ImGuiNavLayer_Main;
 7356|  3.86k|        g.NavFocusScopeId = window ? window->NavRootFocusScopeId : 0;
  ------------------
  |  Branch (7356:29): [True: 1.91k, False: 1.95k]
  ------------------
 7357|  3.86k|        g.NavIdIsAlive = false;
 7358|       |
 7359|       |        // Close popups if any
 7360|  3.86k|        ClosePopupsOverWindow(window, false);
 7361|  3.86k|    }
 7362|       |
 7363|       |    // Move the root window to the top of the pile
 7364|  11.0k|    IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
  ------------------
  |  |   23|  11.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7365|  11.0k|    ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
  ------------------
  |  Branch (7365:39): [True: 3.65k, False: 7.37k]
  ------------------
 7366|  11.0k|    ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
  ------------------
  |  Branch (7366:41): [True: 3.65k, False: 7.37k]
  ------------------
 7367|  11.0k|    ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
  ------------------
  |  Branch (7367:32): [True: 3.65k, False: 7.37k]
  ------------------
 7368|  11.0k|    bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);
  ------------------
  |  Branch (7368:48): [True: 167, False: 10.8k]
  |  Branch (7368:68): [True: 0, False: 167]
  |  Branch (7368:81): [True: 0, False: 0]
  ------------------
 7369|       |
 7370|       |    // Steal active widgets. Some of the cases it triggers includes:
 7371|       |    // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
 7372|       |    // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
 7373|       |    // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
 7374|  11.0k|    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
  ------------------
  |  Branch (7374:9): [True: 167, False: 10.8k]
  |  Branch (7374:28): [True: 167, False: 0]
  |  Branch (7374:48): [True: 76, False: 91]
  ------------------
 7375|     76|        if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
  ------------------
  |  Branch (7375:13): [True: 56, False: 20]
  |  Branch (7375:46): [True: 56, False: 0]
  ------------------
 7376|     56|            ClearActiveID();
 7377|       |
 7378|       |    // Passing NULL allow to disable keyboard focus
 7379|  11.0k|    if (!window)
  ------------------
  |  Branch (7379:9): [True: 7.37k, False: 3.65k]
  ------------------
 7380|  7.37k|        return;
 7381|  3.65k|    window->LastFrameJustFocused = g.FrameCount;
 7382|       |
 7383|       |    // Select in dock node
 7384|  3.65k|    if (dock_node && dock_node->TabBar)
  ------------------
  |  Branch (7384:9): [True: 0, False: 3.65k]
  |  Branch (7384:22): [True: 0, False: 0]
  ------------------
 7385|      0|        dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;
 7386|       |
 7387|       |    // Bring to front
 7388|  3.65k|    BringWindowToFocusFront(focus_front_window);
 7389|  3.65k|    if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
  ------------------
  |  Branch (7389:9): [True: 3.65k, False: 0]
  ------------------
 7390|  3.65k|        BringWindowToDisplayFront(display_front_window);
 7391|  3.65k|}
_ZN5ImGui14SetCurrentFontEP6ImFont:
 7430|  55.4k|{
 7431|  55.4k|    ImGuiContext& g = *GImGui;
 7432|  55.4k|    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7433|  55.4k|    IM_ASSERT(font->Scale > 0.0f);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7434|  55.4k|    g.Font = font;
 7435|  55.4k|    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
 7436|  55.4k|    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
  ------------------
  |  Branch (7436:18): [True: 0, False: 55.4k]
  ------------------
 7437|       |
 7438|  55.4k|    ImFontAtlas* atlas = g.Font->ContainerAtlas;
 7439|  55.4k|    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
 7440|  55.4k|    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
 7441|  55.4k|    g.DrawListSharedData.Font = g.Font;
 7442|  55.4k|    g.DrawListSharedData.FontSize = g.FontSize;
 7443|  55.4k|}
_ZN5ImGui12PushItemFlagEib:
 7464|  11.3k|{
 7465|  11.3k|    ImGuiContext& g = *GImGui;
 7466|  11.3k|    ImGuiItemFlags item_flags = g.CurrentItemFlags;
 7467|  11.3k|    IM_ASSERT(item_flags == g.ItemFlagsStack.back());
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7468|  11.3k|    if (enabled)
  ------------------
  |  Branch (7468:9): [True: 0, False: 11.3k]
  ------------------
 7469|      0|        item_flags |= option;
 7470|  11.3k|    else
 7471|  11.3k|        item_flags &= ~option;
 7472|  11.3k|    g.CurrentItemFlags = item_flags;
 7473|  11.3k|    g.ItemFlagsStack.push_back(item_flags);
 7474|  11.3k|}
_ZN5ImGui11PopItemFlagEv:
 7477|  11.3k|{
 7478|  11.3k|    ImGuiContext& g = *GImGui;
 7479|  11.3k|    IM_ASSERT(g.ItemFlagsStack.Size > 1); // Too many calls to PopItemFlag() - we always leave a 0 at the bottom of the stack.
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7480|  11.3k|    g.ItemFlagsStack.pop_back();
 7481|  11.3k|    g.CurrentItemFlags = g.ItemFlagsStack.back();
 7482|  11.3k|}
_ZN5ImGui22PushAllowKeyboardFocusEb:
 7520|  11.3k|{
 7521|  11.3k|    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);
 7522|  11.3k|}
_ZN5ImGui21PopAllowKeyboardFocusEv:
 7525|  11.3k|{
 7526|  11.3k|    PopItemFlag();
 7527|  11.3k|}
_ZN5ImGui15IsWindowHoveredEi:
 7618|  15.5k|{
 7619|  15.5k|    IM_ASSERT((flags & (ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_AllowWhenDisabled)) == 0);   // Flags not supported by this function
  ------------------
  |  |   23|  15.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7620|  15.5k|    ImGuiContext& g = *GImGui;
 7621|  15.5k|    ImGuiWindow* ref_window = g.HoveredWindow;
 7622|  15.5k|    ImGuiWindow* cur_window = g.CurrentWindow;
 7623|  15.5k|    if (ref_window == NULL)
  ------------------
  |  Branch (7623:9): [True: 14.8k, False: 698]
  ------------------
 7624|  14.8k|        return false;
 7625|       |
 7626|    698|    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
  ------------------
  |  Branch (7626:9): [True: 698, False: 0]
  ------------------
 7627|    698|    {
 7628|    698|        IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|    698|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7629|    698|        const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
 7630|    698|        const bool dock_hierarchy = (flags & ImGuiHoveredFlags_DockHierarchy) != 0;
 7631|    698|        if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (7631:13): [True: 0, False: 698]
  ------------------
 7632|      0|            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 7633|       |
 7634|    698|        bool result;
 7635|    698|        if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (7635:13): [True: 0, False: 698]
  ------------------
 7636|      0|            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 7637|    698|        else
 7638|    698|            result = (ref_window == cur_window);
 7639|    698|        if (!result)
  ------------------
  |  Branch (7639:13): [True: 695, False: 3]
  ------------------
 7640|    695|            return false;
 7641|    698|    }
 7642|       |
 7643|      3|    if (!IsWindowContentHoverable(ref_window, flags))
  ------------------
  |  Branch (7643:9): [True: 0, False: 3]
  ------------------
 7644|      0|        return false;
 7645|      3|    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (7645:9): [True: 3, False: 0]
  ------------------
 7646|      3|        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)
  ------------------
  |  Branch (7646:13): [True: 0, False: 3]
  |  Branch (7646:32): [True: 0, False: 0]
  |  Branch (7646:59): [True: 0, False: 0]
  ------------------
 7647|      0|            return false;
 7648|      3|    return true;
 7649|      3|}
_ZN5ImGui15IsWindowFocusedEi:
 7652|  22.6k|{
 7653|  22.6k|    ImGuiContext& g = *GImGui;
 7654|  22.6k|    ImGuiWindow* ref_window = g.NavWindow;
 7655|  22.6k|    ImGuiWindow* cur_window = g.CurrentWindow;
 7656|       |
 7657|  22.6k|    if (ref_window == NULL)
  ------------------
  |  Branch (7657:9): [True: 14.0k, False: 8.59k]
  ------------------
 7658|  14.0k|        return false;
 7659|  8.59k|    if (flags & ImGuiFocusedFlags_AnyWindow)
  ------------------
  |  Branch (7659:9): [True: 0, False: 8.59k]
  ------------------
 7660|      0|        return true;
 7661|       |
 7662|  8.59k|    IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|  8.59k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7663|  8.59k|    const bool popup_hierarchy = (flags & ImGuiFocusedFlags_NoPopupHierarchy) == 0;
 7664|  8.59k|    const bool dock_hierarchy = (flags & ImGuiFocusedFlags_DockHierarchy) != 0;
 7665|  8.59k|    if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (7665:9): [True: 0, False: 8.59k]
  ------------------
 7666|      0|        cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 7667|       |
 7668|  8.59k|    if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (7668:9): [True: 0, False: 8.59k]
  ------------------
 7669|      0|        return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 7670|  8.59k|    else
 7671|  8.59k|        return (ref_window == cur_window);
 7672|  8.59k|}
_ZN5ImGui20IsWindowNavFocusableEP11ImGuiWindow:
 7690|  37.3k|{
 7691|  37.3k|    return window->WasActive && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
  ------------------
  |  Branch (7691:12): [True: 23.3k, False: 14.0k]
  |  Branch (7691:33): [True: 23.3k, False: 0]
  |  Branch (7691:65): [True: 10.7k, False: 12.6k]
  ------------------
 7692|  37.3k|}
_ZN5ImGui14GetWindowWidthEv:
 7695|  3.03k|{
 7696|  3.03k|    ImGuiWindow* window = GImGui->CurrentWindow;
 7697|  3.03k|    return window->Size.x;
 7698|  3.03k|}
_ZN5ImGui15GetWindowHeightEv:
 7701|  3.04k|{
 7702|  3.04k|    ImGuiWindow* window = GImGui->CurrentWindow;
 7703|  3.04k|    return window->Size.y;
 7704|  3.04k|}
_ZN5ImGui12SetWindowPosEP11ImGuiWindowRK6ImVec2i:
 7714|  23.4k|{
 7715|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 7716|  23.4k|    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
  ------------------
  |  Branch (7716:9): [True: 13.1k, False: 10.2k]
  |  Branch (7716:17): [True: 0, False: 13.1k]
  ------------------
 7717|      0|        return;
 7718|       |
 7719|  23.4k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  23.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7720|  23.4k|    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 7721|  23.4k|    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);
 7722|       |
 7723|       |    // Set
 7724|  23.4k|    const ImVec2 old_pos = window->Pos;
 7725|  23.4k|    window->Pos = ImFloor(pos);
 7726|  23.4k|    ImVec2 offset = window->Pos - old_pos;
 7727|  23.4k|    if (offset.x == 0.0f && offset.y == 0.0f)
  ------------------
  |  Branch (7727:9): [True: 21.1k, False: 2.34k]
  |  Branch (7727:29): [True: 10.2k, False: 10.8k]
  ------------------
 7728|  10.2k|        return;
 7729|  13.1k|    MarkIniSettingsDirty(window);
 7730|       |    // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
 7731|  13.1k|    window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
 7732|  13.1k|    window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
 7733|  13.1k|    window->DC.IdealMaxPos += offset;
 7734|  13.1k|    window->DC.CursorStartPos += offset;
 7735|  13.1k|}
_ZN5ImGui13SetWindowSizeEP11ImGuiWindowRK6ImVec2i:
 7756|  66.8k|{
 7757|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 7758|  66.8k|    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
  ------------------
  |  Branch (7758:9): [True: 66.8k, False: 0]
  |  Branch (7758:17): [True: 55.4k, False: 11.3k]
  ------------------
 7759|  55.4k|        return;
 7760|       |
 7761|  11.3k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7762|  11.3k|    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 7763|       |
 7764|       |    // Set
 7765|  11.3k|    ImVec2 old_size = window->SizeFull;
 7766|  11.3k|    window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (7766:30): [True: 0, False: 11.3k]
  ------------------
 7767|  11.3k|    window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (7767:30): [True: 0, False: 11.3k]
  ------------------
 7768|  11.3k|    if (size.x <= 0.0f)
  ------------------
  |  Branch (7768:9): [True: 0, False: 11.3k]
  ------------------
 7769|      0|        window->AutoFitOnlyGrows = false;
 7770|  11.3k|    else
 7771|  11.3k|        window->SizeFull.x = IM_FLOOR(size.x);
  ------------------
  |  |  266|  11.3k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 7772|  11.3k|    if (size.y <= 0.0f)
  ------------------
  |  Branch (7772:9): [True: 0, False: 11.3k]
  ------------------
 7773|      0|        window->AutoFitOnlyGrows = false;
 7774|  11.3k|    else
 7775|  11.3k|        window->SizeFull.y = IM_FLOOR(size.y);
  ------------------
  |  |  266|  11.3k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 7776|  11.3k|    if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
  ------------------
  |  Branch (7776:9): [True: 4.78k, False: 6.60k]
  |  Branch (7776:45): [True: 1.40k, False: 5.20k]
  ------------------
 7777|  6.18k|        MarkIniSettingsDirty(window);
 7778|  11.3k|}
_ZN5ImGui14SetWindowFocusEv:
 7833|  3.03k|{
 7834|  3.03k|    FocusWindow(GImGui->CurrentWindow);
 7835|  3.03k|}
_ZN5ImGui16SetNextWindowPosERK6ImVec2iS2_:
 7851|  10.2k|{
 7852|  10.2k|    ImGuiContext& g = *GImGui;
 7853|  10.2k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  10.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7854|  10.2k|    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
 7855|  10.2k|    g.NextWindowData.PosVal = pos;
 7856|  10.2k|    g.NextWindowData.PosPivotVal = pivot;
 7857|  10.2k|    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
  ------------------
  |  Branch (7857:32): [True: 10.2k, False: 0]
  ------------------
 7858|  10.2k|    g.NextWindowData.PosUndock = true;
 7859|  10.2k|}
_ZN5ImGui17SetNextWindowSizeERK6ImVec2i:
 7862|  66.8k|{
 7863|  66.8k|    ImGuiContext& g = *GImGui;
 7864|  66.8k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  66.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7865|  66.8k|    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
 7866|  66.8k|    g.NextWindowData.SizeVal = size;
 7867|  66.8k|    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
  ------------------
  |  Branch (7867:33): [True: 55.4k, False: 11.3k]
  ------------------
 7868|  66.8k|}
_ZN5ImGui28SetNextWindowSizeConstraintsERK6ImVec2S2_PFvP21ImGuiSizeCallbackDataEPv:
 7871|  10.2k|{
 7872|  10.2k|    ImGuiContext& g = *GImGui;
 7873|  10.2k|    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
 7874|  10.2k|    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
 7875|  10.2k|    g.NextWindowData.SizeCallback = custom_callback;
 7876|  10.2k|    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
 7877|  10.2k|}
_ZN5ImGui17GetWindowDrawListEv:
 7941|  11.3k|{
 7942|  11.3k|    ImGuiWindow* window = GetCurrentWindow();
 7943|  11.3k|    return window->DrawList;
 7944|  11.3k|}
_ZN5ImGui7GetFontEv:
 7960|  88.0k|{
 7961|  88.0k|    return GImGui->Font;
 7962|  88.0k|}
_ZN5ImGui11GetFontSizeEv:
 7965|  88.2k|{
 7966|  88.2k|    return GImGui->FontSize;
 7967|  88.2k|}
_ZN5ImGui14PushFocusScopeEj:
 7991|   132k|{
 7992|   132k|    ImGuiContext& g = *GImGui;
 7993|   132k|    g.FocusScopeStack.push_back(id);
 7994|   132k|    g.CurrentFocusScopeId = id;
 7995|   132k|}
_ZN5ImGui13PopFocusScopeEv:
 7998|   132k|{
 7999|   132k|    ImGuiContext& g = *GImGui;
 8000|   132k|    IM_ASSERT(g.FocusScopeStack.Size > 0); // Too many PopFocusScope() ?
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8001|   132k|    g.FocusScopeStack.pop_back();
 8002|   132k|    g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back() : 0;
  ------------------
  |  Branch (8002:29): [True: 66.8k, False: 65.6k]
  ------------------
 8003|   132k|}
_ZN5ImGui6PushIDEPKc:
 8070|  11.3k|{
 8071|  11.3k|    ImGuiContext& g = *GImGui;
 8072|  11.3k|    ImGuiWindow* window = g.CurrentWindow;
 8073|  11.3k|    ImGuiID id = window->GetID(str_id);
 8074|  11.3k|    window->IDStack.push_back(id);
 8075|  11.3k|}
_ZN5ImGui5PopIDEv:
 8124|  11.3k|{
 8125|  11.3k|    ImGuiWindow* window = GImGui->CurrentWindow;
 8126|  11.3k|    IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8127|  11.3k|    window->IDStack.pop_back();
 8128|  11.3k|}
_ZN5ImGui10GetKeyDataE8ImGuiKey:
 8225|  1.53M|{
 8226|  1.53M|    ImGuiContext& g = *GImGui;
 8227|       |
 8228|       |    // Special storage location for mods
 8229|  1.53M|    if (key & ImGuiMod_Mask_)
  ------------------
  |  Branch (8229:9): [True: 499k, False: 1.03M]
  ------------------
 8230|   499k|        key = ConvertSingleModFlagToKey(key);
 8231|       |
 8232|  1.53M|    int index;
 8233|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 8234|       |    IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
 8235|       |    if (IsLegacyKey(key))
 8236|       |        index = (g.IO.KeyMap[key] != -1) ? g.IO.KeyMap[key] : key; // Remap native->imgui or imgui->native
 8237|       |    else
 8238|       |        index = key;
 8239|       |#else
 8240|  1.53M|    IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
  ------------------
  |  |   23|  1.53M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8241|  1.53M|    index = key - ImGuiKey_NamedKey_BEGIN;
 8242|  1.53M|#endif
 8243|  1.53M|    return &g.IO.KeysData[index];
 8244|  1.53M|}
_ZN5ImGui25CalcTypematicRepeatAmountEffff:
 8324|  7.37k|{
 8325|  7.37k|    if (t1 == 0.0f)
  ------------------
  |  Branch (8325:9): [True: 0, False: 7.37k]
  ------------------
 8326|      0|        return 1;
 8327|  7.37k|    if (t0 >= t1)
  ------------------
  |  Branch (8327:9): [True: 0, False: 7.37k]
  ------------------
 8328|      0|        return 0;
 8329|  7.37k|    if (repeat_rate <= 0.0f)
  ------------------
  |  Branch (8329:9): [True: 0, False: 7.37k]
  ------------------
 8330|      0|        return (t0 < repeat_delay) && (t1 >= repeat_delay);
  ------------------
  |  Branch (8330:16): [True: 0, False: 0]
  |  Branch (8330:39): [True: 0, False: 0]
  ------------------
 8331|  7.37k|    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (8331:26): [True: 257, False: 7.11k]
  ------------------
 8332|  7.37k|    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (8332:26): [True: 0, False: 7.37k]
  ------------------
 8333|  7.37k|    const int count = count_t1 - count_t0;
 8334|  7.37k|    return count;
 8335|  7.37k|}
_ZN5ImGui22GetTypematicRepeatRateEiPfS0_:
 8338|  14.0k|{
 8339|  14.0k|    ImGuiContext& g = *GImGui;
 8340|  14.0k|    switch (flags & ImGuiInputFlags_RepeatRateMask_)
 8341|  14.0k|    {
 8342|    331|    case ImGuiInputFlags_RepeatRateNavMove:             *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.80f; return;
  ------------------
  |  Branch (8342:5): [True: 331, False: 13.6k]
  ------------------
 8343|      0|    case ImGuiInputFlags_RepeatRateNavTweak:            *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.30f; return;
  ------------------
  |  Branch (8343:5): [True: 0, False: 14.0k]
  ------------------
 8344|  13.6k|    case ImGuiInputFlags_RepeatRateDefault: default:    *repeat_delay = g.IO.KeyRepeatDelay * 1.00f; *repeat_rate = g.IO.KeyRepeatRate * 1.00f; return;
  ------------------
  |  Branch (8344:5): [True: 0, False: 14.0k]
  |  Branch (8344:45): [True: 13.6k, False: 331]
  ------------------
 8345|  14.0k|    }
 8346|  14.0k|}
_ZN5ImGui19GetKeyPressedAmountE8ImGuiKeyff:
 8351|  7.37k|{
 8352|  7.37k|    ImGuiContext& g = *GImGui;
 8353|  7.37k|    const ImGuiKeyData* key_data = GetKeyData(key);
 8354|  7.37k|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8354:9): [True: 0, False: 7.37k]
  ------------------
 8355|      0|        return 0;
 8356|  7.37k|    const float t = key_data->DownDuration;
 8357|  7.37k|    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
 8358|  7.37k|}
_ZN5ImGui17GetKeyMagnitude2dE8ImGuiKeyS0_S0_S0_:
 8362|  13.3k|{
 8363|  13.3k|    return ImVec2(
 8364|  13.3k|        GetKeyData(key_right)->AnalogValue - GetKeyData(key_left)->AnalogValue,
 8365|  13.3k|        GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);
 8366|  13.3k|}
_ZN5ImGui18SetShortcutRoutingEiji:
 8507|   110k|{
 8508|   110k|    ImGuiContext& g = *GImGui;
 8509|   110k|    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
  ------------------
  |  Branch (8509:9): [True: 0, False: 110k]
  ------------------
 8510|      0|        flags |= ImGuiInputFlags_RouteGlobalHigh; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
 8511|   110k|    else
 8512|   110k|        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteMask_)); // Check that only 1 routing flag is used
  ------------------
  |  |   23|   110k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8513|       |
 8514|   110k|    if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
  ------------------
  |  Branch (8514:9): [True: 0, False: 110k]
  ------------------
 8515|      0|        if (g.NavWindow == NULL)
  ------------------
  |  Branch (8515:13): [True: 0, False: 0]
  ------------------
 8516|      0|            return false;
 8517|   110k|    if (flags & ImGuiInputFlags_RouteAlways)
  ------------------
  |  Branch (8517:9): [True: 110k, False: 0]
  ------------------
 8518|   110k|        return true;
 8519|       |
 8520|      0|    const int score = CalcRoutingScore(g.CurrentWindow, owner_id, flags);
 8521|      0|    if (score == 255)
  ------------------
  |  Branch (8521:9): [True: 0, False: 0]
  ------------------
 8522|      0|        return false;
 8523|       |
 8524|       |    // Submit routing for NEXT frame (assuming score is sufficient)
 8525|       |    // FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
 8526|      0|    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);
 8527|      0|    const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
 8528|       |    //const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
 8529|      0|    if (score < routing_data->RoutingNextScore)
  ------------------
  |  Branch (8529:9): [True: 0, False: 0]
  ------------------
 8530|      0|    {
 8531|      0|        routing_data->RoutingNext = routing_id;
 8532|      0|        routing_data->RoutingNextScore = (ImU8)score;
 8533|      0|    }
 8534|       |
 8535|       |    // Return routing state for CURRENT frame
 8536|      0|    return routing_data->RoutingCurr == routing_id;
 8537|      0|}
_ZN5ImGui9IsKeyDownE8ImGuiKey:
 8551|   837k|{
 8552|   837k|    return IsKeyDown(key, ImGuiKeyOwner_Any);
  ------------------
  |  | 1311|   837k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
 8553|   837k|}
_ZN5ImGui9IsKeyDownE8ImGuiKeyj:
 8556|   852k|{
 8557|   852k|    const ImGuiKeyData* key_data = GetKeyData(key);
 8558|   852k|    if (!key_data->Down)
  ------------------
  |  Branch (8558:9): [True: 819k, False: 32.8k]
  ------------------
 8559|   819k|        return false;
 8560|  32.8k|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (8560:9): [True: 0, False: 32.8k]
  ------------------
 8561|      0|        return false;
 8562|  32.8k|    return true;
 8563|  32.8k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyb:
 8566|  54.3k|{
 8567|  54.3k|    return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
  ------------------
  |  | 1311|  54.3k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8567:49): [True: 54.2k, False: 18]
  ------------------
 8568|  54.3k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyji:
 8572|   229k|{
 8573|   229k|    const ImGuiKeyData* key_data = GetKeyData(key);
 8574|   229k|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8574:9): [True: 213k, False: 15.8k]
  ------------------
 8575|   213k|        return false;
 8576|  15.8k|    const float t = key_data->DownDuration;
 8577|  15.8k|    if (t < 0.0f)
  ------------------
  |  Branch (8577:9): [True: 0, False: 15.8k]
  ------------------
 8578|      0|        return false;
 8579|  15.8k|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|  15.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8580|       |
 8581|  15.8k|    bool pressed = (t == 0.0f);
 8582|  15.8k|    if (!pressed && ((flags & ImGuiInputFlags_Repeat) != 0))
  ------------------
  |  Branch (8582:9): [True: 14.8k, False: 983]
  |  Branch (8582:21): [True: 14.0k, False: 806]
  ------------------
 8583|  14.0k|    {
 8584|  14.0k|        float repeat_delay, repeat_rate;
 8585|  14.0k|        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
 8586|  14.0k|        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
  ------------------
  |  Branch (8586:19): [True: 7.37k, False: 6.65k]
  |  Branch (8586:41): [True: 2.52k, False: 4.84k]
  ------------------
 8587|  14.0k|    }
 8588|  15.8k|    if (!pressed)
  ------------------
  |  Branch (8588:9): [True: 12.3k, False: 3.51k]
  ------------------
 8589|  12.3k|        return false;
 8590|  3.51k|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (8590:9): [True: 1, False: 3.51k]
  ------------------
 8591|      1|        return false;
 8592|  3.51k|    return true;
 8593|  3.51k|}
_ZN5ImGui13IsKeyReleasedE8ImGuiKey:
 8596|    392|{
 8597|    392|    return IsKeyReleased(key, ImGuiKeyOwner_Any);
  ------------------
  |  | 1311|    392|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
 8598|    392|}
_ZN5ImGui13IsKeyReleasedE8ImGuiKeyj:
 8601|    392|{
 8602|    392|    const ImGuiKeyData* key_data = GetKeyData(key);
 8603|    392|    if (key_data->DownDurationPrev < 0.0f || key_data->Down)
  ------------------
  |  Branch (8603:9): [True: 76, False: 316]
  |  Branch (8603:46): [True: 316, False: 0]
  ------------------
 8604|    392|        return false;
 8605|      0|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (8605:9): [True: 0, False: 0]
  ------------------
 8606|      0|        return false;
 8607|      0|    return true;
 8608|      0|}
_ZN5ImGui11IsMouseDownEij:
 8618|    301|{
 8619|    301|    ImGuiContext& g = *GImGui;
 8620|    301|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    301|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8621|    301|    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
  ------------------
  |  Branch (8621:12): [True: 301, False: 0]
  |  Branch (8621:38): [True: 301, False: 0]
  ------------------
 8622|    301|}
_ZN5ImGui14IsMouseClickedEib:
 8625|     10|{
 8626|     10|    return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
  ------------------
  |  | 1311|     10|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8626:54): [True: 0, False: 10]
  ------------------
 8627|     10|}
_ZN5ImGui14IsMouseClickedEiji:
 8630|    728|{
 8631|    728|    ImGuiContext& g = *GImGui;
 8632|    728|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    728|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8633|    728|    if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8633:9): [True: 465, False: 263]
  ------------------
 8634|    465|        return false;
 8635|    263|    const float t = g.IO.MouseDownDuration[button];
 8636|    263|    if (t < 0.0f)
  ------------------
  |  Branch (8636:9): [True: 0, False: 263]
  ------------------
 8637|      0|        return false;
 8638|    263|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|    263|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8639|       |
 8640|    263|    const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
 8641|    263|    const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
  ------------------
  |  Branch (8641:26): [True: 63, False: 200]
  |  Branch (8641:42): [True: 0, False: 200]
  |  Branch (8641:52): [True: 0, False: 0]
  |  Branch (8641:79): [True: 0, False: 0]
  ------------------
 8642|    263|    if (!pressed)
  ------------------
  |  Branch (8642:9): [True: 200, False: 63]
  ------------------
 8643|    200|        return false;
 8644|       |
 8645|     63|    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
  ------------------
  |  Branch (8645:9): [True: 0, False: 63]
  ------------------
 8646|      0|        return false;
 8647|       |
 8648|     63|    return true;
 8649|     63|}
_ZN5ImGui20IsMouseDoubleClickedEi:
 8666|      3|{
 8667|      3|    ImGuiContext& g = *GImGui;
 8668|      3|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8669|      3|    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any);
  ------------------
  |  | 1311|      0|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8669:12): [True: 0, False: 3]
  |  Branch (8669:51): [True: 0, False: 0]
  ------------------
 8670|      3|}
_ZN5ImGui19IsMouseHoveringRectERK6ImVec2S2_b:
 8683|   274k|{
 8684|   274k|    ImGuiContext& g = *GImGui;
 8685|       |
 8686|       |    // Clip
 8687|   274k|    ImRect rect_clipped(r_min, r_max);
 8688|   274k|    if (clip)
  ------------------
  |  Branch (8688:9): [True: 141k, False: 132k]
  ------------------
 8689|   141k|        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);
 8690|       |
 8691|       |    // Expand for touch input
 8692|   274k|    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
 8693|   274k|    if (!rect_for_touch.Contains(g.IO.MousePos))
  ------------------
  |  Branch (8693:9): [True: 268k, False: 6.11k]
  ------------------
 8694|   268k|        return false;
 8695|  6.11k|    if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
  ------------------
  |  Branch (8695:9): [True: 0, False: 6.11k]
  ------------------
 8696|      0|        return false;
 8697|  6.11k|    return true;
 8698|  6.11k|}
_ZN5ImGui24IsMouseDragPastThresholdEif:
 8703|    326|{
 8704|    326|    ImGuiContext& g = *GImGui;
 8705|    326|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    326|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8706|    326|    if (lock_threshold < 0.0f)
  ------------------
  |  Branch (8706:9): [True: 319, False: 7]
  ------------------
 8707|    319|        lock_threshold = g.IO.MouseDragThreshold;
 8708|    326|    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
 8709|    326|}
_ZN5ImGui15IsMouseDraggingEif:
 8712|    329|{
 8713|    329|    ImGuiContext& g = *GImGui;
 8714|    329|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    329|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8715|    329|    if (!g.IO.MouseDown[button])
  ------------------
  |  Branch (8715:9): [True: 3, False: 326]
  ------------------
 8716|      3|        return false;
 8717|    326|    return IsMouseDragPastThreshold(button, lock_threshold);
 8718|    329|}
_ZN5ImGui11GetMousePosEv:
 8721|  2.12k|{
 8722|  2.12k|    ImGuiContext& g = *GImGui;
 8723|  2.12k|    return g.IO.MousePos;
 8724|  2.12k|}
_ZN5ImGui15IsMousePosValidEPK6ImVec2:
 8737|   143k|{
 8738|       |    // The assert is only to silence a false-positive in XCode Static Analysis.
 8739|       |    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
 8740|   143k|    IM_ASSERT(GImGui != NULL);
  ------------------
  |  |   23|   143k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8741|   143k|    const float MOUSE_INVALID = -256000.0f;
 8742|   143k|    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
  ------------------
  |  Branch (8742:16): [True: 132k, False: 11.4k]
  ------------------
 8743|   143k|    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
  ------------------
  |  Branch (8743:12): [True: 36.9k, False: 106k]
  |  Branch (8743:36): [True: 34.0k, False: 2.80k]
  ------------------
 8744|   143k|}
_ZN5ImGui17UpdateInputEventsEb:
 9184|  55.4k|{
 9185|  55.4k|    ImGuiContext& g = *GImGui;
 9186|  55.4k|    ImGuiIO& io = g.IO;
 9187|       |
 9188|       |    // Only trickle chars<>key when working with InputText()
 9189|       |    // FIXME: InputText() could parse event trail?
 9190|       |    // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
 9191|  55.4k|    const bool trickle_interleaved_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);
  ------------------
  |  Branch (9191:53): [True: 55.4k, False: 0]
  |  Branch (9191:76): [True: 0, False: 55.4k]
  ------------------
 9192|       |
 9193|  55.4k|    bool mouse_moved = false, mouse_wheeled = false, key_changed = false, text_inputted = false;
 9194|  55.4k|    int  mouse_button_changed = 0x00;
 9195|  55.4k|    ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;
 9196|       |
 9197|  55.4k|    int event_n = 0;
 9198|  62.0k|    for (; event_n < g.InputEventsQueue.Size; event_n++)
  ------------------
  |  Branch (9198:12): [True: 7.16k, False: 54.9k]
  ------------------
 9199|  7.16k|    {
 9200|  7.16k|        ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
 9201|  7.16k|        if (e->Type == ImGuiInputEventType_MousePos)
  ------------------
  |  Branch (9201:13): [True: 1.56k, False: 5.59k]
  ------------------
 9202|  1.56k|        {
 9203|       |            // Trickling Rule: Stop processing queued events if we already handled a mouse button change
 9204|  1.56k|            ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
 9205|  1.56k|            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
  ------------------
  |  Branch (9205:17): [True: 1.56k, False: 0]
  |  Branch (9205:41): [True: 51, False: 1.51k]
  |  Branch (9205:70): [True: 117, False: 1.39k]
  |  Branch (9205:87): [True: 7, False: 1.39k]
  |  Branch (9205:102): [True: 0, False: 1.39k]
  ------------------
 9206|    175|                break;
 9207|  1.39k|            io.MousePos = event_pos;
 9208|  1.39k|            mouse_moved = true;
 9209|  1.39k|        }
 9210|  5.59k|        else if (e->Type == ImGuiInputEventType_MouseButton)
  ------------------
  |  Branch (9210:18): [True: 1.48k, False: 4.11k]
  ------------------
 9211|  1.48k|        {
 9212|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
 9213|  1.48k|            const ImGuiMouseButton button = e->MouseButton.Button;
 9214|  1.48k|            IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  1.48k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9215|  1.48k|            if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
  ------------------
  |  Branch (9215:17): [True: 1.48k, False: 0]
  |  Branch (9215:41): [True: 0, False: 1.48k]
  |  Branch (9215:83): [True: 73, False: 1.41k]
  ------------------
 9216|     73|                break;
 9217|  1.41k|            io.MouseDown[button] = e->MouseButton.Down;
 9218|  1.41k|            mouse_button_changed |= (1 << button);
 9219|  1.41k|        }
 9220|  4.11k|        else if (e->Type == ImGuiInputEventType_MouseWheel)
  ------------------
  |  Branch (9220:18): [True: 1.14k, False: 2.97k]
  ------------------
 9221|  1.14k|        {
 9222|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the event
 9223|  1.14k|            if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
  ------------------
  |  Branch (9223:17): [True: 1.14k, False: 0]
  |  Branch (9223:41): [True: 179, False: 964]
  |  Branch (9223:56): [True: 27, False: 937]
  ------------------
 9224|    206|                break;
 9225|    937|            io.MouseWheelH += e->MouseWheel.WheelX;
 9226|    937|            io.MouseWheel += e->MouseWheel.WheelY;
 9227|    937|            mouse_wheeled = true;
 9228|    937|        }
 9229|  2.97k|        else if (e->Type == ImGuiInputEventType_MouseViewport)
  ------------------
  |  Branch (9229:18): [True: 0, False: 2.97k]
  ------------------
 9230|      0|        {
 9231|      0|            io.MouseHoveredViewport = e->MouseViewport.HoveredViewportID;
 9232|      0|        }
 9233|  2.97k|        else if (e->Type == ImGuiInputEventType_Key)
  ------------------
  |  Branch (9233:18): [True: 2.43k, False: 536]
  ------------------
 9234|  2.43k|        {
 9235|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
 9236|  2.43k|            ImGuiKey key = e->Key.Key;
 9237|  2.43k|            IM_ASSERT(key != ImGuiKey_None);
  ------------------
  |  |   23|  2.43k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9238|  2.43k|            ImGuiKeyData* key_data = GetKeyData(key);
 9239|  2.43k|            const int key_data_index = (int)(key_data - g.IO.KeysData);
 9240|  2.43k|            if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || text_inputted || mouse_button_changed != 0))
  ------------------
  |  Branch (9240:17): [True: 2.43k, False: 0]
  |  Branch (9240:40): [True: 2.35k, False: 85]
  |  Branch (9240:74): [True: 0, False: 2.35k]
  |  Branch (9240:118): [True: 0, False: 2.35k]
  |  Branch (9240:135): [True: 10, False: 2.34k]
  ------------------
 9241|     10|                break;
 9242|  2.42k|            key_data->Down = e->Key.Down;
 9243|  2.42k|            key_data->AnalogValue = e->Key.AnalogValue;
 9244|  2.42k|            key_changed = true;
 9245|  2.42k|            key_changed_mask.SetBit(key_data_index);
 9246|       |
 9247|       |            // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
 9248|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9249|       |            io.KeysDown[key_data_index] = key_data->Down;
 9250|       |            if (io.KeyMap[key_data_index] != -1)
 9251|       |                io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
 9252|       |#endif
 9253|  2.42k|        }
 9254|    536|        else if (e->Type == ImGuiInputEventType_Text)
  ------------------
  |  Branch (9254:18): [True: 536, False: 0]
  ------------------
 9255|    536|        {
 9256|       |            // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
 9257|    536|            if (trickle_fast_inputs && ((key_changed && trickle_interleaved_keys_and_text) || mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
  ------------------
  |  Branch (9257:17): [True: 536, False: 0]
  |  Branch (9257:42): [True: 81, False: 455]
  |  Branch (9257:57): [True: 0, False: 81]
  |  Branch (9257:95): [True: 3, False: 533]
  |  Branch (9257:124): [True: 2, False: 531]
  |  Branch (9257:139): [True: 9, False: 522]
  ------------------
 9258|     14|                break;
 9259|    522|            unsigned int c = e->Text.Char;
 9260|    522|            io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2318|    522|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
                          io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2314|    777|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
  |  Branch (9260:47): [True: 267, False: 255]
  ------------------
 9261|    522|            if (trickle_interleaved_keys_and_text)
  ------------------
  |  Branch (9261:17): [True: 0, False: 522]
  ------------------
 9262|      0|                text_inputted = true;
 9263|    522|        }
 9264|      0|        else if (e->Type == ImGuiInputEventType_Focus)
  ------------------
  |  Branch (9264:18): [True: 0, False: 0]
  ------------------
 9265|      0|        {
 9266|       |            // We intentionally overwrite this and process in NewFrame(), in order to give a chance
 9267|       |            // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
 9268|      0|            const bool focus_lost = !e->AppFocused.Focused;
 9269|      0|            io.AppFocusLost = focus_lost;
 9270|      0|        }
 9271|      0|        else
 9272|      0|        {
 9273|      0|            IM_ASSERT(0 && "Unknown event!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9274|      0|        }
 9275|  7.16k|    }
 9276|       |
 9277|       |    // Record trail (for domain-specific applications wanting to access a precise trail)
 9278|       |    //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
 9279|  62.0k|    for (int n = 0; n < event_n; n++)
  ------------------
  |  Branch (9279:21): [True: 6.68k, False: 55.4k]
  ------------------
 9280|  6.68k|        g.InputEventsTrail.push_back(g.InputEventsQueue[n]);
 9281|       |
 9282|       |    // [DEBUG]
 9283|  55.4k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 9284|  55.4k|    if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
  ------------------
  |  Branch (9284:9): [True: 4.38k, False: 51.0k]
  |  Branch (9284:25): [True: 0, False: 4.38k]
  ------------------
 9285|      0|        for (int n = 0; n < g.InputEventsQueue.Size; n++)
  ------------------
  |  Branch (9285:25): [True: 0, False: 0]
  ------------------
 9286|      0|            DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
  ------------------
  |  Branch (9286:34): [True: 0, False: 0]
  ------------------
 9287|  55.4k|#endif
 9288|       |
 9289|       |    // Remaining events will be processed on the next frame
 9290|  55.4k|    if (event_n == g.InputEventsQueue.Size)
  ------------------
  |  Branch (9290:9): [True: 54.9k, False: 478]
  ------------------
 9291|  54.9k|        g.InputEventsQueue.resize(0);
 9292|    478|    else
 9293|    478|        g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
 9294|       |
 9295|       |    // Clear buttons state when focus is lost
 9296|       |    // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
 9297|       |    // - we clear in EndFrame() and not now in order allow application/user code polling this flag
 9298|       |    //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
 9299|  55.4k|    if (g.IO.AppFocusLost)
  ------------------
  |  Branch (9299:9): [True: 0, False: 55.4k]
  ------------------
 9300|      0|        g.IO.ClearInputKeys();
 9301|  55.4k|}
_ZN5ImGui12TestKeyOwnerE8ImGuiKeyj:
 9324|   147k|{
 9325|   147k|    if (!IsNamedKeyOrModKey(key))
  ------------------
  |  Branch (9325:9): [True: 0, False: 147k]
  ------------------
 9326|      0|        return true;
 9327|       |
 9328|   147k|    ImGuiContext& g = *GImGui;
 9329|   147k|    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
  ------------------
  |  | 1311|     25|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9329:9): [True: 25, False: 147k]
  |  Branch (9329:43): [True: 25, False: 0]
  |  Branch (9329:69): [True: 23, False: 2]
  ------------------
 9330|     23|        if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1238|     46|#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
  ------------------
                      if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1239|     23|#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
  ------------------
  |  Branch (9330:13): [True: 23, False: 0]
  |  Branch (9330:47): [True: 1, False: 22]
  ------------------
 9331|      1|            return false;
 9332|       |
 9333|   147k|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
 9334|   147k|    if (owner_id == ImGuiKeyOwner_Any)
  ------------------
  |  | 1311|   147k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9334:9): [True: 32.7k, False: 115k]
  ------------------
 9335|  32.7k|        return (owner_data->LockThisFrame == false);
 9336|       |
 9337|       |    // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
 9338|       |    // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
 9339|       |    // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
 9340|   115k|    if (owner_data->OwnerCurr != owner_id)
  ------------------
  |  Branch (9340:9): [True: 61, False: 115k]
  ------------------
 9341|     61|    {
 9342|     61|        if (owner_data->LockThisFrame)
  ------------------
  |  Branch (9342:13): [True: 0, False: 61]
  ------------------
 9343|      0|            return false;
 9344|     61|        if (owner_data->OwnerCurr != ImGuiKeyOwner_None)
  ------------------
  |  | 1312|     61|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9344:13): [True: 0, False: 61]
  ------------------
 9345|      0|            return false;
 9346|     61|    }
 9347|       |
 9348|   115k|    return true;
 9349|   115k|}
_ZN5ImGui11SetKeyOwnerE8ImGuiKeyji:
 9357|     63|{
 9358|     63|    IM_ASSERT(IsNamedKeyOrModKey(key) && (owner_id != ImGuiKeyOwner_Any || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
  ------------------
  |  |   23|     63|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9359|     63|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|     63|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9360|       |
 9361|     63|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
 9362|     63|    owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;
 9363|       |
 9364|       |    // We cannot lock by default as it would likely break lots of legacy code.
 9365|       |    // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
 9366|     63|    owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
 9367|     63|    owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);
  ------------------
  |  Branch (9367:33): [True: 0, False: 63]
  |  Branch (9367:81): [True: 0, False: 63]
  ------------------
 9368|     63|}
_ZN5ImGui8ShortcutEiji:
 9392|   110k|{
 9393|   110k|    ImGuiContext& g = *GImGui;
 9394|       |
 9395|       |    // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
 9396|   110k|    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
  ------------------
  |  Branch (9396:9): [True: 110k, False: 0]
  ------------------
 9397|   110k|        flags |= ImGuiInputFlags_RouteFocused;
 9398|   110k|    if (!SetShortcutRouting(key_chord, owner_id, flags))
  ------------------
  |  Branch (9398:9): [True: 0, False: 110k]
  ------------------
 9399|      0|        return false;
 9400|       |
 9401|   110k|    if (key_chord & ImGuiMod_Shortcut)
  ------------------
  |  Branch (9401:9): [True: 0, False: 110k]
  ------------------
 9402|      0|        key_chord = ConvertShortcutMod(key_chord);
 9403|   110k|    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
 9404|   110k|    if (g.IO.KeyMods != mods)
  ------------------
  |  Branch (9404:9): [True: 97.5k, False: 13.2k]
  ------------------
 9405|  97.5k|        return false;
 9406|       |
 9407|       |    // Special storage location for mods
 9408|  13.2k|    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
 9409|  13.2k|    if (key == ImGuiKey_None)
  ------------------
  |  Branch (9409:9): [True: 0, False: 13.2k]
  ------------------
 9410|      0|        key = ConvertSingleModFlagToKey(mods);
 9411|       |
 9412|  13.2k|    if (!IsKeyPressed(key, owner_id, (flags & (ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateMask_))))
  ------------------
  |  Branch (9412:9): [True: 10.1k, False: 3.08k]
  ------------------
 9413|  10.1k|        return false;
 9414|  3.08k|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|  3.08k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9415|       |
 9416|  3.08k|    return true;
 9417|  13.2k|}
_ZN5ImGui30DebugCheckVersionAndDataLayoutEPKcmmmmmm:
 9433|      1|{
 9434|      1|    bool error = false;
 9435|      1|    if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   25|      1|#define IMGUI_VERSION               "1.89.2 WIP"
  ------------------
                  if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9435:9): [True: 0, False: 1]
  ------------------
 9436|      1|    if (sz_io != sizeof(ImGuiIO)) { error = true; IM_ASSERT(sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9436:9): [True: 0, False: 1]
  ------------------
 9437|      1|    if (sz_style != sizeof(ImGuiStyle)) { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9437:9): [True: 0, False: 1]
  ------------------
 9438|      1|    if (sz_vec2 != sizeof(ImVec2)) { error = true; IM_ASSERT(sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9438:9): [True: 0, False: 1]
  ------------------
 9439|      1|    if (sz_vec4 != sizeof(ImVec4)) { error = true; IM_ASSERT(sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9439:9): [True: 0, False: 1]
  ------------------
 9440|      1|    if (sz_vert != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9440:9): [True: 0, False: 1]
  ------------------
 9441|      1|    if (sz_idx != sizeof(ImDrawIdx)) { error = true; IM_ASSERT(sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9441:9): [True: 0, False: 1]
  ------------------
 9442|      1|    return !error;
 9443|      1|}
_ZN15ImGuiStackSizes17SetToCurrentStateEv:
 9685|   132k|{
 9686|   132k|    ImGuiContext& g = *GImGui;
 9687|   132k|    ImGuiWindow* window = g.CurrentWindow;
 9688|   132k|    SizeOfIDStack = (short)window->IDStack.Size;
 9689|   132k|    SizeOfColorStack = (short)g.ColorStack.Size;
 9690|   132k|    SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
 9691|   132k|    SizeOfFontStack = (short)g.FontStack.Size;
 9692|   132k|    SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
 9693|   132k|    SizeOfGroupStack = (short)g.GroupStack.Size;
 9694|   132k|    SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
 9695|   132k|    SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
 9696|   132k|    SizeOfDisabledStack = (short)g.DisabledStackSize;
 9697|   132k|}
_ZN15ImGuiStackSizes23CompareWithCurrentStateEv:
 9701|   132k|{
 9702|   132k|    ImGuiContext& g = *GImGui;
 9703|   132k|    ImGuiWindow* window = g.CurrentWindow;
 9704|   132k|    IM_UNUSED(window);
  ------------------
  |  |   88|   132k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9705|       |
 9706|       |    // Window stacks
 9707|       |    // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
 9708|   132k|    IM_ASSERT(SizeOfIDStack         == window->IDStack.Size     && "PushID/PopID or TreeNode/TreePop Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9709|       |
 9710|       |    // Global stacks
 9711|       |    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
 9712|   132k|    IM_ASSERT(SizeOfGroupStack      == g.GroupStack.Size        && "BeginGroup/EndGroup Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9713|   132k|    IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size   && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9714|   132k|    IM_ASSERT(SizeOfDisabledStack   == g.DisabledStackSize      && "BeginDisabled/EndDisabled Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9715|   132k|    IM_ASSERT(SizeOfItemFlagsStack  >= g.ItemFlagsStack.Size    && "PushItemFlag/PopItemFlag Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9716|   132k|    IM_ASSERT(SizeOfColorStack      >= g.ColorStack.Size        && "PushStyleColor/PopStyleColor Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9717|   132k|    IM_ASSERT(SizeOfStyleVarStack   >= g.StyleVarStack.Size     && "PushStyleVar/PopStyleVar Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9718|   132k|    IM_ASSERT(SizeOfFontStack       >= g.FontStack.Size         && "PushFont/PopFont Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9719|   132k|    IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size   && "PushFocusScope/PopFocusScope Mismatch!");
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9720|   132k|}
_ZN5ImGui8ItemSizeERK6ImVec2f:
 9759|  28.7k|{
 9760|  28.7k|    ImGuiContext& g = *GImGui;
 9761|  28.7k|    ImGuiWindow* window = g.CurrentWindow;
 9762|  28.7k|    if (window->SkipItems)
  ------------------
  |  Branch (9762:9): [True: 0, False: 28.7k]
  ------------------
 9763|      0|        return;
 9764|       |
 9765|       |    // We increase the height in this function to accommodate for baseline offset.
 9766|       |    // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
 9767|       |    // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
 9768|  28.7k|    const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
  ------------------
  |  Branch (9768:46): [True: 10.2k, False: 18.4k]
  ------------------
 9769|       |
 9770|  28.7k|    const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
  ------------------
  |  Branch (9770:27): [True: 0, False: 28.7k]
  ------------------
 9771|  28.7k|    const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/window->DC.CursorPos.y - line_y1/*, 0.0f)*/ + size.y + offset_to_match_baseline_y);
 9772|       |
 9773|       |    // Always align ourselves on pixel boundaries
 9774|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
 9775|  28.7k|    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
 9776|  28.7k|    window->DC.CursorPosPrevLine.y = line_y1;
 9777|  28.7k|    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
  ------------------
  |  |  266|  28.7k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 9778|  28.7k|    window->DC.CursorPos.y = IM_FLOOR(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
  ------------------
  |  |  266|  28.7k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 9779|  28.7k|    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
 9780|  28.7k|    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
 9781|       |    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
 9782|       |
 9783|  28.7k|    window->DC.PrevLineSize.y = line_height;
 9784|  28.7k|    window->DC.CurrLineSize.y = 0.0f;
 9785|  28.7k|    window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
 9786|  28.7k|    window->DC.CurrLineTextBaseOffset = 0.0f;
 9787|  28.7k|    window->DC.IsSameLine = window->DC.IsSetPos = false;
 9788|       |
 9789|       |    // Horizontal layout mode
 9790|  28.7k|    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
  ------------------
  |  Branch (9790:9): [True: 0, False: 28.7k]
  ------------------
 9791|      0|        SameLine();
 9792|  28.7k|}
_ZN5ImGui7ItemAddERK6ImRectjPS1_i:
 9798|   160k|{
 9799|   160k|    ImGuiContext& g = *GImGui;
 9800|   160k|    ImGuiWindow* window = g.CurrentWindow;
 9801|       |
 9802|       |    // Set item data
 9803|       |    // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
 9804|   160k|    g.LastItemData.ID = id;
 9805|   160k|    g.LastItemData.Rect = bb;
 9806|   160k|    g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
  ------------------
  |  Branch (9806:30): [True: 0, False: 160k]
  ------------------
 9807|   160k|    g.LastItemData.InFlags = g.CurrentItemFlags | extra_flags;
 9808|   160k|    g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
 9809|       |
 9810|       |    // Directional navigation processing
 9811|   160k|    if (id != 0)
  ------------------
  |  Branch (9811:9): [True: 150k, False: 9.43k]
  ------------------
 9812|   150k|    {
 9813|   150k|        KeepAliveID(id);
 9814|       |
 9815|       |        // Runs prior to clipping early-out
 9816|       |        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
 9817|       |        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
 9818|       |        //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
 9819|       |        //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
 9820|       |        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
 9821|       |        //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
 9822|       |        // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
 9823|       |        // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
 9824|   150k|        if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
  ------------------
  |  Branch (9824:13): [True: 130k, False: 20.6k]
  ------------------
 9825|   130k|        {
 9826|   130k|            window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
 9827|   130k|            if (g.NavId == id || g.NavAnyRequest)
  ------------------
  |  Branch (9827:17): [True: 247, False: 129k]
  |  Branch (9827:34): [True: 1.37k, False: 128k]
  ------------------
 9828|  1.62k|                if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
  ------------------
  |  Branch (9828:21): [True: 368, False: 1.25k]
  ------------------
 9829|    368|                    if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
  ------------------
  |  Branch (9829:25): [True: 368, False: 0]
  |  Branch (9829:50): [True: 0, False: 0]
  ------------------
 9830|    368|                        NavProcessItem();
 9831|   130k|        }
 9832|       |
 9833|       |        // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
 9834|       |        // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
 9835|       |        // READ THE FAQ: https://dearimgui.org/faq
 9836|   150k|        IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
  ------------------
  |  |   23|   150k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9837|   150k|    }
 9838|   160k|    g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
 9839|       |
 9840|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 9841|       |    if (id != 0)
 9842|       |        IMGUI_TEST_ENGINE_ITEM_ADD(nav_bb_arg ? *nav_bb_arg : bb, id);
 9843|       |#endif
 9844|       |
 9845|       |    // Clipping test
 9846|       |    // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
 9847|       |    //const bool is_clipped = IsClippedEx(bb, id);
 9848|       |    //if (is_clipped)
 9849|       |    //    return false;
 9850|   160k|    const bool is_rect_visible = bb.Overlaps(window->ClipRect);
 9851|   160k|    if (!is_rect_visible)
  ------------------
  |  Branch (9851:9): [True: 20.3k, False: 139k]
  ------------------
 9852|  20.3k|        if (id == 0 || (id != g.ActiveId && id != g.NavId))
  ------------------
  |  Branch (9852:13): [True: 7.37k, False: 12.9k]
  |  Branch (9852:25): [True: 12.9k, False: 0]
  |  Branch (9852:45): [True: 12.9k, False: 3]
  ------------------
 9853|  20.3k|            if (!g.LogEnabled)
  ------------------
  |  Branch (9853:17): [True: 20.3k, False: 0]
  ------------------
 9854|  20.3k|                return false;
 9855|       |
 9856|       |    // [DEBUG]
 9857|   139k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 9858|   139k|    if (id != 0 && id == g.DebugLocateId)
  ------------------
  |  Branch (9858:9): [True: 137k, False: 2.06k]
  |  Branch (9858:20): [True: 0, False: 137k]
  ------------------
 9859|      0|        DebugLocateItemResolveWithLastItem();
 9860|   139k|#endif
 9861|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
 9862|       |
 9863|       |    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
 9864|   139k|    if (is_rect_visible)
  ------------------
  |  Branch (9864:9): [True: 139k, False: 3]
  ------------------
 9865|   139k|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
 9866|   139k|    if (IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (9866:9): [True: 2.44k, False: 137k]
  ------------------
 9867|  2.44k|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
 9868|   139k|    return true;
 9869|   160k|}
_ZN5ImGui18GetCursorScreenPosEv:
 9903|  13.5k|{
 9904|  13.5k|    ImGuiWindow* window = GetCurrentWindowRead();
 9905|  13.5k|    return window->DC.CursorPos;
 9906|  13.5k|}
_ZN5ImGui28GetTextLineHeightWithSpacingEv:
10078|  11.3k|{
10079|  11.3k|    ImGuiContext& g = *GImGui;
10080|  11.3k|    return g.FontSize + g.Style.ItemSpacing.y;
10081|  11.3k|}
_ZN5ImGui14GetFrameHeightEv:
10084|     19|{
10085|     19|    ImGuiContext& g = *GImGui;
10086|     19|    return g.FontSize + g.Style.FramePadding.y * 2.0f;
10087|     19|}
_ZN5ImGui22GetContentRegionMaxAbsEv:
10110|  11.3k|{
10111|  11.3k|    ImGuiContext& g = *GImGui;
10112|  11.3k|    ImGuiWindow* window = g.CurrentWindow;
10113|  11.3k|    ImVec2 mx = window->ContentRegionRect.Max;
10114|  11.3k|    if (window->DC.CurrentColumns || g.CurrentTable)
  ------------------
  |  Branch (10114:9): [True: 0, False: 11.3k]
  |  Branch (10114:38): [True: 0, False: 11.3k]
  ------------------
10115|      0|        mx.x = window->WorkRect.Max.x;
10116|  11.3k|    return mx;
10117|  11.3k|}
_ZN5ImGui21GetContentRegionAvailEv:
10120|  11.3k|{
10121|  11.3k|    ImGuiWindow* window = GImGui->CurrentWindow;
10122|  11.3k|    return GetContentRegionMaxAbs() - window->DC.CursorPos;
10123|  11.3k|}
_ZN5ImGui25GetWindowContentRegionMaxEv:
10133|  11.3k|{
10134|  11.3k|    ImGuiWindow* window = GImGui->CurrentWindow;
10135|  11.3k|    return window->ContentRegionRect.Max - window->Pos;
10136|  11.3k|}
_ZN5ImGui10GetScrollXEv:
10360|  14.4k|{
10361|  14.4k|    ImGuiWindow* window = GImGui->CurrentWindow;
10362|  14.4k|    return window->Scroll.x;
10363|  14.4k|}
_ZN5ImGui10GetScrollYEv:
10366|  14.4k|{
10367|  14.4k|    ImGuiWindow* window = GImGui->CurrentWindow;
10368|  14.4k|    return window->Scroll.y;
10369|  14.4k|}
_ZN5ImGui10SetScrollXEP11ImGuiWindowf:
10384|  2.11k|{
10385|  2.11k|    window->ScrollTarget.x = scroll_x;
10386|  2.11k|    window->ScrollTargetCenterRatio.x = 0.0f;
10387|  2.11k|    window->ScrollTargetEdgeSnapDist.x = 0.0f;
10388|  2.11k|}
_ZN5ImGui10SetScrollYEP11ImGuiWindowf:
10391|  2.31k|{
10392|  2.31k|    window->ScrollTarget.y = scroll_y;
10393|  2.31k|    window->ScrollTargetCenterRatio.y = 0.0f;
10394|  2.31k|    window->ScrollTargetEdgeSnapDist.y = 0.0f;
10395|  2.31k|}
_ZN5ImGui10SetScrollXEf:
10398|  2.07k|{
10399|  2.07k|    ImGuiContext& g = *GImGui;
10400|  2.07k|    SetScrollX(g.CurrentWindow, scroll_x);
10401|  2.07k|}
_ZN5ImGui10SetScrollYEf:
10404|  2.28k|{
10405|  2.28k|    ImGuiContext& g = *GImGui;
10406|  2.28k|    SetScrollY(g.CurrentWindow, scroll_y);
10407|  2.28k|}
_ZN5ImGui20GetTopMostPopupModalEv:
10581|   166k|{
10582|   166k|    ImGuiContext& g = *GImGui;
10583|   166k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (10583:45): [True: 0, False: 166k]
  ------------------
10584|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (10584:26): [True: 0, False: 0]
  ------------------
10585|      0|            if (popup->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (10585:17): [True: 0, False: 0]
  ------------------
10586|      0|                return popup;
10587|   166k|    return NULL;
10588|   166k|}
_ZN5ImGui30GetTopMostAndVisiblePopupModalEv:
10591|  55.4k|{
10592|  55.4k|    ImGuiContext& g = *GImGui;
10593|  55.4k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (10593:45): [True: 0, False: 55.4k]
  ------------------
10594|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (10594:26): [True: 0, False: 0]
  ------------------
10595|      0|            if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
  ------------------
  |  Branch (10595:17): [True: 0, False: 0]
  |  Branch (10595:60): [True: 0, False: 0]
  ------------------
10596|      0|                return popup;
10597|  55.4k|    return NULL;
10598|  55.4k|}
_ZN5ImGui21ClosePopupsOverWindowEP11ImGuiWindowb:
10667|  4.62k|{
10668|  4.62k|    ImGuiContext& g = *GImGui;
10669|  4.62k|    if (g.OpenPopupStack.Size == 0)
  ------------------
  |  Branch (10669:9): [True: 4.62k, False: 0]
  ------------------
10670|  4.62k|        return;
10671|       |
10672|       |    // Don't close our own child popup windows.
10673|      0|    int popup_count_to_keep = 0;
10674|      0|    if (ref_window)
  ------------------
  |  Branch (10674:9): [True: 0, False: 0]
  ------------------
10675|      0|    {
10676|       |        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
10677|      0|        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
  ------------------
  |  Branch (10677:16): [True: 0, False: 0]
  ------------------
10678|      0|        {
10679|      0|            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
10680|      0|            if (!popup.Window)
  ------------------
  |  Branch (10680:17): [True: 0, False: 0]
  ------------------
10681|      0|                continue;
10682|      0|            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10683|      0|            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (10683:17): [True: 0, False: 0]
  ------------------
10684|      0|                continue;
10685|       |
10686|       |            // Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
10687|       |            // - With this stack of window, clicking/focusing Popup1 will close Popup2 and Popup3:
10688|       |            //     Window -> Popup1 -> Popup2 -> Popup3
10689|       |            // - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
10690|       |            //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
10691|      0|            bool ref_window_is_descendent_of_popup = false;
10692|      0|            for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
  ------------------
  |  Branch (10692:47): [True: 0, False: 0]
  ------------------
10693|      0|                if (ImGuiWindow* popup_window = g.OpenPopupStack[n].Window)
  ------------------
  |  Branch (10693:34): [True: 0, False: 0]
  ------------------
10694|       |                    //if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree) // FIXME-MERGE
10695|      0|                    if (IsWindowWithinBeginStackOf(ref_window, popup_window))
  ------------------
  |  Branch (10695:25): [True: 0, False: 0]
  ------------------
10696|      0|                    {
10697|      0|                        ref_window_is_descendent_of_popup = true;
10698|      0|                        break;
10699|      0|                    }
10700|      0|            if (!ref_window_is_descendent_of_popup)
  ------------------
  |  Branch (10700:17): [True: 0, False: 0]
  ------------------
10701|      0|                break;
10702|      0|        }
10703|      0|    }
10704|      0|    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
  ------------------
  |  Branch (10704:9): [True: 0, False: 0]
  ------------------
10705|      0|    {
10706|      0|        IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
  ------------------
  |  |  228|      0|#define IMGUI_DEBUG_LOG_POPUP(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (222:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (228:50): [True: 0, False: 0]
  |  |  |  Branch (228:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
10707|      0|        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
10708|      0|    }
10709|      0|}
_ZN5ImGui12SetNavWindowEP11ImGuiWindow:
11096|  3.93k|{
11097|  3.93k|    ImGuiContext& g = *GImGui;
11098|  3.93k|    if (g.NavWindow != window)
  ------------------
  |  Branch (11098:9): [True: 3.93k, False: 0]
  ------------------
11099|  3.93k|    {
11100|  3.93k|        IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
  ------------------
  |  |  227|  3.93k|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (222:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (227:50): [True: 0, False: 3.93k]
  |  |  |  Branch (227:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11101|  3.93k|        g.NavWindow = window;
11102|  3.93k|    }
11103|  3.93k|    g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11104|  3.93k|    NavUpdateAnyRequestFlag();
11105|  3.93k|}
_ZN5ImGui8SetNavIDEj13ImGuiNavLayerjRK6ImRect:
11108|    329|{
11109|    329|    ImGuiContext& g = *GImGui;
11110|    329|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|    329|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11111|    329|    IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|    329|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11112|    329|    g.NavId = id;
11113|    329|    g.NavLayer = nav_layer;
11114|    329|    g.NavFocusScopeId = focus_scope_id;
11115|    329|    g.NavWindow->NavLastIds[nav_layer] = id;
11116|    329|    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
11117|    329|}
_ZN5ImGui10SetFocusIDEjP11ImGuiWindow:
11120|     63|{
11121|     63|    ImGuiContext& g = *GImGui;
11122|     63|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|     63|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11123|       |
11124|     63|    if (g.NavWindow != window)
  ------------------
  |  Branch (11124:9): [True: 63, False: 0]
  ------------------
11125|     63|       SetNavWindow(window);
11126|       |
11127|       |    // Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
11128|       |    // Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
11129|     63|    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
11130|     63|    g.NavId = id;
11131|     63|    g.NavLayer = nav_layer;
11132|     63|    g.NavFocusScopeId = g.CurrentFocusScopeId;
11133|     63|    window->NavLastIds[nav_layer] = id;
11134|     63|    if (g.LastItemData.ID == id)
  ------------------
  |  Branch (11134:9): [True: 63, False: 0]
  ------------------
11135|     63|        window->NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect);
11136|       |
11137|     63|    if (g.ActiveIdSource == ImGuiInputSource_Nav)
  ------------------
  |  Branch (11137:9): [True: 0, False: 63]
  ------------------
11138|      0|        g.NavDisableMouseHover = true;
11139|     63|    else
11140|     63|        g.NavDisableHighlight = true;
11141|     63|}
_ZN5ImGui28NavMoveRequestButNoResultYetEv:
11434|  9.25k|{
11435|  9.25k|    ImGuiContext& g = *GImGui;
11436|  9.25k|    return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
  ------------------
  |  Branch (11436:12): [True: 211, False: 9.04k]
  |  Branch (11436:37): [True: 211, False: 0]
  |  Branch (11436:69): [True: 211, False: 0]
  ------------------
11437|  9.25k|}
_ZN5ImGui20NavMoveRequestSubmitEiiii:
11441|    211|{
11442|    211|    ImGuiContext& g = *GImGui;
11443|    211|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|    211|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11444|       |
11445|    211|    if (move_flags & ImGuiNavMoveFlags_Tabbing)
  ------------------
  |  Branch (11445:9): [True: 98, False: 113]
  ------------------
11446|     98|        move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;
11447|       |
11448|    211|    g.NavMoveSubmitted = g.NavMoveScoringItems = true;
11449|    211|    g.NavMoveDir = move_dir;
11450|    211|    g.NavMoveDirForDebug = move_dir;
11451|    211|    g.NavMoveClipDir = clip_dir;
11452|    211|    g.NavMoveFlags = move_flags;
11453|    211|    g.NavMoveScrollFlags = scroll_flags;
11454|    211|    g.NavMoveForwardToNextFrame = false;
11455|    211|    g.NavMoveKeyMods = g.IO.KeyMods;
11456|    211|    g.NavMoveResultLocal.Clear();
11457|    211|    g.NavMoveResultLocalVisible.Clear();
11458|    211|    g.NavMoveResultOther.Clear();
11459|    211|    g.NavTabbingCounter = 0;
11460|    211|    g.NavTabbingResultFirst.Clear();
11461|    211|    NavUpdateAnyRequestFlag();
11462|    211|}
_ZN5ImGui20NavMoveRequestCancelEv:
11473|     31|{
11474|     31|    ImGuiContext& g = *GImGui;
11475|     31|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11476|     31|    NavUpdateAnyRequestFlag();
11477|     31|}
_ZN5ImGui13NavInitWindowEP11ImGuiWindowb:
11565|    321|{
11566|       |    // FIXME: ChildWindow test here is wrong for docking
11567|    321|    ImGuiContext& g = *GImGui;
11568|    321|    IM_ASSERT(window == g.NavWindow);
  ------------------
  |  |   23|    321|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11569|       |
11570|    321|    if (window->Flags & ImGuiWindowFlags_NoNavInputs)
  ------------------
  |  Branch (11570:9): [True: 0, False: 321]
  ------------------
11571|      0|    {
11572|      0|        g.NavId = 0;
11573|      0|        g.NavFocusScopeId = window->NavRootFocusScopeId;
11574|      0|        return;
11575|      0|    }
11576|       |
11577|    321|    bool init_for_nav = false;
11578|    321|    if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
  ------------------
  |  Branch (11578:9): [True: 2, False: 319]
  |  Branch (11578:41): [True: 0, False: 319]
  |  Branch (11578:85): [True: 319, False: 0]
  |  Branch (11578:117): [True: 0, False: 0]
  ------------------
11579|    321|        init_for_nav = true;
11580|    321|    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
  ------------------
  |  |  229|    321|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 321]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11581|    321|    if (init_for_nav)
  ------------------
  |  Branch (11581:9): [True: 321, False: 0]
  ------------------
11582|    321|    {
11583|    321|        SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
11584|    321|        g.NavInitRequest = true;
11585|    321|        g.NavInitRequestFromMove = false;
11586|    321|        g.NavInitResultId = 0;
11587|    321|        g.NavInitResultRectRel = ImRect();
11588|    321|        NavUpdateAnyRequestFlag();
11589|    321|    }
11590|      0|    else
11591|      0|    {
11592|      0|        g.NavId = window->NavLastIds[0];
11593|      0|        g.NavFocusScopeId = window->NavRootFocusScopeId;
11594|      0|    }
11595|    321|}
_ZN5ImGui25NavInitRequestApplyResultEv:
11814|      1|{
11815|       |    // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
11816|      1|    ImGuiContext& g = *GImGui;
11817|      1|    if (!g.NavWindow)
  ------------------
  |  Branch (11817:9): [True: 1, False: 0]
  ------------------
11818|      1|        return;
11819|       |
11820|       |    // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
11821|       |    // FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
11822|      0|    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", g.NavInitResultId, g.NavLayer, g.NavWindow->Name);
  ------------------
  |  |  229|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 0]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11823|      0|    SetNavID(g.NavInitResultId, g.NavLayer, 0, g.NavInitResultRectRel);
11824|      0|    g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
11825|      0|    if (g.NavInitRequestFromMove)
  ------------------
  |  Branch (11825:9): [True: 0, False: 0]
  ------------------
11826|      0|        NavRestoreHighlightAfterMove();
11827|      0|}
_ZN5ImGui25NavMoveRequestApplyResultEv:
11964|    171|{
11965|    171|    ImGuiContext& g = *GImGui;
11966|       |#if IMGUI_DEBUG_NAV_SCORING
11967|       |    if (g.NavMoveFlags & ImGuiNavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items in NavWindow at all times
11968|       |        return;
11969|       |#endif
11970|       |
11971|       |    // Select which result to use
11972|    171|    ImGuiNavItemData* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : NULL;
  ------------------
  |  Branch (11972:32): [True: 0, False: 171]
  |  Branch (11972:89): [True: 0, False: 171]
  ------------------
11973|       |
11974|       |    // Tabbing forward wrap
11975|    171|    if (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing)
  ------------------
  |  Branch (11975:9): [True: 90, False: 81]
  ------------------
11976|     90|        if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID)
  ------------------
  |  Branch (11976:14): [True: 0, False: 90]
  |  Branch (11976:42): [True: 84, False: 6]
  |  Branch (11976:67): [True: 0, False: 84]
  ------------------
11977|      0|            result = &g.NavTabbingResultFirst;
11978|       |
11979|       |    // In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
11980|    171|    if (result == NULL)
  ------------------
  |  Branch (11980:9): [True: 171, False: 0]
  ------------------
11981|    171|    {
11982|    171|        if (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing)
  ------------------
  |  Branch (11982:13): [True: 90, False: 81]
  ------------------
11983|     90|            g.NavMoveFlags |= ImGuiNavMoveFlags_DontSetNavHighlight;
11984|    171|        if (g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_DontSetNavHighlight) == 0)
  ------------------
  |  Branch (11984:13): [True: 114, False: 57]
  |  Branch (11984:29): [True: 35, False: 79]
  ------------------
11985|     35|            NavRestoreHighlightAfterMove();
11986|    171|        return;
11987|    171|    }
11988|       |
11989|       |    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
11990|      0|    if (g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
  ------------------
  |  Branch (11990:9): [True: 0, False: 0]
  ------------------
11991|      0|        if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId)
  ------------------
  |  Branch (11991:13): [True: 0, False: 0]
  |  Branch (11991:52): [True: 0, False: 0]
  ------------------
11992|      0|            result = &g.NavMoveResultLocalVisible;
11993|       |
11994|       |    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
11995|      0|    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (11995:9): [True: 0, False: 0]
  |  Branch (11995:44): [True: 0, False: 0]
  |  Branch (11995:76): [True: 0, False: 0]
  ------------------
11996|      0|        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
  ------------------
  |  Branch (11996:13): [True: 0, False: 0]
  |  Branch (11996:66): [True: 0, False: 0]
  |  Branch (11996:117): [True: 0, False: 0]
  ------------------
11997|      0|            result = &g.NavMoveResultOther;
11998|      0|    IM_ASSERT(g.NavWindow && result->Window);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11999|       |
12000|       |    // Scroll to keep newly navigated item fully into view.
12001|      0|    if (g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (12001:9): [True: 0, False: 0]
  ------------------
12002|      0|    {
12003|      0|        if (g.NavMoveFlags & ImGuiNavMoveFlags_ScrollToEdgeY)
  ------------------
  |  Branch (12003:13): [True: 0, False: 0]
  ------------------
12004|      0|        {
12005|       |            // FIXME: Should remove this
12006|      0|            float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
  ------------------
  |  Branch (12006:35): [True: 0, False: 0]
  ------------------
12007|      0|            SetScrollY(result->Window, scroll_target);
12008|      0|        }
12009|      0|        else
12010|      0|        {
12011|      0|            ImRect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
12012|      0|            ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);
12013|      0|        }
12014|      0|    }
12015|       |
12016|      0|    if (g.NavWindow != result->Window)
  ------------------
  |  Branch (12016:9): [True: 0, False: 0]
  ------------------
12017|      0|    {
12018|      0|        IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result->Window->Name);
  ------------------
  |  |  227|      0|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (227:50): [True: 0, False: 0]
  |  |  |  Branch (227:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12019|      0|        g.NavWindow = result->Window;
12020|      0|    }
12021|      0|    if (g.ActiveId != result->ID)
  ------------------
  |  Branch (12021:9): [True: 0, False: 0]
  ------------------
12022|      0|        ClearActiveID();
12023|      0|    if (g.NavId != result->ID)
  ------------------
  |  Branch (12023:9): [True: 0, False: 0]
  ------------------
12024|      0|    {
12025|       |        // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
12026|      0|        g.NavJustMovedToId = result->ID;
12027|      0|        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
12028|      0|        g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
12029|      0|    }
12030|       |
12031|       |    // Focus
12032|      0|    IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
  ------------------
  |  |  229|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 0]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12033|      0|    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
12034|       |
12035|       |    // Tabbing: Activates Inputable or Focus non-Inputable
12036|      0|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing) && (result->InFlags & ImGuiItemFlags_Inputable))
  ------------------
  |  Branch (12036:9): [True: 0, False: 0]
  |  Branch (12036:57): [True: 0, False: 0]
  ------------------
12037|      0|    {
12038|      0|        g.NavNextActivateId = result->ID;
12039|      0|        g.NavNextActivateFlags = ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState;
12040|      0|        g.NavMoveFlags |= ImGuiNavMoveFlags_DontSetNavHighlight;
12041|      0|    }
12042|       |
12043|       |    // Activate
12044|      0|    if (g.NavMoveFlags & ImGuiNavMoveFlags_Activate)
  ------------------
  |  Branch (12044:9): [True: 0, False: 0]
  ------------------
12045|      0|    {
12046|      0|        g.NavNextActivateId = result->ID;
12047|      0|        g.NavNextActivateFlags = ImGuiActivateFlags_None;
12048|      0|    }
12049|       |
12050|       |    // Enable nav highlight
12051|      0|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_DontSetNavHighlight) == 0)
  ------------------
  |  Branch (12051:9): [True: 0, False: 0]
  ------------------
12052|      0|        NavRestoreHighlightAfterMove();
12053|      0|}
_ZN5ImGui13ClearDragDropEv:
12538|     14|{
12539|     14|    ImGuiContext& g = *GImGui;
12540|     14|    g.DragDropActive = false;
12541|     14|    g.DragDropPayload.Clear();
12542|     14|    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
12543|     14|    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
12544|     14|    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
12545|     14|    g.DragDropAcceptFrameCount = -1;
12546|       |
12547|     14|    g.DragDropPayloadBufHeap.clear();
12548|     14|    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
12549|     14|}
_ZN5ImGui19BeginDragDropSourceEi:
12559|     18|{
12560|     18|    ImGuiContext& g = *GImGui;
12561|     18|    ImGuiWindow* window = g.CurrentWindow;
12562|       |
12563|       |    // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
12564|       |    // in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
12565|     18|    ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;
12566|       |
12567|     18|    bool source_drag_active = false;
12568|     18|    ImGuiID source_id = 0;
12569|     18|    ImGuiID source_parent_id = 0;
12570|     18|    if (!(flags & ImGuiDragDropFlags_SourceExtern))
  ------------------
  |  Branch (12570:9): [True: 18, False: 0]
  ------------------
12571|     18|    {
12572|     18|        source_id = g.LastItemData.ID;
12573|     18|        if (source_id != 0)
  ------------------
  |  Branch (12573:13): [True: 18, False: 0]
  ------------------
12574|     18|        {
12575|       |            // Common path: items with ID
12576|     18|            if (g.ActiveId != source_id)
  ------------------
  |  Branch (12576:17): [True: 0, False: 18]
  ------------------
12577|      0|                return false;
12578|     18|            if (g.ActiveIdMouseButton != -1)
  ------------------
  |  Branch (12578:17): [True: 0, False: 18]
  ------------------
12579|      0|                mouse_button = g.ActiveIdMouseButton;
12580|     18|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (12580:17): [True: 0, False: 18]
  |  Branch (12580:58): [True: 0, False: 18]
  ------------------
12581|      0|                return false;
12582|     18|            g.ActiveIdAllowOverlap = false;
12583|     18|        }
12584|      0|        else
12585|      0|        {
12586|       |            // Uncommon path: items without ID
12587|      0|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (12587:17): [True: 0, False: 0]
  |  Branch (12587:58): [True: 0, False: 0]
  ------------------
12588|      0|                return false;
12589|      0|            if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
  ------------------
  |  Branch (12589:17): [True: 0, False: 0]
  |  Branch (12589:90): [True: 0, False: 0]
  |  Branch (12589:109): [True: 0, False: 0]
  ------------------
12590|      0|                return false;
12591|       |
12592|       |            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
12593|       |            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
12594|      0|            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
  ------------------
  |  Branch (12594:17): [True: 0, False: 0]
  ------------------
12595|      0|            {
12596|      0|                IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12597|      0|                return false;
12598|      0|            }
12599|       |
12600|       |            // Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
12601|       |            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
12602|       |            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
12603|       |            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
12604|       |            // Rely on keeping other window->LastItemXXX fields intact.
12605|      0|            source_id = g.LastItemData.ID = window->GetIDFromRectangle(g.LastItemData.Rect);
12606|      0|            KeepAliveID(source_id);
12607|      0|            bool is_hovered = ItemHoverable(g.LastItemData.Rect, source_id);
12608|      0|            if (is_hovered && g.IO.MouseClicked[mouse_button])
  ------------------
  |  Branch (12608:17): [True: 0, False: 0]
  |  Branch (12608:31): [True: 0, False: 0]
  ------------------
12609|      0|            {
12610|      0|                SetActiveID(source_id, window);
12611|      0|                FocusWindow(window);
12612|      0|            }
12613|      0|            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
  ------------------
  |  Branch (12613:17): [True: 0, False: 0]
  ------------------
12614|      0|                g.ActiveIdAllowOverlap = is_hovered;
12615|      0|        }
12616|     18|        if (g.ActiveId != source_id)
  ------------------
  |  Branch (12616:13): [True: 0, False: 18]
  ------------------
12617|      0|            return false;
12618|     18|        source_parent_id = window->IDStack.back();
12619|     18|        source_drag_active = IsMouseDragging(mouse_button);
12620|       |
12621|       |        // Disable navigation and key inputs while dragging + cancel existing request if any
12622|     18|        SetActiveIdUsingAllKeyboardKeys();
12623|     18|    }
12624|      0|    else
12625|      0|    {
12626|      0|        window = NULL;
12627|      0|        source_id = ImHashStr("#SourceExtern");
12628|      0|        source_drag_active = true;
12629|      0|    }
12630|       |
12631|     18|    if (source_drag_active)
  ------------------
  |  Branch (12631:9): [True: 16, False: 2]
  ------------------
12632|     16|    {
12633|     16|        if (!g.DragDropActive)
  ------------------
  |  Branch (12633:13): [True: 7, False: 9]
  ------------------
12634|      7|        {
12635|      7|            IM_ASSERT(source_id != 0);
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12636|      7|            ClearDragDrop();
12637|      7|            ImGuiPayload& payload = g.DragDropPayload;
12638|      7|            payload.SourceId = source_id;
12639|      7|            payload.SourceParentId = source_parent_id;
12640|      7|            g.DragDropActive = true;
12641|      7|            g.DragDropSourceFlags = flags;
12642|      7|            g.DragDropMouseButton = mouse_button;
12643|      7|            if (payload.SourceId == g.ActiveId)
  ------------------
  |  Branch (12643:17): [True: 7, False: 0]
  ------------------
12644|      7|                g.ActiveIdNoClearOnFocusLoss = true;
12645|      7|        }
12646|     16|        g.DragDropSourceFrameCount = g.FrameCount;
12647|     16|        g.DragDropWithinSource = true;
12648|       |
12649|     16|        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (12649:13): [True: 0, False: 16]
  ------------------
12650|      0|        {
12651|       |            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
12652|       |            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
12653|      0|            BeginTooltip();
12654|      0|            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
  ------------------
  |  Branch (12654:17): [True: 0, False: 0]
  |  Branch (12654:43): [True: 0, False: 0]
  ------------------
12655|      0|            {
12656|      0|                ImGuiWindow* tooltip_window = g.CurrentWindow;
12657|      0|                tooltip_window->Hidden = tooltip_window->SkipItems = true;
12658|      0|                tooltip_window->HiddenFramesCanSkipItems = 1;
12659|      0|            }
12660|      0|        }
12661|       |
12662|     16|        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
  ------------------
  |  Branch (12662:13): [True: 16, False: 0]
  |  Branch (12662:67): [True: 16, False: 0]
  ------------------
12663|     16|            g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;
12664|       |
12665|     16|        return true;
12666|     16|    }
12667|      2|    return false;
12668|     18|}
_ZN5ImGui17EndDragDropSourceEv:
12671|     16|{
12672|     16|    ImGuiContext& g = *GImGui;
12673|     16|    IM_ASSERT(g.DragDropActive);
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12674|     16|    IM_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?");
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12675|       |
12676|     16|    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (12676:9): [True: 0, False: 16]
  ------------------
12677|      0|        EndTooltip();
12678|       |
12679|       |    // Discard the drag if have not called SetDragDropPayload()
12680|     16|    if (g.DragDropPayload.DataFrameCount == -1)
  ------------------
  |  Branch (12680:9): [True: 0, False: 16]
  ------------------
12681|      0|        ClearDragDrop();
12682|     16|    g.DragDropWithinSource = false;
12683|     16|}
_ZN5ImGui18SetDragDropPayloadEPKcPKvmi:
12687|     16|{
12688|     16|    ImGuiContext& g = *GImGui;
12689|     16|    ImGuiPayload& payload = g.DragDropPayload;
12690|     16|    if (cond == 0)
  ------------------
  |  Branch (12690:9): [True: 16, False: 0]
  ------------------
12691|     16|        cond = ImGuiCond_Always;
12692|       |
12693|     16|    IM_ASSERT(type != NULL);
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12694|     16|    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12695|     16|    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12696|     16|    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12697|     16|    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12698|       |
12699|     16|    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
  ------------------
  |  Branch (12699:9): [True: 16, False: 0]
  |  Branch (12699:37): [True: 0, False: 0]
  ------------------
12700|     16|    {
12701|       |        // Copy payload
12702|     16|        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
  ------------------
  |  |   87|     16|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
12703|     16|        g.DragDropPayloadBufHeap.resize(0);
12704|     16|        if (data_size > sizeof(g.DragDropPayloadBufLocal))
  ------------------
  |  Branch (12704:13): [True: 0, False: 16]
  ------------------
12705|      0|        {
12706|       |            // Store in heap
12707|      0|            g.DragDropPayloadBufHeap.resize((int)data_size);
12708|      0|            payload.Data = g.DragDropPayloadBufHeap.Data;
12709|      0|            memcpy(payload.Data, data, data_size);
12710|      0|        }
12711|     16|        else if (data_size > 0)
  ------------------
  |  Branch (12711:18): [True: 16, False: 0]
  ------------------
12712|     16|        {
12713|       |            // Store locally
12714|     16|            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
12715|     16|            payload.Data = g.DragDropPayloadBufLocal;
12716|     16|            memcpy(payload.Data, data, data_size);
12717|     16|        }
12718|      0|        else
12719|      0|        {
12720|      0|            payload.Data = NULL;
12721|      0|        }
12722|     16|        payload.DataSize = (int)data_size;
12723|     16|    }
12724|     16|    payload.DataFrameCount = g.FrameCount;
12725|       |
12726|       |    // Return whether the payload has been accepted
12727|     16|    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
  ------------------
  |  Branch (12727:12): [True: 0, False: 16]
  |  Branch (12727:60): [True: 0, False: 16]
  ------------------
12728|     16|}
_ZN5ImGui25BeginDragDropTargetCustomERK6ImRectj:
12731|     39|{
12732|     39|    ImGuiContext& g = *GImGui;
12733|     39|    if (!g.DragDropActive)
  ------------------
  |  Branch (12733:9): [True: 0, False: 39]
  ------------------
12734|      0|        return false;
12735|       |
12736|     39|    ImGuiWindow* window = g.CurrentWindow;
12737|     39|    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
12738|     39|    if (hovered_window == NULL || window->RootWindowDockTree != hovered_window->RootWindowDockTree)
  ------------------
  |  Branch (12738:9): [True: 37, False: 2]
  |  Branch (12738:35): [True: 1, False: 1]
  ------------------
12739|     38|        return false;
12740|      1|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12741|      1|    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
  ------------------
  |  Branch (12741:9): [True: 0, False: 1]
  |  Branch (12741:49): [True: 0, False: 1]
  ------------------
12742|      0|        return false;
12743|      1|    if (window->SkipItems)
  ------------------
  |  Branch (12743:9): [True: 0, False: 1]
  ------------------
12744|      0|        return false;
12745|       |
12746|      1|    IM_ASSERT(g.DragDropWithinTarget == false);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12747|      1|    g.DragDropTargetRect = bb;
12748|      1|    g.DragDropTargetId = id;
12749|      1|    g.DragDropWithinTarget = true;
12750|      1|    return true;
12751|      1|}
_ZN5ImGui30IsDragDropPayloadBeingAcceptedEv:
12788|     13|{
12789|     13|    ImGuiContext& g = *GImGui;
12790|     13|    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
  ------------------
  |  Branch (12790:12): [True: 7, False: 6]
  |  Branch (12790:32): [True: 0, False: 7]
  ------------------
12791|     13|}
_ZN5ImGui21AcceptDragDropPayloadEPKci:
12794|      1|{
12795|      1|    ImGuiContext& g = *GImGui;
12796|      1|    ImGuiWindow* window = g.CurrentWindow;
12797|      1|    ImGuiPayload& payload = g.DragDropPayload;
12798|      1|    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12799|      1|    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12800|      1|    if (type != NULL && !payload.IsDataType(type))
  ------------------
  |  Branch (12800:9): [True: 1, False: 0]
  |  Branch (12800:25): [True: 0, False: 1]
  ------------------
12801|      0|        return NULL;
12802|       |
12803|       |    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
12804|       |    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
12805|      1|    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
12806|      1|    ImRect r = g.DragDropTargetRect;
12807|      1|    float r_surface = r.GetWidth() * r.GetHeight();
12808|      1|    if (r_surface <= g.DragDropAcceptIdCurrRectSurface)
  ------------------
  |  Branch (12808:9): [True: 1, False: 0]
  ------------------
12809|      1|    {
12810|      1|        g.DragDropAcceptFlags = flags;
12811|      1|        g.DragDropAcceptIdCurr = g.DragDropTargetId;
12812|      1|        g.DragDropAcceptIdCurrRectSurface = r_surface;
12813|      1|    }
12814|       |
12815|       |    // Render default drop visuals
12816|      1|    payload.Preview = was_accepted_previously;
12817|      1|    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that live for 1 frame)
12818|      1|    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
  ------------------
  |  Branch (12818:9): [True: 0, False: 1]
  |  Branch (12818:66): [True: 0, False: 0]
  ------------------
12819|      0|        window->DrawList->AddRect(r.Min - ImVec2(3.5f,3.5f), r.Max + ImVec2(3.5f, 3.5f), GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);
12820|       |
12821|      1|    g.DragDropAcceptFrameCount = g.FrameCount;
12822|      1|    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
  ------------------
  |  Branch (12822:24): [True: 0, False: 1]
  |  Branch (12822:51): [True: 0, False: 0]
  ------------------
12823|      1|    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
  ------------------
  |  Branch (12823:9): [True: 1, False: 0]
  |  Branch (12823:30): [True: 0, False: 1]
  ------------------
12824|      0|        return NULL;
12825|       |
12826|      1|    return &payload;
12827|      1|}
_ZN5ImGui17EndDragDropTargetEv:
12843|      1|{
12844|      1|    ImGuiContext& g = *GImGui;
12845|      1|    IM_ASSERT(g.DragDropActive);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12846|      1|    IM_ASSERT(g.DragDropWithinTarget);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12847|      1|    g.DragDropWithinTarget = false;
12848|      1|}
_ZN5ImGui9LogFinishEv:
13034|   121k|{
13035|   121k|    ImGuiContext& g = *GImGui;
13036|   121k|    if (!g.LogEnabled)
  ------------------
  |  Branch (13036:9): [True: 121k, False: 0]
  ------------------
13037|   121k|        return;
13038|       |
13039|      0|    LogText(IM_NEWLINE);
  ------------------
  |  |  258|      0|#define IM_NEWLINE                      "\n"
  ------------------
13040|      0|    switch (g.LogType)
  ------------------
  |  Branch (13040:13): [True: 0, False: 0]
  ------------------
13041|      0|    {
13042|      0|    case ImGuiLogType_TTY:
  ------------------
  |  Branch (13042:5): [True: 0, False: 0]
  ------------------
13043|      0|#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
13044|      0|        fflush(g.LogFile);
13045|      0|#endif
13046|      0|        break;
13047|      0|    case ImGuiLogType_File:
  ------------------
  |  Branch (13047:5): [True: 0, False: 0]
  ------------------
13048|      0|        ImFileClose(g.LogFile);
13049|      0|        break;
13050|      0|    case ImGuiLogType_Buffer:
  ------------------
  |  Branch (13050:5): [True: 0, False: 0]
  ------------------
13051|      0|        break;
13052|      0|    case ImGuiLogType_Clipboard:
  ------------------
  |  Branch (13052:5): [True: 0, False: 0]
  ------------------
13053|      0|        if (!g.LogBuffer.empty())
  ------------------
  |  Branch (13053:13): [True: 0, False: 0]
  ------------------
13054|      0|            SetClipboardText(g.LogBuffer.begin());
13055|      0|        break;
13056|      0|    case ImGuiLogType_None:
  ------------------
  |  Branch (13056:5): [True: 0, False: 0]
  ------------------
13057|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13058|      0|        break;
13059|      0|    }
13060|       |
13061|      0|    g.LogEnabled = false;
13062|      0|    g.LogType = ImGuiLogType_None;
13063|      0|    g.LogFile = NULL;
13064|      0|    g.LogBuffer.clear();
13065|      0|}
_ZN5ImGui20MarkIniSettingsDirtyEP11ImGuiWindow:
13150|  19.4k|{
13151|  19.4k|    ImGuiContext& g = *GImGui;
13152|  19.4k|    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (13152:9): [True: 13.2k, False: 6.18k]
  ------------------
13153|  13.2k|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (13153:13): [True: 129, False: 13.1k]
  ------------------
13154|    129|            g.SettingsDirtyTimer = g.IO.IniSavingRate;
13155|  19.4k|}
_ZN5ImGui18FindWindowSettingsEj:
13180|      2|{
13181|      2|    ImGuiContext& g = *GImGui;
13182|      2|    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
  ------------------
  |  Branch (13182:69): [True: 0, False: 2]
  ------------------
13183|      0|        if (settings->ID == id)
  ------------------
  |  Branch (13183:13): [True: 0, False: 0]
  ------------------
13184|      0|            return settings;
13185|      2|    return NULL;
13186|      2|}
_ZN5ImGui18AddSettingsHandlerEPK20ImGuiSettingsHandler:
13196|      2|{
13197|      2|    ImGuiContext& g = *GImGui;
13198|      2|    IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13199|      2|    g.SettingsHandlers.push_back(*handler);
13200|      2|}
_ZN5ImGui19FindSettingsHandlerEPKc:
13210|      2|{
13211|      2|    ImGuiContext& g = *GImGui;
13212|      2|    const ImGuiID type_hash = ImHashStr(type_name);
13213|      3|    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
  ------------------
  |  Branch (13213:29): [True: 1, False: 2]
  ------------------
13214|      1|        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
  ------------------
  |  Branch (13214:13): [True: 0, False: 1]
  ------------------
13215|      0|            return &g.SettingsHandlers[handler_n];
13216|      2|    return NULL;
13217|      2|}
_ZN5ImGui23LocalizeRegisterEntriesEPK13ImGuiLocEntryi:
13455|      1|{
13456|      1|    ImGuiContext& g = *GImGui;
13457|      9|    for (int n = 0; n < count; n++)
  ------------------
  |  Branch (13457:21): [True: 8, False: 1]
  ------------------
13458|      8|        g.LocalizationTable[entries[n].Key] = entries[n].Text;
13459|      1|}
_ZN5ImGui15GetMainViewportEv:
13491|   142k|{
13492|   142k|    ImGuiContext& g = *GImGui;
13493|   142k|    return g.Viewports[0];
13494|   142k|}
_ZN5ImGui16FindViewportByIDEj:
13498|  55.4k|{
13499|  55.4k|    ImGuiContext& g = *GImGui;
13500|  55.4k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (13500:21): [True: 55.4k, False: 0]
  ------------------
13501|  55.4k|        if (g.Viewports[n]->ID == id)
  ------------------
  |  Branch (13501:13): [True: 55.4k, False: 0]
  ------------------
13502|  55.4k|            return g.Viewports[n];
13503|      0|    return NULL;
13504|  55.4k|}
_ZN5ImGui18SetCurrentViewportEP11ImGuiWindowP14ImGuiViewportP:
13516|   254k|{
13517|   254k|    ImGuiContext& g = *GImGui;
13518|   254k|    (void)current_window;
13519|       |
13520|   254k|    if (viewport)
  ------------------
  |  Branch (13520:9): [True: 199k, False: 55.4k]
  ------------------
13521|   199k|        viewport->LastFrameActive = g.FrameCount;
13522|   254k|    if (g.CurrentViewport == viewport)
  ------------------
  |  Branch (13522:9): [True: 143k, False: 110k]
  ------------------
13523|   143k|        return;
13524|   110k|    g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (13524:25): [True: 55.4k, False: 55.4k]
  ------------------
13525|   110k|    g.CurrentViewport = viewport;
13526|       |    //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
13527|       |
13528|       |    // Notify platform layer of viewport changes
13529|       |    // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
13530|   110k|    if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
  ------------------
  |  Branch (13530:9): [True: 55.4k, False: 55.4k]
  |  Branch (13530:30): [True: 0, False: 55.4k]
  ------------------
13531|      0|        g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
13532|   110k|}
_ZN5ImGui17SetWindowViewportEP11ImGuiWindowP14ImGuiViewportP:
13535|   132k|{
13536|       |    // Abandon viewport
13537|   132k|    if (window->ViewportOwned && window->Viewport->Window == window)
  ------------------
  |  Branch (13537:9): [True: 0, False: 132k]
  |  Branch (13537:34): [True: 0, False: 0]
  ------------------
13538|      0|        window->Viewport->Size = ImVec2(0.0f, 0.0f);
13539|       |
13540|   132k|    window->Viewport = viewport;
13541|   132k|    window->ViewportId = viewport->ID;
13542|   132k|    window->ViewportOwned = (viewport->Window == window);
13543|   132k|}
_ZN5ImGui21DockContextInitializeEP12ImGuiContext:
14650|      1|{
14651|      1|    ImGuiContext& g = *ctx;
14652|       |
14653|       |    // Add .ini handle for persistent docking data
14654|      1|    ImGuiSettingsHandler ini_handler;
14655|      1|    ini_handler.TypeName = "Docking";
14656|      1|    ini_handler.TypeHash = ImHashStr("Docking");
14657|      1|    ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
14658|      1|    ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
14659|      1|    ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
14660|      1|    ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
14661|      1|    ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
14662|      1|    ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
14663|      1|    g.SettingsHandlers.push_back(ini_handler);
14664|      1|}
_ZN5ImGui34DockContextNewFrameUpdateUndockingEP12ImGuiContext:
14698|  55.4k|{
14699|  55.4k|    ImGuiContext& g = *ctx;
14700|  55.4k|    ImGuiDockContext* dc = &ctx->DockContext;
14701|  55.4k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (14701:9): [True: 0, False: 55.4k]
  ------------------
14702|      0|    {
14703|      0|        if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
  ------------------
  |  Branch (14703:13): [True: 0, False: 0]
  |  Branch (14703:40): [True: 0, False: 0]
  ------------------
14704|      0|            DockContextClearNodes(ctx, 0, true);
14705|      0|        return;
14706|      0|    }
14707|       |
14708|       |    // Setting NoSplit at runtime merges all nodes
14709|  55.4k|    if (g.IO.ConfigDockingNoSplit)
  ------------------
  |  Branch (14709:9): [True: 0, False: 55.4k]
  ------------------
14710|      0|        for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (14710:25): [True: 0, False: 0]
  ------------------
14711|      0|            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (14711:32): [True: 0, False: 0]
  ------------------
14712|      0|                if (node->IsRootNode() && node->IsSplitNode())
  ------------------
  |  Branch (14712:21): [True: 0, False: 0]
  |  Branch (14712:43): [True: 0, False: 0]
  ------------------
14713|      0|                {
14714|      0|                    DockBuilderRemoveNodeChildNodes(node->ID);
14715|       |                    //dc->WantFullRebuild = true;
14716|      0|                }
14717|       |
14718|       |    // Process full rebuild
14719|       |#if 0
14720|       |    if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
14721|       |        dc->WantFullRebuild = true;
14722|       |#endif
14723|  55.4k|    if (dc->WantFullRebuild)
  ------------------
  |  Branch (14723:9): [True: 0, False: 55.4k]
  ------------------
14724|      0|    {
14725|      0|        DockContextRebuildNodes(ctx);
14726|      0|        dc->WantFullRebuild = false;
14727|      0|    }
14728|       |
14729|       |    // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
14730|  55.4k|    for (int n = 0; n < dc->Requests.Size; n++)
  ------------------
  |  Branch (14730:21): [True: 0, False: 55.4k]
  ------------------
14731|      0|    {
14732|      0|        ImGuiDockRequest* req = &dc->Requests[n];
14733|      0|        if (req->Type == ImGuiDockRequestType_Undock && req->UndockTargetWindow)
  ------------------
  |  Branch (14733:13): [True: 0, False: 0]
  |  Branch (14733:57): [True: 0, False: 0]
  ------------------
14734|      0|            DockContextProcessUndockWindow(ctx, req->UndockTargetWindow);
14735|      0|        else if (req->Type == ImGuiDockRequestType_Undock && req->UndockTargetNode)
  ------------------
  |  Branch (14735:18): [True: 0, False: 0]
  |  Branch (14735:62): [True: 0, False: 0]
  ------------------
14736|      0|            DockContextProcessUndockNode(ctx, req->UndockTargetNode);
14737|      0|    }
14738|  55.4k|}
_ZN5ImGui32DockContextNewFrameUpdateDockingEP12ImGuiContext:
14742|  55.4k|{
14743|  55.4k|    ImGuiContext& g = *ctx;
14744|  55.4k|    ImGuiDockContext* dc  = &ctx->DockContext;
14745|  55.4k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (14745:9): [True: 0, False: 55.4k]
  ------------------
14746|      0|        return;
14747|       |
14748|       |    // [DEBUG] Store hovered dock node.
14749|       |    // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
14750|       |    // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
14751|  55.4k|    g.DebugHoveredDockNode = NULL;
14752|  55.4k|    if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
  ------------------
  |  Branch (14752:22): [True: 1.08k, False: 54.3k]
  ------------------
14753|  1.08k|    {
14754|  1.08k|        if (hovered_window->DockNodeAsHost)
  ------------------
  |  Branch (14754:13): [True: 0, False: 1.08k]
  ------------------
14755|      0|            g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
14756|  1.08k|        else if (hovered_window->RootWindow->DockNode)
  ------------------
  |  Branch (14756:18): [True: 0, False: 1.08k]
  ------------------
14757|      0|            g.DebugHoveredDockNode = hovered_window->RootWindow->DockNode;
14758|  1.08k|    }
14759|       |
14760|       |    // Process Docking requests
14761|  55.4k|    for (int n = 0; n < dc->Requests.Size; n++)
  ------------------
  |  Branch (14761:21): [True: 0, False: 55.4k]
  ------------------
14762|      0|        if (dc->Requests[n].Type == ImGuiDockRequestType_Dock)
  ------------------
  |  Branch (14762:13): [True: 0, False: 0]
  ------------------
14763|      0|            DockContextProcessDock(ctx, &dc->Requests[n]);
14764|  55.4k|    dc->Requests.resize(0);
14765|       |
14766|       |    // Create windows for each automatic docking nodes
14767|       |    // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
14768|  55.4k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (14768:21): [True: 0, False: 55.4k]
  ------------------
14769|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (14769:28): [True: 0, False: 0]
  ------------------
14770|      0|            if (node->IsFloatingNode())
  ------------------
  |  Branch (14770:17): [True: 0, False: 0]
  ------------------
14771|      0|                DockNodeUpdate(node);
14772|  55.4k|}
_ZN5ImGui19DockContextEndFrameEP12ImGuiContext:
14775|  55.4k|{
14776|       |    // Draw backgrounds of node missing their window
14777|  55.4k|    ImGuiContext& g = *ctx;
14778|  55.4k|    ImGuiDockContext* dc = &g.DockContext;
14779|  55.4k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (14779:21): [True: 0, False: 55.4k]
  ------------------
14780|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (14780:28): [True: 0, False: 0]
  ------------------
14781|      0|            if (node->LastFrameActive == g.FrameCount && node->IsVisible && node->HostWindow && node->IsLeafNode() && !node->IsBgDrawnThisFrame)
  ------------------
  |  Branch (14781:17): [True: 0, False: 0]
  |  Branch (14781:58): [True: 0, False: 0]
  |  Branch (14781:77): [True: 0, False: 0]
  |  Branch (14781:97): [True: 0, False: 0]
  |  Branch (14781:119): [True: 0, False: 0]
  ------------------
14782|      0|            {
14783|      0|                ImRect bg_rect(node->Pos + ImVec2(0.0f, GetFrameHeight()), node->Pos + node->Size);
14784|      0|                ImDrawFlags bg_rounding_flags = CalcRoundingFlagsForRectInRect(bg_rect, node->HostWindow->Rect(), DOCKING_SPLITTER_SIZE);
14785|      0|                node->HostWindow->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1555|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
14786|      0|                node->HostWindow->DrawList->AddRectFilled(bg_rect.Min, bg_rect.Max, node->LastBgColor, node->HostWindow->WindowRounding, bg_rounding_flags);
14787|      0|            }
14788|  55.4k|}
_ZN5ImGui28GetWindowAlwaysWantOwnTabBarEP11ImGuiWindow:
17782|   132k|{
17783|   132k|    ImGuiContext& g = *GImGui;
17784|   132k|    if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
  ------------------
  |  Branch (17784:9): [True: 0, False: 132k]
  |  Branch (17784:43): [True: 0, False: 132k]
  ------------------
17785|      0|        if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
  ------------------
  |  Branch (17785:13): [True: 0, False: 0]
  ------------------
17786|      0|            if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
  ------------------
  |  Branch (17786:17): [True: 0, False: 0]
  ------------------
17787|      0|                return true;
17788|   132k|    return false;
17789|   132k|}
_ZN5ImGui27BeginDockableDragDropSourceEP11ImGuiWindow:
17962|     18|{
17963|     18|    ImGuiContext& g = *GImGui;
17964|     18|    IM_ASSERT(g.ActiveId == window->MoveId);
  ------------------
  |  |   23|     18|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
17965|     18|    IM_ASSERT(g.MovingWindow == window);
  ------------------
  |  |   23|     18|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
17966|     18|    IM_ASSERT(g.CurrentWindow == window);
  ------------------
  |  |   23|     18|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
17967|       |
17968|     18|    g.LastItemData.ID = window->MoveId;
17969|     18|    window = window->RootWindowDockTree;
17970|     18|    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
  ------------------
  |  |   23|     18|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
17971|     18|    bool is_drag_docking = (g.IO.ConfigDockingWithShift) || ImRect(0, 0, window->SizeFull.x, GetFrameHeight()).Contains(g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
  ------------------
  |  Branch (17971:28): [True: 0, False: 18]
  |  Branch (17971:61): [True: 18, False: 0]
  ------------------
17972|     18|    if (is_drag_docking && BeginDragDropSource(ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_SourceAutoExpirePayload))
  ------------------
  |  Branch (17972:9): [True: 18, False: 0]
  |  Branch (17972:28): [True: 16, False: 2]
  ------------------
17973|     16|    {
17974|     16|        SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
  ------------------
  |  |  208|     16|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
17975|     16|        EndDragDropSource();
17976|       |
17977|       |        // Store style overrides
17978|    112|        for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
  ------------------
  |  Branch (17978:31): [True: 96, False: 16]
  ------------------
17979|     96|            window->DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
17980|     16|    }
17981|     18|}
_ZN5ImGui27BeginDockableDragDropTargetEP11ImGuiWindow:
17984|     39|{
17985|     39|    ImGuiContext* ctx = GImGui;
17986|     39|    ImGuiContext& g = *ctx;
17987|       |
17988|       |    //IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
17989|     39|    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
  ------------------
  |  |   23|     39|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
17990|     39|    if (!g.DragDropActive)
  ------------------
  |  Branch (17990:9): [True: 0, False: 39]
  ------------------
17991|      0|        return;
17992|       |    //GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
17993|     39|    if (!BeginDragDropTargetCustom(window->Rect(), window->ID))
  ------------------
  |  Branch (17993:9): [True: 38, False: 1]
  ------------------
17994|     38|        return;
17995|       |
17996|       |    // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
17997|       |    // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
17998|      1|    const ImGuiPayload* payload = &g.DragDropPayload;
17999|      1|    if (!payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, *(ImGuiWindow**)payload->Data))
  ------------------
  |  |  208|      1|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (17999:9): [True: 0, False: 1]
  |  Branch (17999:60): [True: 0, False: 1]
  ------------------
18000|      0|    {
18001|      0|        EndDragDropTarget();
18002|      0|        return;
18003|      0|    }
18004|       |
18005|      1|    ImGuiWindow* payload_window = *(ImGuiWindow**)payload->Data;
18006|      1|    if (AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect))
  ------------------
  |  |  208|      1|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (18006:9): [True: 1, False: 0]
  ------------------
18007|      1|    {
18008|       |        // Select target node
18009|       |        // (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
18010|      1|        bool dock_into_floating_window = false;
18011|      1|        ImGuiDockNode* node = NULL;
18012|      1|        if (window->DockNodeAsHost)
  ------------------
  |  Branch (18012:13): [True: 0, False: 1]
  ------------------
18013|      0|        {
18014|       |            // Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
18015|      0|            node = DockNodeTreeFindVisibleNodeByPos(window->DockNodeAsHost, g.IO.MousePos);
18016|       |
18017|       |            // There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
18018|       |            // In this case we need to fallback into any leaf mode, possibly the central node.
18019|       |            // FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
18020|      0|            if (node && node->IsDockSpace() && node->IsRootNode())
  ------------------
  |  Branch (18020:17): [True: 0, False: 0]
  |  Branch (18020:25): [True: 0, False: 0]
  |  Branch (18020:48): [True: 0, False: 0]
  ------------------
18021|      0|                node = (node->CentralNode && node->IsLeafNode()) ? node->CentralNode : DockNodeTreeFindFallbackLeafNode(node);
  ------------------
  |  Branch (18021:25): [True: 0, False: 0]
  |  Branch (18021:46): [True: 0, False: 0]
  ------------------
18022|      0|        }
18023|      1|        else
18024|      1|        {
18025|      1|            if (window->DockNode)
  ------------------
  |  Branch (18025:17): [True: 0, False: 1]
  ------------------
18026|      0|                node = window->DockNode;
18027|      1|            else
18028|      1|                dock_into_floating_window = true; // Dock into a regular window
18029|      1|        }
18030|       |
18031|      1|        const ImRect explicit_target_rect = (node && node->TabBar && !node->IsHiddenTabBar() && !node->IsNoTabBar()) ? node->TabBar->BarRect : ImRect(window->Pos, window->Pos + ImVec2(window->Size.x, GetFrameHeight()));
  ------------------
  |  Branch (18031:46): [True: 0, False: 1]
  |  Branch (18031:54): [True: 0, False: 0]
  |  Branch (18031:70): [True: 0, False: 0]
  |  Branch (18031:97): [True: 0, False: 0]
  ------------------
18032|      1|        const bool is_explicit_target = g.IO.ConfigDockingWithShift || IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max);
  ------------------
  |  Branch (18032:41): [True: 0, False: 1]
  |  Branch (18032:72): [True: 1, False: 0]
  ------------------
18033|       |
18034|       |        // Preview docking request and find out split direction/ratio
18035|       |        //const bool do_preview = true;     // Ignore testing for payload->IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
18036|      1|        const bool do_preview = payload->IsPreview() || payload->IsDelivery();
  ------------------
  |  Branch (18036:33): [True: 0, False: 1]
  |  Branch (18036:57): [True: 0, False: 1]
  ------------------
18037|      1|        if (do_preview && (node != NULL || dock_into_floating_window))
  ------------------
  |  Branch (18037:13): [True: 0, False: 1]
  |  Branch (18037:28): [True: 0, False: 0]
  |  Branch (18037:44): [True: 0, False: 0]
  ------------------
18038|      0|        {
18039|       |            // If we have a non-leaf node it means we are hovering the border of a parent node, in which case only outer markers will appear.
18040|      0|            ImGuiDockPreviewData split_inner;
18041|      0|            ImGuiDockPreviewData split_outer;
18042|      0|            ImGuiDockPreviewData* split_data = &split_inner;
18043|      0|            if (node && (node->ParentNode || node->IsCentralNode() || !node->IsLeafNode()))
  ------------------
  |  Branch (18043:17): [True: 0, False: 0]
  |  Branch (18043:26): [True: 0, False: 0]
  |  Branch (18043:46): [True: 0, False: 0]
  |  Branch (18043:71): [True: 0, False: 0]
  ------------------
18044|      0|                if (ImGuiDockNode* root_node = DockNodeGetRootNode(node))
  ------------------
  |  Branch (18044:36): [True: 0, False: 0]
  ------------------
18045|      0|                {
18046|      0|                    DockNodePreviewDockSetup(window, root_node, payload_window, NULL, &split_outer, is_explicit_target, true);
18047|      0|                    if (split_outer.IsSplitDirExplicit)
  ------------------
  |  Branch (18047:25): [True: 0, False: 0]
  ------------------
18048|      0|                        split_data = &split_outer;
18049|      0|                }
18050|      0|            if (!node || node->IsLeafNode())
  ------------------
  |  Branch (18050:17): [True: 0, False: 0]
  |  Branch (18050:26): [True: 0, False: 0]
  ------------------
18051|      0|                DockNodePreviewDockSetup(window, node, payload_window, NULL, &split_inner, is_explicit_target, false);
18052|      0|            if (split_data == &split_outer)
  ------------------
  |  Branch (18052:17): [True: 0, False: 0]
  ------------------
18053|      0|                split_inner.IsDropAllowed = false;
18054|       |
18055|       |            // Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
18056|      0|            DockNodePreviewDockRender(window, node, payload_window, &split_inner);
18057|      0|            DockNodePreviewDockRender(window, node, payload_window, &split_outer);
18058|       |
18059|       |            // Queue docking request
18060|      0|            if (split_data->IsDropAllowed && payload->IsDelivery())
  ------------------
  |  Branch (18060:17): [True: 0, False: 0]
  |  Branch (18060:46): [True: 0, False: 0]
  ------------------
18061|      0|                DockContextQueueDock(ctx, window, split_data->SplitNode, payload_window, split_data->SplitDir, split_data->SplitRatio, split_data == &split_outer);
18062|      0|        }
18063|      1|    }
18064|      1|    EndDragDropTarget();
18065|      1|}
imgui.cpp:_ZL20FindLatestInputEvent19ImGuiInputEventTypei:
 1362|  7.93k|{
 1363|  7.93k|    ImGuiContext& g = *GImGui;
 1364|  11.6k|    for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (1364:47): [True: 4.54k, False: 7.05k]
  ------------------
 1365|  4.54k|    {
 1366|  4.54k|        ImGuiInputEvent* e = &g.InputEventsQueue[n];
 1367|  4.54k|        if (e->Type != type)
  ------------------
  |  Branch (1367:13): [True: 2.27k, False: 2.27k]
  ------------------
 1368|  2.27k|            continue;
 1369|  2.27k|        if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
  ------------------
  |  Branch (1369:13): [True: 1.33k, False: 942]
  |  Branch (1369:48): [True: 1.07k, False: 255]
  ------------------
 1370|  1.07k|            continue;
 1371|  1.19k|        if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
  ------------------
  |  Branch (1371:13): [True: 711, False: 486]
  |  Branch (1371:56): [True: 316, False: 395]
  ------------------
 1372|    316|            continue;
 1373|    881|        return e;
 1374|  1.19k|    }
 1375|  7.05k|    return NULL;
 1376|  7.93k|}
imgui.cpp:_ZL10LowerBoundR8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEj:
 2295|   132k|{
 2296|   132k|    ImGuiStorage::ImGuiStoragePair* first = data.Data;
 2297|   132k|    ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
 2298|   132k|    size_t count = (size_t)(last - first);
 2299|   459k|    while (count > 0)
  ------------------
  |  Branch (2299:12): [True: 326k, False: 132k]
  ------------------
 2300|   326k|    {
 2301|   326k|        size_t count2 = count >> 1;
 2302|   326k|        ImGuiStorage::ImGuiStoragePair* mid = first + count2;
 2303|   326k|        if (mid->key < key)
  ------------------
  |  Branch (2303:13): [True: 77.0k, False: 249k]
  ------------------
 2304|  77.0k|        {
 2305|  77.0k|            first = ++mid;
 2306|  77.0k|            count -= count2 + 1;
 2307|  77.0k|        }
 2308|   249k|        else
 2309|   249k|        {
 2310|   249k|            count = count2;
 2311|   249k|        }
 2312|   326k|    }
 2313|   132k|    return first;
 2314|   132k|}
imgui.cpp:_ZL15GetStyleVarInfoi:
 3075|   131k|{
 3076|   131k|    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
  ------------------
  |  |   23|   131k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3077|   131k|    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
  ------------------
  |  |   23|   131k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3078|   131k|    return &GStyleVarInfo[idx];
 3079|   131k|}
_ZNK17ImGuiStyleVarInfo9GetVarPtrEP10ImGuiStyle:
 3037|   131k|    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
imgui.cpp:_ZL13MallocWrappermPv:
 1097|  1.21k|static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
  ------------------
  |  |   88|  1.21k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL11FreeWrapperPvS_:
 1098|  1.16k|static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
  ------------------
  |  |   88|  1.16k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL24IsWindowContentHoverableP11ImGuiWindowi:
 3910|  1.04k|{
 3911|       |    // An active popup disable hovering on other windows (apart from its own children)
 3912|       |    // FIXME-OPT: This could be cached/stored within the window.
 3913|  1.04k|    ImGuiContext& g = *GImGui;
 3914|  1.04k|    if (g.NavWindow)
  ------------------
  |  Branch (3914:9): [True: 411, False: 635]
  ------------------
 3915|    411|        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindowDockTree)
  ------------------
  |  Branch (3915:26): [True: 411, False: 0]
  ------------------
 3916|    411|            if (focused_root_window->WasActive && focused_root_window != window->RootWindowDockTree)
  ------------------
  |  Branch (3916:17): [True: 411, False: 0]
  |  Branch (3916:51): [True: 0, False: 411]
  ------------------
 3917|      0|            {
 3918|       |                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
 3919|       |                // NB: The 'else' is important because Modal windows are also Popups.
 3920|      0|                bool want_inhibit = false;
 3921|      0|                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (3921:21): [True: 0, False: 0]
  ------------------
 3922|      0|                    want_inhibit = true;
 3923|      0|                else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
  ------------------
  |  Branch (3923:26): [True: 0, False: 0]
  |  Branch (3923:83): [True: 0, False: 0]
  ------------------
 3924|      0|                    want_inhibit = true;
 3925|       |
 3926|       |                // Inhibit hover unless the window is within the stack of our modal/popup
 3927|      0|                if (want_inhibit)
  ------------------
  |  Branch (3927:21): [True: 0, False: 0]
  ------------------
 3928|      0|                    if (!ImGui::IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))
  ------------------
  |  Branch (3928:25): [True: 0, False: 0]
  ------------------
 3929|      0|                        return false;
 3930|      0|            }
 3931|       |
 3932|       |    // Filter by viewport
 3933|  1.04k|    if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (3933:9): [True: 0, False: 1.04k]
  ------------------
 3934|      0|        if (g.MovingWindow == NULL || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree)
  ------------------
  |  Branch (3934:13): [True: 0, False: 0]
  |  Branch (3934:39): [True: 0, False: 0]
  ------------------
 3935|      0|            return false;
 3936|       |
 3937|  1.04k|    return true;
 3938|  1.04k|}
imgui.cpp:_ZL24IsWindowActiveAndVisibleP11ImGuiWindow:
 4427|   256k|{
 4428|   256k|    return (window->Active) && (!window->Hidden);
  ------------------
  |  Branch (4428:12): [True: 111k, False: 144k]
  |  Branch (4428:32): [True: 103k, False: 8.65k]
  ------------------
 4429|   256k|}
imgui.cpp:_ZL21GetWindowDisplayLayerP11ImGuiWindow:
 4853|  65.6k|{
 4854|  65.6k|    return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
  ------------------
  |  Branch (4854:12): [True: 0, False: 65.6k]
  ------------------
 4855|  65.6k|}
imgui.cpp:_ZL21AddWindowToSortBufferP8ImVectorIP11ImGuiWindowES1_:
 4786|   219k|{
 4787|   219k|    out_sorted_windows->push_back(window);
 4788|   219k|    if (window->Active)
  ------------------
  |  Branch (4788:9): [True: 77.0k, False: 141k]
  ------------------
 4789|  77.0k|    {
 4790|  77.0k|        int count = window->DC.ChildWindows.Size;
 4791|  77.0k|        ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
 4792|  88.4k|        for (int i = 0; i < count; i++)
  ------------------
  |  Branch (4792:25): [True: 11.3k, False: 77.0k]
  ------------------
 4793|  11.3k|        {
 4794|  11.3k|            ImGuiWindow* child = window->DC.ChildWindows[i];
 4795|  11.3k|            if (child->Active)
  ------------------
  |  Branch (4795:17): [True: 11.3k, False: 0]
  ------------------
 4796|  11.3k|                AddWindowToSortBuffer(out_sorted_windows, child);
 4797|  11.3k|        }
 4798|  77.0k|    }
 4799|   219k|}
imgui.cpp:_ZL21AddDrawListToDrawDataP8ImVectorIP10ImDrawListES1_:
 4802|  72.7k|{
 4803|  72.7k|    if (draw_list->CmdBuffer.Size == 0)
  ------------------
  |  Branch (4803:9): [True: 0, False: 72.7k]
  ------------------
 4804|      0|        return;
 4805|  72.7k|    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
  ------------------
  |  Branch (4805:9): [True: 44.0k, False: 28.6k]
  |  Branch (4805:43): [True: 57, False: 44.0k]
  |  Branch (4805:85): [True: 57, False: 0]
  ------------------
 4806|     57|        return;
 4807|       |
 4808|       |    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
 4809|       |    // May trigger for you if you are using PrimXXX functions incorrectly.
 4810|  72.7k|    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  72.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4811|  72.7k|    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
  ------------------
  |  |   23|  72.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4812|  72.7k|    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (4812:9): [True: 72.7k, False: 0]
  ------------------
 4813|  72.7k|        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  72.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4814|       |
 4815|       |    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
 4816|       |    // If this assert triggers because you are drawing lots of stuff manually:
 4817|       |    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
 4818|       |    //   Be mindful that the ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
 4819|       |    // - If you want large meshes with more than 64K vertices, you can either:
 4820|       |    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
 4821|       |    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
 4822|       |    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
 4823|       |    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
 4824|       |    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
 4825|       |    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
 4826|       |    //       Your own engine or render API may use different parameters or function calls to specify index sizes.
 4827|       |    //       2 and 4 bytes indices are generally supported by most graphics API.
 4828|       |    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
 4829|       |    //   the 64K limit to split your draw commands in multiple draw lists.
 4830|  72.7k|    if (sizeof(ImDrawIdx) == 2)
  ------------------
  |  Branch (4830:9): [Folded - Ignored]
  ------------------
 4831|  72.7k|        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
  ------------------
  |  |   23|  72.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4832|       |
 4833|  72.7k|    out_list->push_back(draw_list);
 4834|  72.7k|}
imgui.cpp:_ZL23AddRootWindowToDrawDataP11ImGuiWindow:
 4859|  65.6k|{
 4860|  65.6k|    AddWindowToDrawData(window, GetWindowDisplayLayer(window));
 4861|  65.6k|}
imgui.cpp:_ZL19AddWindowToDrawDataP11ImGuiWindowi:
 4837|  72.7k|{
 4838|  72.7k|    ImGuiContext& g = *GImGui;
 4839|  72.7k|    ImGuiViewportP* viewport = window->Viewport;
 4840|  72.7k|    g.IO.MetricsRenderWindows++;
 4841|  72.7k|    if (window->Flags & ImGuiWindowFlags_DockNodeHost)
  ------------------
  |  Branch (4841:9): [True: 0, False: 72.7k]
  ------------------
 4842|      0|        window->DrawList->ChannelsMerge();
 4843|  72.7k|    AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[layer], window->DrawList);
 4844|  84.1k|    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
  ------------------
  |  Branch (4844:21): [True: 11.3k, False: 72.7k]
  ------------------
 4845|  11.3k|    {
 4846|  11.3k|        ImGuiWindow* child = window->DC.ChildWindows[i];
 4847|  11.3k|        if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
  ------------------
  |  Branch (4847:13): [True: 7.06k, False: 4.32k]
  ------------------
 4848|  7.06k|            AddWindowToDrawData(child, layer);
 4849|  11.3k|    }
 4850|  72.7k|}
imgui.cpp:_ZN5ImGuiL23RenderDimmedBackgroundsEv:
 4994|  55.4k|{
 4995|  55.4k|    ImGuiContext& g = *GImGui;
 4996|  55.4k|    ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
 4997|  55.4k|    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (4997:9): [True: 45.1k, False: 10.2k]
  |  Branch (4997:33): [True: 44.9k, False: 228]
  ------------------
 4998|  44.9k|        return;
 4999|  10.4k|    const bool dim_bg_for_modal = (modal_window != NULL);
 5000|  10.4k|    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
  ------------------
  |  Branch (5000:42): [True: 10.4k, False: 0]
  |  Branch (5000:78): [True: 10.4k, False: 0]
  ------------------
 5001|  10.4k|    if (!dim_bg_for_modal && !dim_bg_for_window_list)
  ------------------
  |  Branch (5001:9): [True: 10.4k, False: 0]
  |  Branch (5001:30): [True: 0, False: 10.4k]
  ------------------
 5002|      0|        return;
 5003|       |
 5004|  10.4k|    ImGuiViewport* viewports_already_dimmed[2] = { NULL, NULL };
 5005|  10.4k|    if (dim_bg_for_modal)
  ------------------
  |  Branch (5005:9): [True: 0, False: 10.4k]
  ------------------
 5006|      0|    {
 5007|       |        // Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
 5008|      0|        ImGuiWindow* dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);
 5009|      0|        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(ImGuiCol_ModalWindowDimBg, g.DimBgRatio));
 5010|      0|        viewports_already_dimmed[0] = modal_window->Viewport;
 5011|      0|    }
 5012|  10.4k|    else if (dim_bg_for_window_list)
  ------------------
  |  Branch (5012:14): [True: 10.4k, False: 0]
  ------------------
 5013|  10.4k|    {
 5014|       |        // Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
 5015|  10.4k|        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5016|  10.4k|        if (g.NavWindowingListWindow != NULL && g.NavWindowingListWindow->Viewport && g.NavWindowingListWindow->Viewport != g.NavWindowingTargetAnim->Viewport)
  ------------------
  |  Branch (5016:13): [True: 10.4k, False: 0]
  |  Branch (5016:49): [True: 10.4k, False: 0]
  |  Branch (5016:87): [True: 0, False: 10.4k]
  ------------------
 5017|      0|            RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5018|  10.4k|        viewports_already_dimmed[0] = g.NavWindowingTargetAnim->Viewport;
 5019|  10.4k|        viewports_already_dimmed[1] = g.NavWindowingListWindow ? g.NavWindowingListWindow->Viewport : NULL;
  ------------------
  |  Branch (5019:39): [True: 10.4k, False: 0]
  ------------------
 5020|       |
 5021|       |        // Draw border around CTRL+Tab target window
 5022|  10.4k|        ImGuiWindow* window = g.NavWindowingTargetAnim;
 5023|  10.4k|        ImGuiViewport* viewport = window->Viewport;
 5024|  10.4k|        float distance = g.FontSize;
 5025|  10.4k|        ImRect bb = window->Rect();
 5026|  10.4k|        bb.Expand(distance);
 5027|  10.4k|        if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
  ------------------
  |  Branch (5027:13): [True: 0, False: 10.4k]
  |  Branch (5027:50): [True: 0, False: 0]
  ------------------
 5028|      0|            bb.Expand(-distance - 1.0f); // If a window fits the entire viewport, adjust its highlight inward
 5029|  10.4k|        if (window->DrawList->CmdBuffer.Size == 0)
  ------------------
  |  Branch (5029:13): [True: 0, False: 10.4k]
  ------------------
 5030|      0|            window->DrawList->AddDrawCmd();
 5031|  10.4k|        window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);
 5032|  10.4k|        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);
 5033|  10.4k|        window->DrawList->PopClipRect();
 5034|  10.4k|    }
 5035|       |
 5036|       |    // Draw dimming background on _other_ viewports than the ones our windows are in
 5037|  20.9k|    for (int viewport_n = 0; viewport_n < g.Viewports.Size; viewport_n++)
  ------------------
  |  Branch (5037:30): [True: 10.4k, False: 10.4k]
  ------------------
 5038|  10.4k|    {
 5039|  10.4k|        ImGuiViewportP* viewport = g.Viewports[viewport_n];
 5040|  10.4k|        if (viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1])
  ------------------
  |  Branch (5040:13): [True: 10.4k, False: 0]
  |  Branch (5040:56): [True: 0, False: 0]
  ------------------
 5041|  10.4k|            continue;
 5042|      0|        if (modal_window && viewport->Window && IsWindowAbove(viewport->Window, modal_window))
  ------------------
  |  Branch (5042:13): [True: 0, False: 0]
  |  Branch (5042:29): [True: 0, False: 0]
  |  Branch (5042:49): [True: 0, False: 0]
  ------------------
 5043|      0|            continue;
 5044|      0|        ImDrawList* draw_list = GetForegroundDrawList(viewport);
 5045|      0|        const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
  ------------------
  |  Branch (5045:46): [True: 0, False: 0]
  ------------------
 5046|      0|        draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
 5047|      0|    }
 5048|  10.4k|}
imgui.cpp:_ZN5ImGuiL34RenderDimmedBackgroundBehindWindowEP11ImGuiWindowj:
 4939|  10.4k|{
 4940|  10.4k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2487|  10.4k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (4940:9): [True: 232, False: 10.2k]
  ------------------
 4941|    232|        return;
 4942|       |
 4943|  10.2k|    ImGuiViewportP* viewport = window->Viewport;
 4944|  10.2k|    ImRect viewport_rect = viewport->GetMainRect();
 4945|       |
 4946|       |    // Draw behind window by moving the draw command at the FRONT of the draw list
 4947|  10.2k|    {
 4948|       |        // We've already called AddWindowToDrawData() which called DrawList->ChannelsMerge() on DockNodeHost windows,
 4949|       |        // and draw list have been trimmed already, hence the explicit recreation of a draw command if missing.
 4950|       |        // FIXME: This is creating complication, might be simpler if we could inject a drawlist in drawdata at a given position and not attempt to manipulate ImDrawCmd order.
 4951|  10.2k|        ImDrawList* draw_list = window->RootWindowDockTree->DrawList;
 4952|  10.2k|        if (draw_list->CmdBuffer.Size == 0)
  ------------------
  |  Branch (4952:13): [True: 0, False: 10.2k]
  ------------------
 4953|      0|            draw_list->AddDrawCmd();
 4954|  10.2k|        draw_list->PushClipRect(viewport_rect.Min - ImVec2(1, 1), viewport_rect.Max + ImVec2(1, 1), false); // Ensure ImDrawCmd are not merged
 4955|  10.2k|        draw_list->AddRectFilled(viewport_rect.Min, viewport_rect.Max, col);
 4956|  10.2k|        ImDrawCmd cmd = draw_list->CmdBuffer.back();
 4957|  10.2k|        IM_ASSERT(cmd.ElemCount == 6);
  ------------------
  |  |   23|  10.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4958|  10.2k|        draw_list->CmdBuffer.pop_back();
 4959|  10.2k|        draw_list->CmdBuffer.push_front(cmd);
 4960|  10.2k|        draw_list->PopClipRect();
 4961|  10.2k|        draw_list->AddDrawCmd(); // We need to create a command as CmdBuffer.back().IdxOffset won't be correct if we append to same command.
 4962|  10.2k|    }
 4963|       |
 4964|       |    // Draw over sibling docking nodes in a same docking tree
 4965|  10.2k|    if (window->RootWindow->DockIsActive)
  ------------------
  |  Branch (4965:9): [True: 0, False: 10.2k]
  ------------------
 4966|      0|    {
 4967|      0|        ImDrawList* draw_list = FindFrontMostVisibleChildWindow(window->RootWindowDockTree)->DrawList;
 4968|      0|        if (draw_list->CmdBuffer.Size == 0)
  ------------------
  |  Branch (4968:13): [True: 0, False: 0]
  ------------------
 4969|      0|            draw_list->AddDrawCmd();
 4970|      0|        draw_list->PushClipRect(viewport_rect.Min, viewport_rect.Max, false);
 4971|      0|        RenderRectFilledWithHole(draw_list, window->RootWindowDockTree->Rect(), window->RootWindow->Rect(), col, 0.0f);// window->RootWindowDockTree->WindowRounding);
 4972|      0|        draw_list->PopClipRect();
 4973|      0|    }
 4974|  10.2k|}
imgui.cpp:_ZL21SetupViewportDrawDataP14ImGuiViewportPP8ImVectorIP10ImDrawListE:
 4882|  55.4k|{
 4883|       |    // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
 4884|       |    // and to allow applications/backends to easily skip rendering.
 4885|       |    // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
 4886|       |    // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
 4887|       |    // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
 4888|  55.4k|    const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_Minimized) != 0;
 4889|       |
 4890|  55.4k|    ImGuiIO& io = ImGui::GetIO();
 4891|  55.4k|    ImDrawData* draw_data = &viewport->DrawDataP;
 4892|  55.4k|    viewport->DrawData = draw_data; // Make publicly accessible
 4893|  55.4k|    draw_data->Valid = true;
 4894|  55.4k|    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
  ------------------
  |  Branch (4894:27): [True: 55.4k, False: 1]
  ------------------
 4895|  55.4k|    draw_data->CmdListsCount = draw_lists->Size;
 4896|  55.4k|    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
 4897|  55.4k|    draw_data->DisplayPos = viewport->Pos;
 4898|  55.4k|    draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
  ------------------
  |  Branch (4898:30): [True: 0, False: 55.4k]
  ------------------
 4899|  55.4k|    draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
 4900|  55.4k|    draw_data->OwnerViewport = viewport;
 4901|   128k|    for (int n = 0; n < draw_lists->Size; n++)
  ------------------
  |  Branch (4901:21): [True: 72.7k, False: 55.4k]
  ------------------
 4902|  72.7k|    {
 4903|  72.7k|        ImDrawList* draw_list = draw_lists->Data[n];
 4904|  72.7k|        draw_list->_PopUnusedDrawCmd();
 4905|  72.7k|        draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
 4906|  72.7k|        draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
 4907|  72.7k|    }
 4908|  55.4k|}
imgui.cpp:_ZL17FindHoveredWindowv:
 5242|  55.4k|{
 5243|  55.4k|    ImGuiContext& g = *GImGui;
 5244|       |
 5245|       |    // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
 5246|  55.4k|    ImGuiViewportP* moving_window_viewport = g.MovingWindow ? g.MovingWindow->Viewport : NULL;
  ------------------
  |  Branch (5246:46): [True: 24, False: 55.3k]
  ------------------
 5247|  55.4k|    if (g.MovingWindow)
  ------------------
  |  Branch (5247:9): [True: 24, False: 55.3k]
  ------------------
 5248|     24|        g.MovingWindow->Viewport = g.MouseViewport;
 5249|       |
 5250|  55.4k|    ImGuiWindow* hovered_window = NULL;
 5251|  55.4k|    ImGuiWindow* hovered_window_ignoring_moving_window = NULL;
 5252|  55.4k|    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (5252:9): [True: 24, False: 55.3k]
  |  Branch (5252:27): [True: 24, False: 0]
  ------------------
 5253|     24|        hovered_window = g.MovingWindow;
 5254|       |
 5255|  55.4k|    ImVec2 padding_regular = g.Style.TouchExtraPadding;
 5256|  55.4k|    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
  ------------------
  |  Branch (5256:33): [True: 0, False: 55.4k]
  ------------------
 5257|   271k|    for (int i = g.Windows.Size - 1; i >= 0; i--)
  ------------------
  |  Branch (5257:38): [True: 216k, False: 54.2k]
  ------------------
 5258|   216k|    {
 5259|   216k|        ImGuiWindow* window = g.Windows[i];
 5260|   216k|        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5261|   216k|        if (!window->Active || window->Hidden)
  ------------------
  |  Branch (5261:13): [True: 139k, False: 77.0k]
  |  Branch (5261:32): [True: 4.33k, False: 72.7k]
  ------------------
 5262|   144k|            continue;
 5263|  72.7k|        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
  ------------------
  |  Branch (5263:13): [True: 10.2k, False: 62.4k]
  ------------------
 5264|  10.2k|            continue;
 5265|  62.4k|        IM_ASSERT(window->Viewport);
  ------------------
  |  |   23|  62.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5266|  62.4k|        if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (5266:13): [True: 0, False: 62.4k]
  ------------------
 5267|      0|            continue;
 5268|       |
 5269|       |        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
 5270|  62.4k|        ImRect bb(window->OuterRectClipped);
 5271|  62.4k|        if (window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
  ------------------
  |  Branch (5271:13): [True: 7.06k, False: 55.4k]
  ------------------
 5272|  7.06k|            bb.Expand(padding_regular);
 5273|  55.4k|        else
 5274|  55.4k|            bb.Expand(padding_for_resize);
 5275|  62.4k|        if (!bb.Contains(g.IO.MousePos))
  ------------------
  |  Branch (5275:13): [True: 61.3k, False: 1.14k]
  ------------------
 5276|  61.3k|            continue;
 5277|       |
 5278|       |        // Support for one rectangular hole in any given window
 5279|       |        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
 5280|  1.14k|        if (window->HitTestHoleSize.x != 0)
  ------------------
  |  Branch (5280:13): [True: 0, False: 1.14k]
  ------------------
 5281|      0|        {
 5282|      0|            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
 5283|      0|            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
 5284|      0|            if (ImRect(hole_pos, hole_pos + hole_size).Contains(g.IO.MousePos))
  ------------------
  |  Branch (5284:17): [True: 0, False: 0]
  ------------------
 5285|      0|                continue;
 5286|      0|        }
 5287|       |
 5288|  1.14k|        if (hovered_window == NULL)
  ------------------
  |  Branch (5288:13): [True: 1.14k, False: 5]
  ------------------
 5289|  1.14k|            hovered_window = window;
 5290|  1.14k|        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5291|  1.14k|        if (hovered_window_ignoring_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
  ------------------
  |  Branch (5291:13): [True: 1.14k, False: 0]
  |  Branch (5291:63): [True: 1.14k, False: 5]
  |  Branch (5291:82): [True: 0, False: 5]
  ------------------
 5292|  1.14k|            hovered_window_ignoring_moving_window = window;
 5293|  1.14k|        if (hovered_window && hovered_window_ignoring_moving_window)
  ------------------
  |  Branch (5293:13): [True: 1.14k, False: 0]
  |  Branch (5293:31): [True: 1.14k, False: 5]
  ------------------
 5294|  1.14k|            break;
 5295|  1.14k|    }
 5296|       |
 5297|  55.4k|    g.HoveredWindow = hovered_window;
 5298|  55.4k|    g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;
 5299|       |
 5300|  55.4k|    if (g.MovingWindow)
  ------------------
  |  Branch (5300:9): [True: 24, False: 55.3k]
  ------------------
 5301|     24|        g.MovingWindow->Viewport = moving_window_viewport;
 5302|  55.4k|}
imgui.cpp:_ZL22CalcWindowContentSizesP11ImGuiWindowP6ImVec2S2_:
 5729|   132k|{
 5730|   132k|    bool preserve_old_content_sizes = false;
 5731|   132k|    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
  ------------------
  |  Branch (5731:9): [True: 44.0k, False: 88.4k]
  |  Branch (5731:30): [True: 44.0k, False: 0]
  |  Branch (5731:61): [True: 44.0k, False: 0]
  ------------------
 5732|  44.0k|        preserve_old_content_sizes = true;
 5733|  88.4k|    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (5733:14): [True: 4.32k, False: 84.1k]
  |  Branch (5733:32): [True: 4.32k, False: 3]
  |  Branch (5733:76): [True: 4.32k, False: 0]
  ------------------
 5734|  4.32k|        preserve_old_content_sizes = true;
 5735|   132k|    if (preserve_old_content_sizes)
  ------------------
  |  Branch (5735:9): [True: 48.3k, False: 84.1k]
  ------------------
 5736|  48.3k|    {
 5737|  48.3k|        *content_size_current = window->ContentSize;
 5738|  48.3k|        *content_size_ideal = window->ContentSizeIdeal;
 5739|  48.3k|        return;
 5740|  48.3k|    }
 5741|       |
 5742|  84.1k|    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_FLOOR(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
  ------------------
  |  |  266|   168k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5742:31): [True: 0, False: 84.1k]
  ------------------
 5743|  84.1k|    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_FLOOR(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
  ------------------
  |  |  266|   168k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5743:31): [True: 0, False: 84.1k]
  ------------------
 5744|  84.1k|    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_FLOOR(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
  ------------------
  |  |  266|   168k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5744:29): [True: 0, False: 84.1k]
  ------------------
 5745|  84.1k|    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_FLOOR(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
  ------------------
  |  |  266|   168k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5745:29): [True: 0, False: 84.1k]
  ------------------
 5746|  84.1k|}
imgui.cpp:_ZL21CalcWindowAutoFitSizeP11ImGuiWindowRK6ImVec2:
 5749|   132k|{
 5750|   132k|    ImGuiContext& g = *GImGui;
 5751|   132k|    ImGuiStyle& style = g.Style;
 5752|   132k|    const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
 5753|   132k|    const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
 5754|   132k|    ImVec2 size_pad = window->WindowPadding * 2.0f;
 5755|   132k|    ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
 5756|   132k|    if (window->Flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (5756:9): [True: 0, False: 132k]
  ------------------
 5757|      0|    {
 5758|       |        // Tooltip always resize
 5759|      0|        return size_desired;
 5760|      0|    }
 5761|   132k|    else
 5762|   132k|    {
 5763|       |        // Maximum window size is determined by the viewport size or monitor size
 5764|   132k|        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
 5765|   132k|        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
 5766|   132k|        ImVec2 size_min = style.WindowMinSize;
 5767|   132k|        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
  ------------------
  |  Branch (5767:13): [True: 0, False: 132k]
  |  Branch (5767:25): [True: 0, False: 132k]
  ------------------
 5768|      0|            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));
 5769|       |
 5770|   132k|        ImVec2 avail_size = window->Viewport->WorkSize;
 5771|   132k|        if (window->ViewportOwned)
  ------------------
  |  Branch (5771:13): [True: 0, False: 132k]
  ------------------
 5772|      0|            avail_size = ImVec2(FLT_MAX, FLT_MAX);
 5773|   132k|        const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
 5774|   132k|        if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
  ------------------
  |  Branch (5774:13): [True: 0, False: 132k]
  |  Branch (5774:33): [True: 0, False: 0]
  ------------------
 5775|      0|            avail_size = g.PlatformIO.Monitors[monitor_idx].WorkSize;
 5776|   132k|        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, avail_size - style.DisplaySafeAreaPadding * 2.0f));
 5777|       |
 5778|       |        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
 5779|       |        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
 5780|   132k|        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 5781|   132k|        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x  && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
  ------------------
  |  Branch (5781:39): [True: 2.73k, False: 129k]
  |  Branch (5781:141): [True: 2.73k, False: 0]
  |  Branch (5781:192): [True: 0, False: 2.73k]
  |  Branch (5781:251): [True: 11.3k, False: 121k]
  ------------------
 5782|   132k|        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
  ------------------
  |  Branch (5782:39): [True: 1.31k, False: 131k]
  |  Branch (5782:140): [True: 1.31k, False: 0]
  |  Branch (5782:192): [True: 0, False: 131k]
  ------------------
 5783|   132k|        if (will_have_scrollbar_x)
  ------------------
  |  Branch (5783:13): [True: 11.3k, False: 121k]
  ------------------
 5784|  11.3k|            size_auto_fit.y += style.ScrollbarSize;
 5785|   132k|        if (will_have_scrollbar_y)
  ------------------
  |  Branch (5785:13): [True: 1.31k, False: 131k]
  ------------------
 5786|  1.31k|            size_auto_fit.x += style.ScrollbarSize;
 5787|   132k|        return size_auto_fit;
 5788|   132k|    }
 5789|   132k|}
imgui.cpp:_ZL29CalcWindowSizeAfterConstraintP11ImGuiWindowRK6ImVec2:
 5694|   265k|{
 5695|   265k|    ImGuiContext& g = *GImGui;
 5696|   265k|    ImVec2 new_size = size_desired;
 5697|   265k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
  ------------------
  |  Branch (5697:9): [True: 20.5k, False: 244k]
  ------------------
 5698|  20.5k|    {
 5699|       |        // Using -1,-1 on either X/Y axis to preserve the current size.
 5700|  20.5k|        ImRect cr = g.NextWindowData.SizeConstraintRect;
 5701|  20.5k|        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
  ------------------
  |  Branch (5701:23): [True: 20.5k, False: 0]
  |  Branch (5701:40): [True: 20.5k, False: 0]
  ------------------
 5702|  20.5k|        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
  ------------------
  |  Branch (5702:23): [True: 20.5k, False: 0]
  |  Branch (5702:40): [True: 20.5k, False: 0]
  ------------------
 5703|  20.5k|        if (g.NextWindowData.SizeCallback)
  ------------------
  |  Branch (5703:13): [True: 0, False: 20.5k]
  ------------------
 5704|      0|        {
 5705|      0|            ImGuiSizeCallbackData data;
 5706|      0|            data.UserData = g.NextWindowData.SizeCallbackUserData;
 5707|      0|            data.Pos = window->Pos;
 5708|      0|            data.CurrentSize = window->SizeFull;
 5709|      0|            data.DesiredSize = new_size;
 5710|      0|            g.NextWindowData.SizeCallback(&data);
 5711|      0|            new_size = data.DesiredSize;
 5712|      0|        }
 5713|  20.5k|        new_size.x = IM_FLOOR(new_size.x);
  ------------------
  |  |  266|  20.5k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5714|  20.5k|        new_size.y = IM_FLOOR(new_size.y);
  ------------------
  |  |  266|  20.5k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5715|  20.5k|    }
 5716|       |
 5717|       |    // Minimum size
 5718|   265k|    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
  ------------------
  |  Branch (5718:9): [True: 221k, False: 43.3k]
  ------------------
 5719|   221k|    {
 5720|   221k|        ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
 5721|   221k|        new_size = ImMax(new_size, g.Style.WindowMinSize);
 5722|   221k|        const float minimum_height = window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f);
 5723|   221k|        new_size.y = ImMax(new_size.y, minimum_height); // Reduce artifacts with very small windows
 5724|   221k|    }
 5725|   265k|    return new_size;
 5726|   265k|}
imgui.cpp:_ZL30GetWindowForTitleAndMenuHeightP11ImGuiWindow:
 5689|   221k|{
 5690|   221k|    return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
  ------------------
  |  Branch (5690:13): [True: 0, False: 221k]
  |  Branch (5690:39): [True: 0, False: 0]
  ------------------
 5691|   221k|}
imgui.cpp:_ZL15CreateNewWindowPKci:
 5636|      4|{
 5637|      4|    ImGuiContext& g = *GImGui;
 5638|       |    //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
 5639|       |
 5640|       |    // Create window the first time
 5641|      4|    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
  ------------------
  |  | 1863|      8|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 5642|      4|    window->Flags = flags;
 5643|      4|    g.WindowsById.SetVoidPtr(window->ID, window);
 5644|       |
 5645|       |    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
 5646|      4|    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
 5647|      4|    window->Pos = main_viewport->Pos + ImVec2(60, 60);
 5648|      4|    window->ViewportPos = main_viewport->Pos;
 5649|       |
 5650|       |    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
 5651|      4|    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (5651:9): [True: 2, False: 2]
  ------------------
 5652|      2|        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
  ------------------
  |  Branch (5652:34): [True: 0, False: 2]
  ------------------
 5653|      0|        {
 5654|       |            // Retrieve settings from .ini file
 5655|      0|            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
 5656|      0|            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
 5657|      0|            ApplyWindowSettings(window, settings);
 5658|      0|        }
 5659|      4|    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values
 5660|       |
 5661|      4|    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
  ------------------
  |  Branch (5661:9): [True: 1, False: 3]
  ------------------
 5662|      1|    {
 5663|      1|        window->AutoFitFramesX = window->AutoFitFramesY = 2;
 5664|      1|        window->AutoFitOnlyGrows = false;
 5665|      1|    }
 5666|      3|    else
 5667|      3|    {
 5668|      3|        if (window->Size.x <= 0.0f)
  ------------------
  |  Branch (5668:13): [True: 3, False: 0]
  ------------------
 5669|      3|            window->AutoFitFramesX = 2;
 5670|      3|        if (window->Size.y <= 0.0f)
  ------------------
  |  Branch (5670:13): [True: 3, False: 0]
  ------------------
 5671|      3|            window->AutoFitFramesY = 2;
 5672|      3|        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
  ------------------
  |  Branch (5672:36): [True: 3, False: 0]
  |  Branch (5672:68): [True: 0, False: 0]
  ------------------
 5673|      3|    }
 5674|       |
 5675|      4|    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
  ------------------
  |  Branch (5675:9): [True: 0, False: 4]
  ------------------
 5676|      0|        g.Windows.push_front(window); // Quite slow but rare and only once
 5677|      4|    else
 5678|      4|        g.Windows.push_back(window);
 5679|       |
 5680|      4|    return window;
 5681|      4|}
imgui.cpp:_ZL28UpdateWindowInFocusOrderListP11ImGuiWindowbi:
 5613|   132k|{
 5614|   132k|    ImGuiContext& g = *GImGui;
 5615|       |
 5616|   132k|    const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
  ------------------
  |  Branch (5616:40): [True: 11.3k, False: 121k]
  |  Branch (5616:92): [True: 11.3k, False: 0]
  |  Branch (5616:137): [True: 0, False: 0]
  ------------------
 5617|   132k|    const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
 5618|   132k|    if ((just_created || child_flag_changed) && !new_is_explicit_child)
  ------------------
  |  Branch (5618:10): [True: 4, False: 132k]
  |  Branch (5618:26): [True: 0, False: 132k]
  |  Branch (5618:49): [True: 3, False: 1]
  ------------------
 5619|      3|    {
 5620|      3|        IM_ASSERT(!g.WindowsFocusOrder.contains(window));
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5621|      3|        g.WindowsFocusOrder.push_back(window);
 5622|      3|        window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
 5623|      3|    }
 5624|   132k|    else if (!just_created && child_flag_changed && new_is_explicit_child)
  ------------------
  |  Branch (5624:14): [True: 132k, False: 1]
  |  Branch (5624:31): [True: 0, False: 132k]
  |  Branch (5624:53): [True: 0, False: 0]
  ------------------
 5625|      0|    {
 5626|      0|        IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5627|      0|        for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
  ------------------
  |  Branch (5627:46): [True: 0, False: 0]
  ------------------
 5628|      0|            g.WindowsFocusOrder[n]->FocusOrder--;
 5629|      0|        g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
 5630|      0|        window->FocusOrder = -1;
 5631|      0|    }
 5632|   132k|    window->IsExplicitChild = new_is_explicit_child;
 5633|   132k|}
imgui.cpp:_ZL28SetWindowConditionAllowFlagsP11ImGuiWindowib:
 5576|    416|{
 5577|    416|    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
  ------------------
  |  Branch (5577:44): [True: 208, False: 208]
  ------------------
 5578|    416|    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
  ------------------
  |  Branch (5578:44): [True: 208, False: 208]
  ------------------
 5579|    416|    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
  ------------------
  |  Branch (5579:44): [True: 208, False: 208]
  ------------------
 5580|    416|    window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
  ------------------
  |  Branch (5580:44): [True: 208, False: 208]
  ------------------
 5581|    416|}
imgui.cpp:_ZL16SetCurrentWindowP11ImGuiWindow:
 3775|   264k|{
 3776|   264k|    ImGuiContext& g = *GImGui;
 3777|   264k|    g.CurrentWindow = window;
 3778|   264k|    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
  ------------------
  |  Branch (3778:22): [True: 199k, False: 65.6k]
  |  Branch (3778:32): [True: 0, False: 199k]
  ------------------
 3779|   264k|    if (window)
  ------------------
  |  Branch (3779:9): [True: 199k, False: 65.6k]
  ------------------
 3780|   199k|        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
 3781|   264k|}
imgui.cpp:_ZL14ClampWindowPosP11ImGuiWindowRK6ImRect:
 6041|   110k|{
 6042|   110k|    ImGuiContext& g = *GImGui;
 6043|   110k|    ImVec2 size_for_clamping = window->Size;
 6044|   110k|    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && (!(window->Flags & ImGuiWindowFlags_NoTitleBar) || window->DockNodeAsHost))
  ------------------
  |  Branch (6044:9): [True: 0, False: 110k]
  |  Branch (6044:52): [True: 0, False: 0]
  |  Branch (6044:102): [True: 0, False: 0]
  ------------------
 6045|      0|        size_for_clamping.y = ImGui::GetFrameHeight(); // Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
 6046|   110k|    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
 6047|   110k|}
imgui.cpp:_ZN5ImGuiL24UpdateWindowManualResizeEP11ImGuiWindowRK6ImVec2PiiPjRK6ImRect:
 5891|  88.4k|{
 5892|  88.4k|    ImGuiContext& g = *GImGui;
 5893|  88.4k|    ImGuiWindowFlags flags = window->Flags;
 5894|       |
 5895|  88.4k|    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (5895:9): [True: 21.6k, False: 66.8k]
  |  Branch (5895:48): [True: 0, False: 66.8k]
  |  Branch (5895:95): [True: 2, False: 66.7k]
  |  Branch (5895:125): [True: 0, False: 66.7k]
  ------------------
 5896|  21.6k|        return false;
 5897|  66.7k|    if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
  ------------------
  |  Branch (5897:9): [True: 55.4k, False: 11.3k]
  ------------------
 5898|  55.4k|        return false;
 5899|       |
 5900|  11.3k|    bool ret_auto_fit = false;
 5901|  11.3k|    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
  ------------------
  |  Branch (5901:37): [True: 0, False: 11.3k]
  ------------------
 5902|  11.3k|    const float grip_draw_size = IM_FLOOR(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  266|  11.3k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5903|  11.3k|    const float grip_hover_inner_size = IM_FLOOR(grip_draw_size * 0.75f);
  ------------------
  |  |  266|  11.3k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5904|  11.3k|    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;
  ------------------
  |  Branch (5904:41): [True: 0, False: 11.3k]
  ------------------
 5905|       |
 5906|  11.3k|    ImVec2 pos_target(FLT_MAX, FLT_MAX);
 5907|  11.3k|    ImVec2 size_target(FLT_MAX, FLT_MAX);
 5908|       |
 5909|       |    // Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
 5910|       |    // - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
 5911|       |    //   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
 5912|       |    // - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
 5913|       |    // - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
 5914|       |    // We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
 5915|  11.3k|    const bool clip_with_viewport_rect = !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport) || (g.IO.MouseHoveredViewport != window->ViewportId) || !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration);
  ------------------
  |  Branch (5915:42): [True: 11.3k, False: 0]
  |  Branch (5915:110): [True: 0, False: 0]
  |  Branch (5915:163): [True: 0, False: 0]
  ------------------
 5916|  11.3k|    if (clip_with_viewport_rect)
  ------------------
  |  Branch (5916:9): [True: 11.3k, False: 0]
  ------------------
 5917|  11.3k|        window->ClipRect = window->Viewport->GetMainRect();
 5918|       |
 5919|       |    // Resize grips and borders are on layer 1
 5920|  11.3k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 5921|       |
 5922|       |    // Manual resize grips
 5923|  11.3k|    PushID("#RESIZE");
 5924|  22.7k|    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (5924:33): [True: 11.3k, False: 11.3k]
  ------------------
 5925|  11.3k|    {
 5926|  11.3k|        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];
 5927|  11.3k|        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);
 5928|       |
 5929|       |        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
 5930|  11.3k|        bool hovered, held;
 5931|  11.3k|        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
 5932|  11.3k|        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
  ------------------
  |  Branch (5932:13): [True: 11.3k, False: 0]
  ------------------
 5933|  11.3k|        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
  ------------------
  |  Branch (5933:13): [True: 11.3k, False: 0]
  ------------------
 5934|  11.3k|        ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
 5935|  11.3k|        ItemAdd(resize_rect, resize_grip_id, NULL, ImGuiItemFlags_NoNav);
 5936|  11.3k|        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 5937|       |        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
 5938|  11.3k|        if (hovered || held)
  ------------------
  |  Branch (5938:13): [True: 4, False: 11.3k]
  |  Branch (5938:24): [True: 0, False: 11.3k]
  ------------------
 5939|      4|            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;
  ------------------
  |  Branch (5939:29): [True: 0, False: 4]
  ------------------
 5940|       |
 5941|  11.3k|        if (held && g.IO.MouseClickedCount[0] == 2 && resize_grip_n == 0)
  ------------------
  |  Branch (5941:13): [True: 0, False: 11.3k]
  |  Branch (5941:21): [True: 0, False: 0]
  |  Branch (5941:55): [True: 0, False: 0]
  ------------------
 5942|      0|        {
 5943|       |            // Manual auto-fit when double-clicking
 5944|      0|            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 5945|      0|            ret_auto_fit = true;
 5946|      0|            ClearActiveID();
 5947|      0|        }
 5948|  11.3k|        else if (held)
  ------------------
  |  Branch (5948:18): [True: 0, False: 11.3k]
  ------------------
 5949|      0|        {
 5950|       |            // Resize from any of the four corners
 5951|       |            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
 5952|      0|            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? visibility_rect.Min.x : -FLT_MAX, def.CornerPosN.y == 1.0f ? visibility_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (5952:39): [True: 0, False: 0]
  |  Branch (5952:100): [True: 0, False: 0]
  ------------------
 5953|      0|            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? visibility_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? visibility_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (5953:39): [True: 0, False: 0]
  |  Branch (5953:100): [True: 0, False: 0]
  ------------------
 5954|      0|            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
 5955|      0|            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
 5956|      0|            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
 5957|      0|        }
 5958|       |
 5959|       |        // Only lower-left grip is visible before hovering/activating
 5960|  11.3k|        if (resize_grip_n == 0 || held || hovered)
  ------------------
  |  Branch (5960:13): [True: 11.3k, False: 0]
  |  Branch (5960:35): [True: 0, False: 0]
  |  Branch (5960:43): [True: 0, False: 0]
  ------------------
 5961|  11.3k|            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
  ------------------
  |  Branch (5961:58): [True: 0, False: 11.3k]
  |  Branch (5961:93): [True: 4, False: 11.3k]
  ------------------
 5962|  11.3k|    }
 5963|  11.3k|    for (int border_n = 0; border_n < resize_border_count; border_n++)
  ------------------
  |  Branch (5963:28): [True: 0, False: 11.3k]
  ------------------
 5964|      0|    {
 5965|      0|        const ImGuiResizeBorderDef& def = resize_border_def[border_n];
 5966|      0|        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
  ------------------
  |  Branch (5966:33): [True: 0, False: 0]
  |  Branch (5966:62): [True: 0, False: 0]
  ------------------
 5967|       |
 5968|      0|        bool hovered, held;
 5969|      0|        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
 5970|      0|        ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
 5971|      0|        ItemAdd(border_rect, border_id, NULL, ImGuiItemFlags_NoNav);
 5972|      0|        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 5973|       |        //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
 5974|      0|        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
  ------------------
  |  Branch (5974:14): [True: 0, False: 0]
  |  Branch (5974:25): [True: 0, False: 0]
  |  Branch (5974:89): [True: 0, False: 0]
  ------------------
 5975|      0|        {
 5976|      0|            g.MouseCursor = (axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
  ------------------
  |  Branch (5976:29): [True: 0, False: 0]
  ------------------
 5977|      0|            if (held)
  ------------------
  |  Branch (5977:17): [True: 0, False: 0]
  ------------------
 5978|      0|                *border_held = border_n;
 5979|      0|        }
 5980|      0|        if (held)
  ------------------
  |  Branch (5980:13): [True: 0, False: 0]
  ------------------
 5981|      0|        {
 5982|      0|            ImVec2 clamp_min(border_n == ImGuiDir_Right ? visibility_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down ? visibility_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (5982:30): [True: 0, False: 0]
  |  Branch (5982:93): [True: 0, False: 0]
  ------------------
 5983|      0|            ImVec2 clamp_max(border_n == ImGuiDir_Left  ? visibility_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up   ? visibility_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (5983:30): [True: 0, False: 0]
  |  Branch (5983:93): [True: 0, False: 0]
  ------------------
 5984|      0|            ImVec2 border_target = window->Pos;
 5985|      0|            border_target[axis] = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING;
 5986|      0|            border_target = ImClamp(border_target, clamp_min, clamp_max);
 5987|      0|            CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
 5988|      0|        }
 5989|      0|    }
 5990|  11.3k|    PopID();
 5991|       |
 5992|       |    // Restore nav layer
 5993|  11.3k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 5994|       |
 5995|       |    // Navigation resize (keyboard/gamepad)
 5996|       |    // FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
 5997|       |    // Not even sure the callback works here.
 5998|  11.3k|    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindowDockTree == window)
  ------------------
  |  Branch (5998:9): [True: 1.43k, False: 9.96k]
  |  Branch (5998:33): [True: 1.43k, False: 0]
  ------------------
 5999|  1.43k|    {
 6000|  1.43k|        ImVec2 nav_resize_dir;
 6001|  1.43k|        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
  ------------------
  |  Branch (6001:13): [True: 1.43k, False: 0]
  |  Branch (6001:62): [True: 88, False: 1.34k]
  ------------------
 6002|     88|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
 6003|  1.43k|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (6003:13): [True: 0, False: 1.43k]
  ------------------
 6004|      0|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);
 6005|  1.43k|        if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f)
  ------------------
  |  Branch (6005:13): [True: 62, False: 1.36k]
  |  Branch (6005:41): [True: 18, False: 1.35k]
  ------------------
 6006|     80|        {
 6007|     80|            const float NAV_RESIZE_SPEED = 600.0f;
 6008|     80|            const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
 6009|     80|            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
 6010|     80|            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, visibility_rect.Min - window->Pos - window->Size); // We need Pos+Size >= visibility_rect.Min, so Size >= visibility_rect.Min - Pos, so size_delta >= visibility_rect.Min - window->Pos - window->Size
 6011|     80|            g.NavWindowingToggleLayer = false;
 6012|     80|            g.NavDisableMouseHover = true;
 6013|     80|            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
 6014|     80|            ImVec2 accum_floored = ImFloor(g.NavWindowingAccumDeltaSize);
 6015|     80|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (6015:17): [True: 0, False: 80]
  |  Branch (6015:44): [True: 80, False: 0]
  ------------------
 6016|     80|            {
 6017|       |                // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
 6018|     80|                size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);
 6019|     80|                g.NavWindowingAccumDeltaSize -= accum_floored;
 6020|     80|            }
 6021|     80|        }
 6022|  1.43k|    }
 6023|       |
 6024|       |    // Apply back modified position/size to window
 6025|  11.3k|    if (size_target.x != FLT_MAX)
  ------------------
  |  Branch (6025:9): [True: 80, False: 11.3k]
  ------------------
 6026|     80|    {
 6027|     80|        window->SizeFull = size_target;
 6028|     80|        MarkIniSettingsDirty(window);
 6029|     80|    }
 6030|  11.3k|    if (pos_target.x != FLT_MAX)
  ------------------
  |  Branch (6030:9): [True: 0, False: 11.3k]
  ------------------
 6031|      0|    {
 6032|      0|        window->Pos = ImFloor(pos_target);
 6033|      0|        MarkIniSettingsDirty(window);
 6034|      0|    }
 6035|       |
 6036|  11.3k|    window->Size = window->SizeFull;
 6037|  11.3k|    return ret_auto_fit;
 6038|  66.7k|}
imgui.cpp:_ZN5ImGuiL23RenderWindowDecorationsEP11ImGuiWindowRK6ImRectbbiPKjf:
 6076|   132k|{
 6077|   132k|    ImGuiContext& g = *GImGui;
 6078|   132k|    ImGuiStyle& style = g.Style;
 6079|   132k|    ImGuiWindowFlags flags = window->Flags;
 6080|       |
 6081|       |    // Ensure that ScrollBar doesn't read last frame's SkipItems
 6082|   132k|    IM_ASSERT(window->BeginCount == 0);
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6083|   132k|    window->SkipItems = false;
 6084|       |
 6085|       |    // Draw window + handle manual resize
 6086|       |    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
 6087|   132k|    const float window_rounding = window->WindowRounding;
 6088|   132k|    const float window_border_size = window->WindowBorderSize;
 6089|   132k|    if (window->Collapsed)
  ------------------
  |  Branch (6089:9): [True: 44.0k, False: 88.4k]
  ------------------
 6090|  44.0k|    {
 6091|       |        // Title bar only
 6092|  44.0k|        const float backup_border_size = style.FrameBorderSize;
 6093|  44.0k|        g.Style.FrameBorderSize = window->WindowBorderSize;
 6094|  44.0k|        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
  ------------------
  |  Branch (6094:44): [True: 14.7k, False: 29.2k]
  |  Branch (6094:70): [True: 14.3k, False: 410]
  ------------------
 6095|  44.0k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6095:13): [True: 0, False: 44.0k]
  ------------------
 6096|      0|            title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
  ------------------
  |  | 2487|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6097|  44.0k|        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
 6098|  44.0k|        g.Style.FrameBorderSize = backup_border_size;
 6099|  44.0k|    }
 6100|  88.4k|    else
 6101|  88.4k|    {
 6102|       |        // Window background
 6103|  88.4k|        if (!(flags & ImGuiWindowFlags_NoBackground))
  ------------------
  |  Branch (6103:13): [True: 88.4k, False: 0]
  ------------------
 6104|  88.4k|        {
 6105|  88.4k|            bool is_docking_transparent_payload = false;
 6106|  88.4k|            if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
  ------------------
  |  Branch (6106:17): [True: 55, False: 88.4k]
  |  Branch (6106:37): [True: 1, False: 54]
  |  Branch (6106:89): [True: 0, False: 1]
  ------------------
 6107|      0|                if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
  ------------------
  |  |  208|      0|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (6107:21): [True: 0, False: 0]
  |  Branch (6107:80): [True: 0, False: 0]
  ------------------
 6108|      0|                    is_docking_transparent_payload = true;
 6109|       |
 6110|  88.4k|            ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
 6111|  88.4k|            if (window->ViewportOwned)
  ------------------
  |  Branch (6111:17): [True: 0, False: 88.4k]
  ------------------
 6112|      0|            {
 6113|      0|                bg_col |= IM_COL32_A_MASK; // No alpha
  ------------------
  |  | 2487|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6114|      0|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6114:21): [True: 0, False: 0]
  ------------------
 6115|      0|                    window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
 6116|      0|            }
 6117|  88.4k|            else
 6118|  88.4k|            {
 6119|       |                // Adjust alpha. For docking
 6120|  88.4k|                bool override_alpha = false;
 6121|  88.4k|                float alpha = 1.0f;
 6122|  88.4k|                if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
  ------------------
  |  Branch (6122:21): [True: 0, False: 88.4k]
  ------------------
 6123|      0|                {
 6124|      0|                    alpha = g.NextWindowData.BgAlphaVal;
 6125|      0|                    override_alpha = true;
 6126|      0|                }
 6127|  88.4k|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6127:21): [True: 0, False: 88.4k]
  ------------------
 6128|      0|                {
 6129|      0|                    alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
 6130|      0|                    override_alpha = true;
 6131|      0|                }
 6132|  88.4k|                if (override_alpha)
  ------------------
  |  Branch (6132:21): [True: 0, False: 88.4k]
  ------------------
 6133|      0|                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2487|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  |  265|      0|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  ------------------
 6134|  88.4k|            }
 6135|       |
 6136|       |            // Render, for docked windows and host windows we ensure bg goes before decorations
 6137|  88.4k|            if (window->DockIsActive)
  ------------------
  |  Branch (6137:17): [True: 0, False: 88.4k]
  ------------------
 6138|      0|                window->DockNode->LastBgColor = bg_col;
 6139|  88.4k|            ImDrawList* bg_draw_list = window->DockIsActive ? window->DockNode->HostWindow->DrawList : window->DrawList;
  ------------------
  |  Branch (6139:40): [True: 0, False: 88.4k]
  ------------------
 6140|  88.4k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6140:17): [True: 0, False: 88.4k]
  |  Branch (6140:41): [True: 0, False: 88.4k]
  ------------------
 6141|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1555|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
 6142|  88.4k|            bg_draw_list->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
  ------------------
  |  Branch (6142:145): [True: 21.6k, False: 66.8k]
  ------------------
 6143|  88.4k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6143:17): [True: 0, False: 88.4k]
  |  Branch (6143:41): [True: 0, False: 88.4k]
  ------------------
 6144|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
  ------------------
  |  | 1556|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 6145|  88.4k|        }
 6146|  88.4k|        if (window->DockIsActive)
  ------------------
  |  Branch (6146:13): [True: 0, False: 88.4k]
  ------------------
 6147|      0|            window->DockNode->IsBgDrawnThisFrame = true;
 6148|       |
 6149|       |        // Title bar
 6150|       |        // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
 6151|       |        // in order for their pos/size to be matching their undocking state.)
 6152|  88.4k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6152:13): [True: 66.8k, False: 21.6k]
  |  Branch (6152:55): [True: 66.8k, False: 0]
  ------------------
 6153|  66.8k|        {
 6154|  66.8k|            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
  ------------------
  |  Branch (6154:47): [True: 5.48k, False: 61.3k]
  ------------------
 6155|  66.8k|            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
 6156|  66.8k|        }
 6157|       |
 6158|       |        // Menu bar
 6159|  88.4k|        if (flags & ImGuiWindowFlags_MenuBar)
  ------------------
  |  Branch (6159:13): [True: 0, False: 88.4k]
  ------------------
 6160|      0|        {
 6161|      0|            ImRect menu_bar_rect = window->MenuBarRect();
 6162|      0|            menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
 6163|      0|            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
  ------------------
  |  Branch (6163:180): [True: 0, False: 0]
  ------------------
 6164|      0|            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
  ------------------
  |  Branch (6164:17): [True: 0, False: 0]
  |  Branch (6164:49): [True: 0, False: 0]
  ------------------
 6165|      0|                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
 6166|      0|        }
 6167|       |
 6168|       |        // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
 6169|  88.4k|        ImGuiDockNode* node = window->DockNode;
 6170|  88.4k|        if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
  ------------------
  |  Branch (6170:13): [True: 0, False: 88.4k]
  |  Branch (6170:37): [True: 0, False: 0]
  |  Branch (6170:63): [True: 0, False: 0]
  ------------------
 6171|      0|        {
 6172|      0|            float unhide_sz_draw = ImFloor(g.FontSize * 0.70f);
 6173|      0|            float unhide_sz_hit = ImFloor(g.FontSize * 0.55f);
 6174|      0|            ImVec2 p = node->Pos;
 6175|      0|            ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
 6176|      0|            ImGuiID unhide_id = window->GetID("#UNHIDE");
 6177|      0|            KeepAliveID(unhide_id);
 6178|      0|            bool hovered, held;
 6179|      0|            if (ButtonBehavior(r, unhide_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren))
  ------------------
  |  Branch (6179:17): [True: 0, False: 0]
  ------------------
 6180|      0|                node->WantHiddenTabBarToggle = true;
 6181|      0|            else if (held && IsMouseDragging(0))
  ------------------
  |  Branch (6181:22): [True: 0, False: 0]
  |  Branch (6181:30): [True: 0, False: 0]
  ------------------
 6182|      0|                StartMouseMovingWindowOrNode(window, node, true);
 6183|       |
 6184|       |            // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
 6185|      0|            ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (6185:39): [True: 0, False: 0]
  |  Branch (6185:47): [True: 0, False: 0]
  |  Branch (6185:60): [True: 0, False: 0]
  |  Branch (6185:79): [True: 0, False: 0]
  |  Branch (6185:116): [True: 0, False: 0]
  ------------------
 6186|      0|            window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
 6187|      0|        }
 6188|       |
 6189|       |        // Scrollbars
 6190|  88.4k|        if (window->ScrollbarX)
  ------------------
  |  Branch (6190:13): [True: 11.3k, False: 77.0k]
  ------------------
 6191|  11.3k|            Scrollbar(ImGuiAxis_X);
 6192|  88.4k|        if (window->ScrollbarY)
  ------------------
  |  Branch (6192:13): [True: 16.1k, False: 72.3k]
  ------------------
 6193|  16.1k|            Scrollbar(ImGuiAxis_Y);
 6194|       |
 6195|       |        // Render resize grips (after their input handling so we don't have a frame of latency)
 6196|  88.4k|        if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
  ------------------
  |  Branch (6196:13): [True: 88.4k, False: 0]
  |  Branch (6196:48): [True: 66.8k, False: 21.6k]
  ------------------
 6197|  66.8k|        {
 6198|   133k|            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (6198:41): [True: 66.8k, False: 66.8k]
  ------------------
 6199|  66.8k|            {
 6200|  66.8k|                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
 6201|  66.8k|                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
 6202|  66.8k|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
  ------------------
  |  Branch (6202:72): [True: 0, False: 66.8k]
  ------------------
 6203|  66.8k|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
  ------------------
  |  Branch (6203:72): [True: 0, False: 66.8k]
  ------------------
 6204|  66.8k|                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
 6205|  66.8k|                window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
 6206|  66.8k|            }
 6207|  66.8k|        }
 6208|       |
 6209|       |        // Borders (for dock node host they will be rendered over after the tab bar)
 6210|  88.4k|        if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
  ------------------
  |  Branch (6210:13): [True: 88.4k, False: 0]
  |  Branch (6210:48): [True: 88.4k, False: 0]
  ------------------
 6211|  88.4k|            RenderWindowOuterBorders(window);
 6212|  88.4k|    }
 6213|   132k|}
imgui.cpp:_ZL19GetWindowBgColorIdxP11ImGuiWindow:
 5802|  88.4k|{
 5803|  88.4k|    if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (5803:9): [True: 0, False: 88.4k]
  ------------------
 5804|      0|        return ImGuiCol_PopupBg;
 5805|  88.4k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !window->DockIsActive)
  ------------------
  |  Branch (5805:9): [True: 11.3k, False: 77.0k]
  |  Branch (5805:59): [True: 11.3k, False: 0]
  ------------------
 5806|  11.3k|        return ImGuiCol_ChildBg;
 5807|  77.0k|    return ImGuiCol_WindowBg;
 5808|  88.4k|}
imgui.cpp:_ZN5ImGuiL24RenderWindowOuterBordersEP11ImGuiWindow:
 6050|  88.4k|{
 6051|  88.4k|    ImGuiContext& g = *GImGui;
 6052|  88.4k|    float rounding = window->WindowRounding;
 6053|  88.4k|    float border_size = window->WindowBorderSize;
 6054|  88.4k|    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))
  ------------------
  |  Branch (6054:9): [True: 88.4k, False: 0]
  |  Branch (6054:31): [True: 88.4k, False: 0]
  ------------------
 6055|  88.4k|        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
 6056|       |
 6057|  88.4k|    int border_held = window->ResizeBorderHeld;
 6058|  88.4k|    if (border_held != -1)
  ------------------
  |  Branch (6058:9): [True: 0, False: 88.4k]
  ------------------
 6059|      0|    {
 6060|      0|        const ImGuiResizeBorderDef& def = resize_border_def[border_held];
 6061|      0|        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
 6062|      0|        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
  ------------------
  |  |  254|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 6063|      0|        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
  ------------------
  |  |  254|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 6064|      0|        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), 0, ImMax(2.0f, border_size)); // Thicker than usual
 6065|      0|    }
 6066|  88.4k|    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6066:9): [True: 0, False: 88.4k]
  |  Branch (6066:40): [True: 0, False: 0]
  |  Branch (6066:90): [True: 0, False: 0]
  ------------------
 6067|      0|    {
 6068|      0|        float y = window->Pos.y + window->TitleBarHeight() - 1;
 6069|      0|        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);
 6070|      0|    }
 6071|  88.4k|}
imgui.cpp:_ZN5ImGuiL28RenderWindowTitleBarContentsEP11ImGuiWindowRK6ImRectPKcPb:
 6218|   110k|{
 6219|   110k|    ImGuiContext& g = *GImGui;
 6220|   110k|    ImGuiStyle& style = g.Style;
 6221|   110k|    ImGuiWindowFlags flags = window->Flags;
 6222|       |
 6223|   110k|    const bool has_close_button = (p_open != NULL);
 6224|   110k|    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);
  ------------------
  |  Branch (6224:38): [True: 110k, False: 0]
  |  Branch (6224:80): [True: 110k, False: 0]
  ------------------
 6225|       |
 6226|       |    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
 6227|       |    // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
 6228|   110k|    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
 6229|   110k|    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
 6230|   110k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 6231|       |
 6232|       |    // Layout buttons
 6233|       |    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
 6234|   110k|    float pad_l = style.FramePadding.x;
 6235|   110k|    float pad_r = style.FramePadding.x;
 6236|   110k|    float button_sz = g.FontSize;
 6237|   110k|    ImVec2 close_button_pos;
 6238|   110k|    ImVec2 collapse_button_pos;
 6239|   110k|    if (has_close_button)
  ------------------
  |  Branch (6239:9): [True: 0, False: 110k]
  ------------------
 6240|      0|    {
 6241|      0|        pad_r += button_sz;
 6242|      0|        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
 6243|      0|    }
 6244|   110k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
  ------------------
  |  Branch (6244:9): [True: 110k, False: 0]
  |  Branch (6244:32): [True: 0, False: 110k]
  ------------------
 6245|      0|    {
 6246|      0|        pad_r += button_sz;
 6247|      0|        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
 6248|      0|    }
 6249|   110k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
  ------------------
  |  Branch (6249:9): [True: 110k, False: 0]
  |  Branch (6249:32): [True: 110k, False: 0]
  ------------------
 6250|   110k|    {
 6251|   110k|        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l - style.FramePadding.x, title_bar_rect.Min.y);
 6252|   110k|        pad_l += button_sz;
 6253|   110k|    }
 6254|       |
 6255|       |    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
 6256|   110k|    if (has_collapse_button)
  ------------------
  |  Branch (6256:9): [True: 110k, False: 0]
  ------------------
 6257|   110k|        if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
  ------------------
  |  Branch (6257:13): [True: 0, False: 110k]
  ------------------
 6258|      0|            window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
 6259|       |
 6260|       |    // Close button
 6261|   110k|    if (has_close_button)
  ------------------
  |  Branch (6261:9): [True: 0, False: 110k]
  ------------------
 6262|      0|        if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
  ------------------
  |  Branch (6262:13): [True: 0, False: 0]
  ------------------
 6263|      0|            *p_open = false;
 6264|       |
 6265|   110k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 6266|   110k|    g.CurrentItemFlags = item_flags_backup;
 6267|       |
 6268|       |    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
 6269|       |    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
 6270|   110k|    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
  ------------------
  |  Branch (6270:33): [True: 0, False: 110k]
  ------------------
 6271|   110k|    const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
 6272|       |
 6273|       |    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
 6274|       |    // while uncentered title text will still reach edges correctly.
 6275|   110k|    if (pad_l > style.FramePadding.x)
  ------------------
  |  Branch (6275:9): [True: 110k, False: 0]
  ------------------
 6276|   110k|        pad_l += g.Style.ItemInnerSpacing.x;
 6277|   110k|    if (pad_r > style.FramePadding.x)
  ------------------
  |  Branch (6277:9): [True: 0, False: 110k]
  ------------------
 6278|      0|        pad_r += g.Style.ItemInnerSpacing.x;
 6279|   110k|    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
  ------------------
  |  Branch (6279:9): [True: 0, False: 110k]
  |  Branch (6279:44): [True: 0, False: 0]
  ------------------
 6280|      0|    {
 6281|      0|        float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
  ------------------
  |  |  433|      0|#define ImFabs(X)           fabsf(X)
  ------------------
 6282|      0|        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
 6283|      0|        pad_l = ImMax(pad_l, pad_extend * centerness);
 6284|      0|        pad_r = ImMax(pad_r, pad_extend * centerness);
 6285|      0|    }
 6286|       |
 6287|   110k|    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
 6288|   110k|    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
 6289|   110k|    if (flags & ImGuiWindowFlags_UnsavedDocument)
  ------------------
  |  Branch (6289:9): [True: 0, False: 110k]
  ------------------
 6290|      0|    {
 6291|      0|        ImVec2 marker_pos;
 6292|      0|        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
 6293|      0|        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
 6294|      0|        if (marker_pos.x > layout_r.Min.x)
  ------------------
  |  Branch (6294:13): [True: 0, False: 0]
  ------------------
 6295|      0|        {
 6296|      0|            RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
 6297|      0|            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
 6298|      0|        }
 6299|      0|    }
 6300|       |    //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6301|       |    //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6302|   110k|    RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
 6303|   110k|}
imgui.cpp:_ZN5ImGuiL20UpdateKeyboardInputsEv:
 8816|  55.4k|{
 8817|  55.4k|    ImGuiContext& g = *GImGui;
 8818|  55.4k|    ImGuiIO& io = g.IO;
 8819|       |
 8820|       |    // Import legacy keys or verify they are not used
 8821|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 8822|       |    if (io.BackendUsingLegacyKeyArrays == 0)
 8823|       |    {
 8824|       |        // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
 8825|       |        for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
 8826|       |            IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 8827|       |    }
 8828|       |    else
 8829|       |    {
 8830|       |        if (g.FrameCount == 0)
 8831|       |            for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 8832|       |                IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");
 8833|       |
 8834|       |        // Build reverse KeyMap (Named -> Legacy)
 8835|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 8836|       |            if (io.KeyMap[n] != -1)
 8837|       |            {
 8838|       |                IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
 8839|       |                io.KeyMap[io.KeyMap[n]] = n;
 8840|       |            }
 8841|       |
 8842|       |        // Import legacy keys into new ones
 8843|       |        for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 8844|       |            if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
 8845|       |            {
 8846|       |                const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
 8847|       |                IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
 8848|       |                io.KeysData[key].Down = io.KeysDown[n];
 8849|       |                if (key != n)
 8850|       |                    io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
 8851|       |                io.BackendUsingLegacyKeyArrays = 1;
 8852|       |            }
 8853|       |        if (io.BackendUsingLegacyKeyArrays == 1)
 8854|       |        {
 8855|       |            GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
 8856|       |            GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
 8857|       |            GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
 8858|       |            GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
 8859|       |        }
 8860|       |    }
 8861|       |
 8862|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 8863|       |    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
 8864|       |    if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
 8865|       |    {
 8866|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)           do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1]; } while (0)
 8867|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)    do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]); } while (0)
 8868|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
 8869|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
 8870|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
 8871|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
 8872|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
 8873|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadRight, ImGuiNavInput_DpadRight);
 8874|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadUp, ImGuiNavInput_DpadUp);
 8875|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadDown, ImGuiNavInput_DpadDown);
 8876|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadL1, ImGuiNavInput_FocusPrev, ImGuiNavInput_TweakSlow);
 8877|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadR1, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakFast);
 8878|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickLeft, ImGuiNavInput_LStickLeft);
 8879|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickRight, ImGuiNavInput_LStickRight);
 8880|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
 8881|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
 8882|       |        #undef NAV_MAP_KEY
 8883|       |    }
 8884|       |#endif
 8885|       |#endif
 8886|       |
 8887|       |    // Update aliases
 8888|   332k|    for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
  ------------------
  |  Branch (8888:21): [True: 277k, False: 55.4k]
  ------------------
 8889|   277k|        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
  ------------------
  |  Branch (8889:62): [True: 13.5k, False: 263k]
  ------------------
 8890|  55.4k|    UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
 8891|  55.4k|    UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);
 8892|       |
 8893|       |    // Synchronize io.KeyMods and io.KeyXXX values.
 8894|       |    // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 8895|       |    // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 8896|       |    // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
 8897|  55.4k|    io.KeyMods = GetMergedModsFromKeys();
 8898|  55.4k|    io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
 8899|  55.4k|    io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
 8900|  55.4k|    io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
 8901|  55.4k|    io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
 8902|       |
 8903|       |    // Clear gamepad data if disabled
 8904|  55.4k|    if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
  ------------------
  |  Branch (8904:9): [True: 55.4k, False: 0]
  ------------------
 8905|  1.38M|        for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1240|  55.4k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                      for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1241|  1.38M|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (8905:46): [True: 1.32M, False: 55.4k]
  ------------------
 8906|  1.32M|        {
 8907|  1.32M|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
 8908|  1.32M|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
 8909|  1.32M|        }
 8910|       |
 8911|       |    // Update keys
 8912|  7.81M|    for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
  ------------------
  |  Branch (8912:21): [True: 7.75M, False: 55.4k]
  ------------------
 8913|  7.75M|    {
 8914|  7.75M|        ImGuiKeyData* key_data = &io.KeysData[i];
 8915|  7.75M|        key_data->DownDurationPrev = key_data->DownDuration;
 8916|  7.75M|        key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (8916:34): [True: 50.3k, False: 7.70M]
  |  Branch (8916:52): [True: 4.68k, False: 45.6k]
  ------------------
 8917|  7.75M|    }
 8918|       |
 8919|       |    // Update keys/input owner (named keys only): one entry per key
 8920|  7.81M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (8920:50): [True: 7.75M, False: 55.4k]
  ------------------
 8921|  7.75M|    {
 8922|  7.75M|        ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
 8923|  7.75M|        ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
 8924|  7.75M|        owner_data->OwnerCurr = owner_data->OwnerNext;
 8925|  7.75M|        if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
  ------------------
  |  Branch (8925:13): [True: 7.70M, False: 50.3k]
  ------------------
 8926|  7.70M|            owner_data->OwnerNext = ImGuiKeyOwner_None;
  ------------------
  |  | 1312|  7.70M|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 8927|  7.75M|        owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;  // Clear LockUntilRelease when key is not Down anymore
  ------------------
  |  Branch (8927:68): [True: 0, False: 7.75M]
  |  Branch (8927:100): [True: 0, False: 0]
  ------------------
 8928|  7.75M|    }
 8929|       |
 8930|  55.4k|    UpdateKeyRoutingTable(&g.KeysRoutingTable);
 8931|  55.4k|}
imgui.cpp:_ZL14UpdateAliasKey8ImGuiKeybf:
 8797|   387k|{
 8798|   387k|    IM_ASSERT(ImGui::IsAliasKey(key));
  ------------------
  |  |   23|   387k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8799|   387k|    ImGuiKeyData* key_data = ImGui::GetKeyData(key);
 8800|   387k|    key_data->Down = v;
 8801|   387k|    key_data->AnalogValue = analog_value;
 8802|   387k|}
imgui.cpp:_ZL21GetMergedModsFromKeysv:
 8806|   110k|{
 8807|   110k|    ImGuiKeyChord mods = 0;
 8808|   110k|    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }
  ------------------
  |  Branch (8808:9): [True: 26.4k, False: 84.3k]
  ------------------
 8809|   110k|    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }
  ------------------
  |  Branch (8809:9): [True: 1.09k, False: 109k]
  ------------------
 8810|   110k|    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }
  ------------------
  |  Branch (8810:9): [True: 720, False: 110k]
  ------------------
 8811|   110k|    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }
  ------------------
  |  Branch (8811:9): [True: 612, False: 110k]
  ------------------
 8812|   110k|    return mods;
 8813|   110k|}
imgui.cpp:_ZN5ImGuiL21UpdateKeyRoutingTableEP20ImGuiKeyRoutingTable:
 8373|  55.4k|{
 8374|  55.4k|    ImGuiContext& g = *GImGui;
 8375|  55.4k|    rt->EntriesNext.resize(0);
 8376|  7.81M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (8376:50): [True: 7.75M, False: 55.4k]
  ------------------
 8377|  7.75M|    {
 8378|  7.75M|        const int new_routing_start_idx = rt->EntriesNext.Size;
 8379|  7.75M|        ImGuiKeyRoutingData* routing_entry;
 8380|  7.75M|        for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
  ------------------
  |  Branch (8380:78): [True: 0, False: 7.75M]
  ------------------
 8381|      0|        {
 8382|      0|            routing_entry = &rt->Entries[old_routing_idx];
 8383|      0|            routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
 8384|      0|            routing_entry->RoutingNext = ImGuiKeyOwner_None;
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 8385|      0|            routing_entry->RoutingNextScore = 255;
 8386|      0|            if (routing_entry->RoutingCurr == ImGuiKeyOwner_None)
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (8386:17): [True: 0, False: 0]
  ------------------
 8387|      0|                continue;
 8388|      0|            rt->EntriesNext.push_back(*routing_entry); // Write alive ones into new buffer
 8389|       |
 8390|       |            // Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
 8391|      0|            if (routing_entry->Mods == g.IO.KeyMods)
  ------------------
  |  Branch (8391:17): [True: 0, False: 0]
  ------------------
 8392|      0|            {
 8393|      0|                ImGuiKeyOwnerData* owner_data = ImGui::GetKeyOwnerData(key);
 8394|      0|                if (owner_data->OwnerCurr == ImGuiKeyOwner_None)
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (8394:21): [True: 0, False: 0]
  ------------------
 8395|      0|                    owner_data->OwnerCurr = routing_entry->RoutingCurr;
 8396|      0|            }
 8397|      0|        }
 8398|       |
 8399|       |        // Rewrite linked-list
 8400|  7.75M|        rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
  ------------------
  |  Branch (8400:75): [True: 0, False: 7.75M]
  ------------------
 8401|  7.75M|        for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
  ------------------
  |  Branch (8401:45): [True: 0, False: 7.75M]
  ------------------
 8402|      0|            rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
  ------------------
  |  Branch (8402:72): [True: 0, False: 0]
  ------------------
 8403|  7.75M|    }
 8404|  55.4k|    rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
 8405|  55.4k|}
imgui.cpp:_ZN5ImGuiL17UpdateMouseInputsEv:
 8934|  55.4k|{
 8935|  55.4k|    ImGuiContext& g = *GImGui;
 8936|  55.4k|    ImGuiIO& io = g.IO;
 8937|       |
 8938|       |    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
 8939|  55.4k|    if (IsMousePosValid(&io.MousePos))
  ------------------
  |  Branch (8939:9): [True: 8.95k, False: 46.4k]
  ------------------
 8940|  8.95k|        io.MousePos = g.MouseLastValidPos = ImFloorSigned(io.MousePos);
 8941|       |
 8942|       |    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
 8943|  55.4k|    if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (8943:9): [True: 8.95k, False: 46.4k]
  |  Branch (8943:42): [True: 8.31k, False: 635]
  ------------------
 8944|  8.31k|        io.MouseDelta = io.MousePos - io.MousePosPrev;
 8945|  47.0k|    else
 8946|  47.0k|        io.MouseDelta = ImVec2(0.0f, 0.0f);
 8947|       |
 8948|       |    // If mouse moved we re-enable mouse hovering in case it was disabled by gamepad/keyboard. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
 8949|  55.4k|    if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
  ------------------
  |  Branch (8949:9): [True: 302, False: 55.1k]
  |  Branch (8949:36): [True: 98, False: 55.0k]
  ------------------
 8950|    400|        g.NavDisableMouseHover = false;
 8951|       |
 8952|  55.4k|    io.MousePosPrev = io.MousePos;
 8953|   332k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   87|   332k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (8953:21): [True: 277k, False: 55.4k]
  ------------------
 8954|   277k|    {
 8955|   277k|        io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
  ------------------
  |  Branch (8955:30): [True: 13.5k, False: 263k]
  |  Branch (8955:49): [True: 1.41k, False: 12.1k]
  ------------------
 8956|   277k|        io.MouseClickedCount[i] = 0; // Will be filled below
 8957|   277k|        io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
  ------------------
  |  Branch (8957:31): [True: 263k, False: 13.5k]
  |  Branch (8957:51): [True: 0, False: 263k]
  ------------------
 8958|   277k|        io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
 8959|   277k|        io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (8959:35): [True: 13.5k, False: 263k]
  |  Branch (8959:54): [True: 1.41k, False: 12.1k]
  ------------------
 8960|   277k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (8960:13): [True: 1.41k, False: 275k]
  ------------------
 8961|  1.41k|        {
 8962|  1.41k|            bool is_repeated_click = false;
 8963|  1.41k|            if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
  ------------------
  |  Branch (8963:17): [True: 437, False: 973]
  ------------------
 8964|    437|            {
 8965|    437|                ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (8965:47): [True: 199, False: 238]
  ------------------
 8966|    437|                if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
  ------------------
  |  Branch (8966:21): [True: 350, False: 87]
  ------------------
 8967|    350|                    is_repeated_click = true;
 8968|    437|            }
 8969|  1.41k|            if (is_repeated_click)
  ------------------
  |  Branch (8969:17): [True: 350, False: 1.06k]
  ------------------
 8970|    350|                io.MouseClickedLastCount[i]++;
 8971|  1.06k|            else
 8972|  1.06k|                io.MouseClickedLastCount[i] = 1;
 8973|  1.41k|            io.MouseClickedTime[i] = g.Time;
 8974|  1.41k|            io.MouseClickedPos[i] = io.MousePos;
 8975|  1.41k|            io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
 8976|  1.41k|            io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
 8977|  1.41k|            io.MouseDragMaxDistanceSqr[i] = 0.0f;
 8978|  1.41k|        }
 8979|   275k|        else if (io.MouseDown[i])
  ------------------
  |  Branch (8979:18): [True: 12.1k, False: 263k]
  ------------------
 8980|  12.1k|        {
 8981|       |            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
 8982|  12.1k|            ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (8982:43): [True: 5.52k, False: 6.62k]
  ------------------
 8983|  12.1k|            io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
 8984|  12.1k|            io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
  ------------------
  |  Branch (8984:86): [True: 136, False: 12.0k]
  ------------------
 8985|  12.1k|            io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
  ------------------
  |  Branch (8985:86): [True: 136, False: 12.0k]
  ------------------
 8986|  12.1k|        }
 8987|       |
 8988|       |        // We provide io.MouseDoubleClicked[] as a legacy service
 8989|   277k|        io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);
 8990|       |
 8991|       |        // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
 8992|   277k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (8992:13): [True: 1.41k, False: 275k]
  ------------------
 8993|  1.41k|            g.NavDisableMouseHover = false;
 8994|   277k|    }
 8995|  55.4k|}
imgui.cpp:_ZN5ImGuiL16UpdateMouseWheelEv:
 9057|  55.4k|{
 9058|       |    // Reset the locked window if we move the mouse or after the timer elapses.
 9059|       |    // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
 9060|  55.4k|    ImGuiContext& g = *GImGui;
 9061|  55.4k|    if (g.WheelingWindow != NULL)
  ------------------
  |  Branch (9061:9): [True: 16, False: 55.3k]
  ------------------
 9062|     16|    {
 9063|     16|        g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
 9064|     16|        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
  ------------------
  |  Branch (9064:13): [True: 8, False: 8]
  |  Branch (9064:13): [True: 1, False: 15]
  |  Branch (9064:34): [True: 1, False: 7]
  ------------------
 9065|      1|            g.WheelingWindowReleaseTimer = 0.0f;
 9066|     16|        if (g.WheelingWindowReleaseTimer <= 0.0f)
  ------------------
  |  Branch (9066:13): [True: 16, False: 0]
  ------------------
 9067|     16|            LockWheelingWindow(NULL, 0.0f);
 9068|     16|    }
 9069|       |
 9070|  55.4k|    ImVec2 wheel;
 9071|  55.4k|    wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_None) ? g.IO.MouseWheelH : 0.0f;
  ------------------
  |  | 1312|  55.4k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9071:15): [True: 55.4k, False: 0]
  ------------------
 9072|  55.4k|    wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_None) ? g.IO.MouseWheel : 0.0f;
  ------------------
  |  | 1312|  55.4k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9072:15): [True: 55.4k, False: 0]
  ------------------
 9073|       |
 9074|       |    //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
 9075|  55.4k|    ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
  ------------------
  |  Branch (9075:33): [True: 0, False: 55.4k]
  ------------------
 9076|  55.4k|    if (!mouse_window || mouse_window->Collapsed)
  ------------------
  |  Branch (9076:9): [True: 54.2k, False: 1.11k]
  |  Branch (9076:26): [True: 534, False: 579]
  ------------------
 9077|  54.8k|        return;
 9078|       |
 9079|       |    // Zoom / Scale window
 9080|       |    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
 9081|    579|    if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
  ------------------
  |  Branch (9081:9): [True: 1, False: 578]
  |  Branch (9081:28): [True: 0, False: 1]
  |  Branch (9081:44): [True: 0, False: 0]
  ------------------
 9082|      0|    {
 9083|      0|        LockWheelingWindow(mouse_window, wheel.y);
 9084|      0|        ImGuiWindow* window = mouse_window;
 9085|      0|        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
 9086|      0|        const float scale = new_font_scale / window->FontWindowScale;
 9087|      0|        window->FontWindowScale = new_font_scale;
 9088|      0|        if (window == window->RootWindow)
  ------------------
  |  Branch (9088:13): [True: 0, False: 0]
  ------------------
 9089|      0|        {
 9090|      0|            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
 9091|      0|            SetWindowPos(window, window->Pos + offset, 0);
 9092|      0|            window->Size = ImFloor(window->Size * scale);
 9093|      0|            window->SizeFull = ImFloor(window->SizeFull * scale);
 9094|      0|        }
 9095|      0|        return;
 9096|      0|    }
 9097|    579|    if (g.IO.KeyCtrl)
  ------------------
  |  Branch (9097:9): [True: 85, False: 494]
  ------------------
 9098|     85|        return;
 9099|       |
 9100|       |    // Mouse wheel scrolling
 9101|       |    // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
 9102|       |    // (we avoid doing it on OSX as it the OS input layer handles this already)
 9103|    494|    const bool swap_axis = g.IO.KeyShift && !g.IO.ConfigMacOSXBehaviors;
  ------------------
  |  Branch (9103:28): [True: 17, False: 477]
  |  Branch (9103:45): [True: 17, False: 0]
  ------------------
 9104|    494|    if (swap_axis)
  ------------------
  |  Branch (9104:9): [True: 17, False: 477]
  ------------------
 9105|     17|    {
 9106|     17|        wheel.x = wheel.y;
 9107|     17|        wheel.y = 0.0f;
 9108|     17|    }
 9109|       |
 9110|       |    // Maintain a rough average of moving magnitude on both axises
 9111|       |    // FIXME: should by based on wall clock time rather than frame-counter
 9112|    494|    g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
 9113|    494|    g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);
 9114|       |
 9115|       |    // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
 9116|    494|    wheel += g.WheelingWindowWheelRemainder;
 9117|    494|    g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
 9118|    494|    if (wheel.x == 0.0f && wheel.y == 0.0f)
  ------------------
  |  Branch (9118:9): [True: 478, False: 16]
  |  Branch (9118:28): [True: 478, False: 0]
  ------------------
 9119|    478|        return;
 9120|       |
 9121|       |    // Mouse wheel scrolling: find target and apply
 9122|       |    // - don't renew lock if axis doesn't apply on the window.
 9123|       |    // - select a main axis when both axises are being moved.
 9124|     16|    if (ImGuiWindow* window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
  ------------------
  |  Branch (9124:22): [True: 16, False: 0]
  ------------------
 9125|     16|        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (9125:13): [True: 16, False: 0]
  |  Branch (9125:70): [True: 16, False: 0]
  ------------------
 9126|     16|        {
 9127|     16|            bool do_scroll[2] = { wheel.x != 0.0f && window->ScrollMax.x != 0.0f, wheel.y != 0.0f && window->ScrollMax.y != 0.0f };
  ------------------
  |  Branch (9127:35): [True: 16, False: 0]
  |  Branch (9127:54): [True: 16, False: 0]
  |  Branch (9127:83): [True: 1, False: 15]
  |  Branch (9127:102): [True: 1, False: 0]
  ------------------
 9128|     16|            if (do_scroll[ImGuiAxis_X] && do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (9128:17): [True: 16, False: 0]
  |  Branch (9128:43): [True: 1, False: 15]
  ------------------
 9129|      1|                do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis_Y : ImGuiAxis_X] = false;
  ------------------
  |  Branch (9129:27): [True: 0, False: 1]
  ------------------
 9130|     16|            if (do_scroll[ImGuiAxis_X])
  ------------------
  |  Branch (9130:17): [True: 15, False: 1]
  ------------------
 9131|     15|            {
 9132|     15|                LockWheelingWindow(window, wheel.x);
 9133|     15|                float max_step = window->InnerRect.GetWidth() * 0.67f;
 9134|     15|                float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step));
 9135|     15|                SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
 9136|     15|            }
 9137|     16|            if (do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (9137:17): [True: 1, False: 15]
  ------------------
 9138|      1|            {
 9139|      1|                LockWheelingWindow(window, wheel.y);
 9140|      1|                float max_step = window->InnerRect.GetHeight() * 0.67f;
 9141|      1|                float scroll_step = ImFloor(ImMin(5 * window->CalcFontSize(), max_step));
 9142|      1|                SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
 9143|      1|            }
 9144|     16|        }
 9145|     16|}
imgui.cpp:_ZL18LockWheelingWindowP11ImGuiWindowf:
 8998|     32|{
 8999|     32|    ImGuiContext& g = *GImGui;
 9000|     32|    if (window)
  ------------------
  |  Branch (9000:9): [True: 16, False: 16]
  ------------------
 9001|     16|        g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
 9002|     16|    else
 9003|     16|        g.WheelingWindowReleaseTimer = 0.0f;
 9004|     32|    if (g.WheelingWindow == window)
  ------------------
  |  Branch (9004:9): [True: 0, False: 32]
  ------------------
 9005|      0|        return;
 9006|     32|    IMGUI_DEBUG_LOG_IO("LockWheelingWindow() \"%s\"\n", window ? window->Name : "NULL");
  ------------------
  |  |  231|     32|#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (222:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (231:50): [True: 0, False: 32]
  |  |  |  Branch (231:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 9007|     32|    g.WheelingWindow = window;
 9008|     32|    g.WheelingWindowRefMousePos = g.IO.MousePos;
 9009|     32|    if (window == NULL)
  ------------------
  |  Branch (9009:9): [True: 16, False: 16]
  ------------------
 9010|     16|    {
 9011|     16|        g.WheelingWindowStartFrame = -1;
 9012|     16|        g.WheelingAxisAvg = ImVec2(0.0f, 0.0f);
 9013|     16|    }
 9014|     32|}
imgui.cpp:_ZL22FindBestWheelingWindowRK6ImVec2:
 9017|     16|{
 9018|       |    // For each axis, find window in the hierarchy that may want to use scrolling
 9019|     16|    ImGuiContext& g = *GImGui;
 9020|     16|    ImGuiWindow* windows[2] = { NULL, NULL };
 9021|     48|    for (int axis = 0; axis < 2; axis++)
  ------------------
  |  Branch (9021:24): [True: 32, False: 16]
  ------------------
 9022|     32|        if (wheel[axis] != 0.0f)
  ------------------
  |  Branch (9022:13): [True: 17, False: 15]
  ------------------
 9023|     17|            for (ImGuiWindow* window = windows[axis] = g.HoveredWindow; window->Flags & ImGuiWindowFlags_ChildWindow; window = windows[axis] = window->ParentWindow)
  ------------------
  |  Branch (9023:73): [True: 0, False: 17]
  ------------------
 9024|      0|            {
 9025|       |                // Bubble up into parent window if:
 9026|       |                // - a child window doesn't allow any scrolling.
 9027|       |                // - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
 9028|       |                //// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
 9029|      0|                const bool has_scrolling = (window->ScrollMax[axis] != 0.0f);
 9030|      0|                const bool inputs_disabled = (window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs);
  ------------------
  |  Branch (9030:46): [True: 0, False: 0]
  |  Branch (9030:102): [True: 0, False: 0]
  ------------------
 9031|       |                //const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >= window->ScrollMax[axis]);
 9032|      0|                if (has_scrolling && !inputs_disabled) // && !scrolling_past_limits)
  ------------------
  |  Branch (9032:21): [True: 0, False: 0]
  |  Branch (9032:38): [True: 0, False: 0]
  ------------------
 9033|      0|                    break; // select this window
 9034|      0|            }
 9035|     16|    if (windows[0] == NULL && windows[1] == NULL)
  ------------------
  |  Branch (9035:9): [True: 0, False: 16]
  |  Branch (9035:31): [True: 0, False: 0]
  ------------------
 9036|      0|        return NULL;
 9037|       |
 9038|       |    // If there's only one window or only one axis then there's no ambiguity
 9039|     16|    if (windows[0] == windows[1] || windows[0] == NULL || windows[1] == NULL)
  ------------------
  |  Branch (9039:9): [True: 1, False: 15]
  |  Branch (9039:37): [True: 0, False: 15]
  |  Branch (9039:59): [True: 15, False: 0]
  ------------------
 9040|     16|        return windows[1] ? windows[1] : windows[0];
  ------------------
  |  Branch (9040:16): [True: 1, False: 15]
  ------------------
 9041|       |
 9042|       |    // If candidate are different windows we need to decide which one to prioritize
 9043|       |    // - First frame: only find a winner if one axis is zero.
 9044|       |    // - Subsequent frames: only find a winner when one is more than the other.
 9045|      0|    if (g.WheelingWindowStartFrame == -1)
  ------------------
  |  Branch (9045:9): [True: 0, False: 0]
  ------------------
 9046|      0|        g.WheelingWindowStartFrame = g.FrameCount;
 9047|      0|    if ((g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0f && wheel.y != 0.0f) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y))
  ------------------
  |  Branch (9047:10): [True: 0, False: 0]
  |  Branch (9047:56): [True: 0, False: 0]
  |  Branch (9047:75): [True: 0, False: 0]
  |  Branch (9047:95): [True: 0, False: 0]
  ------------------
 9048|      0|    {
 9049|      0|        g.WheelingWindowWheelRemainder = wheel;
 9050|      0|        return NULL;
 9051|      0|    }
 9052|      0|    return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
  ------------------
  |  Branch (9052:12): [True: 0, False: 0]
  ------------------
 9053|      0|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckNewFrameSanityChecksEv:
 9478|  55.4k|{
 9479|  55.4k|    ImGuiContext& g = *GImGui;
 9480|       |
 9481|       |    // Check user IM_ASSERT macro
 9482|       |    // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
 9483|       |    //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
 9484|       |    //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
 9485|       |    // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
 9486|       |    // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
 9487|  55.4k|    if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9487:9): [Folded - Ignored]
  ------------------
 9488|       |
 9489|       |    // Check user data
 9490|       |    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
 9491|  55.4k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9492|  55.4k|    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9493|  55.4k|    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9494|  55.4k|    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9495|  55.4k|    IM_ASSERT(g.IO.Fonts->IsBuilt()                                     && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9496|  55.4k|    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9497|  55.4k|    IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f                 && "Invalid style setting!");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9498|  55.4k|    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9499|  55.4k|    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9500|  55.4k|    IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9501|  55.4k|    IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9502|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9503|       |    for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
 9504|       |        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");
 9505|       |
 9506|       |    // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
 9507|       |    if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
 9508|       |        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
 9509|       |#endif
 9510|       |
 9511|       |    // Check: the io.ConfigWindowsResizeFromEdges option requires backend to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
 9512|  55.4k|    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
  ------------------
  |  Branch (9512:9): [True: 1, False: 55.4k]
  |  Branch (9512:46): [True: 1, False: 0]
  ------------------
 9513|      1|        g.IO.ConfigWindowsResizeFromEdges = false;
 9514|       |
 9515|       |    // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
 9516|  55.4k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
  ------------------
  |  Branch (9516:9): [True: 4, False: 55.4k]
  |  Branch (9516:30): [True: 4, False: 0]
  |  Branch (9516:85): [True: 0, False: 4]
  ------------------
 9517|  55.4k|        IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9518|  55.4k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
  ------------------
  |  Branch (9518:9): [True: 4, False: 55.4k]
  |  Branch (9518:30): [True: 0, False: 4]
  |  Branch (9518:87): [True: 0, False: 0]
  ------------------
 9519|  55.4k|        IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9520|       |
 9521|       |    // Perform simple checks: multi-viewport and platform windows support
 9522|  55.4k|    if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (9522:9): [True: 1, False: 55.4k]
  ------------------
 9523|      1|    {
 9524|      1|        if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
  ------------------
  |  Branch (9524:13): [True: 0, False: 1]
  |  Branch (9524:77): [True: 0, False: 0]
  ------------------
 9525|      0|        {
 9526|      0|            IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9527|      0|            IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9528|      0|            IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9529|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9530|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9531|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9532|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9533|      0|            IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9534|      0|            IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9535|      0|            if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (9535:17): [True: 0, False: 0]
  |  Branch (9535:57): [True: 0, False: 0]
  ------------------
 9536|      0|                IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9537|      0|        }
 9538|      1|        else
 9539|      1|        {
 9540|       |            // Disable feature, our backends do not support it
 9541|      1|            g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
 9542|      1|        }
 9543|       |
 9544|       |        // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
 9545|      1|        for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n++)
  ------------------
  |  Branch (9545:33): [True: 0, False: 1]
  ------------------
 9546|      0|        {
 9547|      0|            ImGuiPlatformMonitor& mon = g.PlatformIO.Monitors[monitor_n];
 9548|      0|            IM_UNUSED(mon);
  ------------------
  |  |   88|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9549|      0|            IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9550|      0|            IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9551|      0|            IM_ASSERT(mon.DpiScale != 0.0f);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9552|      0|        }
 9553|      1|    }
 9554|  55.4k|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckEndFrameSanityChecksEv:
 9557|  55.4k|{
 9558|  55.4k|    ImGuiContext& g = *GImGui;
 9559|       |
 9560|       |    // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
 9561|       |    // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
 9562|       |    // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
 9563|       |    // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
 9564|       |    // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
 9565|       |    // while still correctly asserting on mid-frame key press events.
 9566|  55.4k|    const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
 9567|  55.4k|    IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9568|  55.4k|    IM_UNUSED(key_mods);
  ------------------
  |  |   88|  55.4k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9569|       |
 9570|       |    // [EXPERIMENTAL] Recover from errors: You may call this yourself before EndFrame().
 9571|       |    //ErrorCheckEndFrameRecover();
 9572|       |
 9573|       |    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
 9574|       |    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
 9575|  55.4k|    if (g.CurrentWindowStack.Size != 1)
  ------------------
  |  Branch (9575:9): [True: 0, False: 55.4k]
  ------------------
 9576|      0|    {
 9577|      0|        if (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (9577:13): [True: 0, False: 0]
  ------------------
 9578|      0|        {
 9579|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
  ------------------
  |  |  250|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9580|      0|            while (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (9580:20): [True: 0, False: 0]
  ------------------
 9581|      0|                End();
 9582|      0|        }
 9583|      0|        else
 9584|      0|        {
 9585|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
  ------------------
  |  |  250|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9586|      0|        }
 9587|      0|    }
 9588|       |
 9589|  55.4k|    IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
  ------------------
  |  |  250|  55.4k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9590|  55.4k|}
imgui.cpp:_ZL38CalcNextScrollFromScrollTargetAndClampP11ImGuiWindow:
10250|   132k|{
10251|   132k|    ImVec2 scroll = window->Scroll;
10252|   132k|    ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
10253|   397k|    for (int axis = 0; axis < 2; axis++)
  ------------------
  |  Branch (10253:24): [True: 264k, False: 132k]
  ------------------
10254|   264k|    {
10255|   264k|        if (window->ScrollTarget[axis] < FLT_MAX)
  ------------------
  |  Branch (10255:13): [True: 4.41k, False: 260k]
  ------------------
10256|  4.41k|        {
10257|  4.41k|            float center_ratio = window->ScrollTargetCenterRatio[axis];
10258|  4.41k|            float scroll_target = window->ScrollTarget[axis];
10259|  4.41k|            if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f)
  ------------------
  |  Branch (10259:17): [True: 0, False: 4.41k]
  ------------------
10260|      0|            {
10261|      0|                float snap_min = 0.0f;
10262|      0|                float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
10263|      0|                scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
10264|      0|            }
10265|  4.41k|            scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
10266|  4.41k|        }
10267|   264k|        scroll[axis] = IM_FLOOR(ImMax(scroll[axis], 0.0f));
  ------------------
  |  |  266|   264k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
10268|   264k|        if (!window->Collapsed && !window->SkipItems)
  ------------------
  |  Branch (10268:13): [True: 176k, False: 88.0k]
  |  Branch (10268:35): [True: 168k, False: 8.65k]
  ------------------
10269|   168k|            scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
10270|   264k|    }
10271|   132k|    return scroll;
10272|   132k|}
imgui.cpp:_ZN5ImGuiL14NavProcessItemEv:
11321|    368|{
11322|    368|    ImGuiContext& g = *GImGui;
11323|    368|    ImGuiWindow* window = g.CurrentWindow;
11324|    368|    const ImGuiID id = g.LastItemData.ID;
11325|    368|    const ImRect nav_bb = g.LastItemData.NavRect;
11326|    368|    const ImGuiItemFlags item_flags = g.LastItemData.InFlags;
11327|       |
11328|       |    // Process Init Request
11329|    368|    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
  ------------------
  |  Branch (11329:9): [True: 3, False: 365]
  |  Branch (11329:29): [True: 1, False: 2]
  |  Branch (11329:73): [True: 1, False: 0]
  ------------------
11330|      1|    {
11331|       |        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
11332|      1|        const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
11333|      1|        if (candidate_for_nav_default_focus || g.NavInitResultId == 0)
  ------------------
  |  Branch (11333:13): [True: 1, False: 0]
  |  Branch (11333:48): [True: 0, False: 0]
  ------------------
11334|      1|        {
11335|      1|            g.NavInitResultId = id;
11336|      1|            g.NavInitResultRectRel = WindowRectAbsToRel(window, nav_bb);
11337|      1|        }
11338|      1|        if (candidate_for_nav_default_focus)
  ------------------
  |  Branch (11338:13): [True: 1, False: 0]
  ------------------
11339|      1|        {
11340|      1|            g.NavInitRequest = false; // Found a match, clear request
11341|      1|            NavUpdateAnyRequestFlag();
11342|      1|        }
11343|      1|    }
11344|       |
11345|       |    // Process Move Request (scoring for navigation)
11346|       |    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
11347|    368|    if (g.NavMoveScoringItems)
  ------------------
  |  Branch (11347:9): [True: 131, False: 237]
  ------------------
11348|    131|    {
11349|    131|        const bool is_tab_stop = (item_flags & ImGuiItemFlags_Inputable) && (item_flags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;
  ------------------
  |  Branch (11349:34): [True: 0, False: 131]
  |  Branch (11349:77): [True: 0, False: 0]
  ------------------
11350|    131|        const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing) != 0;
11351|    131|        if (is_tabbing)
  ------------------
  |  Branch (11351:13): [True: 81, False: 50]
  ------------------
11352|     81|        {
11353|     81|            if (is_tab_stop || (g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi))
  ------------------
  |  Branch (11353:17): [True: 0, False: 81]
  |  Branch (11353:32): [True: 0, False: 81]
  ------------------
11354|      0|                NavProcessItemForTabbingRequest(id);
11355|     81|        }
11356|     50|        else if ((g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_Disabled))
  ------------------
  |  Branch (11356:19): [True: 38, False: 12]
  |  Branch (11356:36): [True: 0, False: 12]
  |  Branch (11356:95): [True: 38, False: 0]
  ------------------
11357|     38|        {
11358|     38|            ImGuiNavItemData* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
  ------------------
  |  Branch (11358:40): [True: 38, False: 0]
  ------------------
11359|     38|            if (!is_tabbing)
  ------------------
  |  Branch (11359:17): [True: 38, False: 0]
  ------------------
11360|     38|            {
11361|     38|                if (NavScoreItem(result))
  ------------------
  |  Branch (11361:21): [True: 0, False: 38]
  ------------------
11362|      0|                    NavApplyItemToResult(result);
11363|       |
11364|       |                // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
11365|     38|                const float VISIBLE_RATIO = 0.70f;
11366|     38|                if ((g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
  ------------------
  |  Branch (11366:21): [True: 3, False: 35]
  |  Branch (11366:81): [True: 3, False: 0]
  ------------------
11367|      3|                    if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
  ------------------
  |  Branch (11367:25): [True: 3, False: 0]
  ------------------
11368|      3|                        if (NavScoreItem(&g.NavMoveResultLocalVisible))
  ------------------
  |  Branch (11368:29): [True: 0, False: 3]
  ------------------
11369|      0|                            NavApplyItemToResult(&g.NavMoveResultLocalVisible);
11370|     38|            }
11371|     38|        }
11372|    131|    }
11373|       |
11374|       |    // Update window-relative bounding box of navigated item
11375|    368|    if (g.NavId == id)
  ------------------
  |  Branch (11375:9): [True: 247, False: 121]
  ------------------
11376|    247|    {
11377|    247|        if (g.NavWindow != window)
  ------------------
  |  Branch (11377:13): [True: 0, False: 247]
  ------------------
11378|      0|            SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
11379|    247|        g.NavLayer = window->DC.NavLayerCurrent;
11380|    247|        g.NavFocusScopeId = g.CurrentFocusScopeId;
11381|    247|        g.NavIdIsAlive = true;
11382|    247|        window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb);    // Store item bounding box (relative to window position)
11383|    247|    }
11384|    368|}
imgui.cpp:_ZN5ImGuiL12NavScoreItemEP16ImGuiNavItemData:
11175|     41|{
11176|     41|    ImGuiContext& g = *GImGui;
11177|     41|    ImGuiWindow* window = g.CurrentWindow;
11178|     41|    if (g.NavLayer != window->DC.NavLayerCurrent)
  ------------------
  |  Branch (11178:9): [True: 41, False: 0]
  ------------------
11179|     41|        return false;
11180|       |
11181|       |    // FIXME: Those are not good variables names
11182|      0|    ImRect cand = g.LastItemData.NavRect;   // Current item nav rectangle
11183|      0|    const ImRect curr = g.NavScoringRect;   // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
11184|      0|    g.NavScoringDebugCount++;
11185|       |
11186|       |    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
11187|      0|    if (window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (11187:9): [True: 0, False: 0]
  ------------------
11188|      0|    {
11189|      0|        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11190|      0|        if (!window->ClipRect.Overlaps(cand))
  ------------------
  |  Branch (11190:13): [True: 0, False: 0]
  ------------------
11191|      0|            return false;
11192|      0|        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
11193|      0|    }
11194|       |
11195|       |    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
11196|       |    // For example, this ensures that items in one column are not reached when moving vertically from items in another column.
11197|      0|    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);
11198|       |
11199|       |    // Compute distance between boxes
11200|       |    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
11201|      0|    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
11202|      0|    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
11203|      0|    if (dby != 0.0f && dbx != 0.0f)
  ------------------
  |  Branch (11203:9): [True: 0, False: 0]
  |  Branch (11203:24): [True: 0, False: 0]
  ------------------
11204|      0|        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
  ------------------
  |  Branch (11204:34): [True: 0, False: 0]
  ------------------
11205|      0|    float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  433|      0|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  433|      0|#define ImFabs(X)           fabsf(X)
  ------------------
11206|       |
11207|       |    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
11208|      0|    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
11209|      0|    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
11210|      0|    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  433|      0|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  433|      0|#define ImFabs(X)           fabsf(X)
  ------------------
11211|       |
11212|       |    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
11213|      0|    ImGuiDir quadrant;
11214|      0|    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
11215|      0|    if (dbx != 0.0f || dby != 0.0f)
  ------------------
  |  Branch (11215:9): [True: 0, False: 0]
  |  Branch (11215:24): [True: 0, False: 0]
  ------------------
11216|      0|    {
11217|       |        // For non-overlapping boxes, use distance between boxes
11218|      0|        dax = dbx;
11219|      0|        day = dby;
11220|      0|        dist_axial = dist_box;
11221|      0|        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
11222|      0|    }
11223|      0|    else if (dcx != 0.0f || dcy != 0.0f)
  ------------------
  |  Branch (11223:14): [True: 0, False: 0]
  |  Branch (11223:29): [True: 0, False: 0]
  ------------------
11224|      0|    {
11225|       |        // For overlapping boxes with different centers, use distance between centers
11226|      0|        dax = dcx;
11227|      0|        day = dcy;
11228|      0|        dist_axial = dist_center;
11229|      0|        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
11230|      0|    }
11231|      0|    else
11232|      0|    {
11233|       |        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
11234|      0|        quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
  ------------------
  |  Branch (11234:20): [True: 0, False: 0]
  ------------------
11235|      0|    }
11236|       |
11237|       |#if IMGUI_DEBUG_NAV_SCORING
11238|       |    char buf[128];
11239|       |    if (IsMouseHoveringRect(cand.Min, cand.Max))
11240|       |    {
11241|       |        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
11242|       |        ImDrawList* draw_list = GetForegroundDrawList(window);
11243|       |        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));
11244|       |        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
11245|       |        draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40,0,0,150));
11246|       |        draw_list->AddText(cand.Max, ~0U, buf);
11247|       |    }
11248|       |    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
11249|       |    {
11250|       |        if (quadrant == g.NavMoveDir)
11251|       |        {
11252|       |            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
11253|       |            ImDrawList* draw_list = GetForegroundDrawList(window);
11254|       |            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
11255|       |            draw_list->AddText(cand.Min, IM_COL32(255, 255, 255, 255), buf);
11256|       |        }
11257|       |    }
11258|       |#endif
11259|       |
11260|       |    // Is it in the quadrant we're interested in moving to?
11261|      0|    bool new_best = false;
11262|      0|    const ImGuiDir move_dir = g.NavMoveDir;
11263|      0|    if (quadrant == move_dir)
  ------------------
  |  Branch (11263:9): [True: 0, False: 0]
  ------------------
11264|      0|    {
11265|       |        // Does it beat the current best candidate?
11266|      0|        if (dist_box < result->DistBox)
  ------------------
  |  Branch (11266:13): [True: 0, False: 0]
  ------------------
11267|      0|        {
11268|      0|            result->DistBox = dist_box;
11269|      0|            result->DistCenter = dist_center;
11270|      0|            return true;
11271|      0|        }
11272|      0|        if (dist_box == result->DistBox)
  ------------------
  |  Branch (11272:13): [True: 0, False: 0]
  ------------------
11273|      0|        {
11274|       |            // Try using distance between center points to break ties
11275|      0|            if (dist_center < result->DistCenter)
  ------------------
  |  Branch (11275:17): [True: 0, False: 0]
  ------------------
11276|      0|            {
11277|      0|                result->DistCenter = dist_center;
11278|      0|                new_best = true;
11279|      0|            }
11280|      0|            else if (dist_center == result->DistCenter)
  ------------------
  |  Branch (11280:22): [True: 0, False: 0]
  ------------------
11281|      0|            {
11282|       |                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
11283|       |                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
11284|       |                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
11285|      0|                if (((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
  ------------------
  |  Branch (11285:21): [True: 0, False: 0]
  |  Branch (11285:23): [True: 0, False: 0]
  |  Branch (11285:50): [True: 0, False: 0]
  ------------------
11286|      0|                    new_best = true;
11287|      0|            }
11288|      0|        }
11289|      0|    }
11290|       |
11291|       |    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
11292|       |    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
11293|       |    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
11294|       |    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
11295|       |    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
11296|      0|    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
  ------------------
  |  Branch (11296:9): [True: 0, False: 0]
  |  Branch (11296:39): [True: 0, False: 0]
  ------------------
11297|      0|        if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (11297:13): [True: 0, False: 0]
  |  Branch (11297:49): [True: 0, False: 0]
  ------------------
11298|      0|            if ((move_dir == ImGuiDir_Left && dax < 0.0f) || (move_dir == ImGuiDir_Right && dax > 0.0f) || (move_dir == ImGuiDir_Up && day < 0.0f) || (move_dir == ImGuiDir_Down && day > 0.0f))
  ------------------
  |  Branch (11298:18): [True: 0, False: 0]
  |  Branch (11298:47): [True: 0, False: 0]
  |  Branch (11298:63): [True: 0, False: 0]
  |  Branch (11298:93): [True: 0, False: 0]
  |  Branch (11298:109): [True: 0, False: 0]
  |  Branch (11298:136): [True: 0, False: 0]
  |  Branch (11298:152): [True: 0, False: 0]
  |  Branch (11298:181): [True: 0, False: 0]
  ------------------
11299|      0|            {
11300|      0|                result->DistAxial = dist_axial;
11301|      0|                new_best = true;
11302|      0|            }
11303|       |
11304|      0|    return new_best;
11305|      0|}
imgui.cpp:_ZN5ImGuiL28NavRestoreLastChildNavWindowEP11ImGuiWindow:
11517|    524|{
11518|    524|    if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
  ------------------
  |  Branch (11518:9): [True: 320, False: 204]
  |  Branch (11518:42): [True: 319, False: 1]
  ------------------
11519|    319|        return window->NavLastChildNavWindow;
11520|    205|    if (window->DockNodeAsHost && window->DockNodeAsHost->TabBar)
  ------------------
  |  Branch (11520:9): [True: 0, False: 205]
  |  Branch (11520:35): [True: 0, False: 0]
  ------------------
11521|      0|        if (ImGuiTabItem* tab = TabBarFindMostRecentlySelectedTabForActiveWindow(window->DockNodeAsHost->TabBar))
  ------------------
  |  Branch (11521:27): [True: 0, False: 0]
  ------------------
11522|      0|            return tab->Window;
11523|    205|    return window;
11524|    205|}
imgui.cpp:_ZN5ImGuiL23NavUpdateAnyRequestFlagEv:
11556|  59.9k|{
11557|  59.9k|    ImGuiContext& g = *GImGui;
11558|  59.9k|    g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
  ------------------
  |  |  961|   117k|#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
  |  |  ------------------
  |  |  |  Branch (961:37): [Folded - Ignored]
  |  |  ------------------
  ------------------
  |  Branch (11558:23): [True: 422, False: 59.4k]
  |  Branch (11558:48): [True: 626, False: 58.8k]
  |  Branch (11558:96): [True: 0, False: 0]
  ------------------
11559|  59.9k|    if (g.NavAnyRequest)
  ------------------
  |  Branch (11559:9): [True: 1.04k, False: 58.8k]
  ------------------
11560|  59.9k|        IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|  59.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11561|  59.9k|}
imgui.cpp:_ZN5ImGuiL9NavUpdateEv:
11649|  55.4k|{
11650|  55.4k|    ImGuiContext& g = *GImGui;
11651|  55.4k|    ImGuiIO& io = g.IO;
11652|       |
11653|  55.4k|    io.WantSetMousePos = false;
11654|       |    //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
11655|       |
11656|       |    // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
11657|       |    // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
11658|  55.4k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (11658:37): [True: 55.4k, False: 0]
  |  Branch (11658:98): [True: 0, False: 55.4k]
  ------------------
11659|  55.4k|    const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
11660|  55.4k|    if (nav_gamepad_active)
  ------------------
  |  Branch (11660:9): [True: 0, False: 55.4k]
  ------------------
11661|      0|        for (ImGuiKey key : nav_gamepad_keys_to_change_source)
  ------------------
  |  Branch (11661:27): [True: 0, False: 0]
  ------------------
11662|      0|            if (IsKeyDown(key))
  ------------------
  |  Branch (11662:17): [True: 0, False: 0]
  ------------------
11663|      0|                g.NavInputSource = ImGuiInputSource_Gamepad;
11664|  55.4k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
11665|  55.4k|    const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
11666|  55.4k|    if (nav_keyboard_active)
  ------------------
  |  Branch (11666:9): [True: 55.4k, False: 0]
  ------------------
11667|  55.4k|        for (ImGuiKey key : nav_keyboard_keys_to_change_source)
  ------------------
  |  Branch (11667:27): [True: 387k, False: 55.4k]
  ------------------
11668|   387k|            if (IsKeyDown(key))
  ------------------
  |  Branch (11668:17): [True: 3.35k, False: 384k]
  ------------------
11669|  3.35k|                g.NavInputSource = ImGuiInputSource_Keyboard;
11670|       |
11671|       |    // Process navigation init request (select first/default focus)
11672|  55.4k|    if (g.NavInitResultId != 0)
  ------------------
  |  Branch (11672:9): [True: 1, False: 55.4k]
  ------------------
11673|      1|        NavInitRequestApplyResult();
11674|  55.4k|    g.NavInitRequest = false;
11675|  55.4k|    g.NavInitRequestFromMove = false;
11676|  55.4k|    g.NavInitResultId = 0;
11677|  55.4k|    g.NavJustMovedToId = 0;
11678|       |
11679|       |    // Process navigation move request
11680|  55.4k|    if (g.NavMoveSubmitted)
  ------------------
  |  Branch (11680:9): [True: 171, False: 55.2k]
  ------------------
11681|    171|        NavMoveRequestApplyResult();
11682|  55.4k|    g.NavTabbingCounter = 0;
11683|  55.4k|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11684|       |
11685|       |    // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
11686|  55.4k|    bool set_mouse_pos = false;
11687|  55.4k|    if (g.NavMousePosDirty && g.NavIdIsAlive)
  ------------------
  |  Branch (11687:9): [True: 934, False: 54.4k]
  |  Branch (11687:31): [True: 13, False: 921]
  ------------------
11688|     13|        if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
  ------------------
  |  Branch (11688:13): [True: 13, False: 0]
  |  Branch (11688:39): [True: 12, False: 1]
  |  Branch (11688:65): [True: 12, False: 0]
  ------------------
11689|     12|            set_mouse_pos = true;
11690|  55.4k|    g.NavMousePosDirty = false;
11691|  55.4k|    IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11692|       |
11693|       |    // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
11694|  55.4k|    if (g.NavWindow)
  ------------------
  |  Branch (11694:9): [True: 7.30k, False: 48.1k]
  ------------------
11695|  7.30k|        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
11696|  55.4k|    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (11696:9): [True: 7.30k, False: 48.1k]
  |  Branch (11696:24): [True: 123, False: 7.18k]
  |  Branch (11696:70): [True: 10, False: 113]
  ------------------
11697|     10|        g.NavWindow->NavLastChildNavWindow = NULL;
11698|       |
11699|       |    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
11700|  55.4k|    NavUpdateWindowing();
11701|       |
11702|       |    // Set output flags for user application
11703|  55.4k|    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
  ------------------
  |  Branch (11703:21): [True: 55.4k, False: 0]
  |  Branch (11703:44): [True: 0, False: 0]
  |  Branch (11703:67): [True: 7.83k, False: 47.5k]
  |  Branch (11703:82): [True: 7.83k, False: 0]
  ------------------
11704|  55.4k|    io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);
  ------------------
  |  Branch (11704:22): [True: 7.83k, False: 47.5k]
  |  Branch (11704:38): [True: 3.66k, False: 4.16k]
  |  Branch (11704:54): [True: 3.44k, False: 216]
  |  Branch (11704:81): [True: 12.6k, False: 39.3k]
  ------------------
11705|       |
11706|       |    // Process NavCancel input (to close a popup, get back to parent, clear focus)
11707|  55.4k|    NavUpdateCancelRequest();
11708|       |
11709|       |    // Process manual activation request
11710|  55.4k|    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavActivateInputId = 0;
11711|  55.4k|    g.NavActivateFlags = ImGuiActivateFlags_None;
11712|  55.4k|    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11712:9): [True: 3.67k, False: 51.7k]
  |  Branch (11712:25): [True: 3.45k, False: 216]
  |  Branch (11712:51): [True: 3.17k, False: 282]
  |  Branch (11712:76): [True: 3.17k, False: 0]
  |  Branch (11712:91): [True: 3.17k, False: 0]
  ------------------
11713|  3.17k|    {
11714|  3.17k|        const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate));
  ------------------
  |  | 1252|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  |  Branch (11714:37): [True: 3.17k, False: 0]
  |  Branch (11714:60): [True: 0, False: 3.17k]
  |  Branch (11714:91): [True: 0, False: 3.17k]
  |  Branch (11714:113): [True: 0, False: 0]
  ------------------
11715|  3.17k|        const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, false)));
  ------------------
  |  | 1252|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  |  Branch (11715:39): [True: 0, False: 3.17k]
  |  Branch (11715:58): [True: 0, False: 0]
  |  Branch (11715:81): [True: 0, False: 0]
  |  Branch (11715:122): [True: 0, False: 0]
  |  Branch (11715:144): [True: 0, False: 0]
  ------------------
11716|  3.17k|        const bool input_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Enter)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput));
  ------------------
  |  | 1255|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
  |  Branch (11716:34): [True: 3.17k, False: 0]
  |  Branch (11716:57): [True: 18, False: 3.15k]
  |  Branch (11716:88): [True: 0, False: 3.15k]
  |  Branch (11716:110): [True: 0, False: 0]
  ------------------
11717|  3.17k|        const bool input_pressed = input_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Enter, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, false)));
  ------------------
  |  | 1255|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
  |  Branch (11717:36): [True: 18, False: 3.15k]
  |  Branch (11717:52): [True: 18, False: 0]
  |  Branch (11717:75): [True: 3, False: 15]
  |  Branch (11717:116): [True: 0, False: 15]
  |  Branch (11717:138): [True: 0, False: 0]
  ------------------
11718|  3.17k|        if (g.ActiveId == 0 && activate_pressed)
  ------------------
  |  Branch (11718:13): [True: 3.16k, False: 11]
  |  Branch (11718:32): [True: 0, False: 3.16k]
  ------------------
11719|      0|        {
11720|      0|            g.NavActivateId = g.NavId;
11721|      0|            g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
11722|      0|        }
11723|  3.17k|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed)
  ------------------
  |  Branch (11723:14): [True: 3.16k, False: 11]
  |  Branch (11723:33): [True: 11, False: 0]
  |  Branch (11723:59): [True: 3, False: 3.17k]
  ------------------
11724|      3|        {
11725|      3|            g.NavActivateInputId = g.NavId;
11726|      3|            g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
11727|      3|        }
11728|  3.17k|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
  ------------------
  |  Branch (11728:14): [True: 3.16k, False: 11]
  |  Branch (11728:33): [True: 11, False: 0]
  |  Branch (11728:59): [True: 0, False: 3.17k]
  ------------------
11729|      0|            g.NavActivateDownId = g.NavId;
11730|  3.17k|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
  ------------------
  |  Branch (11730:14): [True: 3.16k, False: 11]
  |  Branch (11730:33): [True: 11, False: 0]
  |  Branch (11730:59): [True: 0, False: 3.17k]
  ------------------
11731|      0|            g.NavActivatePressedId = g.NavId;
11732|  3.17k|    }
11733|  55.4k|    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11733:9): [True: 7.83k, False: 47.5k]
  |  Branch (11733:24): [True: 0, False: 7.83k]
  ------------------
11734|      0|        g.NavDisableHighlight = true;
11735|  55.4k|    if (g.NavActivateId != 0)
  ------------------
  |  Branch (11735:9): [True: 0, False: 55.4k]
  ------------------
11736|  55.4k|        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11737|       |
11738|       |    // Process programmatic activation request
11739|       |    // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
11740|  55.4k|    if (g.NavNextActivateId != 0)
  ------------------
  |  Branch (11740:9): [True: 0, False: 55.4k]
  ------------------
11741|      0|    {
11742|      0|        if (g.NavNextActivateFlags & ImGuiActivateFlags_PreferInput)
  ------------------
  |  Branch (11742:13): [True: 0, False: 0]
  ------------------
11743|      0|            g.NavActivateInputId = g.NavNextActivateId;
11744|      0|        else
11745|      0|            g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
11746|      0|        g.NavActivateFlags = g.NavNextActivateFlags;
11747|      0|    }
11748|  55.4k|    g.NavNextActivateId = 0;
11749|       |
11750|       |    // Process move requests
11751|  55.4k|    NavUpdateCreateMoveRequest();
11752|  55.4k|    if (g.NavMoveDir == ImGuiDir_None)
  ------------------
  |  Branch (11752:9): [True: 55.2k, False: 113]
  ------------------
11753|  55.2k|        NavUpdateCreateTabbingRequest();
11754|  55.4k|    NavUpdateAnyRequestFlag();
11755|  55.4k|    g.NavIdIsAlive = false;
11756|       |
11757|       |    // Scrolling
11758|  55.4k|    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
  ------------------
  |  Branch (11758:9): [True: 7.83k, False: 47.5k]
  |  Branch (11758:24): [True: 7.83k, False: 0]
  |  Branch (11758:80): [True: 7.31k, False: 512]
  ------------------
11759|  7.31k|    {
11760|       |        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
11761|  7.31k|        ImGuiWindow* window = g.NavWindow;
11762|  7.31k|        const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
  ------------------
  |  |  267|  7.31k|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
11763|  7.31k|        const ImGuiDir move_dir = g.NavMoveDir;
11764|  7.31k|        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll && move_dir != ImGuiDir_None)
  ------------------
  |  Branch (11764:13): [True: 3.92k, False: 3.39k]
  |  Branch (11764:55): [True: 3.15k, False: 773]
  |  Branch (11764:82): [True: 41, False: 3.11k]
  ------------------
11765|     41|        {
11766|     41|            if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
  ------------------
  |  Branch (11766:17): [True: 25, False: 16]
  |  Branch (11766:46): [True: 4, False: 12]
  ------------------
11767|     29|                SetScrollX(window, ImFloor(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (11767:64): [True: 25, False: 4]
  ------------------
11768|     41|            if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
  ------------------
  |  Branch (11768:17): [True: 2, False: 39]
  |  Branch (11768:44): [True: 10, False: 29]
  ------------------
11769|     12|                SetScrollY(window, ImFloor(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (11769:64): [True: 2, False: 10]
  ------------------
11770|     41|        }
11771|       |
11772|       |        // *Normal* Manual scroll with LStick
11773|       |        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
11774|  7.31k|        if (nav_gamepad_active)
  ------------------
  |  Branch (11774:13): [True: 0, False: 7.31k]
  ------------------
11775|      0|        {
11776|      0|            const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
11777|      0|            const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1250|      0|#define ImGuiKey_NavGamepadTweakSlow    ImGuiKey_GamepadL1
  ------------------
                          const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1251|      0|#define ImGuiKey_NavGamepadTweakFast    ImGuiKey_GamepadR1
  ------------------
  |  Branch (11777:40): [True: 0, False: 0]
  |  Branch (11777:97): [True: 0, False: 0]
  ------------------
11778|      0|            if (scroll_dir.x != 0.0f && window->ScrollbarX)
  ------------------
  |  Branch (11778:17): [True: 0, False: 0]
  |  Branch (11778:41): [True: 0, False: 0]
  ------------------
11779|      0|                SetScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
11780|      0|            if (scroll_dir.y != 0.0f)
  ------------------
  |  Branch (11780:17): [True: 0, False: 0]
  ------------------
11781|      0|                SetScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
11782|      0|        }
11783|  7.31k|    }
11784|       |
11785|       |    // Always prioritize mouse highlight if navigation is disabled
11786|  55.4k|    if (!nav_keyboard_active && !nav_gamepad_active)
  ------------------
  |  Branch (11786:9): [True: 0, False: 55.4k]
  |  Branch (11786:33): [True: 0, False: 0]
  ------------------
11787|      0|    {
11788|      0|        g.NavDisableHighlight = true;
11789|      0|        g.NavDisableMouseHover = set_mouse_pos = false;
11790|      0|    }
11791|       |
11792|       |    // Update mouse position if requested
11793|       |    // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
11794|  55.4k|    if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
  ------------------
  |  Branch (11794:9): [True: 12, False: 55.3k]
  |  Branch (11794:26): [True: 0, False: 12]
  |  Branch (11794:86): [True: 0, False: 0]
  ------------------
11795|      0|    {
11796|      0|        io.MousePos = io.MousePosPrev = NavCalcPreferredRefPos();
11797|      0|        io.WantSetMousePos = true;
11798|       |        //IMGUI_DEBUG_LOG_IO("SetMousePos: (%.1f,%.1f)\n", io.MousePos.x, io.MousePos.y);
11799|      0|    }
11800|       |
11801|       |    // [DEBUG]
11802|  55.4k|    g.NavScoringDebugCount = 0;
11803|       |#if IMGUI_DEBUG_NAV_RECTS
11804|       |    if (g.NavWindow)
11805|       |    {
11806|       |        ImDrawList* draw_list = GetForegroundDrawList(g.NavWindow);
11807|       |        if (1) { for (int layer = 0; layer < 2; layer++) { ImRect r = WindowRectRelToAbs(g.NavWindow, g.NavWindow->NavRectRel[layer]); draw_list->AddRect(r.Min, r.Max, IM_COL32(255,200,0,255)); } } // [DEBUG]
11808|       |        if (1) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
11809|       |    }
11810|       |#endif
11811|  55.4k|}
imgui.cpp:_ZN5ImGuiL35NavSaveLastChildNavWindowIntoParentEP11ImGuiWindow:
11506|  7.30k|{
11507|  7.30k|    ImGuiWindow* parent = nav_window;
11508|  11.1k|    while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (11508:12): [True: 11.1k, False: 0]
  |  Branch (11508:22): [True: 3.84k, False: 7.30k]
  |  Branch (11508:54): [True: 3.84k, False: 0]
  ------------------
11509|  3.84k|        parent = parent->ParentWindow;
11510|  7.30k|    if (parent && parent != nav_window)
  ------------------
  |  Branch (11510:9): [True: 7.30k, False: 0]
  |  Branch (11510:19): [True: 3.84k, False: 3.45k]
  ------------------
11511|  3.84k|        parent->NavLastChildNavWindow = nav_window;
11512|  7.30k|}
imgui.cpp:_ZN5ImGuiL18NavUpdateWindowingEv:
12294|  55.4k|{
12295|  55.4k|    ImGuiContext& g = *GImGui;
12296|  55.4k|    ImGuiIO& io = g.IO;
12297|       |
12298|  55.4k|    ImGuiWindow* apply_focus_window = NULL;
12299|  55.4k|    bool apply_toggle_layer = false;
12300|       |
12301|  55.4k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
12302|  55.4k|    bool allow_windowing = (modal_window == NULL);
12303|  55.4k|    if (!allow_windowing)
  ------------------
  |  Branch (12303:9): [True: 0, False: 55.4k]
  ------------------
12304|      0|        g.NavWindowingTarget = NULL;
12305|       |
12306|       |    // Fade out
12307|  55.4k|    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
  ------------------
  |  Branch (12307:9): [True: 14.1k, False: 41.2k]
  |  Branch (12307:37): [True: 1.26k, False: 12.9k]
  ------------------
12308|  1.26k|    {
12309|  1.26k|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
12310|  1.26k|        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (12310:13): [True: 579, False: 683]
  |  Branch (12310:37): [True: 500, False: 79]
  ------------------
12311|    500|            g.NavWindowingTargetAnim = NULL;
12312|  1.26k|    }
12313|       |
12314|       |    // Start CTRL+Tab or Square+L/R window selection
12315|  55.4k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12315:37): [True: 55.4k, False: 0]
  |  Branch (12315:98): [True: 0, False: 55.4k]
  ------------------
12316|  55.4k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12317|  55.4k|    const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
  ------------------
  |  | 1312|  55.4k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12317:39): [True: 55.4k, False: 0]
  |  Branch (12317:58): [True: 55.4k, False: 0]
  |  Branch (12317:89): [True: 3.03k, False: 52.3k]
  ------------------
12318|  55.4k|    const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
  ------------------
  |  | 1312|  55.4k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12318:39): [True: 55.4k, False: 0]
  |  Branch (12318:58): [True: 55.4k, False: 0]
  |  Branch (12318:89): [True: 50, False: 55.3k]
  ------------------
12319|  55.4k|    const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, 0, ImGuiInputFlags_None);
  ------------------
  |  | 1254|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (12319:47): [True: 55.4k, False: 0]
  |  Branch (12319:66): [True: 0, False: 55.4k]
  |  Branch (12319:88): [True: 0, False: 0]
  |  Branch (12319:113): [True: 0, False: 0]
  ------------------
12320|  55.4k|    const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
  ------------------
  |  Branch (12320:48): [True: 55.4k, False: 0]
  |  Branch (12320:67): [True: 42.4k, False: 12.9k]
  |  Branch (12320:93): [True: 476, False: 42.0k]
  |  Branch (12320:117): [True: 48, False: 41.9k]
  ------------------
12321|  55.4k|    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
  ------------------
  |  Branch (12321:9): [True: 0, False: 55.4k]
  |  Branch (12321:41): [True: 524, False: 54.8k]
  ------------------
12322|    524|        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
  ------------------
  |  Branch (12322:26): [True: 524, False: 0]
  ------------------
12323|    524|        {
12324|    524|            g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
12325|    524|            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
12326|    524|            g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
12327|    524|            g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
  ------------------
  |  Branch (12327:41): [True: 0, False: 524]
  ------------------
12328|    524|            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
  ------------------
  |  Branch (12328:32): [True: 524, False: 0]
  ------------------
12329|    524|        }
12330|       |
12331|       |    // Gamepad update
12332|  55.4k|    g.NavWindowingTimer += io.DeltaTime;
12333|  55.4k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (12333:9): [True: 13.4k, False: 41.9k]
  |  Branch (12333:33): [True: 0, False: 13.4k]
  ------------------
12334|      0|    {
12335|       |        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
12336|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
12337|       |
12338|       |        // Select window to focus
12339|      0|        const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
12340|      0|        if (focus_change_dir != 0)
  ------------------
  |  Branch (12340:13): [True: 0, False: 0]
  ------------------
12341|      0|        {
12342|      0|            NavUpdateWindowingHighlightWindow(focus_change_dir);
12343|      0|            g.NavWindowingHighlightAlpha = 1.0f;
12344|      0|        }
12345|       |
12346|       |        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
12347|      0|        if (!IsKeyDown(ImGuiKey_NavGamepadMenu))
  ------------------
  |  | 1254|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (12347:13): [True: 0, False: 0]
  ------------------
12348|      0|        {
12349|      0|            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
12350|      0|            if (g.NavWindowingToggleLayer && g.NavWindow)
  ------------------
  |  Branch (12350:17): [True: 0, False: 0]
  |  Branch (12350:46): [True: 0, False: 0]
  ------------------
12351|      0|                apply_toggle_layer = true;
12352|      0|            else if (!g.NavWindowingToggleLayer)
  ------------------
  |  Branch (12352:22): [True: 0, False: 0]
  ------------------
12353|      0|                apply_focus_window = g.NavWindowingTarget;
12354|      0|            g.NavWindowingTarget = NULL;
12355|      0|        }
12356|      0|    }
12357|       |
12358|       |    // Keyboard: Focus
12359|  55.4k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (12359:9): [True: 13.4k, False: 41.9k]
  |  Branch (12359:33): [True: 13.4k, False: 0]
  ------------------
12360|  13.4k|    {
12361|       |        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
12362|  13.4k|        ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
  ------------------
  |  Branch (12362:39): [True: 13.4k, False: 0]
  |  Branch (12362:118): [True: 13.4k, False: 0]
  ------------------
12363|  13.4k|        IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
  ------------------
  |  |   23|  13.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12364|  13.4k|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
12365|  13.4k|        if (keyboard_next_window || keyboard_prev_window)
  ------------------
  |  Branch (12365:13): [True: 3.03k, False: 10.3k]
  |  Branch (12365:37): [True: 50, False: 10.3k]
  ------------------
12366|  3.08k|            NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
  ------------------
  |  Branch (12366:47): [True: 3.03k, False: 50]
  ------------------
12367|  10.3k|        else if ((io.KeyMods & shared_mods) != shared_mods)
  ------------------
  |  Branch (12367:18): [True: 524, False: 9.82k]
  ------------------
12368|    524|            apply_focus_window = g.NavWindowingTarget;
12369|  13.4k|    }
12370|       |
12371|       |    // Keyboard: Press and Release ALT to toggle menu layer
12372|       |    // - Testing that only Alt is tested prevents Alt+Shift or AltGR from toggling menu layer.
12373|       |    // - AltGR is normally Alt+Ctrl but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl). But even on keyboards without AltGR we don't want Alt+Ctrl to open menu anyway.
12374|  55.4k|    if (nav_keyboard_active && IsKeyPressed(ImGuiMod_Alt, ImGuiKeyOwner_None))
  ------------------
  |  | 1312|  55.4k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12374:9): [True: 55.4k, False: 0]
  |  Branch (12374:32): [True: 44, False: 55.3k]
  ------------------
12375|     44|    {
12376|     44|        g.NavWindowingToggleLayer = true;
12377|     44|        g.NavInputSource = ImGuiInputSource_Keyboard;
12378|     44|    }
12379|  55.4k|    if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (12379:9): [True: 392, False: 55.0k]
  |  Branch (12379:38): [True: 392, False: 0]
  ------------------
12380|    392|    {
12381|       |        // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
12382|       |        // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
12383|       |        // We cancel toggling nav layer if an owner has claimed the key.
12384|    392|        if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_None) == false)
  ------------------
  |  | 1312|    389|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12384:13): [True: 0, False: 392]
  |  Branch (12384:49): [True: 3, False: 389]
  |  Branch (12384:63): [True: 0, False: 389]
  |  Branch (12384:78): [True: 0, False: 389]
  |  Branch (12384:93): [True: 0, False: 389]
  ------------------
12385|      3|            g.NavWindowingToggleLayer = false;
12386|       |
12387|       |        // Apply layer toggle on release
12388|       |        // Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
12389|    392|        if (IsKeyReleased(ImGuiMod_Alt) && g.NavWindowingToggleLayer)
  ------------------
  |  Branch (12389:13): [True: 0, False: 392]
  |  Branch (12389:44): [True: 0, False: 0]
  ------------------
12390|      0|            if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (12390:17): [True: 0, False: 0]
  |  Branch (12390:36): [True: 0, False: 0]
  ------------------
12391|      0|                if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (12391:21): [True: 0, False: 0]
  ------------------
12392|      0|                    apply_toggle_layer = true;
12393|    392|        if (!IsKeyDown(ImGuiMod_Alt))
  ------------------
  |  Branch (12393:13): [True: 32, False: 360]
  ------------------
12394|     32|            g.NavWindowingToggleLayer = false;
12395|    392|    }
12396|       |
12397|       |    // Move window
12398|  55.4k|    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (12398:9): [True: 13.4k, False: 41.9k]
  |  Branch (12398:33): [True: 13.4k, False: 0]
  ------------------
12399|  13.4k|    {
12400|  13.4k|        ImVec2 nav_move_dir;
12401|  13.4k|        if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
  ------------------
  |  Branch (12401:13): [True: 13.4k, False: 0]
  |  Branch (12401:62): [True: 13.2k, False: 171]
  ------------------
12402|  13.2k|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
12403|  13.4k|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (12403:13): [True: 0, False: 13.4k]
  ------------------
12404|      0|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
12405|  13.4k|        if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
  ------------------
  |  Branch (12405:13): [True: 13.1k, False: 304]
  |  Branch (12405:39): [True: 54, False: 250]
  ------------------
12406|  13.1k|        {
12407|  13.1k|            const float NAV_MOVE_SPEED = 800.0f;
12408|  13.1k|            const float move_step = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
12409|  13.1k|            g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
12410|  13.1k|            g.NavDisableMouseHover = true;
12411|  13.1k|            ImVec2 accum_floored = ImFloor(g.NavWindowingAccumDeltaPos);
12412|  13.1k|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (12412:17): [True: 2.34k, False: 10.8k]
  |  Branch (12412:44): [True: 10.8k, False: 0]
  ------------------
12413|  13.1k|            {
12414|  13.1k|                ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
12415|  13.1k|                SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
12416|  13.1k|                g.NavWindowingAccumDeltaPos -= accum_floored;
12417|  13.1k|            }
12418|  13.1k|        }
12419|  13.4k|    }
12420|       |
12421|       |    // Apply final focus
12422|  55.4k|    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
  ------------------
  |  Branch (12422:9): [True: 524, False: 54.8k]
  |  Branch (12422:32): [True: 524, False: 0]
  |  Branch (12422:55): [True: 0, False: 0]
  ------------------
12423|    524|    {
12424|    524|        ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
  ------------------
  |  Branch (12424:44): [True: 0, False: 524]
  ------------------
12425|    524|        ClearActiveID();
12426|    524|        NavRestoreHighlightAfterMove();
12427|    524|        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
12428|    524|        ClosePopupsOverWindow(apply_focus_window, false);
12429|    524|        FocusWindow(apply_focus_window);
12430|    524|        if (apply_focus_window->NavLastIds[0] == 0)
  ------------------
  |  Branch (12430:13): [True: 319, False: 205]
  ------------------
12431|    319|            NavInitWindow(apply_focus_window, false);
12432|       |
12433|       |        // If the window has ONLY a menu layer (no main layer), select it directly
12434|       |        // Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
12435|       |        // so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
12436|       |        // the target window as already been previewed once.
12437|       |        // FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
12438|       |        // we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
12439|       |        // won't be valid.
12440|    524|        if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
  ------------------
  |  Branch (12440:13): [True: 0, False: 524]
  ------------------
12441|      0|            g.NavLayer = ImGuiNavLayer_Menu;
12442|       |
12443|       |        // Request OS level focus
12444|    524|        if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
  ------------------
  |  Branch (12444:13): [True: 524, False: 0]
  |  Branch (12444:66): [True: 0, False: 524]
  ------------------
12445|      0|            g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
12446|    524|    }
12447|  55.4k|    if (apply_focus_window)
  ------------------
  |  Branch (12447:9): [True: 524, False: 54.8k]
  ------------------
12448|    524|        g.NavWindowingTarget = NULL;
12449|       |
12450|       |    // Apply menu/layer toggle
12451|  55.4k|    if (apply_toggle_layer && g.NavWindow)
  ------------------
  |  Branch (12451:9): [True: 0, False: 55.4k]
  |  Branch (12451:31): [True: 0, False: 0]
  ------------------
12452|      0|    {
12453|      0|        ClearActiveID();
12454|       |
12455|       |        // Move to parent menu if necessary
12456|      0|        ImGuiWindow* new_nav_window = g.NavWindow;
12457|      0|        while (new_nav_window->ParentWindow
  ------------------
  |  Branch (12457:16): [True: 0, False: 0]
  ------------------
12458|      0|            && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
  ------------------
  |  Branch (12458:16): [True: 0, False: 0]
  ------------------
12459|      0|            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
  ------------------
  |  Branch (12459:16): [True: 0, False: 0]
  ------------------
12460|      0|            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (12460:16): [True: 0, False: 0]
  ------------------
12461|      0|            new_nav_window = new_nav_window->ParentWindow;
12462|      0|        if (new_nav_window != g.NavWindow)
  ------------------
  |  Branch (12462:13): [True: 0, False: 0]
  ------------------
12463|      0|        {
12464|      0|            ImGuiWindow* old_nav_window = g.NavWindow;
12465|      0|            FocusWindow(new_nav_window);
12466|      0|            new_nav_window->NavLastChildNavWindow = old_nav_window;
12467|      0|        }
12468|       |
12469|       |        // Toggle layer
12470|      0|        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
  ------------------
  |  Branch (12470:45): [True: 0, False: 0]
  ------------------
12471|      0|        if (new_nav_layer != g.NavLayer)
  ------------------
  |  Branch (12471:13): [True: 0, False: 0]
  ------------------
12472|      0|        {
12473|       |            // Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
12474|      0|            const bool preserve_layer_1_nav_id = (new_nav_window->DockNodeAsHost != NULL);
12475|      0|            if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id)
  ------------------
  |  Branch (12475:17): [True: 0, False: 0]
  |  Branch (12475:56): [True: 0, False: 0]
  ------------------
12476|      0|                g.NavWindow->NavLastIds[new_nav_layer] = 0;
12477|      0|            NavRestoreLayer(new_nav_layer);
12478|      0|            NavRestoreHighlightAfterMove();
12479|      0|        }
12480|      0|    }
12481|  55.4k|}
imgui.cpp:_ZL22FindWindowNavFocusableiii:
12263|  6.60k|{
12264|  6.60k|    ImGuiContext& g = *GImGui;
12265|  12.6k|    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
  ------------------
  |  Branch (12265:27): [True: 9.63k, False: 3.03k]
  |  Branch (12265:37): [True: 9.58k, False: 50]
  |  Branch (12265:69): [True: 6.49k, False: 3.08k]
  ------------------
12266|  6.49k|        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
  ------------------
  |  Branch (12266:13): [True: 436, False: 6.06k]
  ------------------
12267|    436|            return g.WindowsFocusOrder[i];
12268|  6.17k|    return NULL;
12269|  6.60k|}
imgui.cpp:_ZL33NavUpdateWindowingHighlightWindowi:
12272|  3.08k|{
12273|  3.08k|    ImGuiContext& g = *GImGui;
12274|  3.08k|    IM_ASSERT(g.NavWindowingTarget);
  ------------------
  |  |   23|  3.08k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12275|  3.08k|    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (12275:9): [True: 0, False: 3.08k]
  ------------------
12276|      0|        return;
12277|       |
12278|  3.08k|    const int i_current = ImGui::FindWindowFocusIndex(g.NavWindowingTarget);
12279|  3.08k|    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
12280|  3.08k|    if (!window_target)
  ------------------
  |  Branch (12280:9): [True: 3.08k, False: 0]
  ------------------
12281|  3.08k|        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
  ------------------
  |  Branch (12281:48): [True: 3.03k, False: 50]
  ------------------
12282|  3.08k|    if (window_target) // Don't reset windowing target if there's a single window in the list
  ------------------
  |  Branch (12282:9): [True: 0, False: 3.08k]
  ------------------
12283|      0|    {
12284|      0|        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
12285|      0|        g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
12286|      0|    }
12287|  3.08k|    g.NavWindowingToggleLayer = false;
12288|  3.08k|}
imgui.cpp:_ZN5ImGuiL22NavUpdateCancelRequestEv:
12060|  55.4k|{
12061|  55.4k|    ImGuiContext& g = *GImGui;
12062|  55.4k|    const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12062:37): [True: 55.4k, False: 0]
  |  Branch (12062:100): [True: 0, False: 55.4k]
  ------------------
12063|  55.4k|    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12064|  55.4k|    if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1312|  55.4k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1253|      0|#define ImGuiKey_NavGamepadCancel       ImGuiKey_GamepadFaceRight
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12064:11): [True: 55.4k, False: 0]
  |  Branch (12064:34): [True: 58, False: 55.3k]
  |  Branch (12064:90): [True: 0, False: 55.3k]
  |  Branch (12064:112): [True: 0, False: 0]
  ------------------
12065|  55.3k|        return;
12066|       |
12067|     58|    IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
  ------------------
  |  |  229|     58|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 58]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12068|     58|    if (g.ActiveId != 0)
  ------------------
  |  Branch (12068:9): [True: 0, False: 58]
  ------------------
12069|      0|    {
12070|      0|        ClearActiveID();
12071|      0|    }
12072|     58|    else if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (12072:14): [True: 0, False: 58]
  ------------------
12073|      0|    {
12074|       |        // Leave the "menu" layer
12075|      0|        NavRestoreLayer(ImGuiNavLayer_Main);
12076|      0|        NavRestoreHighlightAfterMove();
12077|      0|    }
12078|     58|    else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
  ------------------
  |  Branch (12078:14): [True: 8, False: 50]
  |  Branch (12078:29): [True: 8, False: 0]
  |  Branch (12078:71): [True: 8, False: 0]
  |  Branch (12078:121): [True: 8, False: 0]
  ------------------
12079|      8|    {
12080|       |        // Exit child window
12081|      8|        ImGuiWindow* child_window = g.NavWindow;
12082|      8|        ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
12083|      8|        IM_ASSERT(child_window->ChildId != 0);
  ------------------
  |  |   23|      8|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12084|      8|        ImRect child_rect = child_window->Rect();
12085|      8|        FocusWindow(parent_window);
12086|      8|        SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_rect));
12087|      8|        NavRestoreHighlightAfterMove();
12088|      8|    }
12089|     50|    else if (g.OpenPopupStack.Size > 0 && g.OpenPopupStack.back().Window != NULL && !(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
  ------------------
  |  Branch (12089:14): [True: 0, False: 50]
  |  Branch (12089:43): [True: 0, False: 0]
  |  Branch (12089:85): [True: 0, False: 0]
  ------------------
12090|      0|    {
12091|       |        // Close open popup/menu
12092|      0|        ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
12093|      0|    }
12094|     50|    else
12095|     50|    {
12096|       |        // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
12097|     50|        if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
  ------------------
  |  Branch (12097:13): [True: 0, False: 50]
  |  Branch (12097:29): [True: 0, False: 0]
  |  Branch (12097:78): [True: 0, False: 0]
  ------------------
12098|      0|            g.NavWindow->NavLastIds[0] = 0;
12099|     50|        g.NavId = 0;
12100|     50|    }
12101|     58|}
imgui.cpp:_ZN5ImGuiL26NavUpdateCreateMoveRequestEv:
11830|  55.4k|{
11831|  55.4k|    ImGuiContext& g = *GImGui;
11832|  55.4k|    ImGuiIO& io = g.IO;
11833|  55.4k|    ImGuiWindow* window = g.NavWindow;
11834|  55.4k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (11834:37): [True: 55.4k, False: 0]
  |  Branch (11834:98): [True: 0, False: 55.4k]
  ------------------
11835|  55.4k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
11836|       |
11837|  55.4k|    if (g.NavMoveForwardToNextFrame && window != NULL)
  ------------------
  |  Branch (11837:9): [True: 0, False: 55.4k]
  |  Branch (11837:40): [True: 0, False: 0]
  ------------------
11838|      0|    {
11839|       |        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
11840|       |        // (preserve most state, which were already set by the NavMoveRequestForward() function)
11841|      0|        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11842|      0|        IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11843|      0|        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
  ------------------
  |  |  229|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 0]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11844|      0|    }
11845|  55.4k|    else
11846|  55.4k|    {
11847|       |        // Initiate directional inputs request
11848|  55.4k|        g.NavMoveDir = ImGuiDir_None;
11849|  55.4k|        g.NavMoveFlags = ImGuiNavMoveFlags_None;
11850|  55.4k|        g.NavMoveScrollFlags = ImGuiScrollFlags_None;
11851|  55.4k|        if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11851:13): [True: 7.83k, False: 47.5k]
  |  Branch (11851:23): [True: 7.31k, False: 512]
  |  Branch (11851:48): [True: 7.31k, False: 0]
  ------------------
11852|  7.31k|        {
11853|  7.31k|            const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateNavMove;
11854|  7.31k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1312|  7.30k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11854:17): [True: 7.30k, False: 9]
  |  Branch (11854:61): [True: 0, False: 7.30k]
  |  Branch (11854:83): [True: 0, False: 0]
  |  Branch (11854:161): [True: 7.30k, False: 0]
  |  Branch (11854:184): [True: 53, False: 7.25k]
  ------------------
11855|  7.31k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1312|  7.30k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11855:17): [True: 7.30k, False: 9]
  |  Branch (11855:61): [True: 0, False: 7.30k]
  |  Branch (11855:83): [True: 0, False: 0]
  |  Branch (11855:161): [True: 7.30k, False: 0]
  |  Branch (11855:184): [True: 11, False: 7.29k]
  ------------------
11856|  7.31k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1312|  7.30k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11856:17): [True: 7.30k, False: 9]
  |  Branch (11856:61): [True: 0, False: 7.30k]
  |  Branch (11856:83): [True: 0, False: 0]
  |  Branch (11856:161): [True: 7.30k, False: 0]
  |  Branch (11856:184): [True: 5, False: 7.30k]
  ------------------
11857|  7.31k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1312|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1312|  7.30k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11857:17): [True: 7.30k, False: 9]
  |  Branch (11857:61): [True: 0, False: 7.30k]
  |  Branch (11857:83): [True: 0, False: 0]
  |  Branch (11857:161): [True: 7.30k, False: 0]
  |  Branch (11857:184): [True: 21, False: 7.28k]
  ------------------
11858|  7.31k|        }
11859|  55.4k|        g.NavMoveClipDir = g.NavMoveDir;
11860|  55.4k|        g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
11861|  55.4k|    }
11862|       |
11863|       |    // Update PageUp/PageDown/Home/End scroll
11864|       |    // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
11865|  55.4k|    float scoring_rect_offset_y = 0.0f;
11866|  55.4k|    if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
  ------------------
  |  Branch (11866:9): [True: 7.83k, False: 47.5k]
  |  Branch (11866:19): [True: 7.74k, False: 90]
  |  Branch (11866:52): [True: 7.74k, False: 0]
  ------------------
11867|  7.74k|        scoring_rect_offset_y = NavUpdatePageUpPageDown();
11868|  55.4k|    if (scoring_rect_offset_y != 0.0f)
  ------------------
  |  Branch (11868:9): [True: 0, False: 55.4k]
  ------------------
11869|      0|    {
11870|      0|        g.NavScoringNoClipRect = window->InnerRect;
11871|      0|        g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
11872|      0|    }
11873|       |
11874|       |    // [DEBUG] Always send a request
11875|       |#if IMGUI_DEBUG_NAV_SCORING
11876|       |    if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
11877|       |        g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
11878|       |    if (io.KeyCtrl && g.NavMoveDir == ImGuiDir_None)
11879|       |    {
11880|       |        g.NavMoveDir = g.NavMoveDirForDebug;
11881|       |        g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
11882|       |    }
11883|       |#endif
11884|       |
11885|       |    // Submit
11886|  55.4k|    g.NavMoveForwardToNextFrame = false;
11887|  55.4k|    if (g.NavMoveDir != ImGuiDir_None)
  ------------------
  |  Branch (11887:9): [True: 113, False: 55.2k]
  ------------------
11888|    113|        NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
11889|       |
11890|       |    // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
11891|  55.4k|    if (g.NavMoveSubmitted && g.NavId == 0)
  ------------------
  |  Branch (11891:9): [True: 113, False: 55.2k]
  |  Branch (11891:31): [True: 74, False: 39]
  ------------------
11892|     74|    {
11893|     74|        IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
  ------------------
  |  |  229|     74|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (222:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 74]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11894|     74|        g.NavInitRequest = g.NavInitRequestFromMove = true;
11895|     74|        g.NavInitResultId = 0;
11896|     74|        g.NavDisableHighlight = false;
11897|     74|    }
11898|       |
11899|       |    // When using gamepad, we project the reference nav bounding box into window visible area.
11900|       |    // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling, since with gamepad all movements are relative
11901|       |    // (can't focus a visible object like we can with the mouse).
11902|  55.4k|    if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != NULL)// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
  ------------------
  |  Branch (11902:9): [True: 113, False: 55.2k]
  |  Branch (11902:31): [True: 0, False: 113]
  |  Branch (11902:79): [True: 0, False: 0]
  |  Branch (11902:115): [True: 0, False: 0]
  ------------------
11903|      0|    {
11904|      0|        bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
11905|      0|        bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
11906|      0|        ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));
11907|      0|        if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
  ------------------
  |  Branch (11907:14): [True: 0, False: 0]
  |  Branch (11907:25): [True: 0, False: 0]
  |  Branch (11907:37): [True: 0, False: 0]
  ------------------
11908|      0|        {
11909|       |            //IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
11910|      0|            float pad_x = ImMin(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
11911|      0|            float pad_y = ImMin(inner_rect_rel.GetHeight(), window->CalcFontSize() * 0.5f); // Terrible approximation for the intent of starting navigation from first fully visible item
11912|      0|            inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX;
  ------------------
  |  Branch (11912:36): [True: 0, False: 0]
  ------------------
11913|      0|            inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX;
  ------------------
  |  Branch (11913:36): [True: 0, False: 0]
  ------------------
11914|      0|            inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
  ------------------
  |  Branch (11914:36): [True: 0, False: 0]
  ------------------
11915|      0|            inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
  ------------------
  |  Branch (11915:36): [True: 0, False: 0]
  ------------------
11916|      0|            window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
11917|      0|            g.NavId = 0;
11918|      0|        }
11919|      0|    }
11920|       |
11921|       |    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
11922|  55.4k|    ImRect scoring_rect;
11923|  55.4k|    if (window != NULL)
  ------------------
  |  Branch (11923:9): [True: 7.83k, False: 47.5k]
  ------------------
11924|  7.83k|    {
11925|  7.83k|        ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
  ------------------
  |  Branch (11925:31): [True: 7.83k, False: 0]
  ------------------
11926|  7.83k|        scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
11927|  7.83k|        scoring_rect.TranslateY(scoring_rect_offset_y);
11928|  7.83k|        scoring_rect.Min.x = ImMin(scoring_rect.Min.x + 1.0f, scoring_rect.Max.x);
11929|  7.83k|        scoring_rect.Max.x = scoring_rect.Min.x;
11930|  7.83k|        IM_ASSERT(!scoring_rect.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
  ------------------
  |  |   23|  7.83k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11931|       |        //GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
11932|       |        //if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
11933|  7.83k|    }
11934|  55.4k|    g.NavScoringRect = scoring_rect;
11935|  55.4k|    g.NavScoringNoClipRect.Add(scoring_rect);
11936|  55.4k|}
imgui.cpp:_ZN5ImGuiL23NavUpdatePageUpPageDownEv:
12108|  7.74k|{
12109|  7.74k|    ImGuiContext& g = *GImGui;
12110|  7.74k|    ImGuiWindow* window = g.NavWindow;
12111|  7.74k|    if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (12111:9): [True: 0, False: 7.74k]
  |  Branch (12111:59): [True: 512, False: 7.22k]
  ------------------
12112|    512|        return 0.0f;
12113|       |
12114|  7.22k|    const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ImGuiKeyOwner_None);
  ------------------
  |  | 1312|  7.22k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12115|  7.22k|    const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ImGuiKeyOwner_None);
  ------------------
  |  | 1312|  7.22k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12116|  7.22k|    const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
  ------------------
  |  | 1312|  7.22k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12117|  7.22k|    const bool end_pressed = IsKeyPressed(ImGuiKey_End, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
  ------------------
  |  | 1312|  7.22k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12118|  7.22k|    if (page_up_held == page_down_held && home_pressed == end_pressed) // Proceed if either (not both) are pressed, otherwise early out
  ------------------
  |  Branch (12118:9): [True: 7.01k, False: 216]
  |  Branch (12118:43): [True: 6.98k, False: 25]
  ------------------
12119|  6.98k|        return 0.0f;
12120|       |
12121|    241|    if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (12121:9): [True: 0, False: 241]
  ------------------
12122|      0|        NavRestoreLayer(ImGuiNavLayer_Main);
12123|       |
12124|    241|    if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll)
  ------------------
  |  Branch (12124:9): [True: 212, False: 29]
  |  Branch (12124:51): [True: 149, False: 63]
  ------------------
12125|    149|    {
12126|       |        // Fallback manual-scroll when window has no navigable item
12127|    149|        if (IsKeyPressed(ImGuiKey_PageUp, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat))
  ------------------
  |  | 1312|    149|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12127:13): [True: 5, False: 144]
  ------------------
12128|      5|            SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
12129|    144|        else if (IsKeyPressed(ImGuiKey_PageDown, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat))
  ------------------
  |  | 1312|    144|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12129:18): [True: 1, False: 143]
  ------------------
12130|      1|            SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
12131|    143|        else if (home_pressed)
  ------------------
  |  Branch (12131:18): [True: 1, False: 142]
  ------------------
12132|      1|            SetScrollY(window, 0.0f);
12133|    142|        else if (end_pressed)
  ------------------
  |  Branch (12133:18): [True: 4, False: 138]
  ------------------
12134|      4|            SetScrollY(window, window->ScrollMax.y);
12135|    149|    }
12136|     92|    else
12137|     92|    {
12138|     92|        ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
12139|     92|        const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
12140|     92|        float nav_scoring_rect_offset_y = 0.0f;
12141|     92|        if (IsKeyPressed(ImGuiKey_PageUp, true))
  ------------------
  |  Branch (12141:13): [True: 2, False: 90]
  ------------------
12142|      2|        {
12143|      2|            nav_scoring_rect_offset_y = -page_offset_y;
12144|      2|            g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
12145|      2|            g.NavMoveClipDir = ImGuiDir_Up;
12146|      2|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
12147|      2|        }
12148|     90|        else if (IsKeyPressed(ImGuiKey_PageDown, true))
  ------------------
  |  Branch (12148:18): [True: 1, False: 89]
  ------------------
12149|      1|        {
12150|      1|            nav_scoring_rect_offset_y = +page_offset_y;
12151|      1|            g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
12152|      1|            g.NavMoveClipDir = ImGuiDir_Down;
12153|      1|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
12154|      1|        }
12155|     89|        else if (home_pressed)
  ------------------
  |  Branch (12155:18): [True: 16, False: 73]
  ------------------
12156|     16|        {
12157|       |            // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
12158|       |            // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
12159|       |            // Preserve current horizontal position if we have any.
12160|     16|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
12161|     16|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (12161:17): [True: 0, False: 16]
  ------------------
12162|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
12163|     16|            g.NavMoveDir = ImGuiDir_Down;
12164|     16|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
12165|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
12166|     16|        }
12167|     73|        else if (end_pressed)
  ------------------
  |  Branch (12167:18): [True: 4, False: 69]
  ------------------
12168|      4|        {
12169|      4|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
12170|      4|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (12170:17): [True: 0, False: 4]
  ------------------
12171|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
12172|      4|            g.NavMoveDir = ImGuiDir_Up;
12173|      4|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
12174|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
12175|      4|        }
12176|     92|        return nav_scoring_rect_offset_y;
12177|     92|    }
12178|    149|    return 0.0f;
12179|    241|}
imgui.cpp:_ZN5ImGuiL29NavUpdateCreateTabbingRequestEv:
11939|  55.2k|{
11940|  55.2k|    ImGuiContext& g = *GImGui;
11941|  55.2k|    ImGuiWindow* window = g.NavWindow;
11942|  55.2k|    IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
  ------------------
  |  |   23|  55.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11943|  55.2k|    if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11943:9): [True: 47.5k, False: 7.71k]
  |  Branch (11943:27): [True: 512, False: 7.20k]
  |  Branch (11943:59): [True: 0, False: 7.20k]
  ------------------
11944|  48.0k|        return;
11945|       |
11946|  7.20k|    const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
  ------------------
  |  | 1312|  7.20k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11946:30): [True: 106, False: 7.09k]
  |  Branch (11946:104): [True: 106, False: 0]
  |  Branch (11946:121): [True: 98, False: 8]
  ------------------
11947|  7.20k|    if (!tab_pressed)
  ------------------
  |  Branch (11947:9): [True: 7.10k, False: 98]
  ------------------
11948|  7.10k|        return;
11949|       |
11950|       |    // Initiate tabbing request
11951|       |    // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
11952|       |    // Initially this was designed to use counters and modulo arithmetic, but that could not work with unsubmitted items (list clipper). Instead we use a strategy close to other move requests.
11953|       |    // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
11954|       |    //// FIXME: We use (g.ActiveId == 0) but (g.NavDisableHighlight == false) might be righter once we can tab through anything
11955|     98|    g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
  ------------------
  |  Branch (11955:23): [True: 6, False: 92]
  |  Branch (11955:44): [True: 91, False: 1]
  ------------------
11956|     98|    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
  ------------------
  |  Branch (11956:37): [True: 0, False: 98]
  ------------------
11957|     98|    ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
  ------------------
  |  Branch (11957:25): [True: 6, False: 92]
  ------------------
11958|     98|    NavMoveRequestSubmit(ImGuiDir_None, clip_dir, ImGuiNavMoveFlags_Tabbing, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
11959|     98|    g.NavTabbingCounter = -1;
11960|     98|}
imgui.cpp:_ZN5ImGuiL28NavRestoreHighlightAfterMoveEv:
11549|    567|{
11550|    567|    ImGuiContext& g = *GImGui;
11551|    567|    g.NavDisableHighlight = false;
11552|    567|    g.NavDisableMouseHover = g.NavMousePosDirty = true;
11553|    567|}
imgui.cpp:_ZN5ImGuiL11NavEndFrameEv:
12182|  55.4k|{
12183|  55.4k|    ImGuiContext& g = *GImGui;
12184|       |
12185|       |    // Show CTRL+TAB list window
12186|  55.4k|    if (g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (12186:9): [True: 12.9k, False: 42.4k]
  ------------------
12187|  12.9k|        NavUpdateWindowingOverlay();
12188|       |
12189|       |    // Perform wrap-around in menus
12190|       |    // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
12191|       |    // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
12192|  55.4k|    const ImGuiNavMoveFlags wanted_flags = ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY;
12193|  55.4k|    if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & wanted_flags) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
  ------------------
  |  Branch (12193:9): [True: 9.25k, False: 46.1k]
  |  Branch (12193:24): [True: 211, False: 9.04k]
  |  Branch (12193:58): [True: 0, False: 211]
  |  Branch (12193:93): [True: 0, False: 0]
  ------------------
12194|      0|        NavUpdateCreateWrappingRequest();
12195|  55.4k|}
imgui.cpp:_ZN5ImGuiL25NavUpdateWindowingOverlayEv:
12497|  12.9k|{
12498|  12.9k|    ImGuiContext& g = *GImGui;
12499|  12.9k|    IM_ASSERT(g.NavWindowingTarget != NULL);
  ------------------
  |  |   23|  12.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12500|       |
12501|  12.9k|    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
  ------------------
  |  Branch (12501:9): [True: 2.61k, False: 10.2k]
  ------------------
12502|  2.61k|        return;
12503|       |
12504|  10.2k|    if (g.NavWindowingListWindow == NULL)
  ------------------
  |  Branch (12504:9): [True: 2, False: 10.2k]
  ------------------
12505|      2|        g.NavWindowingListWindow = FindWindowByName("###NavWindowingList");
12506|  10.2k|    const ImGuiViewport* viewport = /*g.NavWindow ? g.NavWindow->Viewport :*/ GetMainViewport();
12507|  10.2k|    SetNextWindowSizeConstraints(ImVec2(viewport->Size.x * 0.20f, viewport->Size.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
12508|  10.2k|    SetNextWindowPos(viewport->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
12509|  10.2k|    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
12510|  10.2k|    Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
12511|  41.1k|    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (12511:48): [True: 30.8k, False: 10.2k]
  ------------------
12512|  30.8k|    {
12513|  30.8k|        ImGuiWindow* window = g.WindowsFocusOrder[n];
12514|  30.8k|        IM_ASSERT(window != NULL); // Fix static analyzers
  ------------------
  |  |   23|  30.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12515|  30.8k|        if (!IsWindowNavFocusable(window))
  ------------------
  |  Branch (12515:13): [True: 20.5k, False: 10.2k]
  ------------------
12516|  20.5k|            continue;
12517|  10.2k|        const char* label = window->Name;
12518|  10.2k|        if (label == FindRenderedTextEnd(label))
  ------------------
  |  Branch (12518:13): [True: 0, False: 10.2k]
  ------------------
12519|      0|            label = GetFallbackWindowNameForWindowingList(window);
12520|  10.2k|        Selectable(label, g.NavWindowingTarget == window);
12521|  10.2k|    }
12522|  10.2k|    End();
12523|  10.2k|    PopStyleVar();
12524|  10.2k|}
imgui.cpp:_ZN5ImGuiL20FindWindowFocusIndexEP11ImGuiWindow:
12253|  3.08k|{
12254|  3.08k|    ImGuiContext& g = *GImGui;
12255|  3.08k|    IM_UNUSED(g);
  ------------------
  |  |   88|  3.08k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
12256|  3.08k|    int order = window->FocusOrder;
12257|  3.08k|    IM_ASSERT(window->RootWindow == window); // No child window (not testing _ChildWindow because of docking)
  ------------------
  |  |   23|  3.08k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12258|  3.08k|    IM_ASSERT(g.WindowsFocusOrder[order] == window);
  ------------------
  |  |   23|  3.08k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12259|  3.08k|    return order;
12260|  3.08k|}
imgui.cpp:_ZN5ImGuiL14UpdateSettingsEv:
13116|  55.4k|{
13117|       |    // Load settings on first frame (if not explicitly loaded manually before)
13118|  55.4k|    ImGuiContext& g = *GImGui;
13119|  55.4k|    if (!g.SettingsLoaded)
  ------------------
  |  Branch (13119:9): [True: 1, False: 55.4k]
  ------------------
13120|      1|    {
13121|      1|        IM_ASSERT(g.SettingsWindows.empty());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13122|      1|        if (g.IO.IniFilename)
  ------------------
  |  Branch (13122:13): [True: 0, False: 1]
  ------------------
13123|      0|            LoadIniSettingsFromDisk(g.IO.IniFilename);
13124|      1|        g.SettingsLoaded = true;
13125|      1|    }
13126|       |
13127|       |    // Save settings (with a delay after the last modification, so we don't spam disk too much)
13128|  55.4k|    if (g.SettingsDirtyTimer > 0.0f)
  ------------------
  |  Branch (13128:9): [True: 38.4k, False: 16.9k]
  ------------------
13129|  38.4k|    {
13130|  38.4k|        g.SettingsDirtyTimer -= g.IO.DeltaTime;
13131|  38.4k|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (13131:13): [True: 128, False: 38.3k]
  ------------------
13132|    128|        {
13133|    128|            if (g.IO.IniFilename != NULL)
  ------------------
  |  Branch (13133:17): [True: 0, False: 128]
  ------------------
13134|      0|                SaveIniSettingsToDisk(g.IO.IniFilename);
13135|    128|            else
13136|    128|                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
13137|    128|            g.SettingsDirtyTimer = 0.0f;
13138|    128|        }
13139|  38.4k|    }
13140|  55.4k|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsNewFrameEv:
13658|  55.4k|{
13659|  55.4k|    ImGuiContext& g = *GImGui;
13660|  55.4k|    IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13661|       |
13662|       |    // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
13663|  55.4k|    const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
13664|  55.4k|    if (viewports_enabled)
  ------------------
  |  Branch (13664:9): [True: 0, False: 55.4k]
  ------------------
13665|      0|    {
13666|      0|        for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (13666:25): [True: 0, False: 0]
  ------------------
13667|      0|        {
13668|      0|            ImGuiViewportP* viewport = g.Viewports[n];
13669|      0|            const bool platform_funcs_available = viewport->PlatformWindowCreated;
13670|      0|            if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
  ------------------
  |  Branch (13670:17): [True: 0, False: 0]
  |  Branch (13670:61): [True: 0, False: 0]
  ------------------
13671|      0|            {
13672|      0|                bool minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
13673|      0|                if (minimized)
  ------------------
  |  Branch (13673:21): [True: 0, False: 0]
  ------------------
13674|      0|                    viewport->Flags |= ImGuiViewportFlags_Minimized;
13675|      0|                else
13676|      0|                    viewport->Flags &= ~ImGuiViewportFlags_Minimized;
13677|      0|            }
13678|      0|        }
13679|      0|    }
13680|       |
13681|       |    // Create/update main viewport with current platform position.
13682|       |    // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
13683|  55.4k|    ImGuiViewportP* main_viewport = g.Viewports[0];
13684|  55.4k|    IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13685|  55.4k|    IM_ASSERT(main_viewport->Window == NULL);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13686|  55.4k|    ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (13686:32): [True: 0, False: 55.4k]
  ------------------
13687|  55.4k|    ImVec2 main_viewport_size = g.IO.DisplaySize;
13688|  55.4k|    if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_Minimized))
  ------------------
  |  Branch (13688:9): [True: 0, False: 55.4k]
  |  Branch (13688:30): [True: 0, False: 0]
  ------------------
13689|      0|    {
13690|      0|        main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
13691|      0|        main_viewport_size = main_viewport->Size;
13692|      0|    }
13693|  55.4k|    AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);
13694|       |
13695|  55.4k|    g.CurrentDpiScale = 0.0f;
13696|  55.4k|    g.CurrentViewport = NULL;
13697|  55.4k|    g.MouseViewport = NULL;
13698|   110k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (13698:21): [True: 55.4k, False: 55.4k]
  ------------------
13699|  55.4k|    {
13700|  55.4k|        ImGuiViewportP* viewport = g.Viewports[n];
13701|  55.4k|        viewport->Idx = n;
13702|       |
13703|       |        // Erase unused viewports
13704|  55.4k|        if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
  ------------------
  |  Branch (13704:13): [True: 0, False: 55.4k]
  |  Branch (13704:22): [True: 0, False: 0]
  ------------------
13705|      0|        {
13706|      0|            DestroyViewport(viewport);
13707|      0|            n--;
13708|      0|            continue;
13709|      0|        }
13710|       |
13711|  55.4k|        const bool platform_funcs_available = viewport->PlatformWindowCreated;
13712|  55.4k|        if (viewports_enabled)
  ------------------
  |  Branch (13712:13): [True: 0, False: 55.4k]
  ------------------
13713|      0|        {
13714|       |            // Update Position and Size (from Platform Window to ImGui) if requested.
13715|       |            // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
13716|      0|            if (!(viewport->Flags & ImGuiViewportFlags_Minimized) && platform_funcs_available)
  ------------------
  |  Branch (13716:17): [True: 0, False: 0]
  |  Branch (13716:70): [True: 0, False: 0]
  ------------------
13717|      0|            {
13718|       |                // Viewport->WorkPos and WorkSize will be updated below
13719|      0|                if (viewport->PlatformRequestMove)
  ------------------
  |  Branch (13719:21): [True: 0, False: 0]
  ------------------
13720|      0|                    viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
13721|      0|                if (viewport->PlatformRequestResize)
  ------------------
  |  Branch (13721:21): [True: 0, False: 0]
  ------------------
13722|      0|                    viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
13723|      0|            }
13724|      0|        }
13725|       |
13726|       |        // Update/copy monitor info
13727|  55.4k|        UpdateViewportPlatformMonitor(viewport);
13728|       |
13729|       |        // Lock down space taken by menu bars and status bars, reset the offset for functions like BeginMainMenuBar() to alter them again.
13730|  55.4k|        viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
13731|  55.4k|        viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
13732|  55.4k|        viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
13733|  55.4k|        viewport->UpdateWorkRect();
13734|       |
13735|       |        // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
13736|  55.4k|        viewport->Alpha = 1.0f;
13737|       |
13738|       |        // Translate Dear ImGui windows when a Host Viewport has been moved
13739|       |        // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
13740|  55.4k|        const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
13741|  55.4k|        if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
  ------------------
  |  Branch (13741:13): [True: 55.4k, False: 0]
  |  Branch (13741:76): [True: 0, False: 55.4k]
  |  Branch (13741:108): [True: 0, False: 55.4k]
  ------------------
13742|      0|            TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos);
13743|       |
13744|       |        // Update DPI scale
13745|  55.4k|        float new_dpi_scale;
13746|  55.4k|        if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
  ------------------
  |  Branch (13746:13): [True: 0, False: 55.4k]
  |  Branch (13746:56): [True: 0, False: 0]
  ------------------
13747|      0|            new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
13748|  55.4k|        else if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (13748:18): [True: 0, False: 55.4k]
  ------------------
13749|      0|            new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
13750|  55.4k|        else
13751|  55.4k|            new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (13751:29): [True: 55.4k, False: 1]
  ------------------
13752|  55.4k|        if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
  ------------------
  |  Branch (13752:13): [True: 55.4k, False: 1]
  |  Branch (13752:43): [True: 0, False: 55.4k]
  ------------------
13753|      0|        {
13754|      0|            float scale_factor = new_dpi_scale / viewport->DpiScale;
13755|      0|            if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
  ------------------
  |  Branch (13755:17): [True: 0, False: 0]
  ------------------
13756|      0|                ScaleWindowsInViewport(viewport, scale_factor);
13757|       |            //if (viewport == GetMainViewport())
13758|       |            //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);
13759|       |
13760|       |            // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
13761|       |            // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
13762|       |            // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
13763|       |            //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
13764|       |            //    g.ActiveIdClickOffset = ImFloor(g.ActiveIdClickOffset * scale_factor);
13765|      0|        }
13766|  55.4k|        viewport->DpiScale = new_dpi_scale;
13767|  55.4k|    }
13768|       |
13769|       |    // Update fallback monitor
13770|  55.4k|    if (g.PlatformIO.Monitors.Size == 0)
  ------------------
  |  Branch (13770:9): [True: 55.4k, False: 0]
  ------------------
13771|  55.4k|    {
13772|  55.4k|        ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
13773|  55.4k|        monitor->MainPos = main_viewport->Pos;
13774|  55.4k|        monitor->MainSize = main_viewport->Size;
13775|  55.4k|        monitor->WorkPos = main_viewport->WorkPos;
13776|  55.4k|        monitor->WorkSize = main_viewport->WorkSize;
13777|  55.4k|        monitor->DpiScale = main_viewport->DpiScale;
13778|  55.4k|    }
13779|       |
13780|  55.4k|    if (!viewports_enabled)
  ------------------
  |  Branch (13780:9): [True: 55.4k, False: 0]
  ------------------
13781|  55.4k|    {
13782|  55.4k|        g.MouseViewport = main_viewport;
13783|  55.4k|        return;
13784|  55.4k|    }
13785|       |
13786|       |    // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
13787|       |    // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
13788|      0|    ImGuiViewportP* viewport_hovered = NULL;
13789|      0|    if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
  ------------------
  |  Branch (13789:9): [True: 0, False: 0]
  ------------------
13790|      0|    {
13791|      0|        viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
  ------------------
  |  Branch (13791:28): [True: 0, False: 0]
  ------------------
13792|      0|        if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (13792:13): [True: 0, False: 0]
  |  Branch (13792:33): [True: 0, False: 0]
  ------------------
13793|      0|            viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
13794|      0|    }
13795|      0|    else
13796|      0|    {
13797|       |        // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
13798|       |        // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
13799|       |        // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
13800|       |        // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
13801|      0|        viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
13802|      0|    }
13803|      0|    if (viewport_hovered != NULL)
  ------------------
  |  Branch (13803:9): [True: 0, False: 0]
  ------------------
13804|      0|        g.MouseLastHoveredViewport = viewport_hovered;
13805|      0|    else if (g.MouseLastHoveredViewport == NULL)
  ------------------
  |  Branch (13805:14): [True: 0, False: 0]
  ------------------
13806|      0|        g.MouseLastHoveredViewport = g.Viewports[0];
13807|       |
13808|       |    // Update mouse reference viewport
13809|       |    // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
13810|       |    // (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
13811|      0|    if (g.MovingWindow && g.MovingWindow->Viewport)
  ------------------
  |  Branch (13811:9): [True: 0, False: 0]
  |  Branch (13811:27): [True: 0, False: 0]
  ------------------
13812|      0|        g.MouseViewport = g.MovingWindow->Viewport;
13813|      0|    else
13814|      0|        g.MouseViewport = g.MouseLastHoveredViewport;
13815|       |
13816|       |    // When dragging something, always refer to the last hovered viewport.
13817|       |    // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
13818|       |    // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
13819|       |    // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
13820|       |    // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
13821|      0|    const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
13822|      0|    if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
  ------------------
  |  Branch (13822:9): [True: 0, False: 0]
  |  Branch (13822:59): [True: 0, False: 0]
  ------------------
13823|      0|        viewport_hovered = g.MouseLastHoveredViewport;
13824|      0|    if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
  ------------------
  |  Branch (13824:9): [True: 0, False: 0]
  |  Branch (13824:59): [True: 0, False: 0]
  |  Branch (13824:78): [True: 0, False: 0]
  ------------------
13825|      0|        if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (13825:13): [True: 0, False: 0]
  |  Branch (13825:41): [True: 0, False: 0]
  |  Branch (13825:80): [True: 0, False: 0]
  ------------------
13826|      0|            g.MouseViewport = viewport_hovered;
13827|       |
13828|      0|    IM_ASSERT(g.MouseViewport != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13829|      0|}
imgui.cpp:_ZN5ImGuiL29UpdateViewportPlatformMonitorEP14ImGuiViewportP:
14370|  55.4k|{
14371|  55.4k|    viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
14372|  55.4k|}
imgui.cpp:_ZN5ImGuiL26FindPlatformMonitorForRectERK6ImRect:
14338|  55.4k|{
14339|  55.4k|    ImGuiContext& g = *GImGui;
14340|       |
14341|  55.4k|    const int monitor_count = g.PlatformIO.Monitors.Size;
14342|  55.4k|    if (monitor_count <= 1)
  ------------------
  |  Branch (14342:9): [True: 55.4k, False: 0]
  ------------------
14343|  55.4k|        return monitor_count - 1;
14344|       |
14345|       |    // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
14346|       |    // This is necessary for tooltips which always resize down to zero at first.
14347|      0|    const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
14348|      0|    int best_monitor_n = -1;
14349|      0|    float best_monitor_surface = 0.001f;
14350|       |
14351|      0|    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
  ------------------
  |  Branch (14351:29): [True: 0, False: 0]
  |  Branch (14351:71): [True: 0, False: 0]
  ------------------
14352|      0|    {
14353|      0|        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
14354|      0|        const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
14355|      0|        if (monitor_rect.Contains(rect))
  ------------------
  |  Branch (14355:13): [True: 0, False: 0]
  ------------------
14356|      0|            return monitor_n;
14357|      0|        ImRect overlapping_rect = rect;
14358|      0|        overlapping_rect.ClipWithFull(monitor_rect);
14359|      0|        float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
14360|      0|        if (overlapping_surface < best_monitor_surface)
  ------------------
  |  Branch (14360:13): [True: 0, False: 0]
  ------------------
14361|      0|            continue;
14362|      0|        best_monitor_surface = overlapping_surface;
14363|      0|        best_monitor_n = monitor_n;
14364|      0|    }
14365|      0|    return best_monitor_n;
14366|      0|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsEndFrameEv:
13833|  55.4k|{
13834|  55.4k|    ImGuiContext& g = *GImGui;
13835|  55.4k|    g.PlatformIO.Viewports.resize(0);
13836|   110k|    for (int i = 0; i < g.Viewports.Size; i++)
  ------------------
  |  Branch (13836:21): [True: 55.4k, False: 55.4k]
  ------------------
13837|  55.4k|    {
13838|  55.4k|        ImGuiViewportP* viewport = g.Viewports[i];
13839|  55.4k|        viewport->LastPos = viewport->Pos;
13840|  55.4k|        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
  ------------------
  |  Branch (13840:13): [True: 0, False: 55.4k]
  |  Branch (13840:57): [True: 0, False: 55.4k]
  |  Branch (13840:85): [True: 0, False: 55.4k]
  ------------------
13841|      0|            if (i > 0) // Always include main viewport in the list
  ------------------
  |  Branch (13841:17): [True: 0, False: 0]
  ------------------
13842|      0|                continue;
13843|  55.4k|        if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
  ------------------
  |  Branch (13843:13): [True: 0, False: 55.4k]
  |  Branch (13843:33): [True: 0, False: 0]
  ------------------
13844|      0|            continue;
13845|  55.4k|        if (i > 0)
  ------------------
  |  Branch (13845:13): [True: 0, False: 55.4k]
  ------------------
13846|  55.4k|            IM_ASSERT(viewport->Window != NULL);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13847|  55.4k|        g.PlatformIO.Viewports.push_back(viewport);
13848|  55.4k|    }
13849|  55.4k|    g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
13850|  55.4k|}
imgui.cpp:_ZN5ImGuiL17AddUpdateViewportEP11ImGuiWindowjRK6ImVec2S4_i:
13854|  55.4k|{
13855|  55.4k|    ImGuiContext& g = *GImGui;
13856|  55.4k|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13857|       |
13858|  55.4k|    flags |= ImGuiViewportFlags_IsPlatformWindow;
13859|  55.4k|    if (window != NULL)
  ------------------
  |  Branch (13859:9): [True: 0, False: 55.4k]
  ------------------
13860|      0|    {
13861|      0|        if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
  ------------------
  |  Branch (13861:13): [True: 0, False: 0]
  |  Branch (13861:31): [True: 0, False: 0]
  ------------------
13862|      0|            flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
13863|      0|        if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (13863:13): [True: 0, False: 0]
  |  Branch (13863:65): [True: 0, False: 0]
  ------------------
13864|      0|            flags |= ImGuiViewportFlags_NoInputs;
13865|      0|        if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
  ------------------
  |  Branch (13865:13): [True: 0, False: 0]
  ------------------
13866|      0|            flags |= ImGuiViewportFlags_NoFocusOnAppearing;
13867|      0|    }
13868|       |
13869|  55.4k|    ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
13870|  55.4k|    if (viewport)
  ------------------
  |  Branch (13870:9): [True: 55.4k, False: 0]
  ------------------
13871|  55.4k|    {
13872|       |        // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
13873|  55.4k|        if (!viewport->PlatformRequestMove || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (13873:13): [True: 55.4k, False: 0]
  |  Branch (13873:47): [True: 0, False: 0]
  ------------------
13874|  55.4k|            viewport->Pos = pos;
13875|  55.4k|        if (!viewport->PlatformRequestResize || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (13875:13): [True: 55.4k, False: 0]
  |  Branch (13875:49): [True: 0, False: 0]
  ------------------
13876|  55.4k|            viewport->Size = size;
13877|  55.4k|        viewport->Flags = flags | (viewport->Flags & ImGuiViewportFlags_Minimized); // Preserve existing flags
13878|  55.4k|    }
13879|      0|    else
13880|      0|    {
13881|       |        // New viewport
13882|      0|        viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 1863|      0|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
13883|      0|        viewport->ID = id;
13884|      0|        viewport->Idx = g.Viewports.Size;
13885|      0|        viewport->Pos = viewport->LastPos = pos;
13886|      0|        viewport->Size = size;
13887|      0|        viewport->Flags = flags;
13888|      0|        UpdateViewportPlatformMonitor(viewport);
13889|      0|        g.Viewports.push_back(viewport);
13890|      0|        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window->Name : "<NULL>");
  ------------------
  |  |  233|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (222:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (233:50): [True: 0, False: 0]
  |  |  |  Branch (233:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
13891|       |
13892|       |        // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
13893|       |        // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
13894|      0|        g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
13895|      0|        g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
13896|      0|        g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
13897|      0|        g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);
13898|       |
13899|       |        // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
13900|       |        // This is so we can select an appropriate font size on the first frame of our window lifetime
13901|      0|        if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (13901:13): [True: 0, False: 0]
  ------------------
13902|      0|            viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
13903|      0|    }
13904|       |
13905|  55.4k|    viewport->Window = window;
13906|  55.4k|    viewport->LastFrameActive = g.FrameCount;
13907|  55.4k|    viewport->UpdateWorkRect();
13908|  55.4k|    IM_ASSERT(window == NULL || viewport->ID == window->ID);
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13909|       |
13910|  55.4k|    if (window != NULL)
  ------------------
  |  Branch (13910:9): [True: 0, False: 55.4k]
  ------------------
13911|      0|        window->ViewportOwned = true;
13912|       |
13913|  55.4k|    return viewport;
13914|  55.4k|}
imgui.cpp:_ZN5ImGuiL20WindowSelectViewportEP11ImGuiWindow:
13942|   132k|{
13943|   132k|    ImGuiContext& g = *GImGui;
13944|   132k|    ImGuiWindowFlags flags = window->Flags;
13945|   132k|    window->ViewportAllowPlatformMonitorExtend = -1;
13946|       |
13947|       |    // Restore main viewport if multi-viewport is not supported by the backend
13948|   132k|    ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
13949|   132k|    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
  ------------------
  |  Branch (13949:9): [True: 132k, False: 0]
  ------------------
13950|   132k|    {
13951|   132k|        SetWindowViewport(window, main_viewport);
13952|   132k|        return;
13953|   132k|    }
13954|      0|    window->ViewportOwned = false;
13955|       |
13956|       |    // Appearing popups reset their viewport so they can inherit again
13957|      0|    if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
  ------------------
  |  Branch (13957:9): [True: 0, False: 0]
  |  Branch (13957:74): [True: 0, False: 0]
  ------------------
13958|      0|    {
13959|      0|        window->Viewport = NULL;
13960|      0|        window->ViewportId = 0;
13961|      0|    }
13962|       |
13963|      0|    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
  ------------------
  |  Branch (13963:9): [True: 0, False: 0]
  ------------------
13964|      0|    {
13965|       |        // By default inherit from parent window
13966|      0|        if (window->Viewport == NULL && window->ParentWindow && (!window->ParentWindow->IsFallbackWindow || window->ParentWindow->WasActive))
  ------------------
  |  Branch (13966:13): [True: 0, False: 0]
  |  Branch (13966:41): [True: 0, False: 0]
  |  Branch (13966:66): [True: 0, False: 0]
  |  Branch (13966:109): [True: 0, False: 0]
  ------------------
13967|      0|            window->Viewport = window->ParentWindow->Viewport;
13968|       |
13969|       |        // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
13970|      0|        if (window->Viewport == NULL && window->ViewportId != 0)
  ------------------
  |  Branch (13970:13): [True: 0, False: 0]
  |  Branch (13970:41): [True: 0, False: 0]
  ------------------
13971|      0|        {
13972|      0|            window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
13973|      0|            if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
  ------------------
  |  Branch (13973:17): [True: 0, False: 0]
  |  Branch (13973:45): [True: 0, False: 0]
  |  Branch (13973:81): [True: 0, False: 0]
  ------------------
13974|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
13975|      0|        }
13976|      0|    }
13977|       |
13978|      0|    bool lock_viewport = false;
13979|      0|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
  ------------------
  |  Branch (13979:9): [True: 0, False: 0]
  ------------------
13980|      0|    {
13981|       |        // Code explicitly request a viewport
13982|      0|        window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
13983|      0|        window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
13984|      0|        lock_viewport = true;
13985|      0|    }
13986|      0|    else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (13986:14): [True: 0, False: 0]
  |  Branch (13986:56): [True: 0, False: 0]
  ------------------
13987|      0|    {
13988|       |        // Always inherit viewport from parent window
13989|      0|        if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (13989:13): [True: 0, False: 0]
  |  Branch (13989:33): [True: 0, False: 0]
  ------------------
13990|      0|            IM_ASSERT(window->DockNode->HostWindow->Viewport == window->ParentWindow->Viewport);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13991|      0|        window->Viewport = window->ParentWindow->Viewport;
13992|      0|    }
13993|      0|    else if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (13993:14): [True: 0, False: 0]
  |  Branch (13993:34): [True: 0, False: 0]
  ------------------
13994|      0|    {
13995|       |        // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
13996|      0|        window->Viewport = window->DockNode->HostWindow->Viewport;
13997|      0|    }
13998|      0|    else if (flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (13998:14): [True: 0, False: 0]
  ------------------
13999|      0|    {
14000|      0|        window->Viewport = g.MouseViewport;
14001|      0|    }
14002|      0|    else if (GetWindowAlwaysWantOwnViewport(window))
  ------------------
  |  Branch (14002:14): [True: 0, False: 0]
  ------------------
14003|      0|    {
14004|      0|        window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14005|      0|    }
14006|      0|    else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
  ------------------
  |  Branch (14006:14): [True: 0, False: 0]
  |  Branch (14006:32): [True: 0, False: 0]
  |  Branch (14006:80): [True: 0, False: 0]
  ------------------
14007|      0|    {
14008|      0|        if (window->Viewport != NULL && window->Viewport->Window == window)
  ------------------
  |  Branch (14008:13): [True: 0, False: 0]
  |  Branch (14008:41): [True: 0, False: 0]
  ------------------
14009|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14010|      0|    }
14011|      0|    else
14012|      0|    {
14013|       |        // Merge into host viewport?
14014|       |        // We cannot test window->ViewportOwned as it set lower in the function.
14015|       |        // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
14016|      0|        bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
  ------------------
  |  Branch (14016:49): [True: 0, False: 0]
  |  Branch (14016:69): [True: 0, False: 0]
  |  Branch (14016:108): [True: 0, False: 0]
  |  Branch (14016:127): [True: 0, False: 0]
  ------------------
14017|      0|        if (try_to_merge_into_host_viewport)
  ------------------
  |  Branch (14017:13): [True: 0, False: 0]
  ------------------
14018|      0|            UpdateTryMergeWindowIntoHostViewports(window);
14019|      0|    }
14020|       |
14021|       |    // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
14022|      0|    if (window->Viewport == NULL)
  ------------------
  |  Branch (14022:9): [True: 0, False: 0]
  ------------------
14023|      0|        if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
  ------------------
  |  Branch (14023:13): [True: 0, False: 0]
  ------------------
14024|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14025|       |
14026|       |    // Mark window as allowed to protrude outside of its viewport and into the current monitor
14027|      0|    if (!lock_viewport)
  ------------------
  |  Branch (14027:9): [True: 0, False: 0]
  ------------------
14028|      0|    {
14029|      0|        if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (14029:13): [True: 0, False: 0]
  ------------------
14030|      0|        {
14031|       |            // We need to take account of the possibility that mouse may become invalid.
14032|       |            // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
14033|      0|            ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
  ------------------
  |  Branch (14033:32): [True: 0, False: 0]
  ------------------
14034|      0|            bool use_mouse_ref = (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow);
  ------------------
  |  Branch (14034:35): [True: 0, False: 0]
  |  Branch (14034:60): [True: 0, False: 0]
  |  Branch (14034:87): [True: 0, False: 0]
  ------------------
14035|      0|            bool mouse_valid = IsMousePosValid(&mouse_ref);
14036|      0|            if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
  ------------------
  |  Branch (14036:18): [True: 0, False: 0]
  |  Branch (14036:39): [True: 0, False: 0]
  |  Branch (14036:110): [True: 0, False: 0]
  |  Branch (14036:128): [True: 0, False: 0]
  ------------------
14037|      0|                window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
  ------------------
  |  Branch (14037:89): [True: 0, False: 0]
  |  Branch (14037:106): [True: 0, False: 0]
  ------------------
14038|      0|            else
14039|      0|                window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
14040|      0|        }
14041|      0|        else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow) && window->DockNode == NULL)
  ------------------
  |  Branch (14041:18): [True: 0, False: 0]
  |  Branch (14041:38): [True: 0, False: 0]
  |  Branch (14041:76): [True: 0, False: 0]
  |  Branch (14041:104): [True: 0, False: 0]
  |  Branch (14041:147): [True: 0, False: 0]
  ------------------
14042|      0|        {
14043|       |            // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
14044|      0|            const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
  ------------------
  |  Branch (14044:43): [True: 0, False: 0]
  |  Branch (14044:67): [True: 0, False: 0]
  ------------------
14045|      0|            if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
  ------------------
  |  Branch (14045:17): [True: 0, False: 0]
  |  Branch (14045:68): [True: 0, False: 0]
  |  Branch (14045:120): [True: 0, False: 0]
  ------------------
14046|      0|            {
14047|       |                // Steal/transfer ownership
14048|      0|                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
  ------------------
  |  |  233|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  222|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (233:50): [True: 0, False: 0]
  |  |  |  Branch (233:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
14049|      0|                window->Viewport->Window = window;
14050|      0|                window->Viewport->ID = window->ID;
14051|      0|                window->Viewport->LastNameHash = 0;
14052|      0|            }
14053|      0|            else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
  ------------------
  |  Branch (14053:22): [True: 0, False: 0]
  ------------------
14054|      0|            {
14055|       |                // New viewport
14056|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
14057|      0|            }
14058|      0|        }
14059|      0|        else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
  ------------------
  |  Branch (14059:18): [True: 0, False: 0]
  |  Branch (14059:68): [True: 0, False: 0]
  ------------------
14060|      0|        {
14061|       |            // Regular (non-child, non-popup) windows by default are also allowed to protrude
14062|       |            // Child windows are kept contained within their parent.
14063|      0|            window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
14064|      0|        }
14065|      0|    }
14066|       |
14067|       |    // Update flags
14068|      0|    window->ViewportOwned = (window == window->Viewport->Window);
14069|      0|    window->ViewportId = window->Viewport->ID;
14070|       |
14071|       |    // If the OS window has a title bar, hide our imgui title bar
14072|       |    //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
14073|       |    //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
14074|      0|}
imgui.cpp:_ZN5ImGuiL21DockNodeIsDropAllowedEP11ImGuiWindowS1_:
16460|      1|{
16461|      1|    if (root_payload->DockNodeAsHost && root_payload->DockNodeAsHost->IsSplitNode()) // FIXME-DOCK: Missing filtering
  ------------------
  |  Branch (16461:9): [True: 0, False: 1]
  |  Branch (16461:41): [True: 0, False: 0]
  ------------------
16462|      0|        return true;
16463|       |
16464|      1|    const int payload_count = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows.Size : 1;
  ------------------
  |  Branch (16464:31): [True: 0, False: 1]
  ------------------
16465|      1|    for (int payload_n = 0; payload_n < payload_count; payload_n++)
  ------------------
  |  Branch (16465:29): [True: 1, False: 0]
  ------------------
16466|      1|    {
16467|      1|        ImGuiWindow* payload = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows[payload_n] : root_payload;
  ------------------
  |  Branch (16467:32): [True: 0, False: 1]
  ------------------
16468|      1|        if (DockNodeIsDropAllowedOne(payload, host_window))
  ------------------
  |  Branch (16468:13): [True: 1, False: 0]
  ------------------
16469|      1|            return true;
16470|      1|    }
16471|      0|    return false;
16472|      1|}
imgui.cpp:_ZL24DockNodeIsDropAllowedOneP11ImGuiWindowS0_:
16430|      1|{
16431|      1|    if (host_window->DockNodeAsHost && host_window->DockNodeAsHost->IsDockSpace() && payload->BeginOrderWithinContext < host_window->BeginOrderWithinContext)
  ------------------
  |  Branch (16431:9): [True: 0, False: 1]
  |  Branch (16431:40): [True: 0, False: 0]
  |  Branch (16431:86): [True: 0, False: 0]
  ------------------
16432|      0|        return false;
16433|       |
16434|      1|    ImGuiWindowClass* host_class = host_window->DockNodeAsHost ? &host_window->DockNodeAsHost->WindowClass : &host_window->WindowClass;
  ------------------
  |  Branch (16434:36): [True: 0, False: 1]
  ------------------
16435|      1|    ImGuiWindowClass* payload_class = &payload->WindowClass;
16436|      1|    if (host_class->ClassId != payload_class->ClassId)
  ------------------
  |  Branch (16436:9): [True: 0, False: 1]
  ------------------
16437|      0|    {
16438|      0|        if (host_class->ClassId != 0 && host_class->DockingAllowUnclassed && payload_class->ClassId == 0)
  ------------------
  |  Branch (16438:13): [True: 0, False: 0]
  |  Branch (16438:41): [True: 0, False: 0]
  |  Branch (16438:78): [True: 0, False: 0]
  ------------------
16439|      0|            return true;
16440|      0|        if (payload_class->ClassId != 0 && payload_class->DockingAllowUnclassed && host_class->ClassId == 0)
  ------------------
  |  Branch (16440:13): [True: 0, False: 0]
  |  Branch (16440:44): [True: 0, False: 0]
  |  Branch (16440:84): [True: 0, False: 0]
  ------------------
16441|      0|            return true;
16442|      0|        return false;
16443|      0|    }
16444|       |
16445|       |    // Prevent docking any window created above a popup
16446|       |    // Technically we should support it (e.g. in the case of a long-lived modal window that had fancy docking features),
16447|       |    // by e.g. adding a 'if (!ImGui::IsWindowWithinBeginStackOf(host_window, popup_window))' test.
16448|       |    // But it would requires more work on our end because the dock host windows is technically created in NewFrame()
16449|       |    // and our ->ParentXXX and ->RootXXX pointers inside windows are currently mislading or lacking.
16450|      1|    ImGuiContext& g = *GImGui;
16451|      1|    for (int i = g.OpenPopupStack.Size - 1; i >= 0; i--)
  ------------------
  |  Branch (16451:45): [True: 0, False: 1]
  ------------------
16452|      0|        if (ImGuiWindow* popup_window = g.OpenPopupStack[i].Window)
  ------------------
  |  Branch (16452:26): [True: 0, False: 0]
  ------------------
16453|      0|            if (ImGui::IsWindowWithinBeginStackOf(payload, popup_window))   // Payload is created from within a popup begin stack.
  ------------------
  |  Branch (16453:17): [True: 0, False: 0]
  ------------------
16454|      0|                return false;
16455|       |
16456|      1|    return true;
16457|      1|}
imgui.cpp:_ZN5ImGuiL25UpdateDebugToolItemPickerEv:
19911|  55.4k|{
19912|  55.4k|    ImGuiContext& g = *GImGui;
19913|  55.4k|    g.DebugItemPickerBreakId = 0;
19914|  55.4k|    if (!g.DebugItemPickerActive)
  ------------------
  |  Branch (19914:9): [True: 55.4k, False: 0]
  ------------------
19915|  55.4k|        return;
19916|       |
19917|      0|    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
19918|      0|    SetMouseCursor(ImGuiMouseCursor_Hand);
19919|      0|    if (IsKeyPressed(ImGuiKey_Escape))
  ------------------
  |  Branch (19919:9): [True: 0, False: 0]
  ------------------
19920|      0|        g.DebugItemPickerActive = false;
19921|      0|    const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
19922|      0|    if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
  ------------------
  |  Branch (19922:9): [True: 0, False: 0]
  |  Branch (19922:28): [True: 0, False: 0]
  |  Branch (19922:76): [True: 0, False: 0]
  ------------------
19923|      0|    {
19924|      0|        g.DebugItemPickerBreakId = hovered_id;
19925|      0|        g.DebugItemPickerActive = false;
19926|      0|    }
19927|      0|    for (int mouse_button = 0; mouse_button < 3; mouse_button++)
  ------------------
  |  Branch (19927:32): [True: 0, False: 0]
  ------------------
19928|      0|        if (change_mapping && IsMouseClicked(mouse_button))
  ------------------
  |  Branch (19928:13): [True: 0, False: 0]
  |  Branch (19928:31): [True: 0, False: 0]
  ------------------
19929|      0|            g.DebugItemPickerMouseButton = (ImU8)mouse_button;
19930|      0|    SetNextWindowBgAlpha(0.70f);
19931|      0|    BeginTooltip();
19932|      0|    Text("HoveredId: 0x%08X", hovered_id);
19933|      0|    Text("Press ESC to abort picking.");
19934|      0|    const char* mouse_button_names[] = { "Left", "Right", "Middle" };
19935|      0|    if (change_mapping)
  ------------------
  |  Branch (19935:9): [True: 0, False: 0]
  ------------------
19936|      0|        Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
19937|      0|    else
19938|      0|        TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
  ------------------
  |  Branch (19938:39): [True: 0, False: 0]
  ------------------
19939|      0|    EndTooltip();
19940|      0|}
imgui.cpp:_ZN5ImGuiL27UpdateDebugToolStackQueriesEv:
19944|  55.4k|{
19945|  55.4k|    ImGuiContext& g = *GImGui;
19946|  55.4k|    ImGuiStackTool* tool = &g.DebugStackTool;
19947|       |
19948|       |    // Clear hook when stack tool is not visible
19949|  55.4k|    g.DebugHookIdInfo = 0;
19950|  55.4k|    if (g.FrameCount != tool->LastActiveFrame + 1)
  ------------------
  |  Branch (19950:9): [True: 55.4k, False: 4]
  ------------------
19951|  55.4k|        return;
19952|       |
19953|       |    // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
19954|       |    // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
19955|      4|    const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
  ------------------
  |  Branch (19955:30): [True: 0, False: 4]
  ------------------
19956|      4|    if (tool->QueryId != query_id)
  ------------------
  |  Branch (19956:9): [True: 0, False: 4]
  ------------------
19957|      0|    {
19958|      0|        tool->QueryId = query_id;
19959|      0|        tool->StackLevel = -1;
19960|      0|        tool->Results.resize(0);
19961|      0|    }
19962|      4|    if (query_id == 0)
  ------------------
  |  Branch (19962:9): [True: 4, False: 0]
  ------------------
19963|      4|        return;
19964|       |
19965|       |    // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
19966|      0|    int stack_level = tool->StackLevel;
19967|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (19967:9): [True: 0, False: 0]
  |  Branch (19967:29): [True: 0, False: 0]
  ------------------
19968|      0|        if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
  ------------------
  |  Branch (19968:13): [True: 0, False: 0]
  |  Branch (19968:56): [True: 0, False: 0]
  ------------------
19969|      0|            tool->StackLevel++;
19970|       |
19971|       |    // Update hook
19972|      0|    stack_level = tool->StackLevel;
19973|      0|    if (stack_level == -1)
  ------------------
  |  Branch (19973:9): [True: 0, False: 0]
  ------------------
19974|      0|        g.DebugHookIdInfo = query_id;
19975|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (19975:9): [True: 0, False: 0]
  |  Branch (19975:29): [True: 0, False: 0]
  ------------------
19976|      0|    {
19977|      0|        g.DebugHookIdInfo = tool->Results[stack_level].ID;
19978|      0|        tool->Results[stack_level].QueryFrameCount++;
19979|      0|    }
19980|      0|}

_ZN6ImVec2C2Ev:
  263|   708k|    constexpr ImVec2()                      : x(0.0f), y(0.0f) { }
_ZN6ImVec4C2Ev:
  276|   362k|    constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
_ZN6ImVec2C2Eff:
  264|  15.8M|    constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }
_ZN6ImVec4C2Effff:
  277|   686k|    constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }
_ZN12ImGuiStorage16ImGuiStoragePairC2EjPv:
 2394|      4|        ImGuiStoragePair(ImGuiID _key, void* _val_p)    { key = _key; val_p = _val_p; }
_Znwm12ImNewWrapperPv:
 1858|     12|inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
_ZN15ImGuiPlatformIOC2Ev:
 3224|      1|    ImGuiPlatformIO()               { memset(this, 0, sizeof(*this)); }     // Zero clear
_ZN8ImVectorI20ImGuiPlatformMonitorEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP13ImGuiViewportEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiInputEventEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiWindowStackDataEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiColorModEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiStyleModEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP6ImFontEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIiEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiGroupDataEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiPopupDataEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformMonitorC2Ev:
 3234|      1|    ImGuiPlatformMonitor()          { MainPos = MainSize = WorkPos = WorkSize = ImVec2(0, 0); DpiScale = 1.0f; }
_ZN12ImGuiPayloadC2Ev:
 2278|      1|    ImGuiPayload()  { Clear(); }
_ZN8ImVectorIhEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiListClipperDataEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImGuiTableTempDataEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImGuiTableEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIfEC2Ev:
 1891|     11|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImDrawChannelEC2Ev:
 1891|      5|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImGuiTabBarEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiPtrOrIndexEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiShrinkWidthItemEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIcEC2Ev:
 1891|      9|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformImeDataC2Ev:
 3244|      2|    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
_ZN8ImVectorI16ImGuiDockRequestEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI21ImGuiDockNodeSettingsEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN15ImGuiTextBufferC2Ev:
 2363|      3|    ImGuiTextBuffer()   { }
_ZN8ImVectorI20ImGuiSettingsHandlerEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16ImGuiContextHookEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiStackLevelInfoEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN13ImGuiViewportC2Ev:
 3108|      1|    ImGuiViewport()     { memset(this, 0, sizeof(*this)); }
_ZN10ImDrawDataC2Ev:
 2794|      1|    ImDrawData()    { Clear(); }
_ZN8ImVectorIP10ImDrawListEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE5clearEv:
 1896|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorItE5clearEv:
 1896|      3|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 2]
  ------------------
_ZN16ImGuiWindowClassC2Ev:
 2260|      9|    ImGuiWindowClass() { memset(this, 0, sizeof(*this)); ParentViewportId = (ImGuiID)-1; DockingAllowUnclassed = true; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEC2Ev:
 1891|      8|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN10ImDrawListC2EP20ImDrawListSharedData:
 2675|      4|    ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }
_ZN8ImVectorI9ImDrawCmdEC2Ev:
 1891|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImDrawVertEC2Ev:
 1891|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI6ImVec4EC2Ev:
 1891|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIPvEC2Ev:
 1891|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI6ImVec2EC2Ev:
 1891|      5|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN18ImDrawListSplitterC2Ev:
 2604|      4|    inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }
_ZNK6ImFont8IsLoadedEv:
 3032|   110k|    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
_ZN10ImDrawData5ClearEv:
 2795|  55.4k|    void Clear()    { memset(this, 0, sizeof(*this)); }     // The ImDrawList are owned by ImGuiContext!
_ZN8ImVectorIP10ImDrawListE9push_backERKS1_:
 1926|  72.7k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 72.7k]
  ------------------
_ZN8ImVectorIP10ImDrawListE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI9ImDrawCmdE8pop_backEv:
 1927|   138k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   138k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE10push_frontERKS0_:
 1928|  10.2k|    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }
  ------------------
  |  Branch (1928:67): [True: 0, False: 10.2k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_:
 1926|   307k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 4, False: 307k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE7reserveEi:
 1922|      4|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 4]
  |  Branch (1922:167): [True: 0, False: 4]
  ------------------
_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi:
 1918|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 4]
  |  Branch (1918:131): [True: 4, False: 0]
  ------------------
_ZN8ImVectorI9ImDrawCmdE6insertEPKS0_RS2_:
 1932|  10.2k|    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
  ------------------
  |  |   23|  10.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (1932:144): [True: 0, False: 10.2k]
  |  Branch (1932:201): [True: 10.2k, False: 0]
  ------------------
_ZNK8ImVectorIP11ImGuiWindowE14_grow_capacityEi:
 1918|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 1, False: 3]
  |  Branch (1918:131): [True: 3, False: 1]
  ------------------
_ZNK8ImVectorIP11ImGuiWindowE8containsERKS1_:
 1933|      6|    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
  ------------------
  |  Branch (1933:126): [True: 3, False: 3]
  |  Branch (1933:147): [True: 0, False: 3]
  ------------------
_ZN6ImVec2ixEm:
  266|  1.51M|    float& operator[] (size_t idx)          { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
  ------------------
  |  |   23|  1.51M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN10ImDrawList10PathLineToERK6ImVec2:
 2723|  1.08M|    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
_ZN8ImVectorI6ImVec2E9push_backERKS0_:
 1926|  1.15M|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 3, False: 1.15M]
  ------------------
_ZN8ImVectorI6ImVec2E7reserveEi:
 1922|    813|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      6|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 807, False: 6]
  |  Branch (1922:167): [True: 2, False: 4]
  ------------------
_ZNK8ImVectorI6ImVec2E14_grow_capacityEi:
 1918|      6|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 2, False: 4]
  |  Branch (1918:131): [True: 5, False: 1]
  ------------------
_ZN10ImDrawList14PathFillConvexEj:
 2725|   187k|    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
_ZN10ImDrawList10PathStrokeEjif:
 2726|   158k|    inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE6resizeEi:
 1919|  55.4k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 55.4k]
  ------------------
_ZN8ImVectorI19ImGuiKeyRoutingDataE4swapERS1_:
 1916|  55.4k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZNK6ImVec2ixEm:
  265|     32|    float  operator[] (size_t idx) const    { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
  ------------------
  |  |   23|     32|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK11ImFontAtlas7IsBuiltEv:
 2921|  55.4k|    bool                        IsBuilt() const             { return Fonts.Size > 0 && TexReady; } // Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
  ------------------
  |  Branch (2921:70): [True: 55.4k, False: 0]
  |  Branch (2921:88): [True: 55.4k, False: 0]
  ------------------
_ZNK13ImGuiViewport9GetCenterEv:
 3112|  10.2k|    ImVec2              GetCenter() const       { return ImVec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f); }
_ZN12ImGuiPayload5ClearEv:
 2279|     15|    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
_ZNK12ImGuiPayload10IsDataTypeEPKc:
 2280|      2|    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
  ------------------
  |  Branch (2280:54): [True: 2, False: 0]
  |  Branch (2280:78): [True: 2, False: 0]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE6resizeEi:
 1919|  55.4k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 55.4k]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP13ImGuiViewportE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZNK12ImGuiPayload9IsPreviewEv:
 2281|      1|    bool IsPreview() const                  { return Preview; }
_ZNK12ImGuiPayload10IsDeliveryEv:
 2282|      1|    bool IsDelivery() const                 { return Delivery; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiEixEi:
 1905|    446|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIcE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorItEC2Ev:
 1891|      8|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjEC2Ev:
 1891|      6|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjED2Ev:
 1894|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1894:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIjE6resizeEi:
 1919|   187k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 2, False: 187k]
  ------------------
_ZN8ImVectorIjE7reserveEi:
 1922|      7|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      7|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 7]
  |  Branch (1922:167): [True: 0, False: 7]
  ------------------
_ZNK8ImVectorIjE14_grow_capacityEi:
 1918|      7|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 7]
  |  Branch (1918:131): [True: 5, False: 2]
  ------------------
_ZN8ImVectorIjE5clearEv:
 1896|      3|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      3|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 3, False: 0]
  ------------------
_ZN8ImVectorIP10ImDrawListE6resizeEi:
 1919|   166k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 166k]
  ------------------
_ZN8ImVectorItEixEi:
 1905|    315|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    315|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowEC2Ev:
 1891|      7|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP14ImGuiViewportPEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP6ImFontEixEi:
 1905|  55.4k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI15ImGuiInputEventE9push_backERKS0_:
 1926|  14.8k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 10, False: 14.8k]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE7reserveEi:
 1922|     10|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|     10|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      8|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 10]
  |  Branch (1922:167): [True: 8, False: 2]
  ------------------
_ZNK8ImVectorI15ImGuiInputEventE14_grow_capacityEi:
 1918|     10|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 8, False: 2]
  |  Branch (1918:131): [True: 10, False: 0]
  ------------------
_ZN8ImVectorItE6resizeEi:
 1919|   904k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 26, False: 904k]
  ------------------
_ZNK8ImVectorItE14_grow_capacityEi:
 1918|     31|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 25, False: 6]
  |  Branch (1918:131): [True: 20, False: 11]
  ------------------
_ZN8ImVectorI15ImGuiInputEventEixEi:
 1905|  18.3k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  18.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE3endEv:
 1911|   132k|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE3endEv:
 1910|      4|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE6insertEPKS1_RS3_:
 1932|      4|    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
  ------------------
  |  |   23|      4|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (1932:144): [True: 1, False: 3]
  |  Branch (1932:201): [True: 3, False: 1]
  ------------------
_ZNK8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorIcE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiE9push_backERKi:
 1926|  67.0k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 67.0k]
  ------------------
_ZN8ImVectorIiE7reserveEi:
 1922|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 2]
  |  Branch (1922:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorIiE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE9push_backERKS0_:
 1926|  55.4k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 55.4k]
  ------------------
_ZN8ImVectorI13ImGuiColorModE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiColorModE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE4backEv:
 1914|  55.4k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiColorModE8pop_backEv:
 1927|  55.4k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  55.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE9push_backERKS0_:
 1926|  65.6k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 65.6k]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiStyleModE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE4backEv:
 1914|  65.6k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  65.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE8pop_backEv:
 1927|  65.6k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  65.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP14ImGuiViewportPEixEi:
 1905|   762k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   762k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiED2Ev:
 1894|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1894:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE9push_backERKS1_:
 1926|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP14ImGuiViewportPE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIcE6resizeEiRKc:
 1920|  3.07k|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1920:67): [True: 1, False: 0]
  |  Branch (1920:127): [True: 1, False: 0]
  |  Branch (1920:163): [True: 3.07k, False: 1]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE9push_backERKS1_:
 1926|  55.4k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 55.4k]
  ------------------
_ZN8ImVectorI6ImVec2E5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI13ImDrawChannelE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI15ImGuiOldColumnsEC2Ev:
 1891|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjE9push_backERKj:
 1926|   143k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 5, False: 143k]
  ------------------
_ZN8ImVectorIjE4backEv:
 1914|   249k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   249k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIfE5clearEv:
 1896|      4|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 0, False: 4]
  ------------------
_ZN8ImVectorItE7reserveEi:
 1922|     31|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|     31|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|     25|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 31]
  |  Branch (1922:167): [True: 25, False: 6]
  ------------------
_ZN8ImVectorI10ImDrawVertE7reserveEi:
 1922|     23|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|     23|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|     19|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 23]
  |  Branch (1922:167): [True: 19, False: 4]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE6resizeEi:
 1919|   117k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 117k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowEixEi:
 1905|   941k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   941k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIfEixEi:
 1905|    512|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    512|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE6resizeEi:
 1919|  55.4k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 55.4k]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiWindowStackDataE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI14ImGuiPopupDataE6resizeEi:
 1919|  55.4k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 55.4k]
  ------------------
_ZN8ImVectorIiE6resizeEi:
 1919|  55.4k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 55.4k]
  ------------------
_ZN8ImVectorI14ImGuiGroupDataE6resizeEi:
 1919|  55.4k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 55.4k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE9push_backERKS1_:
 1926|   230k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 4, False: 230k]
  ------------------
_ZN8ImVectorI9ImDrawCmdEixEi:
 1905|   294k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   294k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIP10ImDrawListE5emptyEv:
 1900|  55.4k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI6ImVec4E4backEv:
 1914|   397k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   397k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE4backEv:
 1914|  21.6k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  21.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE6resizeEi:
 1919|   187k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 187k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE7reserveEi:
 1922|  55.4k|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      5|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 55.4k, False: 5]
  |  Branch (1922:167): [True: 1, False: 4]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4swapERS2_:
 1916|  55.4k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZNK8ImVectorI20ImGuiWindowStackDataE5emptyEv:
 1900|   132k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI20ImGuiWindowStackDataE4backEv:
 1914|   398k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   398k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE9push_backERKS0_:
 1926|   132k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 132k]
  ------------------
_ZN8ImVectorIfE6resizeEi:
 1919|   264k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 264k]
  ------------------
_ZN8ImVectorIfE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIfE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE8pop_backEv:
 1927|   132k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4backEv:
 1914|  7.31k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  7.31k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP6ImFontE9push_backERKS1_:
 1926|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP6ImFontE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE4backEv:
 1914|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE4backEv:
 1914|  22.7k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  22.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE8pop_backEv:
 1927|  11.3k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  11.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIjE8pop_backEv:
 1927|   143k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   143k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorItE9push_backERKt:
 1926|    522|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 4, False: 518]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE5eraseEPKS0_S3_:
 1930|    478|    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
  ------------------
  |  |   23|    478|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIhE5clearEv:
 1896|     14|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 0, False: 14]
  ------------------
_ZN8ImVectorIhE6resizeEi:
 1919|     16|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 16]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE9push_backERKS0_:
 1926|      3|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 2]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiSettingsHandlerE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerEixEi:
 1905|      1|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI16ImGuiDockRequestE6resizeEi:
 1919|  55.4k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 55.4k]
  ------------------
_ZN9ImDrawCmdC2Ev:
 2558|   307k|    ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed
_ZN18ImDrawListSplitter5ClearEv:
 2606|   132k|    inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame
_ZN21ImFontAtlasCustomRectC2Ev:
 2868|      2|    ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
_ZNK21ImFontAtlasCustomRect8IsPackedEv:
 2869|      2|    bool IsPacked() const           { return X != 0xFFFF; }
_ZN11ImFontAtlas20GetCustomRectByIndexEi:
 2954|      2|    ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectEixEi:
 1905|     16|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildDstDataEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildSrcDataE6resizeEi:
 1919|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE6resizeEi:
 1919|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildDstDataE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE13size_in_bytesEv:
 1902|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZNK8ImVectorI18ImFontBuildDstDataE13size_in_bytesEv:
 1902|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI18ImFontBuildSrcDataEixEi:
 1905|      7|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataEixEi:
 1905|      3|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIjE5emptyEv:
 1900|      1|    inline bool         empty() const                       { return Size == 0; }
_ZNK8ImVectorIjE5beginEv:
 1909|      1|    inline const T*     begin() const                       { return Data; }
_ZNK8ImVectorIjE3endEv:
 1911|      1|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorI18ImFontBuildDstDataE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16stbtt_packedcharE6resizeEi:
 1919|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE13size_in_bytesEv:
 1902|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI16stbtt_packedcharEixEi:
 1905|      1|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI10stbrp_rectE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE14clear_destructEv:
 1898|      2|    inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.
  ------------------
  |  Branch (1898:79): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharED2Ev:
 1894|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1894:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataED2Ev:
 1894|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1894:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataED2Ev:
 1894|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1894:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI9ImDrawCmdE6resizeEi:
 1919|   132k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 132k]
  ------------------
_ZN8ImVectorI10ImDrawVertE6resizeEi:
 1919|   841k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 23, False: 841k]
  ------------------
_ZNK8ImVectorI10ImDrawVertE14_grow_capacityEi:
 1918|     23|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 19, False: 4]
  |  Branch (1918:131): [True: 13, False: 10]
  ------------------
_ZN8ImVectorI6ImVec4E6resizeEi:
 1919|   132k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 132k]
  ------------------
_ZN8ImVectorI6ImVec4E7reserveEi:
 1922|      4|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 4]
  |  Branch (1922:167): [True: 0, False: 4]
  ------------------
_ZNK8ImVectorI6ImVec4E14_grow_capacityEi:
 1918|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 4]
  |  Branch (1918:131): [True: 4, False: 0]
  ------------------
_ZN8ImVectorIPvE6resizeEi:
 1919|   132k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 0, False: 132k]
  ------------------
_ZN8ImVectorIPvE7reserveEi:
 1922|      4|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 4]
  |  Branch (1922:167): [True: 0, False: 4]
  ------------------
_ZNK8ImVectorIPvE14_grow_capacityEi:
 1918|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 4]
  |  Branch (1918:131): [True: 4, False: 0]
  ------------------
_ZN8ImVectorI6ImVec2E6resizeEi:
 1919|   186k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 3, False: 186k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI10ImDrawVertE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIPvE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E9push_backERKS0_:
 1926|   285k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 4, False: 285k]
  ------------------
_ZN8ImVectorI6ImVec4E8pop_backEv:
 1927|   153k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   153k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIPvE9push_backERKS0_:
 1926|   132k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 4, False: 132k]
  ------------------
_ZN8ImVectorI6ImVec2E15reserve_discardEi:
 1923|   345k|    inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 1861|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
                  inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 1860|      3|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
  |  Branch (1923:67): [True: 345k, False: 3]
  |  Branch (1923:105): [True: 2, False: 1]
  ------------------
_ZNK8ImVectorItE5emptyEv:
 1900|  3.69k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI21ImFontAtlasCustomRectEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigEC2Ev:
 1891|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigEixEi:
 1905|      4|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      4|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI12ImFontConfigE9push_backERKS0_:
 1926|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI12ImFontConfigE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE4backEv:
 1914|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_:
 1926|      2|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1926:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE7reserveEi:
 1922|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 1]
  |  Branch (1922:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI21ImFontAtlasCustomRectE14_grow_capacityEi:
 1918|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 1]
  |  Branch (1918:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10stbrp_rectED2Ev:
 1894|      2|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1894:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI10stbrp_rectE6resizeEi:
 1919|      2|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectE7reserveEi:
 1922|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 2]
  |  Branch (1922:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorI10stbrp_rectE14_grow_capacityEi:
 1918|      2|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 0, False: 2]
  |  Branch (1918:131): [True: 1, False: 1]
  ------------------
_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv:
 1902|      2|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI10stbrp_rectEixEi:
 1905|     20|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     20|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphEC2Ev:
 1891|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImFontGlyphE5clearEv:
 1896|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1896:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI11ImFontGlyphEixEi:
 1905|    669|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    669|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE4backEv:
 1914|    225|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE6resizeEi:
 1919|    224|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1919:67): [True: 10, False: 214]
  ------------------
_ZN8ImVectorI11ImFontGlyphE7reserveEi:
 1922|     10|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1860|     10|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1861|      9|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1922:67): [True: 0, False: 10]
  |  Branch (1922:167): [True: 9, False: 1]
  ------------------
_ZNK8ImVectorI11ImFontGlyphE14_grow_capacityEi:
 1918|     10|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1918:82): [True: 9, False: 1]
  |  Branch (1918:131): [True: 10, False: 0]
  ------------------
_ZN8ImVectorIfE6resizeEiRKf:
 1920|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1920:67): [True: 1, False: 0]
  |  Branch (1920:127): [True: 1, False: 0]
  |  Branch (1920:163): [True: 256, False: 1]
  ------------------
_ZN8ImVectorItE6resizeEiRKt:
 1920|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1920:67): [True: 1, False: 0]
  |  Branch (1920:127): [True: 1, False: 0]
  |  Branch (1920:163): [True: 256, False: 1]
  ------------------

_ZN5ImGui15StyleColorsDarkEP10ImGuiStyle:
  175|      1|{
  176|      1|    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
  ------------------
  |  Branch (176:25): [True: 1, False: 0]
  ------------------
  177|      1|    ImVec4* colors = style->Colors;
  178|       |
  179|      1|    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
  180|      1|    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
  181|      1|    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
  182|      1|    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  183|      1|    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
  184|      1|    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
  185|      1|    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  186|      1|    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
  187|      1|    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  188|      1|    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  189|      1|    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
  190|      1|    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
  191|      1|    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
  192|      1|    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
  193|      1|    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
  194|      1|    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
  195|      1|    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
  196|      1|    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
  197|      1|    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  198|      1|    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
  199|      1|    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  200|      1|    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  201|      1|    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  202|      1|    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
  203|      1|    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
  204|      1|    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
  205|      1|    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  206|      1|    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
  207|      1|    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
  208|      1|    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
  209|      1|    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
  210|      1|    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  211|      1|    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
  212|      1|    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
  213|      1|    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
  214|      1|    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
  215|      1|    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
  216|      1|    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
  217|      1|    colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
  218|      1|    colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
  219|      1|    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
  220|      1|    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
  221|      1|    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
  222|      1|    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
  223|      1|    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
  224|      1|    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
  225|      1|    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
  226|      1|    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  227|      1|    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
  228|      1|    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
  229|      1|    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
  230|      1|    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  231|      1|    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
  232|      1|    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
  233|      1|    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
  234|      1|}
_ZN20ImDrawListSharedDataC2Ev:
  366|      1|{
  367|      1|    memset(this, 0, sizeof(*this));
  368|     49|    for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
  ------------------
  |  |   87|     49|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (368:21): [True: 48, False: 1]
  ------------------
  369|     48|    {
  370|     48|        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |  254|     48|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |   87|     48|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  371|     48|        ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  436|     48|#define ImCos(X)            cosf(X)
  ------------------
                      ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  437|     48|#define ImSin(X)            sinf(X)
  ------------------
  372|     48|    }
  373|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  752|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  436|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  374|      1|}
_ZN20ImDrawListSharedData29SetCircleTessellationMaxErrorEf:
  377|  55.4k|{
  378|  55.4k|    if (CircleSegmentMaxError == max_error)
  ------------------
  |  Branch (378:9): [True: 55.4k, False: 1]
  ------------------
  379|  55.4k|        return;
  380|       |
  381|      1|    IM_ASSERT(max_error > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  382|      1|    CircleSegmentMaxError = max_error;
  383|     65|    for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
  ------------------
  |  |   87|     65|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (383:21): [True: 64, False: 1]
  ------------------
  384|     64|    {
  385|     64|        const float radius = (float)i;
  386|     64|        CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  749|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  746|     63|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  747|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  748|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
                      CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  759|      1|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      1|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (386:41): [True: 63, False: 1]
  ------------------
  387|     64|    }
  388|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  752|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  436|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  389|      1|}
_ZN10ImDrawList17_ResetForNewFrameEv:
  393|   132k|{
  394|       |    // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
  395|   132k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, ClipRect) == 0);
  ------------------
  |  |  236|   132k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  396|   132k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, TextureId) == sizeof(ImVec4));
  ------------------
  |  |  236|   132k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  397|   132k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
  ------------------
  |  |  236|   132k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  398|   132k|    if (_Splitter._Count > 1)
  ------------------
  |  Branch (398:9): [True: 0, False: 132k]
  ------------------
  399|      0|        _Splitter.Merge(this);
  400|       |
  401|   132k|    CmdBuffer.resize(0);
  402|   132k|    IdxBuffer.resize(0);
  403|   132k|    VtxBuffer.resize(0);
  404|   132k|    Flags = _Data->InitialFlags;
  405|   132k|    memset(&_CmdHeader, 0, sizeof(_CmdHeader));
  406|   132k|    _VtxCurrentIdx = 0;
  407|   132k|    _VtxWritePtr = NULL;
  408|   132k|    _IdxWritePtr = NULL;
  409|   132k|    _ClipRectStack.resize(0);
  410|   132k|    _TextureIdStack.resize(0);
  411|   132k|    _Path.resize(0);
  412|   132k|    _Splitter.Clear();
  413|   132k|    CmdBuffer.push_back(ImDrawCmd());
  414|   132k|    _FringeScale = 1.0f;
  415|   132k|}
_ZN10ImDrawList16_ClearFreeMemoryEv:
  418|      1|{
  419|      1|    CmdBuffer.clear();
  420|      1|    IdxBuffer.clear();
  421|      1|    VtxBuffer.clear();
  422|      1|    Flags = ImDrawListFlags_None;
  423|      1|    _VtxCurrentIdx = 0;
  424|      1|    _VtxWritePtr = NULL;
  425|      1|    _IdxWritePtr = NULL;
  426|      1|    _ClipRectStack.clear();
  427|      1|    _TextureIdStack.clear();
  428|      1|    _Path.clear();
  429|      1|    _Splitter.ClearFreeMemory();
  430|      1|}
_ZN10ImDrawList10AddDrawCmdEv:
  443|   174k|{
  444|   174k|    ImDrawCmd draw_cmd;
  445|   174k|    draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
  446|   174k|    draw_cmd.TextureId = _CmdHeader.TextureId;
  447|   174k|    draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
  448|   174k|    draw_cmd.IdxOffset = IdxBuffer.Size;
  449|       |
  450|   174k|    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
  ------------------
  |  |   23|   174k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  451|   174k|    CmdBuffer.push_back(draw_cmd);
  452|   174k|}
_ZN10ImDrawList17_PopUnusedDrawCmdEv:
  457|  72.7k|{
  458|   101k|    while (CmdBuffer.Size > 0)
  ------------------
  |  Branch (458:12): [True: 101k, False: 0]
  ------------------
  459|   101k|    {
  460|   101k|        ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  461|   101k|        if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
  ------------------
  |  Branch (461:13): [True: 72.7k, False: 28.5k]
  |  Branch (461:41): [True: 0, False: 28.5k]
  ------------------
  462|  72.7k|            return;// break;
  463|  28.5k|        CmdBuffer.pop_back();
  464|  28.5k|    }
  465|  72.7k|}
_ZN10ImDrawList18_OnChangedClipRectEv:
  505|   438k|{
  506|       |    // If current command is used with different settings we need to add a new command
  507|   438k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  242|   438k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   438k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  508|   438k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  509|   438k|    if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
  ------------------
  |  Branch (509:9): [True: 185k, False: 253k]
  |  Branch (509:37): [True: 164k, False: 20.7k]
  ------------------
  510|   164k|    {
  511|   164k|        AddDrawCmd();
  512|   164k|        return;
  513|   164k|    }
  514|   274k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|   274k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  515|       |
  516|       |    // Try to merge with previous command if it matches, else use current command
  517|   274k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  518|   274k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  485|   109k|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  484|   109k|#define ImDrawCmd_HeaderSize                            (IM_OFFSETOF(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  |  |  ------------------
  |  |  |  |  |  |   89|   109k|#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  487|   384k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (487:57): [True: 99.5k, False: 10.1k]
  |  |  ------------------
  ------------------
  |  Branch (518:9): [True: 253k, False: 20.7k]
  |  Branch (518:37): [True: 109k, False: 144k]
  |  Branch (518:59): [True: 109k, False: 220]
  |  Branch (518:170): [True: 99.5k, False: 0]
  ------------------
  519|  99.5k|    {
  520|  99.5k|        CmdBuffer.pop_back();
  521|  99.5k|        return;
  522|  99.5k|    }
  523|       |
  524|   175k|    curr_cmd->ClipRect = _CmdHeader.ClipRect;
  525|   175k|}
_ZN10ImDrawList19_OnChangedTextureIDEv:
  528|   132k|{
  529|       |    // If current command is used with different settings we need to add a new command
  530|   132k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  242|   132k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  531|   132k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  532|   132k|    if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
  ------------------
  |  Branch (532:9): [True: 0, False: 132k]
  |  Branch (532:37): [True: 0, False: 0]
  ------------------
  533|      0|    {
  534|      0|        AddDrawCmd();
  535|      0|        return;
  536|      0|    }
  537|   132k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|   132k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  538|       |
  539|       |    // Try to merge with previous command if it matches, else use current command
  540|   132k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  541|   132k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  485|      0|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  484|      0|#define ImDrawCmd_HeaderSize                            (IM_OFFSETOF(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  |  |  ------------------
  |  |  |  |  |  |   89|      0|#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  487|   132k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (487:57): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (541:9): [True: 132k, False: 0]
  |  Branch (541:37): [True: 0, False: 132k]
  |  Branch (541:59): [True: 0, False: 0]
  |  Branch (541:170): [True: 0, False: 0]
  ------------------
  542|      0|    {
  543|      0|        CmdBuffer.pop_back();
  544|      0|        return;
  545|      0|    }
  546|       |
  547|   132k|    curr_cmd->TextureId = _CmdHeader.TextureId;
  548|   132k|}
_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf:
  567|  53.9k|{
  568|       |    // Automatic segment count
  569|  53.9k|    const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy
  570|  53.9k|    if (radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
  ------------------
  |  |   87|  53.9k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (570:9): [True: 53.9k, False: 0]
  ------------------
  571|  53.9k|        return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
  572|      0|    else
  573|      0|        return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
  ------------------
  |  |  749|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  746|      0|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  747|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  748|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
  574|  53.9k|}
_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b:
  578|   285k|{
  579|   285k|    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
  580|   285k|    if (intersect_with_current_clip_rect)
  ------------------
  |  Branch (580:9): [True: 132k, False: 153k]
  ------------------
  581|   132k|    {
  582|   132k|        ImVec4 current = _CmdHeader.ClipRect;
  583|   132k|        if (cr.x < current.x) cr.x = current.x;
  ------------------
  |  Branch (583:13): [True: 0, False: 132k]
  ------------------
  584|   132k|        if (cr.y < current.y) cr.y = current.y;
  ------------------
  |  Branch (584:13): [True: 0, False: 132k]
  ------------------
  585|   132k|        if (cr.z > current.z) cr.z = current.z;
  ------------------
  |  Branch (585:13): [True: 0, False: 132k]
  ------------------
  586|   132k|        if (cr.w > current.w) cr.w = current.w;
  ------------------
  |  Branch (586:13): [True: 0, False: 132k]
  ------------------
  587|   132k|    }
  588|   285k|    cr.z = ImMax(cr.x, cr.z);
  589|   285k|    cr.w = ImMax(cr.y, cr.w);
  590|       |
  591|   285k|    _ClipRectStack.push_back(cr);
  592|   285k|    _CmdHeader.ClipRect = cr;
  593|   285k|    _OnChangedClipRect();
  594|   285k|}
_ZN10ImDrawList11PopClipRectEv:
  602|   153k|{
  603|   153k|    _ClipRectStack.pop_back();
  604|   153k|    _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
  ------------------
  |  Branch (604:27): [True: 0, False: 153k]
  ------------------
  605|   153k|    _OnChangedClipRect();
  606|   153k|}
_ZN10ImDrawList13PushTextureIDEPv:
  609|   132k|{
  610|   132k|    _TextureIdStack.push_back(texture_id);
  611|   132k|    _CmdHeader.TextureId = texture_id;
  612|   132k|    _OnChangedTextureID();
  613|   132k|}
_ZN10ImDrawList11PrimReserveEii:
  626|   709k|{
  627|       |    // Large mesh support (when enabled)
  628|   709k|    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
  ------------------
  |  |  242|   709k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   709k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  629|   709k|    if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (629:9): [Folded - Ignored]
  |  Branch (629:35): [True: 0, False: 709k]
  |  Branch (629:80): [True: 0, False: 0]
  ------------------
  630|      0|    {
  631|       |        // FIXME: In theory we should be testing that vtx_count <64k here.
  632|       |        // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
  633|       |        // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
  634|      0|        _CmdHeader.VtxOffset = VtxBuffer.Size;
  635|      0|        _OnChangedVtxOffset();
  636|      0|    }
  637|       |
  638|   709k|    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  639|   709k|    draw_cmd->ElemCount += idx_count;
  640|       |
  641|   709k|    int vtx_buffer_old_size = VtxBuffer.Size;
  642|   709k|    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
  643|   709k|    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;
  644|       |
  645|   709k|    int idx_buffer_old_size = IdxBuffer.Size;
  646|   709k|    IdxBuffer.resize(idx_buffer_old_size + idx_count);
  647|   709k|    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
  648|   709k|}
_ZN10ImDrawList8PrimRectERK6ImVec2S2_j:
  663|   245k|{
  664|   245k|    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
  665|   245k|    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
  666|   245k|    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
  667|   245k|    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
  668|   245k|    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
  669|   245k|    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
  670|   245k|    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
  671|   245k|    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
  672|   245k|    _VtxWritePtr += 4;
  673|   245k|    _VtxCurrentIdx += 4;
  674|   245k|    _IdxWritePtr += 6;
  675|   245k|}
_ZN10ImDrawList11AddPolylineEPK6ImVec2ijif:
  716|   158k|{
  717|   158k|    if (points_count < 2)
  ------------------
  |  Branch (717:9): [True: 0, False: 158k]
  ------------------
  718|      0|        return;
  719|       |
  720|   158k|    const bool closed = (flags & ImDrawFlags_Closed) != 0;
  721|   158k|    const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
  722|   158k|    const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
  ------------------
  |  Branch (722:23): [True: 157k, False: 447]
  ------------------
  723|   158k|    const bool thick_line = (thickness > _FringeScale);
  724|       |
  725|   158k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (725:9): [True: 158k, False: 0]
  ------------------
  726|   158k|    {
  727|       |        // Anti-aliased stroke
  728|   158k|        const float AA_SIZE = _FringeScale;
  729|   158k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2487|   158k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  730|       |
  731|       |        // Thicknesses <1.0 should behave like thickness 1.0
  732|   158k|        thickness = ImMax(thickness, 1.0f);
  733|   158k|        const int integer_thickness = (int)thickness;
  734|   158k|        const float fractional_thickness = thickness - integer_thickness;
  735|       |
  736|       |        // Do we want to draw this line using a texture?
  737|       |        // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
  738|       |        // - If AA_SIZE is not 1.0f we cannot use the texture path.
  739|   158k|        const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);
  ------------------
  |  | 2523|   158k|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (739:34): [True: 158k, False: 0]
  |  Branch (739:86): [True: 158k, False: 0]
  |  Branch (739:143): [True: 158k, False: 0]
  |  Branch (739:181): [True: 158k, False: 0]
  ------------------
  740|       |
  741|       |        // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
  742|   158k|        IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
  ------------------
  |  |  242|   158k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   158k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  743|       |
  744|   158k|        const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
  ------------------
  |  Branch (744:31): [True: 158k, False: 0]
  |  Branch (744:60): [True: 0, False: 0]
  ------------------
  745|   158k|        const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
  ------------------
  |  Branch (745:31): [True: 158k, False: 0]
  |  Branch (745:67): [True: 0, False: 0]
  ------------------
  746|   158k|        PrimReserve(idx_count, vtx_count);
  747|       |
  748|       |        // Temporary buffer
  749|       |        // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
  750|   158k|        _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
  ------------------
  |  Branch (750:60): [True: 158k, False: 0]
  |  Branch (750:75): [True: 0, False: 0]
  ------------------
  751|   158k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
  752|   158k|        ImVec2* temp_points = temp_normals + points_count;
  753|       |
  754|       |        // Calculate normals (tangents) for each line segment
  755|   833k|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (755:26): [True: 674k, False: 158k]
  ------------------
  756|   674k|        {
  757|   674k|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (757:28): [True: 157k, False: 517k]
  ------------------
  758|   674k|            float dx = points[i2].x - points[i1].x;
  759|   674k|            float dy = points[i2].y - points[i1].y;
  760|   674k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|   674k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 670k, False: 4.38k]
  |  |  ------------------
  ------------------
  761|   674k|            temp_normals[i1].x = dy;
  762|   674k|            temp_normals[i1].y = -dx;
  763|   674k|        }
  764|   158k|        if (!closed)
  ------------------
  |  Branch (764:13): [True: 447, False: 157k]
  ------------------
  765|    447|            temp_normals[points_count - 1] = temp_normals[points_count - 2];
  766|       |
  767|       |        // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
  768|   158k|        if (use_texture || !thick_line)
  ------------------
  |  Branch (768:13): [True: 158k, False: 0]
  |  Branch (768:28): [True: 0, False: 0]
  ------------------
  769|   158k|        {
  770|       |            // [PATH 1] Texture-based lines (thick or non-thick)
  771|       |            // [PATH 2] Non texture-based lines (non-thick)
  772|       |
  773|       |            // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
  774|       |            // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
  775|       |            //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
  776|       |            // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
  777|       |            //   allow scaling geometry while preserving one-screen-pixel AA fringe).
  778|   158k|            const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;
  ------------------
  |  Branch (778:42): [True: 158k, False: 0]
  ------------------
  779|       |
  780|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  781|   158k|            if (!closed)
  ------------------
  |  Branch (781:17): [True: 447, False: 157k]
  ------------------
  782|    447|            {
  783|    447|                temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
  784|    447|                temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
  785|    447|                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
  786|    447|                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
  787|    447|            }
  788|       |
  789|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  790|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  791|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  792|   158k|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  793|   833k|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (793:30): [True: 674k, False: 158k]
  ------------------
  794|   674k|            {
  795|   674k|                const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
  ------------------
  |  Branch (795:32): [True: 157k, False: 517k]
  ------------------
  796|   674k|                const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment
  ------------------
  |  Branch (796:43): [True: 157k, False: 517k]
  |  Branch (796:98): [True: 517k, False: 0]
  ------------------
  797|       |
  798|       |                // Average normals
  799|   674k|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  800|   674k|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  801|   674k|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|   674k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|   674k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 674k, False: 16]
  |  |  |  Branch (711:127): [True: 0, False: 674k]
  |  |  ------------------
  ------------------
  802|   674k|                dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
  803|   674k|                dm_y *= half_draw_size;
  804|       |
  805|       |                // Add temporary vertexes for the outer edges
  806|   674k|                ImVec2* out_vtx = &temp_points[i2 * 2];
  807|   674k|                out_vtx[0].x = points[i2].x + dm_x;
  808|   674k|                out_vtx[0].y = points[i2].y + dm_y;
  809|   674k|                out_vtx[1].x = points[i2].x - dm_x;
  810|   674k|                out_vtx[1].y = points[i2].y - dm_y;
  811|       |
  812|   674k|                if (use_texture)
  ------------------
  |  Branch (812:21): [True: 674k, False: 0]
  ------------------
  813|   674k|                {
  814|       |                    // Add indices for two triangles
  815|   674k|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
  816|   674k|                    _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
  817|   674k|                    _IdxWritePtr += 6;
  818|   674k|                }
  819|      0|                else
  820|      0|                {
  821|       |                    // Add indexes for four triangles
  822|      0|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
  823|      0|                    _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
  824|      0|                    _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
  825|      0|                    _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
  826|      0|                    _IdxWritePtr += 12;
  827|      0|                }
  828|       |
  829|   674k|                idx1 = idx2;
  830|   674k|            }
  831|       |
  832|       |            // Add vertexes for each point on the line
  833|   158k|            if (use_texture)
  ------------------
  |  Branch (833:17): [True: 158k, False: 0]
  ------------------
  834|   158k|            {
  835|       |                // If we're using textures we only need to emit the left/right edge vertices
  836|   158k|                ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
  837|       |                /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
  838|       |                {
  839|       |                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
  840|       |                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
  841|       |                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
  842|       |                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
  843|       |                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
  844|       |                }*/
  845|   158k|                ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
  846|   158k|                ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
  847|   833k|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (847:33): [True: 675k, False: 158k]
  ------------------
  848|   675k|                {
  849|   675k|                    _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
  850|   675k|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
  851|   675k|                    _VtxWritePtr += 2;
  852|   675k|                }
  853|   158k|            }
  854|      0|            else
  855|      0|            {
  856|       |                // If we're not using a texture, we need the center vertex as well
  857|      0|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (857:33): [True: 0, False: 0]
  ------------------
  858|      0|                {
  859|      0|                    _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
  860|      0|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge
  861|      0|                    _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge
  862|      0|                    _VtxWritePtr += 3;
  863|      0|                }
  864|      0|            }
  865|   158k|        }
  866|      0|        else
  867|      0|        {
  868|       |            // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
  869|      0|            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
  870|       |
  871|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  872|      0|            if (!closed)
  ------------------
  |  Branch (872:17): [True: 0, False: 0]
  ------------------
  873|      0|            {
  874|      0|                const int points_last = points_count - 1;
  875|      0|                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
  876|      0|                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
  877|      0|                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
  878|      0|                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
  879|      0|                temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  880|      0|                temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
  881|      0|                temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
  882|      0|                temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  883|      0|            }
  884|       |
  885|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  886|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  887|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  888|      0|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  889|      0|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (889:30): [True: 0, False: 0]
  ------------------
  890|      0|            {
  891|      0|                const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
  ------------------
  |  Branch (891:32): [True: 0, False: 0]
  ------------------
  892|      0|                const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment
  ------------------
  |  Branch (892:43): [True: 0, False: 0]
  ------------------
  893|       |
  894|       |                // Average normals
  895|      0|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  896|      0|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  897|      0|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|      0|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 0, False: 0]
  |  |  |  Branch (711:127): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  898|      0|                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
  899|      0|                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
  900|      0|                float dm_in_x = dm_x * half_inner_thickness;
  901|      0|                float dm_in_y = dm_y * half_inner_thickness;
  902|       |
  903|       |                // Add temporary vertices
  904|      0|                ImVec2* out_vtx = &temp_points[i2 * 4];
  905|      0|                out_vtx[0].x = points[i2].x + dm_out_x;
  906|      0|                out_vtx[0].y = points[i2].y + dm_out_y;
  907|      0|                out_vtx[1].x = points[i2].x + dm_in_x;
  908|      0|                out_vtx[1].y = points[i2].y + dm_in_y;
  909|      0|                out_vtx[2].x = points[i2].x - dm_in_x;
  910|      0|                out_vtx[2].y = points[i2].y - dm_in_y;
  911|      0|                out_vtx[3].x = points[i2].x - dm_out_x;
  912|      0|                out_vtx[3].y = points[i2].y - dm_out_y;
  913|       |
  914|       |                // Add indexes
  915|      0|                _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);
  916|      0|                _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);
  917|      0|                _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);
  918|      0|                _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
  919|      0|                _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
  920|      0|                _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
  921|      0|                _IdxWritePtr += 18;
  922|       |
  923|      0|                idx1 = idx2;
  924|      0|            }
  925|       |
  926|       |            // Add vertices
  927|      0|            for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (927:29): [True: 0, False: 0]
  ------------------
  928|      0|            {
  929|      0|                _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
  930|      0|                _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  931|      0|                _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  932|      0|                _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
  933|      0|                _VtxWritePtr += 4;
  934|      0|            }
  935|      0|        }
  936|   158k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
  937|   158k|    }
  938|      0|    else
  939|      0|    {
  940|       |        // [PATH 4] Non texture-based, Non anti-aliased lines
  941|      0|        const int idx_count = count * 6;
  942|      0|        const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
  943|      0|        PrimReserve(idx_count, vtx_count);
  944|       |
  945|      0|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (945:26): [True: 0, False: 0]
  ------------------
  946|      0|        {
  947|      0|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (947:28): [True: 0, False: 0]
  ------------------
  948|      0|            const ImVec2& p1 = points[i1];
  949|      0|            const ImVec2& p2 = points[i2];
  950|       |
  951|      0|            float dx = p2.x - p1.x;
  952|      0|            float dy = p2.y - p1.y;
  953|      0|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|      0|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  954|      0|            dx *= (thickness * 0.5f);
  955|      0|            dy *= (thickness * 0.5f);
  956|       |
  957|      0|            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;
  958|      0|            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  959|      0|            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  960|      0|            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;
  961|      0|            _VtxWritePtr += 4;
  962|       |
  963|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
  964|      0|            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
  965|      0|            _IdxWritePtr += 6;
  966|      0|            _VtxCurrentIdx += 4;
  967|      0|        }
  968|      0|    }
  969|   158k|}
_ZN10ImDrawList19AddConvexPolyFilledEPK6ImVec2ij:
  974|   187k|{
  975|   187k|    if (points_count < 3)
  ------------------
  |  Branch (975:9): [True: 0, False: 187k]
  ------------------
  976|      0|        return;
  977|       |
  978|   187k|    const ImVec2 uv = _Data->TexUvWhitePixel;
  979|       |
  980|   187k|    if (Flags & ImDrawListFlags_AntiAliasedFill)
  ------------------
  |  Branch (980:9): [True: 187k, False: 0]
  ------------------
  981|   187k|    {
  982|       |        // Anti-aliased Fill
  983|   187k|        const float AA_SIZE = _FringeScale;
  984|   187k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2487|   187k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  985|   187k|        const int idx_count = (points_count - 2)*3 + points_count * 6;
  986|   187k|        const int vtx_count = (points_count * 2);
  987|   187k|        PrimReserve(idx_count, vtx_count);
  988|       |
  989|       |        // Add indexes for fill
  990|   187k|        unsigned int vtx_inner_idx = _VtxCurrentIdx;
  991|   187k|        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
  992|   422k|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (992:25): [True: 235k, False: 187k]
  ------------------
  993|   235k|        {
  994|   235k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
  995|   235k|            _IdxWritePtr += 3;
  996|   235k|        }
  997|       |
  998|       |        // Compute normals
  999|   187k|        _Data->TempBuffer.reserve_discard(points_count);
 1000|   187k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
 1001|   798k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1001:49): [True: 610k, False: 187k]
  ------------------
 1002|   610k|        {
 1003|   610k|            const ImVec2& p0 = points[i0];
 1004|   610k|            const ImVec2& p1 = points[i1];
 1005|   610k|            float dx = p1.x - p0.x;
 1006|   610k|            float dy = p1.y - p0.y;
 1007|   610k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|   610k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 610k, False: 172]
  |  |  ------------------
  ------------------
 1008|   610k|            temp_normals[i0].x = dy;
 1009|   610k|            temp_normals[i0].y = -dx;
 1010|   610k|        }
 1011|       |
 1012|   798k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1012:49): [True: 610k, False: 187k]
  ------------------
 1013|   610k|        {
 1014|       |            // Average normals
 1015|   610k|            const ImVec2& n0 = temp_normals[i0];
 1016|   610k|            const ImVec2& n1 = temp_normals[i1];
 1017|   610k|            float dm_x = (n0.x + n1.x) * 0.5f;
 1018|   610k|            float dm_y = (n0.y + n1.y) * 0.5f;
 1019|   610k|            IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|   610k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|   610k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 610k, False: 38]
  |  |  |  Branch (711:127): [True: 0, False: 610k]
  |  |  ------------------
  ------------------
 1020|   610k|            dm_x *= AA_SIZE * 0.5f;
 1021|   610k|            dm_y *= AA_SIZE * 0.5f;
 1022|       |
 1023|       |            // Add vertices
 1024|   610k|            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
 1025|   610k|            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
 1026|   610k|            _VtxWritePtr += 2;
 1027|       |
 1028|       |            // Add indexes for fringes
 1029|   610k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
 1030|   610k|            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
 1031|   610k|            _IdxWritePtr += 6;
 1032|   610k|        }
 1033|   187k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1034|   187k|    }
 1035|      0|    else
 1036|      0|    {
 1037|       |        // Non Anti-aliased Fill
 1038|      0|        const int idx_count = (points_count - 2)*3;
 1039|      0|        const int vtx_count = points_count;
 1040|      0|        PrimReserve(idx_count, vtx_count);
 1041|      0|        for (int i = 0; i < vtx_count; i++)
  ------------------
  |  Branch (1041:25): [True: 0, False: 0]
  ------------------
 1042|      0|        {
 1043|      0|            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
 1044|      0|            _VtxWritePtr++;
 1045|      0|        }
 1046|      0|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (1046:25): [True: 0, False: 0]
  ------------------
 1047|      0|        {
 1048|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
 1049|      0|            _IdxWritePtr += 3;
 1050|      0|        }
 1051|      0|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1052|      0|    }
 1053|   187k|}
_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii:
 1056|  53.9k|{
 1057|  53.9k|    if (radius < 0.5f)
  ------------------
  |  Branch (1057:9): [True: 0, False: 53.9k]
  ------------------
 1058|      0|    {
 1059|      0|        _Path.push_back(center);
 1060|      0|        return;
 1061|      0|    }
 1062|       |
 1063|       |    // Calculate arc auto segment step size
 1064|  53.9k|    if (a_step <= 0)
  ------------------
  |  Branch (1064:9): [True: 53.9k, False: 0]
  ------------------
 1065|  53.9k|        a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);
  ------------------
  |  |  759|  53.9k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|  53.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1066|       |
 1067|       |    // Make sure we never do steps larger than one quarter of the circle
 1068|  53.9k|    a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);
  ------------------
  |  |  757|  53.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  ------------------
 1069|       |
 1070|  53.9k|    const int sample_range = ImAbs(a_max_sample - a_min_sample);
 1071|  53.9k|    const int a_next_step = a_step;
 1072|       |
 1073|  53.9k|    int samples = sample_range + 1;
 1074|  53.9k|    bool extra_max_sample = false;
 1075|  53.9k|    if (a_step > 1)
  ------------------
  |  Branch (1075:9): [True: 53.9k, False: 0]
  ------------------
 1076|  53.9k|    {
 1077|  53.9k|        samples            = sample_range / a_step + 1;
 1078|  53.9k|        const int overstep = sample_range % a_step;
 1079|       |
 1080|  53.9k|        if (overstep > 0)
  ------------------
  |  Branch (1080:13): [True: 44, False: 53.9k]
  ------------------
 1081|     44|        {
 1082|     44|            extra_max_sample = true;
 1083|     44|            samples++;
 1084|       |
 1085|       |            // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
 1086|       |            // distribute first step range evenly between them by reducing first step size.
 1087|     44|            if (sample_range > 0)
  ------------------
  |  Branch (1087:17): [True: 44, False: 0]
  ------------------
 1088|     44|                a_step -= (a_step - overstep) / 2;
 1089|     44|        }
 1090|  53.9k|    }
 1091|       |
 1092|  53.9k|    _Path.resize(_Path.Size + samples);
 1093|  53.9k|    ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);
 1094|       |
 1095|  53.9k|    int sample_index = a_min_sample;
 1096|  53.9k|    if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  759|  53.9k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|  53.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1096:9): [True: 0, False: 53.9k]
  |  Branch (1096:29): [True: 0, False: 53.9k]
  ------------------
 1097|      0|    {
 1098|      0|        sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1099|      0|        if (sample_index < 0)
  ------------------
  |  Branch (1099:13): [True: 0, False: 0]
  ------------------
 1100|      0|            sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1101|      0|    }
 1102|       |
 1103|  53.9k|    if (a_max_sample >= a_min_sample)
  ------------------
  |  Branch (1103:9): [True: 53.9k, False: 0]
  ------------------
 1104|  53.9k|    {
 1105|   182k|        for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
  ------------------
  |  Branch (1105:36): [True: 128k, False: 53.9k]
  ------------------
 1106|   128k|        {
 1107|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1108|   128k|            if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  759|   128k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|   128k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1108:17): [True: 13.4k, False: 115k]
  ------------------
 1109|  13.4k|                sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|  13.4k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|  13.4k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1110|       |
 1111|   128k|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1112|   128k|            out_ptr->x = center.x + s.x * radius;
 1113|   128k|            out_ptr->y = center.y + s.y * radius;
 1114|   128k|            out_ptr++;
 1115|   128k|        }
 1116|  53.9k|    }
 1117|      0|    else
 1118|      0|    {
 1119|      0|        for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
  ------------------
  |  Branch (1119:36): [True: 0, False: 0]
  ------------------
 1120|      0|        {
 1121|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1122|      0|            if (sample_index < 0)
  ------------------
  |  Branch (1122:17): [True: 0, False: 0]
  ------------------
 1123|      0|                sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1124|       |
 1125|      0|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1126|      0|            out_ptr->x = center.x + s.x * radius;
 1127|      0|            out_ptr->y = center.y + s.y * radius;
 1128|      0|            out_ptr++;
 1129|      0|        }
 1130|      0|    }
 1131|       |
 1132|  53.9k|    if (extra_max_sample)
  ------------------
  |  Branch (1132:9): [True: 44, False: 53.9k]
  ------------------
 1133|     44|    {
 1134|     44|        int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|     44|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|     44|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1135|     44|        if (normalized_max_sample < 0)
  ------------------
  |  Branch (1135:13): [True: 0, False: 44]
  ------------------
 1136|      0|            normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1137|       |
 1138|     44|        const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];
 1139|     44|        out_ptr->x = center.x + s.x * radius;
 1140|     44|        out_ptr->y = center.y + s.y * radius;
 1141|     44|        out_ptr++;
 1142|     44|    }
 1143|       |
 1144|  53.9k|    IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
  ------------------
  |  |  242|  53.9k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|  53.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 1145|  53.9k|}
_ZN10ImDrawList11_PathArcToNERK6ImVec2fffi:
 1148|    807|{
 1149|    807|    if (radius < 0.5f)
  ------------------
  |  Branch (1149:9): [True: 0, False: 807]
  ------------------
 1150|      0|    {
 1151|      0|        _Path.push_back(center);
 1152|      0|        return;
 1153|      0|    }
 1154|       |
 1155|       |    // Note that we are adding a point at both a_min and a_max.
 1156|       |    // If you are trying to draw a full closed circle you don't want the overlapping points!
 1157|    807|    _Path.reserve(_Path.Size + (num_segments + 1));
 1158|  10.1k|    for (int i = 0; i <= num_segments; i++)
  ------------------
  |  Branch (1158:21): [True: 9.30k, False: 807]
  ------------------
 1159|  9.30k|    {
 1160|  9.30k|        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
 1161|  9.30k|        _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  436|  9.30k|#define ImCos(X)            cosf(X)
  ------------------
                      _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  437|  9.30k|#define ImSin(X)            sinf(X)
  ------------------
 1162|  9.30k|    }
 1163|    807|}
_ZN10ImDrawList13PathArcToFastERK6ImVec2fii:
 1167|   120k|{
 1168|   120k|    if (radius < 0.5f)
  ------------------
  |  Branch (1168:9): [True: 66.8k, False: 53.9k]
  ------------------
 1169|  66.8k|    {
 1170|  66.8k|        _Path.push_back(center);
 1171|  66.8k|        return;
 1172|  66.8k|    }
 1173|  53.9k|    _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  759|  53.9k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|  53.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                  _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  759|  53.9k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|  53.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1174|  53.9k|}
_ZN10ImDrawList9PathArcToERK6ImVec2fffi:
 1177|    807|{
 1178|    807|    if (radius < 0.5f)
  ------------------
  |  Branch (1178:9): [True: 0, False: 807]
  ------------------
 1179|      0|    {
 1180|      0|        _Path.push_back(center);
 1181|      0|        return;
 1182|      0|    }
 1183|       |
 1184|    807|    if (num_segments > 0)
  ------------------
  |  Branch (1184:9): [True: 807, False: 0]
  ------------------
 1185|    807|    {
 1186|    807|        _PathArcToN(center, radius, a_min, a_max, num_segments);
 1187|    807|        return;
 1188|    807|    }
 1189|       |
 1190|       |    // Automatic segment count
 1191|      0|    if (radius <= _Data->ArcFastRadiusCutoff)
  ------------------
  |  Branch (1191:9): [True: 0, False: 0]
  ------------------
 1192|      0|    {
 1193|      0|        const bool a_is_reverse = a_max < a_min;
 1194|       |
 1195|       |        // We are going to use precomputed values for mid samples.
 1196|       |        // Determine first and last sample in lookup table that belong to the arc.
 1197|      0|        const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  254|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1198|      0|        const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  254|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1199|       |
 1200|      0|        const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);
  ------------------
  |  |  442|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1200:34): [True: 0, False: 0]
  ------------------
 1201|      0|        const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloorSigned(a_max_sample_f);
  ------------------
  |  |  442|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1201:34): [True: 0, False: 0]
  ------------------
 1202|      0|        const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);
  ------------------
  |  Branch (1202:35): [True: 0, False: 0]
  ------------------
 1203|       |
 1204|      0|        const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  254|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1205|      0|        const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  254|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1206|      0|        const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;
 1207|      0|        const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;
 1208|       |
 1209|      0|        _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));
  ------------------
  |  Branch (1209:58): [True: 0, False: 0]
  |  Branch (1209:83): [True: 0, False: 0]
  ------------------
 1210|      0|        if (a_emit_start)
  ------------------
  |  Branch (1210:13): [True: 0, False: 0]
  ------------------
 1211|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  436|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  437|      0|#define ImSin(X)            sinf(X)
  ------------------
 1212|      0|        if (a_mid_samples > 0)
  ------------------
  |  Branch (1212:13): [True: 0, False: 0]
  ------------------
 1213|      0|            _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
 1214|      0|        if (a_emit_end)
  ------------------
  |  Branch (1214:13): [True: 0, False: 0]
  ------------------
 1215|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  436|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  437|      0|#define ImSin(X)            sinf(X)
  ------------------
 1216|      0|    }
 1217|      0|    else
 1218|      0|    {
 1219|      0|        const float arc_length = ImAbs(a_max - a_min);
 1220|      0|        const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
 1221|      0|        const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  442|      0|#define ImCeil(X)           ceilf(X)
  ------------------
                      const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  254|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1222|      0|        _PathArcToN(center, radius, a_min, a_max, arc_segment_count);
 1223|      0|    }
 1224|      0|}
_ZN10ImDrawList8PathRectERK6ImVec2S2_fi:
 1357|   167k|{
 1358|   167k|    flags = FixRectCornerFlags(flags);
 1359|   167k|    rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((flags & ImDrawFlags_RoundCornersTop)  == ImDrawFlags_RoundCornersTop)  || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f ) - 1.0f);
  ------------------
  |  |  433|   167k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1359:54): [True: 167k, False: 0]
  |  Branch (1359:130): [True: 0, False: 0]
  ------------------
 1360|   167k|    rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight)  == ImDrawFlags_RoundCornersRight)  ? 0.5f : 1.0f ) - 1.0f);
  ------------------
  |  |  433|   167k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1360:54): [True: 167k, False: 0]
  |  Branch (1360:130): [True: 0, False: 0]
  ------------------
 1361|       |
 1362|   167k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1362:9): [True: 153k, False: 13.4k]
  |  Branch (1362:28): [True: 0, False: 13.4k]
  ------------------
 1363|   153k|    {
 1364|   153k|        PathLineTo(a);
 1365|   153k|        PathLineTo(ImVec2(b.x, a.y));
 1366|   153k|        PathLineTo(b);
 1367|   153k|        PathLineTo(ImVec2(a.x, b.y));
 1368|   153k|    }
 1369|  13.4k|    else
 1370|  13.4k|    {
 1371|  13.4k|        const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;
  ------------------
  |  Branch (1371:35): [True: 13.4k, False: 0]
  ------------------
 1372|  13.4k|        const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
  ------------------
  |  Branch (1372:35): [True: 13.4k, False: 0]
  ------------------
 1373|  13.4k|        const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
  ------------------
  |  Branch (1373:35): [True: 13.4k, False: 0]
  ------------------
 1374|  13.4k|        const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
  ------------------
  |  Branch (1374:35): [True: 13.4k, False: 0]
  ------------------
 1375|  13.4k|        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
 1376|  13.4k|        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
 1377|  13.4k|        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
 1378|  13.4k|        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
 1379|  13.4k|    }
 1380|   167k|}
_ZN10ImDrawList7AddLineERK6ImVec2S2_jf:
 1383|    447|{
 1384|    447|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2487|    447|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1384:9): [True: 0, False: 447]
  ------------------
 1385|      0|        return;
 1386|    447|    PathLineTo(p1 + ImVec2(0.5f, 0.5f));
 1387|    447|    PathLineTo(p2 + ImVec2(0.5f, 0.5f));
 1388|    447|    PathStroke(col, 0, thickness);
 1389|    447|}
_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif:
 1394|   201k|{
 1395|   201k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2487|   201k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1395:9): [True: 44.0k, False: 157k]
  ------------------
 1396|  44.0k|        return;
 1397|   157k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (1397:9): [True: 157k, False: 0]
  ------------------
 1398|   157k|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
 1399|      0|    else
 1400|      0|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
 1401|   157k|    PathStroke(col, ImDrawFlags_Closed, thickness);
 1402|   157k|}
_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi:
 1405|   254k|{
 1406|   254k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2487|   254k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1406:9): [True: 0, False: 254k]
  ------------------
 1407|      0|        return;
 1408|   254k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1408:9): [True: 245k, False: 9.29k]
  |  Branch (1408:28): [True: 0, False: 9.29k]
  ------------------
 1409|   245k|    {
 1410|   245k|        PrimReserve(6, 4);
 1411|   245k|        PrimRect(p_min, p_max, col);
 1412|   245k|    }
 1413|  9.29k|    else
 1414|  9.29k|    {
 1415|  9.29k|        PathRect(p_min, p_max, rounding, flags);
 1416|  9.29k|        PathFillConvex(col);
 1417|  9.29k|    }
 1418|   254k|}
_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j:
 1472|   110k|{
 1473|   110k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2487|   110k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1473:9): [True: 0, False: 110k]
  ------------------
 1474|      0|        return;
 1475|       |
 1476|   110k|    PathLineTo(p1);
 1477|   110k|    PathLineTo(p2);
 1478|   110k|    PathLineTo(p3);
 1479|   110k|    PathFillConvex(col);
 1480|   110k|}
_ZN10ImDrawList15AddCircleFilledERK6ImVec2fji:
 1507|    807|{
 1508|    807|    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
  ------------------
  |  | 2487|    807|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1508:9): [True: 0, False: 807]
  |  Branch (1508:41): [True: 0, False: 807]
  ------------------
 1509|      0|        return;
 1510|       |
 1511|    807|    if (num_segments <= 0)
  ------------------
  |  Branch (1511:9): [True: 0, False: 807]
  ------------------
 1512|      0|    {
 1513|       |        // Use arc with automatic segment count
 1514|      0|        _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
  ------------------
  |  |  759|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1515|      0|        _Path.Size--;
 1516|      0|    }
 1517|    807|    else
 1518|    807|    {
 1519|       |        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
 1520|    807|        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
  ------------------
  |  |  748|    807|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  ------------------
 1521|       |
 1522|       |        // Because we are filling a closed shape we remove 1 from the count of segments/points
 1523|    807|        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
  ------------------
  |  |  254|    807|#define IM_PI                           3.14159265358979323846f
  ------------------
 1524|    807|        PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
 1525|    807|    }
 1526|       |
 1527|    807|    PathFillConvex(col);
 1528|    807|}
_ZN10ImDrawList7AddTextEPK6ImFontfRK6ImVec2jPKcS7_fPK6ImVec4:
 1577|   140k|{
 1578|   140k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2487|   140k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1578:9): [True: 0, False: 140k]
  ------------------
 1579|      0|        return;
 1580|       |
 1581|   140k|    if (text_end == NULL)
  ------------------
  |  Branch (1581:9): [True: 18.9k, False: 121k]
  ------------------
 1582|  18.9k|        text_end = text_begin + strlen(text_begin);
 1583|   140k|    if (text_begin == text_end)
  ------------------
  |  Branch (1583:9): [True: 0, False: 140k]
  ------------------
 1584|      0|        return;
 1585|       |
 1586|       |    // Pull default font/size from the shared ImDrawListSharedData instance
 1587|   140k|    if (font == NULL)
  ------------------
  |  Branch (1587:9): [True: 140k, False: 0]
  ------------------
 1588|   140k|        font = _Data->Font;
 1589|   140k|    if (font_size == 0.0f)
  ------------------
  |  Branch (1589:9): [True: 140k, False: 0]
  ------------------
 1590|   140k|        font_size = _Data->FontSize;
 1591|       |
 1592|   140k|    IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
  ------------------
  |  |   23|   140k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1593|       |
 1594|   140k|    ImVec4 clip_rect = _CmdHeader.ClipRect;
 1595|   140k|    if (cpu_fine_clip_rect)
  ------------------
  |  Branch (1595:9): [True: 55.4k, False: 84.6k]
  ------------------
 1596|  55.4k|    {
 1597|  55.4k|        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
 1598|  55.4k|        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
 1599|  55.4k|        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
 1600|  55.4k|        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
 1601|  55.4k|    }
 1602|   140k|    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
 1603|   140k|}
_ZN10ImDrawList7AddTextERK6ImVec2jPKcS4_:
 1606|  18.9k|{
 1607|  18.9k|    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
 1608|  18.9k|}
_ZN18ImDrawListSplitter15ClearFreeMemoryEv:
 1676|      1|{
 1677|      1|    for (int i = 0; i < _Channels.Size; i++)
  ------------------
  |  Branch (1677:21): [True: 0, False: 1]
  ------------------
 1678|      0|    {
 1679|      0|        if (i == _Current)
  ------------------
  |  Branch (1679:13): [True: 0, False: 0]
  ------------------
 1680|      0|            memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
 1681|      0|        _Channels[i]._CmdBuffer.clear();
 1682|      0|        _Channels[i]._IdxBuffer.clear();
 1683|      0|    }
 1684|      1|    _Current = 0;
 1685|      1|    _Count = 1;
 1686|      1|    _Channels.clear();
 1687|      1|}
_ZN12ImFontConfigC2Ev:
 1911|      1|{
 1912|      1|    memset(this, 0, sizeof(*this));
 1913|      1|    FontDataOwnedByAtlas = true;
 1914|      1|    OversampleH = 3; // FIXME: 2 may be a better default?
 1915|      1|    OversampleV = 1;
 1916|      1|    GlyphMaxAdvanceX = FLT_MAX;
 1917|      1|    RasterizerMultiply = 1.0f;
 1918|      1|    EllipsisChar = (ImWchar)-1;
 1919|      1|}
_ZN11ImFontAtlasC2Ev:
 1976|      1|{
 1977|      1|    memset(this, 0, sizeof(*this));
 1978|      1|    TexGlyphPadding = 1;
 1979|      1|    PackIdMouseCursors = PackIdLines = -1;
 1980|      1|}
_ZN11ImFontAtlas12ClearTexDataEv:
 2012|      2|{
 2013|      2|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2014|      2|    if (TexPixelsAlpha8)
  ------------------
  |  Branch (2014:9): [True: 0, False: 2]
  ------------------
 2015|      0|        IM_FREE(TexPixelsAlpha8);
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2016|      2|    if (TexPixelsRGBA32)
  ------------------
  |  Branch (2016:9): [True: 0, False: 2]
  ------------------
 2017|      0|        IM_FREE(TexPixelsRGBA32);
  ------------------
  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2018|      2|    TexPixelsAlpha8 = NULL;
 2019|      2|    TexPixelsRGBA32 = NULL;
 2020|      2|    TexPixelsUseColors = false;
 2021|       |    // Important: we leave TexReady untouched
 2022|      2|}
_ZN11ImFontAtlas18GetTexDataAsAlpha8EPPhPiS2_S2_:
 2039|      1|{
 2040|       |    // Build atlas on demand
 2041|      1|    if (TexPixelsAlpha8 == NULL)
  ------------------
  |  Branch (2041:9): [True: 1, False: 0]
  ------------------
 2042|      1|        Build();
 2043|       |
 2044|      1|    *out_pixels = TexPixelsAlpha8;
 2045|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2045:9): [True: 0, False: 1]
  ------------------
 2046|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2046:9): [True: 0, False: 1]
  ------------------
 2047|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
  ------------------
  |  Branch (2047:9): [True: 0, False: 1]
  ------------------
 2048|      1|}
_ZN11ImFontAtlas18GetTexDataAsRGBA32EPPhPiS2_S2_:
 2051|      1|{
 2052|       |    // Convert to RGBA32 format on demand
 2053|       |    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
 2054|      1|    if (!TexPixelsRGBA32)
  ------------------
  |  Branch (2054:9): [True: 1, False: 0]
  ------------------
 2055|      1|    {
 2056|      1|        unsigned char* pixels = NULL;
 2057|      1|        GetTexDataAsAlpha8(&pixels, NULL, NULL);
 2058|      1|        if (pixels)
  ------------------
  |  Branch (2058:13): [True: 1, False: 0]
  ------------------
 2059|      1|        {
 2060|      1|            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2061|      1|            const unsigned char* src = pixels;
 2062|      1|            unsigned int* dst = TexPixelsRGBA32;
 2063|  32.7k|            for (int n = TexWidth * TexHeight; n > 0; n--)
  ------------------
  |  Branch (2063:48): [True: 32.7k, False: 1]
  ------------------
 2064|  32.7k|                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
  ------------------
  |  | 2490|  32.7k|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2486|  32.7k|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2485|  32.7k|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2484|  32.7k|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2483|  32.7k|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2065|      1|        }
 2066|      1|    }
 2067|       |
 2068|      1|    *out_pixels = (unsigned char*)TexPixelsRGBA32;
 2069|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2069:9): [True: 1, False: 0]
  ------------------
 2070|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2070:9): [True: 1, False: 0]
  ------------------
 2071|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
  ------------------
  |  Branch (2071:9): [True: 0, False: 1]
  ------------------
 2072|      1|}
_ZN11ImFontAtlas7AddFontEPK12ImFontConfig:
 2075|      1|{
 2076|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2077|      1|    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2078|      1|    IM_ASSERT(font_cfg->SizePixels > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2079|       |
 2080|       |    // Create new font
 2081|      1|    if (!font_cfg->MergeMode)
  ------------------
  |  Branch (2081:9): [True: 1, False: 0]
  ------------------
 2082|      1|        Fonts.push_back(IM_NEW(ImFont));
  ------------------
  |  | 1863|      1|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 2083|      0|    else
 2084|      1|        IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2085|       |
 2086|      1|    ConfigData.push_back(*font_cfg);
 2087|      1|    ImFontConfig& new_font_cfg = ConfigData.back();
 2088|      1|    if (new_font_cfg.DstFont == NULL)
  ------------------
  |  Branch (2088:9): [True: 1, False: 0]
  ------------------
 2089|      1|        new_font_cfg.DstFont = Fonts.back();
 2090|      1|    if (!new_font_cfg.FontDataOwnedByAtlas)
  ------------------
  |  Branch (2090:9): [True: 0, False: 1]
  ------------------
 2091|      0|    {
 2092|      0|        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
  ------------------
  |  | 1860|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2093|      0|        new_font_cfg.FontDataOwnedByAtlas = true;
 2094|      0|        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
 2095|      0|    }
 2096|       |
 2097|      1|    if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (2097:9): [True: 1, False: 0]
  ------------------
 2098|      1|        new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;
 2099|       |
 2100|       |    // Invalidate texture
 2101|      1|    TexReady = false;
 2102|      1|    ClearTexData();
 2103|      1|    return new_font_cfg.DstFont;
 2104|      1|}
_ZN11ImFontAtlas14AddFontDefaultEPK12ImFontConfig:
 2124|      1|{
 2125|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2125:29): [True: 0, False: 1]
  ------------------
 2126|      1|    if (!font_cfg_template)
  ------------------
  |  Branch (2126:9): [True: 1, False: 0]
  ------------------
 2127|      1|    {
 2128|      1|        font_cfg.OversampleH = font_cfg.OversampleV = 1;
 2129|      1|        font_cfg.PixelSnapH = true;
 2130|      1|    }
 2131|      1|    if (font_cfg.SizePixels <= 0.0f)
  ------------------
  |  Branch (2131:9): [True: 1, False: 0]
  ------------------
 2132|      1|        font_cfg.SizePixels = 13.0f * 1.0f;
 2133|      1|    if (font_cfg.Name[0] == '\0')
  ------------------
  |  Branch (2133:9): [True: 1, False: 0]
  ------------------
 2134|      1|        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 2135|      1|    font_cfg.EllipsisChar = (ImWchar)0x0085;
 2136|      1|    font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units
  ------------------
  |  |  266|      1|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 2137|       |
 2138|      1|    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
 2139|      1|    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
  ------------------
  |  Branch (2139:35): [True: 0, False: 1]
  ------------------
 2140|      1|    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
 2141|      1|    return font;
 2142|      1|}
_ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt:
 2167|      1|{
 2168|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2169|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2169:29): [True: 1, False: 0]
  ------------------
 2170|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2171|      1|    font_cfg.FontData = ttf_data;
 2172|      1|    font_cfg.FontDataSize = ttf_size;
 2173|      1|    font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
  ------------------
  |  Branch (2173:27): [True: 1, False: 0]
  ------------------
 2174|      1|    if (glyph_ranges)
  ------------------
  |  Branch (2174:9): [True: 1, False: 0]
  ------------------
 2175|      1|        font_cfg.GlyphRanges = glyph_ranges;
 2176|      1|    return AddFont(&font_cfg);
 2177|      1|}
_ZN11ImFontAtlas30AddFontFromMemoryCompressedTTFEPKvifPK12ImFontConfigPKt:
 2180|      1|{
 2181|      1|    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
 2182|      1|    unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2183|      1|    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
 2184|       |
 2185|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2185:29): [True: 1, False: 0]
  ------------------
 2186|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2187|      1|    font_cfg.FontDataOwnedByAtlas = true;
 2188|      1|    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
 2189|      1|}
_ZN11ImFontAtlas36AddFontFromMemoryCompressedBase85TTFEPKcfPK12ImFontConfigPKt:
 2192|      1|{
 2193|      1|    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
 2194|      1|    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2195|      1|    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
 2196|      1|    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
 2197|      1|    IM_FREE(compressed_ttf);
  ------------------
  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2198|      1|    return font;
 2199|      1|}
_ZN11ImFontAtlas20AddCustomRectRegularEii:
 2202|      2|{
 2203|      2|    IM_ASSERT(width > 0 && width <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2204|      2|    IM_ASSERT(height > 0 && height <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2205|      2|    ImFontAtlasCustomRect r;
 2206|      2|    r.Width = (unsigned short)width;
 2207|      2|    r.Height = (unsigned short)height;
 2208|      2|    CustomRects.push_back(r);
 2209|      2|    return CustomRects.Size - 1; // Return index
 2210|      2|}
_ZN11ImFontAtlas5BuildEv:
 2261|      1|{
 2262|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2263|       |
 2264|       |    // Default font is none are specified
 2265|      1|    if (ConfigData.Size == 0)
  ------------------
  |  Branch (2265:9): [True: 1, False: 0]
  ------------------
 2266|      1|        AddFontDefault();
 2267|       |
 2268|       |    // Select builder
 2269|       |    // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
 2270|       |    //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
 2271|       |    //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
 2272|       |    //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
 2273|      1|    const ImFontBuilderIO* builder_io = FontBuilderIO;
 2274|      1|    if (builder_io == NULL)
  ------------------
  |  Branch (2274:9): [True: 1, False: 0]
  ------------------
 2275|      1|    {
 2276|       |#ifdef IMGUI_ENABLE_FREETYPE
 2277|       |        builder_io = ImGuiFreeType::GetBuilderForFreeType();
 2278|       |#elif defined(IMGUI_ENABLE_STB_TRUETYPE)
 2279|      1|        builder_io = ImFontAtlasGetBuilderForStbTruetype();
 2280|       |#else
 2281|       |        IM_ASSERT(0); // Invalid Build function
 2282|       |#endif
 2283|      1|    }
 2284|       |
 2285|       |    // Build
 2286|      1|    return builder_io->FontBuilder_Build(this);
 2287|      1|}
_Z35ImFontAtlasGetBuilderForStbTruetypev:
 2598|      1|{
 2599|      1|    static ImFontBuilderIO io;
 2600|      1|    io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
 2601|      1|    return &io;
 2602|      1|}
_Z25ImFontAtlasBuildSetupFontP11ImFontAtlasP6ImFontP12ImFontConfigff:
 2607|      1|{
 2608|      1|    if (!font_config->MergeMode)
  ------------------
  |  Branch (2608:9): [True: 1, False: 0]
  ------------------
 2609|      1|    {
 2610|      1|        font->ClearOutputData();
 2611|      1|        font->FontSize = font_config->SizePixels;
 2612|      1|        font->ConfigData = font_config;
 2613|      1|        font->ConfigDataCount = 0;
 2614|      1|        font->ContainerAtlas = atlas;
 2615|      1|        font->Ascent = ascent;
 2616|      1|        font->Descent = descent;
 2617|      1|    }
 2618|      1|    font->ConfigDataCount++;
 2619|      1|}
_Z31ImFontAtlasBuildPackCustomRectsP11ImFontAtlasPv:
 2622|      1|{
 2623|      1|    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
 2624|      1|    IM_ASSERT(pack_context != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2625|       |
 2626|      1|    ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
 2627|      1|    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2628|       |
 2629|      1|    ImVector<stbrp_rect> pack_rects;
 2630|      1|    pack_rects.resize(user_rects.Size);
 2631|      1|    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
 2632|      3|    for (int i = 0; i < user_rects.Size; i++)
  ------------------
  |  Branch (2632:21): [True: 2, False: 1]
  ------------------
 2633|      2|    {
 2634|      2|        pack_rects[i].w = user_rects[i].Width;
 2635|      2|        pack_rects[i].h = user_rects[i].Height;
 2636|      2|    }
 2637|      1|    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
 2638|      3|    for (int i = 0; i < pack_rects.Size; i++)
  ------------------
  |  Branch (2638:21): [True: 2, False: 1]
  ------------------
 2639|      2|        if (pack_rects[i].was_packed)
  ------------------
  |  Branch (2639:13): [True: 2, False: 0]
  ------------------
 2640|      2|        {
 2641|      2|            user_rects[i].X = (unsigned short)pack_rects[i].x;
 2642|      2|            user_rects[i].Y = (unsigned short)pack_rects[i].y;
 2643|      2|            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2644|      2|            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
 2645|      2|        }
 2646|      1|}
_Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch:
 2649|      2|{
 2650|      2|    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2651|      2|    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2652|      2|    unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
 2653|     56|    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
  ------------------
  |  Branch (2653:25): [True: 54, False: 2]
  ------------------
 2654|  6.64k|        for (int off_x = 0; off_x < w; off_x++)
  ------------------
  |  Branch (2654:29): [True: 6.58k, False: 54]
  ------------------
 2655|  6.58k|            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
  ------------------
  |  Branch (2655:32): [True: 1.12k, False: 5.46k]
  ------------------
 2656|      2|}
_Z20ImFontAtlasBuildInitP11ImFontAtlas:
 2761|      1|{
 2762|       |    // Register texture region for mouse cursors or standard white pixels
 2763|      1|    if (atlas->PackIdMouseCursors < 0)
  ------------------
  |  Branch (2763:9): [True: 1, False: 0]
  ------------------
 2764|      1|    {
 2765|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (2765:13): [True: 1, False: 0]
  ------------------
 2766|      1|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
 2767|      0|        else
 2768|      0|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
 2769|      1|    }
 2770|       |
 2771|       |    // Register texture region for thick lines
 2772|       |    // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
 2773|      1|    if (atlas->PackIdLines < 0)
  ------------------
  |  Branch (2773:9): [True: 1, False: 0]
  ------------------
 2774|      1|    {
 2775|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (2775:13): [True: 1, False: 0]
  ------------------
 2776|      1|            atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2523|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
                          atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2523|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
 2777|      1|    }
 2778|      1|}
_Z22ImFontAtlasBuildFinishP11ImFontAtlas:
 2782|      1|{
 2783|       |    // Render into our custom data blocks
 2784|      1|    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2785|      1|    ImFontAtlasBuildRenderDefaultTexData(atlas);
 2786|      1|    ImFontAtlasBuildRenderLinesTexData(atlas);
 2787|       |
 2788|       |    // Register custom rectangle glyphs
 2789|      3|    for (int i = 0; i < atlas->CustomRects.Size; i++)
  ------------------
  |  Branch (2789:21): [True: 2, False: 1]
  ------------------
 2790|      2|    {
 2791|      2|        const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
 2792|      2|        if (r->Font == NULL || r->GlyphID == 0)
  ------------------
  |  Branch (2792:13): [True: 2, False: 0]
  |  Branch (2792:32): [True: 0, False: 0]
  ------------------
 2793|      2|            continue;
 2794|       |
 2795|       |        // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
 2796|      0|        IM_ASSERT(r->Font->ContainerAtlas == atlas);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2797|      0|        ImVec2 uv0, uv1;
 2798|      0|        atlas->CalcCustomRectUV(r, &uv0, &uv1);
 2799|      0|        r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
 2800|      0|    }
 2801|       |
 2802|       |    // Build all fonts lookup tables
 2803|      2|    for (int i = 0; i < atlas->Fonts.Size; i++)
  ------------------
  |  Branch (2803:21): [True: 1, False: 1]
  ------------------
 2804|      1|        if (atlas->Fonts[i]->DirtyLookupTables)
  ------------------
  |  Branch (2804:13): [True: 1, False: 0]
  ------------------
 2805|      1|            atlas->Fonts[i]->BuildLookupTable();
 2806|       |
 2807|      1|    atlas->TexReady = true;
 2808|      1|}
_ZN11ImFontAtlas21GetGlyphRangesDefaultEv:
 2812|      1|{
 2813|      1|    static const ImWchar ranges[] =
 2814|      1|    {
 2815|      1|        0x0020, 0x00FF, // Basic Latin + Latin Supplement
 2816|      1|        0,
 2817|      1|    };
 2818|      1|    return &ranges[0];
 2819|      1|}
_ZN6ImFontC2Ev:
 3118|      2|{
 3119|      2|    FontSize = 0.0f;
 3120|      2|    FallbackAdvanceX = 0.0f;
 3121|      2|    FallbackChar = (ImWchar)-1;
 3122|      2|    EllipsisChar = (ImWchar)-1;
 3123|      2|    DotChar = (ImWchar)-1;
 3124|      2|    FallbackGlyph = NULL;
 3125|      2|    ContainerAtlas = NULL;
 3126|      2|    ConfigData = NULL;
 3127|      2|    ConfigDataCount = 0;
 3128|      2|    DirtyLookupTables = false;
 3129|      2|    Scale = 1.0f;
 3130|      2|    Ascent = Descent = 0.0f;
 3131|      2|    MetricsTotalSurface = 0;
 3132|      2|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3133|      2|}
_ZN6ImFont15ClearOutputDataEv:
 3141|      1|{
 3142|      1|    FontSize = 0.0f;
 3143|      1|    FallbackAdvanceX = 0.0f;
 3144|      1|    Glyphs.clear();
 3145|      1|    IndexAdvanceX.clear();
 3146|      1|    IndexLookup.clear();
 3147|      1|    FallbackGlyph = NULL;
 3148|      1|    ContainerAtlas = NULL;
 3149|      1|    DirtyLookupTables = true;
 3150|      1|    Ascent = Descent = 0.0f;
 3151|      1|    MetricsTotalSurface = 0;
 3152|      1|}
_ZN6ImFont16BuildLookupTableEv:
 3163|      1|{
 3164|      1|    int max_codepoint = 0;
 3165|    224|    for (int i = 0; i != Glyphs.Size; i++)
  ------------------
  |  Branch (3165:21): [True: 223, False: 1]
  ------------------
 3166|    223|        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);
 3167|       |
 3168|       |    // Build lookup table
 3169|      1|    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3170|      1|    IndexAdvanceX.clear();
 3171|      1|    IndexLookup.clear();
 3172|      1|    DirtyLookupTables = false;
 3173|      1|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3174|      1|    GrowIndex(max_codepoint + 1);
 3175|    224|    for (int i = 0; i < Glyphs.Size; i++)
  ------------------
  |  Branch (3175:21): [True: 223, False: 1]
  ------------------
 3176|    223|    {
 3177|    223|        int codepoint = (int)Glyphs[i].Codepoint;
 3178|    223|        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
 3179|    223|        IndexLookup[codepoint] = (ImWchar)i;
 3180|       |
 3181|       |        // Mark 4K page as used
 3182|    223|        const int page_n = codepoint / 4096;
 3183|    223|        Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
 3184|    223|    }
 3185|       |
 3186|       |    // Create a glyph to handle TAB
 3187|       |    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
 3188|      1|    if (FindGlyph((ImWchar)' '))
  ------------------
  |  Branch (3188:9): [True: 1, False: 0]
  ------------------
 3189|      1|    {
 3190|      1|        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
  ------------------
  |  Branch (3190:13): [True: 1, False: 0]
  ------------------
 3191|      1|            Glyphs.resize(Glyphs.Size + 1);
 3192|      1|        ImFontGlyph& tab_glyph = Glyphs.back();
 3193|      1|        tab_glyph = *FindGlyph((ImWchar)' ');
 3194|      1|        tab_glyph.Codepoint = '\t';
 3195|      1|        tab_glyph.AdvanceX *= IM_TABSIZE;
  ------------------
  |  |  261|      1|#define IM_TABSIZE                      (4)
  ------------------
 3196|      1|        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
 3197|      1|        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
 3198|      1|    }
 3199|       |
 3200|       |    // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
 3201|      1|    SetGlyphVisible((ImWchar)' ', false);
 3202|      1|    SetGlyphVisible((ImWchar)'\t', false);
 3203|       |
 3204|       |    // Ellipsis character is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
 3205|       |    // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
 3206|       |    // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
 3207|      1|    const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
 3208|      1|    const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
 3209|      1|    if (EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (3209:9): [True: 0, False: 1]
  ------------------
 3210|      0|        EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
  ------------------
  |  |   87|      0|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3211|      1|    if (DotChar == (ImWchar)-1)
  ------------------
  |  Branch (3211:9): [True: 1, False: 0]
  ------------------
 3212|      1|        DotChar = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3213|       |
 3214|       |    // Setup fallback character
 3215|      1|    const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
  ------------------
  |  | 2314|      1|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 3216|      1|    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3217|      1|    if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3217:9): [True: 1, False: 0]
  ------------------
 3218|      1|    {
 3219|      1|        FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3220|      1|        FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3221|      1|        if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3221:13): [True: 0, False: 1]
  ------------------
 3222|      0|        {
 3223|      0|            FallbackGlyph = &Glyphs.back();
 3224|      0|            FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
 3225|      0|        }
 3226|      1|    }
 3227|       |
 3228|      1|    FallbackAdvanceX = FallbackGlyph->AdvanceX;
 3229|    257|    for (int i = 0; i < max_codepoint + 1; i++)
  ------------------
  |  Branch (3229:21): [True: 256, False: 1]
  ------------------
 3230|    256|        if (IndexAdvanceX[i] < 0.0f)
  ------------------
  |  Branch (3230:13): [True: 32, False: 224]
  ------------------
 3231|     32|            IndexAdvanceX[i] = FallbackAdvanceX;
 3232|      1|}
_ZN6ImFont15SetGlyphVisibleEtb:
 3248|      2|{
 3249|      2|    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))
  ------------------
  |  Branch (3249:22): [True: 2, False: 0]
  ------------------
 3250|      2|        glyph->Visible = visible ? 1 : 0;
  ------------------
  |  Branch (3250:26): [True: 0, False: 2]
  ------------------
 3251|      2|}
_ZN6ImFont9GrowIndexEi:
 3254|      1|{
 3255|      1|    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3256|      1|    if (new_size <= IndexLookup.Size)
  ------------------
  |  Branch (3256:9): [True: 0, False: 1]
  ------------------
 3257|      0|        return;
 3258|      1|    IndexAdvanceX.resize(new_size, -1.0f);
 3259|      1|    IndexLookup.resize(new_size, (ImWchar)-1);
 3260|      1|}
_ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff:
 3266|    223|{
 3267|    223|    if (cfg != NULL)
  ------------------
  |  Branch (3267:9): [True: 223, False: 0]
  ------------------
 3268|    223|    {
 3269|       |        // Clamp & recenter if needed
 3270|    223|        const float advance_x_original = advance_x;
 3271|    223|        advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
 3272|    223|        if (advance_x != advance_x_original)
  ------------------
  |  Branch (3272:13): [True: 0, False: 223]
  ------------------
 3273|      0|        {
 3274|      0|            float char_off_x = cfg->PixelSnapH ? ImFloor((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
  ------------------
  |  Branch (3274:32): [True: 0, False: 0]
  ------------------
 3275|      0|            x0 += char_off_x;
 3276|      0|            x1 += char_off_x;
 3277|      0|        }
 3278|       |
 3279|       |        // Snap to pixel
 3280|    223|        if (cfg->PixelSnapH)
  ------------------
  |  Branch (3280:13): [True: 223, False: 0]
  ------------------
 3281|    223|            advance_x = IM_ROUND(advance_x);
  ------------------
  |  |  267|    223|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 3282|       |
 3283|       |        // Bake spacing
 3284|    223|        advance_x += cfg->GlyphExtraSpacing.x;
 3285|    223|    }
 3286|       |
 3287|    223|    Glyphs.resize(Glyphs.Size + 1);
 3288|    223|    ImFontGlyph& glyph = Glyphs.back();
 3289|    223|    glyph.Codepoint = (unsigned int)codepoint;
 3290|    223|    glyph.Visible = (x0 != x1) && (y0 != y1);
  ------------------
  |  Branch (3290:21): [True: 214, False: 9]
  |  Branch (3290:35): [True: 214, False: 0]
  ------------------
 3291|    223|    glyph.Colored = false;
 3292|    223|    glyph.X0 = x0;
 3293|    223|    glyph.Y0 = y0;
 3294|    223|    glyph.X1 = x1;
 3295|    223|    glyph.Y1 = y1;
 3296|    223|    glyph.U0 = u0;
 3297|    223|    glyph.V0 = v0;
 3298|    223|    glyph.U1 = u1;
 3299|    223|    glyph.V1 = v1;
 3300|    223|    glyph.AdvanceX = advance_x;
 3301|       |
 3302|       |    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
 3303|       |    // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
 3304|    223|    float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
 3305|    223|    DirtyLookupTables = true;
 3306|    223|    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
 3307|    223|}
_ZNK6ImFont9FindGlyphEt:
 3325|   957k|{
 3326|   957k|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3326:9): [True: 135, False: 957k]
  ------------------
 3327|    135|        return FallbackGlyph;
 3328|   957k|    const ImWchar i = IndexLookup.Data[c];
 3329|   957k|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3329:9): [True: 58, False: 957k]
  ------------------
 3330|     58|        return FallbackGlyph;
 3331|   957k|    return &Glyphs.Data[i];
 3332|   957k|}
_ZNK6ImFont19FindGlyphNoFallbackEt:
 3335|      5|{
 3336|      5|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3336:9): [True: 2, False: 3]
  ------------------
 3337|      2|        return NULL;
 3338|      3|    const ImWchar i = IndexLookup.Data[c];
 3339|      3|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3339:9): [True: 0, False: 3]
  ------------------
 3340|      0|        return NULL;
 3341|      3|    return &Glyphs.Data[i];
 3342|      3|}
_ZNK6ImFont13CalcTextSizeAEfffPKcS1_PS1_:
 3457|   209k|{
 3458|   209k|    if (!text_end)
  ------------------
  |  Branch (3458:9): [True: 88.0k, False: 121k]
  ------------------
 3459|  88.0k|        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.
 3460|       |
 3461|   209k|    const float line_height = size;
 3462|   209k|    const float scale = size / FontSize;
 3463|       |
 3464|   209k|    ImVec2 text_size = ImVec2(0, 0);
 3465|   209k|    float line_width = 0.0f;
 3466|       |
 3467|   209k|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 3468|   209k|    const char* word_wrap_eol = NULL;
 3469|       |
 3470|   209k|    const char* s = text_begin;
 3471|  1.34M|    while (s < text_end)
  ------------------
  |  Branch (3471:12): [True: 1.13M, False: 209k]
  ------------------
 3472|  1.13M|    {
 3473|  1.13M|        if (word_wrap_enabled)
  ------------------
  |  Branch (3473:13): [True: 0, False: 1.13M]
  ------------------
 3474|      0|        {
 3475|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 3476|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (3476:17): [True: 0, False: 0]
  ------------------
 3477|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
 3478|       |
 3479|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (3479:17): [True: 0, False: 0]
  ------------------
 3480|      0|            {
 3481|      0|                if (text_size.x < line_width)
  ------------------
  |  Branch (3481:21): [True: 0, False: 0]
  ------------------
 3482|      0|                    text_size.x = line_width;
 3483|      0|                text_size.y += line_height;
 3484|      0|                line_width = 0.0f;
 3485|      0|                word_wrap_eol = NULL;
 3486|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 3487|      0|                continue;
 3488|      0|            }
 3489|      0|        }
 3490|       |
 3491|       |        // Decode and advance source
 3492|  1.13M|        const char* prev_s = s;
 3493|  1.13M|        unsigned int c = (unsigned int)*s;
 3494|  1.13M|        if (c < 0x80)
  ------------------
  |  Branch (3494:13): [True: 1.12M, False: 12.3k]
  ------------------
 3495|  1.12M|        {
 3496|  1.12M|            s += 1;
 3497|  1.12M|        }
 3498|  12.3k|        else
 3499|  12.3k|        {
 3500|  12.3k|            s += ImTextCharFromUtf8(&c, s, text_end);
 3501|  12.3k|            if (c == 0) // Malformed UTF-8?
  ------------------
  |  Branch (3501:17): [True: 0, False: 12.3k]
  ------------------
 3502|      0|                break;
 3503|  12.3k|        }
 3504|       |
 3505|  1.13M|        if (c < 32)
  ------------------
  |  Branch (3505:13): [True: 1.65k, False: 1.13M]
  ------------------
 3506|  1.65k|        {
 3507|  1.65k|            if (c == '\n')
  ------------------
  |  Branch (3507:17): [True: 0, False: 1.65k]
  ------------------
 3508|      0|            {
 3509|      0|                text_size.x = ImMax(text_size.x, line_width);
 3510|      0|                text_size.y += line_height;
 3511|      0|                line_width = 0.0f;
 3512|      0|                continue;
 3513|      0|            }
 3514|  1.65k|            if (c == '\r')
  ------------------
  |  Branch (3514:17): [True: 167, False: 1.49k]
  ------------------
 3515|    167|                continue;
 3516|  1.65k|        }
 3517|       |
 3518|  1.13M|        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
  ------------------
  |  Branch (3518:35): [True: 1.12M, False: 9.16k]
  ------------------
 3519|  1.13M|        if (line_width + char_width >= max_width)
  ------------------
  |  Branch (3519:13): [True: 0, False: 1.13M]
  ------------------
 3520|      0|        {
 3521|      0|            s = prev_s;
 3522|      0|            break;
 3523|      0|        }
 3524|       |
 3525|  1.13M|        line_width += char_width;
 3526|  1.13M|    }
 3527|       |
 3528|   209k|    if (text_size.x < line_width)
  ------------------
  |  Branch (3528:9): [True: 208k, False: 159]
  ------------------
 3529|   208k|        text_size.x = line_width;
 3530|       |
 3531|   209k|    if (line_width > 0 || text_size.y == 0.0f)
  ------------------
  |  Branch (3531:9): [True: 208k, False: 159]
  |  Branch (3531:27): [True: 159, False: 0]
  ------------------
 3532|   209k|        text_size.y += line_height;
 3533|       |
 3534|   209k|    if (remaining)
  ------------------
  |  Branch (3534:9): [True: 0, False: 209k]
  ------------------
 3535|      0|        *remaining = s;
 3536|       |
 3537|   209k|    return text_size;
 3538|   209k|}
_ZNK6ImFont10RenderTextEP10ImDrawListfRK6ImVec2jRK6ImVec4PKcS9_fb:
 3557|   140k|{
 3558|   140k|    if (!text_end)
  ------------------
  |  Branch (3558:9): [True: 0, False: 140k]
  ------------------
 3559|      0|        text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.
 3560|       |
 3561|       |    // Align to be pixel perfect
 3562|   140k|    float x = IM_FLOOR(pos.x);
  ------------------
  |  |  266|   140k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 3563|   140k|    float y = IM_FLOOR(pos.y);
  ------------------
  |  |  266|   140k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 3564|   140k|    if (y > clip_rect.w)
  ------------------
  |  Branch (3564:9): [True: 17.5k, False: 122k]
  ------------------
 3565|  17.5k|        return;
 3566|       |
 3567|   122k|    const float start_x = x;
 3568|   122k|    const float scale = size / FontSize;
 3569|   122k|    const float line_height = FontSize * scale;
 3570|   122k|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 3571|       |
 3572|       |    // Fast-forward to first visible line
 3573|   122k|    const char* s = text_begin;
 3574|   122k|    if (y + line_height < clip_rect.y)
  ------------------
  |  Branch (3574:9): [True: 4.17k, False: 118k]
  ------------------
 3575|  8.34k|        while (y + line_height < clip_rect.y && s < text_end)
  ------------------
  |  Branch (3575:16): [True: 4.17k, False: 4.17k]
  |  Branch (3575:49): [True: 4.17k, False: 0]
  ------------------
 3576|  4.17k|        {
 3577|  4.17k|            const char* line_end = (const char*)memchr(s, '\n', text_end - s);
 3578|  4.17k|            const char* line_next = line_end ? line_end + 1 : text_end;
  ------------------
  |  Branch (3578:37): [True: 0, False: 4.17k]
  ------------------
 3579|  4.17k|            if (word_wrap_enabled)
  ------------------
  |  Branch (3579:17): [True: 0, False: 4.17k]
  ------------------
 3580|      0|            {
 3581|       |                // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
 3582|       |                // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
 3583|       |                // However it is still better than nothing performing the fast-forward!
 3584|      0|                s = CalcWordWrapPositionA(scale, s, line_next, wrap_width);
 3585|      0|                s = CalcWordWrapNextLineStartA(s, text_end);
 3586|      0|            }
 3587|  4.17k|            else
 3588|  4.17k|            {
 3589|  4.17k|                s = line_next;
 3590|  4.17k|            }
 3591|  4.17k|            y += line_height;
 3592|  4.17k|        }
 3593|       |
 3594|       |    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
 3595|       |    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
 3596|   122k|    if (text_end - s > 10000 && !word_wrap_enabled)
  ------------------
  |  Branch (3596:9): [True: 0, False: 122k]
  |  Branch (3596:33): [True: 0, False: 0]
  ------------------
 3597|      0|    {
 3598|      0|        const char* s_end = s;
 3599|      0|        float y_end = y;
 3600|      0|        while (y_end < clip_rect.w && s_end < text_end)
  ------------------
  |  Branch (3600:16): [True: 0, False: 0]
  |  Branch (3600:39): [True: 0, False: 0]
  ------------------
 3601|      0|        {
 3602|      0|            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
 3603|      0|            s_end = s_end ? s_end + 1 : text_end;
  ------------------
  |  Branch (3603:21): [True: 0, False: 0]
  ------------------
 3604|      0|            y_end += line_height;
 3605|      0|        }
 3606|      0|        text_end = s_end;
 3607|      0|    }
 3608|   122k|    if (s == text_end)
  ------------------
  |  Branch (3608:9): [True: 4.17k, False: 118k]
  ------------------
 3609|  4.17k|        return;
 3610|       |
 3611|       |    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
 3612|   118k|    const int vtx_count_max = (int)(text_end - s) * 4;
 3613|   118k|    const int idx_count_max = (int)(text_end - s) * 6;
 3614|   118k|    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
 3615|   118k|    draw_list->PrimReserve(idx_count_max, vtx_count_max);
 3616|       |
 3617|   118k|    ImDrawVert* vtx_write = draw_list->_VtxWritePtr;
 3618|   118k|    ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
 3619|   118k|    unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;
 3620|       |
 3621|   118k|    const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
  ------------------
  |  | 2487|   118k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 3622|   118k|    const char* word_wrap_eol = NULL;
 3623|       |
 3624|  1.07M|    while (s < text_end)
  ------------------
  |  Branch (3624:12): [True: 957k, False: 118k]
  ------------------
 3625|   957k|    {
 3626|   957k|        if (word_wrap_enabled)
  ------------------
  |  Branch (3626:13): [True: 0, False: 957k]
  ------------------
 3627|      0|        {
 3628|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 3629|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (3629:17): [True: 0, False: 0]
  ------------------
 3630|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));
 3631|       |
 3632|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (3632:17): [True: 0, False: 0]
  ------------------
 3633|      0|            {
 3634|      0|                x = start_x;
 3635|      0|                y += line_height;
 3636|      0|                word_wrap_eol = NULL;
 3637|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 3638|      0|                continue;
 3639|      0|            }
 3640|      0|        }
 3641|       |
 3642|       |        // Decode and advance source
 3643|   957k|        unsigned int c = (unsigned int)*s;
 3644|   957k|        if (c < 0x80)
  ------------------
  |  Branch (3644:13): [True: 957k, False: 193]
  ------------------
 3645|   957k|        {
 3646|   957k|            s += 1;
 3647|   957k|        }
 3648|    193|        else
 3649|    193|        {
 3650|    193|            s += ImTextCharFromUtf8(&c, s, text_end);
 3651|    193|            if (c == 0) // Malformed UTF-8?
  ------------------
  |  Branch (3651:17): [True: 0, False: 193]
  ------------------
 3652|      0|                break;
 3653|    193|        }
 3654|       |
 3655|   957k|        if (c < 32)
  ------------------
  |  Branch (3655:13): [True: 89, False: 957k]
  ------------------
 3656|     89|        {
 3657|     89|            if (c == '\n')
  ------------------
  |  Branch (3657:17): [True: 0, False: 89]
  ------------------
 3658|      0|            {
 3659|      0|                x = start_x;
 3660|      0|                y += line_height;
 3661|      0|                if (y > clip_rect.w)
  ------------------
  |  Branch (3661:21): [True: 0, False: 0]
  ------------------
 3662|      0|                    break; // break out of main loop
 3663|      0|                continue;
 3664|      0|            }
 3665|     89|            if (c == '\r')
  ------------------
  |  Branch (3665:17): [True: 31, False: 58]
  ------------------
 3666|     31|                continue;
 3667|     89|        }
 3668|       |
 3669|   957k|        const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
 3670|   957k|        if (glyph == NULL)
  ------------------
  |  Branch (3670:13): [True: 0, False: 957k]
  ------------------
 3671|      0|            continue;
 3672|       |
 3673|   957k|        float char_width = glyph->AdvanceX * scale;
 3674|   957k|        if (glyph->Visible)
  ------------------
  |  Branch (3674:13): [True: 893k, False: 63.7k]
  ------------------
 3675|   893k|        {
 3676|       |            // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
 3677|   893k|            float x1 = x + glyph->X0 * scale;
 3678|   893k|            float x2 = x + glyph->X1 * scale;
 3679|   893k|            float y1 = y + glyph->Y0 * scale;
 3680|   893k|            float y2 = y + glyph->Y1 * scale;
 3681|   893k|            if (x1 <= clip_rect.z && x2 >= clip_rect.x)
  ------------------
  |  Branch (3681:17): [True: 483k, False: 410k]
  |  Branch (3681:38): [True: 482k, False: 369]
  ------------------
 3682|   482k|            {
 3683|       |                // Render a character
 3684|   482k|                float u1 = glyph->U0;
 3685|   482k|                float v1 = glyph->V0;
 3686|   482k|                float u2 = glyph->U1;
 3687|   482k|                float v2 = glyph->V1;
 3688|       |
 3689|       |                // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
 3690|   482k|                if (cpu_fine_clip)
  ------------------
  |  Branch (3690:21): [True: 102k, False: 380k]
  ------------------
 3691|   102k|                {
 3692|   102k|                    if (x1 < clip_rect.x)
  ------------------
  |  Branch (3692:25): [True: 0, False: 102k]
  ------------------
 3693|      0|                    {
 3694|      0|                        u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
 3695|      0|                        x1 = clip_rect.x;
 3696|      0|                    }
 3697|   102k|                    if (y1 < clip_rect.y)
  ------------------
  |  Branch (3697:25): [True: 11.6k, False: 90.8k]
  ------------------
 3698|  11.6k|                    {
 3699|  11.6k|                        v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
 3700|  11.6k|                        y1 = clip_rect.y;
 3701|  11.6k|                    }
 3702|   102k|                    if (x2 > clip_rect.z)
  ------------------
  |  Branch (3702:25): [True: 51.2k, False: 51.2k]
  ------------------
 3703|  51.2k|                    {
 3704|  51.2k|                        u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
 3705|  51.2k|                        x2 = clip_rect.z;
 3706|  51.2k|                    }
 3707|   102k|                    if (y2 > clip_rect.w)
  ------------------
  |  Branch (3707:25): [True: 0, False: 102k]
  ------------------
 3708|      0|                    {
 3709|      0|                        v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
 3710|      0|                        y2 = clip_rect.w;
 3711|      0|                    }
 3712|   102k|                    if (y1 >= y2)
  ------------------
  |  Branch (3712:25): [True: 0, False: 102k]
  ------------------
 3713|      0|                    {
 3714|      0|                        x += char_width;
 3715|      0|                        continue;
 3716|      0|                    }
 3717|   102k|                }
 3718|       |
 3719|       |                // Support for untinted glyphs
 3720|   482k|                ImU32 glyph_col = glyph->Colored ? col_untinted : col;
  ------------------
  |  Branch (3720:35): [True: 0, False: 482k]
  ------------------
 3721|       |
 3722|       |                // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
 3723|   482k|                {
 3724|   482k|                    idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);
 3725|   482k|                    idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);
 3726|   482k|                    vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
 3727|   482k|                    vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
 3728|   482k|                    vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
 3729|   482k|                    vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
 3730|   482k|                    vtx_write += 4;
 3731|   482k|                    vtx_current_idx += 4;
 3732|   482k|                    idx_write += 6;
 3733|   482k|                }
 3734|   482k|            }
 3735|   893k|        }
 3736|   957k|        x += char_width;
 3737|   957k|    }
 3738|       |
 3739|       |    // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
 3740|   118k|    draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
 3741|   118k|    draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
 3742|   118k|    draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
 3743|   118k|    draw_list->_VtxWritePtr = vtx_write;
 3744|   118k|    draw_list->_IdxWritePtr = idx_write;
 3745|   118k|    draw_list->_VtxCurrentIdx = vtx_current_idx;
 3746|   118k|}
_ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2jif:
 3766|   110k|{
 3767|   110k|    const float h = draw_list->_Data->FontSize * 1.00f;
 3768|   110k|    float r = h * 0.40f * scale;
 3769|   110k|    ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
 3770|       |
 3771|   110k|    ImVec2 a, b, c;
 3772|   110k|    switch (dir)
  ------------------
  |  Branch (3772:13): [True: 0, False: 110k]
  ------------------
 3773|   110k|    {
 3774|      0|    case ImGuiDir_Up:
  ------------------
  |  Branch (3774:5): [True: 0, False: 110k]
  ------------------
 3775|  66.8k|    case ImGuiDir_Down:
  ------------------
  |  Branch (3775:5): [True: 66.8k, False: 44.0k]
  ------------------
 3776|  66.8k|        if (dir == ImGuiDir_Up) r = -r;
  ------------------
  |  Branch (3776:13): [True: 0, False: 66.8k]
  ------------------
 3777|  66.8k|        a = ImVec2(+0.000f, +0.750f) * r;
 3778|  66.8k|        b = ImVec2(-0.866f, -0.750f) * r;
 3779|  66.8k|        c = ImVec2(+0.866f, -0.750f) * r;
 3780|  66.8k|        break;
 3781|      0|    case ImGuiDir_Left:
  ------------------
  |  Branch (3781:5): [True: 0, False: 110k]
  ------------------
 3782|  44.0k|    case ImGuiDir_Right:
  ------------------
  |  Branch (3782:5): [True: 44.0k, False: 66.8k]
  ------------------
 3783|  44.0k|        if (dir == ImGuiDir_Left) r = -r;
  ------------------
  |  Branch (3783:13): [True: 0, False: 44.0k]
  ------------------
 3784|  44.0k|        a = ImVec2(+0.750f, +0.000f) * r;
 3785|  44.0k|        b = ImVec2(-0.750f, +0.866f) * r;
 3786|  44.0k|        c = ImVec2(-0.750f, -0.866f) * r;
 3787|  44.0k|        break;
 3788|      0|    case ImGuiDir_None:
  ------------------
  |  Branch (3788:5): [True: 0, False: 110k]
  ------------------
 3789|      0|    case ImGuiDir_COUNT:
  ------------------
  |  Branch (3789:5): [True: 0, False: 110k]
  ------------------
 3790|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3791|      0|        break;
 3792|   110k|    }
 3793|   110k|    draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
 3794|   110k|}
imgui_draw.cpp:_ZL18FixRectCornerFlagsi:
 1323|   167k|{
 1324|       |#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
 1325|       |    // Obsoleted in 1.82 (from February 2021)
 1326|       |    // Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
 1327|       |    //   ~0   --> ImDrawFlags_RoundCornersAll or 0
 1328|       |    if (flags == ~0)
 1329|       |        return ImDrawFlags_RoundCornersAll;
 1330|       |
 1331|       |    // Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations)
 1332|       |    //   0x01 --> ImDrawFlags_RoundCornersTopLeft (VALUE 0x01 OVERLAPS ImDrawFlags_Closed but ImDrawFlags_Closed is never valid in this path!)
 1333|       |    //   0x02 --> ImDrawFlags_RoundCornersTopRight
 1334|       |    //   0x03 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight
 1335|       |    //   0x04 --> ImDrawFlags_RoundCornersBotLeft
 1336|       |    //   0x05 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBotLeft
 1337|       |    //   ...
 1338|       |    //   0x0F --> ImDrawFlags_RoundCornersAll or 0
 1339|       |    // (See all values in ImDrawCornerFlags_)
 1340|       |    if (flags >= 0x01 && flags <= 0x0F)
 1341|       |        return (flags << 4);
 1342|       |
 1343|       |    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
 1344|       |#endif
 1345|       |
 1346|       |    // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
 1347|       |    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
 1348|   167k|    IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");
  ------------------
  |  |   23|   167k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1349|       |
 1350|   167k|    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
  ------------------
  |  Branch (1350:9): [True: 167k, False: 0]
  ------------------
 1351|   167k|        flags |= ImDrawFlags_RoundCornersAll;
 1352|       |
 1353|   167k|    return flags;
 1354|   167k|}
imgui_draw.cpp:_ZL8Decode85PKhPh:
 2112|      1|{
 2113|  2.39k|    while (*src)
  ------------------
  |  Branch (2113:12): [True: 2.39k, False: 1]
  ------------------
 2114|  2.39k|    {
 2115|  2.39k|        unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
 2116|  2.39k|        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
 2117|  2.39k|        src += 5;
 2118|  2.39k|        dst += 4;
 2119|  2.39k|    }
 2120|      1|}
imgui_draw.cpp:_ZL12Decode85Bytec:
 2110|  11.9k|static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
  ------------------
  |  Branch (2110:86): [True: 3.28k, False: 8.70k]
  ------------------
imgui_draw.cpp:_ZL31ImFontAtlasBuildWithStbTruetypeP11ImFontAtlas:
 2346|      1|{
 2347|      1|    IM_ASSERT(atlas->ConfigData.Size > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2348|       |
 2349|      1|    ImFontAtlasBuildInit(atlas);
 2350|       |
 2351|       |    // Clear atlas
 2352|      1|    atlas->TexID = (ImTextureID)NULL;
 2353|      1|    atlas->TexWidth = atlas->TexHeight = 0;
 2354|      1|    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
 2355|      1|    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
 2356|      1|    atlas->ClearTexData();
 2357|       |
 2358|       |    // Temporary storage for building
 2359|      1|    ImVector<ImFontBuildSrcData> src_tmp_array;
 2360|      1|    ImVector<ImFontBuildDstData> dst_tmp_array;
 2361|      1|    src_tmp_array.resize(atlas->ConfigData.Size);
 2362|      1|    dst_tmp_array.resize(atlas->Fonts.Size);
 2363|      1|    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
 2364|      1|    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());
 2365|       |
 2366|       |    // 1. Initialize font loading structure, check font data validity
 2367|      2|    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
  ------------------
  |  Branch (2367:25): [True: 1, False: 1]
  ------------------
 2368|      1|    {
 2369|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2370|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2371|      1|        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2372|       |
 2373|       |        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
 2374|      1|        src_tmp.DstIndex = -1;
 2375|      2|        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
  ------------------
  |  Branch (2375:32): [True: 1, False: 1]
  |  Branch (2375:64): [True: 1, False: 0]
  ------------------
 2376|      1|            if (cfg.DstFont == atlas->Fonts[output_i])
  ------------------
  |  Branch (2376:17): [True: 1, False: 0]
  ------------------
 2377|      1|                src_tmp.DstIndex = output_i;
 2378|      1|        if (src_tmp.DstIndex == -1)
  ------------------
  |  Branch (2378:13): [True: 0, False: 1]
  ------------------
 2379|      0|        {
 2380|      0|            IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2381|      0|            return false;
 2382|      0|        }
 2383|       |        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
 2384|      1|        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
 2385|      1|        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2386|      1|        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
  ------------------
  |  Branch (2386:13): [True: 0, False: 1]
  ------------------
 2387|      0|            return false;
 2388|       |
 2389|       |        // Measure highest codepoints
 2390|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2391|      1|        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
  ------------------
  |  Branch (2391:29): [True: 1, False: 0]
  ------------------
 2392|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2392:60): [True: 1, False: 1]
  |  Branch (2392:76): [True: 1, False: 0]
  ------------------
 2393|      1|            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
 2394|      1|        dst_tmp.SrcCount++;
 2395|      1|        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
 2396|      1|    }
 2397|       |
 2398|       |    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
 2399|      1|    int total_glyphs_count = 0;
 2400|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2400:25): [True: 1, False: 1]
  ------------------
 2401|      1|    {
 2402|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2403|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2404|      1|        src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
 2405|      1|        if (dst_tmp.GlyphsSet.Storage.empty())
  ------------------
  |  Branch (2405:13): [True: 1, False: 0]
  ------------------
 2406|      1|            dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);
 2407|       |
 2408|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2408:60): [True: 1, False: 1]
  |  Branch (2408:76): [True: 1, False: 0]
  ------------------
 2409|    225|            for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
  ------------------
  |  Branch (2409:57): [True: 224, False: 1]
  ------------------
 2410|    224|            {
 2411|    224|                if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
  ------------------
  |  Branch (2411:21): [True: 0, False: 224]
  ------------------
 2412|      0|                    continue;
 2413|    224|                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
  ------------------
  |  Branch (2413:21): [True: 1, False: 223]
  ------------------
 2414|      1|                    continue;
 2415|       |
 2416|       |                // Add to avail set/counters
 2417|    223|                src_tmp.GlyphsCount++;
 2418|    223|                dst_tmp.GlyphsCount++;
 2419|    223|                src_tmp.GlyphsSet.SetBit(codepoint);
 2420|    223|                dst_tmp.GlyphsSet.SetBit(codepoint);
 2421|    223|                total_glyphs_count++;
 2422|    223|            }
 2423|      1|    }
 2424|       |
 2425|       |    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
 2426|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2426:25): [True: 1, False: 1]
  ------------------
 2427|      1|    {
 2428|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2429|      1|        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
 2430|      1|        UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
 2431|      1|        src_tmp.GlyphsSet.Clear();
 2432|      1|        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2433|      1|    }
 2434|      2|    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
  ------------------
  |  Branch (2434:25): [True: 1, False: 1]
  ------------------
 2435|      1|        dst_tmp_array[dst_i].GlyphsSet.Clear();
 2436|      1|    dst_tmp_array.clear();
 2437|       |
 2438|       |    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
 2439|       |    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
 2440|      1|    ImVector<stbrp_rect> buf_rects;
 2441|      1|    ImVector<stbtt_packedchar> buf_packedchars;
 2442|      1|    buf_rects.resize(total_glyphs_count);
 2443|      1|    buf_packedchars.resize(total_glyphs_count);
 2444|      1|    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
 2445|      1|    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());
 2446|       |
 2447|       |    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
 2448|      1|    int total_surface = 0;
 2449|      1|    int buf_rects_out_n = 0;
 2450|      1|    int buf_packedchars_out_n = 0;
 2451|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2451:25): [True: 1, False: 1]
  ------------------
 2452|      1|    {
 2453|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2454|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2454:13): [True: 0, False: 1]
  ------------------
 2455|      0|            continue;
 2456|       |
 2457|      1|        src_tmp.Rects = &buf_rects[buf_rects_out_n];
 2458|      1|        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
 2459|      1|        buf_rects_out_n += src_tmp.GlyphsCount;
 2460|      1|        buf_packedchars_out_n += src_tmp.GlyphsCount;
 2461|       |
 2462|       |        // Convert our ranges in the format stb_truetype wants
 2463|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2464|      1|        src_tmp.PackRange.font_size = cfg.SizePixels;
 2465|      1|        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
 2466|      1|        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
 2467|      1|        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
 2468|      1|        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
 2469|      1|        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
 2470|      1|        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;
 2471|       |
 2472|       |        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
 2473|      1|        const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);
  ------------------
  |  Branch (2473:29): [True: 1, False: 0]
  ------------------
 2474|      1|        const int padding = atlas->TexGlyphPadding;
 2475|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
  ------------------
  |  Branch (2475:31): [True: 223, False: 1]
  ------------------
 2476|    223|        {
 2477|    223|            int x0, y0, x1, y1;
 2478|    223|            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
 2479|    223|            IM_ASSERT(glyph_index_in_font != 0);
  ------------------
  |  |   23|    223|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2480|    223|            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
 2481|    223|            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
 2482|    223|            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
 2483|    223|            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
 2484|    223|        }
 2485|      1|    }
 2486|       |
 2487|       |    // We need a width for the skyline algorithm, any width!
 2488|       |    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
 2489|       |    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
 2490|      1|    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
  ------------------
  |  |  434|      1|#define ImSqrt(X)           sqrtf(X)
  ------------------
 2491|      1|    atlas->TexHeight = 0;
 2492|      1|    if (atlas->TexDesiredWidth > 0)
  ------------------
  |  Branch (2492:9): [True: 0, False: 1]
  ------------------
 2493|      0|        atlas->TexWidth = atlas->TexDesiredWidth;
 2494|      1|    else
 2495|      1|        atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;
  ------------------
  |  Branch (2495:27): [True: 0, False: 1]
  |  Branch (2495:66): [True: 0, False: 1]
  |  Branch (2495:105): [True: 0, False: 1]
  ------------------
 2496|       |
 2497|       |    // 5. Start packing
 2498|       |    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
 2499|      1|    const int TEX_HEIGHT_MAX = 1024 * 32;
 2500|      1|    stbtt_pack_context spc = {};
 2501|      1|    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
 2502|      1|    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);
 2503|       |
 2504|       |    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
 2505|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2505:25): [True: 1, False: 1]
  ------------------
 2506|      1|    {
 2507|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2508|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2508:13): [True: 0, False: 1]
  ------------------
 2509|      0|            continue;
 2510|       |
 2511|      1|        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);
 2512|       |
 2513|       |        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
 2514|       |        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
 2515|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (2515:31): [True: 223, False: 1]
  ------------------
 2516|    223|            if (src_tmp.Rects[glyph_i].was_packed)
  ------------------
  |  Branch (2516:17): [True: 223, False: 0]
  ------------------
 2517|    223|                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
 2518|      1|    }
 2519|       |
 2520|       |    // 7. Allocate texture
 2521|      1|    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
  ------------------
  |  Branch (2521:24): [True: 0, False: 1]
  ------------------
 2522|      1|    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
 2523|      1|    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
  ------------------
  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2524|      1|    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
 2525|      1|    spc.pixels = atlas->TexPixelsAlpha8;
 2526|      1|    spc.height = atlas->TexHeight;
 2527|       |
 2528|       |    // 8. Render/rasterize font characters into the texture
 2529|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2529:25): [True: 1, False: 1]
  ------------------
 2530|      1|    {
 2531|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2532|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2533|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2533:13): [True: 0, False: 1]
  ------------------
 2534|      0|            continue;
 2535|       |
 2536|      1|        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);
 2537|       |
 2538|       |        // Apply multiply operator
 2539|      1|        if (cfg.RasterizerMultiply != 1.0f)
  ------------------
  |  Branch (2539:13): [True: 0, False: 1]
  ------------------
 2540|      0|        {
 2541|      0|            unsigned char multiply_table[256];
 2542|      0|            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
 2543|      0|            stbrp_rect* r = &src_tmp.Rects[0];
 2544|      0|            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
  ------------------
  |  Branch (2544:35): [True: 0, False: 0]
  ------------------
 2545|      0|                if (r->was_packed)
  ------------------
  |  Branch (2545:21): [True: 0, False: 0]
  ------------------
 2546|      0|                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
 2547|      0|        }
 2548|      1|        src_tmp.Rects = NULL;
 2549|      1|    }
 2550|       |
 2551|       |    // End packing
 2552|      1|    stbtt_PackEnd(&spc);
 2553|      1|    buf_rects.clear();
 2554|       |
 2555|       |    // 9. Setup ImFont and glyphs for runtime
 2556|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2556:25): [True: 1, False: 1]
  ------------------
 2557|      1|    {
 2558|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2559|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2559:13): [True: 0, False: 1]
  ------------------
 2560|      0|            continue;
 2561|       |
 2562|       |        // When merging fonts with MergeMode=true:
 2563|       |        // - We can have multiple input fonts writing into a same destination font.
 2564|       |        // - dst_font->ConfigData is != from cfg which is our source configuration.
 2565|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2566|      1|        ImFont* dst_font = cfg.DstFont;
 2567|       |
 2568|      1|        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
 2569|      1|        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
 2570|      1|        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
 2571|       |
 2572|      1|        const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));
  ------------------
  |  Branch (2572:70): [True: 1, False: 0]
  ------------------
 2573|      1|        const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));
  ------------------
  |  Branch (2573:72): [True: 0, False: 1]
  ------------------
 2574|      1|        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
 2575|      1|        const float font_off_x = cfg.GlyphOffset.x;
 2576|      1|        const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);
  ------------------
  |  |  267|      1|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 2577|       |
 2578|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (2578:31): [True: 223, False: 1]
  ------------------
 2579|    223|        {
 2580|       |            // Register glyph
 2581|    223|            const int codepoint = src_tmp.GlyphsList[glyph_i];
 2582|    223|            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
 2583|    223|            stbtt_aligned_quad q;
 2584|    223|            float unused_x = 0.0f, unused_y = 0.0f;
 2585|    223|            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
 2586|    223|            dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);
 2587|    223|        }
 2588|      1|    }
 2589|       |
 2590|       |    // Cleanup
 2591|      1|    src_tmp_array.clear_destruct();
 2592|       |
 2593|      1|    ImFontAtlasBuildFinish(atlas);
 2594|      1|    return true;
 2595|      1|}
imgui_draw.cpp:_ZL30UnpackBitVectorToFlatIndexListPK11ImBitVectorP8ImVectorIiE:
 2334|      1|{
 2335|      1|    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2336|      1|    const ImU32* it_begin = in->Storage.begin();
 2337|      1|    const ImU32* it_end = in->Storage.end();
 2338|      9|    for (const ImU32* it = it_begin; it < it_end; it++)
  ------------------
  |  Branch (2338:38): [True: 8, False: 1]
  ------------------
 2339|      8|        if (ImU32 entries_32 = *it)
  ------------------
  |  Branch (2339:19): [True: 7, False: 1]
  ------------------
 2340|    231|            for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
  ------------------
  |  Branch (2340:35): [True: 224, False: 7]
  ------------------
 2341|    224|                if (entries_32 & ((ImU32)1 << bit_n))
  ------------------
  |  Branch (2341:21): [True: 223, False: 1]
  ------------------
 2342|    223|                    out->push_back((int)(((it - it_begin) << 5) + bit_n));
 2343|      1|}
imgui_draw.cpp:_ZL36ImFontAtlasBuildRenderDefaultTexDataP11ImFontAtlas:
 2669|      1|{
 2670|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
 2671|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2672|       |
 2673|      1|    const int w = atlas->TexWidth;
 2674|      1|    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (2674:9): [True: 1, False: 0]
  ------------------
 2675|      1|    {
 2676|       |        // Render/copy pixels
 2677|      1|        IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2678|      1|        const int x_for_white = r->X;
 2679|      1|        const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
 2680|      1|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2680:13): [True: 1, False: 0]
  ------------------
 2681|      1|        {
 2682|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
 2683|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
 2684|      1|        }
 2685|      0|        else
 2686|      0|        {
 2687|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
  ------------------
  |  | 2491|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2688|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
  ------------------
  |  | 2491|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2689|      0|        }
 2690|      1|    }
 2691|      0|    else
 2692|      0|    {
 2693|       |        // Render 4 white pixels
 2694|      0|        IM_ASSERT(r->Width == 2 && r->Height == 2);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2695|      0|        const int offset = (int)r->X + (int)r->Y * w;
 2696|      0|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2696:13): [True: 0, False: 0]
  ------------------
 2697|      0|        {
 2698|      0|            atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
 2699|      0|        }
 2700|      0|        else
 2701|      0|        {
 2702|      0|            atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
  ------------------
  |  | 2491|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2703|      0|        }
 2704|      0|    }
 2705|      1|    atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
 2706|      1|}
imgui_draw.cpp:_ZL34ImFontAtlasBuildRenderLinesTexDataP11ImFontAtlas:
 2709|      1|{
 2710|      1|    if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
  ------------------
  |  Branch (2710:9): [True: 0, False: 1]
  ------------------
 2711|      0|        return;
 2712|       |
 2713|       |    // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
 2714|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
 2715|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2716|     65|    for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
  ------------------
  |  | 2523|     65|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (2716:30): [True: 64, False: 1]
  ------------------
 2717|     64|    {
 2718|       |        // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
 2719|     64|        unsigned int y = n;
 2720|     64|        unsigned int line_width = n;
 2721|     64|        unsigned int pad_left = (r->Width - line_width) / 2;
 2722|     64|        unsigned int pad_right = r->Width - (pad_left + line_width);
 2723|       |
 2724|       |        // Write each slice
 2725|     64|        IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
  ------------------
  |  |   23|     64|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2726|     64|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2726:13): [True: 64, False: 0]
  ------------------
 2727|     64|        {
 2728|     64|            unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
 2729|  1.12k|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (2729:38): [True: 1.05k, False: 64]
  ------------------
 2730|  1.05k|                *(write_ptr + i) = 0x00;
 2731|       |
 2732|  2.08k|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (2732:38): [True: 2.01k, False: 64]
  ------------------
 2733|  2.01k|                *(write_ptr + pad_left + i) = 0xFF;
 2734|       |
 2735|  1.15k|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (2735:38): [True: 1.08k, False: 64]
  ------------------
 2736|  1.08k|                *(write_ptr + pad_left + line_width + i) = 0x00;
 2737|     64|        }
 2738|      0|        else
 2739|      0|        {
 2740|      0|            unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
 2741|      0|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (2741:38): [True: 0, False: 0]
  ------------------
 2742|      0|                *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2743|       |
 2744|      0|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (2744:38): [True: 0, False: 0]
  ------------------
 2745|      0|                *(write_ptr + pad_left + i) = IM_COL32_WHITE;
  ------------------
  |  | 2491|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2746|       |
 2747|      0|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (2747:38): [True: 0, False: 0]
  ------------------
 2748|      0|                *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2490|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2486|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2485|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2484|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2483|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2749|      0|        }
 2750|       |
 2751|       |        // Calculate UVs for this line
 2752|     64|        ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
 2753|     64|        ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
 2754|     64|        float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
 2755|     64|        atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
 2756|     64|    }
 2757|      1|}
imgui_draw.cpp:_ZL22FindFirstExistingGlyphP6ImFontPKti:
 3155|      2|{
 3156|      3|    for (int n = 0; n < candidate_chars_count; n++)
  ------------------
  |  Branch (3156:21): [True: 3, False: 0]
  ------------------
 3157|      3|        if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
  ------------------
  |  Branch (3157:13): [True: 2, False: 1]
  ------------------
 3158|      2|            return candidate_chars[n];
 3159|      0|    return (ImWchar)-1;
 3160|      2|}
imgui_draw.cpp:_ZL21stb_decompress_lengthPKh:
 3984|      2|{
 3985|      2|    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
 3986|      2|}
imgui_draw.cpp:_ZL14stb_decompressPhPKhj:
 4062|      1|{
 4063|      1|    if (stb__in4(0) != 0x57bC0000) return 0;
  ------------------
  |  | 4011|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4010|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4009|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4063:9): [True: 0, False: 1]
  ------------------
 4064|      1|    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
  ------------------
  |  | 4011|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4010|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4009|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4064:9): [True: 0, False: 1]
  ------------------
 4065|      1|    const unsigned int olen = stb_decompress_length(i);
 4066|      1|    stb__barrier_in_b = i;
 4067|      1|    stb__barrier_out_e = output + olen;
 4068|      1|    stb__barrier_out_b = output;
 4069|      1|    i += 16;
 4070|       |
 4071|      1|    stb__dout = output;
 4072|  2.98k|    for (;;) {
 4073|  2.98k|        const unsigned char *old_i = i;
 4074|  2.98k|        i = stb_decompress_token(i);
 4075|  2.98k|        if (i == old_i) {
  ------------------
  |  Branch (4075:13): [True: 1, False: 2.98k]
  ------------------
 4076|      1|            if (*i == 0x05 && i[1] == 0xfa) {
  ------------------
  |  Branch (4076:17): [True: 1, False: 0]
  |  Branch (4076:31): [True: 1, False: 0]
  ------------------
 4077|      1|                IM_ASSERT(stb__dout == output + olen);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4078|      1|                if (stb__dout != output + olen) return 0;
  ------------------
  |  Branch (4078:21): [True: 0, False: 1]
  ------------------
 4079|      1|                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
  ------------------
  |  | 4011|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4010|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4009|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4079:21): [True: 0, False: 1]
  ------------------
 4080|      0|                    return 0;
 4081|      1|                return olen;
 4082|      1|            } else {
 4083|      0|                IM_ASSERT(0); /* NOTREACHED */
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4084|      0|                return 0;
 4085|      0|            }
 4086|      1|        }
 4087|  2.98k|        IM_ASSERT(stb__dout <= output + olen);
  ------------------
  |  |   23|  2.98k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4088|  2.98k|        if (stb__dout > output + olen)
  ------------------
  |  Branch (4088:13): [True: 0, False: 2.98k]
  ------------------
 4089|      0|            return 0;
 4090|  2.98k|    }
 4091|      1|}
imgui_draw.cpp:_ZL20stb_decompress_tokenPKh:
 4014|  2.98k|{
 4015|  2.98k|    if (*i >= 0x20) { // use fewer if's for cases that expand small
  ------------------
  |  Branch (4015:9): [True: 2.86k, False: 119]
  ------------------
 4016|  2.86k|        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
  ------------------
  |  Branch (4016:13): [True: 818, False: 2.04k]
  ------------------
 4017|  2.04k|        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
  ------------------
  |  | 4009|  1.39k|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4017:18): [True: 1.39k, False: 653]
  ------------------
 4018|    653|        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
 4019|  2.86k|    } else { // more ifs for cases that expand large, since overhead is amortized
 4020|    119|        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
  ------------------
  |  | 4010|    111|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4009|    111|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4020:13): [True: 111, False: 8]
  ------------------
 4021|      8|        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4010|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4009|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4009|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4021:18): [True: 0, False: 8]
  ------------------
 4022|      8|        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4009|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4009|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4022:18): [True: 7, False: 1]
  ------------------
 4023|      1|        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4009|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4009|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4023:18): [True: 0, False: 1]
  ------------------
 4024|      1|        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
  ------------------
  |  | 4010|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4009|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4024:18): [True: 0, False: 1]
  ------------------
 4025|      1|        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4010|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4009|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4009|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4025:18): [True: 0, False: 1]
  ------------------
 4026|    119|    }
 4027|  2.98k|    return i;
 4028|  2.98k|}
imgui_draw.cpp:_ZL10stb__matchPKhj:
 3992|  2.32k|{
 3993|       |    // INVERSE of memmove... write each byte before copying the next...
 3994|  2.32k|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|  2.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3995|  2.32k|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (3995:9): [True: 0, False: 2.32k]
  ------------------
 3996|  2.32k|    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (3996:9): [True: 0, False: 2.32k]
  ------------------
 3997|  40.8k|    while (length--) *stb__dout++ = *data++;
  ------------------
  |  Branch (3997:12): [True: 38.5k, False: 2.32k]
  ------------------
 3998|  2.32k|}
imgui_draw.cpp:_ZL8stb__litPKhj:
 4001|    660|{
 4002|    660|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|    660|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4003|    660|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (4003:9): [True: 0, False: 660]
  ------------------
 4004|    660|    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (4004:9): [True: 0, False: 660]
  ------------------
 4005|    660|    memcpy(stb__dout, data, length);
 4006|    660|    stb__dout += length;
 4007|    660|}
imgui_draw.cpp:_ZL11stb_adler32jPhj:
 4031|      1|{
 4032|      1|    const unsigned long ADLER_MOD = 65521;
 4033|      1|    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
 4034|      1|    unsigned long blocklen = buflen % 5552;
 4035|       |
 4036|      1|    unsigned long i;
 4037|      9|    while (buflen) {
  ------------------
  |  Branch (4037:12): [True: 8, False: 1]
  ------------------
 4038|  5.15k|        for (i=0; i + 7 < blocklen; i += 8) {
  ------------------
  |  Branch (4038:19): [True: 5.15k, False: 8]
  ------------------
 4039|  5.15k|            s1 += buffer[0], s2 += s1;
 4040|  5.15k|            s1 += buffer[1], s2 += s1;
 4041|  5.15k|            s1 += buffer[2], s2 += s1;
 4042|  5.15k|            s1 += buffer[3], s2 += s1;
 4043|  5.15k|            s1 += buffer[4], s2 += s1;
 4044|  5.15k|            s1 += buffer[5], s2 += s1;
 4045|  5.15k|            s1 += buffer[6], s2 += s1;
 4046|  5.15k|            s1 += buffer[7], s2 += s1;
 4047|       |
 4048|  5.15k|            buffer += 8;
 4049|  5.15k|        }
 4050|       |
 4051|      8|        for (; i < blocklen; ++i)
  ------------------
  |  Branch (4051:16): [True: 0, False: 8]
  ------------------
 4052|      0|            s1 += *buffer++, s2 += s1;
 4053|       |
 4054|      8|        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
 4055|      8|        buflen -= blocklen;
 4056|      8|        blocklen = 5552;
 4057|      8|    }
 4058|      1|    return (unsigned int)(s2 << 16) + (unsigned int)s1;
 4059|      1|}
imgui_draw.cpp:_ZL37GetDefaultCompressedFontDataTTFBase85v:
 4194|      1|{
 4195|      1|    return proggy_clean_ttf_compressed_data_base85;
 4196|      1|}

imgui.cpp:_ZL7ImFloorRK6ImVec2:
  481|   180k|static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }
imgui.cpp:_ZmlRK6ImVec2f:
  389|   399k|static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui.cpp:_ZL7ImFloorf:
  479|  1.19M|static inline float  ImFloor(float f)                                           { return (float)(int)(f); }
_ZN15ImGuiInputEventC2Ev:
 1307|  8.18k|    ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }
_ZN5ImGui18IsNamedKeyOrModKeyE8ImGuiKey:
 3098|   151k|    inline bool             IsNamedKeyOrModKey(ImGuiKey key)                            { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super || key == ImGuiMod_Shortcut; }
  ------------------
  |  Branch (3098:99): [True: 151k, False: 0]
  |  Branch (3098:133): [True: 121k, False: 29.7k]
  |  Branch (3098:165): [True: 26.4k, False: 3.22k]
  |  Branch (3098:189): [True: 1.09k, False: 2.12k]
  |  Branch (3098:214): [True: 1.51k, False: 612]
  |  Branch (3098:237): [True: 612, False: 0]
  |  Branch (3098:262): [True: 0, False: 0]
  ------------------
_ZN5ImGui10IsAliasKeyE8ImGuiKey:
 3103|   394k|    inline bool             IsAliasKey(ImGuiKey key)                                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1244|   788k|#define ImGuiKey_Aliases_BEGIN          (ImGuiKey_Mouse_BEGIN)
  |  |  ------------------
  |  |  |  | 1242|   394k|#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)
  |  |  ------------------
  ------------------
                  inline bool             IsAliasKey(ImGuiKey key)                                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1245|   389k|#define ImGuiKey_Aliases_END            (ImGuiKey_Mouse_END)
  |  |  ------------------
  |  |  |  | 1243|   389k|#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)
  |  |  ------------------
  ------------------
  |  Branch (3103:98): [True: 389k, False: 4.22k]
  |  Branch (3103:131): [True: 387k, False: 1.98k]
  ------------------
_ZN5ImGui12IsGamepadKeyE8ImGuiKey:
 3101|  5.71k|    inline bool             IsGamepadKey(ImGuiKey key)                                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1240|  11.4k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                  inline bool             IsGamepadKey(ImGuiKey key)                                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1241|  2.02k|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (3101:98): [True: 2.02k, False: 3.69k]
  |  Branch (3101:131): [True: 46, False: 1.97k]
  ------------------
_ZN5ImGui10IsNamedKeyE8ImGuiKey:
 3097|  1.68M|    inline bool             IsNamedKey(ImGuiKey key)                                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }
  ------------------
  |  Branch (3097:98): [True: 1.68M, False: 5]
  |  Branch (3097:132): [True: 1.68M, False: 6]
  ------------------
imgui.cpp:_ZL13ImFloorSignedf:
  480|  21.2k|static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (480:99): [True: 19.7k, False: 1.56k]
  |  Branch (480:109): [True: 1.24k, False: 316]
  ------------------
imgui.cpp:_ZL11ImLengthSqrRK6ImVec2:
  476|  22.8k|static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }
imgui.cpp:_ZmiRK6ImVec2S1_:
  392|   802k|static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui.cpp:_ZplRK6ImVec2S1_:
  391|  1.58M|static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui.cpp:_ZL10ImSaturatef:
  475|  3.55M|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (475:90): [True: 3.54k, False: 3.55M]
  |  Branch (475:110): [True: 9.20k, False: 3.54M]
  ------------------
imgui.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  333|  77.0k|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (333:147): [True: 0, False: 77.0k]
  ------------------
_ZN13ImGuiStyleModC2Ei6ImVec2:
 1009|  65.6k|    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
_ZN6ImRect8ClipWithERKS_:
  554|   278k|    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
imgui.cpp:_ZL5ImMinRK6ImVec2S1_:
  469|   278k|static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (469:97): [True: 260k, False: 18.0k]
  |  Branch (469:128): [True: 260k, False: 17.4k]
  ------------------
_ZN6ImRect6ExpandERK6ImVec2:
  550|  71.7k|    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
_ZNK6ImRect8ContainsERKS_:
  545|     24|    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
  ------------------
  |  Branch (545:62): [True: 8, False: 16]
  |  Branch (545:82): [True: 8, False: 0]
  |  Branch (545:102): [True: 4, False: 4]
  |  Branch (545:122): [True: 4, False: 0]
  ------------------
_ZNK14ImGuiViewportP11GetMainRectEv:
 1734|   271k|    ImRect  GetMainRect() const         { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK6ImRect8OverlapsERKS_:
  546|   166k|    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
  ------------------
  |  Branch (546:62): [True: 162k, False: 4.20k]
  |  Branch (546:82): [True: 155k, False: 6.88k]
  |  Branch (546:102): [True: 148k, False: 6.36k]
  |  Branch (546:122): [True: 146k, False: 2.86k]
  ------------------
_ZN6ImRectC2ERK6ImVec2S2_:
  531|  1.12M|    constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}
_ZN12ImGuiContextC2EP11ImFontAtlas:
 2196|      1|    {
 2197|      1|        Initialized = false;
 2198|      1|        ConfigFlagsCurrFrame = ConfigFlagsLastFrame = ImGuiConfigFlags_None;
 2199|      1|        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
  ------------------
  |  Branch (2199:35): [True: 0, False: 1]
  ------------------
 2200|      1|        Font = NULL;
 2201|      1|        FontSize = FontBaseSize = 0.0f;
 2202|      1|        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
  ------------------
  |  | 1863|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
  |  Branch (2202:20): [True: 0, False: 1]
  ------------------
 2203|      1|        Time = 0.0f;
 2204|      1|        FrameCount = 0;
 2205|      1|        FrameCountEnded = FrameCountPlatformEnded = FrameCountRendered = -1;
 2206|      1|        WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
 2207|      1|        GcCompactAll = false;
 2208|      1|        TestEngineHookItems = false;
 2209|      1|        TestEngine = NULL;
 2210|       |
 2211|      1|        WindowsActiveCount = 0;
 2212|      1|        CurrentWindow = NULL;
 2213|      1|        HoveredWindow = NULL;
 2214|      1|        HoveredWindowUnderMovingWindow = NULL;
 2215|      1|        MovingWindow = NULL;
 2216|      1|        WheelingWindow = NULL;
 2217|      1|        WheelingWindowStartFrame = -1;
 2218|      1|        WheelingWindowReleaseTimer = 0.0f;
 2219|       |
 2220|      1|        DebugHookIdInfo = 0;
 2221|      1|        HoveredId = HoveredIdPreviousFrame = 0;
 2222|      1|        HoveredIdAllowOverlap = false;
 2223|      1|        HoveredIdDisabled = false;
 2224|      1|        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
 2225|      1|        ActiveId = 0;
 2226|      1|        ActiveIdIsAlive = 0;
 2227|      1|        ActiveIdTimer = 0.0f;
 2228|      1|        ActiveIdIsJustActivated = false;
 2229|      1|        ActiveIdAllowOverlap = false;
 2230|      1|        ActiveIdNoClearOnFocusLoss = false;
 2231|      1|        ActiveIdHasBeenPressedBefore = false;
 2232|      1|        ActiveIdHasBeenEditedBefore = false;
 2233|      1|        ActiveIdHasBeenEditedThisFrame = false;
 2234|      1|        ActiveIdClickOffset = ImVec2(-1, -1);
 2235|      1|        ActiveIdWindow = NULL;
 2236|      1|        ActiveIdSource = ImGuiInputSource_None;
 2237|      1|        ActiveIdMouseButton = -1;
 2238|      1|        ActiveIdPreviousFrame = 0;
 2239|      1|        ActiveIdPreviousFrameIsAlive = false;
 2240|      1|        ActiveIdPreviousFrameHasBeenEditedBefore = false;
 2241|      1|        ActiveIdPreviousFrameWindow = NULL;
 2242|      1|        LastActiveId = 0;
 2243|      1|        LastActiveIdTimer = 0.0f;
 2244|       |
 2245|      1|        ActiveIdUsingNavDirMask = 0x00;
 2246|      1|        ActiveIdUsingAllKeyboardKeys = false;
 2247|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 2248|       |        ActiveIdUsingNavInputMask = 0x00;
 2249|       |#endif
 2250|       |
 2251|      1|        CurrentFocusScopeId = 0;
 2252|      1|        CurrentItemFlags = ImGuiItemFlags_None;
 2253|      1|        BeginMenuCount = 0;
 2254|       |
 2255|      1|        CurrentDpiScale = 0.0f;
 2256|      1|        CurrentViewport = NULL;
 2257|      1|        MouseViewport = MouseLastHoveredViewport = NULL;
 2258|      1|        PlatformLastFocusedViewportId = 0;
 2259|      1|        ViewportFrontMostStampCount = 0;
 2260|       |
 2261|      1|        NavWindow = NULL;
 2262|      1|        NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavActivateInputId = 0;
 2263|      1|        NavJustMovedToId = NavJustMovedToFocusScopeId = NavNextActivateId = 0;
 2264|      1|        NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
 2265|      1|        NavJustMovedToKeyMods = ImGuiMod_None;
 2266|      1|        NavInputSource = ImGuiInputSource_None;
 2267|      1|        NavLayer = ImGuiNavLayer_Main;
 2268|      1|        NavIdIsAlive = false;
 2269|      1|        NavMousePosDirty = false;
 2270|      1|        NavDisableHighlight = true;
 2271|      1|        NavDisableMouseHover = false;
 2272|      1|        NavAnyRequest = false;
 2273|      1|        NavInitRequest = false;
 2274|      1|        NavInitRequestFromMove = false;
 2275|      1|        NavInitResultId = 0;
 2276|      1|        NavMoveSubmitted = false;
 2277|      1|        NavMoveScoringItems = false;
 2278|      1|        NavMoveForwardToNextFrame = false;
 2279|      1|        NavMoveFlags = ImGuiNavMoveFlags_None;
 2280|      1|        NavMoveScrollFlags = ImGuiScrollFlags_None;
 2281|      1|        NavMoveKeyMods = ImGuiMod_None;
 2282|      1|        NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
 2283|      1|        NavScoringDebugCount = 0;
 2284|      1|        NavTabbingDir = 0;
 2285|      1|        NavTabbingCounter = 0;
 2286|       |
 2287|      1|        ConfigNavWindowingKeyNext = ImGuiMod_Ctrl | ImGuiKey_Tab;
 2288|      1|        ConfigNavWindowingKeyPrev = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab;
 2289|      1|        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
 2290|      1|        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
 2291|      1|        NavWindowingToggleLayer = false;
 2292|       |
 2293|      1|        DimBgRatio = 0.0f;
 2294|      1|        MouseCursor = ImGuiMouseCursor_Arrow;
 2295|       |
 2296|      1|        DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
 2297|      1|        DragDropSourceFlags = ImGuiDragDropFlags_None;
 2298|      1|        DragDropSourceFrameCount = -1;
 2299|      1|        DragDropMouseButton = -1;
 2300|      1|        DragDropTargetId = 0;
 2301|      1|        DragDropAcceptFlags = ImGuiDragDropFlags_None;
 2302|      1|        DragDropAcceptIdCurrRectSurface = 0.0f;
 2303|      1|        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
 2304|      1|        DragDropAcceptFrameCount = -1;
 2305|      1|        DragDropHoldJustPressedId = 0;
 2306|      1|        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));
 2307|       |
 2308|      1|        ClipperTempDataStacked = 0;
 2309|       |
 2310|      1|        CurrentTable = NULL;
 2311|      1|        TablesTempDataStacked = 0;
 2312|      1|        CurrentTabBar = NULL;
 2313|       |
 2314|      1|        HoverDelayId = HoverDelayIdPreviousFrame = 0;
 2315|      1|        HoverDelayTimer = HoverDelayClearTimer = 0.0f;
 2316|       |
 2317|      1|        TempInputId = 0;
 2318|      1|        ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
 2319|      1|        ColorEditLastHue = ColorEditLastSat = 0.0f;
 2320|      1|        ColorEditLastColor = 0;
 2321|      1|        SliderGrabClickOffset = 0.0f;
 2322|      1|        SliderCurrentAccum = 0.0f;
 2323|      1|        SliderCurrentAccumDirty = false;
 2324|      1|        DragCurrentAccumDirty = false;
 2325|      1|        DragCurrentAccum = 0.0f;
 2326|      1|        DragSpeedDefaultRatio = 1.0f / 100.0f;
 2327|      1|        ScrollbarClickDeltaToGrabCenter = 0.0f;
 2328|      1|        DisabledAlphaBackup = 0.0f;
 2329|      1|        DisabledStackSize = 0;
 2330|      1|        TooltipOverrideCount = 0;
 2331|       |
 2332|      1|        PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
 2333|      1|        PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission
 2334|      1|        PlatformImeViewport = 0;
 2335|      1|        PlatformLocaleDecimalPoint = '.';
 2336|       |
 2337|      1|        SettingsLoaded = false;
 2338|      1|        SettingsDirtyTimer = 0.0f;
 2339|      1|        HookIdNext = 0;
 2340|       |
 2341|      1|        memset(LocalizationTable, 0, sizeof(LocalizationTable));
 2342|       |
 2343|      1|        LogEnabled = false;
 2344|      1|        LogType = ImGuiLogType_None;
 2345|      1|        LogNextPrefix = LogNextSuffix = NULL;
 2346|      1|        LogFile = NULL;
 2347|      1|        LogLinePosY = FLT_MAX;
 2348|      1|        LogLineFirstItem = false;
 2349|      1|        LogDepthRef = 0;
 2350|      1|        LogDepthToExpand = LogDepthToExpandDefault = 2;
 2351|       |
 2352|      1|        DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
 2353|      1|        DebugLocateId = 0;
 2354|      1|        DebugLocateFrames = 0;
 2355|      1|        DebugItemPickerActive = false;
 2356|      1|        DebugItemPickerMouseButton = ImGuiMouseButton_Left;
 2357|      1|        DebugItemPickerBreakId = 0;
 2358|      1|        DebugHoveredDockNode = NULL;
 2359|       |
 2360|      1|        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
 2361|      1|        FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
 2362|      1|        FramerateSecPerFrameAccum = 0.0f;
 2363|      1|        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
 2364|      1|    }
_ZN17ImGuiKeyOwnerDataC2Ev:
 1349|    140|    ImGuiKeyOwnerData()             { OwnerCurr = OwnerNext = ImGuiKeyOwner_None; LockThisFrame = LockUntilRelease = false; }
  ------------------
  |  | 1312|    140|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
_ZN20ImGuiKeyRoutingTableC2Ev:
 1336|      1|    ImGuiKeyRoutingTable()          { Clear(); }
_ZN17ImGuiNextItemDataC2Ev:
 1171|      1|    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); }
_ZN17ImGuiLastItemDataC2Ev:
 1185|   132k|    ImGuiLastItemData()     { memset(this, 0, sizeof(*this)); }
_ZN19ImGuiNextWindowDataC2Ev:
 1152|      1|    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiNavItemDataC2Ev:
 1483|      4|    ImGuiNavItemData()  { Clear(); }
_ZN6ImPoolI10ImGuiTableEC2Ev:
  670|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN6ImPoolI11ImGuiTabBarEC2Ev:
  670|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN19ImGuiInputTextStateC2EP12ImGuiContext:
 1079|      1|    ImGuiInputTextState(ImGuiContext* ctx)  { memset(this, 0, sizeof(*this)); Ctx = ctx;}
_ZN21ImGuiComboPreviewDataC2Ev:
 1022|      1|    ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiDockContextC2Ev:
 1690|      1|    ImGuiDockContext()              { memset(this, 0, sizeof(*this)); }
_ZN18ImGuiMetricsConfigC2Ev:
 1837|      1|    {
 1838|      1|        ShowDebugLog = ShowStackTool = ShowWindowsRects = ShowWindowsBeginOrder = ShowTablesRects = false;
 1839|      1|        ShowDrawCmdMesh = true;
 1840|      1|        ShowDrawCmdBoundingBoxes = true;
 1841|      1|        ShowDockingNodes = false;
 1842|      1|        ShowWindowsRectsType = ShowTablesRectsType = -1;
 1843|      1|    }
_ZN14ImGuiStackToolC2Ev:
 1867|      1|    ImGuiStackTool()        { memset(this, 0, sizeof(*this)); CopyToClipboardLastTime = -FLT_MAX; }
_ZN20ImGuiSettingsHandlerC2Ev:
 1775|      3|    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
_ZN14ImGuiViewportPC2Ev:
 1724|      1|    ImGuiViewportP()                    { Idx = -1; LastFrameActive = DrawListsLastFrame[0] = DrawListsLastFrame[1] = LastFrontMostStampCount = -1; LastNameHash = 0; Alpha = LastAlpha = 1.0f; PlatformMonitor = -1; Window = NULL; DrawLists[0] = DrawLists[1] = NULL; LastPlatformPos = LastPlatformSize = LastRendererSize = ImVec2(FLT_MAX, FLT_MAX); }
_ZN20ImGuiKeyRoutingTable5ClearEv:
 1337|    141|    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Index); n++) Index[n] = -1; Entries.clear(); EntriesNext.clear(); }
  ------------------
  |  |   87|    141|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1337:55): [True: 140, False: 1]
  ------------------
_ZN6ImVec1C2Ev:
  510|     12|    constexpr ImVec1()         : x(0.0f) { }
_ZN16ImGuiMenuColumnsC2Ev:
 1053|      4|    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }
_ZN6ImRectC2Ev:
  530|   462k|    constexpr ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}
_ZN8ImVec2ihC2Ev:
  518|      8|    constexpr ImVec2ih()                           : x(0), y(0) {}
_ZN5ImGui18WindowRectAbsToRelEP11ImGuiWindowRK6ImRect:
 2944|    319|    inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }
_ZN14ImGuiViewportP14UpdateWorkRectEv:
 1731|   110k|    void    UpdateWorkRect()            { WorkPos = CalcWorkRectPos(WorkOffsetMin); WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax); } // Update public fields
_ZNK14ImGuiViewportP15CalcWorkRectPosERK6ImVec2:
 1729|   110k|    ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }
_ZNK14ImGuiViewportP16CalcWorkRectSizeERK6ImVec2S2_:
 1730|   110k|    ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }
_ZNK11ImGuiWindow12TitleBarRectEv:
 2559|   287k|    ImRect      TitleBarRect() const    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
_ZNK6ImRect8ContainsERK6ImVec2:
  544|   336k|    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
  ------------------
  |  Branch (544:62): [True: 37.6k, False: 299k]
  |  Branch (544:82): [True: 26.3k, False: 11.3k]
  |  Branch (544:102): [True: 13.8k, False: 12.5k]
  |  Branch (544:122): [True: 7.28k, False: 6.52k]
  ------------------
imgui.cpp:_ZL5ImMaxRK6ImVec2S1_:
  470|   820k|static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (470:97): [True: 602k, False: 217k]
  |  Branch (470:129): [True: 615k, False: 205k]
  ------------------
_ZN5ImGui14GetDefaultFontEv:
 2959|  55.4k|    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }
  ------------------
  |  Branch (2959:82): [True: 0, False: 55.4k]
  ------------------
_ZN6ImRectC2Effff:
  533|  1.07M|    constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}
_ZN6ImRect3AddERKS_:
  548|   110k|    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
  ------------------
  |  Branch (548:59): [True: 110k, False: 0]
  |  Branch (548:97): [True: 110k, False: 0]
  |  Branch (548:135): [True: 110k, False: 0]
  |  Branch (548:173): [True: 110k, False: 0]
  ------------------
_ZNK6ImRect6ToVec4Ev:
  558|  55.4k|    ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }
_ZN5ImGui16GetCurrentWindowEv:
 2931|   588k|    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
_ZN6ImRectC2ERK6ImVec4:
  532|   529k|    constexpr ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}
_ZN17ImDrawDataBuilder5ClearEv:
  790|   166k|    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
  ------------------
  |  |   87|   166k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (790:55): [True: 110k, False: 55.4k]
  ------------------
_ZNK6ImRect7GetSizeEv:
  536|   132k|    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
imgui.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  463|  41.1k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (463:90): [True: 41.1k, False: 6]
  |  Branch (463:106): [True: 0, False: 6]
  ------------------
_ZN15ImGuiStackSizesC2Ev:
 1200|   132k|    ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }
_ZNK11ImGuiWindow14TitleBarHeightEv:
 2558|   730k|    float       TitleBarHeight() const  { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }
  ------------------
  |  Branch (2558:77): [True: 65.0k, False: 664k]
  ------------------
_ZNK11ImGuiWindow13MenuBarHeightEv:
 2560|   354k|    float       MenuBarHeight() const   { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }
  ------------------
  |  Branch (2560:77): [True: 0, False: 354k]
  ------------------
imgui.cpp:_ZmlRK6ImVec2S1_:
  393|   143k|static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
_ZNK11ImGuiWindow4RectEv:
 2556|   170k|    ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK14ImGuiViewportP11GetWorkRectEv:
 1735|   132k|    ImRect  GetWorkRect() const         { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }
_ZNK6ImRect8GetWidthEv:
  537|   288k|    float       GetWidth() const                    { return Max.x - Min.x; }
_ZNK6ImRect9GetHeightEv:
  538|   273k|    float       GetHeight() const                   { return Max.y - Min.y; }
imgui.cpp:_ZL6ImLerpRK6ImVec2S1_S1_:
  473|  78.1k|static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
imgui.cpp:_ZmIR6ImVec2RKS_:
  398|  13.2k|static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
_ZN6ImRect12ClipWithFullERKS_:
  555|   132k|    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
_ZN19ImGuiNextWindowData10ClearFlagsEv:
 1153|   132k|    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }
_ZNK11ImGuiWindow12CalcFontSizeEv:
 2557|   871k|    float       CalcFontSize() const    { ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale * FontDpiScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }
  ------------------
  |  Branch (2557:137): [True: 15.3k, False: 856k]
  ------------------
imgui.cpp:_ZL14ImIsPowerOfTwoi:
  340|   201k|static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
  ------------------
  |  Branch (340:66): [True: 201k, False: 0]
  |  Branch (340:76): [True: 201k, False: 0]
  ------------------
imgui.cpp:_ZpLR6ImVec2RKS_:
  397|  66.5k|static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
_ZN5ImGui20GetCurrentWindowReadEv:
 2930|  13.5k|    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
_ZN5ImGui25ConvertSingleModFlagToKeyE8ImGuiKey:
 3106|   529k|    {
 3107|   529k|        ImGuiContext& g = *GImGui;
 3108|   529k|        if (key == ImGuiMod_Ctrl) return ImGuiKey_ReservedForModCtrl;
  ------------------
  |  Branch (3108:13): [True: 137k, False: 391k]
  ------------------
 3109|   391k|        if (key == ImGuiMod_Shift) return ImGuiKey_ReservedForModShift;
  ------------------
  |  Branch (3109:13): [True: 111k, False: 279k]
  ------------------
 3110|   279k|        if (key == ImGuiMod_Alt) return ImGuiKey_ReservedForModAlt;
  ------------------
  |  Branch (3110:13): [True: 168k, False: 111k]
  ------------------
 3111|   111k|        if (key == ImGuiMod_Super) return ImGuiKey_ReservedForModSuper;
  ------------------
  |  Branch (3111:13): [True: 111k, False: 0]
  ------------------
 3112|      0|        if (key == ImGuiMod_Shortcut) return (g.IO.ConfigMacOSXBehaviors ? ImGuiKey_ReservedForModSuper : ImGuiKey_ReservedForModCtrl);
  ------------------
  |  Branch (3112:13): [True: 0, False: 0]
  |  Branch (3112:47): [True: 0, False: 0]
  ------------------
 3113|      0|        return key;
 3114|      0|    }
_ZN5ImGui16MouseButtonToKeyEi:
 3118|   277k|    inline ImGuiKey         MouseButtonToKey(ImGuiMouseButton button)                   { IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT); return (ImGuiKey)(ImGuiKey_MouseLeft + button); }
  ------------------
  |  |   23|   277k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui.cpp:_ZL13ImFloorSignedRK6ImVec2:
  482|  8.95k|static inline ImVec2 ImFloorSigned(const ImVec2& v)                             { return ImVec2(ImFloorSigned(v.x), ImFloorSigned(v.y)); }
imgui.cpp:_ZL26ImExponentialMovingAverageffi:
  489|    988|static inline float  ImExponentialMovingAverage(float avg, float sample, int n) { avg -= avg / n; avg += sample / n; return avg; }
imgui.cpp:_ZL5ImAbsf:
  448|  1.00k|static inline float  ImAbs(float x)             { return fabsf(x); }
_ZN5ImGui15GetKeyOwnerDataE8ImGuiKey:
 3142|   148k|    inline ImGuiKeyOwnerData*   GetKeyOwnerData(ImGuiKey key)     { if (key & ImGuiMod_Mask_) key = ConvertSingleModFlagToKey(key); IM_ASSERT(IsNamedKey(key)); return &GImGui->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN]; }
  ------------------
  |  |   23|   148k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (3142:73): [True: 29.7k, False: 118k]
  ------------------
imgui.cpp:_ZL7ImClampRK6ImVec2S1_S_:
  471|   508k|static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
  ------------------
  |  Branch (471:97): [True: 119k, False: 389k]
  |  Branch (471:119): [True: 8.05k, False: 381k]
  |  Branch (471:146): [True: 31.8k, False: 476k]
  |  Branch (471:168): [True: 3.99k, False: 472k]
  ------------------
_ZN16ImGuiNavItemData5ClearEv:
 1484|    848|    void Clear()        { Window = NULL; ID = FocusScopeId = 0; InFlags = 0; DistBox = DistCenter = DistAxial = FLT_MAX; }
_ZN5ImGui21IsActiveIdUsingNavDirEi:
 3125|  29.2k|    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }
_ZN6ImRect10TranslateYEf:
  553|  7.83k|    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
_ZN5ImGui18WindowRectRelToAbsEP11ImGuiWindowRK6ImRect:
 2945|  7.83k|    inline ImRect           WindowRectRelToAbs(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y); }
_ZNK13ImChunkStreamI19ImGuiWindowSettingsE5emptyEv:
  705|      1|    bool    empty() const               { return Buf.Size == 0; }
_ZN14ImGuiViewportP17ClearRequestFlagsEv:
 1726|  55.4k|    void    ClearRequestFlags()         { PlatformRequestClose = PlatformRequestMove = PlatformRequestResize = false; }
_ZNK6ImRect10IsInvertedEv:
  557|  15.6k|    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
  ------------------
  |  Branch (557:62): [True: 0, False: 15.6k]
  |  Branch (557:79): [True: 0, False: 15.6k]
  ------------------
_ZNK6ImRect9GetCenterEv:
  535|    759|    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
_ZN6ImRect6ExpandEf:
  549|  10.4k|    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }
imgui.cpp:_ZL5ImMinIfET_S0_S0_:
  461|   309k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (461:90): [True: 29.9k, False: 279k]
  ------------------
imgui.cpp:_ZL5ImMaxIfET_S0_S0_:
  462|  2.98M|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (462:90): [True: 2.18M, False: 802k]
  ------------------
imgui.cpp:_ZL5ImMinIiET_S0_S0_:
  461|  56.8k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (461:90): [True: 59, False: 56.8k]
  ------------------
imgui.cpp:_ZL6ImSwapIfEvRT_S1_:
  465|  22.7k|template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
_ZN10ImBitArrayILi140ELi0EEC2Ev:
  585|  55.4k|    ImBitArray()                                { ClearAllBits(); }
_ZN10ImBitArrayILi140ELi0EE12ClearAllBitsEv:
  586|  55.4k|    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }
_ZNK10ImBitArrayILi140ELi0EE7TestBitEi:
  588|  2.35k|    bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return ImBitArrayTestBit(Storage, n); }
  ------------------
  |  |   23|  2.35k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_Z17ImBitArrayTestBitPKji:
  563|  2.57k|inline bool     ImBitArrayTestBit(const ImU32* arr, int n)      { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }
_ZN10ImBitArrayILi140ELi0EE6SetBitEi:
  589|  2.42k|    void            SetBit(int n)               { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(Storage, n); }
  ------------------
  |  |   23|  2.42k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_Z16ImBitArraySetBitPji:
  565|  2.87k|inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }
_ZN13ImChunkStreamI19ImGuiWindowSettingsE5beginEv:
  708|      2|    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }
  ------------------
  |  Branch (708:66): [True: 2, False: 0]
  ------------------
_ZN11ImBitVector6CreateEi:
  600|      2|    void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
_ZN11ImBitVector5ClearEv:
  601|      2|    void            Clear()                     { Storage.clear(); }
_ZNK11ImBitVector7TestBitEi:
  602|    224|    bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return ImBitArrayTestBit(Storage.Data, n); }
  ------------------
  |  |   23|    224|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN11ImBitVector6SetBitEi:
  603|    446|    void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui_draw.cpp:_ZL6ImLerpRK6ImVec4S1_f:
  474|      4|static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
imgui_draw.cpp:_ZmlRK6ImVec4S1_:
  403|      1|static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }
imgui_draw.cpp:_ZL7ImRsqrtf:
  453|  1.28M|static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }
imgui_draw.cpp:_ZplRK6ImVec2S1_:
  391|   602k|static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui_draw.cpp:_ZmlRK6ImVec2f:
  389|   334k|static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui_draw.cpp:_ZmiRK6ImVec2S1_:
  392|   158k|static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui_draw.cpp:_ZL5ImAbsi:
  447|  53.9k|static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }
  ------------------
  |  Branch (447:58): [True: 0, False: 53.9k]
  ------------------
imgui_draw.cpp:_ZL13ImFloorSignedf:
  480|  1.28k|static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (480:99): [True: 648, False: 636]
  |  Branch (480:109): [True: 636, False: 0]
  ------------------
imgui_draw.cpp:_ZmlRK6ImVec2S1_:
  393|    128|static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
imgui_draw.cpp:_ZL17ImUpperPowerOfTwoi:
  342|      1|static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
imgui_draw.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  333|      4|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (333:147): [True: 4, False: 0]
  ------------------
imgui_draw.cpp:_ZL7ImFloorf:
  479|      2|static inline float  ImFloor(float f)                                           { return (float)(int)(f); }
imgui_draw.cpp:_ZL5ImMinIfET_S0_S0_:
  461|   444k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (461:90): [True: 320k, False: 124k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIfET_S0_S0_:
  462|   840k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (462:90): [True: 230k, False: 610k]
  ------------------
imgui_draw.cpp:_ZL7ImClampIiET_S0_S0_S0_:
  463|  54.8k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (463:90): [True: 0, False: 54.8k]
  |  Branch (463:106): [True: 0, False: 54.8k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIiET_S0_S0_:
  462|    450|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (462:90): [True: 223, False: 227]
  ------------------
imgui_draw.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  463|    223|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (463:90): [True: 0, False: 223]
  |  Branch (463:106): [True: 0, False: 223]
  ------------------
imgui_widgets.cpp:_ZplRK6ImVec2S1_:
  391|   340k|static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui_widgets.cpp:_ZmiRK6ImVec2S1_:
  392|     63|static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui_widgets.cpp:_ZmlRK6ImVec2f:
  389|   110k|static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui_widgets.cpp:_ZL10ImSaturatef:
  475|  15.5k|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (475:90): [True: 0, False: 15.5k]
  |  Branch (475:110): [True: 489, False: 15.0k]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIfET_S0_S0_:
  462|  37.8k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (462:90): [True: 12.4k, False: 25.4k]
  ------------------
imgui_widgets.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  463|  27.8k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (463:90): [True: 5.55k, False: 22.3k]
  |  Branch (463:106): [True: 7.59k, False: 14.7k]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIxET_S0_S0_:
  462|  37.1k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (462:90): [True: 24.3k, False: 12.8k]
  ------------------
imgui_widgets.cpp:_ZL6ImLerpIfET_S0_S0_f:
  464|  18.5k|template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

_ZN5ImGui31TableSettingsAddSettingsHandlerEv:
 3474|      1|{
 3475|      1|    ImGuiSettingsHandler ini_handler;
 3476|      1|    ini_handler.TypeName = "Table";
 3477|      1|    ini_handler.TypeHash = ImHashStr("Table");
 3478|      1|    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
 3479|      1|    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
 3480|      1|    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
 3481|      1|    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
 3482|      1|    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
 3483|      1|    AddSettingsHandler(&ini_handler);
 3484|      1|}

_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i:
  493|   141k|{
  494|   141k|    ImGuiContext& g = *GImGui;
  495|   141k|    ImGuiWindow* window = GetCurrentWindow();
  496|       |
  497|       |    // Default only reacts to left mouse button
  498|   141k|    if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)
  ------------------
  |  Branch (498:9): [True: 141k, False: 0]
  ------------------
  499|   141k|        flags |= ImGuiButtonFlags_MouseButtonDefault_;
  500|       |
  501|       |    // Default behavior requires click + release inside bounding box
  502|   141k|    if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)
  ------------------
  |  Branch (502:9): [True: 141k, False: 0]
  ------------------
  503|   141k|        flags |= ImGuiButtonFlags_PressedOnDefault_;
  504|       |
  505|   141k|    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
  506|   141k|    const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;
  ------------------
  |  Branch (506:43): [True: 11.3k, False: 130k]
  |  Branch (506:89): [True: 578, False: 10.8k]
  |  Branch (506:108): [True: 578, False: 0]
  ------------------
  507|   141k|    if (flatten_hovered_children)
  ------------------
  |  Branch (507:9): [True: 578, False: 141k]
  ------------------
  508|    578|        g.HoveredWindow = window;
  509|       |
  510|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
  511|       |    if (id != 0 && g.LastItemData.ID != id)
  512|       |        IMGUI_TEST_ENGINE_ITEM_ADD(bb, id);
  513|       |#endif
  514|       |
  515|   141k|    bool pressed = false;
  516|   141k|    bool hovered = ItemHoverable(bb, id);
  517|       |
  518|       |    // Drag source doesn't report as hovered
  519|   141k|    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
  ------------------
  |  Branch (519:9): [True: 718, False: 141k]
  |  Branch (519:20): [True: 2, False: 716]
  |  Branch (519:40): [True: 0, False: 2]
  |  Branch (519:76): [True: 0, False: 0]
  ------------------
  520|      0|        hovered = false;
  521|       |
  522|       |    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
  523|   141k|    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
  ------------------
  |  Branch (523:9): [True: 67, False: 141k]
  |  Branch (523:29): [True: 0, False: 67]
  |  Branch (523:81): [True: 0, False: 0]
  ------------------
  524|      0|        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (524:13): [True: 0, False: 0]
  ------------------
  525|      0|        {
  526|      0|            hovered = true;
  527|      0|            SetHoveredID(id);
  528|      0|            if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)
  ------------------
  |  Branch (528:17): [True: 0, False: 0]
  |  Branch (528:85): [True: 0, False: 0]
  ------------------
  529|      0|            {
  530|      0|                pressed = true;
  531|      0|                g.DragDropHoldJustPressedId = id;
  532|      0|                FocusWindow(window);
  533|      0|            }
  534|      0|        }
  535|       |
  536|   141k|    if (flatten_hovered_children)
  ------------------
  |  Branch (536:9): [True: 578, False: 141k]
  ------------------
  537|    578|        g.HoveredWindow = backup_hovered_window;
  538|       |
  539|       |    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
  540|   141k|    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
  ------------------
  |  Branch (540:9): [True: 718, False: 141k]
  |  Branch (540:20): [True: 0, False: 718]
  |  Branch (540:68): [True: 0, False: 0]
  |  Branch (540:102): [True: 0, False: 0]
  ------------------
  541|      0|        hovered = false;
  542|       |
  543|       |    // Mouse handling
  544|   141k|    const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;
  ------------------
  |  | 1311|      0|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (544:35): [True: 0, False: 141k]
  ------------------
  545|   141k|    if (hovered)
  ------------------
  |  Branch (545:9): [True: 718, False: 141k]
  ------------------
  546|    718|    {
  547|    718|        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
  ------------------
  |  Branch (547:13): [True: 718, False: 0]
  |  Branch (547:60): [True: 0, False: 0]
  |  Branch (547:77): [True: 0, False: 0]
  |  Branch (547:95): [True: 0, False: 0]
  ------------------
  548|    718|        {
  549|       |            // Poll buttons
  550|    718|            int mouse_button_clicked = -1;
  551|    718|            if ((flags & ImGuiButtonFlags_MouseButtonLeft) && IsMouseClicked(0, test_owner_id))         { mouse_button_clicked = 0; }
  ------------------
  |  Branch (551:17): [True: 718, False: 0]
  |  Branch (551:63): [True: 63, False: 655]
  ------------------
  552|    655|            else if ((flags & ImGuiButtonFlags_MouseButtonRight) && IsMouseClicked(1, test_owner_id))   { mouse_button_clicked = 1; }
  ------------------
  |  Branch (552:22): [True: 0, False: 655]
  |  Branch (552:69): [True: 0, False: 0]
  ------------------
  553|    655|            else if ((flags & ImGuiButtonFlags_MouseButtonMiddle) && IsMouseClicked(2, test_owner_id))  { mouse_button_clicked = 2; }
  ------------------
  |  Branch (553:22): [True: 0, False: 655]
  |  Branch (553:70): [True: 0, False: 0]
  ------------------
  554|    718|            if (mouse_button_clicked != -1 && g.ActiveId != id)
  ------------------
  |  Branch (554:17): [True: 63, False: 655]
  |  Branch (554:47): [True: 63, False: 0]
  ------------------
  555|     63|            {
  556|     63|                if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))
  ------------------
  |  Branch (556:21): [True: 63, False: 0]
  ------------------
  557|     63|                    SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);
  558|     63|                if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))
  ------------------
  |  Branch (558:21): [True: 63, False: 0]
  ------------------
  559|     63|                {
  560|     63|                    SetActiveID(id, window);
  561|     63|                    g.ActiveIdMouseButton = mouse_button_clicked;
  562|     63|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (562:25): [True: 63, False: 0]
  ------------------
  563|     63|                        SetFocusID(id, window);
  564|     63|                    FocusWindow(window);
  565|     63|                }
  566|     63|                if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2))
  ------------------
  |  Branch (566:21): [True: 0, False: 63]
  |  Branch (566:67): [True: 0, False: 63]
  |  Branch (566:118): [True: 0, False: 0]
  ------------------
  567|      0|                {
  568|      0|                    pressed = true;
  569|      0|                    if (flags & ImGuiButtonFlags_NoHoldingActiveId)
  ------------------
  |  Branch (569:25): [True: 0, False: 0]
  ------------------
  570|      0|                        ClearActiveID();
  571|      0|                    else
  572|      0|                        SetActiveID(id, window); // Hold on ID
  573|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (573:25): [True: 0, False: 0]
  ------------------
  574|      0|                        SetFocusID(id, window);
  575|      0|                    g.ActiveIdMouseButton = mouse_button_clicked;
  576|      0|                    FocusWindow(window);
  577|      0|                }
  578|     63|            }
  579|    718|            if (flags & ImGuiButtonFlags_PressedOnRelease)
  ------------------
  |  Branch (579:17): [True: 0, False: 718]
  ------------------
  580|      0|            {
  581|      0|                int mouse_button_released = -1;
  582|      0|                if ((flags & ImGuiButtonFlags_MouseButtonLeft) && IsMouseReleased(0, test_owner_id))        { mouse_button_released = 0; }
  ------------------
  |  Branch (582:21): [True: 0, False: 0]
  |  Branch (582:67): [True: 0, False: 0]
  ------------------
  583|      0|                else if ((flags & ImGuiButtonFlags_MouseButtonRight) && IsMouseReleased(1, test_owner_id))  { mouse_button_released = 1; }
  ------------------
  |  Branch (583:26): [True: 0, False: 0]
  |  Branch (583:73): [True: 0, False: 0]
  ------------------
  584|      0|                else if ((flags & ImGuiButtonFlags_MouseButtonMiddle) && IsMouseReleased(2, test_owner_id)) { mouse_button_released = 2; }
  ------------------
  |  Branch (584:26): [True: 0, False: 0]
  |  Branch (584:74): [True: 0, False: 0]
  ------------------
  585|      0|                if (mouse_button_released != -1)
  ------------------
  |  Branch (585:21): [True: 0, False: 0]
  ------------------
  586|      0|                {
  587|      0|                    const bool has_repeated_at_least_once = (flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
  ------------------
  |  Branch (587:61): [True: 0, False: 0]
  |  Branch (587:98): [True: 0, False: 0]
  ------------------
  588|      0|                    if (!has_repeated_at_least_once)
  ------------------
  |  Branch (588:25): [True: 0, False: 0]
  ------------------
  589|      0|                        pressed = true;
  590|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (590:25): [True: 0, False: 0]
  ------------------
  591|      0|                        SetFocusID(id, window);
  592|      0|                    ClearActiveID();
  593|      0|                }
  594|      0|            }
  595|       |
  596|       |            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
  597|       |            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
  598|    718|            if (g.ActiveId == id && (flags & ImGuiButtonFlags_Repeat))
  ------------------
  |  Branch (598:17): [True: 256, False: 462]
  |  Branch (598:37): [True: 0, False: 256]
  ------------------
  599|      0|                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, test_owner_id, ImGuiInputFlags_Repeat))
  ------------------
  |  Branch (599:21): [True: 0, False: 0]
  |  Branch (599:77): [True: 0, False: 0]
  ------------------
  600|      0|                    pressed = true;
  601|    718|        }
  602|       |
  603|    718|        if (pressed)
  ------------------
  |  Branch (603:13): [True: 0, False: 718]
  ------------------
  604|      0|            g.NavDisableHighlight = true;
  605|    718|    }
  606|       |
  607|       |    // Gamepad/Keyboard navigation
  608|       |    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
  609|   141k|    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
  ------------------
  |  Branch (609:9): [True: 286, False: 141k]
  |  Branch (609:26): [True: 11, False: 275]
  |  Branch (609:52): [True: 11, False: 0]
  |  Branch (609:79): [True: 0, False: 11]
  |  Branch (609:98): [True: 11, False: 0]
  |  Branch (609:118): [True: 0, False: 0]
  ------------------
  610|     11|        if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))
  ------------------
  |  Branch (610:13): [True: 11, False: 0]
  ------------------
  611|     11|            hovered = true;
  612|   141k|    if (g.NavActivateDownId == id)
  ------------------
  |  Branch (612:9): [True: 0, False: 141k]
  ------------------
  613|      0|    {
  614|      0|        bool nav_activated_by_code = (g.NavActivateId == id);
  615|      0|        bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
  616|      0|        if (!nav_activated_by_inputs && (flags & ImGuiButtonFlags_Repeat))
  ------------------
  |  Branch (616:13): [True: 0, False: 0]
  |  Branch (616:41): [True: 0, False: 0]
  ------------------
  617|      0|        {
  618|       |            // Avoid pressing both keys from triggering double amount of repeat events
  619|      0|            const ImGuiKeyData* key1 = GetKeyData(ImGuiKey_Space);
  620|      0|            const ImGuiKeyData* key2 = GetKeyData(ImGuiKey_NavGamepadActivate);
  ------------------
  |  | 1252|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  621|      0|            const float t1 = ImMax(key1->DownDuration, key2->DownDuration);
  622|      0|            nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
  623|      0|        }
  624|      0|        if (nav_activated_by_code || nav_activated_by_inputs)
  ------------------
  |  Branch (624:13): [True: 0, False: 0]
  |  Branch (624:38): [True: 0, False: 0]
  ------------------
  625|      0|        {
  626|       |            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
  627|      0|            pressed = true;
  628|      0|            SetActiveID(id, window);
  629|      0|            g.ActiveIdSource = ImGuiInputSource_Nav;
  630|      0|            if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (630:17): [True: 0, False: 0]
  ------------------
  631|      0|                SetFocusID(id, window);
  632|      0|        }
  633|      0|    }
  634|       |
  635|       |    // Process while held
  636|   141k|    bool held = false;
  637|   141k|    if (g.ActiveId == id)
  ------------------
  |  Branch (637:9): [True: 301, False: 141k]
  ------------------
  638|    301|    {
  639|    301|        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
  ------------------
  |  Branch (639:13): [True: 301, False: 0]
  ------------------
  640|    301|        {
  641|    301|            if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (641:17): [True: 63, False: 238]
  ------------------
  642|     63|                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
  643|       |
  644|    301|            const int mouse_button = g.ActiveIdMouseButton;
  645|    301|            if (IsMouseDown(mouse_button, test_owner_id))
  ------------------
  |  Branch (645:17): [True: 301, False: 0]
  ------------------
  646|    301|            {
  647|    301|                held = true;
  648|    301|            }
  649|      0|            else
  650|      0|            {
  651|      0|                bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;
  ------------------
  |  Branch (651:35): [True: 0, False: 0]
  |  Branch (651:46): [True: 0, False: 0]
  ------------------
  652|      0|                bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
  653|      0|                if ((release_in || release_anywhere) && !g.DragDropActive)
  ------------------
  |  Branch (653:22): [True: 0, False: 0]
  |  Branch (653:36): [True: 0, False: 0]
  |  Branch (653:57): [True: 0, False: 0]
  ------------------
  654|      0|                {
  655|       |                    // Report as pressed when releasing the mouse (this is the most common path)
  656|      0|                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;
  ------------------
  |  Branch (656:52): [True: 0, False: 0]
  |  Branch (656:103): [True: 0, False: 0]
  |  Branch (656:139): [True: 0, False: 0]
  ------------------
  657|      0|                    bool is_repeating_already = (flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
  ------------------
  |  Branch (657:49): [True: 0, False: 0]
  |  Branch (657:86): [True: 0, False: 0]
  ------------------
  658|      0|                    bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);
  659|      0|                    if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)
  ------------------
  |  Branch (659:25): [True: 0, False: 0]
  |  Branch (659:53): [True: 0, False: 0]
  |  Branch (659:78): [True: 0, False: 0]
  ------------------
  660|      0|                        pressed = true;
  661|      0|                }
  662|      0|                ClearActiveID();
  663|      0|            }
  664|    301|            if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (664:17): [True: 301, False: 0]
  ------------------
  665|    301|                g.NavDisableHighlight = true;
  666|    301|        }
  667|      0|        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
  ------------------
  |  Branch (667:18): [True: 0, False: 0]
  ------------------
  668|      0|        {
  669|       |            // When activated using Nav, we hold on the ActiveID until activation button is released
  670|      0|            if (g.NavActivateDownId != id)
  ------------------
  |  Branch (670:17): [True: 0, False: 0]
  ------------------
  671|      0|                ClearActiveID();
  672|      0|        }
  673|    301|        if (pressed)
  ------------------
  |  Branch (673:13): [True: 0, False: 301]
  ------------------
  674|      0|            g.ActiveIdHasBeenPressedBefore = true;
  675|    301|    }
  676|       |
  677|   141k|    if (out_hovered) *out_hovered = hovered;
  ------------------
  |  Branch (677:9): [True: 141k, False: 0]
  ------------------
  678|   141k|    if (out_held) *out_held = held;
  ------------------
  |  Branch (678:9): [True: 141k, False: 0]
  ------------------
  679|       |
  680|   141k|    return pressed;
  681|   141k|}
_ZN5ImGui14CollapseButtonEjRK6ImVec2P13ImGuiDockNode:
  847|   110k|{
  848|   110k|    ImGuiContext& g = *GImGui;
  849|   110k|    ImGuiWindow* window = g.CurrentWindow;
  850|       |
  851|   110k|    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
  852|   110k|    ItemAdd(bb, id);
  853|   110k|    bool hovered, held;
  854|   110k|    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);
  855|       |
  856|       |    // Render
  857|       |    //bool is_dock_menu = (window->DockNodeAsHost && !window->Collapsed);
  858|   110k|    ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (858:33): [True: 301, False: 110k]
  |  Branch (858:41): [True: 267, False: 34]
  |  Branch (858:76): [True: 458, False: 110k]
  ------------------
  859|   110k|    ImU32 text_col = GetColorU32(ImGuiCol_Text);
  860|   110k|    if (hovered || held)
  ------------------
  |  Branch (860:9): [True: 725, False: 110k]
  |  Branch (860:20): [True: 34, False: 110k]
  ------------------
  861|    759|        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0,-0.5f), g.FontSize * 0.5f + 1.0f, bg_col, 12);
  862|       |
  863|   110k|    if (dock_node)
  ------------------
  |  Branch (863:9): [True: 0, False: 110k]
  ------------------
  864|      0|        RenderArrowDockMenu(window->DrawList, bb.Min + g.Style.FramePadding, g.FontSize, text_col);
  865|   110k|    else
  866|   110k|        RenderArrow(window->DrawList, bb.Min + g.Style.FramePadding, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);
  ------------------
  |  Branch (866:80): [True: 44.0k, False: 66.8k]
  ------------------
  867|       |
  868|       |    // Switch to moving the window after mouse is moved beyond the initial drag threshold
  869|   110k|    if (IsItemActive() && IsMouseDragging(0))
  ------------------
  |  Branch (869:9): [True: 301, False: 110k]
  |  Branch (869:27): [True: 7, False: 294]
  ------------------
  870|      7|        StartMouseMovingWindowOrNode(window, dock_node, true);
  871|       |
  872|   110k|    return pressed;
  873|   110k|}
_ZN5ImGui20GetWindowScrollbarIDEP11ImGuiWindow9ImGuiAxis:
  876|  27.5k|{
  877|  27.5k|    return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
  ------------------
  |  Branch (877:26): [True: 11.3k, False: 16.1k]
  ------------------
  878|  27.5k|}
_ZN5ImGui22GetWindowScrollbarRectEP11ImGuiWindow9ImGuiAxis:
  882|  27.5k|{
  883|  27.5k|    const ImRect outer_rect = window->Rect();
  884|  27.5k|    const ImRect inner_rect = window->InnerRect;
  885|  27.5k|    const float border_size = window->WindowBorderSize;
  886|  27.5k|    const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
  887|  27.5k|    IM_ASSERT(scrollbar_size > 0.0f);
  ------------------
  |  |   23|  27.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  888|  27.5k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (888:9): [True: 11.3k, False: 16.1k]
  ------------------
  889|  11.3k|        return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x, outer_rect.Max.y);
  890|  16.1k|    else
  891|  16.1k|        return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x, inner_rect.Max.y);
  892|  27.5k|}
_ZN5ImGui9ScrollbarE9ImGuiAxis:
  895|  27.5k|{
  896|  27.5k|    ImGuiContext& g = *GImGui;
  897|  27.5k|    ImGuiWindow* window = g.CurrentWindow;
  898|  27.5k|    const ImGuiID id = GetWindowScrollbarID(window, axis);
  899|       |
  900|       |    // Calculate scrollbar bounding box
  901|  27.5k|    ImRect bb = GetWindowScrollbarRect(window, axis);
  902|  27.5k|    ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;
  903|  27.5k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (903:9): [True: 11.3k, False: 16.1k]
  ------------------
  904|  11.3k|    {
  905|  11.3k|        rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;
  906|  11.3k|        if (!window->ScrollbarY)
  ------------------
  |  Branch (906:13): [True: 2.52k, False: 8.86k]
  ------------------
  907|  2.52k|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  908|  11.3k|    }
  909|  16.1k|    else
  910|  16.1k|    {
  911|  16.1k|        if ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar))
  ------------------
  |  Branch (911:13): [True: 8.86k, False: 7.31k]
  |  Branch (911:62): [True: 8.86k, False: 0]
  ------------------
  912|  8.86k|            rounding_corners |= ImDrawFlags_RoundCornersTopRight;
  913|  16.1k|        if (!window->ScrollbarX)
  ------------------
  |  Branch (913:13): [True: 7.31k, False: 8.86k]
  ------------------
  914|  7.31k|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  915|  16.1k|    }
  916|  27.5k|    float size_avail = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
  917|  27.5k|    float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;
  918|  27.5k|    ImS64 scroll = (ImS64)window->Scroll[axis];
  919|  27.5k|    ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_avail, (ImS64)size_contents, rounding_corners);
  920|  27.5k|    window->Scroll[axis] = (float)scroll;
  921|  27.5k|}
_ZN5ImGui11ScrollbarExERK6ImRectj9ImGuiAxisPxxxi:
  930|  27.5k|{
  931|  27.5k|    ImGuiContext& g = *GImGui;
  932|  27.5k|    ImGuiWindow* window = g.CurrentWindow;
  933|  27.5k|    if (window->SkipItems)
  ------------------
  |  Branch (933:9): [True: 0, False: 27.5k]
  ------------------
  934|      0|        return false;
  935|       |
  936|  27.5k|    const float bb_frame_width = bb_frame.GetWidth();
  937|  27.5k|    const float bb_frame_height = bb_frame.GetHeight();
  938|  27.5k|    if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)
  ------------------
  |  Branch (938:9): [True: 5.31k, False: 22.2k]
  |  Branch (938:35): [True: 6.75k, False: 15.5k]
  ------------------
  939|  12.0k|        return false;
  940|       |
  941|       |    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
  942|  15.5k|    float alpha = 1.0f;
  943|  15.5k|    if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
  ------------------
  |  Branch (943:9): [True: 8.65k, False: 6.85k]
  |  Branch (943:34): [True: 6.28k, False: 2.36k]
  ------------------
  944|  6.28k|        alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
  945|  15.5k|    if (alpha <= 0.0f)
  ------------------
  |  Branch (945:9): [True: 6.21k, False: 9.29k]
  ------------------
  946|  6.21k|        return false;
  947|       |
  948|  9.29k|    const ImGuiStyle& style = g.Style;
  949|  9.29k|    const bool allow_interaction = (alpha >= 1.0f);
  950|       |
  951|  9.29k|    ImRect bb = bb_frame;
  952|  9.29k|    bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  266|  9.29k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
                  bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  266|  9.29k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  953|       |
  954|       |    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
  955|  9.29k|    const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();
  ------------------
  |  Branch (955:36): [True: 6.85k, False: 2.43k]
  ------------------
  956|       |
  957|       |    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
  958|       |    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
  959|  9.29k|    IM_ASSERT(ImMax(size_contents_v, size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
  ------------------
  |  |   23|  9.29k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  960|  9.29k|    const ImS64 win_size_v = ImMax(ImMax(size_contents_v, size_avail_v), (ImS64)1);
  961|  9.29k|    const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_avail_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);
  962|  9.29k|    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;
  963|       |
  964|       |    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
  965|  9.29k|    bool held = false;
  966|  9.29k|    bool hovered = false;
  967|  9.29k|    ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);
  968|  9.29k|    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);
  969|       |
  970|  9.29k|    const ImS64 scroll_max = ImMax((ImS64)1, size_contents_v - size_avail_v);
  971|  9.29k|    float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
  972|  9.29k|    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
  973|  9.29k|    if (held && allow_interaction && grab_h_norm < 1.0f)
  ------------------
  |  Branch (973:9): [True: 0, False: 9.29k]
  |  Branch (973:17): [True: 0, False: 0]
  |  Branch (973:38): [True: 0, False: 0]
  ------------------
  974|      0|    {
  975|      0|        const float scrollbar_pos_v = bb.Min[axis];
  976|      0|        const float mouse_pos_v = g.IO.MousePos[axis];
  977|       |
  978|       |        // Click position in scrollbar normalized space (0.0f->1.0f)
  979|      0|        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
  980|      0|        SetHoveredID(id);
  981|       |
  982|      0|        bool seek_absolute = false;
  983|      0|        if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (983:13): [True: 0, False: 0]
  ------------------
  984|      0|        {
  985|       |            // On initial click calculate the distance between mouse and the center of the grab
  986|      0|            seek_absolute = (clicked_v_norm < grab_v_norm || clicked_v_norm > grab_v_norm + grab_h_norm);
  ------------------
  |  Branch (986:30): [True: 0, False: 0]
  |  Branch (986:62): [True: 0, False: 0]
  ------------------
  987|      0|            if (seek_absolute)
  ------------------
  |  Branch (987:17): [True: 0, False: 0]
  ------------------
  988|      0|                g.ScrollbarClickDeltaToGrabCenter = 0.0f;
  989|      0|            else
  990|      0|                g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
  991|      0|        }
  992|       |
  993|       |        // Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
  994|       |        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
  995|      0|        const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
  996|      0|        *p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);
  997|       |
  998|       |        // Update values for rendering
  999|      0|        scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
 1000|      0|        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
 1001|       |
 1002|       |        // Update distance to grab now that we have seeked and saturated
 1003|      0|        if (seek_absolute)
  ------------------
  |  Branch (1003:13): [True: 0, False: 0]
  ------------------
 1004|      0|            g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
 1005|      0|    }
 1006|       |
 1007|       |    // Render
 1008|  9.29k|    const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);
 1009|  9.29k|    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
  ------------------
  |  Branch (1009:40): [True: 0, False: 9.29k]
  |  Branch (1009:78): [True: 0, False: 9.29k]
  ------------------
 1010|  9.29k|    window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);
 1011|  9.29k|    ImRect grab_rect;
 1012|  9.29k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (1012:9): [True: 6.85k, False: 2.43k]
  ------------------
 1013|  6.85k|        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);
 1014|  2.43k|    else
 1015|  2.43k|        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
 1016|  9.29k|    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
 1017|       |
 1018|  9.29k|    return held;
 1019|  15.5k|}
_ZN5ImGui5DummyERK6ImVec2:
 1360|  11.3k|{
 1361|  11.3k|    ImGuiWindow* window = GetCurrentWindow();
 1362|  11.3k|    if (window->SkipItems)
  ------------------
  |  Branch (1362:9): [True: 4.32k, False: 7.06k]
  ------------------
 1363|  4.32k|        return;
 1364|       |
 1365|  7.06k|    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
 1366|  7.06k|    ItemSize(size);
 1367|  7.06k|    ItemAdd(bb, 0);
 1368|  7.06k|}
_ZN5ImGui10SelectableEPKcbiRK6ImVec2:
 6261|  10.2k|{
 6262|  10.2k|    ImGuiWindow* window = GetCurrentWindow();
 6263|  10.2k|    if (window->SkipItems)
  ------------------
  |  Branch (6263:9): [True: 0, False: 10.2k]
  ------------------
 6264|      0|        return false;
 6265|       |
 6266|  10.2k|    ImGuiContext& g = *GImGui;
 6267|  10.2k|    const ImGuiStyle& style = g.Style;
 6268|       |
 6269|       |    // Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.
 6270|  10.2k|    ImGuiID id = window->GetID(label);
 6271|  10.2k|    ImVec2 label_size = CalcTextSize(label, NULL, true);
 6272|  10.2k|    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
  ------------------
  |  Branch (6272:17): [True: 0, False: 10.2k]
  |  Branch (6272:65): [True: 0, False: 10.2k]
  ------------------
 6273|  10.2k|    ImVec2 pos = window->DC.CursorPos;
 6274|  10.2k|    pos.y += window->DC.CurrLineTextBaseOffset;
 6275|  10.2k|    ItemSize(size, 0.0f);
 6276|       |
 6277|       |    // Fill horizontal space
 6278|       |    // We don't support (size < 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.
 6279|  10.2k|    const bool span_all_columns = (flags & ImGuiSelectableFlags_SpanAllColumns) != 0;
 6280|  10.2k|    const float min_x = span_all_columns ? window->ParentWorkRect.Min.x : pos.x;
  ------------------
  |  Branch (6280:25): [True: 0, False: 10.2k]
  ------------------
 6281|  10.2k|    const float max_x = span_all_columns ? window->ParentWorkRect.Max.x : window->WorkRect.Max.x;
  ------------------
  |  Branch (6281:25): [True: 0, False: 10.2k]
  ------------------
 6282|  10.2k|    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_SpanAvailWidth))
  ------------------
  |  Branch (6282:9): [True: 10.2k, False: 0]
  |  Branch (6282:31): [True: 0, False: 0]
  ------------------
 6283|  10.2k|        size.x = ImMax(label_size.x, max_x - min_x);
 6284|       |
 6285|       |    // Text stays at the submission position, but bounding box may be extended on both sides
 6286|  10.2k|    const ImVec2 text_min = pos;
 6287|  10.2k|    const ImVec2 text_max(min_x + size.x, pos.y + size.y);
 6288|       |
 6289|       |    // Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.
 6290|  10.2k|    ImRect bb(min_x, pos.y, text_max.x, text_max.y);
 6291|  10.2k|    if ((flags & ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0)
  ------------------
  |  Branch (6291:9): [True: 10.2k, False: 0]
  ------------------
 6292|  10.2k|    {
 6293|  10.2k|        const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;
  ------------------
  |  Branch (6293:33): [True: 0, False: 10.2k]
  ------------------
 6294|  10.2k|        const float spacing_y = style.ItemSpacing.y;
 6295|  10.2k|        const float spacing_L = IM_FLOOR(spacing_x * 0.50f);
  ------------------
  |  |  266|  10.2k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 6296|  10.2k|        const float spacing_U = IM_FLOOR(spacing_y * 0.50f);
  ------------------
  |  |  266|  10.2k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 6297|  10.2k|        bb.Min.x -= spacing_L;
 6298|  10.2k|        bb.Min.y -= spacing_U;
 6299|  10.2k|        bb.Max.x += (spacing_x - spacing_L);
 6300|  10.2k|        bb.Max.y += (spacing_y - spacing_U);
 6301|  10.2k|    }
 6302|       |    //if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }
 6303|       |
 6304|       |    // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackground for every Selectable..
 6305|  10.2k|    const float backup_clip_rect_min_x = window->ClipRect.Min.x;
 6306|  10.2k|    const float backup_clip_rect_max_x = window->ClipRect.Max.x;
 6307|  10.2k|    if (span_all_columns)
  ------------------
  |  Branch (6307:9): [True: 0, False: 10.2k]
  ------------------
 6308|      0|    {
 6309|      0|        window->ClipRect.Min.x = window->ParentWorkRect.Min.x;
 6310|      0|        window->ClipRect.Max.x = window->ParentWorkRect.Max.x;
 6311|      0|    }
 6312|       |
 6313|  10.2k|    const bool disabled_item = (flags & ImGuiSelectableFlags_Disabled) != 0;
 6314|  10.2k|    const bool item_add = ItemAdd(bb, id, NULL, disabled_item ? ImGuiItemFlags_Disabled : ImGuiItemFlags_None);
  ------------------
  |  Branch (6314:49): [True: 0, False: 10.2k]
  ------------------
 6315|  10.2k|    if (span_all_columns)
  ------------------
  |  Branch (6315:9): [True: 0, False: 10.2k]
  ------------------
 6316|      0|    {
 6317|      0|        window->ClipRect.Min.x = backup_clip_rect_min_x;
 6318|      0|        window->ClipRect.Max.x = backup_clip_rect_max_x;
 6319|      0|    }
 6320|       |
 6321|  10.2k|    if (!item_add)
  ------------------
  |  Branch (6321:9): [True: 0, False: 10.2k]
  ------------------
 6322|      0|        return false;
 6323|       |
 6324|  10.2k|    const bool disabled_global = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
 6325|  10.2k|    if (disabled_item && !disabled_global) // Only testing this as an optimization
  ------------------
  |  Branch (6325:9): [True: 0, False: 10.2k]
  |  Branch (6325:26): [True: 0, False: 0]
  ------------------
 6326|      0|        BeginDisabled();
 6327|       |
 6328|       |    // FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,
 6329|       |    // which would be advantageous since most selectable are not selected.
 6330|  10.2k|    if (span_all_columns && window->DC.CurrentColumns)
  ------------------
  |  Branch (6330:9): [True: 0, False: 10.2k]
  |  Branch (6330:29): [True: 0, False: 0]
  ------------------
 6331|      0|        PushColumnsBackground();
 6332|  10.2k|    else if (span_all_columns && g.CurrentTable)
  ------------------
  |  Branch (6332:14): [True: 0, False: 10.2k]
  |  Branch (6332:34): [True: 0, False: 0]
  ------------------
 6333|      0|        TablePushBackgroundChannel();
 6334|       |
 6335|       |    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
 6336|  10.2k|    ImGuiButtonFlags button_flags = 0;
 6337|  10.2k|    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) { button_flags |= ImGuiButtonFlags_NoHoldingActiveId; }
  ------------------
  |  Branch (6337:9): [True: 0, False: 10.2k]
  ------------------
 6338|  10.2k|    if (flags & ImGuiSelectableFlags_NoSetKeyOwner)     { button_flags |= ImGuiButtonFlags_NoSetKeyOwner; }
  ------------------
  |  Branch (6338:9): [True: 0, False: 10.2k]
  ------------------
 6339|  10.2k|    if (flags & ImGuiSelectableFlags_SelectOnClick)     { button_flags |= ImGuiButtonFlags_PressedOnClick; }
  ------------------
  |  Branch (6339:9): [True: 0, False: 10.2k]
  ------------------
 6340|  10.2k|    if (flags & ImGuiSelectableFlags_SelectOnRelease)   { button_flags |= ImGuiButtonFlags_PressedOnRelease; }
  ------------------
  |  Branch (6340:9): [True: 0, False: 10.2k]
  ------------------
 6341|  10.2k|    if (flags & ImGuiSelectableFlags_AllowDoubleClick)  { button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick; }
  ------------------
  |  Branch (6341:9): [True: 0, False: 10.2k]
  ------------------
 6342|  10.2k|    if (flags & ImGuiSelectableFlags_AllowItemOverlap)  { button_flags |= ImGuiButtonFlags_AllowItemOverlap; }
  ------------------
  |  Branch (6342:9): [True: 0, False: 10.2k]
  ------------------
 6343|       |
 6344|  10.2k|    const bool was_selected = selected;
 6345|  10.2k|    bool hovered, held;
 6346|  10.2k|    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
 6347|       |
 6348|       |    // Auto-select when moved into
 6349|       |    // - This will be more fully fleshed in the range-select branch
 6350|       |    // - This is not exposed as it won't nicely work with some user side handling of shift/control
 6351|       |    // - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons
 6352|       |    //   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())
 6353|       |    //   - (2) usage will fail with clipped items
 6354|       |    //   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.
 6355|  10.2k|    if ((flags & ImGuiSelectableFlags_SelectOnNav) && g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId)
  ------------------
  |  Branch (6355:9): [True: 0, False: 10.2k]
  |  Branch (6355:55): [True: 0, False: 0]
  |  Branch (6355:82): [True: 0, False: 0]
  ------------------
 6356|      0|        if (g.NavJustMovedToId == id)
  ------------------
  |  Branch (6356:13): [True: 0, False: 0]
  ------------------
 6357|      0|            selected = pressed = true;
 6358|       |
 6359|       |    // Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard
 6360|  10.2k|    if (pressed || (hovered && (flags & ImGuiSelectableFlags_SetNavIdOnHover)))
  ------------------
  |  Branch (6360:9): [True: 0, False: 10.2k]
  |  Branch (6360:21): [True: 0, False: 10.2k]
  |  Branch (6360:32): [True: 0, False: 0]
  ------------------
 6361|      0|    {
 6362|      0|        if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)
  ------------------
  |  Branch (6362:13): [True: 0, False: 0]
  |  Branch (6362:40): [True: 0, False: 0]
  |  Branch (6362:65): [True: 0, False: 0]
  ------------------
 6363|      0|        {
 6364|      0|            SetNavID(id, window->DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)
 6365|      0|            g.NavDisableHighlight = true;
 6366|      0|        }
 6367|      0|    }
 6368|  10.2k|    if (pressed)
  ------------------
  |  Branch (6368:9): [True: 0, False: 10.2k]
  ------------------
 6369|      0|        MarkItemEdited(id);
 6370|       |
 6371|  10.2k|    if (flags & ImGuiSelectableFlags_AllowItemOverlap)
  ------------------
  |  Branch (6371:9): [True: 0, False: 10.2k]
  ------------------
 6372|      0|        SetItemAllowOverlap();
 6373|       |
 6374|       |    // In this branch, Selectable() cannot toggle the selection so this will never trigger.
 6375|  10.2k|    if (selected != was_selected) //-V547
  ------------------
  |  Branch (6375:9): [True: 0, False: 10.2k]
  ------------------
 6376|      0|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;
 6377|       |
 6378|       |    // Render
 6379|  10.2k|    if (held && (flags & ImGuiSelectableFlags_DrawHoveredWhenHeld))
  ------------------
  |  Branch (6379:9): [True: 0, False: 10.2k]
  |  Branch (6379:17): [True: 0, False: 0]
  ------------------
 6380|      0|        hovered = true;
 6381|  10.2k|    if (hovered || selected)
  ------------------
  |  Branch (6381:9): [True: 0, False: 10.2k]
  |  Branch (6381:20): [True: 10.2k, False: 0]
  ------------------
 6382|  10.2k|    {
 6383|  10.2k|        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
  ------------------
  |  Branch (6383:40): [True: 0, False: 10.2k]
  |  Branch (6383:48): [True: 0, False: 0]
  |  Branch (6383:83): [True: 0, False: 10.2k]
  ------------------
 6384|  10.2k|        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
 6385|  10.2k|    }
 6386|  10.2k|    RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
 6387|       |
 6388|  10.2k|    if (span_all_columns && window->DC.CurrentColumns)
  ------------------
  |  Branch (6388:9): [True: 0, False: 10.2k]
  |  Branch (6388:29): [True: 0, False: 0]
  ------------------
 6389|      0|        PopColumnsBackground();
 6390|  10.2k|    else if (span_all_columns && g.CurrentTable)
  ------------------
  |  Branch (6390:14): [True: 0, False: 10.2k]
  |  Branch (6390:34): [True: 0, False: 0]
  ------------------
 6391|      0|        TablePopBackgroundChannel();
 6392|       |
 6393|  10.2k|    RenderTextClipped(text_min, text_max, label, NULL, &label_size, style.SelectableTextAlign, &bb);
 6394|       |
 6395|       |    // Automatically close popups
 6396|  10.2k|    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(g.LastItemData.InFlags & ImGuiItemFlags_SelectableDontClosePopup))
  ------------------
  |  Branch (6396:9): [True: 0, False: 10.2k]
  |  Branch (6396:20): [True: 0, False: 0]
  |  Branch (6396:64): [True: 0, False: 0]
  |  Branch (6396:115): [True: 0, False: 0]
  ------------------
 6397|      0|        CloseCurrentPopup();
 6398|       |
 6399|  10.2k|    if (disabled_item && !disabled_global)
  ------------------
  |  Branch (6399:9): [True: 0, False: 10.2k]
  |  Branch (6399:26): [True: 0, False: 0]
  ------------------
 6400|      0|        EndDisabled();
 6401|       |
 6402|  10.2k|    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
  ------------------
  |  | 3506|  10.2k|#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      ((void)g)
  ------------------
 6403|  10.2k|    return pressed; //-V1020
 6404|  10.2k|}
_ZN16ImGuiMenuColumns6UpdateEfb:
 6762|   132k|{
 6763|   132k|    if (window_reappearing)
  ------------------
  |  Branch (6763:9): [True: 208, False: 132k]
  ------------------
 6764|    208|        memset(Widths, 0, sizeof(Widths));
 6765|   132k|    Spacing = (ImU16)spacing;
 6766|   132k|    CalcNextTotalWidth(true);
 6767|   132k|    memset(Widths, 0, sizeof(Widths));
 6768|   132k|    TotalWidth = NextTotalWidth;
 6769|   132k|    NextTotalWidth = 0;
 6770|   132k|}
_ZN16ImGuiMenuColumns18CalcNextTotalWidthEb:
 6773|   132k|{
 6774|   132k|    ImU16 offset = 0;
 6775|   132k|    bool want_spacing = false;
 6776|   662k|    for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)
  ------------------
  |  |   87|   662k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (6776:21): [True: 529k, False: 132k]
  ------------------
 6777|   529k|    {
 6778|   529k|        ImU16 width = Widths[i];
 6779|   529k|        if (want_spacing && width > 0)
  ------------------
  |  Branch (6779:13): [True: 0, False: 529k]
  |  Branch (6779:29): [True: 0, False: 0]
  ------------------
 6780|      0|            offset += Spacing;
 6781|   529k|        want_spacing |= (width > 0);
 6782|   529k|        if (update_offsets)
  ------------------
  |  Branch (6782:13): [True: 529k, False: 0]
  ------------------
 6783|   529k|        {
 6784|   529k|            if (i == 1) { OffsetLabel = offset; }
  ------------------
  |  Branch (6784:17): [True: 132k, False: 397k]
  ------------------
 6785|   529k|            if (i == 2) { OffsetShortcut = offset; }
  ------------------
  |  Branch (6785:17): [True: 132k, False: 397k]
  ------------------
 6786|   529k|            if (i == 3) { OffsetMark = offset; }
  ------------------
  |  Branch (6786:17): [True: 132k, False: 397k]
  ------------------
 6787|   529k|        }
 6788|   529k|        offset += width;
 6789|   529k|    }
 6790|   132k|    NextTotalWidth = offset;
 6791|   132k|}

imgui_draw.cpp:_ZL17stbrp_init_targetP13stbrp_contextiiP10stbrp_nodei:
  266|      1|{
  267|      1|   int i;
  268|       |
  269|    511|   for (i=0; i < num_nodes-1; ++i)
  ------------------
  |  Branch (269:14): [True: 510, False: 1]
  ------------------
  270|    510|      nodes[i].next = &nodes[i+1];
  271|      1|   nodes[i].next = NULL;
  272|      1|   context->init_mode = STBRP__INIT_skyline;
  273|      1|   context->heuristic = STBRP_HEURISTIC_Skyline_default;
  274|      1|   context->free_head = &nodes[0];
  275|      1|   context->active_head = &context->extra[0];
  276|      1|   context->width = width;
  277|      1|   context->height = height;
  278|      1|   context->num_nodes = num_nodes;
  279|      1|   stbrp_setup_allow_out_of_mem(context, 0);
  280|       |
  281|       |   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
  282|      1|   context->extra[0].x = 0;
  283|      1|   context->extra[0].y = 0;
  284|      1|   context->extra[0].next = &context->extra[1];
  285|      1|   context->extra[1].x = (stbrp_coord) width;
  286|      1|   context->extra[1].y = (1<<30);
  287|      1|   context->extra[1].next = NULL;
  288|      1|}
imgui_draw.cpp:_ZL28stbrp_setup_allow_out_of_memP13stbrp_contexti:
  246|      1|{
  247|      1|   if (allow_out_of_mem)
  ------------------
  |  Branch (247:8): [True: 0, False: 1]
  ------------------
  248|       |      // if it's ok to run out of memory, then don't bother aligning them;
  249|       |      // this gives better packing, but may fail due to OOM (even though
  250|       |      // the rectangles easily fit). @TODO a smarter approach would be to only
  251|       |      // quantize once we've hit OOM, then we could get rid of this parameter.
  252|      0|      context->align = 1;
  253|      1|   else {
  254|       |      // if it's not ok to run out of memory, then quantize the widths
  255|       |      // so that num_nodes is always enough nodes.
  256|       |      //
  257|       |      // I.e. num_nodes * align >= width
  258|       |      //                  align >= width / num_nodes
  259|       |      //                  align = ceil(width/num_nodes)
  260|       |
  261|      1|      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
  262|      1|   }
  263|      1|}
imgui_draw.cpp:_ZL16stbrp_pack_rectsP13stbrp_contextP10stbrp_recti:
  547|      2|{
  548|      2|   int i, all_rects_packed = 1;
  549|       |
  550|       |   // we use the 'was_packed' field internally to allow sorting/unsorting
  551|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (551:14): [True: 225, False: 2]
  ------------------
  552|    225|      rects[i].was_packed = i;
  553|    225|   }
  554|       |
  555|       |   // sort according to heuristic
  556|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);
  ------------------
  |  |  118|      2|#define STBRP_SORT          ImQsort
  ------------------
  557|       |
  558|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (558:14): [True: 225, False: 2]
  ------------------
  559|    225|      if (rects[i].w == 0 || rects[i].h == 0) {
  ------------------
  |  Branch (559:11): [True: 0, False: 225]
  |  Branch (559:30): [True: 0, False: 225]
  ------------------
  560|      0|         rects[i].x = rects[i].y = 0;  // empty rect needs no space
  561|    225|      } else {
  562|    225|         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
  563|    225|         if (fr.prev_link) {
  ------------------
  |  Branch (563:14): [True: 225, False: 0]
  ------------------
  564|    225|            rects[i].x = (stbrp_coord) fr.x;
  565|    225|            rects[i].y = (stbrp_coord) fr.y;
  566|    225|         } else {
  567|      0|            rects[i].x = rects[i].y = STBRP__MAXVAL;
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  568|      0|         }
  569|    225|      }
  570|    225|   }
  571|       |
  572|       |   // unsort
  573|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);
  ------------------
  |  |  118|      2|#define STBRP_SORT          ImQsort
  ------------------
  574|       |
  575|       |   // set was_packed flags and all_rects_packed status
  576|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (576:14): [True: 225, False: 2]
  ------------------
  577|    225|      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|    450|#define STBRP__MAXVAL  0x7fffffff
  ------------------
                    rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  |  Branch (577:31): [True: 0, False: 225]
  |  Branch (577:62): [True: 0, False: 0]
  ------------------
  578|    225|      if (!rects[i].was_packed)
  ------------------
  |  Branch (578:11): [True: 0, False: 225]
  ------------------
  579|      0|         all_rects_packed = 0;
  580|    225|   }
  581|       |
  582|       |   // return the all_rects_packed status
  583|      2|   return all_rects_packed;
  584|      2|}
imgui_draw.cpp:_ZL19rect_height_comparePKvS0_:
  529|  1.40k|{
  530|  1.40k|   const stbrp_rect *p = (const stbrp_rect *) a;
  531|  1.40k|   const stbrp_rect *q = (const stbrp_rect *) b;
  532|  1.40k|   if (p->h > q->h)
  ------------------
  |  Branch (532:8): [True: 224, False: 1.17k]
  ------------------
  533|    224|      return -1;
  534|  1.17k|   if (p->h < q->h)
  ------------------
  |  Branch (534:8): [True: 383, False: 795]
  ------------------
  535|    383|      return  1;
  536|    795|   return (p->w > q->w) ? -1 : (p->w < q->w);
  ------------------
  |  Branch (536:11): [True: 97, False: 698]
  ------------------
  537|  1.17k|}
imgui_draw.cpp:_ZL29stbrp__skyline_pack_rectangleP13stbrp_contextii:
  450|    225|{
  451|       |   // find best position according to heuristic
  452|    225|   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
  453|    225|   stbrp_node *node, *cur;
  454|       |
  455|       |   // bail if:
  456|       |   //    1. it failed
  457|       |   //    2. the best node doesn't fit (we don't always check this)
  458|       |   //    3. we're out of memory
  459|    225|   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
  ------------------
  |  Branch (459:8): [True: 0, False: 225]
  |  Branch (459:33): [True: 0, False: 225]
  |  Branch (459:69): [True: 0, False: 225]
  ------------------
  460|      0|      res.prev_link = NULL;
  461|      0|      return res;
  462|      0|   }
  463|       |
  464|       |   // on success, create new node
  465|    225|   node = context->free_head;
  466|    225|   node->x = (stbrp_coord) res.x;
  467|    225|   node->y = (stbrp_coord) (res.y + height);
  468|       |
  469|    225|   context->free_head = node->next;
  470|       |
  471|       |   // insert the new node into the right starting point, and
  472|       |   // let 'cur' point to the remaining nodes needing to be
  473|       |   // stiched back in
  474|       |
  475|    225|   cur = *res.prev_link;
  476|    225|   if (cur->x < res.x) {
  ------------------
  |  Branch (476:8): [True: 0, False: 225]
  ------------------
  477|       |      // preserve the existing one, so start testing with the next one
  478|      0|      stbrp_node *next = cur->next;
  479|      0|      cur->next = node;
  480|      0|      cur = next;
  481|    225|   } else {
  482|    225|      *res.prev_link = node;
  483|    225|   }
  484|       |
  485|       |   // from here, traverse cur and free the nodes, until we get to one
  486|       |   // that shouldn't be freed
  487|    361|   while (cur->next && cur->next->x <= res.x + width) {
  ------------------
  |  Branch (487:11): [True: 358, False: 3]
  |  Branch (487:24): [True: 136, False: 222]
  ------------------
  488|    136|      stbrp_node *next = cur->next;
  489|       |      // move the current node to the free list
  490|    136|      cur->next = context->free_head;
  491|    136|      context->free_head = cur;
  492|    136|      cur = next;
  493|    136|   }
  494|       |
  495|       |   // stitch the list back in
  496|    225|   node->next = cur;
  497|       |
  498|    225|   if (cur->x < res.x + width)
  ------------------
  |  Branch (498:8): [True: 177, False: 48]
  ------------------
  499|    177|      cur->x = (stbrp_coord) (res.x + width);
  500|       |
  501|       |#ifdef _DEBUG
  502|       |   cur = context->active_head;
  503|       |   while (cur->x < context->width) {
  504|       |      STBRP_ASSERT(cur->x < cur->next->x);
  505|       |      cur = cur->next;
  506|       |   }
  507|       |   STBRP_ASSERT(cur->next == NULL);
  508|       |
  509|       |   {
  510|       |      int count=0;
  511|       |      cur = context->active_head;
  512|       |      while (cur) {
  513|       |         cur = cur->next;
  514|       |         ++count;
  515|       |      }
  516|       |      cur = context->free_head;
  517|       |      while (cur) {
  518|       |         cur = cur->next;
  519|       |         ++count;
  520|       |      }
  521|       |      STBRP_ASSERT(count == context->num_nodes+2);
  522|       |   }
  523|       |#endif
  524|       |
  525|    225|   return res;
  526|    225|}
imgui_draw.cpp:_ZL28stbrp__skyline_find_best_posP13stbrp_contextii:
  348|    225|{
  349|    225|   int best_waste = (1<<30), best_x, best_y = (1 << 30);
  350|    225|   stbrp__findresult fr;
  351|    225|   stbrp_node **prev, *node, *tail, **best = NULL;
  352|       |
  353|       |   // align to multiple of c->align
  354|    225|   width = (width + c->align - 1);
  355|    225|   width -= width % c->align;
  356|    225|   STBRP_ASSERT(width % c->align == 0);
  ------------------
  |  |  117|    225|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  357|       |
  358|       |   // if it can't possibly fit, bail immediately
  359|    225|   if (width > c->width || height > c->height) {
  ------------------
  |  Branch (359:8): [True: 0, False: 225]
  |  Branch (359:28): [True: 0, False: 225]
  ------------------
  360|      0|      fr.prev_link = NULL;
  361|      0|      fr.x = fr.y = 0;
  362|      0|      return fr;
  363|      0|   }
  364|       |
  365|    225|   node = c->active_head;
  366|    225|   prev = &c->active_head;
  367|  11.9k|   while (node->x + width <= c->width) {
  ------------------
  |  Branch (367:11): [True: 11.7k, False: 225]
  ------------------
  368|  11.7k|      int y,waste;
  369|  11.7k|      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
  370|  11.7k|      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
  ------------------
  |  Branch (370:11): [True: 11.7k, False: 0]
  ------------------
  371|       |         // bottom left
  372|  11.7k|         if (y < best_y) {
  ------------------
  |  Branch (372:14): [True: 1.03k, False: 10.7k]
  ------------------
  373|  1.03k|            best_y = y;
  374|  1.03k|            best = prev;
  375|  1.03k|         }
  376|  11.7k|      } else {
  377|       |         // best-fit
  378|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (378:14): [True: 0, False: 0]
  ------------------
  379|       |            // can only use it if it first vertically
  380|      0|            if (y < best_y || (y == best_y && waste < best_waste)) {
  ------------------
  |  Branch (380:17): [True: 0, False: 0]
  |  Branch (380:32): [True: 0, False: 0]
  |  Branch (380:47): [True: 0, False: 0]
  ------------------
  381|      0|               best_y = y;
  382|      0|               best_waste = waste;
  383|      0|               best = prev;
  384|      0|            }
  385|      0|         }
  386|      0|      }
  387|  11.7k|      prev = &node->next;
  388|  11.7k|      node = node->next;
  389|  11.7k|   }
  390|       |
  391|    225|   best_x = (best == NULL) ? 0 : (*best)->x;
  ------------------
  |  Branch (391:13): [True: 0, False: 225]
  ------------------
  392|       |
  393|       |   // if doing best-fit (BF), we also have to try aligning right edge to each node position
  394|       |   //
  395|       |   // e.g, if fitting
  396|       |   //
  397|       |   //     ____________________
  398|       |   //    |____________________|
  399|       |   //
  400|       |   //            into
  401|       |   //
  402|       |   //   |                         |
  403|       |   //   |             ____________|
  404|       |   //   |____________|
  405|       |   //
  406|       |   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
  407|       |   //
  408|       |   // This makes BF take about 2x the time
  409|       |
  410|    225|   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
  ------------------
  |  Branch (410:8): [True: 0, False: 225]
  ------------------
  411|      0|      tail = c->active_head;
  412|      0|      node = c->active_head;
  413|      0|      prev = &c->active_head;
  414|       |      // find first node that's admissible
  415|      0|      while (tail->x < width)
  ------------------
  |  Branch (415:14): [True: 0, False: 0]
  ------------------
  416|      0|         tail = tail->next;
  417|      0|      while (tail) {
  ------------------
  |  Branch (417:14): [True: 0, False: 0]
  ------------------
  418|      0|         int xpos = tail->x - width;
  419|      0|         int y,waste;
  420|      0|         STBRP_ASSERT(xpos >= 0);
  ------------------
  |  |  117|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  421|       |         // find the left position that matches this
  422|      0|         while (node->next->x <= xpos) {
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|            prev = &node->next;
  424|      0|            node = node->next;
  425|      0|         }
  426|      0|         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
  ------------------
  |  |  117|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  427|      0|         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
  428|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (428:14): [True: 0, False: 0]
  ------------------
  429|      0|            if (y <= best_y) {
  ------------------
  |  Branch (429:17): [True: 0, False: 0]
  ------------------
  430|      0|               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
  ------------------
  |  Branch (430:20): [True: 0, False: 0]
  |  Branch (430:34): [True: 0, False: 0]
  |  Branch (430:57): [True: 0, False: 0]
  |  Branch (430:78): [True: 0, False: 0]
  ------------------
  431|      0|                  best_x = xpos;
  432|       |                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
  433|      0|                  best_y = y;
  434|      0|                  best_waste = waste;
  435|      0|                  best = prev;
  436|      0|               }
  437|      0|            }
  438|      0|         }
  439|      0|         tail = tail->next;
  440|      0|      }
  441|      0|   }
  442|       |
  443|    225|   fr.prev_link = best;
  444|    225|   fr.x = best_x;
  445|    225|   fr.y = best_y;
  446|    225|   return fr;
  447|    225|}
imgui_draw.cpp:_ZL25stbrp__skyline_find_min_yP13stbrp_contextP10stbrp_nodeiiPi:
  292|  11.7k|{
  293|  11.7k|   stbrp_node *node = first;
  294|  11.7k|   int x1 = x0 + width;
  295|  11.7k|   int min_y, visited_width, waste_area;
  296|       |
  297|  11.7k|   STBRP__NOTUSED(c);
  ------------------
  |  |  224|  11.7k|#define STBRP__NOTUSED(v)  (void)sizeof(v)
  ------------------
  298|       |
  299|  11.7k|   STBRP_ASSERT(first->x <= x0);
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  300|       |
  301|       |   #if 0
  302|       |   // skip in case we're past the node
  303|       |   while (node->next->x <= x0)
  304|       |      ++node;
  305|       |   #else
  306|  11.7k|   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  307|  11.7k|   #endif
  308|       |
  309|  11.7k|   STBRP_ASSERT(node->x <= x0);
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  310|       |
  311|  11.7k|   min_y = 0;
  312|  11.7k|   waste_area = 0;
  313|  11.7k|   visited_width = 0;
  314|  26.9k|   while (node->x < x1) {
  ------------------
  |  Branch (314:11): [True: 15.1k, False: 11.7k]
  ------------------
  315|  15.1k|      if (node->y > min_y) {
  ------------------
  |  Branch (315:11): [True: 11.9k, False: 3.19k]
  ------------------
  316|       |         // raise min_y higher.
  317|       |         // we've accounted for all waste up to min_y,
  318|       |         // but we'll now add more waste for everything we've visted
  319|  11.9k|         waste_area += visited_width * (node->y - min_y);
  320|  11.9k|         min_y = node->y;
  321|       |         // the first time through, visited_width might be reduced
  322|  11.9k|         if (node->x < x0)
  ------------------
  |  Branch (322:14): [True: 0, False: 11.9k]
  ------------------
  323|      0|            visited_width += node->next->x - x0;
  324|  11.9k|         else
  325|  11.9k|            visited_width += node->next->x - node->x;
  326|  11.9k|      } else {
  327|       |         // add waste area
  328|  3.19k|         int under_width = node->next->x - node->x;
  329|  3.19k|         if (under_width + visited_width > width)
  ------------------
  |  Branch (329:14): [True: 2.55k, False: 636]
  ------------------
  330|  2.55k|            under_width = width - visited_width;
  331|  3.19k|         waste_area += under_width * (min_y - node->y);
  332|  3.19k|         visited_width += under_width;
  333|  3.19k|      }
  334|  15.1k|      node = node->next;
  335|  15.1k|   }
  336|       |
  337|  11.7k|   *pwaste = waste_area;
  338|  11.7k|   return min_y;
  339|  11.7k|}
imgui_draw.cpp:_ZL19rect_original_orderPKvS0_:
  540|  1.33k|{
  541|  1.33k|   const stbrp_rect *p = (const stbrp_rect *) a;
  542|  1.33k|   const stbrp_rect *q = (const stbrp_rect *) b;
  543|  1.33k|   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
  ------------------
  |  Branch (543:11): [True: 722, False: 616]
  ------------------
  544|  1.33k|}

imgui_draw.cpp:_ZL27stbtt_GetFontOffsetForIndexPKhi:
 4951|      1|{
 4952|      1|   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
 4953|      1|}
imgui_draw.cpp:_ZL36stbtt_GetFontOffsetForIndex_internalPhi:
 1325|      1|{
 1326|       |   // if it's just a font, there's only one valid index
 1327|      1|   if (stbtt__isfont(font_collection))
  ------------------
  |  Branch (1327:8): [True: 1, False: 0]
  ------------------
 1328|      1|      return index == 0 ? 0 : -1;
  ------------------
  |  Branch (1328:14): [True: 1, False: 0]
  ------------------
 1329|       |
 1330|       |   // check if it's a TTC
 1331|      0|   if (stbtt_tag(font_collection, "ttcf")) {
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1332|       |      // version 1?
 1333|      0|      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
  ------------------
  |  Branch (1333:11): [True: 0, False: 0]
  |  Branch (1333:55): [True: 0, False: 0]
  ------------------
 1334|      0|         stbtt_int32 n = ttLONG(font_collection+8);
 1335|      0|         if (index >= n)
  ------------------
  |  Branch (1335:14): [True: 0, False: 0]
  ------------------
 1336|      0|            return -1;
 1337|      0|         return ttULONG(font_collection+12+index*4);
 1338|      0|      }
 1339|      0|   }
 1340|      0|   return -1;
 1341|      0|}
imgui_draw.cpp:_ZL13stbtt__isfontPh:
 1300|      1|{
 1301|       |   // check the version number
 1302|      1|   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1303|      1|   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1304|      1|   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1305|      1|   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 1, False: 0]
  |  |  |  Branch (1296:54): [True: 1, False: 0]
  |  |  |  Branch (1296:72): [True: 1, False: 0]
  |  |  |  Branch (1296:90): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 1306|      0|   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1307|      0|   return 0;
 1308|      0|}
imgui_draw.cpp:_ZL7ttULONGPh:
 1293|      9|static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
imgui_draw.cpp:_ZL14stbtt_InitFontP14stbtt_fontinfoPKhi:
 4961|      1|{
 4962|      1|   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
 4963|      1|}
imgui_draw.cpp:_ZL23stbtt_InitFont_internalP14stbtt_fontinfoPhi:
 1389|      1|{
 1390|      1|   stbtt_uint32 cmap, t;
 1391|      1|   stbtt_int32 i,numTables;
 1392|       |
 1393|      1|   info->data = data;
 1394|      1|   info->fontstart = fontstart;
 1395|      1|   info->cff = stbtt__new_buf(NULL, 0);
 1396|       |
 1397|      1|   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
 1398|      1|   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
 1399|      1|   info->head = stbtt__find_table(data, fontstart, "head"); // required
 1400|      1|   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
 1401|      1|   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
 1402|      1|   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
 1403|      1|   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
 1404|      1|   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required
 1405|       |
 1406|      1|   if (!cmap || !info->head || !info->hhea || !info->hmtx)
  ------------------
  |  Branch (1406:8): [True: 0, False: 1]
  |  Branch (1406:17): [True: 0, False: 1]
  |  Branch (1406:32): [True: 0, False: 1]
  |  Branch (1406:47): [True: 0, False: 1]
  ------------------
 1407|      0|      return 0;
 1408|      1|   if (info->glyf) {
  ------------------
  |  Branch (1408:8): [True: 1, False: 0]
  ------------------
 1409|       |      // required for truetype
 1410|      1|      if (!info->loca) return 0;
  ------------------
  |  Branch (1410:11): [True: 0, False: 1]
  ------------------
 1411|      1|   } else {
 1412|       |      // initialization for CFF / Type2 fonts (OTF)
 1413|      0|      stbtt__buf b, topdict, topdictidx;
 1414|      0|      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
 1415|      0|      stbtt_uint32 cff;
 1416|       |
 1417|      0|      cff = stbtt__find_table(data, fontstart, "CFF ");
 1418|      0|      if (!cff) return 0;
  ------------------
  |  Branch (1418:11): [True: 0, False: 0]
  ------------------
 1419|       |
 1420|      0|      info->fontdicts = stbtt__new_buf(NULL, 0);
 1421|      0|      info->fdselect = stbtt__new_buf(NULL, 0);
 1422|       |
 1423|       |      // @TODO this should use size from table (not 512MB)
 1424|      0|      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
 1425|      0|      b = info->cff;
 1426|       |
 1427|       |      // read the header
 1428|      0|      stbtt__buf_skip(&b, 2);
 1429|      0|      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize
 1430|       |
 1431|       |      // @TODO the name INDEX could list multiple fonts,
 1432|       |      // but we just use the first one.
 1433|      0|      stbtt__cff_get_index(&b);  // name INDEX
 1434|      0|      topdictidx = stbtt__cff_get_index(&b);
 1435|      0|      topdict = stbtt__cff_index_get(topdictidx, 0);
 1436|      0|      stbtt__cff_get_index(&b);  // string INDEX
 1437|      0|      info->gsubrs = stbtt__cff_get_index(&b);
 1438|       |
 1439|      0|      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
 1440|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
 1441|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
 1442|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
 1443|      0|      info->subrs = stbtt__get_subrs(b, topdict);
 1444|       |
 1445|       |      // we only support Type 2 charstrings
 1446|      0|      if (cstype != 2) return 0;
  ------------------
  |  Branch (1446:11): [True: 0, False: 0]
  ------------------
 1447|      0|      if (charstrings == 0) return 0;
  ------------------
  |  Branch (1447:11): [True: 0, False: 0]
  ------------------
 1448|       |
 1449|      0|      if (fdarrayoff) {
  ------------------
  |  Branch (1449:11): [True: 0, False: 0]
  ------------------
 1450|       |         // looks like a CID font
 1451|      0|         if (!fdselectoff) return 0;
  ------------------
  |  Branch (1451:14): [True: 0, False: 0]
  ------------------
 1452|      0|         stbtt__buf_seek(&b, fdarrayoff);
 1453|      0|         info->fontdicts = stbtt__cff_get_index(&b);
 1454|      0|         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
 1455|      0|      }
 1456|       |
 1457|      0|      stbtt__buf_seek(&b, charstrings);
 1458|      0|      info->charstrings = stbtt__cff_get_index(&b);
 1459|      0|   }
 1460|       |
 1461|      1|   t = stbtt__find_table(data, fontstart, "maxp");
 1462|      1|   if (t)
  ------------------
  |  Branch (1462:8): [True: 1, False: 0]
  ------------------
 1463|      1|      info->numGlyphs = ttUSHORT(data+t+4);
 1464|      0|   else
 1465|      0|      info->numGlyphs = 0xffff;
 1466|       |
 1467|      1|   info->svg = -1;
 1468|       |
 1469|       |   // find a cmap encoding table we understand *now* to avoid searching
 1470|       |   // later. (todo: could make this installable)
 1471|       |   // the same regardless of glyph.
 1472|      1|   numTables = ttUSHORT(data + cmap + 2);
 1473|      1|   info->index_map = 0;
 1474|      4|   for (i=0; i < numTables; ++i) {
  ------------------
  |  Branch (1474:14): [True: 3, False: 1]
  ------------------
 1475|      3|      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
 1476|       |      // find an encoding we understand:
 1477|      3|      switch(ttUSHORT(data+encoding_record)) {
  ------------------
  |  Branch (1477:14): [True: 1, False: 2]
  ------------------
 1478|      1|         case STBTT_PLATFORM_ID_MICROSOFT:
  ------------------
  |  Branch (1478:10): [True: 1, False: 2]
  ------------------
 1479|      1|            switch (ttUSHORT(data+encoding_record+2)) {
  ------------------
  |  Branch (1479:21): [True: 0, False: 1]
  ------------------
 1480|      1|               case STBTT_MS_EID_UNICODE_BMP:
  ------------------
  |  Branch (1480:16): [True: 1, False: 0]
  ------------------
 1481|      1|               case STBTT_MS_EID_UNICODE_FULL:
  ------------------
  |  Branch (1481:16): [True: 0, False: 1]
  ------------------
 1482|       |                  // MS/Unicode
 1483|      1|                  info->index_map = cmap + ttULONG(data+encoding_record+4);
 1484|      1|                  break;
 1485|      1|            }
 1486|      1|            break;
 1487|      1|        case STBTT_PLATFORM_ID_UNICODE:
  ------------------
  |  Branch (1487:9): [True: 1, False: 2]
  ------------------
 1488|       |            // Mac/iOS has these
 1489|       |            // all the encodingIDs are unicode, so we don't bother to check it
 1490|      1|            info->index_map = cmap + ttULONG(data+encoding_record+4);
 1491|      1|            break;
 1492|      3|      }
 1493|      3|   }
 1494|      1|   if (info->index_map == 0)
  ------------------
  |  Branch (1494:8): [True: 0, False: 1]
  ------------------
 1495|      0|      return 0;
 1496|       |
 1497|      1|   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
 1498|      1|   return 1;
 1499|      1|}
imgui_draw.cpp:_ZL14stbtt__new_bufPKvm:
 1174|      1|{
 1175|      1|   stbtt__buf r;
 1176|      1|   STBTT_assert(size < 0x40000000);
  ------------------
  |  |  133|      1|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1177|      1|   r.data = (stbtt_uint8*) p;
 1178|      1|   r.size = (int) size;
 1179|      1|   r.cursor = 0;
 1180|      1|   return r;
 1181|      1|}
imgui_draw.cpp:_ZL17stbtt__find_tablePhjPKc:
 1312|      9|{
 1313|      9|   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
 1314|      9|   stbtt_uint32 tabledir = fontstart + 12;
 1315|      9|   stbtt_int32 i;
 1316|     67|   for (i=0; i < num_tables; ++i) {
  ------------------
  |  Branch (1316:14): [True: 65, False: 2]
  ------------------
 1317|     65|      stbtt_uint32 loc = tabledir + 16*i;
 1318|     65|      if (stbtt_tag(data+loc+0, tag))
  ------------------
  |  | 1297|     65|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|     65|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 10, False: 55]
  |  |  |  |  |  Branch (1296:54): [True: 7, False: 3]
  |  |  |  |  |  Branch (1296:72): [True: 7, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 7, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1319|      7|         return ttULONG(data+loc+8);
 1320|     65|   }
 1321|      2|   return 0;
 1322|      9|}
imgui_draw.cpp:_ZL8ttUSHORTPh:
 1291|  12.9k|static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi:
 1502|    670|{
 1503|    670|   stbtt_uint8 *data = info->data;
 1504|    670|   stbtt_uint32 index_map = info->index_map;
 1505|       |
 1506|    670|   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
 1507|    670|   if (format == 0) { // apple byte encoding
  ------------------
  |  Branch (1507:8): [True: 0, False: 670]
  ------------------
 1508|      0|      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
 1509|      0|      if (unicode_codepoint < bytes-6)
  ------------------
  |  Branch (1509:11): [True: 0, False: 0]
  ------------------
 1510|      0|         return ttBYTE(data + index_map + 6 + unicode_codepoint);
  ------------------
  |  | 1287|      0|#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
  ------------------
 1511|      0|      return 0;
 1512|    670|   } else if (format == 6) {
  ------------------
  |  Branch (1512:15): [True: 0, False: 670]
  ------------------
 1513|      0|      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
 1514|      0|      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
 1515|      0|      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
  ------------------
  |  Branch (1515:11): [True: 0, False: 0]
  |  Branch (1515:56): [True: 0, False: 0]
  ------------------
 1516|      0|         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
 1517|      0|      return 0;
 1518|    670|   } else if (format == 2) {
  ------------------
  |  Branch (1518:15): [True: 0, False: 670]
  ------------------
 1519|      0|      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1520|      0|      return 0;
 1521|    670|   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
  ------------------
  |  Branch (1521:15): [True: 670, False: 0]
  ------------------
 1522|    670|      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
 1523|    670|      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
 1524|    670|      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
 1525|    670|      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;
 1526|       |
 1527|       |      // do a binary search of the segments
 1528|    670|      stbtt_uint32 endCount = index_map + 14;
 1529|    670|      stbtt_uint32 search = endCount;
 1530|       |
 1531|    670|      if (unicode_codepoint > 0xffff)
  ------------------
  |  Branch (1531:11): [True: 0, False: 670]
  ------------------
 1532|      0|         return 0;
 1533|       |
 1534|       |      // they lie from endCount .. endCount + segCount
 1535|       |      // but searchRange is the nearest power of two, so...
 1536|    670|      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
  ------------------
  |  Branch (1536:11): [True: 385, False: 285]
  ------------------
 1537|    385|         search += rangeShift*2;
 1538|       |
 1539|       |      // now decrement to bias correctly to find smallest
 1540|    670|      search -= 2;
 1541|  2.01k|      while (entrySelector) {
  ------------------
  |  Branch (1541:14): [True: 1.34k, False: 670]
  ------------------
 1542|  1.34k|         stbtt_uint16 end;
 1543|  1.34k|         searchRange >>= 1;
 1544|  1.34k|         end = ttUSHORT(data + search + searchRange*2);
 1545|  1.34k|         if (unicode_codepoint > end)
  ------------------
  |  Branch (1545:14): [True: 382, False: 958]
  ------------------
 1546|    382|            search += searchRange*2;
 1547|  1.34k|         --entrySelector;
 1548|  1.34k|      }
 1549|    670|      search += 2;
 1550|       |
 1551|    670|      {
 1552|    670|         stbtt_uint16 offset, start, last;
 1553|    670|         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
 1554|       |
 1555|    670|         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
 1556|    670|         last = ttUSHORT(data + endCount + 2*item);
 1557|    670|         if (unicode_codepoint < start || unicode_codepoint > last)
  ------------------
  |  Branch (1557:14): [True: 1, False: 669]
  |  Branch (1557:43): [True: 0, False: 669]
  ------------------
 1558|      1|            return 0;
 1559|       |
 1560|    669|         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
 1561|    669|         if (offset == 0)
  ------------------
  |  Branch (1561:14): [True: 669, False: 0]
  ------------------
 1562|    669|            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));
 1563|       |
 1564|      0|         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
 1565|    669|      }
 1566|    669|   } else if (format == 12 || format == 13) {
  ------------------
  |  Branch (1566:15): [True: 0, False: 0]
  |  Branch (1566:31): [True: 0, False: 0]
  ------------------
 1567|      0|      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
 1568|      0|      stbtt_int32 low,high;
 1569|      0|      low = 0; high = (stbtt_int32)ngroups;
 1570|       |      // Binary search the right group.
 1571|      0|      while (low < high) {
  ------------------
  |  Branch (1571:14): [True: 0, False: 0]
  ------------------
 1572|      0|         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
 1573|      0|         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
 1574|      0|         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
 1575|      0|         if ((stbtt_uint32) unicode_codepoint < start_char)
  ------------------
  |  Branch (1575:14): [True: 0, False: 0]
  ------------------
 1576|      0|            high = mid;
 1577|      0|         else if ((stbtt_uint32) unicode_codepoint > end_char)
  ------------------
  |  Branch (1577:19): [True: 0, False: 0]
  ------------------
 1578|      0|            low = mid+1;
 1579|      0|         else {
 1580|      0|            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
 1581|      0|            if (format == 12)
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|               return start_glyph + unicode_codepoint-start_char;
 1583|      0|            else // format == 13
 1584|      0|               return start_glyph;
 1585|      0|         }
 1586|      0|      }
 1587|      0|      return 0; // not found
 1588|      0|   }
 1589|       |   // @TODO
 1590|      0|   STBTT_assert(0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1591|      0|   return 0;
 1592|    670|}
imgui_draw.cpp:_ZL7ttSHORTPh:
 1292|  3.90k|static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof:
 2666|      3|{
 2667|      3|   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
 2668|      3|   return (float) height / fheight;
 2669|      3|}
imgui_draw.cpp:_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_:
 2727|    669|{
 2728|    669|   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
 2729|    669|   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
  ------------------
  |  Branch (2729:8): [True: 27, False: 642]
  ------------------
 2730|       |      // e.g. space character
 2731|     27|      if (ix0) *ix0 = 0;
  ------------------
  |  Branch (2731:11): [True: 27, False: 0]
  ------------------
 2732|     27|      if (iy0) *iy0 = 0;
  ------------------
  |  Branch (2732:11): [True: 27, False: 0]
  ------------------
 2733|     27|      if (ix1) *ix1 = 0;
  ------------------
  |  Branch (2733:11): [True: 18, False: 9]
  ------------------
 2734|     27|      if (iy1) *iy1 = 0;
  ------------------
  |  Branch (2734:11): [True: 18, False: 9]
  ------------------
 2735|    642|   } else {
 2736|       |      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
 2737|    642|      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
  ------------------
  |  |  138|    642|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
  |  Branch (2737:11): [True: 642, False: 0]
  ------------------
 2738|    642|      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
  ------------------
  |  |  138|    642|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
  |  Branch (2738:11): [True: 642, False: 0]
  ------------------
 2739|    642|      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
  ------------------
  |  |  139|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  442|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2739:11): [True: 428, False: 214]
  ------------------
 2740|    642|      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
  ------------------
  |  |  139|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  442|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2740:11): [True: 428, False: 214]
  ------------------
 2741|    642|   }
 2742|    669|}
imgui_draw.cpp:_ZL17stbtt_GetGlyphBoxPK14stbtt_fontinfoiPiS2_S2_S2_:
 1631|    669|{
 1632|    669|   if (info->cff.size) {
  ------------------
  |  Branch (1632:8): [True: 0, False: 669]
  ------------------
 1633|      0|      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
 1634|    669|   } else {
 1635|    669|      int g = stbtt__GetGlyfOffset(info, glyph_index);
 1636|    669|      if (g < 0) return 0;
  ------------------
  |  Branch (1636:11): [True: 27, False: 642]
  ------------------
 1637|       |
 1638|    642|      if (x0) *x0 = ttSHORT(info->data + g + 2);
  ------------------
  |  Branch (1638:11): [True: 642, False: 0]
  ------------------
 1639|    642|      if (y0) *y0 = ttSHORT(info->data + g + 4);
  ------------------
  |  Branch (1639:11): [True: 642, False: 0]
  ------------------
 1640|    642|      if (x1) *x1 = ttSHORT(info->data + g + 6);
  ------------------
  |  Branch (1640:11): [True: 642, False: 0]
  ------------------
 1641|    642|      if (y1) *y1 = ttSHORT(info->data + g + 8);
  ------------------
  |  Branch (1641:11): [True: 642, False: 0]
  ------------------
 1642|    642|   }
 1643|    642|   return 1;
 1644|    669|}
imgui_draw.cpp:_ZL15stbtt_setvertexP12stbtt_vertexhiiii:
 1600|  15.8k|{
 1601|  15.8k|   v->type = type;
 1602|  15.8k|   v->x = (stbtt_int16) x;
 1603|  15.8k|   v->y = (stbtt_int16) y;
 1604|  15.8k|   v->cx = (stbtt_int16) cx;
 1605|  15.8k|   v->cy = (stbtt_int16) cy;
 1606|  15.8k|}
imgui_draw.cpp:_ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi:
 1609|    892|{
 1610|    892|   int g1,g2;
 1611|       |
 1612|    892|   STBTT_assert(!info->cff.size);
  ------------------
  |  |  133|    892|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|    892|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1613|       |
 1614|    892|   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
  ------------------
  |  Branch (1614:8): [True: 0, False: 892]
  ------------------
 1615|    892|   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format
  ------------------
  |  Branch (1615:8): [True: 0, False: 892]
  ------------------
 1616|       |
 1617|    892|   if (info->indexToLocFormat == 0) {
  ------------------
  |  Branch (1617:8): [True: 892, False: 0]
  ------------------
 1618|    892|      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
 1619|    892|      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
 1620|    892|   } else {
 1621|      0|      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
 1622|      0|      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
 1623|      0|   }
 1624|       |
 1625|    892|   return g1==g2 ? -1 : g1; // if length is 0, return -1
  ------------------
  |  Branch (1625:11): [True: 36, False: 856]
  ------------------
 1626|    892|}
imgui_draw.cpp:_ZL15stbtt_PackBeginP18stbtt_pack_contextPhiiiiPv:
 3966|      1|{
 3967|      1|   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
  ------------------
  |  |  131|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3968|      1|   int            num_nodes = pw - padding;
 3969|      1|   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);
  ------------------
  |  |  131|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3970|       |
 3971|      1|   if (context == NULL || nodes == NULL) {
  ------------------
  |  Branch (3971:8): [True: 0, False: 1]
  |  Branch (3971:27): [True: 0, False: 1]
  ------------------
 3972|      0|      if (context != NULL) STBTT_free(context, alloc_context);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3972:11): [True: 0, False: 0]
  ------------------
 3973|      0|      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3973:11): [True: 0, False: 0]
  ------------------
 3974|      0|      return 0;
 3975|      0|   }
 3976|       |
 3977|      1|   spc->user_allocator_context = alloc_context;
 3978|      1|   spc->width = pw;
 3979|      1|   spc->height = ph;
 3980|      1|   spc->pixels = pixels;
 3981|      1|   spc->pack_info = context;
 3982|      1|   spc->nodes = nodes;
 3983|      1|   spc->padding = padding;
 3984|      1|   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
  ------------------
  |  Branch (3984:27): [True: 0, False: 1]
  ------------------
 3985|      1|   spc->h_oversample = 1;
 3986|      1|   spc->v_oversample = 1;
 3987|      1|   spc->skip_missing = 0;
 3988|       |
 3989|      1|   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
 3990|       |
 3991|      1|   if (pixels)
  ------------------
  |  Branch (3991:8): [True: 0, False: 1]
  ------------------
 3992|      0|      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
  ------------------
  |  |  493|      0|   #define STBTT_memset       memset
  ------------------
 3993|       |
 3994|      1|   return 1;
 3995|      1|}
imgui_draw.cpp:_ZL35stbtt_PackFontRangesRenderIntoRectsP18stbtt_pack_contextPK14stbtt_fontinfoP16stbtt_pack_rangeiP10stbrp_rect:
 4217|      1|{
 4218|      1|   int i,j,k, missing_glyph = -1, return_value = 1;
 4219|       |
 4220|       |   // save current values
 4221|      1|   int old_h_over = spc->h_oversample;
 4222|      1|   int old_v_over = spc->v_oversample;
 4223|       |
 4224|      1|   k = 0;
 4225|      2|   for (i=0; i < num_ranges; ++i) {
  ------------------
  |  Branch (4225:14): [True: 1, False: 1]
  ------------------
 4226|      1|      float fh = ranges[i].font_size;
 4227|      1|      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
  ------------------
  |  Branch (4227:21): [True: 1, False: 0]
  ------------------
 4228|      1|      float recip_h,recip_v,sub_x,sub_y;
 4229|      1|      spc->h_oversample = ranges[i].h_oversample;
 4230|      1|      spc->v_oversample = ranges[i].v_oversample;
 4231|      1|      recip_h = 1.0f / spc->h_oversample;
 4232|      1|      recip_v = 1.0f / spc->v_oversample;
 4233|      1|      sub_x = stbtt__oversample_shift(spc->h_oversample);
 4234|      1|      sub_y = stbtt__oversample_shift(spc->v_oversample);
 4235|    224|      for (j=0; j < ranges[i].num_chars; ++j) {
  ------------------
  |  Branch (4235:17): [True: 223, False: 1]
  ------------------
 4236|    223|         stbrp_rect *r = &rects[k];
 4237|    223|         if (r->was_packed && r->w != 0 && r->h != 0) {
  ------------------
  |  Branch (4237:14): [True: 223, False: 0]
  |  Branch (4237:31): [True: 223, False: 0]
  |  Branch (4237:44): [True: 223, False: 0]
  ------------------
 4238|    223|            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
 4239|    223|            int advance, lsb, x0,y0,x1,y1;
 4240|    223|            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
  ------------------
  |  Branch (4240:29): [True: 0, False: 223]
  ------------------
 4241|    223|            int glyph = stbtt_FindGlyphIndex(info, codepoint);
 4242|    223|            stbrp_coord pad = (stbrp_coord) spc->padding;
 4243|       |
 4244|       |            // pad on left and top
 4245|    223|            r->x += pad;
 4246|    223|            r->y += pad;
 4247|    223|            r->w -= pad;
 4248|    223|            r->h -= pad;
 4249|    223|            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
 4250|    223|            stbtt_GetGlyphBitmapBox(info, glyph,
 4251|    223|                                    scale * spc->h_oversample,
 4252|    223|                                    scale * spc->v_oversample,
 4253|    223|                                    &x0,&y0,&x1,&y1);
 4254|    223|            stbtt_MakeGlyphBitmapSubpixel(info,
 4255|    223|                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4256|    223|                                          r->w - spc->h_oversample+1,
 4257|    223|                                          r->h - spc->v_oversample+1,
 4258|    223|                                          spc->stride_in_bytes,
 4259|    223|                                          scale * spc->h_oversample,
 4260|    223|                                          scale * spc->v_oversample,
 4261|    223|                                          0,0,
 4262|    223|                                          glyph);
 4263|       |
 4264|    223|            if (spc->h_oversample > 1)
  ------------------
  |  Branch (4264:17): [True: 0, False: 223]
  ------------------
 4265|      0|               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4266|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4267|      0|                                  spc->h_oversample);
 4268|       |
 4269|    223|            if (spc->v_oversample > 1)
  ------------------
  |  Branch (4269:17): [True: 0, False: 223]
  ------------------
 4270|      0|               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4271|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4272|      0|                                  spc->v_oversample);
 4273|       |
 4274|    223|            bc->x0       = (stbtt_int16)  r->x;
 4275|    223|            bc->y0       = (stbtt_int16)  r->y;
 4276|    223|            bc->x1       = (stbtt_int16) (r->x + r->w);
 4277|    223|            bc->y1       = (stbtt_int16) (r->y + r->h);
 4278|    223|            bc->xadvance =                scale * advance;
 4279|    223|            bc->xoff     =       (float)  x0 * recip_h + sub_x;
 4280|    223|            bc->yoff     =       (float)  y0 * recip_v + sub_y;
 4281|    223|            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
 4282|    223|            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
 4283|       |
 4284|    223|            if (glyph == 0)
  ------------------
  |  Branch (4284:17): [True: 0, False: 223]
  ------------------
 4285|      0|               missing_glyph = j;
 4286|    223|         } else if (spc->skip_missing) {
  ------------------
  |  Branch (4286:21): [True: 0, False: 0]
  ------------------
 4287|      0|            return_value = 0;
 4288|      0|         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
  ------------------
  |  Branch (4288:21): [True: 0, False: 0]
  |  Branch (4288:38): [True: 0, False: 0]
  |  Branch (4288:51): [True: 0, False: 0]
  |  Branch (4288:64): [True: 0, False: 0]
  ------------------
 4289|      0|            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
 4290|      0|         } else {
 4291|      0|            return_value = 0; // if any fail, report failure
 4292|      0|         }
 4293|       |
 4294|    223|         ++k;
 4295|    223|      }
 4296|      1|   }
 4297|       |
 4298|       |   // restore original values
 4299|      1|   spc->h_oversample = old_h_over;
 4300|      1|   spc->v_oversample = old_v_over;
 4301|       |
 4302|      1|   return return_value;
 4303|      1|}
imgui_draw.cpp:_ZL23stbtt__oversample_shifti:
 4145|      2|{
 4146|      2|   if (!oversample)
  ------------------
  |  Branch (4146:8): [True: 0, False: 2]
  ------------------
 4147|      0|      return 0.0f;
 4148|       |
 4149|       |   // The prefilter is a box filter of width "oversample",
 4150|       |   // which shifts phase by (oversample - 1)/2 pixels in
 4151|       |   // oversampled space. We want to shift in the opposite
 4152|       |   // direction to counter this.
 4153|      2|   return (float)-(oversample - 1) / (2.0f * (float)oversample);
 4154|      2|}
imgui_draw.cpp:_ZL22stbtt_GetGlyphHMetricsPK14stbtt_fontinfoiPiS2_:
 2311|    223|{
 2312|    223|   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
 2313|    223|   if (glyph_index < numOfLongHorMetrics) {
  ------------------
  |  Branch (2313:8): [True: 0, False: 223]
  ------------------
 2314|      0|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
  ------------------
  |  Branch (2314:11): [True: 0, False: 0]
  ------------------
 2315|      0|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
  ------------------
  |  Branch (2315:11): [True: 0, False: 0]
  ------------------
 2316|    223|   } else {
 2317|    223|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
  ------------------
  |  Branch (2317:11): [True: 223, False: 0]
  ------------------
 2318|    223|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
  ------------------
  |  Branch (2318:11): [True: 223, False: 0]
  ------------------
 2319|    223|   }
 2320|    223|}
imgui_draw.cpp:_ZL23stbtt_GetGlyphBitmapBoxPK14stbtt_fontinfoiffPiS2_S2_S2_:
 2745|    223|{
 2746|    223|   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
 2747|    223|}
imgui_draw.cpp:_ZL29stbtt_MakeGlyphBitmapSubpixelPK14stbtt_fontinfoPhiiiffffi:
 3767|    223|{
 3768|    223|   int ix0,iy0;
 3769|    223|   stbtt_vertex *vertices;
 3770|    223|   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
 3771|    223|   stbtt__bitmap gbm;
 3772|       |
 3773|    223|   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
 3774|    223|   gbm.pixels = output;
 3775|    223|   gbm.w = out_w;
 3776|    223|   gbm.h = out_h;
 3777|    223|   gbm.stride = out_stride;
 3778|       |
 3779|    223|   if (gbm.w && gbm.h)
  ------------------
  |  Branch (3779:8): [True: 214, False: 9]
  |  Branch (3779:17): [True: 214, False: 0]
  ------------------
 3780|    214|      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);
 3781|       |
 3782|    223|   STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|    223|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|    223|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3783|    223|}
imgui_draw.cpp:_ZL19stbtt_GetGlyphShapePK14stbtt_fontinfoiPP12stbtt_vertex:
 2303|    223|{
 2304|    223|   if (!info->cff.size)
  ------------------
  |  Branch (2304:8): [True: 223, False: 0]
  ------------------
 2305|    223|      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
 2306|      0|   else
 2307|      0|      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
 2308|    223|}
imgui_draw.cpp:_ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex:
 1680|    223|{
 1681|    223|   stbtt_int16 numberOfContours;
 1682|    223|   stbtt_uint8 *endPtsOfContours;
 1683|    223|   stbtt_uint8 *data = info->data;
 1684|    223|   stbtt_vertex *vertices=0;
 1685|    223|   int num_vertices=0;
 1686|    223|   int g = stbtt__GetGlyfOffset(info, glyph_index);
 1687|       |
 1688|    223|   *pvertices = NULL;
 1689|       |
 1690|    223|   if (g < 0) return 0;
  ------------------
  |  Branch (1690:8): [True: 9, False: 214]
  ------------------
 1691|       |
 1692|    214|   numberOfContours = ttSHORT(data + g);
 1693|       |
 1694|    214|   if (numberOfContours > 0) {
  ------------------
  |  Branch (1694:8): [True: 214, False: 0]
  ------------------
 1695|    214|      stbtt_uint8 flags=0,flagcount;
 1696|    214|      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
 1697|    214|      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
 1698|    214|      stbtt_uint8 *points;
 1699|    214|      endPtsOfContours = (data + g + 10);
 1700|    214|      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
 1701|    214|      points = data + g + 10 + numberOfContours * 2 + 2 + ins;
 1702|       |
 1703|    214|      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);
 1704|       |
 1705|    214|      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
 1706|    214|      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1707|    214|      if (vertices == 0)
  ------------------
  |  Branch (1707:11): [True: 0, False: 214]
  ------------------
 1708|      0|         return 0;
 1709|       |
 1710|    214|      next_move = 0;
 1711|    214|      flagcount=0;
 1712|       |
 1713|       |      // in first pass, we load uninterpreted data into the allocated array
 1714|       |      // above, shifted to the end of the array so we won't overwrite it when
 1715|       |      // we create our final data starting from the front
 1716|       |
 1717|    214|      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
 1718|       |
 1719|       |      // first load flags
 1720|       |
 1721|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1721:17): [True: 12.6k, False: 214]
  ------------------
 1722|  12.6k|         if (flagcount == 0) {
  ------------------
  |  Branch (1722:14): [True: 12.5k, False: 63]
  ------------------
 1723|  12.5k|            flags = *points++;
 1724|  12.5k|            if (flags & 8)
  ------------------
  |  Branch (1724:17): [True: 63, False: 12.5k]
  ------------------
 1725|     63|               flagcount = *points++;
 1726|  12.5k|         } else
 1727|     63|            --flagcount;
 1728|  12.6k|         vertices[off+i].type = flags;
 1729|  12.6k|      }
 1730|       |
 1731|       |      // now load x coordinates
 1732|    214|      x=0;
 1733|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1733:17): [True: 12.6k, False: 214]
  ------------------
 1734|  12.6k|         flags = vertices[off+i].type;
 1735|  12.6k|         if (flags & 2) {
  ------------------
  |  Branch (1735:14): [True: 3.76k, False: 8.87k]
  ------------------
 1736|  3.76k|            stbtt_int16 dx = *points++;
 1737|  3.76k|            x += (flags & 16) ? dx : -dx; // ???
  ------------------
  |  Branch (1737:18): [True: 3.41k, False: 350]
  ------------------
 1738|  8.87k|         } else {
 1739|  8.87k|            if (!(flags & 16)) {
  ------------------
  |  Branch (1739:17): [True: 1.56k, False: 7.30k]
  ------------------
 1740|  1.56k|               x = x + (stbtt_int16) (points[0]*256 + points[1]);
 1741|  1.56k|               points += 2;
 1742|  1.56k|            }
 1743|  8.87k|         }
 1744|  12.6k|         vertices[off+i].x = (stbtt_int16) x;
 1745|  12.6k|      }
 1746|       |
 1747|       |      // now load y coordinates
 1748|    214|      y=0;
 1749|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1749:17): [True: 12.6k, False: 214]
  ------------------
 1750|  12.6k|         flags = vertices[off+i].type;
 1751|  12.6k|         if (flags & 4) {
  ------------------
  |  Branch (1751:14): [True: 7.59k, False: 5.04k]
  ------------------
 1752|  7.59k|            stbtt_int16 dy = *points++;
 1753|  7.59k|            y += (flags & 32) ? dy : -dy; // ???
  ------------------
  |  Branch (1753:18): [True: 3.16k, False: 4.43k]
  ------------------
 1754|  7.59k|         } else {
 1755|  5.04k|            if (!(flags & 32)) {
  ------------------
  |  Branch (1755:17): [True: 273, False: 4.77k]
  ------------------
 1756|    273|               y = y + (stbtt_int16) (points[0]*256 + points[1]);
 1757|    273|               points += 2;
 1758|    273|            }
 1759|  5.04k|         }
 1760|  12.6k|         vertices[off+i].y = (stbtt_int16) y;
 1761|  12.6k|      }
 1762|       |
 1763|       |      // now convert them to our format
 1764|    214|      num_vertices=0;
 1765|    214|      sx = sy = cx = cy = scx = scy = 0;
 1766|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1766:17): [True: 12.6k, False: 214]
  ------------------
 1767|  12.6k|         flags = vertices[off+i].type;
 1768|  12.6k|         x     = (stbtt_int16) vertices[off+i].x;
 1769|  12.6k|         y     = (stbtt_int16) vertices[off+i].y;
 1770|       |
 1771|  12.6k|         if (next_move == i) {
  ------------------
  |  Branch (1771:14): [True: 3.16k, False: 9.48k]
  ------------------
 1772|  3.16k|            if (i != 0)
  ------------------
  |  Branch (1772:17): [True: 2.94k, False: 214]
  ------------------
 1773|  2.94k|               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1774|       |
 1775|       |            // now start the new one
 1776|  3.16k|            start_off = !(flags & 1);
 1777|  3.16k|            if (start_off) {
  ------------------
  |  Branch (1777:17): [True: 0, False: 3.16k]
  ------------------
 1778|       |               // if we start off with an off-curve point, then when we need to find a point on the curve
 1779|       |               // where we can start, and we need to save some state for when we wraparound.
 1780|      0|               scx = x;
 1781|      0|               scy = y;
 1782|      0|               if (!(vertices[off+i+1].type & 1)) {
  ------------------
  |  Branch (1782:20): [True: 0, False: 0]
  ------------------
 1783|       |                  // next point is also a curve point, so interpolate an on-point curve
 1784|      0|                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
 1785|      0|                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
 1786|      0|               } else {
 1787|       |                  // otherwise just use the next point as our start point
 1788|      0|                  sx = (stbtt_int32) vertices[off+i+1].x;
 1789|      0|                  sy = (stbtt_int32) vertices[off+i+1].y;
 1790|      0|                  ++i; // we're using point i+1 as the starting point, so skip it
 1791|      0|               }
 1792|  3.16k|            } else {
 1793|  3.16k|               sx = x;
 1794|  3.16k|               sy = y;
 1795|  3.16k|            }
 1796|  3.16k|            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
 1797|  3.16k|            was_off = 0;
 1798|  3.16k|            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
 1799|  3.16k|            ++j;
 1800|  9.48k|         } else {
 1801|  9.48k|            if (!(flags & 1)) { // if it's a curve
  ------------------
  |  Branch (1801:17): [True: 0, False: 9.48k]
  ------------------
 1802|      0|               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
  ------------------
  |  Branch (1802:20): [True: 0, False: 0]
  ------------------
 1803|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
 1804|      0|               cx = x;
 1805|      0|               cy = y;
 1806|      0|               was_off = 1;
 1807|  9.48k|            } else {
 1808|  9.48k|               if (was_off)
  ------------------
  |  Branch (1808:20): [True: 0, False: 9.48k]
  ------------------
 1809|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
 1810|  9.48k|               else
 1811|  9.48k|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
 1812|  9.48k|               was_off = 0;
 1813|  9.48k|            }
 1814|  9.48k|         }
 1815|  12.6k|      }
 1816|    214|      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1817|    214|   } else if (numberOfContours < 0) {
  ------------------
  |  Branch (1817:15): [True: 0, False: 0]
  ------------------
 1818|       |      // Compound shapes.
 1819|      0|      int more = 1;
 1820|      0|      stbtt_uint8 *comp = data + g + 10;
 1821|      0|      num_vertices = 0;
 1822|      0|      vertices = 0;
 1823|      0|      while (more) {
  ------------------
  |  Branch (1823:14): [True: 0, False: 0]
  ------------------
 1824|      0|         stbtt_uint16 flags, gidx;
 1825|      0|         int comp_num_verts = 0, i;
 1826|      0|         stbtt_vertex *comp_verts = 0, *tmp = 0;
 1827|      0|         float mtx[6] = {1,0,0,1,0,0}, m, n;
 1828|       |
 1829|      0|         flags = ttSHORT(comp); comp+=2;
 1830|      0|         gidx = ttSHORT(comp); comp+=2;
 1831|       |
 1832|      0|         if (flags & 2) { // XY values
  ------------------
  |  Branch (1832:14): [True: 0, False: 0]
  ------------------
 1833|      0|            if (flags & 1) { // shorts
  ------------------
  |  Branch (1833:17): [True: 0, False: 0]
  ------------------
 1834|      0|               mtx[4] = ttSHORT(comp); comp+=2;
 1835|      0|               mtx[5] = ttSHORT(comp); comp+=2;
 1836|      0|            } else {
 1837|      0|               mtx[4] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1838|      0|               mtx[5] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1839|      0|            }
 1840|      0|         }
 1841|      0|         else {
 1842|       |            // @TODO handle matching point
 1843|      0|            STBTT_assert(0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1844|      0|         }
 1845|      0|         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
  ------------------
  |  Branch (1845:14): [True: 0, False: 0]
  ------------------
 1846|      0|            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1847|      0|            mtx[1] = mtx[2] = 0;
 1848|      0|         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
  ------------------
  |  Branch (1848:21): [True: 0, False: 0]
  ------------------
 1849|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1850|      0|            mtx[1] = mtx[2] = 0;
 1851|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1852|      0|         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
  ------------------
  |  Branch (1852:21): [True: 0, False: 0]
  ------------------
 1853|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1854|      0|            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
 1855|      0|            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
 1856|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1857|      0|         }
 1858|       |
 1859|       |         // Find transformation scales.
 1860|      0|         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
  ------------------
  |  |  135|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  434|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1861|      0|         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);
  ------------------
  |  |  135|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  434|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1862|       |
 1863|       |         // Get indexed glyph.
 1864|      0|         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
 1865|      0|         if (comp_num_verts > 0) {
  ------------------
  |  Branch (1865:14): [True: 0, False: 0]
  ------------------
 1866|       |            // Transform vertices.
 1867|      0|            for (i = 0; i < comp_num_verts; ++i) {
  ------------------
  |  Branch (1867:25): [True: 0, False: 0]
  ------------------
 1868|      0|               stbtt_vertex* v = &comp_verts[i];
 1869|      0|               stbtt_vertex_type x,y;
  ------------------
  |  |  839|      0|   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
  ------------------
 1870|      0|               x=v->x; y=v->y;
 1871|      0|               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1872|      0|               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1873|      0|               x=v->cx; y=v->cy;
 1874|      0|               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1875|      0|               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1876|      0|            }
 1877|       |            // Append vertices.
 1878|      0|            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
  ------------------
  |  |  131|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1879|      0|            if (!tmp) {
  ------------------
  |  Branch (1879:17): [True: 0, False: 0]
  ------------------
 1880|      0|               if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1880:20): [True: 0, False: 0]
  ------------------
 1881|      0|               if (comp_verts) STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1881:20): [True: 0, False: 0]
  ------------------
 1882|      0|               return 0;
 1883|      0|            }
 1884|      0|            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
  |  Branch (1884:17): [True: 0, False: 0]
  |  Branch (1884:37): [True: 0, False: 0]
  ------------------
 1885|      0|            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
 1886|      0|            if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1886:17): [True: 0, False: 0]
  ------------------
 1887|      0|            vertices = tmp;
 1888|      0|            STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 1889|      0|            num_vertices += comp_num_verts;
 1890|      0|         }
 1891|       |         // More components ?
 1892|      0|         more = flags & (1<<5);
 1893|      0|      }
 1894|      0|   } else {
 1895|       |      // numberOfCounters == 0, do nothing
 1896|      0|   }
 1897|       |
 1898|    214|   *pvertices = vertices;
 1899|    214|   return num_vertices;
 1900|    214|}
imgui_draw.cpp:_ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii:
 1665|  3.16k|{
 1666|  3.16k|   if (start_off) {
  ------------------
  |  Branch (1666:8): [True: 0, False: 3.16k]
  ------------------
 1667|      0|      if (was_off)
  ------------------
  |  Branch (1667:11): [True: 0, False: 0]
  ------------------
 1668|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
 1669|      0|      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
 1670|  3.16k|   } else {
 1671|  3.16k|      if (was_off)
  ------------------
  |  Branch (1671:11): [True: 0, False: 3.16k]
  ------------------
 1672|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
 1673|  3.16k|      else
 1674|  3.16k|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
 1675|  3.16k|   }
 1676|  3.16k|   return num_vertices;
 1677|  3.16k|}
imgui_draw.cpp:_ZL15stbtt_RasterizeP13stbtt__bitmapfP12stbtt_vertexiffffiiiPv:
 3704|    214|{
 3705|    214|   float scale            = scale_x > scale_y ? scale_y : scale_x;
  ------------------
  |  Branch (3705:29): [True: 0, False: 214]
  ------------------
 3706|    214|   int winding_count      = 0;
 3707|    214|   int *winding_lengths   = NULL;
 3708|    214|   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
 3709|    214|   if (windings) {
  ------------------
  |  Branch (3709:8): [True: 214, False: 0]
  ------------------
 3710|    214|      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
 3711|    214|      STBTT_free(winding_lengths, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3712|    214|      STBTT_free(windings, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3713|    214|   }
 3714|    214|}
imgui_draw.cpp:_ZL19stbtt_FlattenCurvesP12stbtt_vertexifPPiS1_Pv:
 3627|    214|{
 3628|    214|   stbtt__point *points=0;
 3629|    214|   int num_points=0;
 3630|       |
 3631|    214|   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
 3632|    214|   int i,n=0,start=0, pass;
 3633|       |
 3634|       |   // count how many "moves" there are to get the contour count
 3635|  16.0k|   for (i=0; i < num_verts; ++i)
  ------------------
  |  Branch (3635:14): [True: 15.8k, False: 214]
  ------------------
 3636|  15.8k|      if (vertices[i].type == STBTT_vmove)
  ------------------
  |  Branch (3636:11): [True: 3.16k, False: 12.6k]
  ------------------
 3637|  3.16k|         ++n;
 3638|       |
 3639|    214|   *num_contours = n;
 3640|    214|   if (n == 0) return 0;
  ------------------
  |  Branch (3640:8): [True: 0, False: 214]
  ------------------
 3641|       |
 3642|    214|   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3643|       |
 3644|    214|   if (*contour_lengths == 0) {
  ------------------
  |  Branch (3644:8): [True: 0, False: 214]
  ------------------
 3645|      0|      *num_contours = 0;
 3646|      0|      return 0;
 3647|      0|   }
 3648|       |
 3649|       |   // make two passes through the points so we don't need to realloc
 3650|    642|   for (pass=0; pass < 2; ++pass) {
  ------------------
  |  Branch (3650:17): [True: 428, False: 214]
  ------------------
 3651|    428|      float x=0,y=0;
 3652|    428|      if (pass == 1) {
  ------------------
  |  Branch (3652:11): [True: 214, False: 214]
  ------------------
 3653|    214|         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3654|    214|         if (points == NULL) goto error;
  ------------------
  |  Branch (3654:14): [True: 0, False: 214]
  ------------------
 3655|    214|      }
 3656|    428|      num_points = 0;
 3657|    428|      n= -1;
 3658|  32.0k|      for (i=0; i < num_verts; ++i) {
  ------------------
  |  Branch (3658:17): [True: 31.6k, False: 428]
  ------------------
 3659|  31.6k|         switch (vertices[i].type) {
  ------------------
  |  Branch (3659:18): [True: 0, False: 31.6k]
  ------------------
 3660|  6.32k|            case STBTT_vmove:
  ------------------
  |  Branch (3660:13): [True: 6.32k, False: 25.2k]
  ------------------
 3661|       |               // start the next contour
 3662|  6.32k|               if (n >= 0)
  ------------------
  |  Branch (3662:20): [True: 5.89k, False: 428]
  ------------------
 3663|  5.89k|                  (*contour_lengths)[n] = num_points - start;
 3664|  6.32k|               ++n;
 3665|  6.32k|               start = num_points;
 3666|       |
 3667|  6.32k|               x = vertices[i].x, y = vertices[i].y;
 3668|  6.32k|               stbtt__add_point(points, num_points++, x,y);
 3669|  6.32k|               break;
 3670|  25.2k|            case STBTT_vline:
  ------------------
  |  Branch (3670:13): [True: 25.2k, False: 6.32k]
  ------------------
 3671|  25.2k|               x = vertices[i].x, y = vertices[i].y;
 3672|  25.2k|               stbtt__add_point(points, num_points++, x, y);
 3673|  25.2k|               break;
 3674|      0|            case STBTT_vcurve:
  ------------------
  |  Branch (3674:13): [True: 0, False: 31.6k]
  ------------------
 3675|      0|               stbtt__tesselate_curve(points, &num_points, x,y,
 3676|      0|                                        vertices[i].cx, vertices[i].cy,
 3677|      0|                                        vertices[i].x,  vertices[i].y,
 3678|      0|                                        objspace_flatness_squared, 0);
 3679|      0|               x = vertices[i].x, y = vertices[i].y;
 3680|      0|               break;
 3681|      0|            case STBTT_vcubic:
  ------------------
  |  Branch (3681:13): [True: 0, False: 31.6k]
  ------------------
 3682|      0|               stbtt__tesselate_cubic(points, &num_points, x,y,
 3683|      0|                                        vertices[i].cx, vertices[i].cy,
 3684|      0|                                        vertices[i].cx1, vertices[i].cy1,
 3685|      0|                                        vertices[i].x,  vertices[i].y,
 3686|      0|                                        objspace_flatness_squared, 0);
 3687|      0|               x = vertices[i].x, y = vertices[i].y;
 3688|      0|               break;
 3689|  31.6k|         }
 3690|  31.6k|      }
 3691|    428|      (*contour_lengths)[n] = num_points - start;
 3692|    428|   }
 3693|       |
 3694|    214|   return points;
 3695|      0|error:
 3696|      0|   STBTT_free(points, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3697|      0|   STBTT_free(*contour_lengths, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3698|      0|   *contour_lengths = 0;
 3699|      0|   *num_contours = 0;
 3700|      0|   return NULL;
 3701|    214|}
imgui_draw.cpp:_ZL16stbtt__add_pointP12stbtt__pointiff:
 3556|  31.6k|{
 3557|  31.6k|   if (!points) return; // during first pass, it's unallocated
  ------------------
  |  Branch (3557:8): [True: 15.8k, False: 15.8k]
  ------------------
 3558|  15.8k|   points[n].x = x;
 3559|  15.8k|   points[n].y = y;
 3560|  15.8k|}
imgui_draw.cpp:_ZL16stbtt__rasterizeP13stbtt__bitmapP12stbtt__pointPiiffffiiiPv:
 3499|    214|{
 3500|    214|   float y_scale_inv = invert ? -scale_y : scale_y;
  ------------------
  |  Branch (3500:24): [True: 214, False: 0]
  ------------------
 3501|    214|   stbtt__edge *e;
 3502|    214|   int n,i,j,k,m;
 3503|       |#if STBTT_RASTERIZER_VERSION == 1
 3504|       |   int vsubsample = result->h < 8 ? 15 : 5;
 3505|       |#elif STBTT_RASTERIZER_VERSION == 2
 3506|    214|   int vsubsample = 1;
 3507|       |#else
 3508|       |   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
 3509|       |#endif
 3510|       |   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
 3511|       |
 3512|       |   // now we have to blow out the windings into explicit edge lists
 3513|    214|   n = 0;
 3514|  3.37k|   for (i=0; i < windings; ++i)
  ------------------
  |  Branch (3514:14): [True: 3.16k, False: 214]
  ------------------
 3515|  3.16k|      n += wcount[i];
 3516|       |
 3517|    214|   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3518|    214|   if (e == 0) return;
  ------------------
  |  Branch (3518:8): [True: 0, False: 214]
  ------------------
 3519|    214|   n = 0;
 3520|       |
 3521|    214|   m=0;
 3522|  3.37k|   for (i=0; i < windings; ++i) {
  ------------------
  |  Branch (3522:14): [True: 3.16k, False: 214]
  ------------------
 3523|  3.16k|      stbtt__point *p = pts + m;
 3524|  3.16k|      m += wcount[i];
 3525|  3.16k|      j = wcount[i]-1;
 3526|  18.9k|      for (k=0; k < wcount[i]; j=k++) {
  ------------------
  |  Branch (3526:17): [True: 15.8k, False: 3.16k]
  ------------------
 3527|  15.8k|         int a=k,b=j;
 3528|       |         // skip the edge if horizontal
 3529|  15.8k|         if (p[j].y == p[k].y)
  ------------------
  |  Branch (3529:14): [True: 9.48k, False: 6.32k]
  ------------------
 3530|  9.48k|            continue;
 3531|       |         // add edge from j to k to the list
 3532|  6.32k|         e[n].invert = 0;
 3533|  6.32k|         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
  ------------------
  |  Branch (3533:14): [True: 6.32k, False: 0]
  |  Branch (3533:14): [True: 3.16k, False: 3.16k]
  ------------------
 3534|  3.16k|            e[n].invert = 1;
 3535|  3.16k|            a=j,b=k;
 3536|  3.16k|         }
 3537|  6.32k|         e[n].x0 = p[a].x * scale_x + shift_x;
 3538|  6.32k|         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
 3539|  6.32k|         e[n].x1 = p[b].x * scale_x + shift_x;
 3540|  6.32k|         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
 3541|  6.32k|         ++n;
 3542|  6.32k|      }
 3543|  3.16k|   }
 3544|       |
 3545|       |   // now sort the edges by their highest point (should snap to integer, and then by x)
 3546|       |   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
 3547|    214|   stbtt__sort_edges(e, n);
 3548|       |
 3549|       |   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
 3550|    214|   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);
 3551|       |
 3552|    214|   STBTT_free(e, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3553|    214|}
imgui_draw.cpp:_ZL17stbtt__sort_edgesP11stbtt__edgei:
 3488|    214|{
 3489|    214|   stbtt__sort_edges_quicksort(p, n);
 3490|    214|   stbtt__sort_edges_ins_sort(p, n);
 3491|    214|}
imgui_draw.cpp:_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei:
 3426|    862|{
 3427|       |   /* threshold for transitioning to insertion sort */
 3428|  1.51k|   while (n > 12) {
  ------------------
  |  Branch (3428:11): [True: 648, False: 862]
  ------------------
 3429|    648|      stbtt__edge t;
 3430|    648|      int c01,c12,c,m,i,j;
 3431|       |
 3432|       |      /* compute median of three */
 3433|    648|      m = n >> 1;
 3434|    648|      c01 = STBTT__COMPARE(&p[0],&p[m]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3435|    648|      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3436|       |      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
 3437|    648|      if (c01 != c12) {
  ------------------
  |  Branch (3437:11): [True: 249, False: 399]
  ------------------
 3438|       |         /* otherwise, we'll need to swap something else to middle */
 3439|    249|         int z;
 3440|    249|         c = STBTT__COMPARE(&p[0],&p[n-1]);
  ------------------
  |  | 3405|    249|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3441|       |         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
 3442|       |         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
 3443|    249|         z = (c == c12) ? 0 : n-1;
  ------------------
  |  Branch (3443:14): [True: 6, False: 243]
  ------------------
 3444|    249|         t = p[z];
 3445|    249|         p[z] = p[m];
 3446|    249|         p[m] = t;
 3447|    249|      }
 3448|       |      /* now p[m] is the median-of-three */
 3449|       |      /* swap it to the beginning so it won't move around */
 3450|    648|      t = p[0];
 3451|    648|      p[0] = p[m];
 3452|    648|      p[m] = t;
 3453|       |
 3454|       |      /* partition loop */
 3455|    648|      i=1;
 3456|    648|      j=n-1;
 3457|  1.98k|      for(;;) {
 3458|       |         /* handling of equality is crucial here */
 3459|       |         /* for sentinels & efficiency with duplicates */
 3460|  8.69k|         for (;;++i) {
 3461|  8.69k|            if (!STBTT__COMPARE(&p[i], &p[0])) break;
  ------------------
  |  | 3405|  8.69k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3461:17): [True: 1.98k, False: 6.71k]
  ------------------
 3462|  8.69k|         }
 3463|  5.67k|         for (;;--j) {
 3464|  5.67k|            if (!STBTT__COMPARE(&p[0], &p[j])) break;
  ------------------
  |  | 3405|  5.67k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3464:17): [True: 1.98k, False: 3.69k]
  ------------------
 3465|  5.67k|         }
 3466|       |         /* make sure we haven't crossed */
 3467|  1.98k|         if (i >= j) break;
  ------------------
  |  Branch (3467:14): [True: 648, False: 1.33k]
  ------------------
 3468|  1.33k|         t = p[i];
 3469|  1.33k|         p[i] = p[j];
 3470|  1.33k|         p[j] = t;
 3471|       |
 3472|  1.33k|         ++i;
 3473|  1.33k|         --j;
 3474|  1.33k|      }
 3475|       |      /* recurse on smaller side, iterate on larger */
 3476|    648|      if (j < (n-i)) {
  ------------------
  |  Branch (3476:11): [True: 199, False: 449]
  ------------------
 3477|    199|         stbtt__sort_edges_quicksort(p,j);
 3478|    199|         p = p+i;
 3479|    199|         n = n-i;
 3480|    449|      } else {
 3481|    449|         stbtt__sort_edges_quicksort(p+i, n-i);
 3482|    449|         n = j;
 3483|    449|      }
 3484|    648|   }
 3485|    862|}
imgui_draw.cpp:_ZL26stbtt__sort_edges_ins_sortP11stbtt__edgei:
 3408|    214|{
 3409|    214|   int i,j;
 3410|  6.32k|   for (i=1; i < n; ++i) {
  ------------------
  |  Branch (3410:14): [True: 6.10k, False: 214]
  ------------------
 3411|  6.10k|      stbtt__edge t = p[i], *a = &t;
 3412|  6.10k|      j = i;
 3413|  11.1k|      while (j > 0) {
  ------------------
  |  Branch (3413:14): [True: 10.9k, False: 177]
  ------------------
 3414|  10.9k|         stbtt__edge *b = &p[j-1];
 3415|  10.9k|         int c = STBTT__COMPARE(a,b);
  ------------------
  |  | 3405|  10.9k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3416|  10.9k|         if (!c) break;
  ------------------
  |  Branch (3416:14): [True: 5.93k, False: 5.04k]
  ------------------
 3417|  5.04k|         p[j] = p[j-1];
 3418|  5.04k|         --j;
 3419|  5.04k|      }
 3420|  6.10k|      if (i != j)
  ------------------
  |  Branch (3420:11): [True: 2.86k, False: 3.23k]
  ------------------
 3421|  2.86k|         p[j] = t;
 3422|  6.10k|   }
 3423|    214|}
imgui_draw.cpp:_ZL29stbtt__rasterize_sorted_edgesP13stbtt__bitmapP11stbtt__edgeiiiiPv:
 3306|    214|{
 3307|    214|   stbtt__hheap hh = { 0, 0, 0 };
 3308|    214|   stbtt__active_edge *active = NULL;
 3309|    214|   int y,j=0, i;
 3310|    214|   float scanline_data[129], *scanline, *scanline2;
 3311|       |
 3312|    214|   STBTT__NOTUSED(vsubsample);
  ------------------
  |  | 1130|    214|#define STBTT__NOTUSED(v)  (void)sizeof(v)
  ------------------
 3313|       |
 3314|    214|   if (result->w > 64)
  ------------------
  |  Branch (3314:8): [True: 0, False: 214]
  ------------------
 3315|      0|      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
  ------------------
  |  |  131|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3316|    214|   else
 3317|    214|      scanline = scanline_data;
 3318|       |
 3319|    214|   scanline2 = scanline + result->w;
 3320|       |
 3321|    214|   y = off_y;
 3322|    214|   e[n].y0 = (float) (off_y + result->h) + 1;
 3323|       |
 3324|  1.83k|   while (j < result->h) {
  ------------------
  |  Branch (3324:11): [True: 1.61k, False: 214]
  ------------------
 3325|       |      // find center of pixel for this scanline
 3326|  1.61k|      float scan_y_top    = y + 0.0f;
 3327|  1.61k|      float scan_y_bottom = y + 1.0f;
 3328|  1.61k|      stbtt__active_edge **step = &active;
 3329|       |
 3330|  1.61k|      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3331|  1.61k|      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3332|       |
 3333|       |      // update all active edges;
 3334|       |      // remove all active edges that terminate before the top of this scanline
 3335|  12.1k|      while (*step) {
  ------------------
  |  Branch (3335:14): [True: 10.5k, False: 1.61k]
  ------------------
 3336|  10.5k|         stbtt__active_edge * z = *step;
 3337|  10.5k|         if (z->ey <= scan_y_top) {
  ------------------
  |  Branch (3337:14): [True: 5.20k, False: 5.36k]
  ------------------
 3338|  5.20k|            *step = z->next; // delete from list
 3339|  5.20k|            STBTT_assert(z->direction);
  ------------------
  |  |  133|  5.20k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  5.20k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3340|  5.20k|            z->direction = 0;
 3341|  5.20k|            stbtt__hheap_free(&hh, z);
 3342|  5.36k|         } else {
 3343|  5.36k|            step = &((*step)->next); // advance through list
 3344|  5.36k|         }
 3345|  10.5k|      }
 3346|       |
 3347|       |      // insert all edges that start before the bottom of this scanline
 3348|  7.94k|      while (e->y0 <= scan_y_bottom) {
  ------------------
  |  Branch (3348:14): [True: 6.32k, False: 1.61k]
  ------------------
 3349|  6.32k|         if (e->y0 != e->y1) {
  ------------------
  |  Branch (3349:14): [True: 6.32k, False: 0]
  ------------------
 3350|  6.32k|            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
 3351|  6.32k|            if (z != NULL) {
  ------------------
  |  Branch (3351:17): [True: 6.32k, False: 0]
  ------------------
 3352|  6.32k|               if (j == 0 && off_y != 0) {
  ------------------
  |  Branch (3352:20): [True: 1.60k, False: 4.72k]
  |  Branch (3352:30): [True: 1.58k, False: 20]
  ------------------
 3353|  1.58k|                  if (z->ey < scan_y_top) {
  ------------------
  |  Branch (3353:23): [True: 0, False: 1.58k]
  ------------------
 3354|       |                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
 3355|      0|                     z->ey = scan_y_top;
 3356|      0|                  }
 3357|  1.58k|               }
 3358|  6.32k|               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
  ------------------
  |  |  133|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3359|       |               // insert at front
 3360|  6.32k|               z->next = active;
 3361|  6.32k|               active = z;
 3362|  6.32k|            }
 3363|  6.32k|         }
 3364|  6.32k|         ++e;
 3365|  6.32k|      }
 3366|       |
 3367|       |      // now process all active edges
 3368|  1.61k|      if (active)
  ------------------
  |  Branch (3368:11): [True: 1.61k, False: 5]
  ------------------
 3369|  1.61k|         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
 3370|       |
 3371|  1.61k|      {
 3372|  1.61k|         float sum = 0;
 3373|  9.77k|         for (i=0; i < result->w; ++i) {
  ------------------
  |  Branch (3373:20): [True: 8.15k, False: 1.61k]
  ------------------
 3374|  8.15k|            float k;
 3375|  8.15k|            int m;
 3376|  8.15k|            sum += scanline2[i];
 3377|  8.15k|            k = scanline[i] + sum;
 3378|  8.15k|            k = (float) STBTT_fabs(k)*255 + 0.5f;
  ------------------
  |  |  137|  8.15k|#define STBTT_fabs(x)       ImFabs(x)
  |  |  ------------------
  |  |  |  |  433|  8.15k|#define ImFabs(X)           fabsf(X)
  |  |  ------------------
  ------------------
 3379|  8.15k|            m = (int) k;
 3380|  8.15k|            if (m > 255) m = 255;
  ------------------
  |  Branch (3380:17): [True: 0, False: 8.15k]
  ------------------
 3381|  8.15k|            result->pixels[j*result->stride + i] = (unsigned char) m;
 3382|  8.15k|         }
 3383|  1.61k|      }
 3384|       |      // advance all the edges
 3385|  1.61k|      step = &active;
 3386|  13.3k|      while (*step) {
  ------------------
  |  Branch (3386:14): [True: 11.6k, False: 1.61k]
  ------------------
 3387|  11.6k|         stbtt__active_edge *z = *step;
 3388|  11.6k|         z->fx += z->fdx; // advance to position for current scanline
 3389|  11.6k|         step = &((*step)->next); // advance through list
 3390|  11.6k|      }
 3391|       |
 3392|  1.61k|      ++y;
 3393|  1.61k|      ++j;
 3394|  1.61k|   }
 3395|       |
 3396|    214|   stbtt__hheap_cleanup(&hh, userdata);
 3397|       |
 3398|    214|   if (scanline != scanline_data)
  ------------------
  |  Branch (3398:8): [True: 0, False: 214]
  ------------------
 3399|      0|      STBTT_free(scanline, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3400|    214|}
imgui_draw.cpp:_ZL17stbtt__hheap_freeP12stbtt__hheapPv:
 2797|  5.20k|{
 2798|  5.20k|   *(void **) p = hh->first_free;
 2799|  5.20k|   hh->first_free = p;
 2800|  5.20k|}
imgui_draw.cpp:_ZL17stbtt__new_activeP12stbtt__hheapP11stbtt__edgeifPv:
 2863|  6.32k|{
 2864|  6.32k|   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
 2865|  6.32k|   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
 2866|  6.32k|   STBTT_assert(z != NULL);
  ------------------
  |  |  133|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2867|       |   //STBTT_assert(e->y0 <= start_point);
 2868|  6.32k|   if (!z) return z;
  ------------------
  |  Branch (2868:8): [True: 0, False: 6.32k]
  ------------------
 2869|  6.32k|   z->fdx = dxdy;
 2870|  6.32k|   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
  ------------------
  |  Branch (2870:13): [True: 0, False: 6.32k]
  ------------------
 2871|  6.32k|   z->fx = e->x0 + dxdy * (start_point - e->y0);
 2872|  6.32k|   z->fx -= off_x;
 2873|  6.32k|   z->direction = e->invert ? 1.0f : -1.0f;
  ------------------
  |  Branch (2873:19): [True: 3.16k, False: 3.16k]
  ------------------
 2874|  6.32k|   z->sy = e->y0;
 2875|  6.32k|   z->ey = e->y1;
 2876|  6.32k|   z->next = 0;
 2877|  6.32k|   return z;
 2878|  6.32k|}
imgui_draw.cpp:_ZL18stbtt__hheap_allocP12stbtt__hheapmPv:
 2776|  6.32k|{
 2777|  6.32k|   if (hh->first_free) {
  ------------------
  |  Branch (2777:8): [True: 4.07k, False: 2.24k]
  ------------------
 2778|  4.07k|      void *p = hh->first_free;
 2779|  4.07k|      hh->first_free = * (void **) p;
 2780|  4.07k|      return p;
 2781|  4.07k|   } else {
 2782|  2.24k|      if (hh->num_remaining_in_head_chunk == 0) {
  ------------------
  |  Branch (2782:11): [True: 214, False: 2.03k]
  ------------------
 2783|    214|         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
  ------------------
  |  Branch (2783:23): [True: 0, False: 214]
  |  Branch (2783:42): [True: 214, False: 0]
  ------------------
 2784|    214|         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1860|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 2785|    214|         if (c == NULL)
  ------------------
  |  Branch (2785:14): [True: 0, False: 214]
  ------------------
 2786|      0|            return NULL;
 2787|    214|         c->next = hh->head;
 2788|    214|         hh->head = c;
 2789|    214|         hh->num_remaining_in_head_chunk = count;
 2790|    214|      }
 2791|  2.24k|      --hh->num_remaining_in_head_chunk;
 2792|  2.24k|      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
 2793|  2.24k|   }
 2794|  6.32k|}
imgui_draw.cpp:_ZL28stbtt__fill_active_edges_newPfS_iP18stbtt__active_edgef:
 3088|  1.61k|{
 3089|  1.61k|   float y_bottom = y_top+1;
 3090|       |
 3091|  13.2k|   while (e) {
  ------------------
  |  Branch (3091:11): [True: 11.6k, False: 1.61k]
  ------------------
 3092|       |      // brute force every pixel
 3093|       |
 3094|       |      // compute intersection points with top & bottom
 3095|  11.6k|      STBTT_assert(e->ey >= y_top);
  ------------------
  |  |  133|  11.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  11.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3096|       |
 3097|  11.6k|      if (e->fdx == 0) {
  ------------------
  |  Branch (3097:11): [True: 11.6k, False: 0]
  ------------------
 3098|  11.6k|         float x0 = e->fx;
 3099|  11.6k|         if (x0 < len) {
  ------------------
  |  Branch (3099:14): [True: 10.3k, False: 1.36k]
  ------------------
 3100|  10.3k|            if (x0 >= 0) {
  ------------------
  |  Branch (3100:17): [True: 10.3k, False: 0]
  ------------------
 3101|  10.3k|               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
 3102|  10.3k|               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
 3103|  10.3k|            } else {
 3104|      0|               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
 3105|      0|            }
 3106|  10.3k|         }
 3107|  11.6k|      } else {
 3108|      0|         float x0 = e->fx;
 3109|      0|         float dx = e->fdx;
 3110|      0|         float xb = x0 + dx;
 3111|      0|         float x_top, x_bottom;
 3112|      0|         float sy0,sy1;
 3113|      0|         float dy = e->fdy;
 3114|      0|         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3115|       |
 3116|       |         // compute endpoints of line segment clipped to this scanline (if the
 3117|       |         // line segment starts on this scanline. x0 is the intersection of the
 3118|       |         // line with y_top, but that may be off the line segment.
 3119|      0|         if (e->sy > y_top) {
  ------------------
  |  Branch (3119:14): [True: 0, False: 0]
  ------------------
 3120|      0|            x_top = x0 + dx * (e->sy - y_top);
 3121|      0|            sy0 = e->sy;
 3122|      0|         } else {
 3123|      0|            x_top = x0;
 3124|      0|            sy0 = y_top;
 3125|      0|         }
 3126|      0|         if (e->ey < y_bottom) {
  ------------------
  |  Branch (3126:14): [True: 0, False: 0]
  ------------------
 3127|      0|            x_bottom = x0 + dx * (e->ey - y_top);
 3128|      0|            sy1 = e->ey;
 3129|      0|         } else {
 3130|      0|            x_bottom = xb;
 3131|      0|            sy1 = y_bottom;
 3132|      0|         }
 3133|       |
 3134|      0|         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
  ------------------
  |  Branch (3134:14): [True: 0, False: 0]
  |  Branch (3134:28): [True: 0, False: 0]
  |  Branch (3134:45): [True: 0, False: 0]
  |  Branch (3134:60): [True: 0, False: 0]
  ------------------
 3135|       |            // from here on, we don't have to range check x values
 3136|       |
 3137|      0|            if ((int) x_top == (int) x_bottom) {
  ------------------
  |  Branch (3137:17): [True: 0, False: 0]
  ------------------
 3138|      0|               float height;
 3139|       |               // simple case, only spans one pixel
 3140|      0|               int x = (int) x_top;
 3141|      0|               height = (sy1 - sy0) * e->direction;
 3142|      0|               STBTT_assert(x >= 0 && x < len);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3143|      0|               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
 3144|      0|               scanline_fill[x] += height; // everything right of this pixel is filled
 3145|      0|            } else {
 3146|      0|               int x,x1,x2;
 3147|      0|               float y_crossing, y_final, step, sign, area;
 3148|       |               // covers 2+ pixels
 3149|      0|               if (x_top > x_bottom) {
  ------------------
  |  Branch (3149:20): [True: 0, False: 0]
  ------------------
 3150|       |                  // flip scanline vertically; signed area is the same
 3151|      0|                  float t;
 3152|      0|                  sy0 = y_bottom - (sy0 - y_top);
 3153|      0|                  sy1 = y_bottom - (sy1 - y_top);
 3154|      0|                  t = sy0, sy0 = sy1, sy1 = t;
 3155|      0|                  t = x_bottom, x_bottom = x_top, x_top = t;
 3156|      0|                  dx = -dx;
 3157|      0|                  dy = -dy;
 3158|      0|                  t = x0, x0 = xb, xb = t;
 3159|      0|               }
 3160|      0|               STBTT_assert(dy >= 0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3161|      0|               STBTT_assert(dx >= 0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3162|       |
 3163|      0|               x1 = (int) x_top;
 3164|      0|               x2 = (int) x_bottom;
 3165|       |               // compute intersection with y axis at x1+1
 3166|      0|               y_crossing = y_top + dy * (x1+1 - x0);
 3167|       |
 3168|       |               // compute intersection with y axis at x2
 3169|      0|               y_final = y_top + dy * (x2 - x0);
 3170|       |
 3171|       |               //           x1    x_top                            x2    x_bottom
 3172|       |               //     y_top  +------|-----+------------+------------+--------|---+------------+
 3173|       |               //            |            |            |            |            |            |
 3174|       |               //            |            |            |            |            |            |
 3175|       |               //       sy0  |      Txxxxx|............|............|............|............|
 3176|       |               // y_crossing |            *xxxxx.......|............|............|............|
 3177|       |               //            |            |     xxxxx..|............|............|............|
 3178|       |               //            |            |     /-   xx*xxxx........|............|............|
 3179|       |               //            |            | dy <       |    xxxxxx..|............|............|
 3180|       |               //   y_final  |            |     \-     |          xx*xxx.........|............|
 3181|       |               //       sy1  |            |            |            |   xxxxxB...|............|
 3182|       |               //            |            |            |            |            |            |
 3183|       |               //            |            |            |            |            |            |
 3184|       |               //  y_bottom  +------------+------------+------------+------------+------------+
 3185|       |               //
 3186|       |               // goal is to measure the area covered by '.' in each pixel
 3187|       |
 3188|       |               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
 3189|       |               // @TODO: maybe test against sy1 rather than y_bottom?
 3190|      0|               if (y_crossing > y_bottom)
  ------------------
  |  Branch (3190:20): [True: 0, False: 0]
  ------------------
 3191|      0|                  y_crossing = y_bottom;
 3192|       |
 3193|      0|               sign = e->direction;
 3194|       |
 3195|       |               // area of the rectangle covered from sy0..y_crossing
 3196|      0|               area = sign * (y_crossing-sy0);
 3197|       |
 3198|       |               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
 3199|      0|               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);
 3200|       |
 3201|       |               // check if final y_crossing is blown up; no test case for this
 3202|      0|               if (y_final > y_bottom) {
  ------------------
  |  Branch (3202:20): [True: 0, False: 0]
  ------------------
 3203|      0|                  int denom = (x2 - (x1+1));
 3204|      0|                  y_final = y_bottom;
 3205|      0|                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
  ------------------
  |  Branch (3205:23): [True: 0, False: 0]
  ------------------
 3206|      0|                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
 3207|      0|                  }
 3208|      0|               }
 3209|       |
 3210|       |               // in second pixel, area covered by line segment found in first pixel
 3211|       |               // is always a rectangle 1 wide * the height of that line segment; this
 3212|       |               // is exactly what the variable 'area' stores. it also gets a contribution
 3213|       |               // from the line segment within it. the THIRD pixel will get the first
 3214|       |               // pixel's rectangle contribution, the second pixel's rectangle contribution,
 3215|       |               // and its own contribution. the 'own contribution' is the same in every pixel except
 3216|       |               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
 3217|       |               // the second pixel's contribution to the third pixel will be the
 3218|       |               // rectangle 1 wide times the height change in the second pixel, which is dy.
 3219|       |
 3220|      0|               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
 3221|       |               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
 3222|       |               // so the area advances by 'step' every time
 3223|       |
 3224|      0|               for (x = x1+1; x < x2; ++x) {
  ------------------
  |  Branch (3224:31): [True: 0, False: 0]
  ------------------
 3225|      0|                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
 3226|      0|                  area += step;
 3227|      0|               }
 3228|      0|               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3229|      0|               STBTT_assert(sy1 > y_final-0.01f);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3230|       |
 3231|       |               // area covered in the last pixel is the rectangle from all the pixels to the left,
 3232|       |               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
 3233|      0|               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);
 3234|       |
 3235|       |               // the rest of the line is filled based on the total height of the line segment in this pixel
 3236|      0|               scanline_fill[x2] += sign * (sy1-sy0);
 3237|      0|            }
 3238|      0|         } else {
 3239|       |            // if edge goes outside of box we're drawing, we require
 3240|       |            // clipping logic. since this does not match the intended use
 3241|       |            // of this library, we use a different, very slow brute
 3242|       |            // force implementation
 3243|       |            // note though that this does happen some of the time because
 3244|       |            // x_top and x_bottom can be extrapolated at the top & bottom of
 3245|       |            // the shape and actually lie outside the bounding box
 3246|      0|            int x;
 3247|      0|            for (x=0; x < len; ++x) {
  ------------------
  |  Branch (3247:23): [True: 0, False: 0]
  ------------------
 3248|       |               // cases:
 3249|       |               //
 3250|       |               // there can be up to two intersections with the pixel. any intersection
 3251|       |               // with left or right edges can be handled by splitting into two (or three)
 3252|       |               // regions. intersections with top & bottom do not necessitate case-wise logic.
 3253|       |               //
 3254|       |               // the old way of doing this found the intersections with the left & right edges,
 3255|       |               // then used some simple logic to produce up to three segments in sorted order
 3256|       |               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
 3257|       |               // across the x border, then the corresponding y position might not be distinct
 3258|       |               // from the other y segment, and it might ignored as an empty segment. to avoid
 3259|       |               // that, we need to explicitly produce segments based on x positions.
 3260|       |
 3261|       |               // rename variables to clearly-defined pairs
 3262|      0|               float y0 = y_top;
 3263|      0|               float x1 = (float) (x);
 3264|      0|               float x2 = (float) (x+1);
 3265|      0|               float x3 = xb;
 3266|      0|               float y3 = y_bottom;
 3267|       |
 3268|       |               // x = e->x + e->dx * (y-y_top)
 3269|       |               // (y-y_top) = (x - e->x) / e->dx
 3270|       |               // y = (x - e->x) / e->dx + y_top
 3271|      0|               float y1 = (x - x0) / dx + y_top;
 3272|      0|               float y2 = (x+1 - x0) / dx + y_top;
 3273|       |
 3274|      0|               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
  ------------------
  |  Branch (3274:20): [True: 0, False: 0]
  |  Branch (3274:31): [True: 0, False: 0]
  ------------------
 3275|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3276|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
 3277|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3278|      0|               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
  ------------------
  |  Branch (3278:27): [True: 0, False: 0]
  |  Branch (3278:38): [True: 0, False: 0]
  ------------------
 3279|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3280|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
 3281|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3282|      0|               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
  ------------------
  |  Branch (3282:27): [True: 0, False: 0]
  |  Branch (3282:38): [True: 0, False: 0]
  ------------------
 3283|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3284|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3285|      0|               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
  ------------------
  |  Branch (3285:27): [True: 0, False: 0]
  |  Branch (3285:38): [True: 0, False: 0]
  ------------------
 3286|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3287|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3288|      0|               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
  ------------------
  |  Branch (3288:27): [True: 0, False: 0]
  |  Branch (3288:38): [True: 0, False: 0]
  ------------------
 3289|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3290|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3291|      0|               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
  ------------------
  |  Branch (3291:27): [True: 0, False: 0]
  |  Branch (3291:38): [True: 0, False: 0]
  ------------------
 3292|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3293|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3294|      0|               } else {  // one segment
 3295|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
 3296|      0|               }
 3297|      0|            }
 3298|      0|         }
 3299|      0|      }
 3300|  11.6k|      e = e->next;
 3301|  11.6k|   }
 3302|  1.61k|}
imgui_draw.cpp:_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff:
 3034|  20.6k|{
 3035|  20.6k|   if (y0 == y1) return;
  ------------------
  |  Branch (3035:8): [True: 0, False: 20.6k]
  ------------------
 3036|  20.6k|   STBTT_assert(y0 < y1);
  ------------------
  |  |  133|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3037|  20.6k|   STBTT_assert(e->sy <= e->ey);
  ------------------
  |  |  133|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3038|  20.6k|   if (y0 > e->ey) return;
  ------------------
  |  Branch (3038:8): [True: 0, False: 20.6k]
  ------------------
 3039|  20.6k|   if (y1 < e->sy) return;
  ------------------
  |  Branch (3039:8): [True: 0, False: 20.6k]
  ------------------
 3040|  20.6k|   if (y0 < e->sy) {
  ------------------
  |  Branch (3040:8): [True: 9.44k, False: 11.1k]
  ------------------
 3041|  9.44k|      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
 3042|  9.44k|      y0 = e->sy;
 3043|  9.44k|   }
 3044|  20.6k|   if (y1 > e->ey) {
  ------------------
  |  Branch (3044:8): [True: 0, False: 20.6k]
  ------------------
 3045|      0|      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
 3046|      0|      y1 = e->ey;
 3047|      0|   }
 3048|       |
 3049|  20.6k|   if (x0 == x)
  ------------------
  |  Branch (3049:8): [True: 10.3k, False: 10.3k]
  ------------------
 3050|  10.3k|      STBTT_assert(x1 <= x+1);
  ------------------
  |  |  133|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3051|  10.3k|   else if (x0 == x+1)
  ------------------
  |  Branch (3051:13): [True: 0, False: 10.3k]
  ------------------
 3052|      0|      STBTT_assert(x1 >= x);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3053|  10.3k|   else if (x0 <= x)
  ------------------
  |  Branch (3053:13): [True: 10.3k, False: 0]
  ------------------
 3054|  10.3k|      STBTT_assert(x1 <= x);
  ------------------
  |  |  133|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3055|      0|   else if (x0 >= x+1)
  ------------------
  |  Branch (3055:13): [True: 0, False: 0]
  ------------------
 3056|      0|      STBTT_assert(x1 >= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3057|      0|   else
 3058|      0|      STBTT_assert(x1 >= x && x1 <= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3059|       |
 3060|  20.6k|   if (x0 <= x && x1 <= x)
  ------------------
  |  Branch (3060:8): [True: 20.6k, False: 0]
  |  Branch (3060:19): [True: 20.6k, False: 0]
  ------------------
 3061|  20.6k|      scanline[x] += e->direction * (y1-y0);
 3062|      0|   else if (x0 >= x+1 && x1 >= x+1)
  ------------------
  |  Branch (3062:13): [True: 0, False: 0]
  |  Branch (3062:26): [True: 0, False: 0]
  ------------------
 3063|      0|      ;
 3064|      0|   else {
 3065|      0|      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3066|      0|      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
 3067|      0|   }
 3068|  20.6k|}
imgui_draw.cpp:_ZL20stbtt__hheap_cleanupP12stbtt__hheapPv:
 2803|    214|{
 2804|    214|   stbtt__hheap_chunk *c = hh->head;
 2805|    428|   while (c) {
  ------------------
  |  Branch (2805:11): [True: 214, False: 214]
  ------------------
 2806|    214|      stbtt__hheap_chunk *n = c->next;
 2807|    214|      STBTT_free(c, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 2808|    214|      c = n;
 2809|    214|   }
 2810|    214|}
imgui_draw.cpp:_ZL13stbtt_PackEndP18stbtt_pack_context:
 3998|      1|{
 3999|      1|   STBTT_free(spc->nodes    , spc->user_allocator_context);
  ------------------
  |  |  132|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4000|      1|   STBTT_free(spc->pack_info, spc->user_allocator_context);
  ------------------
  |  |  132|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1861|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4001|      1|}
imgui_draw.cpp:_ZL21stbtt_GetFontVMetricsPK14stbtt_fontinfoPiS2_S2_:
 2640|      1|{
 2641|      1|   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
  ------------------
  |  Branch (2641:8): [True: 1, False: 0]
  ------------------
 2642|      1|   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
  ------------------
  |  Branch (2642:8): [True: 1, False: 0]
  ------------------
 2643|      1|   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
  ------------------
  |  Branch (2643:8): [True: 1, False: 0]
  ------------------
 2644|      1|}
imgui_draw.cpp:_ZL19stbtt_GetPackedQuadPK16stbtt_packedchariiiPfS2_P18stbtt_aligned_quadi:
 4372|    223|{
 4373|    223|   float ipw = 1.0f / pw, iph = 1.0f / ph;
 4374|    223|   const stbtt_packedchar *b = chardata + char_index;
 4375|       |
 4376|    223|   if (align_to_integer) {
  ------------------
  |  Branch (4376:8): [True: 0, False: 223]
  ------------------
 4377|      0|      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
  ------------------
  |  |  138|      0|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
 4378|      0|      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
  ------------------
  |  |  138|      0|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
 4379|      0|      q->x0 = x;
 4380|      0|      q->y0 = y;
 4381|      0|      q->x1 = x + b->xoff2 - b->xoff;
 4382|      0|      q->y1 = y + b->yoff2 - b->yoff;
 4383|    223|   } else {
 4384|    223|      q->x0 = *xpos + b->xoff;
 4385|    223|      q->y0 = *ypos + b->yoff;
 4386|    223|      q->x1 = *xpos + b->xoff2;
 4387|    223|      q->y1 = *ypos + b->yoff2;
 4388|    223|   }
 4389|       |
 4390|    223|   q->s0 = b->x0 * ipw;
 4391|    223|   q->t0 = b->y0 * iph;
 4392|    223|   q->s1 = b->x1 * ipw;
 4393|    223|   q->t1 = b->y1 * iph;
 4394|       |
 4395|    223|   *xpos += b->xadvance;
 4396|    223|}

_Z12consume_boolPKhmRm:
  104|   118k|{
  105|   118k|    if (!has_x_more(index, sizeof(bool), size))
  ------------------
  |  Branch (105:9): [True: 76, False: 118k]
  ------------------
  106|     76|    {
  107|     76|        return {};
  108|     76|    }
  109|       |
  110|   118k|    PHI_ASSUME(index % sizeof(void*) == 0);
  111|       |
  112|   118k|    bool value = static_cast<bool>((data + index));
  113|   118k|    index += aligned_size<bool>();
  114|       |
  115|   118k|    return value;
  116|   118k|}
_Z14consume_uint32PKhmRm:
  121|    549|{
  122|    549|    return consume_t<std::uint32_t>(data, size, index);
  123|    549|}
_Z14consume_size_tPKhmRm:
  128|    148|{
  129|    148|    return consume_t<std::size_t>(data, size, index);
  130|    148|}
_Z14consume_stringPKhmRm:
  134|    545|{
  135|    545|    const char* str_begin = reinterpret_cast<const char*>(data);
  136|    545|    phi::size_t str_len   = 0u;
  137|       |
  138|  2.78k|    while (index < size && data[index] != '\0')
  ------------------
  |  Branch (138:12): [True: 2.69k, False: 83]
  |  Branch (138:28): [True: 2.23k, False: 462]
  ------------------
  139|  2.23k|    {
  140|  2.23k|        ++index;
  141|  2.23k|        ++str_len;
  142|  2.23k|    }
  143|       |
  144|       |    // Reject too long strings
  145|    545|    if (str_len - 1u > MaxStringLength)
  ------------------
  |  Branch (145:9): [True: 323, False: 222]
  ------------------
  146|    323|    {
  147|    323|        return false;
  148|    323|    }
  149|       |
  150|       |    // Reject strings that are not null terminated
  151|    222|    if (data[index - 1u] != '\0')
  ------------------
  |  Branch (151:9): [True: 222, False: 0]
  ------------------
  152|    222|    {
  153|    222|        return false;
  154|    222|    }
  155|       |
  156|       |    // Move back to proper alignment
  157|      0|    index += (sizeof(void*) - (index % sizeof(void*)));
  158|       |
  159|       |    // Assign string value to cache
  160|      0|    cache.string = str_begin;
  161|       |
  162|      0|    return true;
  163|    222|}
_Z21consume_vector_stringPKhmRm:
  169|    148|{
  170|    148|    auto number_of_lines_opt = consume_size_t(data, size, index);
  171|    148|    if (!number_of_lines_opt)
  ------------------
  |  Branch (171:9): [True: 2, False: 146]
  ------------------
  172|      2|    {
  173|      2|        return {};
  174|      2|    }
  175|       |
  176|    146|    const std::size_t number_of_lines = number_of_lines_opt.value();
  177|    146|    if (number_of_lines >= MaxVectorSize)
  ------------------
  |  Branch (177:9): [True: 3, False: 143]
  ------------------
  178|      3|    {
  179|      3|        return {};
  180|      3|    }
  181|       |
  182|    143|    std::vector<std::string>& res = cache.vector_string[number_of_lines];
  183|    143|    for (std::size_t i{0u}; i < number_of_lines; ++i)
  ------------------
  |  Branch (183:29): [True: 15, False: 128]
  ------------------
  184|     15|    {
  185|     15|        if (!consume_string(data, size, index))
  ------------------
  |  Branch (185:13): [True: 15, False: 0]
  ------------------
  186|     15|        {
  187|     15|            return {};
  188|     15|        }
  189|       |
  190|      0|        res[i] = cache.string;
  191|      0|    }
  192|       |
  193|    128|    return number_of_lines;
  194|    143|}
_Z19consume_coordinatesPKhmRm:
  198|    850|{
  199|    850|    auto column_opt = consume_t<std::uint32_t>(data, size, index);
  200|    850|    if (!column_opt)
  ------------------
  |  Branch (200:9): [True: 2, False: 848]
  ------------------
  201|      2|    {
  202|      2|        return {};
  203|      2|    }
  204|    848|    std::uint32_t column = column_opt.value();
  205|       |
  206|    848|    auto line_opt = consume_t<std::uint32_t>(data, size, index);
  207|    848|    if (!line_opt)
  ------------------
  |  Branch (207:9): [True: 2, False: 846]
  ------------------
  208|      2|    {
  209|      2|        return {};
  210|      2|    }
  211|    846|    std::uint32_t line = line_opt.value();
  212|       |
  213|    846|    return dlxemu::CodeEditor::Coordinates{column, line};
  214|    848|}
_Z10print_chart:
  265|  44.0k|{
  266|  44.0k|    return fmt::format(R"(ImWchar("{:s}" (\0x{:02X})))", pretty_char(character),
  267|  44.0k|                       static_cast<std::uint32_t>(character));
  268|  44.0k|}
_Z19print_vector_stringRKNSt3__16vectorINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS4_IS6_EEEE:
  271|    128|{
  272|    128|    std::string ret;
  273|       |
  274|    128|    ret += fmt::format("Vector(size: {:d}):\n", vec.size());
  275|       |
  276|    128|    for (const std::string& str : vec)
  ------------------
  |  Branch (276:33): [True: 0, False: 128]
  ------------------
  277|      0|    {
  278|      0|        ret += print_string(str) + '\n';
  279|      0|    }
  280|       |
  281|    128|    return ret;
  282|    128|}
_Z19print_error_markersRKNSt3__13mapIjNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_4lessIjEENS4_INS_4pairIKjS6_EEEEEE:
  286|     13|{
  287|     13|    std::string ret;
  288|       |
  289|     13|    ret += fmt::format("ErrorMarkers(size: {:d}):\n", markers.size());
  290|       |
  291|     13|    for (const auto& val : markers)
  ------------------
  |  Branch (291:26): [True: 0, False: 13]
  ------------------
  292|      0|    {
  293|      0|        ret += fmt::format("{:s}: {:s}\n", print_int(val.first), print_string(val.second));
  294|      0|    }
  295|       |
  296|     13|    return ret;
  297|     13|}
_Z17print_breakpointsRKNSt3__113unordered_setIjNS_4hashIjEENS_8equal_toIjEENS_9allocatorIjEEEE:
  301|  1.43k|{
  302|  1.43k|    std::string lines;
  303|       |
  304|  1.43k|    for (const phi::u32 line_number : breakpoints)
  ------------------
  |  Branch (304:37): [True: 9.30k, False: 1.43k]
  ------------------
  305|  9.30k|    {
  306|  9.30k|        lines += fmt::format("{:s}, ", print_int(line_number.unsafe()));
  307|  9.30k|    }
  308|       |
  309|  1.43k|    std::string ret = fmt::format("Breakpoints(size: {:d}: {:s})", breakpoints.size(),
  310|  1.43k|                                  lines.substr(0, lines.size() - 2));
  311|       |
  312|  1.43k|    return ret.substr(0, ret.size());
  313|  1.43k|}
_Z10print_boolb:
  316|  62.6k|{
  317|  62.6k|    return b ? "true" : "false";
  ------------------
  |  Branch (317:12): [True: 62.6k, False: 0]
  ------------------
  318|  62.6k|}
_Z10SetupImGuiv:
  321|      1|{
  322|      1|    IMGUI_CHECKVERSION();
  323|      1|    if (GImGui != nullptr)
  ------------------
  |  Branch (323:9): [True: 0, False: 1]
  ------------------
  324|      0|    {
  325|      0|        return true;
  326|      0|    }
  327|       |
  328|      1|    if (ImGui::CreateContext() == nullptr)
  ------------------
  |  Branch (328:9): [True: 0, False: 1]
  ------------------
  329|      0|    {
  330|      0|        FUZZ_LOG("Failed to create ImGuiContext");
  ------------------
  |  |   24|      0|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|      0|        std::putc('\n', stderr);                                                                   \
  |  |   26|      0|        std::fflush(stderr)
  ------------------
  331|      0|        return false;
  332|      0|    }
  333|       |
  334|       |    // Set config
  335|      1|    ImGuiIO& io = ImGui::GetIO();
  336|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
  337|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;  // Enable Gamepad Controls
  338|      1|    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;     // Enable Docking
  339|      1|    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; // Enable Multi-Viewport / Platform Windows
  340|       |
  341|       |    // Enforce valid display size
  342|      1|    io.DisplaySize.x = 1024.0f;
  343|      1|    io.DisplaySize.y = 768.0f;
  344|       |
  345|       |    // Enfore valid DeltaTime
  346|      1|    io.DeltaTime = 1.0f / 60.0f;
  347|       |
  348|       |    // Don't save any config
  349|      1|    io.IniFilename = nullptr;
  350|       |
  351|       |    // SetStyle
  352|      1|    ImGuiStyle& style = ImGui::GetStyle();
  353|      1|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (353:9): [True: 1, False: 0]
  ------------------
  354|      1|    {
  355|      1|        style.WindowRounding              = 0.0f;
  356|      1|        style.Colors[ImGuiCol_WindowBg].w = 1.0f;
  357|      1|    }
  358|       |
  359|       |    // Build atlas
  360|      1|    unsigned char* tex_pixels{nullptr};
  361|      1|    int            tex_w;
  362|      1|    int            tex_h;
  363|      1|    io.Fonts->GetTexDataAsRGBA32(&tex_pixels, &tex_w, &tex_h);
  364|       |
  365|      1|    return true;
  366|      1|}
_Z8EndImGuiv:
  369|  55.4k|{
  370|  55.4k|    ImGui::Render();
  371|       |
  372|  55.4k|    volatile ImDrawData* draw_data = ImGui::GetDrawData();
  373|  55.4k|    PHI_UNUSED_VARIABLE(draw_data);
  374|       |
  375|  55.4k|    ImGuiIO& io = ImGui::GetIO();
  376|       |    // Update and Render additional Platform Windows
  377|       |    // (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.
  378|  55.4k|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (378:9): [True: 0, False: 55.4k]
  ------------------
  379|      0|    {
  380|      0|        ImGui::UpdatePlatformWindows();
  381|      0|        ImGui::RenderPlatformWindowsDefault();
  382|      0|    }
  383|       |
  384|  55.4k|    ImGui::EndFrame();
  385|       |
  386|       |    // Ensure frame count doesn't overflow
  387|  55.4k|    GImGui->FrameCount %= 16384;
  388|  55.4k|}
LLVMFuzzerTestOneInput:
  392|  7.25k|{
  393|  7.25k|    static bool imgui_init = SetupImGui();
  394|  7.25k|    (void)imgui_init;
  395|       |
  396|       |    // Reset some ImGui states
  397|  7.25k|    ImGui::GetIO().ClearInputCharacters();
  398|  7.25k|    ImGui::GetIO().ClearInputKeys();
  399|  7.25k|    ImGui::GetIO().InputQueueSurrogate = 0;
  400|  7.25k|    GImGui->InputEventsQueue.resize(0u);
  401|  7.25k|    ImGui::FocusWindow(nullptr);
  402|       |
  403|  7.25k|    dlxemu::Emulator   emulator;
  404|  7.25k|    dlxemu::CodeEditor editor{&emulator};
  405|       |
  406|  7.25k|    editor.UpdatePalette();
  407|       |
  408|  7.25k|    FUZZ_LOG("Beginning execution");
  ------------------
  |  |   24|  7.25k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  7.25k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  7.25k|        std::fflush(stderr)
  ------------------
  409|       |
  410|   155k|    for (std::size_t index{0u}; index < size;)
  ------------------
  |  Branch (410:33): [True: 152k, False: 2.33k]
  ------------------
  411|   152k|    {
  412|   152k|        auto function_index_opt = consume_t<std::uint32_t>(data, size, index);
  413|   152k|        if (!function_index_opt)
  ------------------
  |  Branch (413:13): [True: 556, False: 152k]
  ------------------
  414|    556|        {
  415|    556|            return 0;
  416|    556|        }
  417|       |
  418|   152k|        const std::uint32_t function_index = function_index_opt.value();
  419|       |
  420|   152k|        switch (function_index)
  421|   152k|        {
  422|       |            // AddErrorMarker
  423|    549|            case 0: {
  ------------------
  |  Branch (423:13): [True: 549, False: 151k]
  ------------------
  424|    549|                auto line_number_opt = consume_uint32(data, size, index);
  425|    549|                if (!line_number_opt)
  ------------------
  |  Branch (425:21): [True: 71, False: 478]
  ------------------
  426|     71|                {
  427|     71|                    return 0;
  428|     71|                }
  429|    478|                std::uint32_t line_number = line_number_opt.value();
  430|       |
  431|    478|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (431:21): [True: 478, False: 0]
  ------------------
  432|    478|                {
  433|    478|                    return 0;
  434|    478|                }
  435|      0|                std::string& message = cache.string;
  436|       |
  437|      0|                FUZZ_LOG("AddErrorMarker({:s}, {:s})", print_int(line_number),
  ------------------
  |  |   24|      0|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|      0|        std::putc('\n', stderr);                                                                   \
  |  |   26|      0|        std::fflush(stderr)
  ------------------
  438|      0|                         print_string(message));
  439|       |
  440|      0|                editor.AddErrorMarker(line_number, message);
  441|      0|                break;
  442|    478|            }
  443|       |
  444|       |            // ClearErrorMarkers
  445|  6.04k|            case 1: {
  ------------------
  |  Branch (445:13): [True: 6.04k, False: 146k]
  ------------------
  446|  6.04k|                FUZZ_LOG("ClearErrorMarkers");
  ------------------
  |  |   24|  6.04k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  6.04k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  6.04k|        std::fflush(stderr)
  ------------------
  447|       |
  448|  6.04k|                editor.ClearErrorMarkers();
  449|  6.04k|                break;
  450|    478|            }
  451|       |
  452|       |            // SetText
  453|     15|            case 2: {
  ------------------
  |  Branch (453:13): [True: 15, False: 152k]
  ------------------
  454|     15|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (454:21): [True: 15, False: 0]
  ------------------
  455|     15|                {
  456|     15|                    return 0;
  457|     15|                }
  458|      0|                std::string& text = cache.string;
  459|       |
  460|      0|                FUZZ_LOG("SetText({:s})", print_string(text));
  ------------------
  |  |   24|      0|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|      0|        std::putc('\n', stderr);                                                                   \
  |  |   26|      0|        std::fflush(stderr)
  ------------------
  461|       |
  462|      0|                editor.SetText(text);
  463|      0|                break;
  464|     15|            }
  465|       |
  466|       |            // GetText
  467|     60|            case 3: {
  ------------------
  |  Branch (467:13): [True: 60, False: 152k]
  ------------------
  468|     60|                FUZZ_LOG("GetText()");
  ------------------
  |  |   24|     60|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     60|        std::putc('\n', stderr);                                                                   \
  |  |   26|     60|        std::fflush(stderr)
  ------------------
  469|       |
  470|     60|                volatile std::string str = editor.GetText();
  471|     60|                PHI_UNUSED_VARIABLE(str);
  472|     60|                break;
  473|     15|            }
  474|       |
  475|       |            // SetTextLines
  476|    148|            case 4: {
  ------------------
  |  Branch (476:13): [True: 148, False: 152k]
  ------------------
  477|    148|                auto lines_opt = consume_vector_string(data, size, index);
  478|    148|                if (!lines_opt)
  ------------------
  |  Branch (478:21): [True: 20, False: 128]
  ------------------
  479|     20|                {
  480|     20|                    return 0;
  481|     20|                }
  482|       |
  483|    128|                const std::vector<std::string>& lines = cache.vector_string[lines_opt.value()];
  484|       |
  485|    128|                FUZZ_LOG("SetTextLines({:s})", print_vector_string(lines));
  ------------------
  |  |   24|    128|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    128|        std::putc('\n', stderr);                                                                   \
  |  |   26|    128|        std::fflush(stderr)
  ------------------
  486|       |
  487|    128|                editor.SetTextLines(lines);
  488|    128|                break;
  489|    148|            }
  490|       |
  491|       |            // GetTextLines
  492|    129|            case 5: {
  ------------------
  |  Branch (492:13): [True: 129, False: 152k]
  ------------------
  493|    129|                FUZZ_LOG("GetTextLines()");
  ------------------
  |  |   24|    129|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    129|        std::putc('\n', stderr);                                                                   \
  |  |   26|    129|        std::fflush(stderr)
  ------------------
  494|       |
  495|    129|                volatile std::vector<std::string> lines = editor.GetTextLines();
  496|    129|                PHI_UNUSED_VARIABLE(lines);
  497|    129|                break;
  498|    148|            }
  499|       |
  500|       |            // GetSelectedText
  501|    184|            case 6: {
  ------------------
  |  Branch (501:13): [True: 184, False: 152k]
  ------------------
  502|    184|                FUZZ_LOG("GetSelectedText()");
  ------------------
  |  |   24|    184|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    184|        std::putc('\n', stderr);                                                                   \
  |  |   26|    184|        std::fflush(stderr)
  ------------------
  503|       |
  504|    184|                volatile std::string line = editor.GetSelectedText();
  505|    184|                PHI_UNUSED_VARIABLE(line);
  506|    184|                break;
  507|    148|            }
  508|       |
  509|       |            // GetCurrentLineText
  510|     35|            case 7: {
  ------------------
  |  Branch (510:13): [True: 35, False: 152k]
  ------------------
  511|     35|                FUZZ_LOG("GetCurrentLineText()");
  ------------------
  |  |   24|     35|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     35|        std::putc('\n', stderr);                                                                   \
  |  |   26|     35|        std::fflush(stderr)
  ------------------
  512|       |
  513|     35|                volatile std::string line = editor.GetCurrentLineText();
  514|     35|                PHI_UNUSED_VARIABLE(line);
  515|     35|                break;
  516|    148|            }
  517|       |
  518|       |            // SetReadOnly
  519|  1.28k|            case 8: {
  ------------------
  |  Branch (519:13): [True: 1.28k, False: 151k]
  ------------------
  520|  1.28k|                auto read_only_opt = consume_bool(data, size, index);
  521|  1.28k|                if (!read_only_opt)
  ------------------
  |  Branch (521:21): [True: 3, False: 1.28k]
  ------------------
  522|      3|                {
  523|      3|                    return 0;
  524|      3|                }
  525|  1.28k|                bool read_only = read_only_opt.value();
  526|       |
  527|  1.28k|                FUZZ_LOG("SetReadOnly({:s})", print_bool(read_only));
  ------------------
  |  |   24|  1.28k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.28k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.28k|        std::fflush(stderr)
  ------------------
  528|       |
  529|  1.28k|                editor.SetReadOnly(read_only);
  530|  1.28k|                break;
  531|  1.28k|            }
  532|       |
  533|       |            // GetCursorPosition
  534|  5.08k|            case 9: {
  ------------------
  |  Branch (534:13): [True: 5.08k, False: 147k]
  ------------------
  535|  5.08k|                FUZZ_LOG("GetCursorPosition()");
  ------------------
  |  |   24|  5.08k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  5.08k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  5.08k|        std::fflush(stderr)
  ------------------
  536|       |
  537|  5.08k|                volatile dlxemu::CodeEditor::Coordinates coords = editor.GetCursorPosition();
  538|  5.08k|                PHI_UNUSED_VARIABLE(coords);
  539|  5.08k|                break;
  540|  1.28k|            }
  541|       |
  542|       |            // SetCursorPosition
  543|    850|            case 10: {
  ------------------
  |  Branch (543:13): [True: 850, False: 151k]
  ------------------
  544|    850|                auto coords_opt = consume_coordinates(data, size, index);
  545|    850|                if (!coords_opt)
  ------------------
  |  Branch (545:21): [True: 4, False: 846]
  ------------------
  546|      4|                {
  547|      4|                    return 0;
  548|      4|                }
  549|       |
  550|    846|                auto coords = coords_opt.value();
  551|       |
  552|    846|                FUZZ_LOG("SetCursorPosition(Coordinates({:s}, {:s}))",
  ------------------
  |  |   24|    846|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    846|        std::putc('\n', stderr);                                                                   \
  |  |   26|    846|        std::fflush(stderr)
  ------------------
  553|    846|                         print_int(coords.m_Line.unsafe()), print_int(coords.m_Column.unsafe()));
  554|       |
  555|    846|                editor.SetCursorPosition(coords);
  556|    846|                break;
  557|    850|            }
  558|       |
  559|       |            // SetShowWhitespaces
  560|    671|            case 11: {
  ------------------
  |  Branch (560:13): [True: 671, False: 151k]
  ------------------
  561|    671|                auto show_whitespace_opt = consume_bool(data, size, index);
  562|    671|                if (!show_whitespace_opt)
  ------------------
  |  Branch (562:21): [True: 1, False: 670]
  ------------------
  563|      1|                {
  564|      1|                    return 0;
  565|      1|                }
  566|    670|                bool show_whitespaces = show_whitespace_opt.value();
  567|       |
  568|    670|                FUZZ_LOG("SetShowShitespaces({:s})", print_bool(show_whitespaces));
  ------------------
  |  |   24|    670|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    670|        std::putc('\n', stderr);                                                                   \
  |  |   26|    670|        std::fflush(stderr)
  ------------------
  569|       |
  570|    670|                editor.SetShowWhitespaces(show_whitespaces);
  571|    670|                break;
  572|    671|            }
  573|       |
  574|       |            // SetTabSize
  575|  1.13k|            case 12: {
  ------------------
  |  Branch (575:13): [True: 1.13k, False: 151k]
  ------------------
  576|  1.13k|                auto tab_size_opt = consume_t<std::uint_fast8_t>(data, size, index);
  577|  1.13k|                if (!tab_size_opt)
  ------------------
  |  Branch (577:21): [True: 1, False: 1.13k]
  ------------------
  578|      1|                {
  579|      1|                    return 0;
  580|      1|                }
  581|  1.13k|                std::uint_fast8_t tab_size = tab_size_opt.value();
  582|       |
  583|  1.13k|                FUZZ_LOG("SetTabSize({:s})", print_int(tab_size));
  ------------------
  |  |   24|  1.13k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.13k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.13k|        std::fflush(stderr)
  ------------------
  584|       |
  585|  1.13k|                editor.SetTabSize(tab_size);
  586|  1.13k|                break;
  587|  1.13k|            }
  588|       |
  589|       |            // InsertText
  590|     15|            case 13: {
  ------------------
  |  Branch (590:13): [True: 15, False: 152k]
  ------------------
  591|     15|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (591:21): [True: 15, False: 0]
  ------------------
  592|     15|                {
  593|     15|                    return 0;
  594|     15|                }
  595|       |
  596|      0|                std::string& message = cache.string;
  597|       |
  598|      0|                FUZZ_LOG("InsertText({:s})", print_string(message));
  ------------------
  |  |   24|      0|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|      0|        std::putc('\n', stderr);                                                                   \
  |  |   26|      0|        std::fflush(stderr)
  ------------------
  599|       |
  600|      0|                editor.InsertText(message);
  601|      0|                break;
  602|     15|            }
  603|       |
  604|       |            // MoveUp
  605|  1.74k|            case 14: {
  ------------------
  |  Branch (605:13): [True: 1.74k, False: 150k]
  ------------------
  606|  1.74k|                auto amount_opt = consume_t<std::uint32_t>(data, size, index);
  607|  1.74k|                if (!amount_opt)
  ------------------
  |  Branch (607:21): [True: 1, False: 1.74k]
  ------------------
  608|      1|                {
  609|      1|                    return 0;
  610|      1|                }
  611|  1.74k|                std::uint32_t amount = amount_opt.value();
  612|       |
  613|  1.74k|                auto select_opt = consume_bool(data, size, index);
  614|  1.74k|                if (!select_opt)
  ------------------
  |  Branch (614:21): [True: 1, False: 1.74k]
  ------------------
  615|      1|                {
  616|      1|                    return 0;
  617|      1|                }
  618|  1.74k|                bool select = select_opt.value();
  619|       |
  620|  1.74k|                FUZZ_LOG("MoveUp({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   24|  1.74k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.74k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.74k|        std::fflush(stderr)
  ------------------
  621|       |
  622|  1.74k|                editor.MoveUp(amount, select);
  623|  1.74k|                break;
  624|  1.74k|            }
  625|       |
  626|       |            // MoveDown
  627|  1.32k|            case 15: {
  ------------------
  |  Branch (627:13): [True: 1.32k, False: 150k]
  ------------------
  628|  1.32k|                auto amount_opt = consume_t<std::uint32_t>(data, size, index);
  629|  1.32k|                if (!amount_opt)
  ------------------
  |  Branch (629:21): [True: 1, False: 1.32k]
  ------------------
  630|      1|                {
  631|      1|                    return 0;
  632|      1|                }
  633|  1.32k|                std::uint32_t amount = amount_opt.value();
  634|       |
  635|  1.32k|                auto select_opt = consume_bool(data, size, index);
  636|  1.32k|                if (!select_opt)
  ------------------
  |  Branch (636:21): [True: 4, False: 1.32k]
  ------------------
  637|      4|                {
  638|      4|                    return 0;
  639|      4|                }
  640|  1.32k|                bool select = select_opt.value();
  641|       |
  642|  1.32k|                FUZZ_LOG("MoveDown({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   24|  1.32k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.32k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.32k|        std::fflush(stderr)
  ------------------
  643|       |
  644|  1.32k|                editor.MoveDown(amount, select);
  645|  1.32k|                break;
  646|  1.32k|            }
  647|       |
  648|       |            // MoveLeft
  649|  1.92k|            case 16: {
  ------------------
  |  Branch (649:13): [True: 1.92k, False: 150k]
  ------------------
  650|  1.92k|                auto amount_opt = consume_t<std::uint32_t>(data, size, index);
  651|  1.92k|                if (!amount_opt)
  ------------------
  |  Branch (651:21): [True: 2, False: 1.91k]
  ------------------
  652|      2|                {
  653|      2|                    return 0;
  654|      2|                }
  655|  1.91k|                std::uint32_t amount = amount_opt.value();
  656|       |
  657|  1.91k|                auto select_opt = consume_bool(data, size, index);
  658|  1.91k|                if (!select_opt)
  ------------------
  |  Branch (658:21): [True: 4, False: 1.91k]
  ------------------
  659|      4|                {
  660|      4|                    return 0;
  661|      4|                }
  662|  1.91k|                bool select = select_opt.value();
  663|       |
  664|  1.91k|                auto word_mode_opt = consume_bool(data, size, index);
  665|  1.91k|                if (!word_mode_opt)
  ------------------
  |  Branch (665:21): [True: 2, False: 1.91k]
  ------------------
  666|      2|                {
  667|      2|                    return 0;
  668|      2|                }
  669|  1.91k|                bool word_mode = word_mode_opt.value();
  670|       |
  671|  1.91k|                FUZZ_LOG("MoveLeft({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   24|  1.91k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.91k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.91k|        std::fflush(stderr)
  ------------------
  672|  1.91k|                         print_bool(word_mode));
  673|       |
  674|  1.91k|                editor.MoveLeft(amount, select, word_mode);
  675|  1.91k|                break;
  676|  1.91k|            }
  677|       |
  678|       |            // MoveRight
  679|    942|            case 17: {
  ------------------
  |  Branch (679:13): [True: 942, False: 151k]
  ------------------
  680|    942|                auto amount_opt = consume_t<std::uint32_t>(data, size, index);
  681|    942|                if (!amount_opt)
  ------------------
  |  Branch (681:21): [True: 2, False: 940]
  ------------------
  682|      2|                {
  683|      2|                    return 0;
  684|      2|                }
  685|    940|                std::uint32_t amount = amount_opt.value();
  686|       |
  687|    940|                auto select_opt = consume_bool(data, size, index);
  688|    940|                if (!select_opt)
  ------------------
  |  Branch (688:21): [True: 1, False: 939]
  ------------------
  689|      1|                {
  690|      1|                    return 0;
  691|      1|                }
  692|    939|                bool select = select_opt.value();
  693|       |
  694|    939|                auto word_mode_opt = consume_bool(data, size, index);
  695|    939|                if (!word_mode_opt)
  ------------------
  |  Branch (695:21): [True: 3, False: 936]
  ------------------
  696|      3|                {
  697|      3|                    return 0;
  698|      3|                }
  699|    936|                bool word_mode = word_mode_opt.value();
  700|       |
  701|    936|                FUZZ_LOG("MoveRight({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   24|    936|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    936|        std::putc('\n', stderr);                                                                   \
  |  |   26|    936|        std::fflush(stderr)
  ------------------
  702|    936|                         print_bool(word_mode));
  703|       |
  704|    936|                editor.MoveRight(amount, select, word_mode);
  705|    936|                break;
  706|    939|            }
  707|       |
  708|       |            // MoveTop
  709|  1.09k|            case 18: {
  ------------------
  |  Branch (709:13): [True: 1.09k, False: 151k]
  ------------------
  710|  1.09k|                auto select_opt = consume_bool(data, size, index);
  711|  1.09k|                if (!select_opt)
  ------------------
  |  Branch (711:21): [True: 1, False: 1.09k]
  ------------------
  712|      1|                {
  713|      1|                    return 0;
  714|      1|                }
  715|  1.09k|                bool select = select_opt.value();
  716|       |
  717|  1.09k|                FUZZ_LOG("MoveTop({:s})", print_bool(select));
  ------------------
  |  |   24|  1.09k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.09k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.09k|        std::fflush(stderr)
  ------------------
  718|       |
  719|  1.09k|                editor.MoveTop(select);
  720|  1.09k|                break;
  721|  1.09k|            }
  722|       |
  723|       |            // MoveBottom
  724|     47|            case 19: {
  ------------------
  |  Branch (724:13): [True: 47, False: 152k]
  ------------------
  725|     47|                auto select_opt = consume_bool(data, size, index);
  726|     47|                if (!select_opt)
  ------------------
  |  Branch (726:21): [True: 2, False: 45]
  ------------------
  727|      2|                {
  728|      2|                    return 0;
  729|      2|                }
  730|     45|                bool select = select_opt.value();
  731|       |
  732|     45|                FUZZ_LOG("MoveBottom({:s})", print_bool(select));
  ------------------
  |  |   24|     45|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     45|        std::putc('\n', stderr);                                                                   \
  |  |   26|     45|        std::fflush(stderr)
  ------------------
  733|       |
  734|     45|                editor.MoveBottom(select);
  735|     45|                break;
  736|     47|            }
  737|       |
  738|       |            // MoveHome
  739|    225|            case 20: {
  ------------------
  |  Branch (739:13): [True: 225, False: 152k]
  ------------------
  740|    225|                auto select_opt = consume_bool(data, size, index);
  741|    225|                if (!select_opt)
  ------------------
  |  Branch (741:21): [True: 1, False: 224]
  ------------------
  742|      1|                {
  743|      1|                    return 0;
  744|      1|                }
  745|    224|                bool select = select_opt.value();
  746|       |
  747|    224|                FUZZ_LOG("MoveHome({:s})", print_bool(select));
  ------------------
  |  |   24|    224|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    224|        std::putc('\n', stderr);                                                                   \
  |  |   26|    224|        std::fflush(stderr)
  ------------------
  748|       |
  749|    224|                editor.MoveHome(select);
  750|    224|                break;
  751|    225|            }
  752|       |
  753|       |            // MoveEnd
  754|    347|            case 21: {
  ------------------
  |  Branch (754:13): [True: 347, False: 151k]
  ------------------
  755|    347|                auto select_opt = consume_bool(data, size, index);
  756|    347|                if (!select_opt)
  ------------------
  |  Branch (756:21): [True: 1, False: 346]
  ------------------
  757|      1|                {
  758|      1|                    return 0;
  759|      1|                }
  760|    346|                bool select = select_opt.value();
  761|       |
  762|    346|                FUZZ_LOG("MoveEnd({:s})", print_bool(select));
  ------------------
  |  |   24|    346|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    346|        std::putc('\n', stderr);                                                                   \
  |  |   26|    346|        std::fflush(stderr)
  ------------------
  763|       |
  764|    346|                editor.MoveEnd(select);
  765|    346|                break;
  766|    347|            }
  767|       |
  768|       |            // SetSelectionStart
  769|     46|            case 22: {
  ------------------
  |  Branch (769:13): [True: 46, False: 152k]
  ------------------
  770|     46|                auto column_opt = consume_t<std::uint32_t>(data, size, index);
  771|     46|                if (!column_opt)
  ------------------
  |  Branch (771:21): [True: 1, False: 45]
  ------------------
  772|      1|                {
  773|      1|                    return 0;
  774|      1|                }
  775|     45|                std::uint32_t column = column_opt.value();
  776|       |
  777|     45|                auto line_opt = consume_t<std::uint32_t>(data, size, index);
  778|     45|                if (!line_opt)
  ------------------
  |  Branch (778:21): [True: 2, False: 43]
  ------------------
  779|      2|                {
  780|      2|                    return 0;
  781|      2|                }
  782|     43|                std::uint32_t line = line_opt.value();
  783|       |
  784|     43|                dlxemu::CodeEditor::Coordinates coord;
  785|     43|                coord.m_Column = column;
  786|     43|                coord.m_Line   = line;
  787|       |
  788|     43|                FUZZ_LOG("SetSelectionStart(Coordinates({:s}, {:s}))", print_int(line),
  ------------------
  |  |   24|     43|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     43|        std::putc('\n', stderr);                                                                   \
  |  |   26|     43|        std::fflush(stderr)
  ------------------
  789|     43|                         print_int(column));
  790|       |
  791|     43|                editor.SetSelectionStart(coord);
  792|     43|                break;
  793|     45|            }
  794|       |
  795|       |            // SetSelectionEnd
  796|  2.13k|            case 23: {
  ------------------
  |  Branch (796:13): [True: 2.13k, False: 150k]
  ------------------
  797|  2.13k|                auto column_opt = consume_t<std::uint32_t>(data, size, index);
  798|  2.13k|                if (!column_opt)
  ------------------
  |  Branch (798:21): [True: 1, False: 2.13k]
  ------------------
  799|      1|                {
  800|      1|                    return 0;
  801|      1|                }
  802|  2.13k|                std::uint32_t column = column_opt.value();
  803|       |
  804|  2.13k|                auto line_opt = consume_t<std::uint32_t>(data, size, index);
  805|  2.13k|                if (!line_opt)
  ------------------
  |  Branch (805:21): [True: 4, False: 2.12k]
  ------------------
  806|      4|                {
  807|      4|                    return 0;
  808|      4|                }
  809|  2.12k|                std::uint32_t line = line_opt.value();
  810|       |
  811|  2.12k|                dlxemu::CodeEditor::Coordinates coord;
  812|  2.12k|                coord.m_Column = column;
  813|  2.12k|                coord.m_Line   = line;
  814|       |
  815|  2.12k|                FUZZ_LOG("SetSelectionEnd(Coordinates({:s}, {:s}))", print_int(line),
  ------------------
  |  |   24|  2.12k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  2.12k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  2.12k|        std::fflush(stderr)
  ------------------
  816|  2.12k|                         print_int(column));
  817|       |
  818|  2.12k|                editor.SetSelectionEnd(coord);
  819|  2.12k|                break;
  820|  2.13k|            }
  821|       |
  822|       |            // SetSelection
  823|  2.81k|            case 24: {
  ------------------
  |  Branch (823:13): [True: 2.81k, False: 149k]
  ------------------
  824|  2.81k|                auto column_start_opt = consume_t<std::uint32_t>(data, size, index);
  825|  2.81k|                if (!column_start_opt)
  ------------------
  |  Branch (825:21): [True: 1, False: 2.81k]
  ------------------
  826|      1|                {
  827|      1|                    return 0;
  828|      1|                }
  829|  2.81k|                std::uint32_t column_start = column_start_opt.value();
  830|       |
  831|  2.81k|                auto line_start_opt = consume_t<std::uint32_t>(data, size, index);
  832|  2.81k|                if (!line_start_opt)
  ------------------
  |  Branch (832:21): [True: 2, False: 2.81k]
  ------------------
  833|      2|                {
  834|      2|                    return 0;
  835|      2|                }
  836|  2.81k|                std::uint32_t line_start = line_start_opt.value();
  837|       |
  838|  2.81k|                dlxemu::CodeEditor::Coordinates coord_start;
  839|  2.81k|                coord_start.m_Column = column_start;
  840|  2.81k|                coord_start.m_Line   = line_start;
  841|       |
  842|  2.81k|                auto column_end_opt = consume_t<std::uint32_t>(data, size, index);
  843|  2.81k|                if (!column_end_opt)
  ------------------
  |  Branch (843:21): [True: 3, False: 2.81k]
  ------------------
  844|      3|                {
  845|      3|                    return 0;
  846|      3|                }
  847|  2.81k|                std::uint32_t column_end = column_end_opt.value();
  848|       |
  849|  2.81k|                auto line_end_opt = consume_t<std::uint32_t>(data, size, index);
  850|  2.81k|                if (!line_end_opt)
  ------------------
  |  Branch (850:21): [True: 1, False: 2.81k]
  ------------------
  851|      1|                {
  852|      1|                    return 0;
  853|      1|                }
  854|  2.81k|                std::uint32_t line_end = line_end_opt.value();
  855|       |
  856|  2.81k|                dlxemu::CodeEditor::Coordinates coord_end;
  857|  2.81k|                coord_end.m_Column = column_end;
  858|  2.81k|                coord_end.m_Line   = line_end;
  859|       |
  860|  2.81k|                auto selection_mode_opt = consume_t<std::uint8_t>(data, size, index);
  861|  2.81k|                if (!selection_mode_opt || selection_mode_opt.value() > 2u)
  ------------------
  |  Branch (861:21): [True: 6, False: 2.80k]
  |  Branch (861:44): [True: 21, False: 2.78k]
  ------------------
  862|     27|                {
  863|     27|                    return 0;
  864|     27|                }
  865|  2.78k|                dlxemu::CodeEditor::SelectionMode selection_mode =
  866|  2.78k|                        static_cast<dlxemu::CodeEditor::SelectionMode>(selection_mode_opt.value());
  867|       |
  868|  2.78k|                FUZZ_LOG("SetSelection(Coordinates({:s}, {:s}), Coordinates({:s}, "
  ------------------
  |  |   24|  2.78k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  2.78k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  2.78k|        std::fflush(stderr)
  ------------------
  869|  2.78k|                         "{:s}), {:s})",
  870|  2.78k|                         print_int(line_start), print_int(column_start), print_int(line_end),
  871|  2.78k|                         print_int(column_end), dlx::enum_name(selection_mode));
  872|       |
  873|  2.78k|                editor.SetSelection(coord_start, coord_end, selection_mode);
  874|  2.78k|                break;
  875|  2.81k|            }
  876|       |
  877|       |            // SelectWordUnderCursor
  878|    495|            case 25: {
  ------------------
  |  Branch (878:13): [True: 495, False: 151k]
  ------------------
  879|    495|                FUZZ_LOG("SelectWordUnderCursor");
  ------------------
  |  |   24|    495|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    495|        std::putc('\n', stderr);                                                                   \
  |  |   26|    495|        std::fflush(stderr)
  ------------------
  880|       |
  881|    495|                editor.SelectWordUnderCursor();
  882|    495|                break;
  883|  2.81k|            }
  884|       |
  885|       |            // SelectAll
  886|    404|            case 26: {
  ------------------
  |  Branch (886:13): [True: 404, False: 151k]
  ------------------
  887|    404|                FUZZ_LOG("SelectAll");
  ------------------
  |  |   24|    404|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    404|        std::putc('\n', stderr);                                                                   \
  |  |   26|    404|        std::fflush(stderr)
  ------------------
  888|       |
  889|    404|                editor.SelectAll();
  890|    404|                break;
  891|  2.81k|            }
  892|       |
  893|       |            // Delete
  894|    313|            case 27: {
  ------------------
  |  Branch (894:13): [True: 313, False: 151k]
  ------------------
  895|    313|                FUZZ_LOG("Delete");
  ------------------
  |  |   24|    313|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    313|        std::putc('\n', stderr);                                                                   \
  |  |   26|    313|        std::fflush(stderr)
  ------------------
  896|       |
  897|    313|                editor.Delete();
  898|    313|                break;
  899|  2.81k|            }
  900|       |
  901|       |            // Undo
  902|  5.47k|            case 28: {
  ------------------
  |  Branch (902:13): [True: 5.47k, False: 146k]
  ------------------
  903|  5.47k|                FUZZ_LOG("Undo()");
  ------------------
  |  |   24|  5.47k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  5.47k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  5.47k|        std::fflush(stderr)
  ------------------
  904|       |
  905|  5.47k|                editor.Undo();
  906|  5.47k|                break;
  907|  2.81k|            }
  908|       |
  909|       |            // Redo
  910|     66|            case 29: {
  ------------------
  |  Branch (910:13): [True: 66, False: 152k]
  ------------------
  911|     66|                FUZZ_LOG("Redo()");
  ------------------
  |  |   24|     66|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     66|        std::putc('\n', stderr);                                                                   \
  |  |   26|     66|        std::fflush(stderr)
  ------------------
  912|       |
  913|     66|                editor.Redo();
  914|     66|                break;
  915|  2.81k|            }
  916|       |
  917|       |            // SetErrorMarkers
  918|     26|            case 30: {
  ------------------
  |  Branch (918:13): [True: 26, False: 152k]
  ------------------
  919|     26|                auto count_opt = consume_t<std::size_t>(data, size, index);
  920|     26|                if (!count_opt)
  ------------------
  |  Branch (920:21): [True: 1, False: 25]
  ------------------
  921|      1|                {
  922|      1|                    return 0;
  923|      1|                }
  924|     25|                std::size_t count = std::min(count_opt.value(), MaxVectorSize);
  925|       |
  926|     25|                dlxemu::CodeEditor::ErrorMarkers markers;
  927|     25|                for (std::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (927:41): [True: 12, False: 13]
  ------------------
  928|     12|                {
  929|     12|                    auto line_number_opt = consume_t<std::uint32_t>(data, size, index);
  930|     12|                    if (!line_number_opt)
  ------------------
  |  Branch (930:25): [True: 1, False: 11]
  ------------------
  931|      1|                    {
  932|      1|                        return 0;
  933|      1|                    }
  934|     11|                    std::uint32_t line_number = line_number_opt.value();
  935|       |
  936|     11|                    if (!consume_string(data, size, index))
  ------------------
  |  Branch (936:25): [True: 11, False: 0]
  ------------------
  937|     11|                    {
  938|     11|                        return 0;
  939|     11|                    }
  940|      0|                    std::string& message = cache.string;
  941|       |
  942|       |                    // Add to error markers
  943|      0|                    markers[line_number] = message;
  944|      0|                }
  945|       |
  946|     13|                FUZZ_LOG("SetErrorMarkers({:s})", print_error_markers(markers));
  ------------------
  |  |   24|     13|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     13|        std::putc('\n', stderr);                                                                   \
  |  |   26|     13|        std::fflush(stderr)
  ------------------
  947|       |
  948|     13|                editor.SetErrorMarkers(markers);
  949|     13|                break;
  950|     25|            }
  951|       |
  952|       |            // SetBreakpoints
  953|  1.57k|            case 31: {
  ------------------
  |  Branch (953:13): [True: 1.57k, False: 150k]
  ------------------
  954|  1.57k|                auto count_opt = consume_t<std::size_t>(data, size, index);
  955|  1.57k|                if (!count_opt)
  ------------------
  |  Branch (955:21): [True: 2, False: 1.57k]
  ------------------
  956|      2|                {
  957|      2|                    return 0;
  958|      2|                }
  959|  1.57k|                std::size_t count = std::min(count_opt.value(), MaxVectorSize);
  960|       |
  961|  1.57k|                dlxemu::CodeEditor::Breakpoints breakpoints;
  962|       |
  963|  12.8k|                for (std::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (963:41): [True: 11.3k, False: 1.43k]
  ------------------
  964|  11.3k|                {
  965|  11.3k|                    auto line_number_opt = consume_t<std::uint32_t>(data, size, index);
  966|  11.3k|                    if (!line_number_opt)
  ------------------
  |  Branch (966:25): [True: 136, False: 11.2k]
  ------------------
  967|    136|                    {
  968|    136|                        return 0;
  969|    136|                    }
  970|  11.2k|                    std::uint32_t line_number = line_number_opt.value();
  971|       |
  972|  11.2k|                    breakpoints.insert(line_number);
  973|  11.2k|                }
  974|       |
  975|  1.43k|                FUZZ_LOG("SetBreakpoints({:s})", print_breakpoints(breakpoints));
  ------------------
  |  |   24|  1.43k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.43k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.43k|        std::fflush(stderr)
  ------------------
  976|       |
  977|  1.43k|                editor.SetBreakpoints(breakpoints);
  978|  1.43k|                break;
  979|  1.57k|            }
  980|       |
  981|       |            // Render
  982|  55.4k|            case 32: {
  ------------------
  |  Branch (982:13): [True: 55.4k, False: 96.8k]
  ------------------
  983|  55.4k|                auto x_opt = consume_t<float>(data, size, index);
  984|  55.4k|                if (!x_opt)
  ------------------
  |  Branch (984:21): [True: 22, False: 55.4k]
  ------------------
  985|     22|                {
  986|     22|                    return 0;
  987|     22|                }
  988|  55.4k|                float x = x_opt.value();
  989|       |
  990|  55.4k|                auto y_opt = consume_t<float>(data, size, index);
  991|  55.4k|                if (!y_opt)
  ------------------
  |  Branch (991:21): [True: 17, False: 55.4k]
  ------------------
  992|     17|                {
  993|     17|                    return 0;
  994|     17|                }
  995|  55.4k|                float y = y_opt.value();
  996|       |
  997|  55.4k|                ImVec2 size_vec(x, y);
  998|       |
  999|  55.4k|                auto border_opt = consume_bool(data, size, index);
 1000|  55.4k|                if (!border_opt)
  ------------------
  |  Branch (1000:21): [True: 21, False: 55.4k]
  ------------------
 1001|     21|                {
 1002|     21|                    return 0;
 1003|     21|                }
 1004|  55.4k|                bool border = border_opt.value();
 1005|       |
 1006|  55.4k|                FUZZ_LOG("Render(ImVec2({:f}, {:f}), {:s})", x, y, border ? "true" : "false");
  ------------------
  |  |   24|   110k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |  ------------------
  |  |  |  Branch (24:28): [True: 55.4k, False: 0]
  |  |  ------------------
  |  |   25|  55.4k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  55.4k|        std::fflush(stderr)
  ------------------
 1007|       |
 1008|  55.4k|                ImGui::NewFrame();
 1009|  55.4k|                editor.Render(size_vec, border);
 1010|  55.4k|                EndImGui();
 1011|       |
 1012|  55.4k|                break;
 1013|  55.4k|            }
 1014|       |
 1015|       |            // EnterCharacter
 1016|  44.1k|            case 33: {
  ------------------
  |  Branch (1016:13): [True: 44.1k, False: 108k]
  ------------------
 1017|  44.1k|                auto character_opt = consume_t<ImWchar>(data, size, index);
 1018|  44.1k|                if (!character_opt)
  ------------------
  |  Branch (1018:21): [True: 23, False: 44.0k]
  ------------------
 1019|     23|                {
 1020|     23|                    return 0;
 1021|     23|                }
 1022|  44.0k|                ImWchar character = character_opt.value();
 1023|       |
 1024|  44.0k|                auto shift_opt = consume_bool(data, size, index);
 1025|  44.0k|                if (!shift_opt)
  ------------------
  |  Branch (1025:21): [True: 20, False: 44.0k]
  ------------------
 1026|     20|                {
 1027|     20|                    return 0;
 1028|     20|                }
 1029|  44.0k|                bool shift = shift_opt.value();
 1030|       |
 1031|  44.0k|                FUZZ_LOG("EnterCharacter({:s}, {:s})", print_char(character), print_bool(shift));
  ------------------
  |  |   24|  44.0k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  44.0k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  44.0k|        std::fflush(stderr)
  ------------------
 1032|  44.0k|                editor.EnterCharacter(character, shift);
 1033|  44.0k|                break;
 1034|  44.0k|            }
 1035|       |
 1036|       |            // ClearText
 1037|     78|            case 34: {
  ------------------
  |  Branch (1037:13): [True: 78, False: 152k]
  ------------------
 1038|     78|                FUZZ_LOG("ClearText()");
  ------------------
  |  |   24|     78|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     78|        std::putc('\n', stderr);                                                                   \
  |  |   26|     78|        std::fflush(stderr)
  ------------------
 1039|       |
 1040|     78|                editor.ClearText();
 1041|     78|                break;
 1042|  44.0k|            }
 1043|       |
 1044|       |            // ClearSelection
 1045|     41|            case 35: {
  ------------------
  |  Branch (1045:13): [True: 41, False: 152k]
  ------------------
 1046|     41|                FUZZ_LOG("ClearSelection");
  ------------------
  |  |   24|     41|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|     41|        std::putc('\n', stderr);                                                                   \
  |  |   26|     41|        std::fflush(stderr)
  ------------------
 1047|       |
 1048|     41|                editor.ClearSelection();
 1049|     41|                break;
 1050|  44.0k|            }
 1051|       |
 1052|       |            // Backspace
 1053|  1.42k|            case 36: {
  ------------------
  |  Branch (1053:13): [True: 1.42k, False: 150k]
  ------------------
 1054|  1.42k|                FUZZ_LOG("Backspace");
  ------------------
  |  |   24|  1.42k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.42k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.42k|        std::fflush(stderr)
  ------------------
 1055|       |
 1056|  1.42k|                editor.Backspace();
 1057|  1.42k|                break;
 1058|  44.0k|            }
 1059|       |
 1060|       |            // ImGui::AddKeyEvent
 1061|    185|            case 37: {
  ------------------
  |  Branch (1061:13): [True: 185, False: 152k]
  ------------------
 1062|    185|                auto key_opt = consume_t<ImGuiKey>(data, size, index);
 1063|    185|                if (!key_opt)
  ------------------
  |  Branch (1063:21): [True: 1, False: 184]
  ------------------
 1064|      1|                {
 1065|      1|                    return 0;
 1066|      1|                }
 1067|    184|                ImGuiKey key = key_opt.value();
 1068|       |
 1069|    184|                if (!ImGui::IsNamedKey(key) || ImGui::IsAliasKey(key))
  ------------------
  |  Branch (1069:21): [True: 3, False: 181]
  |  Branch (1069:48): [True: 1, False: 180]
  ------------------
 1070|      4|                {
 1071|      4|                    return 0;
 1072|      4|                }
 1073|       |
 1074|    180|                auto down_opt = consume_bool(data, size, index);
 1075|    180|                if (!down_opt)
  ------------------
  |  Branch (1075:21): [True: 2, False: 178]
  ------------------
 1076|      2|                {
 1077|      2|                    return 0;
 1078|      2|                }
 1079|    178|                bool down = down_opt.value();
 1080|       |
 1081|    178|                FUZZ_LOG("ImGui::GetIO().AddKeyEvent({}, {:s})", key, print_bool(down));
  ------------------
  |  |   24|    178|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    178|        std::putc('\n', stderr);                                                                   \
  |  |   26|    178|        std::fflush(stderr)
  ------------------
 1082|    178|                ImGui::GetIO().AddKeyEvent(key, down);
 1083|       |
 1084|    178|                break;
 1085|    180|            }
 1086|       |
 1087|       |            // ImGui::AddKeyAnalogEvent
 1088|  2.94k|            case 38: {
  ------------------
  |  Branch (1088:13): [True: 2.94k, False: 149k]
  ------------------
 1089|  2.94k|                auto key_opt = consume_t<ImGuiKey>(data, size, index);
 1090|  2.94k|                if (!key_opt)
  ------------------
  |  Branch (1090:21): [True: 1, False: 2.94k]
  ------------------
 1091|      1|                {
 1092|      1|                    return 0;
 1093|      1|                }
 1094|  2.94k|                ImGuiKey key = key_opt.value();
 1095|       |
 1096|  2.94k|                if (!ImGui::IsNamedKey(key) || ImGui::IsAliasKey(key))
  ------------------
  |  Branch (1096:21): [True: 8, False: 2.93k]
  |  Branch (1096:48): [True: 1, False: 2.93k]
  ------------------
 1097|      9|                {
 1098|      9|                    return 0;
 1099|      9|                }
 1100|       |
 1101|  2.93k|                auto down_opt = consume_bool(data, size, index);
 1102|  2.93k|                if (!down_opt)
  ------------------
  |  Branch (1102:21): [True: 7, False: 2.92k]
  ------------------
 1103|      7|                {
 1104|      7|                    return 0;
 1105|      7|                }
 1106|  2.92k|                bool down = down_opt.value();
 1107|       |
 1108|  2.92k|                auto value_opt = consume_t<float>(data, size, index);
 1109|  2.92k|                if (!value_opt)
  ------------------
  |  Branch (1109:21): [True: 1, False: 2.92k]
  ------------------
 1110|      1|                {
 1111|      1|                    return 0;
 1112|      1|                }
 1113|  2.92k|                float value = value_opt.value();
 1114|       |
 1115|  2.92k|                FUZZ_LOG("ImGui::GetIO().AddKeyAnalogEvent({}, {:s}, {:f})", key, print_bool(down),
  ------------------
  |  |   24|  2.92k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  2.92k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  2.92k|        std::fflush(stderr)
  ------------------
 1116|  2.92k|                         value);
 1117|  2.92k|                ImGui::GetIO().AddKeyAnalogEvent(key, down, value);
 1118|       |
 1119|  2.92k|                break;
 1120|  2.92k|            }
 1121|       |
 1122|       |            // ImGui::AddMousePosEvent
 1123|  1.80k|            case 39: {
  ------------------
  |  Branch (1123:13): [True: 1.80k, False: 150k]
  ------------------
 1124|  1.80k|                auto x_opt = consume_t<float>(data, size, index);
 1125|  1.80k|                if (!x_opt)
  ------------------
  |  Branch (1125:21): [True: 2, False: 1.79k]
  ------------------
 1126|      2|                {
 1127|      2|                    return 0;
 1128|      2|                }
 1129|  1.79k|                float x = x_opt.value();
 1130|       |
 1131|  1.79k|                if (phi::abs(x) >= 1024.0f)
  ------------------
  |  Branch (1131:21): [True: 1, False: 1.79k]
  ------------------
 1132|      1|                {
 1133|      1|                    return 0;
 1134|      1|                }
 1135|       |
 1136|  1.79k|                auto y_opt = consume_t<float>(data, size, index);
 1137|  1.79k|                if (!y_opt)
  ------------------
  |  Branch (1137:21): [True: 1, False: 1.79k]
  ------------------
 1138|      1|                {
 1139|      1|                    return 0;
 1140|      1|                }
 1141|  1.79k|                float y = y_opt.value();
 1142|       |
 1143|  1.79k|                if (phi::abs(y) >= 1024.0f)
  ------------------
  |  Branch (1143:21): [True: 2, False: 1.79k]
  ------------------
 1144|      2|                {
 1145|      2|                    return 0;
 1146|      2|                }
 1147|       |
 1148|  1.79k|                FUZZ_LOG("ImGui::GetIO().AddMousePosEvent({:f}, {:f})", x, y);
  ------------------
  |  |   24|  1.79k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.79k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.79k|        std::fflush(stderr)
  ------------------
 1149|  1.79k|                ImGui::GetIO().AddMousePosEvent(x, y);
 1150|       |
 1151|  1.79k|                break;
 1152|  1.79k|            }
 1153|       |
 1154|       |            // ImGui::AddMouseButtonEvent
 1155|  2.81k|            case 40: {
  ------------------
  |  Branch (1155:13): [True: 2.81k, False: 149k]
  ------------------
 1156|  2.81k|                auto button_opt = consume_t<int>(data, size, index);
 1157|  2.81k|                if (!button_opt)
  ------------------
  |  Branch (1157:21): [True: 1, False: 2.81k]
  ------------------
 1158|      1|                {
 1159|      1|                    return 0;
 1160|      1|                }
 1161|  2.81k|                int button = button_opt.value();
 1162|       |
 1163|  2.81k|                if (button < 0 || button >= ImGuiMouseButton_COUNT)
  ------------------
  |  Branch (1163:21): [True: 5, False: 2.80k]
  |  Branch (1163:35): [True: 10, False: 2.79k]
  ------------------
 1164|     15|                {
 1165|     15|                    return 0;
 1166|     15|                }
 1167|       |
 1168|  2.79k|                auto down_opt = consume_bool(data, size, index);
 1169|  2.79k|                if (!down_opt)
  ------------------
  |  Branch (1169:21): [True: 1, False: 2.79k]
  ------------------
 1170|      1|                {
 1171|      1|                    return 0;
 1172|      1|                }
 1173|  2.79k|                bool down = down_opt.value();
 1174|       |
 1175|  2.79k|                FUZZ_LOG("ImGui::GetIO().AddMouseButtonEvent({}, {:s})", button, print_bool(down));
  ------------------
  |  |   24|  2.79k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  2.79k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  2.79k|        std::fflush(stderr)
  ------------------
 1176|  2.79k|                ImGui::GetIO().AddMouseButtonEvent(button, down);
 1177|       |
 1178|  2.79k|                break;
 1179|  2.79k|            }
 1180|       |
 1181|       |            // ImGui::AddMouseWheelEvent
 1182|  1.31k|            case 41: {
  ------------------
  |  Branch (1182:13): [True: 1.31k, False: 150k]
  ------------------
 1183|  1.31k|                auto wh_x_opt = consume_t<float>(data, size, index);
 1184|  1.31k|                if (!wh_x_opt)
  ------------------
  |  Branch (1184:21): [True: 1, False: 1.31k]
  ------------------
 1185|      1|                {
 1186|      1|                    return 0;
 1187|      1|                }
 1188|  1.31k|                float wh_x = wh_x_opt.value();
 1189|       |
 1190|  1.31k|                auto wh_y_opt = consume_t<float>(data, size, index);
 1191|  1.31k|                if (!wh_y_opt)
  ------------------
  |  Branch (1191:21): [True: 2, False: 1.31k]
  ------------------
 1192|      2|                {
 1193|      2|                    return 0;
 1194|      2|                }
 1195|  1.31k|                float wh_y = wh_y_opt.value();
 1196|       |
 1197|  1.31k|                FUZZ_LOG("ImGui::GetIO().AddMouseWheelEvent({:f}, {:f})", wh_x, wh_y);
  ------------------
  |  |   24|  1.31k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  1.31k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  1.31k|        std::fflush(stderr)
  ------------------
 1198|  1.31k|                ImGui::GetIO().AddMouseWheelEvent(wh_x, wh_y);
 1199|       |
 1200|  1.31k|                break;
 1201|  1.31k|            }
 1202|       |
 1203|       |            // ImGui::AddFocusEvent
 1204|    241|            case 42: {
  ------------------
  |  Branch (1204:13): [True: 241, False: 152k]
  ------------------
 1205|    241|                auto focused_opt = consume_bool(data, size, index);
 1206|    241|                if (!focused_opt)
  ------------------
  |  Branch (1206:21): [True: 1, False: 240]
  ------------------
 1207|      1|                {
 1208|      1|                    return 0;
 1209|      1|                }
 1210|    240|                bool focused = focused_opt.value();
 1211|       |
 1212|    240|                FUZZ_LOG("ImGui::GetIO().AddFocusEvent({:s})", print_bool(focused));
  ------------------
  |  |   24|    240|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    240|        std::putc('\n', stderr);                                                                   \
  |  |   26|    240|        std::fflush(stderr)
  ------------------
 1213|    240|                ImGui::GetIO().AddFocusEvent(focused);
 1214|       |
 1215|    240|                break;
 1216|    241|            }
 1217|       |
 1218|       |            // ImGui::AddInputCharacter
 1219|    535|            case 43: {
  ------------------
  |  Branch (1219:13): [True: 535, False: 151k]
  ------------------
 1220|    535|                auto c_opt = consume_t<unsigned int>(data, size, index);
 1221|    535|                if (!c_opt)
  ------------------
  |  Branch (1221:21): [True: 2, False: 533]
  ------------------
 1222|      2|                {
 1223|      2|                    return 0;
 1224|      2|                }
 1225|    533|                unsigned int c = c_opt.value();
 1226|       |
 1227|    533|                FUZZ_LOG("ImGui::GetIO().AddInputCharacter({})", c);
  ------------------
  |  |   24|    533|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    533|        std::putc('\n', stderr);                                                                   \
  |  |   26|    533|        std::fflush(stderr)
  ------------------
 1228|    533|                ImGui::GetIO().AddInputCharacter(c);
 1229|       |
 1230|    533|                break;
 1231|    535|            }
 1232|       |
 1233|       |            // ImGui::AddInputCharacterUTF16
 1234|    789|            case 44: {
  ------------------
  |  Branch (1234:13): [True: 789, False: 151k]
  ------------------
 1235|    789|                auto c_opt = consume_t<ImWchar16>(data, size, index);
 1236|    789|                if (!c_opt)
  ------------------
  |  Branch (1236:21): [True: 1, False: 788]
  ------------------
 1237|      1|                {
 1238|      1|                    return 0;
 1239|      1|                }
 1240|    788|                ImWchar16 c = c_opt.value();
 1241|       |
 1242|    788|                FUZZ_LOG("ImGui::GetIO().AddInputCharacterUTF16({})", c);
  ------------------
  |  |   24|    788|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|    788|        std::putc('\n', stderr);                                                                   \
  |  |   26|    788|        std::fflush(stderr)
  ------------------
 1243|    788|                ImGui::GetIO().AddInputCharacterUTF16(c);
 1244|       |
 1245|    788|                break;
 1246|    789|            }
 1247|       |
 1248|       |            // ImGui::AddInputCharactersUTF8
 1249|     11|            case 45: {
  ------------------
  |  Branch (1249:13): [True: 11, False: 152k]
  ------------------
 1250|     11|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (1250:21): [True: 11, False: 0]
  ------------------
 1251|     11|                {
 1252|     11|                    return 0;
 1253|     11|                }
 1254|      0|                std::string& str = cache.string;
 1255|       |
 1256|      0|                FUZZ_LOG("ImGui::GetIO().AddInputCharactersUTF8({:s})", print_string(str));
  ------------------
  |  |   24|      0|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|      0|        std::putc('\n', stderr);                                                                   \
  |  |   26|      0|        std::fflush(stderr)
  ------------------
 1257|      0|                ImGui::GetIO().AddInputCharactersUTF8(str.c_str());
 1258|       |
 1259|      0|                break;
 1260|     11|            }
 1261|       |
 1262|  3.37k|            default: {
  ------------------
  |  Branch (1262:13): [True: 3.37k, False: 148k]
  ------------------
 1263|  3.37k|                return 0;
 1264|     11|            }
 1265|   152k|        }
 1266|   152k|    }
 1267|       |
 1268|  2.33k|    FUZZ_LOG("VerifyInternalState()");
  ------------------
  |  |   24|  2.33k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  2.33k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  2.33k|        std::fflush(stderr)
  ------------------
 1269|  2.33k|    editor.VerifyInternalState();
 1270|       |
 1271|  2.33k|    FUZZ_LOG("Finished execution");
  ------------------
  |  |   24|  2.33k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   25|  2.33k|        std::putc('\n', stderr);                                                                   \
  |  |   26|  2.33k|        std::fflush(stderr)
  ------------------
 1272|       |
 1273|  2.33k|    return 0;
 1274|  7.25k|}
_ZN5Cache10InitializeEv:
   49|      2|    {
   50|      2|        Cache c;
   51|       |
   52|       |        // Resize vector args
   53|     18|        for (phi::usize i{0u}; i < MaxVectorSize; ++i)
  ------------------
  |  Branch (53:32): [True: 16, False: 2]
  ------------------
   54|     16|        {
   55|     16|            svec& vector = c.vector_string[i.unsafe()];
   56|     16|            vector.resize(i.unsafe());
   57|       |
   58|       |            // Reserve max size
   59|     16|            for (std::string& str : vector)
  ------------------
  |  Branch (59:35): [True: 56, False: 16]
  ------------------
   60|     56|            {
   61|     56|                str.reserve(MaxStringLength);
   62|     56|            }
   63|     16|        }
   64|       |
   65|      2|        c.string.reserve(MaxStringLength);
   66|       |
   67|      2|        return c;
   68|      2|    }
_Z10has_x_moremmm:
   75|   483k|{
   76|   483k|    return index + x < size;
   77|   483k|}
_Z12aligned_sizeIbEmv:
   81|   118k|{
   82|   118k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|   118k|}
_Z9consume_tIjEN3phi8optionalIT_EEPKhmRm:
   88|   188k|{
   89|   188k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (89:9): [True: 791, False: 187k]
  ------------------
   90|    791|    {
   91|    791|        return {};
   92|    791|    }
   93|       |
   94|   187k|    PHI_ASSUME(index % sizeof(void*) == 0);
   95|       |
   96|   187k|    T value = *reinterpret_cast<const T*>(data + index);
   97|   187k|    index += aligned_size<T>();
   98|       |
   99|   187k|    return value;
  100|   188k|}
_Z12aligned_sizeIjEmv:
   81|   187k|{
   82|   187k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|   187k|}
_Z9consume_tImEN3phi8optionalIT_EEPKhmRm:
   88|  1.74k|{
   89|  1.74k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (89:9): [True: 5, False: 1.74k]
  ------------------
   90|      5|    {
   91|      5|        return {};
   92|      5|    }
   93|       |
   94|  1.74k|    PHI_ASSUME(index % sizeof(void*) == 0);
   95|       |
   96|  1.74k|    T value = *reinterpret_cast<const T*>(data + index);
   97|  1.74k|    index += aligned_size<T>();
   98|       |
   99|  1.74k|    return value;
  100|  1.74k|}
_Z12aligned_sizeImEmv:
   81|  1.74k|{
   82|  1.74k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|  1.74k|}
_Z11pretty_charItENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
  224|  44.0k|{
  225|  44.0k|    switch (c)
  226|  44.0k|    {
  227|  9.23k|        case '\n':
  ------------------
  |  Branch (227:9): [True: 9.23k, False: 34.8k]
  ------------------
  228|  9.23k|            return "\\n";
  229|  2.56k|        case '\0':
  ------------------
  |  Branch (229:9): [True: 2.56k, False: 41.4k]
  ------------------
  230|  2.56k|            return "\\0";
  231|  3.56k|        case '\t':
  ------------------
  |  Branch (231:9): [True: 3.56k, False: 40.4k]
  ------------------
  232|  3.56k|            return "\\t";
  233|     74|        case '\r':
  ------------------
  |  Branch (233:9): [True: 74, False: 43.9k]
  ------------------
  234|     74|            return "\\r";
  235|     70|        case '\a':
  ------------------
  |  Branch (235:9): [True: 70, False: 43.9k]
  ------------------
  236|     70|            return "\\a";
  237|     58|        case '\v':
  ------------------
  |  Branch (237:9): [True: 58, False: 44.0k]
  ------------------
  238|     58|            return "\\v";
  239|     43|        case '"':
  ------------------
  |  Branch (239:9): [True: 43, False: 44.0k]
  ------------------
  240|     43|            return "\\\"";
  241|       |
  242|  28.4k|        default:
  ------------------
  |  Branch (242:9): [True: 28.4k, False: 15.6k]
  ------------------
  243|  28.4k|            return {1u, static_cast<const char>(c)};
  244|  44.0k|    }
  245|  44.0k|}
_Z9print_intIjENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
  218|  32.3k|{
  219|  32.3k|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
  220|  32.3k|}
_Z9consume_tIhEN3phi8optionalIT_EEPKhmRm:
   88|  3.94k|{
   89|  3.94k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (89:9): [True: 7, False: 3.93k]
  ------------------
   90|      7|    {
   91|      7|        return {};
   92|      7|    }
   93|       |
   94|  3.93k|    PHI_ASSUME(index % sizeof(void*) == 0);
   95|       |
   96|  3.93k|    T value = *reinterpret_cast<const T*>(data + index);
   97|  3.93k|    index += aligned_size<T>();
   98|       |
   99|  3.93k|    return value;
  100|  3.94k|}
_Z12aligned_sizeIhEmv:
   81|  3.93k|{
   82|  3.93k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|  3.93k|}
_Z9print_intIhENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
  218|  1.13k|{
  219|  1.13k|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
  220|  1.13k|}
_Z9consume_tIfEN3phi8optionalIT_EEPKhmRm:
   88|   120k|{
   89|   120k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (89:9): [True: 46, False: 120k]
  ------------------
   90|     46|    {
   91|     46|        return {};
   92|     46|    }
   93|       |
   94|   120k|    PHI_ASSUME(index % sizeof(void*) == 0);
   95|       |
   96|   120k|    T value = *reinterpret_cast<const T*>(data + index);
   97|   120k|    index += aligned_size<T>();
   98|       |
   99|   120k|    return value;
  100|   120k|}
_Z12aligned_sizeIfEmv:
   81|   120k|{
   82|   120k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|   120k|}
_Z9consume_tItEN3phi8optionalIT_EEPKhmRm:
   88|  44.8k|{
   89|  44.8k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (89:9): [True: 24, False: 44.8k]
  ------------------
   90|     24|    {
   91|     24|        return {};
   92|     24|    }
   93|       |
   94|  44.8k|    PHI_ASSUME(index % sizeof(void*) == 0);
   95|       |
   96|  44.8k|    T value = *reinterpret_cast<const T*>(data + index);
   97|  44.8k|    index += aligned_size<T>();
   98|       |
   99|  44.8k|    return value;
  100|  44.8k|}
_Z12aligned_sizeItEmv:
   81|  44.8k|{
   82|  44.8k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|  44.8k|}
_Z9consume_tI8ImGuiKeyEN3phi8optionalIT_EEPKhmRm:
   88|  3.12k|{
   89|  3.12k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (89:9): [True: 2, False: 3.12k]
  ------------------
   90|      2|    {
   91|      2|        return {};
   92|      2|    }
   93|       |
   94|  3.12k|    PHI_ASSUME(index % sizeof(void*) == 0);
   95|       |
   96|  3.12k|    T value = *reinterpret_cast<const T*>(data + index);
   97|  3.12k|    index += aligned_size<T>();
   98|       |
   99|  3.12k|    return value;
  100|  3.12k|}
_Z12aligned_sizeI8ImGuiKeyEmv:
   81|  3.12k|{
   82|  3.12k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|  3.12k|}
_Z9consume_tIiEN3phi8optionalIT_EEPKhmRm:
   88|  2.81k|{
   89|  2.81k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (89:9): [True: 1, False: 2.81k]
  ------------------
   90|      1|    {
   91|      1|        return {};
   92|      1|    }
   93|       |
   94|  2.81k|    PHI_ASSUME(index % sizeof(void*) == 0);
   95|       |
   96|  2.81k|    T value = *reinterpret_cast<const T*>(data + index);
   97|  2.81k|    index += aligned_size<T>();
   98|       |
   99|  2.81k|    return value;
  100|  2.81k|}
_Z12aligned_sizeIiEmv:
   81|  2.81k|{
   82|  2.81k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   83|  2.81k|}

