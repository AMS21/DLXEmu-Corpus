_ZN3dlx11MemoryBlock10MemoryByteC2Ev:
   17|   344k|            {}

_ZN3dlx11MemoryBlockC2EN3phi7integerImEES3_:
   15|  2.63k|    {
   16|  2.63k|        m_Values.resize(starting_size.unsafe());
   17|  2.63k|    }
_ZNK3dlx11MemoryBlock8LoadByteEN3phi7integerImEE:
   20|  38.8k|    {
   21|  38.8k|        if (!IsAddressValid(address, 1u))
  ------------------
  |  Branch (21:13): [True: 34.1k, False: 4.74k]
  ------------------
   22|  34.1k|        {
   23|  34.1k|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|  34.1k|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   24|  34.1k|            return {};
   25|  34.1k|        }
   26|       |
   27|  4.74k|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
   28|       |
   29|  4.74k|        return m_Values[raw_address].signed_value;
   30|  38.8k|    }
_ZNK3dlx11MemoryBlock16LoadUnsignedByteEN3phi7integerImEE:
   33|    908|    {
   34|    908|        if (!IsAddressValid(address, 1u))
  ------------------
  |  Branch (34:13): [True: 810, False: 98]
  ------------------
   35|    810|        {
   36|    810|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    810|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   37|    810|            return {};
   38|    810|        }
   39|       |
   40|     98|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
   41|     98|        return m_Values[raw_address].unsigned_value;
   42|    908|    }
_ZNK3dlx11MemoryBlock12LoadHalfWordEN3phi7integerImEE:
   45|    981|    {
   46|    981|        if (!IsAddressValid(address, 2u))
  ------------------
  |  Branch (46:13): [True: 840, False: 141]
  ------------------
   47|    840|        {
   48|    840|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    840|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   49|    840|            return {};
   50|    840|        }
   51|       |
   52|    141|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
   53|       |
   54|    141|        if (!IsAddressAlignedCorrectly(raw_address, 2u))
  ------------------
  |  Branch (54:13): [True: 56, False: 85]
  ------------------
   55|     56|        {
   56|     56|            DLX_ERROR("Address {} is misaligned", address.unsafe());
  ------------------
  |  |    9|     56|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   57|     56|            return {};
   58|     56|        }
   59|       |
   60|     85|        return *reinterpret_cast<const std::int16_t*>(&m_Values[raw_address].signed_value);
   61|    141|    }
_ZNK3dlx11MemoryBlock20LoadUnsignedHalfWordEN3phi7integerImEE:
   64|    324|    {
   65|    324|        if (!IsAddressValid(address, 2u))
  ------------------
  |  Branch (65:13): [True: 259, False: 65]
  ------------------
   66|    259|        {
   67|    259|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    259|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   68|    259|            return {};
   69|    259|        }
   70|       |
   71|     65|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
   72|       |
   73|     65|        if (!IsAddressAlignedCorrectly(raw_address, 2u))
  ------------------
  |  Branch (73:13): [True: 26, False: 39]
  ------------------
   74|     26|        {
   75|     26|            DLX_ERROR("Address {} is misaligned", address.unsafe());
  ------------------
  |  |    9|     26|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   76|     26|            return {};
   77|     26|        }
   78|       |
   79|     39|        return *reinterpret_cast<const std::uint16_t*>(&m_Values[raw_address].unsigned_value);
   80|     65|    }
_ZNK3dlx11MemoryBlock8LoadWordEN3phi7integerImEE:
   83|    639|    {
   84|    639|        if (!IsAddressValid(address, 4u))
  ------------------
  |  Branch (84:13): [True: 547, False: 92]
  ------------------
   85|    547|        {
   86|    547|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    547|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   87|    547|            return {};
   88|    547|        }
   89|       |
   90|     92|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
   91|       |
   92|     92|        if (!IsAddressAlignedCorrectly(raw_address, 4u))
  ------------------
  |  Branch (92:13): [True: 22, False: 70]
  ------------------
   93|     22|        {
   94|     22|            DLX_ERROR("Address {} is misaligned", address.unsafe());
  ------------------
  |  |    9|     22|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
   95|     22|            return {};
   96|     22|        }
   97|       |
   98|     70|        return *reinterpret_cast<const std::int32_t*>(&m_Values[raw_address].signed_value);
   99|     92|    }
_ZNK3dlx11MemoryBlock16LoadUnsignedWordEN3phi7integerImEE:
  102|    432|    {
  103|    432|        if (!IsAddressValid(address, 4u))
  ------------------
  |  Branch (103:13): [True: 362, False: 70]
  ------------------
  104|    362|        {
  105|    362|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    362|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  106|    362|            return {};
  107|    362|        }
  108|       |
  109|     70|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
  110|       |
  111|     70|        if (!IsAddressAlignedCorrectly(raw_address, 4u))
  ------------------
  |  Branch (111:13): [True: 21, False: 49]
  ------------------
  112|     21|        {
  113|     21|            DLX_ERROR("Address {} is misaligned", address.unsafe());
  ------------------
  |  |    9|     21|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  114|     21|            return {};
  115|     21|        }
  116|       |
  117|     49|        return *reinterpret_cast<const std::uint32_t*>(&m_Values[raw_address].unsigned_value);
  118|     70|    }
_ZNK3dlx11MemoryBlock9LoadFloatEN3phi7integerImEE:
  121|    338|    {
  122|    338|        if (!IsAddressValid(address, 4u))
  ------------------
  |  Branch (122:13): [True: 283, False: 55]
  ------------------
  123|    283|        {
  124|    283|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    283|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  125|    283|            return {};
  126|    283|        }
  127|       |
  128|     55|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
  129|       |
  130|     55|        if (!IsAddressAlignedCorrectly(raw_address, sizeof(phi::f32)))
  ------------------
  |  Branch (130:13): [True: 20, False: 35]
  ------------------
  131|     20|        {
  132|     20|            DLX_ERROR("Address {} is misaligned", address.unsafe());
  ------------------
  |  |    9|     20|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  133|     20|            return {};
  134|     20|        }
  135|       |
  136|     35|        return *reinterpret_cast<const float*>(&m_Values[raw_address].signed_value);
  137|     55|    }
_ZNK3dlx11MemoryBlock10LoadDoubleEN3phi7integerImEE:
  140|    389|    {
  141|    389|        if (!IsAddressValid(address, 8u))
  ------------------
  |  Branch (141:13): [True: 212, False: 177]
  ------------------
  142|    212|        {
  143|    212|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    212|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  144|    212|            return {};
  145|    212|        }
  146|       |
  147|    177|        const phi::size_t raw_address = (address - m_StartingAddress).unsafe();
  148|       |
  149|    177|        if (!IsAddressAlignedCorrectly(raw_address, sizeof(phi::f64)))
  ------------------
  |  Branch (149:13): [True: 122, False: 55]
  ------------------
  150|    122|        {
  151|    122|            DLX_ERROR("Address {} is misaligned", address.unsafe());
  ------------------
  |  |    9|    122|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  152|    122|            return {};
  153|    122|        }
  154|       |
  155|     55|        return *reinterpret_cast<const double*>(&m_Values[(raw_address)].signed_value);
  156|    177|    }
_ZN3dlx11MemoryBlock9StoreByteEN3phi7integerImEENS2_IaEE:
  159|    597|    {
  160|    597|        if (!IsAddressValid(address, 1u))
  ------------------
  |  Branch (160:13): [True: 501, False: 96]
  ------------------
  161|    501|        {
  162|    501|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    501|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  163|    501|            return false;
  164|    501|        }
  165|       |
  166|     96|        m_Values[(address - m_StartingAddress).unsafe()].signed_value = value.unsafe();
  167|     96|        return true;
  168|    597|    }
_ZN3dlx11MemoryBlock17StoreUnsignedByteEN3phi7integerImEENS2_IhEE:
  171|    390|    {
  172|    390|        if (!IsAddressValid(address, 1u))
  ------------------
  |  Branch (172:13): [True: 314, False: 76]
  ------------------
  173|    314|        {
  174|    314|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    314|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  175|    314|            return false;
  176|    314|        }
  177|       |
  178|     76|        m_Values[(address - m_StartingAddress).unsafe()].unsigned_value = value.unsafe();
  179|     76|        return true;
  180|    390|    }
_ZN3dlx11MemoryBlock13StoreHalfWordEN3phi7integerImEENS2_IsEE:
  183|  1.45k|    {
  184|  1.45k|        if (!IsAddressValid(address, 2u))
  ------------------
  |  Branch (184:13): [True: 1.34k, False: 107]
  ------------------
  185|  1.34k|        {
  186|  1.34k|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|  1.34k|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  187|  1.34k|            return false;
  188|  1.34k|        }
  189|       |
  190|    107|        phi::size_t index = (address - m_StartingAddress).unsafe();
  191|    107|        *reinterpret_cast<std::int16_t*>(&m_Values[index].signed_value) = value.unsafe();
  192|       |
  193|    107|        return true;
  194|  1.45k|    }
_ZN3dlx11MemoryBlock21StoreUnsignedHalfWordEN3phi7integerImEENS2_ItEE:
  197|    315|    {
  198|    315|        if (!IsAddressValid(address, 2u))
  ------------------
  |  Branch (198:13): [True: 254, False: 61]
  ------------------
  199|    254|        {
  200|    254|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    254|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  201|    254|            return false;
  202|    254|        }
  203|       |
  204|     61|        phi::size_t index = (address - m_StartingAddress).unsafe();
  205|     61|        *reinterpret_cast<std::uint16_t*>(&m_Values[index].unsigned_value) = value.unsafe();
  206|       |
  207|     61|        return true;
  208|    315|    }
_ZN3dlx11MemoryBlock9StoreWordEN3phi7integerImEENS2_IiEE:
  211|    853|    {
  212|    853|        if (!IsAddressValid(address, 4u))
  ------------------
  |  Branch (212:13): [True: 764, False: 89]
  ------------------
  213|    764|        {
  214|    764|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    764|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  215|    764|            return false;
  216|    764|        }
  217|       |
  218|     89|        phi::size_t index = (address - m_StartingAddress).unsafe();
  219|     89|        *reinterpret_cast<std::int32_t*>(&m_Values[index].signed_value) = value.unsafe();
  220|       |
  221|     89|        return true;
  222|    853|    }
_ZN3dlx11MemoryBlock17StoreUnsignedWordEN3phi7integerImEENS2_IjEE:
  225|    224|    {
  226|    224|        if (!IsAddressValid(address, 4u))
  ------------------
  |  Branch (226:13): [True: 190, False: 34]
  ------------------
  227|    190|        {
  228|    190|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|    190|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  229|    190|            return false;
  230|    190|        }
  231|       |
  232|     34|        phi::size_t index = (address - m_StartingAddress).unsafe();
  233|     34|        *reinterpret_cast<std::uint32_t*>(&m_Values[index].unsigned_value) = value.unsafe();
  234|       |
  235|     34|        return true;
  236|    224|    }
_ZN3dlx11MemoryBlock10StoreFloatEN3phi7integerImEENS1_14floating_pointIfEE:
  239|  1.99k|    {
  240|  1.99k|        if (!IsAddressValid(address, 4u))
  ------------------
  |  Branch (240:13): [True: 1.93k, False: 60]
  ------------------
  241|  1.93k|        {
  242|  1.93k|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|  1.93k|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  243|  1.93k|            return false;
  244|  1.93k|        }
  245|       |
  246|     60|        phi::size_t index = (address - m_StartingAddress).unsafe();
  247|     60|        *reinterpret_cast<float*>(&m_Values[index].signed_value) = value.unsafe();
  248|       |
  249|     60|        return true;
  250|  1.99k|    }
_ZN3dlx11MemoryBlock11StoreDoubleEN3phi7integerImEENS1_14floating_pointIdEE:
  253|  3.22k|    {
  254|  3.22k|        if (!IsAddressValid(address, 8u))
  ------------------
  |  Branch (254:13): [True: 3.13k, False: 87]
  ------------------
  255|  3.13k|        {
  256|  3.13k|            DLX_ERROR("Address {} is out of bounds", address.unsafe());
  ------------------
  |  |    9|  3.13k|#define DLX_ERROR(...)    PHI_EMPTY_MACRO()
  ------------------
  257|  3.13k|            return false;
  258|  3.13k|        }
  259|       |
  260|     87|        phi::size_t index = (address - m_StartingAddress).unsafe();
  261|     87|        *reinterpret_cast<double*>(&m_Values[index].signed_value) = value.unsafe();
  262|       |
  263|     87|        return true;
  264|  3.22k|    }
_ZNK3dlx11MemoryBlock14IsAddressValidEN3phi7integerImEES3_:
  267|  52.2k|    {
  268|  52.2k|        return address >= m_StartingAddress &&
  ------------------
  |  Branch (268:16): [True: 34.8k, False: 17.3k]
  ------------------
  269|  52.2k|               !phi::detail::will_addition_error(phi::detail::arithmetic_tag_for<phi::size_t>{},
  ------------------
  |  Branch (269:16): [True: 32.6k, False: 2.21k]
  ------------------
  270|  34.8k|                                                 address.unsafe(), size.unsafe()) &&
  271|  52.2k|               (address + size) <= (m_StartingAddress + m_Values.size());
  ------------------
  |  Branch (271:16): [True: 6.05k, False: 26.6k]
  ------------------
  272|  52.2k|    }
_ZN3dlx11MemoryBlock25IsAddressAlignedCorrectlyEN3phi7integerImEES3_:
  276|    984|    {
  277|    984|        return size != 0u && (address % size) == 0u;
  ------------------
  |  Branch (277:16): [True: 850, False: 134]
  |  Branch (277:30): [True: 414, False: 436]
  ------------------
  278|    984|    }
_ZNK3dlx11MemoryBlock18GetStartingAddressEv:
  289|     58|    {
  290|     58|        return m_StartingAddress;
  291|     58|    }
_ZN3dlx11MemoryBlock18SetStartingAddressEN3phi7integerImEE:
  294|    513|    {
  295|    513|        m_StartingAddress = new_starting_address;
  296|    513|    }
_ZNK3dlx11MemoryBlock7GetSizeEv:
  299|     39|    {
  300|     39|        return m_Values.size();
  301|     39|    }
_ZN3dlx11MemoryBlock6ResizeEN3phi7integerImEE:
  304|    565|    {
  305|    565|        m_Values.resize(new_size.unsafe());
  306|    565|    }
_ZN3dlx11MemoryBlock12GetRawMemoryEv:
  309|    146|    {
  310|    146|        return m_Values;
  311|    146|    }

_ZN3fmt2v96detail6bufferIcE10try_resizeEm:
  930|  63.1k|  FMT_CONSTEXPR20 void try_resize(size_t count) {
  931|  63.1k|    try_reserve(count);
  932|  63.1k|    size_ = count <= capacity_ ? count : capacity_;
  ------------------
  |  Branch (932:13): [True: 63.1k, False: 0]
  ------------------
  933|  63.1k|  }
_ZN3fmt2v96detail11to_unsignedIiEENSt3__113make_unsignedIT_E4typeES5_:
  393|  74.9M|    typename std::make_unsigned<Int>::type {
  394|  74.9M|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  352|   149M|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (352:37): [Folded - Ignored]
  |  |  |  Branch (352:37): [True: 74.9M, False: 0]
  |  |  ------------------
  ------------------
  395|  74.9M|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  396|  74.9M|}
_ZN3fmt2v96detail13ignore_unusedIJbA15_cEEEvDpRKT_:
  328|  75.5M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt2v917basic_string_viewIcE4sizeEv:
  460|   701k|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail13ignore_unusedIJbA1_cEEEvDpRKT_:
  328|  3.35M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt2v96detail6bufferIcE4sizeEv:
  914|   178k|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail6bufferIcEC2EPcmm:
  886|   120k|      : ptr_(p), size_(sz), capacity_(cap) {}
_ZN3fmt2v96detail6bufferIcE3setEPcm:
  892|   120k|  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  893|   120k|    ptr_ = buf_data;
  894|   120k|    capacity_ = buf_capacity;
  895|   120k|  }
_ZNK3fmt2v96detail6bufferIcE8capacityEv:
  917|  58.3k|  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
_ZN3fmt2v96detail6bufferIcE4dataEv:
  920|   246k|  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
_ZN3fmt2v96detail6bufferIcE9push_backERKc:
  943|  42.1k|  FMT_CONSTEXPR20 void push_back(const T& value) {
  944|  42.1k|    try_reserve(size_ + 1);
  945|  42.1k|    ptr_[size_++] = value;
  946|  42.1k|  }
_ZNK3fmt2v917basic_string_viewIcE5beginEv:
  462|   295k|  constexpr auto begin() const noexcept -> iterator { return data_; }
_ZNK3fmt2v917basic_string_viewIcE3endEv:
  463|   295k|  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
_ZN3fmt2v96detail10locale_refC2Ev:
 1726|   115k|  constexpr FMT_INLINE locale_ref() : locale_(nullptr) {}
_ZNK3fmt2v919basic_format_stringIcJEEcvNS0_17basic_string_viewIcEEEv:
 2870|  3.73k|  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
_ZN3fmt2v916make_format_argsINS0_20basic_format_contextINS0_8appenderEcEEJEEENS0_16format_arg_storeIT_JDpNSt3__19remove_cvINS7_16remove_referenceIT0_E4typeEE4typeEEEEDpOSA_:
 1920|  3.73k|    -> format_arg_store<Context, remove_cvref_t<T>...> {
 1921|  3.73k|  return {FMT_FORWARD(args)...};
 1922|  3.73k|}
_ZN3fmt2v916format_arg_storeINS0_20basic_format_contextINS0_8appenderEcEEJEEC2IJEEEDpOT_:
 1905|  3.73k|            FMT_FORWARD(args))...} {
 1906|  3.73k|    detail::init_named_args(data_.named_args(), 0, 0, args...);
 1907|  3.73k|  }
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EEC2IJEEEDpRKT_:
 1187|  3.73k|  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1281|   183k|  constexpr FMT_INLINE value() : no_value() {}
_ZN3fmt2v99monostateC2Ev:
  311|   183k|  constexpr monostate() {}
_ZN3fmt2v96detail15init_named_argsIJEEEvDniiDpRKT_:
 1220|  3.73k|                                              const Args&...) {}
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EE10named_argsEv:
 1189|  3.73k|  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
 1190|  3.73k|    return nullptr;
 1191|  3.73k|  }
_ZN3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEC2IJEEERKNS0_16format_arg_storeIS4_JDpT_EEE:
 2003|  3.73k|                          store.data_.args()) {}
_ZNK3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EE4argsEv:
 1188|  3.73k|  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
_ZN3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEC2EyPKNS0_6detail5valueIS4_EE:
 1987|   115k|      : desc_(desc), values_(values) {}
_ZNK3fmt2v917basic_string_viewIcE4dataEv:
  457|   289k|  constexpr auto data() const noexcept -> const Char* { return data_; }
_ZN3fmt2v917basic_string_viewIcEC2EPKcm:
  428|   411k|      : data_(s), size_(count) {}
_ZN3fmt2v96detail13ignore_unusedIJbA18_cEEEvDpRKT_:
  328|  1.74M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt2v96detail11to_unsignedIlEENSt3__113make_unsignedIT_E4typeES5_:
  393|   603k|    typename std::make_unsigned<Int>::type {
  394|   603k|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  352|  1.20M|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (352:37): [Folded - Ignored]
  |  |  |  Branch (352:37): [True: 603k, False: 0]
  |  |  ------------------
  ------------------
  395|   603k|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  396|   603k|}
_ZN3fmt2v96detail6bufferIcE11try_reserveEm:
  939|   408k|  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
  940|   408k|    if (new_capacity > capacity_) grow(new_capacity);
  ------------------
  |  Branch (940:9): [True: 0, False: 408k]
  ------------------
  941|   408k|  }
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE3getEi:
 2025|   180k|  FMT_CONSTEXPR auto get(int id) const -> format_arg {
 2026|   180k|    format_arg arg;
 2027|   180k|    if (!is_packed()) {
  ------------------
  |  Branch (2027:9): [True: 0, False: 180k]
  ------------------
 2028|      0|      if (id < max_size()) arg = args_[id];
  ------------------
  |  Branch (2028:11): [True: 0, False: 0]
  ------------------
 2029|      0|      return arg;
 2030|      0|    }
 2031|   180k|    if (id >= detail::max_packed_args) return arg;
  ------------------
  |  Branch (2031:9): [True: 0, False: 180k]
  ------------------
 2032|   180k|    arg.type_ = type(id);
 2033|   180k|    if (arg.type_ == detail::type::none_type) return arg;
  ------------------
  |  Branch (2033:9): [True: 0, False: 180k]
  ------------------
 2034|   180k|    arg.value_ = values_[id];
 2035|   180k|    return arg;
 2036|   180k|  }
_ZN3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1614|   180k|  constexpr basic_format_arg() : type_(detail::type::none_type) {}
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE9is_packedEv:
 1972|   180k|  constexpr auto is_packed() const -> bool {
 1973|   180k|    return (desc_ & detail::is_unpacked_bit) == 0;
 1974|   180k|  }
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE4typeEi:
 1979|   180k|  FMT_CONSTEXPR auto type(int index) const -> detail::type {
 1980|   180k|    int shift = index * detail::packed_arg_bits;
 1981|   180k|    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
 1982|   180k|    return static_cast<detail::type>((desc_ >> shift) & mask);
 1983|   180k|  }
_ZNK3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEcvbEv:
 1616|   180k|  constexpr explicit operator bool() const noexcept {
 1617|   180k|    return type_ != detail::type::none_type;
 1618|   180k|  }
_ZN3fmt2v96detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EE:
  842|   479k|    -> Container& {
  843|   479k|  using base = std::back_insert_iterator<Container>;
  844|   479k|  struct accessor : base {
  845|   479k|    accessor(base b) : base(b) {}
  846|   479k|    using base::container;
  847|   479k|  };
  848|   479k|  return *accessor(it).container;
  849|   479k|}
_ZZN3fmt2v96detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EEEN8accessorC2ENS8_IS4_EE:
  845|   479k|    accessor(base b) : base(b) {}
_ZN3fmt2v96detail13ignore_unusedIJbA20_cEEEvDpRKT_:
  328|  58.3k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt2v98appenderppEi:
 1570|  42.1k|  auto operator++(int) noexcept -> appender { return *this; }
_ZN3fmt2v96detail8copy_strIcPcEENS0_8appenderET0_S5_S4_:
 1679|  58.3k|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1680|  58.3k|  get_container(out).append(begin, end);
 1681|  58.3k|  return out;
 1682|  58.3k|}
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEi:
 1374|    853|  FMT_CONSTEXPR FMT_INLINE auto map(int val) -> int { return val; }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ei:
 1282|  2.90k|  constexpr FMT_INLINE value(int val) : int_value(val) {}
_ZNK3fmt2v96detail6fill_tIcE4sizeEv:
 2103|   122k|  constexpr auto size() const -> size_t { return size_; }
_ZNK3fmt2v96detail6fill_tIcE4dataEv:
 2104|    350|  constexpr auto data() const -> const Char* { return data_; }
_ZN3fmt2v96detail8copy_strIcPKcEENS0_8appenderET0_S6_S5_:
 1679|   362k|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1680|   362k|  get_container(out).append(begin, end);
 1681|   362k|  return out;
 1682|   362k|}
_ZN3fmt2v912format_specsIcEC2Ev:
 2154|   180k|        localized(false) {}
_ZN3fmt2v96detail11const_checkIbEET_S3_:
  341|  5.21k|template <typename T> constexpr FMT_INLINE auto const_check(T value) -> T {
  342|  5.21k|  return value;
  343|  5.21k|}
_ZN3fmt2v96detail6fill_tIcEixEm:
 2106|  58.3k|  FMT_CONSTEXPR auto operator[](size_t index) -> Char& { return data_[index]; }
_ZN3fmt2v96detail6bufferIjEC2EPjmm:
  886|  27.9k|      : ptr_(p), size_(sz), capacity_(cap) {}
_ZN3fmt2v96detail6bufferIjE3setEPjm:
  892|  27.9k|  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  893|  27.9k|    ptr_ = buf_data;
  894|  27.9k|    capacity_ = buf_capacity;
  895|  27.9k|  }
_ZNK3fmt2v96detail6bufferIjE8capacityEv:
  917|  15.5k|  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
_ZN3fmt2v96detail6bufferIjE4dataEv:
  920|  46.2k|  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
_ZNK3fmt2v96detail6bufferIjE4sizeEv:
  914|  19.3M|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail6bufferIjEixImEERjT_:
  951|  14.3M|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  952|  14.3M|    return ptr_[index];
  953|  14.3M|  }
_ZN3fmt2v96detail6bufferIjE10try_resizeEm:
  930|  1.80M|  FMT_CONSTEXPR20 void try_resize(size_t count) {
  931|  1.80M|    try_reserve(count);
  932|  1.80M|    size_ = count <= capacity_ ? count : capacity_;
  ------------------
  |  Branch (932:13): [True: 1.80M, False: 0]
  ------------------
  933|  1.80M|  }
_ZN3fmt2v96detail6bufferIjE11try_reserveEm:
  939|  1.85M|  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
  940|  1.85M|    if (new_capacity > capacity_) grow(new_capacity);
  ------------------
  |  Branch (940:9): [True: 0, False: 1.85M]
  ------------------
  941|  1.85M|  }
_ZN3fmt2v96detail6bufferIjE9push_backERKj:
  943|  49.4k|  FMT_CONSTEXPR20 void push_back(const T& value) {
  944|  49.4k|    try_reserve(size_ + 1);
  945|  49.4k|    ptr_[size_++] = value;
  946|  49.4k|  }
_ZN3fmt2v96detail8copy_strIjPjS3_EET1_T0_S5_S4_:
  853|  15.5k|    -> OutputIt {
  854|  52.2k|  while (begin != end) *out++ = static_cast<Char>(*begin++);
  ------------------
  |  Branch (854:10): [True: 36.7k, False: 15.5k]
  ------------------
  855|  15.5k|  return out;
  856|  15.5k|}
_ZN3fmt2v96detail6bufferIjEixIiEERjT_:
  951|   393k|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  952|   393k|    return ptr_[index];
  953|   393k|  }
_ZN3fmt2v96detail6bufferIjEixIjEERjT_:
  951|  65.3M|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  952|  65.3M|    return ptr_[index];
  953|  65.3M|  }
_ZNK3fmt2v96detail6bufferIjE4dataEv:
  923|    704|  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }
_ZNK3fmt2v96detail6bufferIjEixIjEERKjT_:
  955|  7.46M|  FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
  956|  7.46M|    return ptr_[index];
  957|  7.46M|  }
_ZNK3fmt2v96detail6bufferIjEixImEERKjT_:
  955|  32.0M|  FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
  956|  32.0M|    return ptr_[index];
  957|  32.0M|  }
_ZN3fmt2v96detail6bufferIcEixIiEERcT_:
  951|   403k|  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
  952|   403k|    return ptr_[index];
  953|   403k|  }
_ZN3fmt2v926basic_format_parse_contextIcEC2ENS0_17basic_string_viewIcEEi:
  681|   115k|      : format_str_(format_str), next_arg_id_(next_arg_id) {}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcEC2ES2_NS0_17basic_format_argsIS3_EENS0_6detail10locale_refE:
 1823|   115k|      : out_(out), args_(ctx_args), loc_(loc) {}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE3outEv:
 1838|   476k|  FMT_CONSTEXPR auto out() -> iterator { return out_; }
_ZN3fmt2v96detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_:
 2585|   115k|    basic_string_view<Char> format_str, Handler&& handler) {
 2586|       |  // Workaround a name-lookup bug in MSVC's modules implementation.
 2587|   115k|  using detail::find;
 2588|       |
 2589|   115k|  auto begin = format_str.data();
 2590|   115k|  auto end = begin + format_str.size();
 2591|   115k|  if (end - begin < 32) {
  ------------------
  |  Branch (2591:7): [True: 115k, False: 699]
  ------------------
 2592|       |    // Use a simple loop instead of memchr for small strings.
 2593|   115k|    const Char* p = begin;
 2594|  1.14M|    while (p != end) {
  ------------------
  |  Branch (2594:12): [True: 1.02M, False: 115k]
  ------------------
 2595|  1.02M|      auto c = *p++;
 2596|  1.02M|      if (c == '{') {
  ------------------
  |  Branch (2596:11): [True: 178k, False: 846k]
  ------------------
 2597|   178k|        handler.on_text(begin, p - 1);
 2598|   178k|        begin = p = parse_replacement_field(p - 1, end, handler);
 2599|   846k|      } else if (c == '}') {
  ------------------
  |  Branch (2599:18): [True: 0, False: 846k]
  ------------------
 2600|      0|        if (p == end || *p != '}')
  ------------------
  |  Branch (2600:13): [True: 0, False: 0]
  |  Branch (2600:25): [True: 0, False: 0]
  ------------------
 2601|      0|          return handler.on_error("unmatched '}' in format string");
 2602|      0|        handler.on_text(begin, p);
 2603|      0|        begin = ++p;
 2604|      0|      }
 2605|  1.02M|    }
 2606|   115k|    handler.on_text(begin, end);
 2607|   115k|    return;
 2608|   115k|  }
 2609|    699|  struct writer {
 2610|    699|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2611|    699|      if (from == to) return;
 2612|    699|      for (;;) {
 2613|    699|        const Char* p = nullptr;
 2614|    699|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
 2615|    699|          return handler_.on_text(from, to);
 2616|    699|        ++p;
 2617|    699|        if (p == to || *p != '}')
 2618|    699|          return handler_.on_error("unmatched '}' in format string");
 2619|    699|        handler_.on_text(from, p);
 2620|    699|        from = p + 1;
 2621|    699|      }
 2622|    699|    }
 2623|    699|    Handler& handler_;
 2624|    699|  } write = {handler};
 2625|  2.09k|  while (begin != end) {
  ------------------
  |  Branch (2625:10): [True: 2.09k, False: 0]
  ------------------
 2626|       |    // Doing two passes with memchr (one for '{' and another for '}') is up to
 2627|       |    // 2.5x faster than the naive one-pass implementation on big format strings.
 2628|  2.09k|    const Char* p = begin;
 2629|  2.09k|    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
  ------------------
  |  Branch (2629:9): [True: 2.09k, False: 0]
  |  Branch (2629:26): [True: 699, False: 1.39k]
  ------------------
 2630|    699|      return write(begin, end);
 2631|  1.39k|    write(begin, p);
 2632|  1.39k|    begin = parse_replacement_field(p, end, handler);
 2633|  1.39k|  }
 2634|    699|}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE10advance_toES2_:
 1841|   476k|  void advance_to(iterator it) {
 1842|   476k|    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
  ------------------
  |  Branch (1842:9): [Folded - Ignored]
  ------------------
 1843|   476k|  }
_ZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_:
 2548|   180k|                                           Handler&& handler) -> const Char* {
 2549|   180k|  struct id_adapter {
 2550|   180k|    Handler& handler;
 2551|   180k|    int arg_id;
 2552|       |
 2553|   180k|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
 2554|   180k|    FMT_CONSTEXPR void on_index(int id) { arg_id = handler.on_arg_id(id); }
 2555|   180k|    FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
 2556|   180k|      arg_id = handler.on_arg_id(id);
 2557|   180k|    }
 2558|   180k|  };
 2559|       |
 2560|   180k|  ++begin;
 2561|   180k|  if (begin == end) return handler.on_error("invalid format string"), end;
  ------------------
  |  Branch (2561:7): [True: 0, False: 180k]
  ------------------
 2562|   180k|  if (*begin == '}') {
  ------------------
  |  Branch (2562:7): [True: 0, False: 180k]
  ------------------
 2563|      0|    handler.on_replacement_field(handler.on_arg_id(), begin);
 2564|   180k|  } else if (*begin == '{') {
  ------------------
  |  Branch (2564:14): [True: 0, False: 180k]
  ------------------
 2565|      0|    handler.on_text(begin, begin + 1);
 2566|   180k|  } else {
 2567|   180k|    auto adapter = id_adapter{handler, 0};
 2568|   180k|    begin = parse_arg_id(begin, end, adapter);
 2569|   180k|    Char c = begin != end ? *begin : Char();
  ------------------
  |  Branch (2569:14): [True: 180k, False: 0]
  ------------------
 2570|   180k|    if (c == '}') {
  ------------------
  |  Branch (2570:9): [True: 0, False: 180k]
  ------------------
 2571|      0|      handler.on_replacement_field(adapter.arg_id, begin);
 2572|   180k|    } else if (c == ':') {
  ------------------
  |  Branch (2572:16): [True: 180k, False: 0]
  ------------------
 2573|   180k|      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
 2574|   180k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (2574:11): [True: 0, False: 180k]
  |  Branch (2574:27): [True: 0, False: 180k]
  ------------------
 2575|      0|        return handler.on_error("unknown format specifier"), end;
 2576|   180k|    } else {
 2577|      0|      return handler.on_error("missing '}' in format string"), end;
 2578|      0|    }
 2579|   180k|  }
 2580|   180k|  return begin + 1;
 2581|   180k|}
_ZNK3fmt2v920basic_format_contextINS0_8appenderEcE3argEi:
 1825|   180k|  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE6localeEv:
 1845|   180k|  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
_ZN3fmt2v926basic_format_parse_contextIcE11next_arg_idEv:
  705|  63.5k|  FMT_CONSTEXPR auto next_arg_id() -> int {
  706|  63.5k|    if (next_arg_id_ < 0) {
  ------------------
  |  Branch (706:9): [True: 0, False: 63.5k]
  ------------------
  707|      0|      detail::throw_format_error(
  708|      0|          "cannot switch from manual to automatic argument indexing");
  709|      0|      return 0;
  710|      0|    }
  711|  63.5k|    int id = next_arg_id_++;
  712|  63.5k|    do_check_arg_id(id);
  713|  63.5k|    return id;
  714|  63.5k|  }
_ZN3fmt2v926basic_format_parse_contextIcE15do_check_arg_idEi:
  776|   180k|FMT_CONSTEXPR void basic_format_parse_context<Char>::do_check_arg_id(int id) {
  777|       |  // Argument id is only checked at compile-time during parsing because
  778|       |  // formatting has its own validation.
  779|   180k|  if (detail::is_constant_evaluated() &&
  ------------------
  |  Branch (779:7): [Folded - Ignored]
  ------------------
  780|   180k|      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   32|      0|#  define FMT_GCC_VERSION 0
  ------------------
                    (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   32|      0|#  define FMT_GCC_VERSION 0
  ------------------
  |  Branch (780:8): [Folded - Ignored]
  |  Branch (780:28): [Folded - Ignored]
  ------------------
  781|      0|    using context = detail::compile_parse_context<Char>;
  782|      0|    if (id >= static_cast<context*>(this)->num_args())
  ------------------
  |  Branch (782:9): [True: 0, False: 0]
  ------------------
  783|      0|      detail::throw_format_error("argument not found");
  784|      0|  }
  785|   180k|}
_ZN3fmt2v96detail12parse_arg_idIcRZNS1_23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS6_EENS1_12vformat_argsIS6_E4typeENS1_10locale_refEE14format_handlerEEPKS6_SI_SI_OT0_E10id_adapterEESI_SI_SI_SK_:
 2314|   180k|                                           Handler&& handler) -> const Char* {
 2315|   180k|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  352|   180k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2316|   180k|  Char c = *begin;
 2317|   180k|  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
  ------------------
  |  Branch (2317:7): [True: 180k, False: 0]
  |  Branch (2317:19): [True: 116k, False: 63.5k]
  ------------------
 2318|  63.5k|  handler.on_auto();
 2319|  63.5k|  return begin;
 2320|   180k|}
_ZN3fmt2v96detail15do_parse_arg_idIcRZNS1_23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS6_EENS1_12vformat_argsIS6_E4typeENS1_10locale_refEE14format_handlerEEPKS6_SI_SI_OT0_E10id_adapterEESI_SI_SI_SK_:
 2285|   116k|                                   Handler&& handler) -> const Char* {
 2286|   116k|  Char c = *begin;
 2287|   116k|  if (c >= '0' && c <= '9') {
  ------------------
  |  Branch (2287:7): [True: 116k, False: 0]
  |  Branch (2287:19): [True: 116k, False: 0]
  ------------------
 2288|   116k|    int index = 0;
 2289|   116k|    constexpr int max = (std::numeric_limits<int>::max)();
 2290|   116k|    if (c != '0')
  ------------------
  |  Branch (2290:9): [True: 58.3k, False: 58.3k]
  ------------------
 2291|  58.3k|      index = parse_nonnegative_int(begin, end, max);
 2292|  58.3k|    else
 2293|  58.3k|      ++begin;
 2294|   116k|    if (begin == end || (*begin != '}' && *begin != ':'))
  ------------------
  |  Branch (2294:9): [True: 0, False: 116k]
  |  Branch (2294:26): [True: 116k, False: 0]
  |  Branch (2294:43): [True: 0, False: 116k]
  ------------------
 2295|      0|      throw_format_error("invalid format string");
 2296|   116k|    else
 2297|   116k|      handler.on_index(index);
 2298|   116k|    return begin;
 2299|   116k|  }
 2300|      0|  if (!is_name_start(c)) {
  ------------------
  |  Branch (2300:7): [True: 0, False: 0]
  ------------------
 2301|      0|    throw_format_error("invalid format string");
 2302|      0|    return begin;
 2303|      0|  }
 2304|      0|  auto it = begin;
 2305|      0|  do {
 2306|      0|    ++it;
 2307|      0|  } while (it != end && (is_name_start(*it) || ('0' <= *it && *it <= '9')));
  ------------------
  |  Branch (2307:12): [True: 0, False: 0]
  |  Branch (2307:26): [True: 0, False: 0]
  |  Branch (2307:49): [True: 0, False: 0]
  |  Branch (2307:63): [True: 0, False: 0]
  ------------------
 2308|      0|  handler.on_name({begin, to_unsigned(it - begin)});
 2309|      0|  return it;
 2310|      0|}
_ZN3fmt2v96detail21parse_nonnegative_intIcEEiRPKT_S5_i:
 2246|   116k|                                         int error_value) noexcept -> int {
 2247|   116k|  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
  ------------------
  |  |  352|   466k|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (352:37): [True: 116k, False: 0]
  |  |  |  Branch (352:37): [True: 116k, False: 0]
  |  |  |  Branch (352:37): [True: 116k, False: 0]
  |  |  ------------------
  ------------------
 2248|   116k|  unsigned value = 0, prev = 0;
 2249|   116k|  auto p = begin;
 2250|   116k|  do {
 2251|   116k|    prev = value;
 2252|   116k|    value = value * 10 + unsigned(*p - '0');
 2253|   116k|    ++p;
 2254|   116k|  } while (p != end && '0' <= *p && *p <= '9');
  ------------------
  |  Branch (2254:12): [True: 116k, False: 0]
  |  Branch (2254:24): [True: 116k, False: 0]
  |  Branch (2254:37): [True: 0, False: 116k]
  ------------------
 2255|   116k|  auto num_digits = p - begin;
 2256|   116k|  begin = p;
 2257|   116k|  if (num_digits <= std::numeric_limits<int>::digits10)
  ------------------
  |  Branch (2257:7): [True: 116k, False: 0]
  ------------------
 2258|   116k|    return static_cast<int>(value);
 2259|       |  // Check for overflow.
 2260|      0|  const unsigned max = to_unsigned((std::numeric_limits<int>::max)());
 2261|      0|  return num_digits == std::numeric_limits<int>::digits10 + 1 &&
  ------------------
  |  Branch (2261:10): [True: 0, False: 0]
  ------------------
 2262|      0|                 prev * 10ull + unsigned(p[-1] - '0') <= max
  ------------------
  |  Branch (2262:18): [True: 0, False: 0]
  ------------------
 2263|      0|             ? static_cast<int>(value)
 2264|      0|             : error_value;
 2265|   116k|}
_ZZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_EN10id_adapter8on_indexEi:
 2554|   116k|    FMT_CONSTEXPR void on_index(int id) { arg_id = handler.on_arg_id(id); }
_ZN3fmt2v926basic_format_parse_contextIcE12check_arg_idEi:
  720|   116k|  FMT_CONSTEXPR void check_arg_id(int id) {
  721|   116k|    if (next_arg_id_ > 0) {
  ------------------
  |  Branch (721:9): [True: 0, False: 116k]
  ------------------
  722|      0|      detail::throw_format_error(
  723|      0|          "cannot switch from automatic to manual argument indexing");
  724|      0|      return;
  725|      0|    }
  726|   116k|    next_arg_id_ = -1;
  727|   116k|    do_check_arg_id(id);
  728|   116k|  }
_ZZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_EN10id_adapter7on_autoEv:
 2553|  63.5k|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
_ZNK3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEE4typeEv:
 1620|   360k|  auto type() const -> detail::type { return type_; }
_ZN3fmt2v96detail7arg_refIcEC2Ev:
 2163|   360k|  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
_ZN3fmt2v96detail7arg_refIcE5valueC2Ei:
 2178|   360k|    FMT_CONSTEXPR value(int idx = 0) : index(idx) {}
_ZN3fmt2v96detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeE:
 2430|   180k|    basic_format_parse_context<Char>& ctx, type arg_type) -> const Char* {
 2431|   180k|  auto c = '\0';
 2432|   180k|  if (end - begin > 1) {
  ------------------
  |  Branch (2432:7): [True: 180k, False: 0]
  ------------------
 2433|   180k|    auto next = to_ascii(begin[1]);
 2434|   180k|    c = parse_align(next) == align::none ? to_ascii(*begin) : '\0';
  ------------------
  |  Branch (2434:9): [True: 180k, False: 0]
  ------------------
 2435|   180k|  } else {
 2436|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2436:9): [True: 0, False: 0]
  ------------------
 2437|      0|    c = to_ascii(*begin);
 2438|      0|  }
 2439|   180k|  struct {
 2440|   180k|    state current_state = state::start;
 2441|   180k|    FMT_CONSTEXPR void operator()(state s, bool valid = true) {
 2442|   180k|      if (current_state >= s || !valid)
 2443|   180k|        throw_format_error("invalid format specifier");
 2444|   180k|      current_state = s;
 2445|   180k|    }
 2446|   180k|  } enter_state;
 2447|   296k|  for (;;) {
 2448|   296k|    switch (c) {
 2449|      0|    case '<':
  ------------------
  |  Branch (2449:5): [True: 0, False: 296k]
  ------------------
 2450|      0|    case '>':
  ------------------
  |  Branch (2450:5): [True: 0, False: 296k]
  ------------------
 2451|      0|    case '^':
  ------------------
  |  Branch (2451:5): [True: 0, False: 296k]
  ------------------
 2452|      0|      enter_state(state::align);
 2453|      0|      specs.align = parse_align(c);
 2454|      0|      ++begin;
 2455|      0|      break;
 2456|      0|    case '+':
  ------------------
  |  Branch (2456:5): [True: 0, False: 296k]
  ------------------
 2457|      0|    case '-':
  ------------------
  |  Branch (2457:5): [True: 0, False: 296k]
  ------------------
 2458|      0|    case ' ':
  ------------------
  |  Branch (2458:5): [True: 0, False: 296k]
  ------------------
 2459|      0|      enter_state(state::sign, in(arg_type, sint_set | float_set));
 2460|      0|      switch (c) {
  ------------------
  |  Branch (2460:15): [True: 0, False: 0]
  ------------------
 2461|      0|      case '+':
  ------------------
  |  Branch (2461:7): [True: 0, False: 0]
  ------------------
 2462|      0|        specs.sign = sign::plus;
 2463|      0|        break;
 2464|      0|      case '-':
  ------------------
  |  Branch (2464:7): [True: 0, False: 0]
  ------------------
 2465|      0|        specs.sign = sign::minus;
 2466|      0|        break;
 2467|      0|      case ' ':
  ------------------
  |  Branch (2467:7): [True: 0, False: 0]
  ------------------
 2468|      0|        specs.sign = sign::space;
 2469|      0|        break;
 2470|      0|      }
 2471|      0|      ++begin;
 2472|      0|      break;
 2473|      0|    case '#':
  ------------------
  |  Branch (2473:5): [True: 0, False: 296k]
  ------------------
 2474|      0|      enter_state(state::hash, is_arithmetic_type(arg_type));
 2475|      0|      specs.alt = true;
 2476|      0|      ++begin;
 2477|      0|      break;
 2478|  58.3k|    case '0':
  ------------------
  |  Branch (2478:5): [True: 58.3k, False: 238k]
  ------------------
 2479|  58.3k|      enter_state(state::zero);
 2480|  58.3k|      if (!is_arithmetic_type(arg_type))
  ------------------
  |  Branch (2480:11): [True: 0, False: 58.3k]
  ------------------
 2481|      0|        throw_format_error("format specifier requires numeric argument");
 2482|  58.3k|      if (specs.align == align::none) {
  ------------------
  |  Branch (2482:11): [True: 58.3k, False: 0]
  ------------------
 2483|       |        // Ignore 0 if align is specified for compatibility with std::format.
 2484|  58.3k|        specs.align = align::numeric;
 2485|  58.3k|        specs.fill[0] = Char('0');
 2486|  58.3k|      }
 2487|  58.3k|      ++begin;
 2488|  58.3k|      break;
 2489|      0|    case '1':
  ------------------
  |  Branch (2489:5): [True: 0, False: 296k]
  ------------------
 2490|  58.3k|    case '2':
  ------------------
  |  Branch (2490:5): [True: 58.3k, False: 238k]
  ------------------
 2491|  58.3k|    case '3':
  ------------------
  |  Branch (2491:5): [True: 0, False: 296k]
  ------------------
 2492|  58.3k|    case '4':
  ------------------
  |  Branch (2492:5): [True: 0, False: 296k]
  ------------------
 2493|  58.3k|    case '5':
  ------------------
  |  Branch (2493:5): [True: 0, False: 296k]
  ------------------
 2494|  58.3k|    case '6':
  ------------------
  |  Branch (2494:5): [True: 0, False: 296k]
  ------------------
 2495|  58.3k|    case '7':
  ------------------
  |  Branch (2495:5): [True: 0, False: 296k]
  ------------------
 2496|  58.3k|    case '8':
  ------------------
  |  Branch (2496:5): [True: 0, False: 296k]
  ------------------
 2497|  58.3k|    case '9':
  ------------------
  |  Branch (2497:5): [True: 0, False: 296k]
  ------------------
 2498|  58.3k|    case '{':
  ------------------
  |  Branch (2498:5): [True: 0, False: 296k]
  ------------------
 2499|  58.3k|      enter_state(state::width);
 2500|  58.3k|      begin = parse_dynamic_spec(begin, end, specs.width, specs.width_ref, ctx);
 2501|  58.3k|      break;
 2502|      0|    case '.':
  ------------------
  |  Branch (2502:5): [True: 0, False: 296k]
  ------------------
 2503|      0|      enter_state(state::precision,
 2504|      0|                  in(arg_type, float_set | string_set | cstring_set));
 2505|      0|      begin = parse_precision(begin, end, specs.precision, specs.precision_ref,
 2506|      0|                              ctx);
 2507|      0|      break;
 2508|      0|    case 'L':
  ------------------
  |  Branch (2508:5): [True: 0, False: 296k]
  ------------------
 2509|      0|      enter_state(state::locale, is_arithmetic_type(arg_type));
 2510|      0|      specs.localized = true;
 2511|      0|      ++begin;
 2512|      0|      break;
 2513|      0|    case '}':
  ------------------
  |  Branch (2513:5): [True: 0, False: 296k]
  ------------------
 2514|      0|      return begin;
 2515|   180k|    default: {
  ------------------
  |  Branch (2515:5): [True: 180k, False: 116k]
  ------------------
 2516|   180k|      if (is_ascii_letter(c) || c == '?') {
  ------------------
  |  Branch (2516:11): [True: 180k, False: 0]
  |  Branch (2516:33): [True: 0, False: 0]
  ------------------
 2517|   180k|        auto type = parse_presentation_type(c, arg_type);
 2518|   180k|        if (type == presentation_type::none)
  ------------------
  |  Branch (2518:13): [True: 0, False: 180k]
  ------------------
 2519|      0|          throw_format_error("invalid format specifier");
 2520|   180k|        specs.type = type;
 2521|   180k|        return begin + 1;
 2522|   180k|      }
 2523|      0|      if (*begin == '}') return begin;
  ------------------
  |  Branch (2523:11): [True: 0, False: 0]
  ------------------
 2524|       |      // Parse fill and alignment.
 2525|      0|      auto fill_end = begin + code_point_length(begin);
 2526|      0|      if (end - fill_end <= 0) {
  ------------------
  |  Branch (2526:11): [True: 0, False: 0]
  ------------------
 2527|      0|        throw_format_error("invalid format specifier");
 2528|      0|        return begin;
 2529|      0|      }
 2530|      0|      if (*begin == '{') {
  ------------------
  |  Branch (2530:11): [True: 0, False: 0]
  ------------------
 2531|      0|        throw_format_error("invalid fill character '{'");
 2532|      0|        return begin;
 2533|      0|      }
 2534|      0|      auto align = parse_align(to_ascii(*fill_end));
 2535|      0|      enter_state(state::align, align != align::none);
 2536|      0|      specs.fill = {begin, to_unsigned(fill_end - begin)};
 2537|      0|      specs.align = align;
 2538|      0|      begin = fill_end + 1;
 2539|      0|    }
 2540|   296k|    }
 2541|   116k|    if (begin == end) return begin;
  ------------------
  |  Branch (2541:9): [True: 0, False: 116k]
  ------------------
 2542|   116k|    c = to_ascii(*begin);
 2543|   116k|  }
 2544|   180k|}
_ZN3fmt2v96detail8to_asciiIcLi0EEEcT_:
 2201|   476k|constexpr auto to_ascii(Char c) -> char {
 2202|   476k|  return c <= 0xff ? static_cast<char>(c) : '\0';
  ------------------
  |  Branch (2202:10): [True: 476k, False: 0]
  ------------------
 2203|   476k|}
_ZN3fmt2v96detail11parse_alignEc:
 2267|   180k|FMT_CONSTEXPR inline auto parse_align(char c) -> align_t {
 2268|   180k|  switch (c) {
  ------------------
  |  Branch (2268:11): [True: 180k, False: 0]
  ------------------
 2269|      0|  case '<':
  ------------------
  |  Branch (2269:3): [True: 0, False: 180k]
  ------------------
 2270|      0|    return align::left;
 2271|      0|  case '>':
  ------------------
  |  Branch (2271:3): [True: 0, False: 180k]
  ------------------
 2272|      0|    return align::right;
 2273|      0|  case '^':
  ------------------
  |  Branch (2273:3): [True: 0, False: 180k]
  ------------------
 2274|      0|    return align::center;
 2275|   180k|  }
 2276|   180k|  return align::none;
 2277|   180k|}
_ZZN3fmt2v96detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeEENUt_clENS1_5stateEb:
 2441|   116k|    FMT_CONSTEXPR void operator()(state s, bool valid = true) {
 2442|   116k|      if (current_state >= s || !valid)
  ------------------
  |  Branch (2442:11): [True: 0, False: 116k]
  |  Branch (2442:33): [True: 0, False: 116k]
  ------------------
 2443|      0|        throw_format_error("invalid format specifier");
 2444|   116k|      current_state = s;
 2445|   116k|    }
_ZN3fmt2v96detail2inENS1_4typeEi:
  627|   180k|constexpr auto in(type t, int set) -> bool {
  628|   180k|  return ((set >> static_cast<int>(t)) & 1) != 0;
  629|   180k|}
_ZN3fmt2v96detail18is_arithmetic_typeENS1_4typeE:
  622|  58.3k|constexpr bool is_arithmetic_type(type t) {
  623|  58.3k|  return t > type::none_type && t <= type::last_numeric_type;
  ------------------
  |  Branch (623:10): [True: 58.3k, False: 0]
  |  Branch (623:33): [True: 58.3k, False: 0]
  ------------------
  624|  58.3k|}
_ZN3fmt2v96detail18parse_dynamic_specIcEEPKT_S5_S5_RiRNS1_7arg_refIS3_EERNS0_26basic_format_parse_contextIS3_EE:
 2347|  58.3k|    -> const Char* {
 2348|  58.3k|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  352|  58.3k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2349|  58.3k|  if ('0' <= *begin && *begin <= '9') {
  ------------------
  |  Branch (2349:7): [True: 58.3k, False: 0]
  |  Branch (2349:24): [True: 58.3k, False: 0]
  ------------------
 2350|  58.3k|    int val = parse_nonnegative_int(begin, end, -1);
 2351|  58.3k|    if (val != -1)
  ------------------
  |  Branch (2351:9): [True: 58.3k, False: 0]
  ------------------
 2352|  58.3k|      value = val;
 2353|      0|    else
 2354|      0|      throw_format_error("number is too big");
 2355|  58.3k|  } else if (*begin == '{') {
  ------------------
  |  Branch (2355:14): [True: 0, False: 0]
  ------------------
 2356|      0|    ++begin;
 2357|      0|    auto handler = dynamic_spec_id_handler<Char>{ctx, ref};
 2358|      0|    if (begin != end) begin = parse_arg_id(begin, end, handler);
  ------------------
  |  Branch (2358:9): [True: 0, False: 0]
  ------------------
 2359|      0|    if (begin != end && *begin == '}') return ++begin;
  ------------------
  |  Branch (2359:9): [True: 0, False: 0]
  |  Branch (2359:25): [True: 0, False: 0]
  ------------------
 2360|      0|    throw_format_error("invalid format string");
 2361|      0|  }
 2362|  58.3k|  return begin;
 2363|  58.3k|}
_ZN3fmt2v96detail15is_ascii_letterIcEEbT_:
 2195|   180k|template <typename Char> constexpr bool is_ascii_letter(Char c) {
 2196|   180k|  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
  ------------------
  |  Branch (2196:11): [True: 121k, False: 58.3k]
  |  Branch (2196:23): [True: 121k, False: 0]
  |  Branch (2196:37): [True: 58.3k, False: 0]
  |  Branch (2196:49): [True: 58.3k, False: 0]
  ------------------
 2197|   180k|}
_ZN3fmt2v96detail23parse_presentation_typeEcNS1_4typeE:
 2379|   180k|    -> presentation_type {
 2380|   180k|  using pt = presentation_type;
 2381|   180k|  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
 2382|   180k|  switch (c) {
 2383|  58.3k|  case 'd':
  ------------------
  |  Branch (2383:3): [True: 58.3k, False: 121k]
  ------------------
 2384|  58.3k|    return in(t, integral_set) ? pt::dec : pt::none;
  ------------------
  |  Branch (2384:12): [True: 58.3k, False: 0]
  ------------------
 2385|      0|  case 'o':
  ------------------
  |  Branch (2385:3): [True: 0, False: 180k]
  ------------------
 2386|      0|    return in(t, integral_set) ? pt::oct : pt::none;
  ------------------
  |  Branch (2386:12): [True: 0, False: 0]
  ------------------
 2387|      0|  case 'x':
  ------------------
  |  Branch (2387:3): [True: 0, False: 180k]
  ------------------
 2388|      0|    return in(t, integral_set) ? pt::hex_lower : pt::none;
  ------------------
  |  Branch (2388:12): [True: 0, False: 0]
  ------------------
 2389|  58.3k|  case 'X':
  ------------------
  |  Branch (2389:3): [True: 58.3k, False: 121k]
  ------------------
 2390|  58.3k|    return in(t, integral_set) ? pt::hex_upper : pt::none;
  ------------------
  |  Branch (2390:12): [True: 58.3k, False: 0]
  ------------------
 2391|      0|  case 'b':
  ------------------
  |  Branch (2391:3): [True: 0, False: 180k]
  ------------------
 2392|      0|    return in(t, integral_set) ? pt::bin_lower : pt::none;
  ------------------
  |  Branch (2392:12): [True: 0, False: 0]
  ------------------
 2393|      0|  case 'B':
  ------------------
  |  Branch (2393:3): [True: 0, False: 180k]
  ------------------
 2394|      0|    return in(t, integral_set) ? pt::bin_upper : pt::none;
  ------------------
  |  Branch (2394:12): [True: 0, False: 0]
  ------------------
 2395|      0|  case 'a':
  ------------------
  |  Branch (2395:3): [True: 0, False: 180k]
  ------------------
 2396|      0|    return in(t, float_set) ? pt::hexfloat_lower : pt::none;
  ------------------
  |  Branch (2396:12): [True: 0, False: 0]
  ------------------
 2397|      0|  case 'A':
  ------------------
  |  Branch (2397:3): [True: 0, False: 180k]
  ------------------
 2398|      0|    return in(t, float_set) ? pt::hexfloat_upper : pt::none;
  ------------------
  |  Branch (2398:12): [True: 0, False: 0]
  ------------------
 2399|      0|  case 'e':
  ------------------
  |  Branch (2399:3): [True: 0, False: 180k]
  ------------------
 2400|      0|    return in(t, float_set) ? pt::exp_lower : pt::none;
  ------------------
  |  Branch (2400:12): [True: 0, False: 0]
  ------------------
 2401|      0|  case 'E':
  ------------------
  |  Branch (2401:3): [True: 0, False: 180k]
  ------------------
 2402|      0|    return in(t, float_set) ? pt::exp_upper : pt::none;
  ------------------
  |  Branch (2402:12): [True: 0, False: 0]
  ------------------
 2403|  5.21k|  case 'f':
  ------------------
  |  Branch (2403:3): [True: 5.21k, False: 174k]
  ------------------
 2404|  5.21k|    return in(t, float_set) ? pt::fixed_lower : pt::none;
  ------------------
  |  Branch (2404:12): [True: 5.21k, False: 0]
  ------------------
 2405|      0|  case 'F':
  ------------------
  |  Branch (2405:3): [True: 0, False: 180k]
  ------------------
 2406|      0|    return in(t, float_set) ? pt::fixed_upper : pt::none;
  ------------------
  |  Branch (2406:12): [True: 0, False: 0]
  ------------------
 2407|      0|  case 'g':
  ------------------
  |  Branch (2407:3): [True: 0, False: 180k]
  ------------------
 2408|      0|    return in(t, float_set) ? pt::general_lower : pt::none;
  ------------------
  |  Branch (2408:12): [True: 0, False: 0]
  ------------------
 2409|      0|  case 'G':
  ------------------
  |  Branch (2409:3): [True: 0, False: 180k]
  ------------------
 2410|      0|    return in(t, float_set) ? pt::general_upper : pt::none;
  ------------------
  |  Branch (2410:12): [True: 0, False: 0]
  ------------------
 2411|      0|  case 'c':
  ------------------
  |  Branch (2411:3): [True: 0, False: 180k]
  ------------------
 2412|      0|    return in(t, integral_set) ? pt::chr : pt::none;
  ------------------
  |  Branch (2412:12): [True: 0, False: 0]
  ------------------
 2413|  58.3k|  case 's':
  ------------------
  |  Branch (2413:3): [True: 58.3k, False: 121k]
  ------------------
 2414|  58.3k|    return in(t, bool_set | string_set | cstring_set) ? pt::string : pt::none;
  ------------------
  |  Branch (2414:12): [True: 58.3k, False: 0]
  ------------------
 2415|      0|  case 'p':
  ------------------
  |  Branch (2415:3): [True: 0, False: 180k]
  ------------------
 2416|      0|    return in(t, pointer_set | cstring_set) ? pt::pointer : pt::none;
  ------------------
  |  Branch (2416:12): [True: 0, False: 0]
  ------------------
 2417|      0|  case '?':
  ------------------
  |  Branch (2417:3): [True: 0, False: 180k]
  ------------------
 2418|      0|    return in(t, char_set | string_set | cstring_set) ? pt::debug : pt::none;
  ------------------
  |  Branch (2418:12): [True: 0, False: 0]
  ------------------
 2419|      0|  default:
  ------------------
  |  Branch (2419:3): [True: 0, False: 180k]
  ------------------
 2420|      0|    return pt::none;
 2421|   180k|  }
 2422|   180k|}
_ZN3fmt2v916visit_format_argIRNS0_6detail13arg_formatterIcEENS0_20basic_format_contextINS0_8appenderEcEEEEDTclfp_Li0EEEOT_RKNS0_16basic_format_argIT0_EE:
 1637|   180k|    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
 1638|   180k|  switch (arg.type_) {
  ------------------
  |  Branch (1638:11): [True: 0, False: 180k]
  ------------------
 1639|      0|  case detail::type::none_type:
  ------------------
  |  Branch (1639:3): [True: 0, False: 180k]
  ------------------
 1640|      0|    break;
 1641|  2.90k|  case detail::type::int_type:
  ------------------
  |  Branch (1641:3): [True: 2.90k, False: 177k]
  ------------------
 1642|  2.90k|    return vis(arg.value_.int_value);
 1643|  4.76k|  case detail::type::uint_type:
  ------------------
  |  Branch (1643:3): [True: 4.76k, False: 175k]
  ------------------
 1644|  4.76k|    return vis(arg.value_.uint_value);
 1645|      0|  case detail::type::long_long_type:
  ------------------
  |  Branch (1645:3): [True: 0, False: 180k]
  ------------------
 1646|      0|    return vis(arg.value_.long_long_value);
 1647|   108k|  case detail::type::ulong_long_type:
  ------------------
  |  Branch (1647:3): [True: 108k, False: 71.1k]
  ------------------
 1648|   108k|    return vis(arg.value_.ulong_long_value);
 1649|      0|  case detail::type::int128_type:
  ------------------
  |  Branch (1649:3): [True: 0, False: 180k]
  ------------------
 1650|      0|    return vis(detail::convert_for_visit(arg.value_.int128_value));
 1651|      0|  case detail::type::uint128_type:
  ------------------
  |  Branch (1651:3): [True: 0, False: 180k]
  ------------------
 1652|      0|    return vis(detail::convert_for_visit(arg.value_.uint128_value));
 1653|      0|  case detail::type::bool_type:
  ------------------
  |  Branch (1653:3): [True: 0, False: 180k]
  ------------------
 1654|      0|    return vis(arg.value_.bool_value);
 1655|      0|  case detail::type::char_type:
  ------------------
  |  Branch (1655:3): [True: 0, False: 180k]
  ------------------
 1656|      0|    return vis(arg.value_.char_value);
 1657|  1.99k|  case detail::type::float_type:
  ------------------
  |  Branch (1657:3): [True: 1.99k, False: 178k]
  ------------------
 1658|  1.99k|    return vis(arg.value_.float_value);
 1659|  3.22k|  case detail::type::double_type:
  ------------------
  |  Branch (1659:3): [True: 3.22k, False: 176k]
  ------------------
 1660|  3.22k|    return vis(arg.value_.double_value);
 1661|      0|  case detail::type::long_double_type:
  ------------------
  |  Branch (1661:3): [True: 0, False: 180k]
  ------------------
 1662|      0|    return vis(arg.value_.long_double_value);
 1663|      0|  case detail::type::cstring_type:
  ------------------
  |  Branch (1663:3): [True: 0, False: 180k]
  ------------------
 1664|      0|    return vis(arg.value_.string.data);
 1665|  58.3k|  case detail::type::string_type:
  ------------------
  |  Branch (1665:3): [True: 58.3k, False: 121k]
  ------------------
 1666|  58.3k|    using sv = basic_string_view<typename Context::char_type>;
 1667|  58.3k|    return vis(sv(arg.value_.string.data, arg.value_.string.size));
 1668|      0|  case detail::type::pointer_type:
  ------------------
  |  Branch (1668:3): [True: 0, False: 180k]
  ------------------
 1669|      0|    return vis(arg.value_.pointer);
 1670|      0|  case detail::type::custom_type:
  ------------------
  |  Branch (1670:3): [True: 0, False: 180k]
  ------------------
 1671|      0|    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
 1672|   180k|  }
 1673|      0|  return vis(monostate());
 1674|   180k|}
_ZN3fmt2v96detail10make_valueINS0_20basic_format_contextINS0_8appenderEcEERjEENS1_5valueIT_EEOT0_:
 1745|  1.07k|FMT_CONSTEXPR FMT_INLINE auto make_value(T&& val) -> value<Context> {
 1746|  1.07k|  const auto& arg = arg_mapper<Context>().map(FMT_FORWARD(val));
  ------------------
  |  |  201|  1.07k|#define FMT_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
  ------------------
 1747|       |
 1748|  1.07k|  constexpr bool formattable_char =
 1749|  1.07k|      !std::is_same<decltype(arg), const unformattable_char&>::value;
 1750|  1.07k|  static_assert(formattable_char, "Mixing character types is disallowed.");
 1751|       |
 1752|  1.07k|  constexpr bool formattable_const =
 1753|  1.07k|      !std::is_same<decltype(arg), const unformattable_const&>::value;
 1754|  1.07k|  static_assert(formattable_const, "Cannot format a const argument.");
 1755|       |
 1756|       |  // Formatting of arbitrary pointers is disallowed. If you want to format a
 1757|       |  // pointer cast it to `void*` or `const void*`. In particular, this forbids
 1758|       |  // formatting of `[const] volatile char*` printed as bool by iostreams.
 1759|  1.07k|  constexpr bool formattable_pointer =
 1760|  1.07k|      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
 1761|  1.07k|  static_assert(formattable_pointer,
 1762|  1.07k|                "Formatting of non-void pointers is disallowed.");
 1763|       |
 1764|  1.07k|  constexpr bool formattable =
 1765|  1.07k|      !std::is_same<decltype(arg), const unformattable&>::value;
 1766|  1.07k|  static_assert(
 1767|  1.07k|      formattable,
 1768|  1.07k|      "Cannot format an argument. To make type T formattable provide a "
 1769|  1.07k|      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
 1770|  1.07k|  return {arg};
 1771|  1.07k|}
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEj:
 1375|  1.30k|  FMT_CONSTEXPR FMT_INLINE auto map(unsigned val) -> unsigned { return val; }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ej:
 1283|  4.76k|  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ey:
 1285|   108k|  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
_ZN3fmt2v96detail10make_valueINS0_20basic_format_contextINS0_8appenderEcEERhEENS1_5valueIT_EEOT0_:
 1745|    987|FMT_CONSTEXPR FMT_INLINE auto make_value(T&& val) -> value<Context> {
 1746|    987|  const auto& arg = arg_mapper<Context>().map(FMT_FORWARD(val));
  ------------------
  |  |  201|    987|#define FMT_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
  ------------------
 1747|       |
 1748|    987|  constexpr bool formattable_char =
 1749|    987|      !std::is_same<decltype(arg), const unformattable_char&>::value;
 1750|    987|  static_assert(formattable_char, "Mixing character types is disallowed.");
 1751|       |
 1752|    987|  constexpr bool formattable_const =
 1753|    987|      !std::is_same<decltype(arg), const unformattable_const&>::value;
 1754|    987|  static_assert(formattable_const, "Cannot format a const argument.");
 1755|       |
 1756|       |  // Formatting of arbitrary pointers is disallowed. If you want to format a
 1757|       |  // pointer cast it to `void*` or `const void*`. In particular, this forbids
 1758|       |  // formatting of `[const] volatile char*` printed as bool by iostreams.
 1759|    987|  constexpr bool formattable_pointer =
 1760|    987|      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
 1761|    987|  static_assert(formattable_pointer,
 1762|    987|                "Formatting of non-void pointers is disallowed.");
 1763|       |
 1764|    987|  constexpr bool formattable =
 1765|    987|      !std::is_same<decltype(arg), const unformattable&>::value;
 1766|    987|  static_assert(
 1767|    987|      formattable,
 1768|    987|      "Cannot format an argument. To make type T formattable provide a "
 1769|    987|      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
 1770|    987|  return {arg};
 1771|    987|}
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEh:
 1367|  1.37k|  FMT_CONSTEXPR FMT_INLINE auto map(unsigned char val) -> unsigned {
 1368|  1.37k|    return val;
 1369|  1.37k|  }
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEf:
 1410|  1.99k|  FMT_CONSTEXPR FMT_INLINE auto map(float val) -> float { return val; }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ef:
 1288|  1.99k|  constexpr FMT_INLINE value(float val) : float_value(val) {}
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEd:
 1411|  3.22k|  FMT_CONSTEXPR FMT_INLINE auto map(double val) -> double { return val; }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ed:
 1289|  3.22k|  constexpr FMT_INLINE value(double val) : double_value(val) {}
_ZN3fmt2v96detail4findILb0EcPKcEEbT1_S5_T0_RS5_:
 2236|  4.19k|                              const char*& out) -> bool {
 2237|  4.19k|  out = static_cast<const char*>(
 2238|  4.19k|      std::memchr(first, value, to_unsigned(last - first)));
 2239|  4.19k|  return out != nullptr;
 2240|  4.19k|}
_ZZN3fmt2v96detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_EN6writerclEPKcSL_:
 2610|  2.09k|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2611|  2.09k|      if (from == to) return;
  ------------------
  |  Branch (2611:11): [True: 0, False: 2.09k]
  ------------------
 2612|  2.09k|      for (;;) {
 2613|  2.09k|        const Char* p = nullptr;
 2614|  2.09k|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
  ------------------
  |  Branch (2614:13): [True: 2.09k, False: 0]
  ------------------
 2615|  2.09k|          return handler_.on_text(from, to);
 2616|      0|        ++p;
 2617|      0|        if (p == to || *p != '}')
  ------------------
  |  Branch (2617:13): [True: 0, False: 0]
  |  Branch (2617:24): [True: 0, False: 0]
  ------------------
 2618|      0|          return handler_.on_error("unmatched '}' in format string");
 2619|      0|        handler_.on_text(from, p);
 2620|      0|        from = p + 1;
 2621|      0|      }
 2622|  2.09k|    }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2ENS0_17basic_string_viewIcEE:
 1297|  58.3k|  FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
 1298|  58.3k|    string.data = val.data();
 1299|  58.3k|    string.size = val.size();
 1300|  58.3k|  }
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EEC2IJS7_S7_EEEDpRKT_:
 1187|  68.1k|  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EE10named_argsEv:
 1189|  68.1k|  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
 1190|  68.1k|    return nullptr;
 1191|  68.1k|  }
_ZNK3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EE4argsEv:
 1188|  68.1k|  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
_ZNK3fmt2v96detail6bufferIcE4dataEv:
  923|  58.3k|  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }

_ZN3fmt2v97vformatENS0_17basic_string_viewIcEENS0_17basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEE:
 1488|  58.3k|FMT_FUNC std::string vformat(string_view fmt, format_args args) {
 1489|       |  // Don't optimize the "{}" case to keep the binary size small and because it
 1490|       |  // can be better optimized in fmt::format anyway.
 1491|  58.3k|  auto buffer = memory_buffer();
 1492|  58.3k|  detail::vformat_to(buffer, fmt, args);
 1493|  58.3k|  return to_string(buffer);
 1494|  58.3k|}
_ZN3fmt2v96detail5printEP8_IO_FILENS0_17basic_string_viewIcEE:
 1521|  57.4k|FMT_FUNC void print(std::FILE* f, string_view text) {
 1522|       |#ifdef _WIN32
 1523|       |  if (write_console(f, text)) return;
 1524|       |#endif
 1525|  57.4k|  detail::fwrite_fully(text.data(), 1, text.size(), f);
 1526|  57.4k|}
_ZN3fmt2v96vprintEP8_IO_FILENS0_17basic_string_viewIcEENS0_17basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEE:
 1529|  57.4k|FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
 1530|  57.4k|  memory_buffer buffer;
 1531|  57.4k|  detail::vformat_to(buffer, format_str, args);
 1532|  57.4k|  detail::print(f, {buffer.data(), buffer.size()});
 1533|  57.4k|}
_ZN3fmt2v96detail12fwrite_fullyEPKvmmP8_IO_FILE:
   81|  57.4k|                         FILE* stream) {
   82|  57.4k|  size_t written = std::fwrite(ptr, size, count, stream);
   83|  57.4k|  if (written < count)
  ------------------
  |  Branch (83:7): [True: 0, False: 57.4k]
  ------------------
   84|      0|    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
  ------------------
  |  |  100|      0|      do {                             \
  |  |  101|      0|        FMT_ASSERT(false, (x).what()); \
  |  |  ------------------
  |  |  |  |  352|      0|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  102|      0|      } while (false)
  |  |  ------------------
  |  |  |  Branch (102:16): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|  57.4k|}

_ZN3fmt2v96detail6bufferIcE6appendIcEEvPKT_S7_:
  820|   420k|void buffer<T>::append(const U* begin, const U* end) {
  821|   724k|  while (begin != end) {
  ------------------
  |  Branch (821:10): [True: 303k, False: 420k]
  ------------------
  822|   303k|    auto count = to_unsigned(end - begin);
  823|   303k|    try_reserve(size_ + count);
  824|   303k|    auto free_cap = capacity_ - size_;
  825|   303k|    if (free_cap < count) count = free_cap;
  ------------------
  |  Branch (825:9): [True: 0, False: 303k]
  ------------------
  826|   303k|    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
  827|   303k|    size_ += count;
  828|   303k|    begin += count;
  829|   303k|  }
  830|   420k|}
_ZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refE:
 4145|   115k|                typename vformat_args<Char>::type args, locale_ref loc) {
 4146|       |  // workaround for msvc bug regarding name-lookup in module
 4147|       |  // link names into function scope
 4148|   115k|  using detail::arg_formatter;
 4149|   115k|  using detail::buffer_appender;
 4150|   115k|  using detail::custom_formatter;
 4151|   115k|  using detail::default_arg_formatter;
 4152|   115k|  using detail::get_arg;
 4153|   115k|  using detail::locale_ref;
 4154|   115k|  using detail::parse_format_specs;
 4155|   115k|  using detail::to_unsigned;
 4156|   115k|  using detail::type;
 4157|   115k|  using detail::write;
 4158|   115k|  auto out = buffer_appender<Char>(buf);
 4159|   115k|  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
  ------------------
  |  Branch (4159:7): [True: 0, False: 115k]
  |  Branch (4159:26): [True: 0, False: 0]
  ------------------
 4160|      0|    auto arg = args.get(0);
 4161|      0|    if (!arg) error_handler().on_error("argument not found");
  ------------------
  |  Branch (4161:9): [True: 0, False: 0]
  ------------------
 4162|      0|    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
 4163|      0|    return;
 4164|      0|  }
 4165|       |
 4166|   115k|  struct format_handler : error_handler {
 4167|   115k|    basic_format_parse_context<Char> parse_context;
 4168|   115k|    buffer_context<Char> context;
 4169|       |
 4170|   115k|    format_handler(buffer_appender<Char> p_out, basic_string_view<Char> str,
 4171|   115k|                   basic_format_args<buffer_context<Char>> p_args,
 4172|   115k|                   locale_ref p_loc)
 4173|   115k|        : parse_context(str), context(p_out, p_args, p_loc) {}
 4174|       |
 4175|   115k|    void on_text(const Char* begin, const Char* end) {
 4176|   115k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4177|   115k|      context.advance_to(write<Char>(context.out(), text));
 4178|   115k|    }
 4179|       |
 4180|   115k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4181|   115k|      return parse_context.next_arg_id();
 4182|   115k|    }
 4183|   115k|    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
 4184|   115k|      return parse_context.check_arg_id(id), id;
 4185|   115k|    }
 4186|   115k|    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
 4187|   115k|      int arg_id = context.arg_id(id);
 4188|   115k|      if (arg_id < 0) on_error("argument not found");
 4189|   115k|      return arg_id;
 4190|   115k|    }
 4191|       |
 4192|   115k|    FMT_INLINE void on_replacement_field(int id, const Char*) {
 4193|   115k|      auto arg = get_arg(context, id);
 4194|   115k|      context.advance_to(visit_format_arg(
 4195|   115k|          default_arg_formatter<Char>{context.out(), context.args(),
 4196|   115k|                                      context.locale()},
 4197|   115k|          arg));
 4198|   115k|    }
 4199|       |
 4200|   115k|    auto on_format_specs(int id, const Char* begin, const Char* end)
 4201|   115k|        -> const Char* {
 4202|   115k|      auto arg = get_arg(context, id);
 4203|   115k|      if (arg.type() == type::custom_type) {
 4204|   115k|        parse_context.advance_to(begin);
 4205|   115k|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4206|   115k|        return parse_context.begin();
 4207|   115k|      }
 4208|   115k|      auto specs = detail::dynamic_format_specs<Char>();
 4209|   115k|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4210|   115k|      detail::handle_dynamic_spec<detail::width_checker>(
 4211|   115k|          specs.width, specs.width_ref, context);
 4212|   115k|      detail::handle_dynamic_spec<detail::precision_checker>(
 4213|   115k|          specs.precision, specs.precision_ref, context);
 4214|   115k|      if (begin == end || *begin != '}')
 4215|   115k|        on_error("missing '}' in format string");
 4216|   115k|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4217|   115k|      context.advance_to(visit_format_arg(f, arg));
 4218|   115k|      return begin;
 4219|   115k|    }
 4220|   115k|  };
 4221|   115k|  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
 4222|   115k|}
_ZN3fmt2v96detail11is_negativeIiLi0EEEbT_:
 1083|  2.90k|constexpr auto is_negative(T value) -> bool {
 1084|  2.90k|  return value < 0;
 1085|  2.90k|}
_ZN3fmt2v96detail12count_digitsEj:
 1227|  12.2k|FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
 1228|  12.2k|#ifdef FMT_BUILTIN_CLZ
 1229|  12.2k|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1229:7): [Folded - Ignored]
  ------------------
 1230|  12.2k|    return do_count_digits(n);
 1231|  12.2k|  }
 1232|      0|#endif
 1233|      0|  return count_digits_fallback(n);
 1234|  12.2k|}
_ZN3fmt2v96detail15do_count_digitsEj:
 1204|  12.2k|FMT_INLINE auto do_count_digits(uint32_t n) -> int {
 1205|       |// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
 1206|       |// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
 1208|  12.2k|  static constexpr uint64_t table[] = {
 1209|  12.2k|      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1210|  12.2k|      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1211|  12.2k|      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1212|  12.2k|      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1213|  12.2k|      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1214|  12.2k|      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1215|  12.2k|      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1216|  12.2k|      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1217|  12.2k|      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1218|  12.2k|      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1219|       |      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1207|  12.2k|#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
  ------------------
 1220|  12.2k|  };
 1221|  12.2k|  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
  ------------------
  |  |  145|  12.2k|#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
  ------------------
 1222|  12.2k|  return static_cast<int>((n + inc) >> 32);
 1223|  12.2k|}
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEEC2ERKS4_:
  889|   120k|      : alloc_(alloc) {
  890|   120k|    this->set(store_, SIZE);
  891|   120k|    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  ------------------
  |  Branch (891:9): [Folded - Ignored]
  ------------------
  892|   120k|  }
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEED2Ev:
  893|   120k|  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEE10deallocateEv:
  875|   120k|  FMT_CONSTEXPR20 void deallocate() {
  876|   120k|    T* data = this->data();
  877|   120k|    if (data != store_) alloc_.deallocate(data, this->capacity());
  ------------------
  |  Branch (877:9): [True: 0, False: 120k]
  ------------------
  878|   120k|  }
_ZN3fmt2v96detail8bit_castIjfLi0EEET_RKT0_:
  311|  1.08k|FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
  312|  1.08k|#ifdef __cpp_lib_bit_cast
  313|  1.08k|  if (is_constant_evaluated()) return std::bit_cast<To>(from);
  ------------------
  |  Branch (313:7): [Folded - Ignored]
  ------------------
  314|  1.08k|#endif
  315|  1.08k|  auto to = To();
  316|       |  // The cast suppresses a bogus -Wclass-memaccess on GCC.
  317|  1.08k|  std::memcpy(static_cast<void*>(&to), &from, sizeof(to));
  318|  1.08k|  return to;
  319|  1.08k|}
_ZN3fmt2v96detail13exponent_maskIfEENS1_9dragonbox10float_infoIT_vE12carrier_uintEv:
 1438|  1.08k|    typename dragonbox::float_info<Float>::carrier_uint {
 1439|  1.08k|  using float_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1440|  1.08k|  return ((float_uint(1) << dragonbox::float_info<Float>::exponent_bits) - 1)
 1441|  1.08k|         << num_significand_bits<Float>();
 1442|  1.08k|}
_ZN3fmt2v96detail20num_significand_bitsIfEEiv:
 1429|  1.08k|template <typename Float> constexpr int num_significand_bits() {
 1430|       |  // std::numeric_limits may not support __float128.
 1431|  1.08k|  return is_float128<Float>() ? 112
  ------------------
  |  Branch (1431:10): [Folded - Ignored]
  ------------------
 1432|  1.08k|                              : (std::numeric_limits<Float>::digits -
 1433|  1.08k|                                 (has_implicit_bit<Float>() ? 1 : 0));
  ------------------
  |  Branch (1433:35): [Folded - Ignored]
  ------------------
 1434|  1.08k|}
_ZN3fmt2v96detail13exponent_biasIfEEiv:
 1443|  1.08k|template <typename Float> constexpr auto exponent_bias() -> int {
 1444|       |  // std::numeric_limits may not support __float128.
 1445|  1.08k|  return is_float128<Float>() ? 16383
  ------------------
  |  Branch (1445:10): [Folded - Ignored]
  ------------------
 1446|  1.08k|                              : std::numeric_limits<Float>::max_exponent - 1;
 1447|  1.08k|}
_ZN3fmt2v96detail8bit_castImdLi0EEET_RKT0_:
  311|  6.61k|FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
  312|  6.61k|#ifdef __cpp_lib_bit_cast
  313|  6.61k|  if (is_constant_evaluated()) return std::bit_cast<To>(from);
  ------------------
  |  Branch (313:7): [Folded - Ignored]
  ------------------
  314|  6.61k|#endif
  315|  6.61k|  auto to = To();
  316|       |  // The cast suppresses a bogus -Wclass-memaccess on GCC.
  317|  6.61k|  std::memcpy(static_cast<void*>(&to), &from, sizeof(to));
  318|  6.61k|  return to;
  319|  6.61k|}
_ZN3fmt2v96detail13exponent_maskIdEENS1_9dragonbox10float_infoIT_vE12carrier_uintEv:
 1438|  6.61k|    typename dragonbox::float_info<Float>::carrier_uint {
 1439|  6.61k|  using float_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1440|  6.61k|  return ((float_uint(1) << dragonbox::float_info<Float>::exponent_bits) - 1)
 1441|  6.61k|         << num_significand_bits<Float>();
 1442|  6.61k|}
_ZN3fmt2v96detail20num_significand_bitsIdEEiv:
 1429|  6.61k|template <typename Float> constexpr int num_significand_bits() {
 1430|       |  // std::numeric_limits may not support __float128.
 1431|  6.61k|  return is_float128<Float>() ? 112
  ------------------
  |  Branch (1431:10): [Folded - Ignored]
  ------------------
 1432|  6.61k|                              : (std::numeric_limits<Float>::digits -
 1433|  6.61k|                                 (has_implicit_bit<Float>() ? 1 : 0));
  ------------------
  |  Branch (1433:35): [Folded - Ignored]
  ------------------
 1434|  6.61k|}
_ZN3fmt2v96detail13exponent_biasIdEEiv:
 1443|  6.61k|template <typename Float> constexpr auto exponent_bias() -> int {
 1444|       |  // std::numeric_limits may not support __float128.
 1445|  6.61k|  return is_float128<Float>() ? 16383
  ------------------
  |  Branch (1445:10): [Folded - Ignored]
  ------------------
 1446|  6.61k|                              : std::numeric_limits<Float>::max_exponent - 1;
 1447|  6.61k|}
_ZN3fmt2v96detail12make_checkedIcEEPT_S4_m:
  529|   303k|template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
  530|   303k|  return p;
  531|   303k|}
_ZN3fmt2v96detail7reserveINS0_8appenderEEERT_S5_m:
  557|   476k|constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
  558|   476k|  return it;
  559|   476k|}
_ZN3fmt2v96detail10to_pointerIcEEPT_NSt3__111conditionalIXsr3std7is_sameIS3_cEE5valueENS0_8appenderENS5_20back_insert_iteratorINS1_6bufferIS3_EEEEE4typeEm:
  569|  58.3k|template <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {
  570|  58.3k|  buffer<T>& buf = get_container(it);
  571|  58.3k|  auto size = buf.size();
  572|  58.3k|  if (buf.capacity() < size + n) return nullptr;
  ------------------
  |  Branch (572:7): [True: 0, False: 58.3k]
  ------------------
  573|  58.3k|  buf.try_resize(size + n);
  574|  58.3k|  return buf.data() + size;
  575|  58.3k|}
_ZN3fmt2v96detail14format_decimalIcjEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1297|  3.83k|    -> format_decimal_result<Char*> {
 1298|  3.83k|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  352|  3.83k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 1299|  3.83k|  out += size;
 1300|  3.83k|  Char* end = out;
 1301|  6.84k|  while (value >= 100) {
  ------------------
  |  Branch (1301:10): [True: 3.00k, False: 3.83k]
  ------------------
 1302|       |    // Integer division is slow so do it for a group of two digits instead
 1303|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1304|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1305|  3.00k|    out -= 2;
 1306|  3.00k|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1307|  3.00k|    value /= 100;
 1308|  3.00k|  }
 1309|  3.83k|  if (value < 10) {
  ------------------
  |  Branch (1309:7): [True: 2.76k, False: 1.07k]
  ------------------
 1310|  2.76k|    *--out = static_cast<Char>('0' + value);
 1311|  2.76k|    return {out, end};
 1312|  2.76k|  }
 1313|  1.07k|  out -= 2;
 1314|  1.07k|  copy2(out, digits2(static_cast<size_t>(value)));
 1315|  1.07k|  return {out, end};
 1316|  3.83k|}
_ZN3fmt2v96detail5copy2IcEEvPT_PKc:
 1278|   251k|FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
 1279|   251k|  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
  ------------------
  |  Branch (1279:7): [Folded - Ignored]
  |  Branch (1279:35): [Folded - Ignored]
  ------------------
 1280|   251k|    memcpy(dst, src, 2);
 1281|   251k|    return;
 1282|   251k|  }
 1283|      0|  *dst++ = static_cast<Char>(*src++);
 1284|      0|  *dst = static_cast<Char>(*src);
 1285|      0|}
_ZN3fmt2v96detail7digits2Em:
 1115|   251k|constexpr const char* digits2(size_t value) {
 1116|       |  // GCC generates slightly better code when value is pointer-size.
 1117|   251k|  return &"0001020304050607080910111213141516171819"
 1118|   251k|         "2021222324252627282930313233343536373839"
 1119|   251k|         "4041424344454647484950515253545556575859"
 1120|   251k|         "6061626364656667686970717273747576777879"
 1121|   251k|         "8081828384858687888990919293949596979899"[value * 2];
 1122|   251k|}
_ZN3fmt2v96detail14format_decimalIcjNS0_8appenderELi0EEENS1_21format_decimal_resultIT1_EES5_T0_i:
 1321|  3.83k|    -> format_decimal_result<Iterator> {
 1322|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1323|  3.83k|  Char buffer[digits10<UInt>() + 1] = {};
 1324|  3.83k|  auto end = format_decimal(buffer, value, size).end;
 1325|  3.83k|  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
 1326|  3.83k|}
_ZN3fmt2v96detail17copy_str_noinlineIcPcNS0_8appenderEEET1_T0_S6_S5_:
  614|  58.3k|                                                  OutputIt out) -> OutputIt {
  615|  58.3k|  return copy_str<OutChar>(begin, end, out);
  616|  58.3k|}
_ZN3fmt2v96detail13base_iteratorINS0_8appenderEEET_S4_S4_:
  585|   476k|constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
  586|   476k|  return it;
  587|   476k|}
_ZN3fmt2v96detail11is_negativeIjLi0EEEbT_:
 1087|  4.76k|constexpr auto is_negative(T) -> bool {
 1088|  4.76k|  return false;
 1089|  4.76k|}
_ZN3fmt2v96detail12count_digitsEm:
 1175|   108k|FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
 1176|   108k|#ifdef FMT_BUILTIN_CLZLL
 1177|   108k|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1177:7): [Folded - Ignored]
  ------------------
 1178|   108k|    return do_count_digits(n);
 1179|   108k|  }
 1180|      0|#endif
 1181|      0|  return count_digits_fallback(n);
 1182|   108k|}
_ZN3fmt2v96detail15do_count_digitsEm:
 1155|   108k|inline auto do_count_digits(uint64_t n) -> int {
 1156|       |  // This has comparable performance to the version by Kendall Willets
 1157|       |  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
 1158|       |  // but uses smaller tables.
 1159|       |  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
 1160|   108k|  static constexpr uint8_t bsr2log10[] = {
 1161|   108k|      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
 1162|   108k|      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
 1163|   108k|      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
 1164|   108k|      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
 1165|   108k|  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
  ------------------
  |  |  148|   108k|#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
  ------------------
 1166|   108k|  static constexpr const uint64_t zero_or_powers_of_10[] = {
 1167|   108k|      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1110|   108k|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1111|   108k|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1112|   108k|      (factor)*1000000000
  ------------------
                    0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1110|   108k|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1111|   108k|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1112|   108k|      (factor)*1000000000
  ------------------
 1168|   108k|      10000000000000000000ULL};
 1169|   108k|  return t - (n < zero_or_powers_of_10[t]);
 1170|   108k|}
_ZN3fmt2v96detail14format_decimalIcmEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1297|  54.4k|    -> format_decimal_result<Char*> {
 1298|  54.4k|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  352|  54.4k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 1299|  54.4k|  out += size;
 1300|  54.4k|  Char* end = out;
 1301|   280k|  while (value >= 100) {
  ------------------
  |  Branch (1301:10): [True: 226k, False: 54.4k]
  ------------------
 1302|       |    // Integer division is slow so do it for a group of two digits instead
 1303|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1304|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1305|   226k|    out -= 2;
 1306|   226k|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1307|   226k|    value /= 100;
 1308|   226k|  }
 1309|  54.4k|  if (value < 10) {
  ------------------
  |  Branch (1309:7): [True: 32.7k, False: 21.7k]
  ------------------
 1310|  32.7k|    *--out = static_cast<Char>('0' + value);
 1311|  32.7k|    return {out, end};
 1312|  32.7k|  }
 1313|  21.7k|  out -= 2;
 1314|  21.7k|  copy2(out, digits2(static_cast<size_t>(value)));
 1315|  21.7k|  return {out, end};
 1316|  54.4k|}
_ZN3fmt2v96detail14format_decimalIcmNS0_8appenderELi0EEENS1_21format_decimal_resultIT1_EES5_T0_i:
 1321|  54.4k|    -> format_decimal_result<Iterator> {
 1322|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1323|  54.4k|  Char buffer[digits10<UInt>() + 1] = {};
 1324|  54.4k|  auto end = format_decimal(buffer, value, size).end;
 1325|  54.4k|  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
 1326|  54.4k|}
_ZN3fmt2v96detail11is_negativeIyLi0EEEbT_:
 1087|   108k|constexpr auto is_negative(T) -> bool {
 1088|   108k|  return false;
 1089|   108k|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEiLi0EEET0_S4_T1_RKNS0_12format_specsIT_EENS1_10locale_refE:
 2169|  2.90k|                                    locale_ref loc) -> OutputIt {
 2170|  2.90k|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2170:7): [True: 0, False: 2.90k]
  |  Branch (2170:26): [True: 0, False: 0]
  ------------------
 2171|  2.90k|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2172|  2.90k|                            loc);
 2173|  2.90k|}
_ZN3fmt2v96detail18write_int_noinlineIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2160|  7.66k|    locale_ref loc) -> OutputIt {
 2161|  7.66k|  return write_int(out, arg, specs, loc);
 2162|  7.66k|}
_ZN3fmt2v96detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2104|  7.66k|                                        locale_ref) -> OutputIt {
 2105|  7.66k|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2106|  7.66k|  auto abs_value = arg.abs_value;
 2107|  7.66k|  auto prefix = arg.prefix;
 2108|  7.66k|  switch (specs.type) {
 2109|      0|  case presentation_type::none:
  ------------------
  |  Branch (2109:3): [True: 0, False: 7.66k]
  ------------------
 2110|  3.83k|  case presentation_type::dec: {
  ------------------
  |  Branch (2110:3): [True: 3.83k, False: 3.83k]
  ------------------
 2111|  3.83k|    auto num_digits = count_digits(abs_value);
 2112|  3.83k|    return write_int(
 2113|  3.83k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2114|  3.83k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2115|  3.83k|        });
 2116|      0|  }
 2117|      0|  case presentation_type::hex_lower:
  ------------------
  |  Branch (2117:3): [True: 0, False: 7.66k]
  ------------------
 2118|  3.83k|  case presentation_type::hex_upper: {
  ------------------
  |  Branch (2118:3): [True: 3.83k, False: 3.83k]
  ------------------
 2119|  3.83k|    bool upper = specs.type == presentation_type::hex_upper;
 2120|  3.83k|    if (specs.alt)
  ------------------
  |  Branch (2120:9): [True: 0, False: 3.83k]
  ------------------
 2121|      0|      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2121:38): [True: 0, False: 0]
  ------------------
 2122|  3.83k|    int num_digits = count_digits<4>(abs_value);
 2123|  3.83k|    return write_int(
 2124|  3.83k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2125|  3.83k|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2126|  3.83k|        });
 2127|      0|  }
 2128|      0|  case presentation_type::bin_lower:
  ------------------
  |  Branch (2128:3): [True: 0, False: 7.66k]
  ------------------
 2129|      0|  case presentation_type::bin_upper: {
  ------------------
  |  Branch (2129:3): [True: 0, False: 7.66k]
  ------------------
 2130|      0|    bool upper = specs.type == presentation_type::bin_upper;
 2131|      0|    if (specs.alt)
  ------------------
  |  Branch (2131:9): [True: 0, False: 0]
  ------------------
 2132|      0|      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2132:38): [True: 0, False: 0]
  ------------------
 2133|      0|    int num_digits = count_digits<1>(abs_value);
 2134|      0|    return write_int(out, num_digits, prefix, specs,
 2135|      0|                     [=](reserve_iterator<OutputIt> it) {
 2136|      0|                       return format_uint<1, Char>(it, abs_value, num_digits);
 2137|      0|                     });
 2138|      0|  }
 2139|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2139:3): [True: 0, False: 7.66k]
  ------------------
 2140|      0|    int num_digits = count_digits<3>(abs_value);
 2141|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2142|       |    // is not greater than the number of digits.
 2143|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2143:9): [True: 0, False: 0]
  |  Branch (2143:22): [True: 0, False: 0]
  |  Branch (2143:55): [True: 0, False: 0]
  ------------------
 2144|      0|      prefix_append(prefix, '0');
 2145|      0|    return write_int(out, num_digits, prefix, specs,
 2146|      0|                     [=](reserve_iterator<OutputIt> it) {
 2147|      0|                       return format_uint<3, Char>(it, abs_value, num_digits);
 2148|      0|                     });
 2149|      0|  }
 2150|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2150:3): [True: 0, False: 7.66k]
  ------------------
 2151|      0|    return write_char(out, static_cast<Char>(abs_value), specs);
 2152|      0|  default:
  ------------------
  |  Branch (2152:3): [True: 0, False: 7.66k]
  ------------------
 2153|      0|    throw_format_error("invalid format specifier");
 2154|  7.66k|  }
 2155|      0|  return out;
 2156|  7.66k|}
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_jEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E_EESA_SA_ijRKNS9_IS5_EES7_:
 1939|  3.83k|                                        W write_digits) -> OutputIt {
 1940|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1941|  3.83k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1941:7): [True: 3.83k, False: 0]
  ------------------
 1942|  3.83k|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1943|  3.83k|    if (prefix != 0) {
  ------------------
  |  Branch (1943:9): [True: 650, False: 3.18k]
  ------------------
 1944|  1.30k|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1944:44): [True: 650, False: 650]
  ------------------
 1945|    650|        *it++ = static_cast<Char>(p & 0xff);
 1946|    650|    }
 1947|  3.83k|    return base_iterator(out, write_digits(it));
 1948|  3.83k|  }
 1949|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1950|      0|  return write_padded<align::right>(
 1951|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1952|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1953|      0|          *it++ = static_cast<Char>(p & 0xff);
 1954|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1955|      0|        return write_digits(it);
 1956|      0|      });
 1957|  3.83k|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEENKUlS3_E_clES3_:
 2113|  3.83k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2114|  3.83k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2115|  3.83k|        });
_ZN3fmt2v96detail14write_int_dataIcEC2EijRKNS0_12format_specsIcEE:
 1917|  58.3k|      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
 1918|  58.3k|    if (specs.align == align::numeric) {
  ------------------
  |  Branch (1918:9): [True: 58.3k, False: 0]
  ------------------
 1919|  58.3k|      auto width = to_unsigned(specs.width);
 1920|  58.3k|      if (width > size) {
  ------------------
  |  Branch (1920:11): [True: 24.8k, False: 33.4k]
  ------------------
 1921|  24.8k|        padding = width - size;
 1922|  24.8k|        size = width;
 1923|  24.8k|      }
 1924|  58.3k|    } else if (specs.precision > num_digits) {
  ------------------
  |  Branch (1924:16): [True: 0, False: 0]
  ------------------
 1925|      0|      size = (prefix >> 24) + to_unsigned(specs.precision);
 1926|      0|      padding = to_unsigned(specs.precision - num_digits);
 1927|      0|    }
 1928|  58.3k|  }
_ZN3fmt2v96detail6fill_nINS0_8appenderEmcEET_S4_T0_RKT1_:
  593|  58.3k|    -> OutputIt {
  594|  83.2k|  for (Size i = 0; i < count; ++i) *out++ = value;
  ------------------
  |  Branch (594:20): [True: 24.8k, False: 58.3k]
  ------------------
  595|  58.3k|  return out;
  596|  58.3k|}
_ZN3fmt2v96detail12count_digitsILi4EjEEiT0_:
 1186|  3.83k|FMT_CONSTEXPR auto count_digits(UInt n) -> int {
 1187|  3.83k|#ifdef FMT_BUILTIN_CLZ
 1188|  3.83k|  if (!is_constant_evaluated() && num_bits<UInt>() == 32)
  ------------------
  |  Branch (1188:7): [Folded - Ignored]
  |  Branch (1188:35): [Folded - Ignored]
  ------------------
 1189|  3.83k|    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
  ------------------
  |  |  145|  3.83k|#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
  ------------------
 1190|      0|#endif
 1191|       |  // Lambda avoids unreachable code warnings from NVHPC.
 1192|      0|  return [](UInt m) {
 1193|      0|    int num_digits = 0;
 1194|      0|    do {
 1195|      0|      ++num_digits;
 1196|      0|    } while ((m >>= BITS) != 0);
 1197|      0|    return num_digits;
 1198|      0|  }(n);
 1199|  3.83k|}
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_jEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E0_EESA_SA_ijRKNS9_IS5_EES7_:
 1939|  3.83k|                                        W write_digits) -> OutputIt {
 1940|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1941|  3.83k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1941:7): [True: 0, False: 3.83k]
  ------------------
 1942|      0|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1943|      0|    if (prefix != 0) {
  ------------------
  |  Branch (1943:9): [True: 0, False: 0]
  ------------------
 1944|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1944:44): [True: 0, False: 0]
  ------------------
 1945|      0|        *it++ = static_cast<Char>(p & 0xff);
 1946|      0|    }
 1947|      0|    return base_iterator(out, write_digits(it));
 1948|      0|  }
 1949|  3.83k|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1950|  3.83k|  return write_padded<align::right>(
 1951|  3.83k|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1952|  3.83k|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1953|  3.83k|          *it++ = static_cast<Char>(p & 0xff);
 1954|  3.83k|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1955|  3.83k|        return write_digits(it);
 1956|  3.83k|      });
 1957|  3.83k|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEENKUlS3_E0_clES3_:
 2124|  3.83k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2125|  3.83k|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2126|  3.83k|        });
_ZN3fmt2v96detail11format_uintILj4EcNS0_8appenderEjEET1_S4_T2_ib:
 1344|  3.83k|    -> It {
 1345|  3.83k|  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
  ------------------
  |  Branch (1345:12): [True: 3.83k, False: 0]
  ------------------
 1346|  3.83k|    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
 1347|  3.83k|    return out;
 1348|  3.83k|  }
 1349|       |  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
 1350|      0|  char buffer[num_bits<UInt>() / BASE_BITS + 1];
 1351|      0|  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
 1352|      0|  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
 1353|  3.83k|}
_ZN3fmt2v96detail11format_uintILj4EcjEEPT0_S4_T1_ib:
 1330|  3.83k|                               bool upper = false) -> Char* {
 1331|  3.83k|  buffer += num_digits;
 1332|  3.83k|  Char* end = buffer;
 1333|  10.1k|  do {
 1334|  10.1k|    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
  ------------------
  |  Branch (1334:26): [True: 10.1k, False: 0]
  ------------------
 1335|  10.1k|    unsigned digit = static_cast<unsigned>(value & ((1 << BASE_BITS) - 1));
 1336|  10.1k|    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
  ------------------
  |  Branch (1336:35): [Folded - Ignored]
  ------------------
 1337|  10.1k|                                                : digits[digit]);
 1338|  10.1k|  } while ((value >>= BASE_BITS) != 0);
  ------------------
  |  Branch (1338:12): [True: 6.31k, False: 3.83k]
  ------------------
 1339|  3.83k|  return end;
 1340|  3.83k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcZNS1_9write_intIS5_cZNS1_9write_intIcS5_jEET0_S8_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS5_E0_EESD_SD_ijRKNSC_IS8_EESA_EUlS5_E_EES8_S8_RKNSC_ISA_EEmOT2_:
 1700|  3.83k|                            size_t size, F&& f) -> OutputIt {
 1701|  3.83k|  return write_padded<align>(out, specs, size, size, f);
 1702|  3.83k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcRZNS1_9write_intIS5_cZNS1_9write_intIcS5_jEET0_S8_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS5_E0_EESD_SD_ijRKNSC_IS8_EESA_EUlS5_E_EES8_S8_RKNSC_ISA_EEmmOT2_:
 1681|  3.83k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1682|  3.83k|  static_assert(align == align::left || align == align::right, "");
 1683|  3.83k|  unsigned spec_width = to_unsigned(specs.width);
 1684|  3.83k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1684:20): [True: 0, False: 3.83k]
  ------------------
 1685|       |  // Shifts are encoded as string literals because static constexpr is not
 1686|       |  // supported in constexpr functions.
 1687|  3.83k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1687:18): [Folded - Ignored]
  ------------------
 1688|  3.83k|  size_t left_padding = padding >> shifts[specs.align];
 1689|  3.83k|  size_t right_padding = padding - left_padding;
 1690|  3.83k|  auto it = reserve(out, size + padding * specs.fill.size());
 1691|  3.83k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1691:7): [True: 0, False: 3.83k]
  ------------------
 1692|  3.83k|  it = f(it);
 1693|  3.83k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1693:7): [True: 0, False: 3.83k]
  ------------------
 1694|  3.83k|  return base_iterator(out, it);
 1695|  3.83k|}
_ZZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_jEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E0_EESA_SA_ijRKNS9_IS5_EES7_ENKUlS3_E_clES3_:
 1951|  3.83k|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1952|  3.83k|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1952:46): [True: 0, False: 3.83k]
  ------------------
 1953|      0|          *it++ = static_cast<Char>(p & 0xff);
 1954|  3.83k|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1955|  3.83k|        return write_digits(it);
 1956|  3.83k|      });
_ZN3fmt2v96detail18make_write_int_argIiEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2066|  2.90k|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2067|  2.90k|  auto prefix = 0u;
 2068|  2.90k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2069|  2.90k|  if (is_negative(value)) {
  ------------------
  |  Branch (2069:7): [True: 650, False: 2.25k]
  ------------------
 2070|    650|    prefix = 0x01000000 | '-';
 2071|    650|    abs_value = 0 - abs_value;
 2072|  2.25k|  } else {
 2073|  2.25k|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2074|  2.25k|                                            0x1000000u | ' '};
 2075|  2.25k|    prefix = prefixes[sign];
 2076|  2.25k|  }
 2077|  2.90k|  return {abs_value, prefix};
 2078|  2.90k|}
_ZN3fmt2v96detail27is_supported_floating_pointIfEEbT_:
 1092|  1.99k|FMT_CONSTEXPR auto is_supported_floating_point(T) -> bool {
 1093|  1.99k|  if (std::is_same<T, float>()) return FMT_USE_FLOAT;
  ------------------
  |  |  183|  1.99k|#  define FMT_USE_FLOAT 1
  ------------------
  |  Branch (1093:7): [Folded - Ignored]
  ------------------
 1094|      0|  if (std::is_same<T, double>()) return FMT_USE_DOUBLE;
  ------------------
  |  |  186|      0|#  define FMT_USE_DOUBLE 1
  ------------------
  |  Branch (1094:7): [Folded - Ignored]
  ------------------
 1095|      0|  if (std::is_same<T, long double>()) return FMT_USE_LONG_DOUBLE;
  ------------------
  |  |  189|      0|#  define FMT_USE_LONG_DOUBLE 1
  ------------------
  |  Branch (1095:7): [Folded - Ignored]
  ------------------
 1096|      0|  return true;
 1097|      0|}
_ZN3fmt2v96detail7signbitIfLi0EEEbT_:
 2631|  1.99k|FMT_INLINE FMT_CONSTEXPR bool signbit(T value) {
 2632|  1.99k|  if (is_constant_evaluated()) {
  ------------------
  |  Branch (2632:7): [Folded - Ignored]
  ------------------
 2633|      0|#ifdef __cpp_if_constexpr
 2634|      0|    if constexpr (std::numeric_limits<double>::is_iec559) {
  ------------------
  |  Branch (2634:19): [Folded - Ignored]
  ------------------
 2635|      0|      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
 2636|      0|      return (bits >> (num_bits<uint64_t>() - 1)) != 0;
 2637|      0|    }
 2638|      0|#endif
 2639|      0|  }
 2640|  1.99k|  return std::signbit(static_cast<double>(value));
 2641|  1.99k|}
_ZN3fmt2v96detail15write_nonfiniteIcNS0_8appenderEEET0_S4_bNS0_12format_specsIT_EERKNS1_11float_specsE:
 2350|    350|                                     const float_specs& fspecs) -> OutputIt {
 2351|    350|  auto str =
 2352|    350|      isnan ? (fspecs.upper ? "NAN" : "nan") : (fspecs.upper ? "INF" : "inf");
  ------------------
  |  Branch (2352:7): [True: 328, False: 22]
  |  Branch (2352:16): [True: 0, False: 328]
  |  Branch (2352:49): [True: 0, False: 22]
  ------------------
 2353|    350|  constexpr size_t str_size = 3;
 2354|    350|  auto sign = fspecs.sign;
 2355|    350|  auto size = str_size + (sign ? 1 : 0);
  ------------------
  |  Branch (2355:27): [True: 282, False: 68]
  ------------------
 2356|       |  // Replace '0'-padding with space for non-finite values.
 2357|    350|  const bool is_zero_fill =
 2358|    350|      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');
  ------------------
  |  Branch (2358:7): [True: 350, False: 0]
  |  Branch (2358:33): [True: 0, False: 350]
  ------------------
 2359|    350|  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');
  ------------------
  |  Branch (2359:7): [True: 0, False: 350]
  ------------------
 2360|    350|  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
 2361|    350|    if (sign) *it++ = detail::sign<Char>(sign);
 2362|    350|    return copy_str<Char>(str, str + str_size, it);
 2363|    350|  });
 2364|    350|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcZNS1_15write_nonfiniteIcS5_EET0_S7_bNS0_12format_specsIT_EERKNS1_11float_specsEEUlS5_E_EES7_S7_RKNS8_IT1_EEmOT2_:
 1700|    350|                            size_t size, F&& f) -> OutputIt {
 1701|    350|  return write_padded<align>(out, specs, size, size, f);
 1702|    350|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcRZNS1_15write_nonfiniteIcS5_EET0_S7_bNS0_12format_specsIT_EERKNS1_11float_specsEEUlS5_E_EES7_S7_RKNS8_IT1_EEmmOT2_:
 1681|    350|                                size_t size, size_t width, F&& f) -> OutputIt {
 1682|    350|  static_assert(align == align::left || align == align::right, "");
 1683|    350|  unsigned spec_width = to_unsigned(specs.width);
 1684|    350|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1684:20): [True: 0, False: 350]
  ------------------
 1685|       |  // Shifts are encoded as string literals because static constexpr is not
 1686|       |  // supported in constexpr functions.
 1687|    350|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1687:18): [Folded - Ignored]
  ------------------
 1688|    350|  size_t left_padding = padding >> shifts[specs.align];
 1689|    350|  size_t right_padding = padding - left_padding;
 1690|    350|  auto it = reserve(out, size + padding * specs.fill.size());
 1691|    350|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1691:7): [True: 0, False: 350]
  ------------------
 1692|    350|  it = f(it);
 1693|    350|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1693:7): [True: 0, False: 350]
  ------------------
 1694|    350|  return base_iterator(out, it);
 1695|    350|}
_ZZN3fmt2v96detail15write_nonfiniteIcNS0_8appenderEEET0_S4_bNS0_12format_specsIT_EERKNS1_11float_specsEENKUlS3_E_clES3_:
 2360|    350|  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
 2361|    350|    if (sign) *it++ = detail::sign<Char>(sign);
  ------------------
  |  Branch (2361:9): [True: 282, False: 68]
  ------------------
 2362|    350|    return copy_str<Char>(str, str + str_size, it);
 2363|    350|  });
_ZN3fmt2v96detail4signIcNS0_4sign4typeEEET_T0_:
 1125|  2.82k|template <typename Char, typename Sign> constexpr Char sign(Sign s) {
 1126|  2.82k|#if !FMT_GCC_VERSION || FMT_GCC_VERSION >= 604
 1127|  2.82k|  static_assert(std::is_same<Sign, sign_t>::value, "");
 1128|  2.82k|#endif
 1129|  2.82k|  return static_cast<Char>("\0-+ "[s]);
 1130|  2.82k|}
_ZN3fmt2v96detail6fill_nINS0_8appenderEicEET_S4_T0_RKT1_:
  593|  1.93k|    -> OutputIt {
  594|  8.87k|  for (Size i = 0; i < count; ++i) *out++ = value;
  ------------------
  |  Branch (594:20): [True: 6.94k, False: 1.93k]
  ------------------
  595|  1.93k|  return out;
  596|  1.93k|}
_ZN3fmt2v96detail14digit_groupingIcEC2ENS1_10locale_refEb:
 1981|  2.93k|  explicit digit_grouping(locale_ref loc, bool localized = true) {
 1982|  2.93k|    if (!localized) return;
  ------------------
  |  Branch (1982:9): [True: 2.93k, False: 0]
  ------------------
 1983|      0|    auto sep = thousands_sep<Char>(loc);
 1984|      0|    grouping_ = sep.grouping;
 1985|      0|    if (sep.thousands_sep) thousands_sep_.assign(1, sep.thousands_sep);
  ------------------
  |  Branch (1985:9): [True: 0, False: 0]
  ------------------
 1986|      0|  }
_ZNK3fmt2v96detail14digit_groupingIcE16count_separatorsEi:
 1992|  2.93k|  int count_separators(int num_digits) const {
 1993|  2.93k|    int count = 0;
 1994|  2.93k|    auto state = initial_state();
 1995|  2.93k|    while (num_digits > next(state)) ++count;
  ------------------
  |  Branch (1995:12): [True: 0, False: 2.93k]
  ------------------
 1996|  2.93k|    return count;
 1997|  2.93k|  }
_ZNK3fmt2v96detail14digit_groupingIcE13initial_stateEv:
 1968|  2.93k|  next_state initial_state() const { return {grouping_.begin(), 0}; }
_ZNK3fmt2v96detail14digit_groupingIcE4nextERNS3_10next_stateE:
 1971|  2.93k|  int next(next_state& state) const {
 1972|  2.93k|    if (thousands_sep_.empty()) return max_value<int>();
  ------------------
  |  Branch (1972:9): [True: 2.93k, False: 0]
  ------------------
 1973|      0|    if (state.group == grouping_.end()) return state.pos += grouping_.back();
  ------------------
  |  Branch (1973:9): [True: 0, False: 0]
  ------------------
 1974|      0|    if (*state.group <= 0 || *state.group == max_value<char>())
  ------------------
  |  Branch (1974:9): [True: 0, False: 0]
  |  Branch (1974:30): [True: 0, False: 0]
  ------------------
 1975|      0|      return max_value<int>();
 1976|      0|    state.pos += *state.group++;
 1977|      0|    return state.pos;
 1978|      0|  }
_ZN3fmt2v96detail9max_valueIiEET_v:
  459|  5.86k|template <typename T> constexpr auto max_value() -> T {
  460|  5.86k|  return (std::numeric_limits<T>::max)();
  461|  5.86k|}
_ZNK3fmt2v96detail14digit_groupingIcE13has_separatorEv:
 1990|  2.93k|  bool has_separator() const { return !thousands_sep_.empty(); }
_ZN3fmt2v96detail27is_supported_floating_pointIdEEbT_:
 1092|  3.22k|FMT_CONSTEXPR auto is_supported_floating_point(T) -> bool {
 1093|  3.22k|  if (std::is_same<T, float>()) return FMT_USE_FLOAT;
  ------------------
  |  |  183|      0|#  define FMT_USE_FLOAT 1
  ------------------
  |  Branch (1093:7): [Folded - Ignored]
  ------------------
 1094|  3.22k|  if (std::is_same<T, double>()) return FMT_USE_DOUBLE;
  ------------------
  |  |  186|  3.22k|#  define FMT_USE_DOUBLE 1
  ------------------
  |  Branch (1094:7): [Folded - Ignored]
  ------------------
 1095|      0|  if (std::is_same<T, long double>()) return FMT_USE_LONG_DOUBLE;
  ------------------
  |  |  189|      0|#  define FMT_USE_LONG_DOUBLE 1
  ------------------
  |  Branch (1095:7): [Folded - Ignored]
  ------------------
 1096|      0|  return true;
 1097|      0|}
_ZN3fmt2v96detail7signbitIdLi0EEEbT_:
 2631|  3.22k|FMT_INLINE FMT_CONSTEXPR bool signbit(T value) {
 2632|  3.22k|  if (is_constant_evaluated()) {
  ------------------
  |  Branch (2632:7): [Folded - Ignored]
  ------------------
 2633|      0|#ifdef __cpp_if_constexpr
 2634|      0|    if constexpr (std::numeric_limits<double>::is_iec559) {
  ------------------
  |  Branch (2634:19): [Folded - Ignored]
  ------------------
 2635|      0|      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
 2636|      0|      return (bits >> (num_bits<uint64_t>() - 1)) != 0;
 2637|      0|    }
 2638|      0|#endif
 2639|      0|  }
 2640|  3.22k|  return std::signbit(static_cast<double>(value));
 2641|  3.22k|}
_ZN3fmt2v96detail21parse_float_type_specINS1_13error_handlerEcEENS1_11float_specsERKNS0_12format_specsIT0_EEOT_:
 2306|  5.21k|    -> float_specs {
 2307|  5.21k|  auto result = float_specs();
 2308|  5.21k|  result.showpoint = specs.alt;
 2309|  5.21k|  result.locale = specs.localized;
 2310|  5.21k|  switch (specs.type) {
 2311|      0|  case presentation_type::none:
  ------------------
  |  Branch (2311:3): [True: 0, False: 5.21k]
  ------------------
 2312|      0|    result.format = float_format::general;
 2313|      0|    break;
 2314|      0|  case presentation_type::general_upper:
  ------------------
  |  Branch (2314:3): [True: 0, False: 5.21k]
  ------------------
 2315|      0|    result.upper = true;
 2316|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  164|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2317|      0|  case presentation_type::general_lower:
  ------------------
  |  Branch (2317:3): [True: 0, False: 5.21k]
  ------------------
 2318|      0|    result.format = float_format::general;
 2319|      0|    break;
 2320|      0|  case presentation_type::exp_upper:
  ------------------
  |  Branch (2320:3): [True: 0, False: 5.21k]
  ------------------
 2321|      0|    result.upper = true;
 2322|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  164|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2323|      0|  case presentation_type::exp_lower:
  ------------------
  |  Branch (2323:3): [True: 0, False: 5.21k]
  ------------------
 2324|      0|    result.format = float_format::exp;
 2325|      0|    result.showpoint |= specs.precision != 0;
 2326|      0|    break;
 2327|      0|  case presentation_type::fixed_upper:
  ------------------
  |  Branch (2327:3): [True: 0, False: 5.21k]
  ------------------
 2328|      0|    result.upper = true;
 2329|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  164|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2330|  5.21k|  case presentation_type::fixed_lower:
  ------------------
  |  Branch (2330:3): [True: 5.21k, False: 0]
  ------------------
 2331|  5.21k|    result.format = float_format::fixed;
 2332|  5.21k|    result.showpoint |= specs.precision != 0;
 2333|  5.21k|    break;
 2334|      0|  case presentation_type::hexfloat_upper:
  ------------------
  |  Branch (2334:3): [True: 0, False: 5.21k]
  ------------------
 2335|      0|    result.upper = true;
 2336|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  164|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2337|      0|  case presentation_type::hexfloat_lower:
  ------------------
  |  Branch (2337:3): [True: 0, False: 5.21k]
  ------------------
 2338|      0|    result.format = float_format::hex;
 2339|      0|    break;
 2340|      0|  default:
  ------------------
  |  Branch (2340:3): [True: 0, False: 5.21k]
  ------------------
 2341|      0|    eh.on_error("invalid format specifier");
 2342|      0|    break;
 2343|  5.21k|  }
 2344|  5.21k|  return result;
 2345|  5.21k|}
_ZN3fmt2v96detail6fill_nIciEEPT_S4_T0_c:
  598|    280|FMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {
  599|    280|  if (is_constant_evaluated()) {
  ------------------
  |  Branch (599:7): [Folded - Ignored]
  ------------------
  600|      0|    return fill_n<T*, Size, T>(out, count, value);
  601|      0|  }
  602|    280|  std::memset(out, value, to_unsigned(count));
  603|    280|  return out + count;
  604|    280|}
_ZN3fmt2v96detail8basic_fpIoEC2Ev:
 1479|  3.11k|  constexpr basic_fp() : f(0), e(0) {}
_ZN3fmt2v96detail8basic_fpIoE6assignIfLi0EEEbT_:
 1487|  1.08k|  FMT_CONSTEXPR auto assign(Float n) -> bool {
 1488|  1.08k|    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
 1489|       |    // Assume Float is in the format [sign][exponent][significand].
 1490|  1.08k|    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1491|  1.08k|    const auto num_float_significand_bits =
 1492|  1.08k|        detail::num_significand_bits<Float>();
 1493|  1.08k|    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
 1494|  1.08k|    const auto significand_mask = implicit_bit - 1;
 1495|  1.08k|    auto u = bit_cast<carrier_uint>(n);
 1496|  1.08k|    f = static_cast<F>(u & significand_mask);
 1497|  1.08k|    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
 1498|  1.08k|                                     num_float_significand_bits);
 1499|       |    // The predecessor is closer if n is a normalized power of 2 (f == 0)
 1500|       |    // other than the smallest normalized number (biased_e > 1).
 1501|  1.08k|    auto is_predecessor_closer = f == 0 && biased_e > 1;
  ------------------
  |  Branch (1501:34): [True: 490, False: 591]
  |  Branch (1501:44): [True: 490, False: 0]
  ------------------
 1502|  1.08k|    if (biased_e == 0)
  ------------------
  |  Branch (1502:9): [True: 0, False: 1.08k]
  ------------------
 1503|      0|      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
 1504|  1.08k|    else if (has_implicit_bit<Float>())
  ------------------
  |  Branch (1504:14): [Folded - Ignored]
  ------------------
 1505|  1.08k|      f += static_cast<F>(implicit_bit);
 1506|  1.08k|    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
 1507|  1.08k|    if (!has_implicit_bit<Float>()) ++e;
  ------------------
  |  Branch (1507:9): [Folded - Ignored]
  ------------------
 1508|  1.08k|    return is_predecessor_closer;
 1509|  1.08k|  }
_ZN3fmt2v96detail13format_dragonENS1_8basic_fpIoEEjiRNS1_6bufferIcEERi:
 3083|  3.11k|                                          buffer<char>& buf, int& exp10) {
 3084|  3.11k|  bigint numerator;    // 2 * R in (FPP)^2.
 3085|  3.11k|  bigint denominator;  // 2 * S in (FPP)^2.
 3086|       |  // lower and upper are differences between value and corresponding boundaries.
 3087|  3.11k|  bigint lower;             // (M^- in (FPP)^2).
 3088|  3.11k|  bigint upper_store;       // upper's value if different from lower.
 3089|  3.11k|  bigint* upper = nullptr;  // (M^+ in (FPP)^2).
 3090|       |  // Shift numerator and denominator by an extra bit or two (if lower boundary
 3091|       |  // is closer) to make lower and upper integers. This eliminates multiplication
 3092|       |  // by 2 during later computations.
 3093|  3.11k|  bool is_predecessor_closer = (flags & dragon::predecessor_closer) != 0;
 3094|  3.11k|  int shift = is_predecessor_closer ? 2 : 1;
  ------------------
  |  Branch (3094:15): [True: 690, False: 2.42k]
  ------------------
 3095|  3.11k|  if (value.e >= 0) {
  ------------------
  |  Branch (3095:7): [True: 2.34k, False: 772]
  ------------------
 3096|  2.34k|    numerator = value.f;
 3097|  2.34k|    numerator <<= value.e + shift;
 3098|  2.34k|    lower = 1;
 3099|  2.34k|    lower <<= value.e;
 3100|  2.34k|    if (is_predecessor_closer) {
  ------------------
  |  Branch (3100:9): [True: 284, False: 2.06k]
  ------------------
 3101|    284|      upper_store = 1;
 3102|    284|      upper_store <<= value.e + 1;
 3103|    284|      upper = &upper_store;
 3104|    284|    }
 3105|  2.34k|    denominator.assign_pow10(exp10);
 3106|  2.34k|    denominator <<= shift;
 3107|  2.34k|  } else if (exp10 < 0) {
  ------------------
  |  Branch (3107:14): [True: 371, False: 401]
  ------------------
 3108|    371|    numerator.assign_pow10(-exp10);
 3109|    371|    lower.assign(numerator);
 3110|    371|    if (is_predecessor_closer) {
  ------------------
  |  Branch (3110:9): [True: 333, False: 38]
  ------------------
 3111|    333|      upper_store.assign(numerator);
 3112|    333|      upper_store <<= 1;
 3113|    333|      upper = &upper_store;
 3114|    333|    }
 3115|    371|    numerator *= value.f;
 3116|    371|    numerator <<= shift;
 3117|    371|    denominator = 1;
 3118|    371|    denominator <<= shift - value.e;
 3119|    401|  } else {
 3120|    401|    numerator = value.f;
 3121|    401|    numerator <<= shift;
 3122|    401|    denominator.assign_pow10(exp10);
 3123|    401|    denominator <<= shift - value.e;
 3124|    401|    lower = 1;
 3125|    401|    if (is_predecessor_closer) {
  ------------------
  |  Branch (3125:9): [True: 73, False: 328]
  ------------------
 3126|     73|      upper_store = 1ULL << 1;
 3127|     73|      upper = &upper_store;
 3128|     73|    }
 3129|    401|  }
 3130|  3.11k|  int even = static_cast<int>((value.f & 1) == 0);
 3131|  3.11k|  if (!upper) upper = &lower;
  ------------------
  |  Branch (3131:7): [True: 2.42k, False: 690]
  ------------------
 3132|  3.11k|  if ((flags & dragon::fixup) != 0) {
  ------------------
  |  Branch (3132:7): [True: 0, False: 3.11k]
  ------------------
 3133|      0|    if (add_compare(numerator, *upper, denominator) + even <= 0) {
  ------------------
  |  Branch (3133:9): [True: 0, False: 0]
  ------------------
 3134|      0|      --exp10;
 3135|      0|      numerator *= 10;
 3136|      0|      if (num_digits < 0) {
  ------------------
  |  Branch (3136:11): [True: 0, False: 0]
  ------------------
 3137|      0|        lower *= 10;
 3138|      0|        if (upper != &lower) *upper *= 10;
  ------------------
  |  Branch (3138:13): [True: 0, False: 0]
  ------------------
 3139|      0|      }
 3140|      0|    }
 3141|      0|    if ((flags & dragon::fixed) != 0) adjust_precision(num_digits, exp10 + 1);
  ------------------
  |  Branch (3141:9): [True: 0, False: 0]
  ------------------
 3142|      0|  }
 3143|       |  // Invariant: value == (numerator / denominator) * pow(10, exp10).
 3144|  3.11k|  if (num_digits < 0) {
  ------------------
  |  Branch (3144:7): [True: 0, False: 3.11k]
  ------------------
 3145|       |    // Generate the shortest representation.
 3146|      0|    num_digits = 0;
 3147|      0|    char* data = buf.data();
 3148|      0|    for (;;) {
 3149|      0|      int digit = numerator.divmod_assign(denominator);
 3150|      0|      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.
 3151|       |      // numerator + upper >[=] pow10:
 3152|      0|      bool high = add_compare(numerator, *upper, denominator) + even > 0;
 3153|      0|      data[num_digits++] = static_cast<char>('0' + digit);
 3154|      0|      if (low || high) {
  ------------------
  |  Branch (3154:11): [True: 0, False: 0]
  |  Branch (3154:18): [True: 0, False: 0]
  ------------------
 3155|      0|        if (!low) {
  ------------------
  |  Branch (3155:13): [True: 0, False: 0]
  ------------------
 3156|      0|          ++data[num_digits - 1];
 3157|      0|        } else if (high) {
  ------------------
  |  Branch (3157:20): [True: 0, False: 0]
  ------------------
 3158|      0|          int result = add_compare(numerator, numerator, denominator);
 3159|       |          // Round half to even.
 3160|      0|          if (result > 0 || (result == 0 && (digit % 2) != 0))
  ------------------
  |  Branch (3160:15): [True: 0, False: 0]
  |  Branch (3160:30): [True: 0, False: 0]
  |  Branch (3160:45): [True: 0, False: 0]
  ------------------
 3161|      0|            ++data[num_digits - 1];
 3162|      0|        }
 3163|      0|        buf.try_resize(to_unsigned(num_digits));
 3164|      0|        exp10 -= num_digits - 1;
 3165|      0|        return;
 3166|      0|      }
 3167|      0|      numerator *= 10;
 3168|      0|      lower *= 10;
 3169|      0|      if (upper != &lower) *upper *= 10;
  ------------------
  |  Branch (3169:11): [True: 0, False: 0]
  ------------------
 3170|      0|    }
 3171|      0|  }
 3172|       |  // Generate the given number of digits.
 3173|  3.11k|  exp10 -= num_digits - 1;
 3174|  3.11k|  if (num_digits == 0) {
  ------------------
  |  Branch (3174:7): [True: 0, False: 3.11k]
  ------------------
 3175|      0|    denominator *= 10;
 3176|      0|    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
  ------------------
  |  Branch (3176:18): [True: 0, False: 0]
  ------------------
 3177|      0|    buf.push_back(digit);
 3178|      0|    return;
 3179|      0|  }
 3180|  3.11k|  buf.try_resize(to_unsigned(num_digits));
 3181|   403k|  for (int i = 0; i < num_digits - 1; ++i) {
  ------------------
  |  Branch (3181:19): [True: 400k, False: 3.11k]
  ------------------
 3182|   400k|    int digit = numerator.divmod_assign(denominator);
 3183|   400k|    buf[i] = static_cast<char>('0' + digit);
 3184|   400k|    numerator *= 10;
 3185|   400k|  }
 3186|  3.11k|  int digit = numerator.divmod_assign(denominator);
 3187|  3.11k|  auto result = add_compare(numerator, numerator, denominator);
 3188|  3.11k|  if (result > 0 || (result == 0 && (digit % 2) != 0)) {
  ------------------
  |  Branch (3188:7): [True: 46, False: 3.07k]
  |  Branch (3188:22): [True: 463, False: 2.60k]
  |  Branch (3188:37): [True: 187, False: 276]
  ------------------
 3189|    233|    if (digit == 9) {
  ------------------
  |  Branch (3189:9): [True: 0, False: 233]
  ------------------
 3190|      0|      const auto overflow = '0' + 10;
 3191|      0|      buf[num_digits - 1] = overflow;
 3192|       |      // Propagate the carry.
 3193|      0|      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
  ------------------
  |  Branch (3193:36): [True: 0, False: 0]
  |  Branch (3193:45): [True: 0, False: 0]
  ------------------
 3194|      0|        buf[i] = '0';
 3195|      0|        ++buf[i - 1];
 3196|      0|      }
 3197|      0|      if (buf[0] == overflow) {
  ------------------
  |  Branch (3197:11): [True: 0, False: 0]
  ------------------
 3198|      0|        buf[0] = '1';
 3199|      0|        ++exp10;
 3200|      0|      }
 3201|      0|      return;
 3202|      0|    }
 3203|    233|    ++digit;
 3204|    233|  }
 3205|  3.11k|  buf[num_digits - 1] = static_cast<char>('0' + digit);
 3206|  3.11k|}
_ZN3fmt2v96detail6bigintC2Ev:
 2908|  12.4k|  FMT_CONSTEXPR20 bigint() : exp_(0) {}
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEEC2ERKS4_:
  889|  12.4k|      : alloc_(alloc) {
  890|  12.4k|    this->set(store_, SIZE);
  891|  12.4k|    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  ------------------
  |  Branch (891:9): [Folded - Ignored]
  ------------------
  892|  12.4k|  }
_ZN3fmt2v96detail12make_checkedIjEEPT_S4_m:
  529|  16.2k|template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
  530|  16.2k|  return p;
  531|  16.2k|}
_ZN3fmt2v96detail6bigintaSIoEEvT_:
 2922|  2.74k|  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
 2923|  2.74k|    FMT_ASSERT(n > 0, "");
  ------------------
  |  |  352|  2.74k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2924|  2.74k|    assign(uint64_or_128_t<Int>(n));
 2925|  2.74k|  }
_ZN3fmt2v96detail6bigint6assignIoLi0EEEvT_:
 2897|  2.74k|  FMT_CONSTEXPR20 void assign(UInt n) {
 2898|  2.74k|    size_t num_bigits = 0;
 2899|  4.78k|    do {
 2900|  4.78k|      bigits_[num_bigits++] = static_cast<bigit>(n);
 2901|  4.78k|      n >>= bigit_bits;
 2902|  4.78k|    } while (n != 0);
  ------------------
  |  Branch (2902:14): [True: 2.03k, False: 2.74k]
  ------------------
 2903|  2.74k|    bigits_.resize(num_bigits);
 2904|  2.74k|    exp_ = 0;
 2905|  2.74k|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEE6resizeEm:
  945|  1.80M|  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }
_ZN3fmt2v96detail6bigintlSEi:
 2931|  12.2k|  FMT_NOINLINE FMT_CONSTEXPR20 bigint& operator<<=(int shift) {
 2932|  12.2k|    FMT_ASSERT(shift >= 0, "");
  ------------------
  |  |  352|  12.2k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2933|  12.2k|    exp_ += shift / bigit_bits;
 2934|  12.2k|    shift %= bigit_bits;
 2935|  12.2k|    if (shift == 0) return *this;
  ------------------
  |  Branch (2935:9): [True: 523, False: 11.7k]
  ------------------
 2936|  11.7k|    bigit carry = 0;
 2937|  78.4k|    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
  ------------------
  |  Branch (2937:44): [True: 66.7k, False: 11.7k]
  ------------------
 2938|  66.7k|      bigit c = bigits_[i] >> (bigit_bits - shift);
 2939|  66.7k|      bigits_[i] = (bigits_[i] << shift) + carry;
 2940|  66.7k|      carry = c;
 2941|  66.7k|    }
 2942|  11.7k|    if (carry != 0) bigits_.push_back(carry);
  ------------------
  |  Branch (2942:9): [True: 3.33k, False: 8.37k]
  ------------------
 2943|  11.7k|    return *this;
 2944|  12.2k|  }
_ZN3fmt2v96detail6bigintaSIiEEvT_:
 2922|  6.51k|  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
 2923|  6.51k|    FMT_ASSERT(n > 0, "");
  ------------------
  |  |  352|  6.51k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2924|  6.51k|    assign(uint64_or_128_t<Int>(n));
 2925|  6.51k|  }
_ZN3fmt2v96detail6bigint6assignImLi0EEEvT_:
 2897|  6.58k|  FMT_CONSTEXPR20 void assign(UInt n) {
 2898|  6.58k|    size_t num_bigits = 0;
 2899|  6.58k|    do {
 2900|  6.58k|      bigits_[num_bigits++] = static_cast<bigit>(n);
 2901|  6.58k|      n >>= bigit_bits;
 2902|  6.58k|    } while (n != 0);
  ------------------
  |  Branch (2902:14): [True: 0, False: 6.58k]
  ------------------
 2903|  6.58k|    bigits_.resize(num_bigits);
 2904|  6.58k|    exp_ = 0;
 2905|  6.58k|  }
_ZN3fmt2v96detail6bigint12assign_pow10Ei:
 2995|  3.11k|  FMT_CONSTEXPR20 void assign_pow10(int exp) {
 2996|  3.11k|    FMT_ASSERT(exp >= 0, "");
  ------------------
  |  |  352|  3.11k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2997|  3.11k|    if (exp == 0) return *this = 1;
  ------------------
  |  Branch (2997:9): [True: 74, False: 3.04k]
  ------------------
 2998|       |    // Find the top bit.
 2999|  3.04k|    int bitmask = 1;
 3000|  21.6k|    while (exp >= bitmask) bitmask <<= 1;
  ------------------
  |  Branch (3000:12): [True: 18.5k, False: 3.04k]
  ------------------
 3001|  3.04k|    bitmask >>= 1;
 3002|       |    // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by
 3003|       |    // repeated squaring and multiplication.
 3004|  3.04k|    *this = 5;
 3005|  3.04k|    bitmask >>= 1;
 3006|  18.5k|    while (bitmask != 0) {
  ------------------
  |  Branch (3006:12): [True: 15.5k, False: 3.04k]
  ------------------
 3007|  15.5k|      square();
 3008|  15.5k|      if ((exp & bitmask) != 0) *this *= 5;
  ------------------
  |  Branch (3008:11): [True: 6.80k, False: 8.72k]
  ------------------
 3009|  15.5k|      bitmask >>= 1;
 3010|  15.5k|    }
 3011|  3.04k|    *this <<= exp;  // Multiply by pow(2, exp) by shifting.
 3012|  3.04k|  }
_ZN3fmt2v96detail6bigint6squareEv:
 3014|  15.5k|  FMT_CONSTEXPR20 void square() {
 3015|  15.5k|    int num_bigits = static_cast<int>(bigits_.size());
 3016|  15.5k|    int num_result_bigits = 2 * num_bigits;
 3017|  15.5k|    basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
 3018|  15.5k|    bigits_.resize(to_unsigned(num_result_bigits));
 3019|  15.5k|    auto sum = uint128_t();
 3020|  52.2k|    for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
  ------------------
  |  Branch (3020:31): [True: 36.7k, False: 15.5k]
  ------------------
 3021|       |      // Compute bigit at position bigit_index of the result by adding
 3022|       |      // cross-product terms n[i] * n[j] such that i + j == bigit_index.
 3023|   150k|      for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
  ------------------
  |  Branch (3023:40): [True: 114k, False: 36.7k]
  ------------------
 3024|       |        // Most terms are multiplied twice which can be optimized in the future.
 3025|   114k|        sum += static_cast<double_bigit>(n[i]) * n[j];
 3026|   114k|      }
 3027|  36.7k|      (*this)[bigit_index] = static_cast<bigit>(sum);
 3028|  36.7k|      sum >>= num_bits<bigit>();  // Compute the carry.
 3029|  36.7k|    }
 3030|       |    // Do the same for the top half.
 3031|  52.2k|    for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
  ------------------
  |  Branch (3031:40): [True: 36.7k, False: 15.5k]
  ------------------
 3032|  36.7k|         ++bigit_index) {
 3033|   114k|      for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
  ------------------
  |  Branch (3033:57): [True: 77.3k, False: 36.7k]
  ------------------
 3034|  77.3k|        sum += static_cast<double_bigit>(n[i++]) * n[j--];
 3035|  36.7k|      (*this)[bigit_index] = static_cast<bigit>(sum);
 3036|  36.7k|      sum >>= num_bits<bigit>();
 3037|  36.7k|    }
 3038|  15.5k|    remove_leading_zeros();
 3039|  15.5k|    exp_ *= 2;
 3040|  15.5k|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEEC2EOS5_:
  922|  15.5k|  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other) noexcept {
  923|  15.5k|    move(other);
  924|  15.5k|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEE4moveERS5_:
  897|  15.5k|  FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
  898|  15.5k|    alloc_ = std::move(other.alloc_);
  899|  15.5k|    T* data = other.data();
  900|  15.5k|    size_t size = other.size(), capacity = other.capacity();
  901|  15.5k|    if (data == other.store_) {
  ------------------
  |  Branch (901:9): [True: 15.5k, False: 0]
  ------------------
  902|  15.5k|      this->set(store_, capacity);
  903|  15.5k|      detail::copy_str<T>(other.store_, other.store_ + size,
  904|  15.5k|                          detail::make_checked(store_, capacity));
  905|  15.5k|    } else {
  906|      0|      this->set(data, capacity);
  907|       |      // Set pointer to the inline array so that delete is not called
  908|       |      // when deallocating.
  909|      0|      other.set(other.store_, 0);
  910|      0|      other.clear();
  911|      0|    }
  912|  15.5k|    this->resize(size);
  913|  15.5k|  }
_ZN3fmt2v96detail6bigintixEi:
 2831|  65.3M|  FMT_CONSTEXPR20 bigit& operator[](int index) {
 2832|  65.3M|    return bigits_[to_unsigned(index)];
 2833|  65.3M|  }
_ZN3fmt2v96detail8num_bitsIjEEiv:
  462|  73.4k|template <typename T> constexpr auto num_bits() -> int {
  463|  73.4k|  return std::numeric_limits<T>::digits;
  464|  73.4k|}
_ZN3fmt2v96detail6bigint20remove_leading_zerosEv:
 2845|  1.76M|  FMT_CONSTEXPR20 void remove_leading_zeros() {
 2846|  1.76M|    int num_bigits = static_cast<int>(bigits_.size()) - 1;
 2847|  1.84M|    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
  ------------------
  |  Branch (2847:12): [True: 1.82M, False: 24.2k]
  |  Branch (2847:30): [True: 84.5k, False: 1.73M]
  ------------------
 2848|  1.76M|    bigits_.resize(to_unsigned(num_bigits + 1));
 2849|  1.76M|  }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEED2Ev:
  893|  27.9k|  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
_ZN3fmt2v919basic_memory_bufferIjLm32ENSt3__19allocatorIjEEE10deallocateEv:
  875|  27.9k|  FMT_CONSTEXPR20 void deallocate() {
  876|  27.9k|    T* data = this->data();
  877|  27.9k|    if (data != store_) alloc_.deallocate(data, this->capacity());
  ------------------
  |  Branch (877:9): [True: 0, False: 27.9k]
  ------------------
  878|  27.9k|  }
_ZN3fmt2v96detail6bigint6assignERKS2_:
 2914|    704|  FMT_CONSTEXPR20 void assign(const bigint& other) {
 2915|    704|    auto size = other.bigits_.size();
 2916|    704|    bigits_.resize(size);
 2917|    704|    auto data = other.bigits_.data();
 2918|    704|    std::copy(data, data + size, make_checked(bigits_.data(), size));
 2919|    704|    exp_ = other.exp_;
 2920|    704|  }
_ZN3fmt2v96detail6bigintmLIoEERS2_T_:
 2946|    371|  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
 2947|    371|    FMT_ASSERT(value > 0, "");
  ------------------
  |  |  352|    371|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2948|    371|    multiply(uint32_or_64_or_128_t<Int>(value));
 2949|    371|    return *this;
 2950|    371|  }
_ZN3fmt2v96detail6bigint8multiplyIoLi0EEEvT_:
 2876|    371|  FMT_CONSTEXPR20 void multiply(UInt value) {
 2877|    371|    using half_uint =
 2878|    371|        conditional_t<std::is_same<UInt, uint128_t>::value, uint64_t, uint32_t>;
 2879|    371|    const int shift = num_bits<half_uint>() - bigit_bits;
 2880|    371|    const UInt lower = static_cast<half_uint>(value);
 2881|    371|    const UInt upper = value >> num_bits<half_uint>();
 2882|    371|    UInt carry = 0;
 2883|    742|    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
  ------------------
  |  Branch (2883:44): [True: 371, False: 371]
  ------------------
 2884|    371|      UInt result = lower * bigits_[i] + static_cast<bigit>(carry);
 2885|    371|      carry = (upper * bigits_[i] << shift) + (result >> bigit_bits) +
 2886|    371|              (carry >> bigit_bits);
 2887|    371|      bigits_[i] = static_cast<bigit>(result);
 2888|    371|    }
 2889|    612|    while (carry != 0) {
  ------------------
  |  Branch (2889:12): [True: 241, False: 371]
  ------------------
 2890|    241|      bigits_.push_back(static_cast<bigit>(carry));
 2891|    241|      carry >>= bigit_bits;
 2892|    241|    }
 2893|    371|  }
_ZN3fmt2v96detail8num_bitsImEEiv:
  462|    371|template <typename T> constexpr auto num_bits() -> int {
  463|    371|  return std::numeric_limits<T>::digits;
  464|    371|}
_ZN3fmt2v96detail6bigintaSIyEEvT_:
 2922|     73|  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
 2923|     73|    FMT_ASSERT(n > 0, "");
  ------------------
  |  |  352|     73|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2924|     73|    assign(uint64_or_128_t<Int>(n));
 2925|     73|  }
_ZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_:
 2970|  3.11k|                                         const bigint& rhs) {
 2971|  3.11k|    auto minimum = [](int a, int b) { return a < b ? a : b; };
 2972|  3.11k|    auto maximum = [](int a, int b) { return a > b ? a : b; };
 2973|  3.11k|    int max_lhs_bigits = maximum(lhs1.num_bigits(), lhs2.num_bigits());
 2974|  3.11k|    int num_rhs_bigits = rhs.num_bigits();
 2975|  3.11k|    if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
  ------------------
  |  Branch (2975:9): [True: 1.99k, False: 1.12k]
  ------------------
 2976|  1.12k|    if (max_lhs_bigits > num_rhs_bigits) return 1;
  ------------------
  |  Branch (2976:9): [True: 0, False: 1.12k]
  ------------------
 2977|  1.12k|    auto get_bigit = [](const bigint& n, int i) -> bigit {
 2978|  1.12k|      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
 2979|  1.12k|    };
 2980|  1.12k|    double_bigit borrow = 0;
 2981|  1.12k|    int min_exp = minimum(minimum(lhs1.exp_, lhs2.exp_), rhs.exp_);
 2982|  1.89k|    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
  ------------------
  |  Branch (2982:38): [True: 1.43k, False: 463]
  ------------------
 2983|  1.43k|      double_bigit sum =
 2984|  1.43k|          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
 2985|  1.43k|      bigit rhs_bigit = get_bigit(rhs, i);
 2986|  1.43k|      if (sum > rhs_bigit + borrow) return 1;
  ------------------
  |  Branch (2986:11): [True: 46, False: 1.38k]
  ------------------
 2987|  1.38k|      borrow = rhs_bigit + borrow - sum;
 2988|  1.38k|      if (borrow > 1) return -1;
  ------------------
  |  Branch (2988:11): [True: 614, False: 775]
  ------------------
 2989|    775|      borrow <<= bigit_bits;
 2990|    775|    }
 2991|    463|    return borrow != 0 ? -1 : 0;
  ------------------
  |  Branch (2991:12): [True: 0, False: 463]
  ------------------
 2992|  1.12k|  }
_ZZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_ENKUliiE0_clEii:
 2972|  3.11k|    auto maximum = [](int a, int b) { return a > b ? a : b; };
  ------------------
  |  Branch (2972:46): [True: 0, False: 3.11k]
  ------------------
_ZNK3fmt2v96detail6bigint10num_bigitsEv:
 2927|  7.80M|  FMT_CONSTEXPR20 int num_bigits() const {
 2928|  7.80M|    return static_cast<int>(bigits_.size()) + exp_;
 2929|  7.80M|  }
_ZZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_ENKUliiE_clEii:
 2971|  2.24k|    auto minimum = [](int a, int b) { return a < b ? a : b; };
  ------------------
  |  Branch (2971:46): [True: 289, False: 1.95k]
  ------------------
_ZZN3fmt2v96detail11add_compareERKNS1_6bigintES4_S4_ENKUlS4_iE_clES4_i:
 2977|  4.30k|    auto get_bigit = [](const bigint& n, int i) -> bigit {
 2978|  4.30k|      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
  ------------------
  |  Branch (2978:14): [True: 4.06k, False: 243]
  |  Branch (2978:29): [True: 3.05k, False: 1.00k]
  ------------------
 2979|  4.30k|    };
_ZNK3fmt2v96detail6bigintixEi:
 2828|  7.46M|  FMT_CONSTEXPR20 bigit operator[](int index) const {
 2829|  7.46M|    return bigits_[to_unsigned(index)];
 2830|  7.46M|  }
_ZN3fmt2v96detail6bigintmLIiEERS2_T_:
 2946|   407k|  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
 2947|   407k|    FMT_ASSERT(value > 0, "");
  ------------------
  |  |  352|   407k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2948|   407k|    multiply(uint32_or_64_or_128_t<Int>(value));
 2949|   407k|    return *this;
 2950|   407k|  }
_ZN3fmt2v96detail6bigint8multiplyEj:
 2863|   407k|  FMT_CONSTEXPR20 void multiply(uint32_t value) {
 2864|   407k|    const double_bigit wide_value = value;
 2865|   407k|    bigit carry = 0;
 2866|  7.49M|    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
  ------------------
  |  Branch (2866:44): [True: 7.08M, False: 407k]
  ------------------
 2867|  7.08M|      double_bigit result = bigits_[i] * wide_value + carry;
 2868|  7.08M|      bigits_[i] = static_cast<bigit>(result);
 2869|  7.08M|      carry = static_cast<bigit>(result >> bigit_bits);
 2870|  7.08M|    }
 2871|   407k|    if (carry != 0) bigits_.push_back(carry);
  ------------------
  |  Branch (2871:9): [True: 45.8k, False: 361k]
  ------------------
 2872|   407k|  }
_ZN3fmt2v96detail16adjust_precisionERii:
 2715|  4.58k|inline FMT_CONSTEXPR20 void adjust_precision(int& precision, int exp10) {
 2716|       |  // Adjust fixed precision by exponent because it is relative to decimal
 2717|       |  // point.
 2718|  4.58k|  if (exp10 > 0 && precision > max_value<int>() - exp10)
  ------------------
  |  Branch (2718:7): [True: 2.93k, False: 1.65k]
  |  Branch (2718:20): [True: 0, False: 2.93k]
  ------------------
 2719|      0|    FMT_THROW(format_error("number is too big"));
  ------------------
  |  |  100|      0|      do {                             \
  |  |  101|      0|        FMT_ASSERT(false, (x).what()); \
  |  |  ------------------
  |  |  |  |  352|      0|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  102|      0|      } while (false)
  |  |  ------------------
  |  |  |  Branch (102:16): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2720|  4.58k|  precision += exp10;
 2721|  4.58k|}
_ZN3fmt2v96detail6bigint13divmod_assignERKS2_:
 3057|   403k|  FMT_CONSTEXPR20 int divmod_assign(const bigint& divisor) {
 3058|   403k|    FMT_ASSERT(this != &divisor, "");
  ------------------
  |  |  352|   403k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 3059|   403k|    if (compare(*this, divisor) < 0) return 0;
  ------------------
  |  Branch (3059:9): [True: 51.3k, False: 352k]
  ------------------
 3060|   352k|    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
  ------------------
  |  |  352|   352k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 3061|   352k|    align(divisor);
 3062|   352k|    int quotient = 0;
 3063|  1.74M|    do {
 3064|  1.74M|      subtract_aligned(divisor);
 3065|  1.74M|      ++quotient;
 3066|  1.74M|    } while (compare(*this, divisor) >= 0);
  ------------------
  |  Branch (3066:14): [True: 1.39M, False: 352k]
  ------------------
 3067|   352k|    return quotient;
 3068|   403k|  }
_ZN3fmt2v96detail6bigint5alignERKS2_:
 3044|   352k|  FMT_CONSTEXPR20 void align(const bigint& other) {
 3045|   352k|    int exp_difference = exp_ - other.exp_;
 3046|   352k|    if (exp_difference <= 0) return;
  ------------------
  |  Branch (3046:9): [True: 350k, False: 1.99k]
  ------------------
 3047|  1.99k|    int num_bigits = static_cast<int>(bigits_.size());
 3048|  1.99k|    bigits_.resize(to_unsigned(num_bigits + exp_difference));
 3049|  7.33k|    for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
  ------------------
  |  Branch (3049:58): [True: 5.33k, False: 1.99k]
  ------------------
 3050|  5.33k|      bigits_[j] = bigits_[i];
 3051|  1.99k|    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
 3052|  1.99k|    exp_ -= exp_difference;
 3053|  1.99k|  }
_ZN3fmt2v96detail6bigint16subtract_alignedERKS2_:
 2852|  1.74M|  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {
 2853|  1.74M|    FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
  ------------------
  |  |  352|  1.74M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2854|  1.74M|    FMT_ASSERT(compare(*this, other) >= 0, "");
  ------------------
  |  |  352|  1.74M|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2855|  1.74M|    bigit borrow = 0;
 2856|  1.74M|    int i = other.exp_ - exp_;
 2857|  33.4M|    for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
  ------------------
  |  Branch (2857:50): [True: 31.6M, False: 1.74M]
  ------------------
 2858|  31.6M|      subtract_bigits(i, other.bigits_[j], borrow);
 2859|  1.82M|    while (borrow > 0) subtract_bigits(i, 0, borrow);
  ------------------
  |  Branch (2859:12): [True: 78.5k, False: 1.74M]
  ------------------
 2860|  1.74M|    remove_leading_zeros();
 2861|  1.74M|  }
_ZN3fmt2v96detail6bigint15subtract_bigitsEijRj:
 2839|  31.7M|  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {
 2840|  31.7M|    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
 2841|  31.7M|    (*this)[index] = static_cast<bigit>(result);
 2842|  31.7M|    borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
 2843|  31.7M|  }
_ZN3fmt2v96detail7compareERKNS1_6bigintES4_:
 2952|  3.89M|  friend FMT_CONSTEXPR20 int compare(const bigint& lhs, const bigint& rhs) {
 2953|  3.89M|    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
 2954|  3.89M|    if (num_lhs_bigits != num_rhs_bigits)
  ------------------
  |  Branch (2954:9): [True: 258k, False: 3.63M]
  ------------------
 2955|   258k|      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
  ------------------
  |  Branch (2955:14): [True: 217k, False: 40.9k]
  ------------------
 2956|  3.63M|    int i = static_cast<int>(lhs.bigits_.size()) - 1;
 2957|  3.63M|    int j = static_cast<int>(rhs.bigits_.size()) - 1;
 2958|  3.63M|    int end = i - j;
 2959|  3.63M|    if (end < 0) end = 0;
  ------------------
  |  Branch (2959:9): [True: 1.86k, False: 3.63M]
  ------------------
 2960|  3.73M|    for (; i >= end; --i, --j) {
  ------------------
  |  Branch (2960:12): [True: 3.73M, False: 7.13k]
  ------------------
 2961|  3.73M|      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
 2962|  3.73M|      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
  ------------------
  |  Branch (2962:11): [True: 3.62M, False: 102k]
  |  Branch (2962:42): [True: 3.26M, False: 362k]
  ------------------
 2963|  3.73M|    }
 2964|  7.13k|    if (i != j) return i > j ? 1 : -1;
  ------------------
  |  Branch (2964:9): [True: 2.02k, False: 5.11k]
  |  Branch (2964:24): [True: 2.02k, False: 0]
  ------------------
 2965|  5.11k|    return 0;
 2966|  7.13k|  }
_ZN3fmt2v96detail11write_floatINS0_8appenderENS1_14big_decimal_fpEcEET_S5_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refE:
 2594|  4.86k|    -> OutputIt {
 2595|  4.86k|  if (is_constant_evaluated()) {
  ------------------
  |  Branch (2595:7): [Folded - Ignored]
  ------------------
 2596|      0|    return do_write_float<OutputIt, DecimalFP, Char,
 2597|      0|                          fallback_digit_grouping<Char>>(out, f, specs, fspecs,
 2598|      0|                                                         loc);
 2599|  4.86k|  } else {
 2600|  4.86k|    return do_write_float(out, f, specs, fspecs, loc);
 2601|  4.86k|  }
 2602|  4.86k|}
_ZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refE:
 2475|  4.86k|    -> OutputIt {
 2476|  4.86k|  auto significand = f.significand;
 2477|  4.86k|  int significand_size = get_significand_size(f);
 2478|  4.86k|  const Char zero = static_cast<Char>('0');
 2479|  4.86k|  auto sign = fspecs.sign;
 2480|  4.86k|  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
  ------------------
  |  Branch (2480:50): [True: 2.54k, False: 2.31k]
  ------------------
 2481|  4.86k|  using iterator = reserve_iterator<OutputIt>;
 2482|       |
 2483|  4.86k|  Char decimal_point =
 2484|  4.86k|      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');
  ------------------
  |  Branch (2484:7): [True: 0, False: 4.86k]
  ------------------
 2485|       |
 2486|  4.86k|  int output_exp = f.exponent + significand_size - 1;
 2487|  4.86k|  auto use_exp_format = [=]() {
 2488|  4.86k|    if (fspecs.format == float_format::exp) return true;
 2489|  4.86k|    if (fspecs.format != float_format::general) return false;
 2490|       |    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
 2491|       |    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
 2492|  4.86k|    const int exp_lower = -4, exp_upper = 16;
 2493|  4.86k|    return output_exp < exp_lower ||
 2494|  4.86k|           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
 2495|  4.86k|  };
 2496|  4.86k|  if (use_exp_format()) {
  ------------------
  |  Branch (2496:7): [True: 0, False: 4.86k]
  ------------------
 2497|      0|    int num_zeros = 0;
 2498|      0|    if (fspecs.showpoint) {
  ------------------
  |  Branch (2498:9): [True: 0, False: 0]
  ------------------
 2499|      0|      num_zeros = fspecs.precision - significand_size;
 2500|      0|      if (num_zeros < 0) num_zeros = 0;
  ------------------
  |  Branch (2500:11): [True: 0, False: 0]
  ------------------
 2501|      0|      size += to_unsigned(num_zeros);
 2502|      0|    } else if (significand_size == 1) {
  ------------------
  |  Branch (2502:16): [True: 0, False: 0]
  ------------------
 2503|      0|      decimal_point = Char();
 2504|      0|    }
 2505|      0|    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;
  ------------------
  |  Branch (2505:27): [True: 0, False: 0]
  ------------------
 2506|      0|    int exp_digits = 2;
 2507|      0|    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;
  ------------------
  |  Branch (2507:9): [True: 0, False: 0]
  |  Branch (2507:45): [True: 0, False: 0]
  ------------------
 2508|       |
 2509|      0|    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
  ------------------
  |  Branch (2509:26): [True: 0, False: 0]
  ------------------
 2510|      0|    char exp_char = fspecs.upper ? 'E' : 'e';
  ------------------
  |  Branch (2510:21): [True: 0, False: 0]
  ------------------
 2511|      0|    auto write = [=](iterator it) {
 2512|      0|      if (sign) *it++ = detail::sign<Char>(sign);
 2513|       |      // Insert a decimal point after the first digit and add an exponent.
 2514|      0|      it = write_significand(it, significand, significand_size, 1,
 2515|      0|                             decimal_point);
 2516|      0|      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);
 2517|      0|      *it++ = static_cast<Char>(exp_char);
 2518|      0|      return write_exponent<Char>(output_exp, it);
 2519|      0|    };
 2520|      0|    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
  ------------------
  |  Branch (2520:12): [True: 0, False: 0]
  ------------------
 2521|      0|                           : base_iterator(out, write(reserve(out, size)));
 2522|      0|  }
 2523|       |
 2524|  4.86k|  int exp = f.exponent + significand_size;
 2525|  4.86k|  if (f.exponent >= 0) {
  ------------------
  |  Branch (2525:7): [True: 0, False: 4.86k]
  ------------------
 2526|       |    // 1234e5 -> 123400000[.0+]
 2527|      0|    size += to_unsigned(f.exponent);
 2528|      0|    int num_zeros = fspecs.precision - exp;
 2529|      0|    abort_fuzzing_if(num_zeros > 5000);
 2530|      0|    if (fspecs.showpoint) {
  ------------------
  |  Branch (2530:9): [True: 0, False: 0]
  ------------------
 2531|      0|      ++size;
 2532|      0|      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;
  ------------------
  |  Branch (2532:11): [True: 0, False: 0]
  |  Branch (2532:29): [True: 0, False: 0]
  ------------------
 2533|      0|      if (num_zeros > 0) size += to_unsigned(num_zeros);
  ------------------
  |  Branch (2533:11): [True: 0, False: 0]
  ------------------
 2534|      0|    }
 2535|      0|    auto grouping = Grouping(loc, fspecs.locale);
 2536|      0|    size += to_unsigned(grouping.count_separators(exp));
 2537|      0|    return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2538|      0|      if (sign) *it++ = detail::sign<Char>(sign);
 2539|      0|      it = write_significand<Char>(it, significand, significand_size,
 2540|      0|                                   f.exponent, grouping);
 2541|      0|      if (!fspecs.showpoint) return it;
 2542|      0|      *it++ = decimal_point;
 2543|      0|      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
 2544|      0|    });
 2545|  4.86k|  } else if (exp > 0) {
  ------------------
  |  Branch (2545:14): [True: 2.93k, False: 1.93k]
  ------------------
 2546|       |    // 1234e-2 -> 12.34[0+]
 2547|  2.93k|    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
  ------------------
  |  Branch (2547:21): [True: 2.93k, False: 0]
  ------------------
 2548|  2.93k|    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
  ------------------
  |  Branch (2548:29): [True: 0, False: 2.93k]
  ------------------
 2549|  2.93k|    auto grouping = Grouping(loc, fspecs.locale);
 2550|  2.93k|    size += to_unsigned(grouping.count_separators(significand_size));
 2551|  2.93k|    return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2552|  2.93k|      if (sign) *it++ = detail::sign<Char>(sign);
 2553|  2.93k|      it = write_significand(it, significand, significand_size, exp,
 2554|  2.93k|                             decimal_point, grouping);
 2555|  2.93k|      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
 2556|  2.93k|    });
 2557|  2.93k|  }
 2558|       |  // 1234e-6 -> 0.001234
 2559|  1.93k|  int num_zeros = -exp;
 2560|  1.93k|  if (significand_size == 0 && fspecs.precision >= 0 &&
  ------------------
  |  Branch (2560:7): [True: 711, False: 1.22k]
  |  Branch (2560:32): [True: 711, False: 0]
  ------------------
 2561|  1.93k|      fspecs.precision < num_zeros) {
  ------------------
  |  Branch (2561:7): [True: 711, False: 0]
  ------------------
 2562|    711|    num_zeros = fspecs.precision;
 2563|    711|  }
 2564|  1.93k|  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
  ------------------
  |  Branch (2564:17): [True: 1.51k, False: 415]
  |  Branch (2564:35): [True: 415, False: 0]
  |  Branch (2564:60): [True: 0, False: 0]
  ------------------
 2565|  1.93k|  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
  ------------------
  |  Branch (2565:16): [True: 1.93k, False: 0]
  ------------------
 2566|  1.93k|  return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2567|  1.93k|    if (sign) *it++ = detail::sign<Char>(sign);
 2568|  1.93k|    *it++ = zero;
 2569|  1.93k|    if (!pointy) return it;
 2570|  1.93k|    *it++ = decimal_point;
 2571|  1.93k|    it = detail::fill_n(it, num_zeros, zero);
 2572|  1.93k|    return write_significand<Char>(it, significand, significand_size);
 2573|  1.93k|  });
 2574|  4.86k|}
_ZN3fmt2v96detail20get_significand_sizeERKNS1_14big_decimal_fpE:
 2373|  4.86k|constexpr auto get_significand_size(const big_decimal_fp& f) -> int {
 2374|  4.86k|  return f.significand_size;
 2375|  4.86k|}
_ZZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refEENKUlvE_clEv:
 2487|  4.86k|  auto use_exp_format = [=]() {
 2488|  4.86k|    if (fspecs.format == float_format::exp) return true;
  ------------------
  |  Branch (2488:9): [True: 0, False: 4.86k]
  ------------------
 2489|  4.86k|    if (fspecs.format != float_format::general) return false;
  ------------------
  |  Branch (2489:9): [True: 4.86k, False: 0]
  ------------------
 2490|       |    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
 2491|       |    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
 2492|      0|    const int exp_lower = -4, exp_upper = 16;
 2493|      0|    return output_exp < exp_lower ||
  ------------------
  |  Branch (2493:12): [True: 0, False: 0]
  ------------------
 2494|      0|           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
  ------------------
  |  Branch (2494:12): [True: 0, False: 0]
  |  Branch (2494:27): [True: 0, False: 0]
  ------------------
 2495|  4.86k|  };
_ZN3fmt2v96detail17write_significandINS0_8appenderEcEET_S4_PKciiT0_:
 2443|  2.93k|                                     Char decimal_point) -> OutputIt {
 2444|  2.93k|  out = detail::copy_str_noinline<Char>(significand,
 2445|  2.93k|                                        significand + integral_size, out);
 2446|  2.93k|  if (!decimal_point) return out;
  ------------------
  |  Branch (2446:7): [True: 0, False: 2.93k]
  ------------------
 2447|  2.93k|  *out++ = decimal_point;
 2448|  2.93k|  return detail::copy_str_noinline<Char>(significand + integral_size,
 2449|  2.93k|                                         significand + significand_size, out);
 2450|  2.93k|}
_ZN3fmt2v96detail17copy_str_noinlineIcPKcNS0_8appenderEEET1_T0_S7_S6_:
  614|   301k|                                                  OutputIt out) -> OutputIt {
  615|   301k|  return copy_str<OutChar>(begin, end, out);
  616|   301k|}
_ZN3fmt2v96detail17write_significandIcNS0_8appenderEEET0_S4_PKci:
 2383|  1.93k|                                 int significand_size) -> OutputIt {
 2384|  1.93k|  return copy_str<Char>(significand, significand + significand_size, out);
 2385|  1.93k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E1_EESB_SB_SI_mOT2_:
 1700|  2.93k|                            size_t size, F&& f) -> OutputIt {
 1701|  2.93k|  return write_padded<align>(out, specs, size, size, f);
 1702|  2.93k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcRZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E1_EESB_SB_SI_mmOT2_:
 1681|  2.93k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1682|  2.93k|  static_assert(align == align::left || align == align::right, "");
 1683|  2.93k|  unsigned spec_width = to_unsigned(specs.width);
 1684|  2.93k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1684:20): [True: 0, False: 2.93k]
  ------------------
 1685|       |  // Shifts are encoded as string literals because static constexpr is not
 1686|       |  // supported in constexpr functions.
 1687|  2.93k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1687:18): [Folded - Ignored]
  ------------------
 1688|  2.93k|  size_t left_padding = padding >> shifts[specs.align];
 1689|  2.93k|  size_t right_padding = padding - left_padding;
 1690|  2.93k|  auto it = reserve(out, size + padding * specs.fill.size());
 1691|  2.93k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1691:7): [True: 0, False: 2.93k]
  ------------------
 1692|  2.93k|  it = f(it);
 1693|  2.93k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1693:7): [True: 0, False: 2.93k]
  ------------------
 1694|  2.93k|  return base_iterator(out, it);
 1695|  2.93k|}
_ZZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refEENKUlS3_E1_clES3_:
 2551|  2.93k|    return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2552|  2.93k|      if (sign) *it++ = detail::sign<Char>(sign);
  ------------------
  |  Branch (2552:11): [True: 1.72k, False: 1.21k]
  ------------------
 2553|  2.93k|      it = write_significand(it, significand, significand_size, exp,
 2554|  2.93k|                             decimal_point, grouping);
 2555|  2.93k|      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
  ------------------
  |  Branch (2555:14): [True: 0, False: 2.93k]
  ------------------
 2556|  2.93k|    });
_ZN3fmt2v96detail17write_significandINS0_8appenderEcPKcNS1_14digit_groupingIcEEEET_S8_T1_iiT0_RKT2_:
 2456|  2.93k|                                       const Grouping& grouping) -> OutputIt {
 2457|  2.93k|  if (!grouping.has_separator()) {
  ------------------
  |  Branch (2457:7): [True: 2.93k, False: 0]
  ------------------
 2458|  2.93k|    return write_significand(out, significand, significand_size, integral_size,
 2459|  2.93k|                             decimal_point);
 2460|  2.93k|  }
 2461|      0|  auto buffer = basic_memory_buffer<Char>();
 2462|      0|  write_significand(buffer_appender<Char>(buffer), significand,
 2463|      0|                    significand_size, integral_size, decimal_point);
 2464|      0|  grouping.apply(
 2465|      0|      out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));
 2466|      0|  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,
 2467|      0|                                         buffer.end(), out);
 2468|  2.93k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E2_EESB_SB_SI_mOT2_:
 1700|  1.93k|                            size_t size, F&& f) -> OutputIt {
 1701|  1.93k|  return write_padded<align>(out, specs, size, size, f);
 1702|  1.93k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcRZNS1_14do_write_floatIS5_NS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_SA_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refEEUlS5_E2_EESB_SB_SI_mmOT2_:
 1681|  1.93k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1682|  1.93k|  static_assert(align == align::left || align == align::right, "");
 1683|  1.93k|  unsigned spec_width = to_unsigned(specs.width);
 1684|  1.93k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1684:20): [True: 0, False: 1.93k]
  ------------------
 1685|       |  // Shifts are encoded as string literals because static constexpr is not
 1686|       |  // supported in constexpr functions.
 1687|  1.93k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1687:18): [Folded - Ignored]
  ------------------
 1688|  1.93k|  size_t left_padding = padding >> shifts[specs.align];
 1689|  1.93k|  size_t right_padding = padding - left_padding;
 1690|  1.93k|  auto it = reserve(out, size + padding * specs.fill.size());
 1691|  1.93k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1691:7): [True: 0, False: 1.93k]
  ------------------
 1692|  1.93k|  it = f(it);
 1693|  1.93k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1693:7): [True: 0, False: 1.93k]
  ------------------
 1694|  1.93k|  return base_iterator(out, it);
 1695|  1.93k|}
_ZZN3fmt2v96detail14do_write_floatINS0_8appenderENS1_14big_decimal_fpEcNS1_14digit_groupingIcEEEET_S7_RKT0_RKNS0_12format_specsIT1_EENS1_11float_specsENS1_10locale_refEENKUlS3_E2_clES3_:
 2566|  1.93k|  return write_padded<align::right>(out, specs, size, [&](iterator it) {
 2567|  1.93k|    if (sign) *it++ = detail::sign<Char>(sign);
  ------------------
  |  Branch (2567:9): [True: 822, False: 1.10k]
  ------------------
 2568|  1.93k|    *it++ = zero;
 2569|  1.93k|    if (!pointy) return it;
  ------------------
  |  Branch (2569:9): [True: 0, False: 1.93k]
  ------------------
 2570|  1.93k|    *it++ = decimal_point;
 2571|  1.93k|    it = detail::fill_n(it, num_zeros, zero);
 2572|  1.93k|    return write_significand<Char>(it, significand, significand_size);
 2573|  1.93k|  });
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EE:
 3475|   295k|    -> OutputIt {
 3476|   295k|  auto it = reserve(out, value.size());
 3477|   295k|  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
 3478|   295k|  return base_iterator(out, it);
 3479|   295k|}
_ZN3fmt2v96detail12count_digitsILi4EmEEiT0_:
 1186|  54.4k|FMT_CONSTEXPR auto count_digits(UInt n) -> int {
 1187|  54.4k|#ifdef FMT_BUILTIN_CLZ
 1188|  54.4k|  if (!is_constant_evaluated() && num_bits<UInt>() == 32)
  ------------------
  |  Branch (1188:7): [Folded - Ignored]
  |  Branch (1188:35): [Folded - Ignored]
  ------------------
 1189|      0|    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
  ------------------
  |  |  145|      0|#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
  ------------------
 1190|  54.4k|#endif
 1191|       |  // Lambda avoids unreachable code warnings from NVHPC.
 1192|  54.4k|  return [](UInt m) {
 1193|  54.4k|    int num_digits = 0;
 1194|  54.4k|    do {
 1195|  54.4k|      ++num_digits;
 1196|  54.4k|    } while ((m >>= BITS) != 0);
 1197|  54.4k|    return num_digits;
 1198|  54.4k|  }(n);
 1199|  54.4k|}
_ZZN3fmt2v96detail12count_digitsILi4EmEEiT0_ENKUlmE_clEm:
 1192|  54.4k|  return [](UInt m) {
 1193|  54.4k|    int num_digits = 0;
 1194|   436k|    do {
 1195|   436k|      ++num_digits;
 1196|   436k|    } while ((m >>= BITS) != 0);
  ------------------
  |  Branch (1196:14): [True: 382k, False: 54.4k]
  ------------------
 1197|  54.4k|    return num_digits;
 1198|  54.4k|  }(n);
_ZN3fmt2v96detail11format_uintILj4EcNS0_8appenderEmEET1_S4_T2_ib:
 1344|  54.4k|    -> It {
 1345|  54.4k|  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
  ------------------
  |  Branch (1345:12): [True: 54.4k, False: 0]
  ------------------
 1346|  54.4k|    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
 1347|  54.4k|    return out;
 1348|  54.4k|  }
 1349|       |  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
 1350|      0|  char buffer[num_bits<UInt>() / BASE_BITS + 1];
 1351|      0|  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
 1352|      0|  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
 1353|  54.4k|}
_ZN3fmt2v96detail11format_uintILj4EcmEEPT0_S4_T1_ib:
 1330|  54.4k|                               bool upper = false) -> Char* {
 1331|  54.4k|  buffer += num_digits;
 1332|  54.4k|  Char* end = buffer;
 1333|   436k|  do {
 1334|   436k|    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
  ------------------
  |  Branch (1334:26): [True: 436k, False: 0]
  ------------------
 1335|   436k|    unsigned digit = static_cast<unsigned>(value & ((1 << BASE_BITS) - 1));
 1336|   436k|    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
  ------------------
  |  Branch (1336:35): [Folded - Ignored]
  ------------------
 1337|   436k|                                                : digits[digit]);
 1338|   436k|  } while ((value >>= BASE_BITS) != 0);
  ------------------
  |  Branch (1338:12): [True: 382k, False: 54.4k]
  ------------------
 1339|  54.4k|  return end;
 1340|  54.4k|}
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler7on_textEPKcSF_:
 4175|   295k|    void on_text(const Char* begin, const Char* end) {
 4176|   295k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4177|   295k|      context.advance_to(write<Char>(context.out(), text));
 4178|   295k|    }
_ZN3fmt2v96detail7get_argINS0_20basic_format_contextINS0_8appenderEcEEiEENT_10format_argERS6_T0_:
 3658|   180k|    typename Context::format_arg {
 3659|   180k|  auto arg = ctx.arg(id);
 3660|   180k|  if (!arg) ctx.on_error("argument not found");
  ------------------
  |  Branch (3660:7): [True: 0, False: 180k]
  ------------------
 3661|   180k|  return arg;
 3662|   180k|}
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler9on_arg_idEv:
 4180|  63.5k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4181|  63.5k|      return parse_context.next_arg_id();
 4182|  63.5k|    }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler9on_arg_idEi:
 4183|   116k|    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
 4184|   116k|      return parse_context.check_arg_id(id), id;
 4185|   116k|    }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler15on_format_specsEiPKcSF_:
 4201|   180k|        -> const Char* {
 4202|   180k|      auto arg = get_arg(context, id);
 4203|   180k|      if (arg.type() == type::custom_type) {
  ------------------
  |  Branch (4203:11): [True: 0, False: 180k]
  ------------------
 4204|      0|        parse_context.advance_to(begin);
 4205|      0|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4206|      0|        return parse_context.begin();
 4207|      0|      }
 4208|   180k|      auto specs = detail::dynamic_format_specs<Char>();
 4209|   180k|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4210|   180k|      detail::handle_dynamic_spec<detail::width_checker>(
 4211|   180k|          specs.width, specs.width_ref, context);
 4212|   180k|      detail::handle_dynamic_spec<detail::precision_checker>(
 4213|   180k|          specs.precision, specs.precision_ref, context);
 4214|   180k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (4214:11): [True: 0, False: 180k]
  |  Branch (4214:27): [True: 0, False: 180k]
  ------------------
 4215|      0|        on_error("missing '}' in format string");
 4216|   180k|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4217|   180k|      context.advance_to(visit_format_arg(f, arg));
 4218|   180k|      return begin;
 4219|   180k|    }
_ZN3fmt2v96detail19handle_dynamic_specINS1_13width_checkerENS0_20basic_format_contextINS0_8appenderEcEEEEvRiNS1_7arg_refINT0_9char_typeEEERS9_:
 3667|   180k|                                       Context& ctx) {
 3668|   180k|  switch (ref.kind) {
  ------------------
  |  Branch (3668:11): [True: 0, False: 180k]
  ------------------
 3669|   180k|  case arg_id_kind::none:
  ------------------
  |  Branch (3669:3): [True: 180k, False: 0]
  ------------------
 3670|   180k|    break;
 3671|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (3671:3): [True: 0, False: 180k]
  ------------------
 3672|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index),
 3673|      0|                                              ctx.error_handler());
 3674|      0|    break;
 3675|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (3675:3): [True: 0, False: 180k]
  ------------------
 3676|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name),
 3677|      0|                                              ctx.error_handler());
 3678|      0|    break;
 3679|   180k|  }
 3680|   180k|}
_ZN3fmt2v96detail19handle_dynamic_specINS1_17precision_checkerENS0_20basic_format_contextINS0_8appenderEcEEEEvRiNS1_7arg_refINT0_9char_typeEEERS9_:
 3667|   180k|                                       Context& ctx) {
 3668|   180k|  switch (ref.kind) {
  ------------------
  |  Branch (3668:11): [True: 0, False: 180k]
  ------------------
 3669|   180k|  case arg_id_kind::none:
  ------------------
  |  Branch (3669:3): [True: 180k, False: 0]
  ------------------
 3670|   180k|    break;
 3671|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (3671:3): [True: 0, False: 180k]
  ------------------
 3672|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index),
 3673|      0|                                              ctx.error_handler());
 3674|      0|    break;
 3675|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (3675:3): [True: 0, False: 180k]
  ------------------
 3676|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name),
 3677|      0|                                              ctx.error_handler());
 3678|      0|    break;
 3679|   180k|  }
 3680|   180k|}
_ZN3fmt2v96detail13arg_formatterIcEclIiEENS0_8appenderET_:
 3587|  2.90k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3588|  2.90k|    return detail::write(out, value, specs, locale);
 3589|  2.90k|  }
_ZN3fmt2v96detail13arg_formatterIcEclIjEENS0_8appenderET_:
 3587|  4.76k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3588|  4.76k|    return detail::write(out, value, specs, locale);
 3589|  4.76k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEjLi0EEET0_S4_T1_RKNS0_12format_specsIT_EENS1_10locale_refE:
 2169|  4.76k|                                    locale_ref loc) -> OutputIt {
 2170|  4.76k|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2170:7): [True: 0, False: 4.76k]
  |  Branch (2170:26): [True: 0, False: 0]
  ------------------
 2171|  4.76k|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2172|  4.76k|                            loc);
 2173|  4.76k|}
_ZN3fmt2v96detail18make_write_int_argIjEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2066|  4.76k|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2067|  4.76k|  auto prefix = 0u;
 2068|  4.76k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2069|  4.76k|  if (is_negative(value)) {
  ------------------
  |  Branch (2069:7): [True: 0, False: 4.76k]
  ------------------
 2070|      0|    prefix = 0x01000000 | '-';
 2071|      0|    abs_value = 0 - abs_value;
 2072|  4.76k|  } else {
 2073|  4.76k|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2074|  4.76k|                                            0x1000000u | ' '};
 2075|  4.76k|    prefix = prefixes[sign];
 2076|  4.76k|  }
 2077|  4.76k|  return {abs_value, prefix};
 2078|  4.76k|}
_ZN3fmt2v96detail18write_int_noinlineIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2160|   108k|    locale_ref loc) -> OutputIt {
 2161|   108k|  return write_int(out, arg, specs, loc);
 2162|   108k|}
_ZN3fmt2v96detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2104|   108k|                                        locale_ref) -> OutputIt {
 2105|   108k|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2106|   108k|  auto abs_value = arg.abs_value;
 2107|   108k|  auto prefix = arg.prefix;
 2108|   108k|  switch (specs.type) {
 2109|      0|  case presentation_type::none:
  ------------------
  |  Branch (2109:3): [True: 0, False: 108k]
  ------------------
 2110|  54.4k|  case presentation_type::dec: {
  ------------------
  |  Branch (2110:3): [True: 54.4k, False: 54.4k]
  ------------------
 2111|  54.4k|    auto num_digits = count_digits(abs_value);
 2112|  54.4k|    return write_int(
 2113|  54.4k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2114|  54.4k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2115|  54.4k|        });
 2116|      0|  }
 2117|      0|  case presentation_type::hex_lower:
  ------------------
  |  Branch (2117:3): [True: 0, False: 108k]
  ------------------
 2118|  54.4k|  case presentation_type::hex_upper: {
  ------------------
  |  Branch (2118:3): [True: 54.4k, False: 54.4k]
  ------------------
 2119|  54.4k|    bool upper = specs.type == presentation_type::hex_upper;
 2120|  54.4k|    if (specs.alt)
  ------------------
  |  Branch (2120:9): [True: 0, False: 54.4k]
  ------------------
 2121|      0|      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2121:38): [True: 0, False: 0]
  ------------------
 2122|  54.4k|    int num_digits = count_digits<4>(abs_value);
 2123|  54.4k|    return write_int(
 2124|  54.4k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2125|  54.4k|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2126|  54.4k|        });
 2127|      0|  }
 2128|      0|  case presentation_type::bin_lower:
  ------------------
  |  Branch (2128:3): [True: 0, False: 108k]
  ------------------
 2129|      0|  case presentation_type::bin_upper: {
  ------------------
  |  Branch (2129:3): [True: 0, False: 108k]
  ------------------
 2130|      0|    bool upper = specs.type == presentation_type::bin_upper;
 2131|      0|    if (specs.alt)
  ------------------
  |  Branch (2131:9): [True: 0, False: 0]
  ------------------
 2132|      0|      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2132:38): [True: 0, False: 0]
  ------------------
 2133|      0|    int num_digits = count_digits<1>(abs_value);
 2134|      0|    return write_int(out, num_digits, prefix, specs,
 2135|      0|                     [=](reserve_iterator<OutputIt> it) {
 2136|      0|                       return format_uint<1, Char>(it, abs_value, num_digits);
 2137|      0|                     });
 2138|      0|  }
 2139|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2139:3): [True: 0, False: 108k]
  ------------------
 2140|      0|    int num_digits = count_digits<3>(abs_value);
 2141|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2142|       |    // is not greater than the number of digits.
 2143|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2143:9): [True: 0, False: 0]
  |  Branch (2143:22): [True: 0, False: 0]
  |  Branch (2143:55): [True: 0, False: 0]
  ------------------
 2144|      0|      prefix_append(prefix, '0');
 2145|      0|    return write_int(out, num_digits, prefix, specs,
 2146|      0|                     [=](reserve_iterator<OutputIt> it) {
 2147|      0|                       return format_uint<3, Char>(it, abs_value, num_digits);
 2148|      0|                     });
 2149|      0|  }
 2150|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2150:3): [True: 0, False: 108k]
  ------------------
 2151|      0|    return write_char(out, static_cast<Char>(abs_value), specs);
 2152|      0|  default:
  ------------------
  |  Branch (2152:3): [True: 0, False: 108k]
  ------------------
 2153|      0|    throw_format_error("invalid format specifier");
 2154|   108k|  }
 2155|      0|  return out;
 2156|   108k|}
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_mEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E_EESA_SA_ijRKNS9_IS5_EES7_:
 1939|  54.4k|                                        W write_digits) -> OutputIt {
 1940|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1941|  54.4k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1941:7): [True: 54.4k, False: 0]
  ------------------
 1942|  54.4k|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1943|  54.4k|    if (prefix != 0) {
  ------------------
  |  Branch (1943:9): [True: 0, False: 54.4k]
  ------------------
 1944|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1944:44): [True: 0, False: 0]
  ------------------
 1945|      0|        *it++ = static_cast<Char>(p & 0xff);
 1946|      0|    }
 1947|  54.4k|    return base_iterator(out, write_digits(it));
 1948|  54.4k|  }
 1949|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1950|      0|  return write_padded<align::right>(
 1951|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1952|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1953|      0|          *it++ = static_cast<Char>(p & 0xff);
 1954|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1955|      0|        return write_digits(it);
 1956|      0|      });
 1957|  54.4k|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEENKUlS3_E_clES3_:
 2113|  54.4k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2114|  54.4k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2115|  54.4k|        });
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_mEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E0_EESA_SA_ijRKNS9_IS5_EES7_:
 1939|  54.4k|                                        W write_digits) -> OutputIt {
 1940|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1941|  54.4k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1941:7): [True: 0, False: 54.4k]
  ------------------
 1942|      0|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1943|      0|    if (prefix != 0) {
  ------------------
  |  Branch (1943:9): [True: 0, False: 0]
  ------------------
 1944|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1944:44): [True: 0, False: 0]
  ------------------
 1945|      0|        *it++ = static_cast<Char>(p & 0xff);
 1946|      0|    }
 1947|      0|    return base_iterator(out, write_digits(it));
 1948|      0|  }
 1949|  54.4k|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1950|  54.4k|  return write_padded<align::right>(
 1951|  54.4k|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1952|  54.4k|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1953|  54.4k|          *it++ = static_cast<Char>(p & 0xff);
 1954|  54.4k|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1955|  54.4k|        return write_digits(it);
 1956|  54.4k|      });
 1957|  54.4k|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEENKUlS3_E0_clES3_:
 2124|  54.4k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2125|  54.4k|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2126|  54.4k|        });
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcZNS1_9write_intIS5_cZNS1_9write_intIcS5_mEET0_S8_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS5_E0_EESD_SD_ijRKNSC_IS8_EESA_EUlS5_E_EES8_S8_RKNSC_ISA_EEmOT2_:
 1700|  54.4k|                            size_t size, F&& f) -> OutputIt {
 1701|  54.4k|  return write_padded<align>(out, specs, size, size, f);
 1702|  54.4k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE2ENS0_8appenderEcRZNS1_9write_intIS5_cZNS1_9write_intIcS5_mEET0_S8_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS5_E0_EESD_SD_ijRKNSC_IS8_EESA_EUlS5_E_EES8_S8_RKNSC_ISA_EEmmOT2_:
 1681|  54.4k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1682|  54.4k|  static_assert(align == align::left || align == align::right, "");
 1683|  54.4k|  unsigned spec_width = to_unsigned(specs.width);
 1684|  54.4k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1684:20): [True: 0, False: 54.4k]
  ------------------
 1685|       |  // Shifts are encoded as string literals because static constexpr is not
 1686|       |  // supported in constexpr functions.
 1687|  54.4k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1687:18): [Folded - Ignored]
  ------------------
 1688|  54.4k|  size_t left_padding = padding >> shifts[specs.align];
 1689|  54.4k|  size_t right_padding = padding - left_padding;
 1690|  54.4k|  auto it = reserve(out, size + padding * specs.fill.size());
 1691|  54.4k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1691:7): [True: 0, False: 54.4k]
  ------------------
 1692|  54.4k|  it = f(it);
 1693|  54.4k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1693:7): [True: 0, False: 54.4k]
  ------------------
 1694|  54.4k|  return base_iterator(out, it);
 1695|  54.4k|}
_ZZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_mEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E0_EESA_SA_ijRKNS9_IS5_EES7_ENKUlS3_E_clES3_:
 1951|  54.4k|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1952|  54.4k|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1952:46): [True: 0, False: 54.4k]
  ------------------
 1953|      0|          *it++ = static_cast<Char>(p & 0xff);
 1954|  54.4k|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1955|  54.4k|        return write_digits(it);
 1956|  54.4k|      });
_ZN3fmt2v96detail13arg_formatterIcEclIyEENS0_8appenderET_:
 3587|   108k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3588|   108k|    return detail::write(out, value, specs, locale);
 3589|   108k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEyLi0EEET0_S4_T1_RKNS0_12format_specsIT_EENS1_10locale_refE:
 2169|   108k|                                    locale_ref loc) -> OutputIt {
 2170|   108k|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2170:7): [True: 0, False: 108k]
  |  Branch (2170:26): [True: 0, False: 0]
  ------------------
 2171|   108k|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2172|   108k|                            loc);
 2173|   108k|}
_ZN3fmt2v96detail18make_write_int_argIyEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2066|   108k|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2067|   108k|  auto prefix = 0u;
 2068|   108k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2069|   108k|  if (is_negative(value)) {
  ------------------
  |  Branch (2069:7): [True: 0, False: 108k]
  ------------------
 2070|      0|    prefix = 0x01000000 | '-';
 2071|      0|    abs_value = 0 - abs_value;
 2072|   108k|  } else {
 2073|   108k|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2074|   108k|                                            0x1000000u | ' '};
 2075|   108k|    prefix = prefixes[sign];
 2076|   108k|  }
 2077|   108k|  return {abs_value, prefix};
 2078|   108k|}
_ZN3fmt2v96detail13arg_formatterIcEclIfEENS0_8appenderET_:
 3587|  1.99k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3588|  1.99k|    return detail::write(out, value, specs, locale);
 3589|  1.99k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEfLi0EEET0_S4_T1_NS0_12format_specsIT_EENS1_10locale_refE:
 3429|  1.99k|                           locale_ref loc = {}) -> OutputIt {
 3430|  1.99k|  if (const_check(!is_supported_floating_point(value))) return out;
  ------------------
  |  Branch (3430:7): [True: 0, False: 1.99k]
  ------------------
 3431|  1.99k|  return specs.localized && write_loc(out, value, specs, loc)
  ------------------
  |  Branch (3431:10): [True: 0, False: 1.99k]
  |  Branch (3431:29): [True: 0, False: 0]
  ------------------
 3432|  1.99k|             ? out
 3433|  1.99k|             : write_float(out, value, specs, loc);
 3434|  1.99k|}
_ZN3fmt2v96detail11write_floatIcNS0_8appenderEfEET0_S4_T1_NS0_12format_specsIT_EENS1_10locale_refE:
 3380|  1.99k|    -> OutputIt {
 3381|  1.99k|  float_specs fspecs = parse_float_type_spec(specs);
 3382|  1.99k|  fspecs.sign = specs.sign;
 3383|  1.99k|  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
  ------------------
  |  Branch (3383:7): [True: 1.08k, False: 913]
  ------------------
 3384|  1.08k|    fspecs.sign = sign::minus;
 3385|  1.08k|    value = -value;
 3386|  1.08k|  } else if (fspecs.sign == sign::minus) {
  ------------------
  |  Branch (3386:14): [True: 0, False: 913]
  ------------------
 3387|      0|    fspecs.sign = sign::none;
 3388|      0|  }
 3389|       |
 3390|  1.99k|  if (!detail::isfinite(value))
  ------------------
  |  Branch (3390:7): [True: 149, False: 1.84k]
  ------------------
 3391|    149|    return write_nonfinite(out, detail::isnan(value), specs, fspecs);
 3392|       |
 3393|  1.84k|  if (specs.align == align::numeric && fspecs.sign) {
  ------------------
  |  Branch (3393:7): [True: 0, False: 1.84k]
  |  Branch (3393:40): [True: 0, False: 0]
  ------------------
 3394|      0|    auto it = reserve(out, 1);
 3395|      0|    *it++ = detail::sign<Char>(fspecs.sign);
 3396|      0|    out = base_iterator(out, it);
 3397|      0|    fspecs.sign = sign::none;
 3398|      0|    if (specs.width != 0) --specs.width;
  ------------------
  |  Branch (3398:9): [True: 0, False: 0]
  ------------------
 3399|      0|  }
 3400|       |
 3401|  1.84k|  memory_buffer buffer;
 3402|  1.84k|  if (fspecs.format == float_format::hex) {
  ------------------
  |  Branch (3402:7): [True: 0, False: 1.84k]
  ------------------
 3403|      0|    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
  ------------------
  |  Branch (3403:9): [True: 0, False: 0]
  ------------------
 3404|      0|    format_hexfloat(convert_float(value), specs.precision, fspecs, buffer);
 3405|      0|    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
 3406|      0|                                     specs);
 3407|      0|  }
 3408|  1.84k|  int precision = specs.precision >= 0 || specs.type == presentation_type::none
  ------------------
  |  Branch (3408:19): [True: 0, False: 1.84k]
  |  Branch (3408:43): [True: 0, False: 1.84k]
  ------------------
 3409|  1.84k|                      ? specs.precision
 3410|  1.84k|                      : 6;
 3411|  1.84k|  if (fspecs.format == float_format::exp) {
  ------------------
  |  Branch (3411:7): [True: 0, False: 1.84k]
  ------------------
 3412|      0|    if (precision == max_value<int>())
  ------------------
  |  Branch (3412:9): [True: 0, False: 0]
  ------------------
 3413|      0|      throw_format_error("number is too big");
 3414|      0|    else
 3415|      0|      ++precision;
 3416|  1.84k|  } else if (fspecs.format != float_format::fixed && precision == 0) {
  ------------------
  |  Branch (3416:14): [True: 0, False: 1.84k]
  |  Branch (3416:54): [True: 0, False: 0]
  ------------------
 3417|      0|    precision = 1;
 3418|      0|  }
 3419|  1.84k|  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
  ------------------
  |  Branch (3419:7): [Folded - Ignored]
  ------------------
 3420|  1.84k|  int exp = format_float(convert_float(value), precision, fspecs, buffer);
 3421|  1.84k|  fspecs.precision = precision;
 3422|  1.84k|  auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
 3423|  1.84k|  return write_float(out, f, specs, fspecs, loc);
 3424|  1.84k|}
_ZN3fmt2v96detail8isfiniteIfLi0EEEbT_:
 2617|  1.99k|FMT_CONSTEXPR20 bool isfinite(T value) {
 2618|  1.99k|  constexpr T inf = T(std::numeric_limits<double>::infinity());
 2619|  1.99k|  if (is_constant_evaluated())
  ------------------
  |  Branch (2619:7): [Folded - Ignored]
  ------------------
 2620|      0|    return !detail::isnan(value) && value < inf && value > -inf;
  ------------------
  |  Branch (2620:12): [True: 0, False: 0]
  |  Branch (2620:37): [True: 0, False: 0]
  |  Branch (2620:52): [True: 0, False: 0]
  ------------------
 2621|  1.99k|  return std::isfinite(value);
 2622|  1.99k|}
_ZN3fmt2v96detail5isnanIfEEbT_:
 2604|    149|template <typename T> constexpr bool isnan(T value) {
 2605|    149|  return !(value >= value);  // std::isnan doesn't support __float128.
 2606|    149|}
_ZN3fmt2v96detail13convert_floatIfEENSt3__111conditionalIXoosr3std7is_sameIT_fEE5valueeqsr3std14numeric_limitsIS5_EE6digitsL_ZNS3_14numeric_limitsIdE6digitsEEEdS5_E4typeES5_:
 1660|  1.84k|constexpr auto convert_float(T value) -> convert_float_result<T> {
 1661|  1.84k|  return static_cast<convert_float_result<T>>(value);
 1662|  1.84k|}
_ZN3fmt2v96detail12format_floatIdEEiT_iNS1_11float_specsERNS1_6bufferIcEE:
 3292|  4.86k|                                  buffer<char>& buf) -> int {
 3293|       |  // float is passed as double to reduce the number of instantiations.
 3294|  4.86k|  static_assert(!std::is_same<Float, float>::value, "");
 3295|  4.86k|  FMT_ASSERT(value >= 0, "value is negative");
  ------------------
  |  |  352|  4.86k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 3296|  4.86k|  auto converted_value = convert_float(value);
 3297|       |
 3298|  4.86k|  const bool fixed = specs.format == float_format::fixed;
 3299|  4.86k|  if (value <= 0) {  // <= instead of == to silence a warning.
  ------------------
  |  Branch (3299:7): [True: 280, False: 4.58k]
  ------------------
 3300|    280|    if (precision <= 0 || !fixed) {
  ------------------
  |  Branch (3300:9): [True: 0, False: 280]
  |  Branch (3300:27): [True: 0, False: 280]
  ------------------
 3301|      0|      buf.push_back('0');
 3302|      0|      return 0;
 3303|      0|    }
 3304|    280|    buf.try_resize(to_unsigned(precision));
 3305|    280|    fill_n(buf.data(), precision, '0');
 3306|    280|    return -precision;
 3307|    280|  }
 3308|       |
 3309|  4.58k|  int exp = 0;
 3310|  4.58k|  bool use_dragon = true;
 3311|  4.58k|  unsigned dragon_flags = 0;
 3312|  4.58k|  if (!is_fast_float<Float>()) {
  ------------------
  |  Branch (3312:7): [Folded - Ignored]
  ------------------
 3313|      0|    const auto inv_log2_10 = 0.3010299956639812;  // 1 / log2(10)
 3314|      0|    using info = dragonbox::float_info<decltype(converted_value)>;
 3315|      0|    const auto f = basic_fp<typename info::carrier_uint>(converted_value);
 3316|       |    // Compute exp, an approximate power of 10, such that
 3317|       |    //   10^(exp - 1) <= value < 10^exp or 10^exp <= value < 10^(exp + 1).
 3318|       |    // This is based on log10(value) == log2(value) / log2(10) and approximation
 3319|       |    // of log2(value) by e + num_fraction_bits idea from double-conversion.
 3320|      0|    exp = static_cast<int>(
 3321|      0|        std::ceil((f.e + count_digits<1>(f.f) - 1) * inv_log2_10 - 1e-10));
 3322|      0|    dragon_flags = dragon::fixup;
 3323|  4.58k|  } else if (!is_constant_evaluated() && precision < 0) {
  ------------------
  |  Branch (3323:14): [Folded - Ignored]
  |  Branch (3323:42): [True: 0, False: 4.58k]
  ------------------
 3324|       |    // Use Dragonbox for the shortest format.
 3325|      0|    if (specs.binary32) {
  ------------------
  |  Branch (3325:9): [True: 0, False: 0]
  ------------------
 3326|      0|      auto dec = dragonbox::to_decimal(static_cast<float>(value));
 3327|      0|      write<char>(buffer_appender<char>(buf), dec.significand);
 3328|      0|      return dec.exponent;
 3329|      0|    }
 3330|      0|    auto dec = dragonbox::to_decimal(static_cast<double>(value));
 3331|      0|    write<char>(buffer_appender<char>(buf), dec.significand);
 3332|      0|    return dec.exponent;
 3333|  4.58k|  } else {
 3334|       |    // Use Grisu + Dragon4 for the given precision:
 3335|       |    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.
 3336|  4.58k|    const int min_exp = -60;  // alpha in Grisu.
 3337|  4.58k|    int cached_exp10 = 0;     // K in Grisu.
 3338|  4.58k|    fp normalized = normalize(fp(converted_value));
 3339|  4.58k|    const auto cached_pow = get_cached_power(
 3340|  4.58k|        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);
 3341|  4.58k|    normalized = normalized * cached_pow;
 3342|  4.58k|    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
 3343|  4.58k|    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&
  ------------------
  |  Branch (3343:9): [True: 1.46k, False: 3.11k]
  ------------------
 3344|  4.58k|        !is_constant_evaluated()) {
  ------------------
  |  Branch (3344:9): [Folded - Ignored]
  ------------------
 3345|  1.46k|      exp += handler.exp10;
 3346|  1.46k|      buf.try_resize(to_unsigned(handler.size));
 3347|  1.46k|      use_dragon = false;
 3348|  3.11k|    } else {
 3349|  3.11k|      exp += handler.size - cached_exp10 - 1;
 3350|  3.11k|      precision = handler.precision;
 3351|  3.11k|    }
 3352|  4.58k|  }
 3353|  4.58k|  if (use_dragon) {
  ------------------
  |  Branch (3353:7): [True: 3.11k, False: 1.46k]
  ------------------
 3354|  3.11k|    auto f = basic_fp<uint128_t>();
 3355|  3.11k|    bool is_predecessor_closer = specs.binary32
  ------------------
  |  Branch (3355:34): [True: 1.08k, False: 2.03k]
  ------------------
 3356|  3.11k|                                     ? f.assign(static_cast<float>(value))
 3357|  3.11k|                                     : f.assign(converted_value);
 3358|  3.11k|    if (is_predecessor_closer) dragon_flags |= dragon::predecessor_closer;
  ------------------
  |  Branch (3358:9): [True: 690, False: 2.42k]
  ------------------
 3359|  3.11k|    if (fixed) dragon_flags |= dragon::fixed;
  ------------------
  |  Branch (3359:9): [True: 3.11k, False: 0]
  ------------------
 3360|       |    // Limit precision to the maximum possible number of significant digits in
 3361|       |    // an IEEE754 double because we don't need to generate zeros.
 3362|  3.11k|    const int max_double_digits = 767;
 3363|  3.11k|    if (precision > max_double_digits) precision = max_double_digits;
  ------------------
  |  Branch (3363:9): [True: 0, False: 3.11k]
  ------------------
 3364|  3.11k|    format_dragon(f, dragon_flags, precision, buf, exp);
 3365|  3.11k|  }
 3366|  4.58k|  if (!fixed && !specs.showpoint) {
  ------------------
  |  Branch (3366:7): [True: 0, False: 4.58k]
  |  Branch (3366:17): [True: 0, False: 0]
  ------------------
 3367|       |    // Remove trailing zeros.
 3368|      0|    auto num_digits = buf.size();
 3369|      0|    while (num_digits > 0 && buf[num_digits - 1] == '0') {
  ------------------
  |  Branch (3369:12): [True: 0, False: 0]
  |  Branch (3369:30): [True: 0, False: 0]
  ------------------
 3370|      0|      --num_digits;
 3371|      0|      ++exp;
 3372|      0|    }
 3373|      0|    buf.try_resize(num_digits);
 3374|      0|  }
 3375|  4.58k|  return exp;
 3376|  4.58k|}
_ZN3fmt2v96detail13convert_floatIdEENSt3__111conditionalIXoosr3std7is_sameIT_fEE5valueeqsr3std14numeric_limitsIS5_EE6digitsL_ZNS3_14numeric_limitsIdE6digitsEEEdS5_E4typeES5_:
 1660|  7.88k|constexpr auto convert_float(T value) -> convert_float_result<T> {
 1661|  7.88k|  return static_cast<convert_float_result<T>>(value);
 1662|  7.88k|}
_ZN3fmt2v96detail9normalizeILi0EyEENS1_8basic_fpIT0_EES5_:
 1522|  4.58k|FMT_CONSTEXPR basic_fp<F> normalize(basic_fp<F> value) {
 1523|       |  // Handle subnormals.
 1524|  4.58k|  const auto implicit_bit = F(1) << num_significand_bits<double>();
 1525|  4.58k|  const auto shifted_implicit_bit = implicit_bit << SHIFT;
 1526|  10.2k|  while ((value.f & shifted_implicit_bit) == 0) {
  ------------------
  |  Branch (1526:10): [True: 5.62k, False: 4.58k]
  ------------------
 1527|  5.62k|    value.f <<= 1;
 1528|  5.62k|    --value.e;
 1529|  5.62k|  }
 1530|       |  // Subtract 1 to account for hidden bit.
 1531|  4.58k|  const auto offset = basic_fp<F>::num_significand_bits -
 1532|  4.58k|                      num_significand_bits<double>() - SHIFT - 1;
 1533|  4.58k|  value.f <<= offset;
 1534|  4.58k|  value.e -= offset;
 1535|  4.58k|  return value;
 1536|  4.58k|}
_ZN3fmt2v96detail8basic_fpIyEC2IdEET_:
 1483|  4.58k|  template <typename Float> FMT_CONSTEXPR basic_fp(Float n) { assign(n); }
_ZN3fmt2v96detail8basic_fpIyE6assignIdLi0EEEbT_:
 1487|  4.58k|  FMT_CONSTEXPR auto assign(Float n) -> bool {
 1488|  4.58k|    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
 1489|       |    // Assume Float is in the format [sign][exponent][significand].
 1490|  4.58k|    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1491|  4.58k|    const auto num_float_significand_bits =
 1492|  4.58k|        detail::num_significand_bits<Float>();
 1493|  4.58k|    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
 1494|  4.58k|    const auto significand_mask = implicit_bit - 1;
 1495|  4.58k|    auto u = bit_cast<carrier_uint>(n);
 1496|  4.58k|    f = static_cast<F>(u & significand_mask);
 1497|  4.58k|    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
 1498|  4.58k|                                     num_float_significand_bits);
 1499|       |    // The predecessor is closer if n is a normalized power of 2 (f == 0)
 1500|       |    // other than the smallest normalized number (biased_e > 1).
 1501|  4.58k|    auto is_predecessor_closer = f == 0 && biased_e > 1;
  ------------------
  |  Branch (1501:34): [True: 711, False: 3.87k]
  |  Branch (1501:44): [True: 711, False: 0]
  ------------------
 1502|  4.58k|    if (biased_e == 0)
  ------------------
  |  Branch (1502:9): [True: 263, False: 4.32k]
  ------------------
 1503|    263|      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
 1504|  4.32k|    else if (has_implicit_bit<Float>())
  ------------------
  |  Branch (1504:14): [Folded - Ignored]
  ------------------
 1505|  4.32k|      f += static_cast<F>(implicit_bit);
 1506|  4.58k|    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
 1507|  4.58k|    if (!has_implicit_bit<Float>()) ++e;
  ------------------
  |  Branch (1507:9): [Folded - Ignored]
  ------------------
 1508|  4.58k|    return is_predecessor_closer;
 1509|  4.58k|  }
_ZN3fmt2v96detail16get_cached_powerEiRi:
 1631|  4.58k|                                         int& pow10_exponent) {
 1632|  4.58k|  const int shift = 32;
 1633|       |  // log10(2) = 0x0.4d104d427de7fbcc...
 1634|  4.58k|  const int64_t significand = 0x4d104d427de7fbcc;
 1635|  4.58k|  int index = static_cast<int>(
 1636|  4.58k|      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +
 1637|  4.58k|       ((int64_t(1) << shift) - 1))  // ceil
 1638|  4.58k|      >> 32                          // arithmetic shift
 1639|  4.58k|  );
 1640|       |  // Decimal exponent of the first (smallest) cached power of 10.
 1641|  4.58k|  const int first_dec_exp = -348;
 1642|       |  // Difference between 2 consecutive decimal exponents in cached powers of 10.
 1643|  4.58k|  const int dec_exp_step = 8;
 1644|  4.58k|  index = (index - first_dec_exp - 1) / dec_exp_step + 1;
 1645|  4.58k|  pow10_exponent = first_dec_exp + index * dec_exp_step;
 1646|       |  // Using *(x + index) instead of x[index] avoids an issue with some compilers
 1647|       |  // using the EDG frontend (e.g. nvhpc/22.3 in C++17 mode).
 1648|  4.58k|  return {*(data::pow10_significands + index),
 1649|  4.58k|          *(data::pow10_exponents + index)};
 1650|  4.58k|}
_ZN3fmt2v96detail8basic_fpIyEC2Emi:
 1480|  13.7k|  constexpr basic_fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
_ZN3fmt2v96detailmlENS1_8basic_fpIyEES3_:
 1556|  4.58k|FMT_CONSTEXPR inline fp operator*(fp x, fp y) {
 1557|  4.58k|  return {multiply(x.f, y.f), x.e + y.e + 64};
 1558|  4.58k|}
_ZN3fmt2v96detail8multiplyEmm:
 1539|  4.58k|FMT_CONSTEXPR inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
 1540|  4.58k|#if FMT_USE_INT128
 1541|  4.58k|  auto product = static_cast<__uint128_t>(lhs) * rhs;
 1542|  4.58k|  auto f = static_cast<uint64_t>(product >> 64);
 1543|  4.58k|  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
  ------------------
  |  Branch (1543:10): [True: 1.87k, False: 2.71k]
  ------------------
 1544|       |#else
 1545|       |  // Multiply 32-bit parts of significands.
 1546|       |  uint64_t mask = (1ULL << 32) - 1;
 1547|       |  uint64_t a = lhs >> 32, b = lhs & mask;
 1548|       |  uint64_t c = rhs >> 32, d = rhs & mask;
 1549|       |  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
 1550|       |  // Compute mid 64-bit of result and round.
 1551|       |  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
 1552|       |  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
 1553|       |#endif
 1554|  4.58k|}
_ZN3fmt2v96detail16grisu_gen_digitsENS1_8basic_fpIyEEmRiRNS1_18gen_digits_handlerE:
 2729|  4.58k|    -> digits::result {
 2730|  4.58k|  const fp one(1ULL << -value.e, value.e);
 2731|       |  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
 2732|       |  // zero because it contains a product of two 64-bit numbers with MSB set (due
 2733|       |  // to normalization) - 1, shifted right by at most 60 bits.
 2734|  4.58k|  auto integral = static_cast<uint32_t>(value.f >> -one.e);
 2735|  4.58k|  FMT_ASSERT(integral != 0, "");
  ------------------
  |  |  352|  4.58k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2736|  4.58k|  FMT_ASSERT(integral == value.f >> -one.e, "");
  ------------------
  |  |  352|  4.58k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2737|       |  // The fractional part of scaled value (p2 in Grisu) c = value % one.
 2738|  4.58k|  uint64_t fractional = value.f & (one.f - 1);
 2739|  4.58k|  exp = count_digits(integral);  // kappa in Grisu.
 2740|       |  // Non-fixed formats require at least one digit and no precision adjustment.
 2741|  4.58k|  if (handler.fixed) {
  ------------------
  |  Branch (2741:7): [True: 4.58k, False: 0]
  ------------------
 2742|  4.58k|    adjust_precision(handler.precision, exp + handler.exp10);
 2743|       |    // Check if precision is satisfied just by leading zeros, e.g.
 2744|       |    // format("{:.2f}", 0.001) gives "0.00" without generating any digits.
 2745|  4.58k|    if (handler.precision <= 0) {
  ------------------
  |  Branch (2745:9): [True: 774, False: 3.81k]
  ------------------
 2746|    774|      if (handler.precision < 0) return digits::done;
  ------------------
  |  Branch (2746:11): [True: 711, False: 63]
  ------------------
 2747|       |      // Divide by 10 to prevent overflow.
 2748|     63|      uint64_t divisor = data::power_of_10_64[exp - 1] << -one.e;
 2749|     63|      auto dir = get_round_direction(divisor, value.f / 10, error * 10);
 2750|     63|      if (dir == round_direction::unknown) return digits::error;
  ------------------
  |  Branch (2750:11): [True: 0, False: 63]
  ------------------
 2751|     63|      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';
  ------------------
  |  Branch (2751:37): [True: 31, False: 32]
  ------------------
 2752|     63|      return digits::done;
 2753|     63|    }
 2754|  4.58k|  }
 2755|       |  // Generate digits for the integral part. This can produce up to 10 digits.
 2756|  17.9k|  do {
 2757|  17.9k|    uint32_t digit = 0;
 2758|  17.9k|    auto divmod_integral = [&](uint32_t divisor) {
 2759|  17.9k|      digit = integral / divisor;
 2760|  17.9k|      integral %= divisor;
 2761|  17.9k|    };
 2762|       |    // This optimization by Milo Yip reduces the number of integer divisions by
 2763|       |    // one per iteration.
 2764|  17.9k|    switch (exp) {
 2765|      0|    case 10:
  ------------------
  |  Branch (2765:5): [True: 0, False: 17.9k]
  ------------------
 2766|      0|      divmod_integral(1000000000);
 2767|      0|      break;
 2768|    393|    case 9:
  ------------------
  |  Branch (2768:5): [True: 393, False: 17.5k]
  ------------------
 2769|    393|      divmod_integral(100000000);
 2770|    393|      break;
 2771|    894|    case 8:
  ------------------
  |  Branch (2771:5): [True: 894, False: 17.0k]
  ------------------
 2772|    894|      divmod_integral(10000000);
 2773|    894|      break;
 2774|  1.38k|    case 7:
  ------------------
  |  Branch (2774:5): [True: 1.38k, False: 16.5k]
  ------------------
 2775|  1.38k|      divmod_integral(1000000);
 2776|  1.38k|      break;
 2777|  1.45k|    case 6:
  ------------------
  |  Branch (2777:5): [True: 1.45k, False: 16.4k]
  ------------------
 2778|  1.45k|      divmod_integral(100000);
 2779|  1.45k|      break;
 2780|  1.91k|    case 5:
  ------------------
  |  Branch (2780:5): [True: 1.91k, False: 16.0k]
  ------------------
 2781|  1.91k|      divmod_integral(10000);
 2782|  1.91k|      break;
 2783|  2.58k|    case 4:
  ------------------
  |  Branch (2783:5): [True: 2.58k, False: 15.3k]
  ------------------
 2784|  2.58k|      divmod_integral(1000);
 2785|  2.58k|      break;
 2786|  2.68k|    case 3:
  ------------------
  |  Branch (2786:5): [True: 2.68k, False: 15.2k]
  ------------------
 2787|  2.68k|      divmod_integral(100);
 2788|  2.68k|      break;
 2789|  3.24k|    case 2:
  ------------------
  |  Branch (2789:5): [True: 3.24k, False: 14.7k]
  ------------------
 2790|  3.24k|      divmod_integral(10);
 2791|  3.24k|      break;
 2792|  3.40k|    case 1:
  ------------------
  |  Branch (2792:5): [True: 3.40k, False: 14.5k]
  ------------------
 2793|  3.40k|      digit = integral;
 2794|  3.40k|      integral = 0;
 2795|  3.40k|      break;
 2796|      0|    default:
  ------------------
  |  Branch (2796:5): [True: 0, False: 17.9k]
  ------------------
 2797|      0|      FMT_ASSERT(false, "invalid number of digits");
  ------------------
  |  |  352|      0|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2798|  17.9k|    }
 2799|  17.9k|    --exp;
 2800|  17.9k|    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
 2801|  17.9k|    auto result = handler.on_digit(static_cast<char>('0' + digit),
 2802|  17.9k|                                   data::power_of_10_64[exp] << -one.e,
 2803|  17.9k|                                   remainder, error, true);
 2804|  17.9k|    if (result != digits::more) return result;
  ------------------
  |  Branch (2804:9): [True: 405, False: 17.5k]
  ------------------
 2805|  17.9k|  } while (exp > 0);
  ------------------
  |  Branch (2805:12): [True: 14.1k, False: 3.40k]
  ------------------
 2806|       |  // Generate digits for the fractional part.
 2807|  34.9k|  for (;;) {
 2808|  34.9k|    fractional *= 10;
 2809|  34.9k|    error *= 10;
 2810|  34.9k|    char digit = static_cast<char>('0' + (fractional >> -one.e));
 2811|  34.9k|    fractional &= one.f - 1;
 2812|  34.9k|    --exp;
 2813|  34.9k|    auto result = handler.on_digit(digit, one.f, fractional, error, false);
 2814|  34.9k|    if (result != digits::more) return result;
  ------------------
  |  Branch (2814:9): [True: 3.40k, False: 31.5k]
  ------------------
 2815|  34.9k|  }
 2816|  3.40k|}
_ZN3fmt2v96detail19get_round_directionEmmm:
 2651|  1.15k|                                                         uint64_t error) {
 2652|  1.15k|  FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
  ------------------
  |  |  352|  1.15k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2653|  1.15k|  FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
  ------------------
  |  |  352|  1.15k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2654|  1.15k|  FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
  ------------------
  |  |  352|  1.15k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2655|       |  // Round down if (remainder + error) * 2 <= divisor.
 2656|  1.15k|  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
  ------------------
  |  Branch (2656:7): [True: 506, False: 649]
  |  Branch (2656:43): [True: 228, False: 278]
  ------------------
 2657|    228|    return round_direction::down;
 2658|       |  // Round up if (remainder - error) * 2 >= divisor.
 2659|    927|  if (remainder >= error &&
  ------------------
  |  Branch (2659:7): [True: 927, False: 0]
  ------------------
 2660|    927|      remainder - error >= divisor - (remainder - error)) {
  ------------------
  |  Branch (2660:7): [True: 529, False: 398]
  ------------------
 2661|    529|    return round_direction::up;
 2662|    529|  }
 2663|    398|  return round_direction::unknown;
 2664|    927|}
_ZZN3fmt2v96detail16grisu_gen_digitsENS1_8basic_fpIyEEmRiRNS1_18gen_digits_handlerEENKUljE_clEj:
 2758|  14.5k|    auto divmod_integral = [&](uint32_t divisor) {
 2759|  14.5k|      digit = integral / divisor;
 2760|  14.5k|      integral %= divisor;
 2761|  14.5k|    };
_ZN3fmt2v96detail18gen_digits_handler8on_digitEcmmmb:
 2683|  52.9k|                                        bool integral) {
 2684|  52.9k|    FMT_ASSERT(remainder < divisor, "");
  ------------------
  |  |  352|  52.9k|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2685|  52.9k|    buf[size++] = digit;
 2686|  52.9k|    if (!integral && error >= remainder) return digits::error;
  ------------------
  |  Branch (2686:9): [True: 34.9k, False: 17.9k]
  |  Branch (2686:22): [True: 2.71k, False: 32.2k]
  ------------------
 2687|  50.2k|    if (size < precision) return digits::more;
  ------------------
  |  Branch (2687:9): [True: 49.1k, False: 1.09k]
  ------------------
 2688|  1.09k|    if (!integral) {
  ------------------
  |  Branch (2688:9): [True: 691, False: 405]
  ------------------
 2689|       |      // Check if error * 2 < divisor with overflow prevention.
 2690|       |      // The check is not needed for the integral part because error = 1
 2691|       |      // and divisor > (1 << 32) there.
 2692|    691|      if (error >= divisor || error >= divisor - error) return digits::error;
  ------------------
  |  Branch (2692:11): [True: 0, False: 691]
  |  Branch (2692:31): [True: 4, False: 687]
  ------------------
 2693|    691|    } else {
 2694|    405|      FMT_ASSERT(error == 1 && divisor > 2, "");
  ------------------
  |  |  352|    810|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (352:37): [True: 405, False: 0]
  |  |  |  Branch (352:37): [True: 405, False: 0]
  |  |  ------------------
  ------------------
 2695|    405|    }
 2696|  1.09k|    auto dir = get_round_direction(divisor, remainder, error);
 2697|  1.09k|    if (dir != round_direction::up)
  ------------------
  |  Branch (2697:9): [True: 594, False: 498]
  ------------------
 2698|    594|      return dir == round_direction::down ? digits::done : digits::error;
  ------------------
  |  Branch (2698:14): [True: 196, False: 398]
  ------------------
 2699|    498|    ++buf[size - 1];
 2700|  1.33k|    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
  ------------------
  |  Branch (2700:28): [True: 992, False: 342]
  |  Branch (2700:37): [True: 836, False: 156]
  ------------------
 2701|    836|      buf[i] = '0';
 2702|    836|      ++buf[i - 1];
 2703|    836|    }
 2704|    498|    if (buf[0] > '9') {
  ------------------
  |  Branch (2704:9): [True: 12, False: 486]
  ------------------
 2705|     12|      buf[0] = '1';
 2706|     12|      if (fixed)
  ------------------
  |  Branch (2706:11): [True: 12, False: 0]
  ------------------
 2707|     12|        buf[size++] = '0';
 2708|      0|      else
 2709|      0|        ++exp10;
 2710|     12|    }
 2711|    498|    return digits::done;
 2712|  1.09k|  }
_ZN3fmt2v96detail8basic_fpIoE6assignIdLi0EEEbT_:
 1487|  2.03k|  FMT_CONSTEXPR auto assign(Float n) -> bool {
 1488|  2.03k|    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
 1489|       |    // Assume Float is in the format [sign][exponent][significand].
 1490|  2.03k|    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
 1491|  2.03k|    const auto num_float_significand_bits =
 1492|  2.03k|        detail::num_significand_bits<Float>();
 1493|  2.03k|    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
 1494|  2.03k|    const auto significand_mask = implicit_bit - 1;
 1495|  2.03k|    auto u = bit_cast<carrier_uint>(n);
 1496|  2.03k|    f = static_cast<F>(u & significand_mask);
 1497|  2.03k|    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
 1498|  2.03k|                                     num_float_significand_bits);
 1499|       |    // The predecessor is closer if n is a normalized power of 2 (f == 0)
 1500|       |    // other than the smallest normalized number (biased_e > 1).
 1501|  2.03k|    auto is_predecessor_closer = f == 0 && biased_e > 1;
  ------------------
  |  Branch (1501:34): [True: 200, False: 1.83k]
  |  Branch (1501:44): [True: 200, False: 0]
  ------------------
 1502|  2.03k|    if (biased_e == 0)
  ------------------
  |  Branch (1502:9): [True: 0, False: 2.03k]
  ------------------
 1503|      0|      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
 1504|  2.03k|    else if (has_implicit_bit<Float>())
  ------------------
  |  Branch (1504:14): [Folded - Ignored]
  ------------------
 1505|  2.03k|      f += static_cast<F>(implicit_bit);
 1506|  2.03k|    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
 1507|  2.03k|    if (!has_implicit_bit<Float>()) ++e;
  ------------------
  |  Branch (1507:9): [Folded - Ignored]
  ------------------
 1508|  2.03k|    return is_predecessor_closer;
 1509|  2.03k|  }
_ZN3fmt2v96detail13arg_formatterIcEclIdEENS0_8appenderET_:
 3587|  3.22k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3588|  3.22k|    return detail::write(out, value, specs, locale);
 3589|  3.22k|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEdLi0EEET0_S4_T1_NS0_12format_specsIT_EENS1_10locale_refE:
 3429|  3.22k|                           locale_ref loc = {}) -> OutputIt {
 3430|  3.22k|  if (const_check(!is_supported_floating_point(value))) return out;
  ------------------
  |  Branch (3430:7): [True: 0, False: 3.22k]
  ------------------
 3431|  3.22k|  return specs.localized && write_loc(out, value, specs, loc)
  ------------------
  |  Branch (3431:10): [True: 0, False: 3.22k]
  |  Branch (3431:29): [True: 0, False: 0]
  ------------------
 3432|  3.22k|             ? out
 3433|  3.22k|             : write_float(out, value, specs, loc);
 3434|  3.22k|}
_ZN3fmt2v96detail11write_floatIcNS0_8appenderEdEET0_S4_T1_NS0_12format_specsIT_EENS1_10locale_refE:
 3380|  3.22k|    -> OutputIt {
 3381|  3.22k|  float_specs fspecs = parse_float_type_spec(specs);
 3382|  3.22k|  fspecs.sign = specs.sign;
 3383|  3.22k|  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
  ------------------
  |  Branch (3383:7): [True: 1.74k, False: 1.47k]
  ------------------
 3384|  1.74k|    fspecs.sign = sign::minus;
 3385|  1.74k|    value = -value;
 3386|  1.74k|  } else if (fspecs.sign == sign::minus) {
  ------------------
  |  Branch (3386:14): [True: 0, False: 1.47k]
  ------------------
 3387|      0|    fspecs.sign = sign::none;
 3388|      0|  }
 3389|       |
 3390|  3.22k|  if (!detail::isfinite(value))
  ------------------
  |  Branch (3390:7): [True: 201, False: 3.01k]
  ------------------
 3391|    201|    return write_nonfinite(out, detail::isnan(value), specs, fspecs);
 3392|       |
 3393|  3.01k|  if (specs.align == align::numeric && fspecs.sign) {
  ------------------
  |  Branch (3393:7): [True: 0, False: 3.01k]
  |  Branch (3393:40): [True: 0, False: 0]
  ------------------
 3394|      0|    auto it = reserve(out, 1);
 3395|      0|    *it++ = detail::sign<Char>(fspecs.sign);
 3396|      0|    out = base_iterator(out, it);
 3397|      0|    fspecs.sign = sign::none;
 3398|      0|    if (specs.width != 0) --specs.width;
  ------------------
  |  Branch (3398:9): [True: 0, False: 0]
  ------------------
 3399|      0|  }
 3400|       |
 3401|  3.01k|  memory_buffer buffer;
 3402|  3.01k|  if (fspecs.format == float_format::hex) {
  ------------------
  |  Branch (3402:7): [True: 0, False: 3.01k]
  ------------------
 3403|      0|    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
  ------------------
  |  Branch (3403:9): [True: 0, False: 0]
  ------------------
 3404|      0|    format_hexfloat(convert_float(value), specs.precision, fspecs, buffer);
 3405|      0|    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
 3406|      0|                                     specs);
 3407|      0|  }
 3408|  3.01k|  int precision = specs.precision >= 0 || specs.type == presentation_type::none
  ------------------
  |  Branch (3408:19): [True: 0, False: 3.01k]
  |  Branch (3408:43): [True: 0, False: 3.01k]
  ------------------
 3409|  3.01k|                      ? specs.precision
 3410|  3.01k|                      : 6;
 3411|  3.01k|  if (fspecs.format == float_format::exp) {
  ------------------
  |  Branch (3411:7): [True: 0, False: 3.01k]
  ------------------
 3412|      0|    if (precision == max_value<int>())
  ------------------
  |  Branch (3412:9): [True: 0, False: 0]
  ------------------
 3413|      0|      throw_format_error("number is too big");
 3414|      0|    else
 3415|      0|      ++precision;
 3416|  3.01k|  } else if (fspecs.format != float_format::fixed && precision == 0) {
  ------------------
  |  Branch (3416:14): [True: 0, False: 3.01k]
  |  Branch (3416:54): [True: 0, False: 0]
  ------------------
 3417|      0|    precision = 1;
 3418|      0|  }
 3419|  3.01k|  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
  ------------------
  |  Branch (3419:7): [Folded - Ignored]
  ------------------
 3420|  3.01k|  int exp = format_float(convert_float(value), precision, fspecs, buffer);
 3421|  3.01k|  fspecs.precision = precision;
 3422|  3.01k|  auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
 3423|  3.01k|  return write_float(out, f, specs, fspecs, loc);
 3424|  3.01k|}
_ZN3fmt2v96detail8isfiniteIdLi0EEEbT_:
 2617|  3.22k|FMT_CONSTEXPR20 bool isfinite(T value) {
 2618|  3.22k|  constexpr T inf = T(std::numeric_limits<double>::infinity());
 2619|  3.22k|  if (is_constant_evaluated())
  ------------------
  |  Branch (2619:7): [Folded - Ignored]
  ------------------
 2620|      0|    return !detail::isnan(value) && value < inf && value > -inf;
  ------------------
  |  Branch (2620:12): [True: 0, False: 0]
  |  Branch (2620:37): [True: 0, False: 0]
  |  Branch (2620:52): [True: 0, False: 0]
  ------------------
 2621|  3.22k|  return std::isfinite(value);
 2622|  3.22k|}
_ZN3fmt2v96detail5isnanIdEEbT_:
 2604|    201|template <typename T> constexpr bool isnan(T value) {
 2605|    201|  return !(value >= value);  // std::isnan doesn't support __float128.
 2606|    201|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewINS0_13type_identityIT_E4typeEEERKNS0_12format_specsIS7_EENS1_10locale_refE:
 2251|  58.3k|    -> OutputIt {
 2252|  58.3k|  return write(out, s, specs);
 2253|  58.3k|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS6_EE:
 2228|  58.3k|                         const format_specs<Char>& specs) -> OutputIt {
 2229|  58.3k|  auto data = s.data();
 2230|  58.3k|  auto size = s.size();
 2231|  58.3k|  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
  ------------------
  |  Branch (2231:7): [True: 0, False: 58.3k]
  |  Branch (2231:31): [True: 0, False: 0]
  ------------------
 2232|      0|    size = code_point_index(s, to_unsigned(specs.precision));
 2233|  58.3k|  bool is_debug = specs.type == presentation_type::debug;
 2234|  58.3k|  size_t width = 0;
 2235|  58.3k|  if (specs.width != 0) {
  ------------------
  |  Branch (2235:7): [True: 0, False: 58.3k]
  ------------------
 2236|      0|    if (is_debug)
  ------------------
  |  Branch (2236:9): [True: 0, False: 0]
  ------------------
 2237|      0|      width = write_escaped_string(counting_iterator{}, s).count();
 2238|      0|    else
 2239|      0|      width = compute_width(basic_string_view<Char>(data, size));
 2240|      0|  }
 2241|  58.3k|  return write_padded(out, specs, size, width,
 2242|  58.3k|                      [=](reserve_iterator<OutputIt> it) {
 2243|  58.3k|                        if (is_debug) return write_escaped_string(it, s);
 2244|  58.3k|                        return copy_str<Char>(data, data + size, it);
 2245|  58.3k|                      });
 2246|  58.3k|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcZNS1_5writeIcS5_EET0_S7_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS9_EEEUlS5_E_EES7_S7_RKNSB_IT1_EEmmOT2_:
 1681|  58.3k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1682|  58.3k|  static_assert(align == align::left || align == align::right, "");
 1683|  58.3k|  unsigned spec_width = to_unsigned(specs.width);
 1684|  58.3k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1684:20): [True: 0, False: 58.3k]
  ------------------
 1685|       |  // Shifts are encoded as string literals because static constexpr is not
 1686|       |  // supported in constexpr functions.
 1687|  58.3k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1687:18): [Folded - Ignored]
  ------------------
 1688|  58.3k|  size_t left_padding = padding >> shifts[specs.align];
 1689|  58.3k|  size_t right_padding = padding - left_padding;
 1690|  58.3k|  auto it = reserve(out, size + padding * specs.fill.size());
 1691|  58.3k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1691:7): [True: 0, False: 58.3k]
  ------------------
 1692|  58.3k|  it = f(it);
 1693|  58.3k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1693:7): [True: 0, False: 58.3k]
  ------------------
 1694|  58.3k|  return base_iterator(out, it);
 1695|  58.3k|}
_ZZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS6_EEENKUlS3_E_clES3_:
 2242|  58.3k|                      [=](reserve_iterator<OutputIt> it) {
 2243|  58.3k|                        if (is_debug) return write_escaped_string(it, s);
  ------------------
  |  Branch (2243:29): [True: 0, False: 58.3k]
  ------------------
 2244|  58.3k|                        return copy_str<Char>(data, data + size, it);
 2245|  58.3k|                      });
_ZN3fmt2v96detail13arg_formatterIcEclINS0_17basic_string_viewIcEEEENS0_8appenderET_:
 3587|  58.3k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3588|  58.3k|    return detail::write(out, value, specs, locale);
 3589|  58.3k|  }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handlerC2ENS0_8appenderENS7_IcEENS0_17basic_format_argsINS0_20basic_format_contextISE_cEEEESC_:
 4173|   115k|        : parse_context(str), context(p_out, p_args, p_loc) {}
_ZN3fmt2v99to_stringIcLm500EEENSt3__112basic_stringIT_NS2_11char_traitsIS4_EENS2_9allocatorIS4_EEEERKNS0_19basic_memory_bufferIS4_XT0_ES8_EE:
 4135|  58.3k|    -> std::basic_string<Char> {
 4136|  58.3k|  auto size = buf.size();
 4137|  58.3k|  detail::assume(size < std::basic_string<Char>().max_size());
 4138|  58.3k|  return std::basic_string<Char>(buf.data(), size);
 4139|  58.3k|}
_ZN3fmt2v96detail6assumeEb:
  498|  58.3k|FMT_INLINE void assume(bool condition) {
  499|  58.3k|  (void)condition;
  500|  58.3k|#if FMT_HAS_BUILTIN(__builtin_assume) && !FMT_ICC_VERSION
  501|  58.3k|  __builtin_assume(condition);
  502|  58.3k|#endif
  503|  58.3k|}

LLVMFuzzerTestOneInput:
   73|  2.63k|{
   74|  2.63k|    dlx::MemoryBlock memory_block{1000u, max_size};
   75|       |
   76|  2.63k|    FUZZ_LOG("Beginning execution");
  ------------------
  |  |   19|  2.63k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|  2.63k|        std::putc('\n', stderr);                                                                   \
  |  |   21|  2.63k|        std::fflush(stderr)
  ------------------
   77|       |
   78|   189k|    for (std::size_t index{0u}; index < size;)
  ------------------
  |  Branch (78:33): [True: 188k, False: 854]
  ------------------
   79|   188k|    {
   80|   188k|        GET_T(phi::uint32_t, function_index);
  ------------------
  |  |   10|   188k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|   188k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 1.34k, False: 187k]
  |  |  ------------------
  |  |   12|   188k|    {                                                                                              \
  |  |   13|  1.34k|        return 0;                                                                                  \
  |  |   14|  1.34k|    }                                                                                              \
  |  |   15|   188k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
   81|       |
   82|   187k|        switch (function_index)
  ------------------
  |  Branch (82:17): [True: 132k, False: 54.4k]
  ------------------
   83|   187k|        {
   84|       |            // LoadByte
   85|  39.1k|            case 0: {
  ------------------
  |  Branch (85:13): [True: 39.1k, False: 148k]
  ------------------
   86|  39.1k|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|  39.1k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|  39.1k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 290, False: 38.8k]
  |  |  ------------------
  |  |   12|  39.1k|    {                                                                                              \
  |  |   13|    290|        return 0;                                                                                  \
  |  |   14|    290|    }                                                                                              \
  |  |   15|  39.1k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
   87|       |
   88|  38.8k|                FUZZ_LOG("LoadByte({:s})", print_int(address));
  ------------------
  |  |   19|  38.8k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|  38.8k|        std::putc('\n', stderr);                                                                   \
  |  |   21|  38.8k|        std::fflush(stderr)
  ------------------
   89|  38.8k|                (void)memory_block.LoadByte(address);
   90|  38.8k|                break;
   91|  39.1k|            }
   92|       |
   93|       |            // LoadUnsignedByte
   94|    918|            case 1: {
  ------------------
  |  Branch (94:13): [True: 918, False: 186k]
  ------------------
   95|    918|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    918|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    918|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 10, False: 908]
  |  |  ------------------
  |  |   12|    918|    {                                                                                              \
  |  |   13|     10|        return 0;                                                                                  \
  |  |   14|     10|    }                                                                                              \
  |  |   15|    918|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
   96|       |
   97|    908|                FUZZ_LOG("LoadUnsignedByte({:s})", print_int(address));
  ------------------
  |  |   19|    908|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    908|        std::putc('\n', stderr);                                                                   \
  |  |   21|    908|        std::fflush(stderr)
  ------------------
   98|    908|                (void)memory_block.LoadUnsignedByte(address);
   99|    908|                break;
  100|    918|            }
  101|       |
  102|       |            // LoadHalfWord
  103|    988|            case 2: {
  ------------------
  |  Branch (103:13): [True: 988, False: 186k]
  ------------------
  104|    988|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    988|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    988|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 7, False: 981]
  |  |  ------------------
  |  |   12|    988|    {                                                                                              \
  |  |   13|      7|        return 0;                                                                                  \
  |  |   14|      7|    }                                                                                              \
  |  |   15|    988|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  105|       |
  106|    981|                FUZZ_LOG("LoadHalfWord({:s})", print_int(address));
  ------------------
  |  |   19|    981|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    981|        std::putc('\n', stderr);                                                                   \
  |  |   21|    981|        std::fflush(stderr)
  ------------------
  107|    981|                (void)memory_block.LoadHalfWord(address);
  108|    981|                break;
  109|    988|            }
  110|       |
  111|       |                // LoadUnsignedHalfWord
  112|    327|            case 3: {
  ------------------
  |  Branch (112:13): [True: 327, False: 187k]
  ------------------
  113|    327|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    327|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    327|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 324]
  |  |  ------------------
  |  |   12|    327|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    327|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  114|       |
  115|    324|                FUZZ_LOG("LoadUnsignedHalfWord({:s})", print_int(address));
  ------------------
  |  |   19|    324|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    324|        std::putc('\n', stderr);                                                                   \
  |  |   21|    324|        std::fflush(stderr)
  ------------------
  116|    324|                (void)memory_block.LoadUnsignedHalfWord(address);
  117|    324|                break;
  118|    327|            }
  119|       |
  120|       |            // LoadWord
  121|    643|            case 4: {
  ------------------
  |  Branch (121:13): [True: 643, False: 186k]
  ------------------
  122|    643|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    643|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    643|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 4, False: 639]
  |  |  ------------------
  |  |   12|    643|    {                                                                                              \
  |  |   13|      4|        return 0;                                                                                  \
  |  |   14|      4|    }                                                                                              \
  |  |   15|    643|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  123|       |
  124|    639|                FUZZ_LOG("LoadWord({:s})", print_int(address));
  ------------------
  |  |   19|    639|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    639|        std::putc('\n', stderr);                                                                   \
  |  |   21|    639|        std::fflush(stderr)
  ------------------
  125|    639|                (void)memory_block.LoadWord(address);
  126|    639|                break;
  127|    643|            }
  128|       |
  129|       |            // LoadUnsignedWord
  130|    436|            case 5: {
  ------------------
  |  Branch (130:13): [True: 436, False: 186k]
  ------------------
  131|    436|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    436|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    436|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 4, False: 432]
  |  |  ------------------
  |  |   12|    436|    {                                                                                              \
  |  |   13|      4|        return 0;                                                                                  \
  |  |   14|      4|    }                                                                                              \
  |  |   15|    436|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  132|       |
  133|    432|                FUZZ_LOG("LoadUnsignedWord({:s})", print_int(address));
  ------------------
  |  |   19|    432|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    432|        std::putc('\n', stderr);                                                                   \
  |  |   21|    432|        std::fflush(stderr)
  ------------------
  134|    432|                (void)memory_block.LoadUnsignedWord(address);
  135|    432|                break;
  136|    436|            }
  137|       |
  138|       |            // LoadFloat
  139|    342|            case 6: {
  ------------------
  |  Branch (139:13): [True: 342, False: 187k]
  ------------------
  140|    342|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    342|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    342|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 4, False: 338]
  |  |  ------------------
  |  |   12|    342|    {                                                                                              \
  |  |   13|      4|        return 0;                                                                                  \
  |  |   14|      4|    }                                                                                              \
  |  |   15|    342|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  141|       |
  142|    338|                FUZZ_LOG("LoadFloat({:s})", print_int(address));
  ------------------
  |  |   19|    338|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    338|        std::putc('\n', stderr);                                                                   \
  |  |   21|    338|        std::fflush(stderr)
  ------------------
  143|    338|                (void)memory_block.LoadFloat(address);
  144|    338|                break;
  145|    342|            }
  146|       |
  147|       |            // LoadDouble
  148|    399|            case 7: {
  ------------------
  |  Branch (148:13): [True: 399, False: 186k]
  ------------------
  149|    399|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    399|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    399|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 10, False: 389]
  |  |  ------------------
  |  |   12|    399|    {                                                                                              \
  |  |   13|     10|        return 0;                                                                                  \
  |  |   14|     10|    }                                                                                              \
  |  |   15|    399|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  150|       |
  151|    389|                FUZZ_LOG("LoadDouble({:s})", print_int(address));
  ------------------
  |  |   19|    389|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    389|        std::putc('\n', stderr);                                                                   \
  |  |   21|    389|        std::fflush(stderr)
  ------------------
  152|    389|                (void)memory_block.LoadDouble(address);
  153|    389|                break;
  154|    399|            }
  155|       |
  156|       |            // StoreByte
  157|    602|            case 8: {
  ------------------
  |  Branch (157:13): [True: 602, False: 186k]
  ------------------
  158|    602|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    602|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    602|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 2, False: 600]
  |  |  ------------------
  |  |   12|    602|    {                                                                                              \
  |  |   13|      2|        return 0;                                                                                  \
  |  |   14|      2|    }                                                                                              \
  |  |   15|    602|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  159|    600|                GET_T(phi::int8_t, value);
  ------------------
  |  |   10|    600|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    600|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 597]
  |  |  ------------------
  |  |   12|    600|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    600|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  160|       |
  161|    597|                FUZZ_LOG("StoreByte({:s}, {:s})", print_int(address), print_int(value));
  ------------------
  |  |   19|    597|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    597|        std::putc('\n', stderr);                                                                   \
  |  |   21|    597|        std::fflush(stderr)
  ------------------
  162|    597|                (void)memory_block.StoreByte(address, value);
  163|    597|                break;
  164|    600|            }
  165|       |
  166|       |            // StoreUnsignedByte
  167|    396|            case 9: {
  ------------------
  |  Branch (167:13): [True: 396, False: 186k]
  ------------------
  168|    396|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    396|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    396|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 393]
  |  |  ------------------
  |  |   12|    396|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    396|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  169|    393|                GET_T(phi::uint8_t, value);
  ------------------
  |  |   10|    393|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    393|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 390]
  |  |  ------------------
  |  |   12|    393|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    393|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  170|       |
  171|    390|                FUZZ_LOG("StoreUnsignedByte({:s}, {:s})", print_int(address), print_int(value));
  ------------------
  |  |   19|    390|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    390|        std::putc('\n', stderr);                                                                   \
  |  |   21|    390|        std::fflush(stderr)
  ------------------
  172|    390|                (void)memory_block.StoreUnsignedByte(address, value);
  173|    390|                break;
  174|    393|            }
  175|       |
  176|       |            // StoreHalfWord
  177|  1.46k|            case 10: {
  ------------------
  |  Branch (177:13): [True: 1.46k, False: 185k]
  ------------------
  178|  1.46k|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|  1.46k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|  1.46k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 4, False: 1.45k]
  |  |  ------------------
  |  |   12|  1.46k|    {                                                                                              \
  |  |   13|      4|        return 0;                                                                                  \
  |  |   14|      4|    }                                                                                              \
  |  |   15|  1.46k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  179|  1.45k|                GET_T(phi::int16_t, value);
  ------------------
  |  |   10|  1.45k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|  1.45k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 1.45k]
  |  |  ------------------
  |  |   12|  1.45k|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|  1.45k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  180|       |
  181|  1.45k|                FUZZ_LOG("StoreHalfWord({:s}, {:s})", print_int(address), print_int(value));
  ------------------
  |  |   19|  1.45k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|  1.45k|        std::putc('\n', stderr);                                                                   \
  |  |   21|  1.45k|        std::fflush(stderr)
  ------------------
  182|  1.45k|                (void)memory_block.StoreHalfWord(address, value);
  183|  1.45k|                break;
  184|  1.45k|            }
  185|       |
  186|       |            // StoreUnsignedHalfWord
  187|    321|            case 11: {
  ------------------
  |  Branch (187:13): [True: 321, False: 187k]
  ------------------
  188|    321|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    321|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    321|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 318]
  |  |  ------------------
  |  |   12|    321|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    321|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  189|    318|                GET_T(phi::uint16_t, value);
  ------------------
  |  |   10|    318|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    318|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 315]
  |  |  ------------------
  |  |   12|    318|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    318|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  190|       |
  191|    315|                FUZZ_LOG("StoreUnsignedHalfWord({:s}, {:s})", print_int(address), print_int(value));
  ------------------
  |  |   19|    315|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    315|        std::putc('\n', stderr);                                                                   \
  |  |   21|    315|        std::fflush(stderr)
  ------------------
  192|    315|                (void)memory_block.StoreUnsignedHalfWord(address, value);
  193|    315|                break;
  194|    318|            }
  195|       |
  196|       |            // StoreWord
  197|    873|            case 12: {
  ------------------
  |  Branch (197:13): [True: 873, False: 186k]
  ------------------
  198|    873|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    873|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    873|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 15, False: 858]
  |  |  ------------------
  |  |   12|    873|    {                                                                                              \
  |  |   13|     15|        return 0;                                                                                  \
  |  |   14|     15|    }                                                                                              \
  |  |   15|    873|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  199|    858|                GET_T(phi::int32_t, value);
  ------------------
  |  |   10|    858|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    858|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 5, False: 853]
  |  |  ------------------
  |  |   12|    858|    {                                                                                              \
  |  |   13|      5|        return 0;                                                                                  \
  |  |   14|      5|    }                                                                                              \
  |  |   15|    858|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  200|       |
  201|    853|                FUZZ_LOG("StoreWord({:s}, {:s})", print_int(address), print_int(value));
  ------------------
  |  |   19|    853|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    853|        std::putc('\n', stderr);                                                                   \
  |  |   21|    853|        std::fflush(stderr)
  ------------------
  202|    853|                (void)memory_block.StoreWord(address, value);
  203|    853|                break;
  204|    858|            }
  205|       |
  206|       |            // StoreUnsignedWord
  207|    230|            case 13: {
  ------------------
  |  Branch (207:13): [True: 230, False: 187k]
  ------------------
  208|    230|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    230|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    230|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 227]
  |  |  ------------------
  |  |   12|    230|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    230|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  209|    227|                GET_T(phi::uint32_t, value);
  ------------------
  |  |   10|    227|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    227|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 224]
  |  |  ------------------
  |  |   12|    227|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    227|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  210|       |
  211|    224|                FUZZ_LOG("StoreUnsignedWord({:s}, {:s})", print_int(address), print_int(value));
  ------------------
  |  |   19|    224|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    224|        std::putc('\n', stderr);                                                                   \
  |  |   21|    224|        std::fflush(stderr)
  ------------------
  212|    224|                (void)memory_block.StoreUnsignedWord(address, value);
  213|    224|                break;
  214|    227|            }
  215|       |
  216|       |            // StoreFloat
  217|  2.00k|            case 14: {
  ------------------
  |  Branch (217:13): [True: 2.00k, False: 185k]
  ------------------
  218|  2.00k|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|  2.00k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|  2.00k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 8, False: 1.99k]
  |  |  ------------------
  |  |   12|  2.00k|    {                                                                                              \
  |  |   13|      8|        return 0;                                                                                  \
  |  |   14|      8|    }                                                                                              \
  |  |   15|  2.00k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  219|  1.99k|                GET_T(phi::float32, value);
  ------------------
  |  |   10|  1.99k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|  1.99k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 4, False: 1.99k]
  |  |  ------------------
  |  |   12|  1.99k|    {                                                                                              \
  |  |   13|      4|        return 0;                                                                                  \
  |  |   14|      4|    }                                                                                              \
  |  |   15|  1.99k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  220|       |
  221|  1.99k|                FUZZ_LOG("StoreFloat({:s}, {:f})", print_int(address), value);
  ------------------
  |  |   19|  1.99k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|  1.99k|        std::putc('\n', stderr);                                                                   \
  |  |   21|  1.99k|        std::fflush(stderr)
  ------------------
  222|  1.99k|                (void)memory_block.StoreFloat(address, value);
  223|  1.99k|                break;
  224|  1.99k|            }
  225|       |
  226|       |            // StoreDouble
  227|  3.23k|            case 15: {
  ------------------
  |  Branch (227:13): [True: 3.23k, False: 184k]
  ------------------
  228|  3.23k|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|  3.23k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|  3.23k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 7, False: 3.22k]
  |  |  ------------------
  |  |   12|  3.23k|    {                                                                                              \
  |  |   13|      7|        return 0;                                                                                  \
  |  |   14|      7|    }                                                                                              \
  |  |   15|  3.23k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  229|  3.22k|                GET_T(phi::float64, value);
  ------------------
  |  |   10|  3.22k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|  3.22k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 5, False: 3.22k]
  |  |  ------------------
  |  |   12|  3.22k|    {                                                                                              \
  |  |   13|      5|        return 0;                                                                                  \
  |  |   14|      5|    }                                                                                              \
  |  |   15|  3.22k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  230|       |
  231|  3.22k|                FUZZ_LOG("StoreDouble({:s}, {:f})", print_int(address), value);
  ------------------
  |  |   19|  3.22k|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|  3.22k|        std::putc('\n', stderr);                                                                   \
  |  |   21|  3.22k|        std::fflush(stderr)
  ------------------
  232|  3.22k|                (void)memory_block.StoreDouble(address, value);
  233|  3.22k|                break;
  234|  3.22k|            }
  235|       |
  236|       |            // IsAddressValid
  237|    367|            case 16: {
  ------------------
  |  Branch (237:13): [True: 367, False: 186k]
  ------------------
  238|    367|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    367|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    367|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 4, False: 363]
  |  |  ------------------
  |  |   12|    367|    {                                                                                              \
  |  |   13|      4|        return 0;                                                                                  \
  |  |   14|      4|    }                                                                                              \
  |  |   15|    367|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  239|    363|                GET_T(phi::size_t, arg_size);
  ------------------
  |  |   10|    363|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    363|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 360]
  |  |  ------------------
  |  |   12|    363|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    363|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  240|       |
  241|    360|                FUZZ_LOG("IsAddressValid({:s}, {:s})", print_int(address), print_int(arg_size));
  ------------------
  |  |   19|    360|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    360|        std::putc('\n', stderr);                                                                   \
  |  |   21|    360|        std::fflush(stderr)
  ------------------
  242|    360|                (void)memory_block.IsAddressValid(address, arg_size);
  243|    360|                break;
  244|    363|            }
  245|       |
  246|       |            // IsAddressAlignedCorrectly
  247|    394|            case 17: {
  ------------------
  |  Branch (247:13): [True: 394, False: 186k]
  ------------------
  248|    394|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    394|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    394|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 5, False: 389]
  |  |  ------------------
  |  |   12|    394|    {                                                                                              \
  |  |   13|      5|        return 0;                                                                                  \
  |  |   14|      5|    }                                                                                              \
  |  |   15|    394|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  249|    389|                GET_T(phi::size_t, arg_size);
  ------------------
  |  |   10|    389|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    389|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 5, False: 384]
  |  |  ------------------
  |  |   12|    389|    {                                                                                              \
  |  |   13|      5|        return 0;                                                                                  \
  |  |   14|      5|    }                                                                                              \
  |  |   15|    389|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  250|       |
  251|    384|                FUZZ_LOG("IsAddressAlignedCorrectly({:s}, {:s})", print_int(address),
  ------------------
  |  |   19|    384|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    384|        std::putc('\n', stderr);                                                                   \
  |  |   21|    384|        std::fflush(stderr)
  ------------------
  252|    384|                         print_int(arg_size));
  253|    384|                (void)dlx::MemoryBlock::IsAddressAlignedCorrectly(address, arg_size);
  254|    384|                break;
  255|    389|            }
  256|       |
  257|       |            // GetStartingAddress
  258|     58|            case 18: {
  ------------------
  |  Branch (258:13): [True: 58, False: 187k]
  ------------------
  259|     58|                FUZZ_LOG("GetStartingAddress()");
  ------------------
  |  |   19|     58|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|     58|        std::putc('\n', stderr);                                                                   \
  |  |   21|     58|        std::fflush(stderr)
  ------------------
  260|     58|                (void)memory_block.GetStartingAddress();
  261|     58|                break;
  262|    389|            }
  263|       |
  264|       |            // SetStartingAddress
  265|    516|            case 19: {
  ------------------
  |  Branch (265:13): [True: 516, False: 186k]
  ------------------
  266|    516|                GET_T(phi::size_t, address);
  ------------------
  |  |   10|    516|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    516|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 513]
  |  |  ------------------
  |  |   12|    516|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    516|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  267|       |
  268|    513|                FUZZ_LOG("SetStartingAddress({:s})", print_int(address));
  ------------------
  |  |   19|    513|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    513|        std::putc('\n', stderr);                                                                   \
  |  |   21|    513|        std::fflush(stderr)
  ------------------
  269|    513|                memory_block.SetStartingAddress(address);
  270|    513|                break;
  271|    516|            }
  272|       |
  273|       |            // GetSize
  274|     39|            case 20: {
  ------------------
  |  Branch (274:13): [True: 39, False: 187k]
  ------------------
  275|     39|                FUZZ_LOG("GetSize()");
  ------------------
  |  |   19|     39|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|     39|        std::putc('\n', stderr);                                                                   \
  |  |   21|     39|        std::fflush(stderr)
  ------------------
  276|     39|                (void)memory_block.GetSize();
  277|     39|                break;
  278|    516|            }
  279|       |
  280|       |            // Resize
  281|    573|            case 21: {
  ------------------
  |  Branch (281:13): [True: 573, False: 186k]
  ------------------
  282|    573|                GET_T(phi::size_t, new_size);
  ------------------
  |  |   10|    573|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   11|    573|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (11:9): [True: 3, False: 570]
  |  |  ------------------
  |  |   12|    573|    {                                                                                              \
  |  |   13|      3|        return 0;                                                                                  \
  |  |   14|      3|    }                                                                                              \
  |  |   15|    573|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  283|       |
  284|       |                // Reject too big resizes
  285|    570|                if (new_size > max_size)
  ------------------
  |  Branch (285:21): [True: 5, False: 565]
  ------------------
  286|      5|                {
  287|      5|                    return 0;
  288|      5|                }
  289|       |
  290|    565|                FUZZ_LOG("Resize({:s})", print_int(new_size));
  ------------------
  |  |   19|    565|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    565|        std::putc('\n', stderr);                                                                   \
  |  |   21|    565|        std::fflush(stderr)
  ------------------
  291|    565|                memory_block.Resize(new_size);
  292|    565|                break;
  293|    570|            }
  294|       |
  295|       |            // GetRawMemory
  296|     66|            case 22: {
  ------------------
  |  Branch (296:13): [True: 66, False: 187k]
  ------------------
  297|     66|                FUZZ_LOG("GetRawMemory()");
  ------------------
  |  |   19|     66|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|     66|        std::putc('\n', stderr);                                                                   \
  |  |   21|     66|        std::fflush(stderr)
  ------------------
  298|     66|                (void)memory_block.GetRawMemory();
  299|     66|                break;
  300|    570|            }
  301|       |
  302|       |            // GetRawMemory const
  303|     80|            case 23: {
  ------------------
  |  Branch (303:13): [True: 80, False: 187k]
  ------------------
  304|     80|                const dlx::MemoryBlock const_memory_block = memory_block;
  305|     80|                FUZZ_LOG("const GetRawMemory()");
  ------------------
  |  |   19|     80|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|     80|        std::putc('\n', stderr);                                                                   \
  |  |   21|     80|        std::fflush(stderr)
  ------------------
  306|     80|                (void)memory_block.GetRawMemory();
  307|     80|                break;
  308|    570|            }
  309|   187k|        }
  310|   187k|    }
  311|       |
  312|    854|    FUZZ_LOG("Finished execution");
  ------------------
  |  |   19|    854|        fmt::print(stderr, __VA_ARGS__);                                                           \
  |  |   20|    854|        std::putc('\n', stderr);                                                                   \
  |  |   21|    854|        std::fflush(stderr)
  ------------------
  313|       |
  314|    854|    return 0;
  315|  2.63k|}
_Z9consume_tIjEN3phi8optionalIT_EEPKhmRm:
   43|   188k|{
   44|   188k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 1.35k, False: 187k]
  ------------------
   45|  1.35k|    {
   46|  1.35k|        return {};
   47|  1.35k|    }
   48|       |
   49|   187k|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|   187k|    const phi::size_t old_index = index;
   52|   187k|    index += aligned_size<T>();
   53|       |
   54|   187k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|   187k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|   187k|        return static_cast<bool>(value);
   58|   187k|    }
   59|   187k|    else
   60|   187k|    {
   61|   187k|        return *reinterpret_cast<const T*>(data + old_index);
   62|   187k|    }
   63|   187k|}
_Z10has_x_moremmm:
   28|   252k|{
   29|   252k|    return index + x < size;
   30|   252k|}
_Z12aligned_sizeIjEmv:
   36|   187k|{
   37|   187k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|   187k|}
_Z9consume_tImEN3phi8optionalIT_EEPKhmRm:
   43|  54.9k|{
   44|  54.9k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 400, False: 54.5k]
  ------------------
   45|    400|    {
   46|    400|        return {};
   47|    400|    }
   48|       |
   49|  54.5k|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|  54.5k|    const phi::size_t old_index = index;
   52|  54.5k|    index += aligned_size<T>();
   53|       |
   54|  54.5k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|  54.5k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|  54.5k|        return static_cast<bool>(value);
   58|  54.5k|    }
   59|  54.5k|    else
   60|  54.5k|    {
   61|  54.5k|        return *reinterpret_cast<const T*>(data + old_index);
   62|  54.5k|    }
   63|  54.5k|}
_Z12aligned_sizeImEmv:
   36|  54.5k|{
   37|  54.5k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|  54.5k|}
_Z9print_intImENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
   67|  54.4k|{
   68|  54.4k|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
   69|  54.4k|}
_Z9consume_tIaEN3phi8optionalIT_EEPKhmRm:
   43|    600|{
   44|    600|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 3, False: 597]
  ------------------
   45|      3|    {
   46|      3|        return {};
   47|      3|    }
   48|       |
   49|    597|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|    597|    const phi::size_t old_index = index;
   52|    597|    index += aligned_size<T>();
   53|       |
   54|    597|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|    597|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|    597|        return static_cast<bool>(value);
   58|    597|    }
   59|    597|    else
   60|    597|    {
   61|    597|        return *reinterpret_cast<const T*>(data + old_index);
   62|    597|    }
   63|    597|}
_Z12aligned_sizeIaEmv:
   36|    597|{
   37|    597|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|    597|}
_Z9print_intIaENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
   67|    597|{
   68|    597|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
   69|    597|}
_Z9consume_tIhEN3phi8optionalIT_EEPKhmRm:
   43|    393|{
   44|    393|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 3, False: 390]
  ------------------
   45|      3|    {
   46|      3|        return {};
   47|      3|    }
   48|       |
   49|    390|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|    390|    const phi::size_t old_index = index;
   52|    390|    index += aligned_size<T>();
   53|       |
   54|    390|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|    390|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|    390|        return static_cast<bool>(value);
   58|    390|    }
   59|    390|    else
   60|    390|    {
   61|    390|        return *reinterpret_cast<const T*>(data + old_index);
   62|    390|    }
   63|    390|}
_Z12aligned_sizeIhEmv:
   36|    390|{
   37|    390|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|    390|}
_Z9print_intIhENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
   67|    390|{
   68|    390|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
   69|    390|}
_Z9consume_tIsEN3phi8optionalIT_EEPKhmRm:
   43|  1.45k|{
   44|  1.45k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 3, False: 1.45k]
  ------------------
   45|      3|    {
   46|      3|        return {};
   47|      3|    }
   48|       |
   49|  1.45k|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|  1.45k|    const phi::size_t old_index = index;
   52|  1.45k|    index += aligned_size<T>();
   53|       |
   54|  1.45k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|  1.45k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|  1.45k|        return static_cast<bool>(value);
   58|  1.45k|    }
   59|  1.45k|    else
   60|  1.45k|    {
   61|  1.45k|        return *reinterpret_cast<const T*>(data + old_index);
   62|  1.45k|    }
   63|  1.45k|}
_Z12aligned_sizeIsEmv:
   36|  1.45k|{
   37|  1.45k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|  1.45k|}
_Z9print_intIsENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
   67|  1.45k|{
   68|  1.45k|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
   69|  1.45k|}
_Z9consume_tItEN3phi8optionalIT_EEPKhmRm:
   43|    318|{
   44|    318|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 3, False: 315]
  ------------------
   45|      3|    {
   46|      3|        return {};
   47|      3|    }
   48|       |
   49|    315|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|    315|    const phi::size_t old_index = index;
   52|    315|    index += aligned_size<T>();
   53|       |
   54|    315|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|    315|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|    315|        return static_cast<bool>(value);
   58|    315|    }
   59|    315|    else
   60|    315|    {
   61|    315|        return *reinterpret_cast<const T*>(data + old_index);
   62|    315|    }
   63|    315|}
_Z12aligned_sizeItEmv:
   36|    315|{
   37|    315|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|    315|}
_Z9print_intItENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
   67|    315|{
   68|    315|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
   69|    315|}
_Z9consume_tIiEN3phi8optionalIT_EEPKhmRm:
   43|    858|{
   44|    858|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 5, False: 853]
  ------------------
   45|      5|    {
   46|      5|        return {};
   47|      5|    }
   48|       |
   49|    853|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|    853|    const phi::size_t old_index = index;
   52|    853|    index += aligned_size<T>();
   53|       |
   54|    853|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|    853|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|    853|        return static_cast<bool>(value);
   58|    853|    }
   59|    853|    else
   60|    853|    {
   61|    853|        return *reinterpret_cast<const T*>(data + old_index);
   62|    853|    }
   63|    853|}
_Z12aligned_sizeIiEmv:
   36|    853|{
   37|    853|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|    853|}
_Z9print_intIiENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
   67|    853|{
   68|    853|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
   69|    853|}
_Z9print_intIjENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEET_:
   67|    224|{
   68|    224|    return fmt::format("{0:d} 0x{1:02X}", val, static_cast<phi::make_unsigned_t<T>>(val));
   69|    224|}
_Z9consume_tIfEN3phi8optionalIT_EEPKhmRm:
   43|  1.99k|{
   44|  1.99k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 4, False: 1.99k]
  ------------------
   45|      4|    {
   46|      4|        return {};
   47|      4|    }
   48|       |
   49|  1.99k|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|  1.99k|    const phi::size_t old_index = index;
   52|  1.99k|    index += aligned_size<T>();
   53|       |
   54|  1.99k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|  1.99k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|  1.99k|        return static_cast<bool>(value);
   58|  1.99k|    }
   59|  1.99k|    else
   60|  1.99k|    {
   61|  1.99k|        return *reinterpret_cast<const T*>(data + old_index);
   62|  1.99k|    }
   63|  1.99k|}
_Z12aligned_sizeIfEmv:
   36|  1.99k|{
   37|  1.99k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|  1.99k|}
_Z9consume_tIdEN3phi8optionalIT_EEPKhmRm:
   43|  3.22k|{
   44|  3.22k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (44:9): [True: 5, False: 3.22k]
  ------------------
   45|      5|    {
   46|      5|        return {};
   47|      5|    }
   48|       |
   49|  3.22k|    PHI_ASSUME(index % sizeof(void*) == 0);
   50|       |
   51|  3.22k|    const phi::size_t old_index = index;
   52|  3.22k|    index += aligned_size<T>();
   53|       |
   54|  3.22k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (54:19): [Folded - Ignored]
  ------------------
   55|      0|    {
   56|  3.22k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
   57|  3.22k|        return static_cast<bool>(value);
   58|  3.22k|    }
   59|  3.22k|    else
   60|  3.22k|    {
   61|  3.22k|        return *reinterpret_cast<const T*>(data + old_index);
   62|  3.22k|    }
   63|  3.22k|}
_Z12aligned_sizeIdEmv:
   36|  3.22k|{
   37|  3.22k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
   38|  3.22k|}

