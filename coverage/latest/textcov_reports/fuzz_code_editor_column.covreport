_ZN6dlxemu10CodeEditor10UndoRecordC2Ev:
  265|  73.3k|            UndoRecord() = default;

_ZN6dlxemu6WindowC2Ev:
   13|  6.34k|        Window() = default;

_ZN6dlxemu10CodeEditor11CoordinatesC2Ev:
  194|   797k|    {}
_ZN6dlxemu10CodeEditor11CoordinatesC2EN3phi7integerIjEES4_:
  199|   888k|    {}
_ZNK6dlxemu10CodeEditor11CoordinateseqERKS1_:
  202|  6.13k|    {
  203|  6.13k|        return (m_Line == other.m_Line) && (m_Column == other.m_Column);
  ------------------
  |  Branch (203:16): [True: 2.94k, False: 3.19k]
  |  Branch (203:44): [True: 1.08k, False: 1.85k]
  ------------------
  204|  6.13k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesneERKS1_:
  207|   121k|    {
  208|   121k|        return (m_Line != other.m_Line) || (m_Column != other.m_Column);
  ------------------
  |  Branch (208:16): [True: 12.5k, False: 109k]
  |  Branch (208:44): [True: 40.5k, False: 68.8k]
  ------------------
  209|   121k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesltERKS1_:
  212|  18.4k|    {
  213|  18.4k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (213:13): [True: 14.2k, False: 4.19k]
  ------------------
  214|  14.2k|        {
  215|  14.2k|            return m_Line < other.m_Line;
  216|  14.2k|        }
  217|       |
  218|  4.19k|        return m_Column < other.m_Column;
  219|  18.4k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgtERKS1_:
  222|   219k|    {
  223|   219k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (223:13): [True: 45.4k, False: 173k]
  ------------------
  224|  45.4k|        {
  225|  45.4k|            return m_Line > other.m_Line;
  226|  45.4k|        }
  227|       |
  228|   173k|        return m_Column > other.m_Column;
  229|   219k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesleERKS1_:
  232|   108k|    {
  233|   108k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (233:13): [True: 39.7k, False: 68.4k]
  ------------------
  234|  39.7k|        {
  235|  39.7k|            return m_Line < other.m_Line;
  236|  39.7k|        }
  237|       |
  238|  68.4k|        return m_Column <= other.m_Column;
  239|   108k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgeERKS1_:
  242|  15.9k|    {
  243|  15.9k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (243:13): [True: 350, False: 15.6k]
  ------------------
  244|    350|        {
  245|    350|            return m_Line > other.m_Line;
  246|    350|        }
  247|       |
  248|  15.6k|        return m_Column >= other.m_Column;
  249|  15.9k|    }
_ZN6dlxemu10CodeEditor5GlyphC2EhNS0_12PaletteIndexE:
  256|  12.1M|    {}
_ZN6dlxemu10CodeEditorC2EPNS_8EmulatorE:
  284|  12.6k|    {
  285|  12.6k|        Colorize();
  286|  12.6k|        m_Lines.emplace_back();
  287|  12.6k|    }
_ZN6dlxemu10CodeEditorD2Ev:
  290|  12.6k|    {
  291|  12.6k|        VerifyInternalState();
  292|  12.6k|    }
_ZN6dlxemu10CodeEditor15SetErrorMarkersERKNSt3__13mapIjNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS1_4lessIjEENS6_INS1_4pairIKjS8_EEEEEE:
  307|    538|    {
  308|       |        // Reject if any markers are invalid
  309|    538|        for (auto&& marker : markers)
  ------------------
  |  Branch (309:28): [True: 388, False: 320]
  ------------------
  310|    388|        {
  311|    388|            const phi::u32 line_number = marker.first;
  312|       |
  313|    388|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (313:17): [True: 138, False: 250]
  |  Branch (313:17): [True: 218, False: 170]
  |  Branch (313:38): [True: 80, False: 170]
  ------------------
  314|    218|            {
  315|    218|                return;
  316|    218|            }
  317|    388|        }
  318|       |
  319|    320|        m_ErrorMarkers = markers;
  320|    320|    }
_ZN6dlxemu10CodeEditor14AddErrorMarkerEN3phi7integerIjEERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE:
  323|   506k|    {
  324|   506k|        if (line_number > m_Lines.size() || line_number == 0u)
  ------------------
  |  Branch (324:13): [True: 8.11k, False: 498k]
  |  Branch (324:13): [True: 13.2k, False: 493k]
  |  Branch (324:45): [True: 5.08k, False: 493k]
  ------------------
  325|  13.2k|        {
  326|  13.2k|            return;
  327|  13.2k|        }
  328|       |
  329|   493k|        if (m_ErrorMarkers.find(line_number.unsafe()) != m_ErrorMarkers.end())
  ------------------
  |  Branch (329:13): [True: 473k, False: 20.3k]
  ------------------
  330|   473k|        {
  331|   473k|            m_ErrorMarkers[line_number.unsafe()] += '\n' + message;
  332|   473k|        }
  333|  20.3k|        else
  334|  20.3k|        {
  335|  20.3k|            m_ErrorMarkers[line_number.unsafe()] = message;
  336|  20.3k|        }
  337|   493k|    }
_ZN6dlxemu10CodeEditor17ClearErrorMarkersEv:
  340|  10.1k|    {
  341|  10.1k|        m_ErrorMarkers.clear();
  342|  10.1k|    }
_ZN6dlxemu10CodeEditor14SetBreakpointsERKNSt3__113unordered_setIjNS1_4hashIjEENS1_8equal_toIjEENS1_9allocatorIjEEEE:
  355|    713|    {
  356|       |        // Reject if any lines are invalid
  357|    713|        for (phi::u32 line_number : markers)
  ------------------
  |  Branch (357:35): [True: 586, False: 285]
  ------------------
  358|    586|        {
  359|    586|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (359:17): [True: 59, False: 527]
  |  Branch (359:17): [True: 428, False: 158]
  |  Branch (359:38): [True: 369, False: 158]
  ------------------
  360|    428|            {
  361|    428|                return;
  362|    428|            }
  363|    586|        }
  364|       |
  365|    285|        m_Breakpoints = markers;
  366|    285|    }
_ZN6dlxemu10CodeEditor13AddBreakpointEN3phi7integerIjEE:
  369|  1.33k|    {
  370|  1.33k|        if (line_number > m_Lines.size() || line_number == 0u)
  ------------------
  |  Branch (370:13): [True: 290, False: 1.04k]
  |  Branch (370:13): [True: 306, False: 1.03k]
  |  Branch (370:45): [True: 16, False: 1.03k]
  ------------------
  371|    306|        {
  372|    306|            return false;
  373|    306|        }
  374|       |
  375|  1.03k|        return m_Breakpoints.insert(line_number.unsafe()).second;
  376|  1.33k|    }
_ZN6dlxemu10CodeEditor16RemoveBreakpointEN3phi7integerIjEE:
  379|    314|    {
  380|    314|        auto iterator = m_Breakpoints.find(line_number.unsafe());
  381|       |
  382|    314|        if (iterator != m_Breakpoints.end())
  ------------------
  |  Branch (382:13): [True: 25, False: 289]
  ------------------
  383|     25|        {
  384|     25|            m_Breakpoints.erase(iterator);
  385|     25|            return true;
  386|     25|        }
  387|       |
  388|    289|        return false;
  389|    314|    }
_ZN6dlxemu10CodeEditor16ToggleBreakpointEN3phi7integerIjEE:
  392|  1.48k|    {
  393|  1.48k|        if (auto iterator = m_Breakpoints.find(line_number.unsafe());
  394|  1.48k|            iterator != m_Breakpoints.end())
  ------------------
  |  Branch (394:13): [True: 149, False: 1.33k]
  ------------------
  395|    149|        {
  396|    149|            m_Breakpoints.erase(iterator);
  397|    149|            return false;
  398|    149|        }
  399|       |
  400|  1.33k|        AddBreakpoint(line_number);
  401|  1.33k|        return true;
  402|  1.48k|    }
_ZN6dlxemu10CodeEditor16ClearBreakPointsEv:
  405|  1.35k|    {
  406|  1.35k|        m_Breakpoints.clear();
  407|  1.35k|    }
_ZN6dlxemu10CodeEditor6RenderERK6ImVec2N3phi7booleanE:
  420|  29.3k|    {
  421|       |        // Verify that ImGui is correctly initialized
  422|  29.3k|        PHI_ASSERT(GImGui && GImGui->Initialized, "ImGui was not initialized!");
  423|       |
  424|  29.3k|        m_CursorPositionChanged = false;
  425|       |
  426|  29.3k|        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::ColorConvertU32ToFloat4(GetPaletteForIndex(
  427|  29.3k|                                                        PaletteIndex::Background)));
  428|  29.3k|        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
  429|       |
  430|       |        // Assert size is properly sanitized
  431|  29.3k|        PHI_ASSERT(size.x >= 0.0f);
  432|  29.3k|        PHI_ASSERT(!(phi::is_nan(size.x) || phi::is_infinity(size.x)));
  433|       |
  434|  29.3k|        PHI_ASSERT(size.y >= 0.0f);
  435|  29.3k|        PHI_ASSERT(!(phi::is_nan(size.y) || phi::is_infinity(size.y)));
  436|       |
  437|  29.3k|        if (ImGui::Begin("Code Editor"))
  ------------------
  |  Branch (437:13): [True: 25.9k, False: 3.41k]
  ------------------
  438|  25.9k|        {
  439|  25.9k|            ImGui::BeginChild("Code Editor", size, border.unsafe(),
  440|  25.9k|                              ImGuiWindowFlags_HorizontalScrollbar |
  441|  25.9k|                                      ImGuiWindowFlags_AlwaysHorizontalScrollbar |
  442|  25.9k|                                      ImGuiWindowFlags_NoMove);
  443|       |
  444|       |            // Need to calculate char advance before any inputs which use the values
  445|  25.9k|            ComputeCharAdvance();
  446|       |
  447|  25.9k|            HandleKeyboardInputs();
  448|  25.9k|            ImGui::PushTabStop(true);
  449|       |
  450|  25.9k|            HandleMouseInputs();
  451|       |
  452|  25.9k|            if (m_TextChanged)
  ------------------
  |  Branch (452:17): [True: 8.22k, False: 17.7k]
  ------------------
  453|  8.22k|            {
  454|  8.22k|                m_FullText = GetText();
  455|       |
  456|  8.22k|                m_Emulator->ParseProgram(m_FullText);
  457|       |
  458|  8.22k|                ColorizeInternal();
  459|       |
  460|  8.22k|                ClearErrorMarkers();
  461|       |
  462|       |                // Add error markers
  463|  8.22k|                for (const dlx::ParseError& err : m_Emulator->m_DLXProgram.m_ParseErrors)
  ------------------
  |  Branch (463:49): [True: 492k, False: 8.22k]
  ------------------
  464|   492k|                {
  465|   492k|                    AddErrorMarker(static_cast<phi::uint32_t>(err.GetLineNumber()),
  466|   492k|                                   err.ConstructMessage());
  467|   492k|                }
  468|       |
  469|  8.22k|                m_TextChanged = false;
  470|  8.22k|            }
  471|       |
  472|  25.9k|            InternalRender();
  473|       |
  474|  25.9k|            ImGui::PopTabStop();
  475|       |
  476|  25.9k|            ImGui::EndChild();
  477|  25.9k|        }
  478|  29.3k|        ImGui::End();
  479|       |
  480|  29.3k|        ImGui::PopStyleVar();
  481|  29.3k|        ImGui::PopStyleColor();
  482|  29.3k|    }
_ZN6dlxemu10CodeEditor7SetTextERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  485|    135|    {
  486|    135|        m_Lines.clear();
  487|    135|        ResetState();
  488|    135|        m_Lines.emplace_back();
  489|       |
  490|    135|        for (const char character : text)
  ------------------
  |  Branch (490:35): [True: 0, False: 135]
  ------------------
  491|      0|        {
  492|      0|            if (character == '\r' ||
  ------------------
  |  Branch (492:17): [True: 0, False: 0]
  |  Branch (492:17): [True: 0, False: 0]
  ------------------
  493|      0|                (phi::is_control(character) && character != '\n' && character != '\t'))
  ------------------
  |  Branch (493:18): [True: 0, False: 0]
  |  Branch (493:48): [True: 0, False: 0]
  |  Branch (493:69): [True: 0, False: 0]
  ------------------
  494|      0|            {
  495|       |                // ignore the carriage return character and control characters
  496|      0|            }
  497|      0|            else if (character == '\n')
  ------------------
  |  Branch (497:22): [True: 0, False: 0]
  ------------------
  498|      0|            {
  499|      0|                m_Lines.emplace_back();
  500|      0|            }
  501|      0|            else
  502|      0|            {
  503|      0|                m_Lines.back().emplace_back(static_cast<Char>(character), PaletteIndex::Default);
  504|      0|            }
  505|      0|        }
  506|       |
  507|    135|        m_TextChanged = true;
  508|    135|        m_ScrollToTop = true;
  509|       |
  510|    135|        m_UndoBuffer.clear();
  511|    135|        m_UndoIndex = 0u;
  512|       |
  513|    135|        Colorize();
  514|    135|    }
_ZNK6dlxemu10CodeEditor7GetTextEv:
  517|  10.9k|    {
  518|  10.9k|        const phi::u32 max_line = GetMaxLineNumber();
  519|       |
  520|  10.9k|        return GetText(Coordinates(0u, 0u), Coordinates(max_line, GetLineMaxColumn(max_line)));
  521|  10.9k|    }
_ZN6dlxemu10CodeEditor9ClearTextEv:
  524|    521|    {
  525|    521|        PHI_ASSERT(!m_Lines.empty());
  526|       |
  527|    521|        if (IsReadOnly())
  ------------------
  |  Branch (527:13): [True: 72, False: 449]
  ------------------
  528|     72|        {
  529|     72|            return;
  530|     72|        }
  531|       |
  532|       |        // No text to clear
  533|    449|        if (m_Lines.size() == 1u && m_Lines[0u].empty())
  ------------------
  |  Branch (533:13): [True: 97, False: 352]
  |  Branch (533:37): [True: 58, False: 39]
  ------------------
  534|     58|        {
  535|     58|            return;
  536|     58|        }
  537|       |
  538|    391|        UndoRecord undo;
  539|    391|        undo.StoreBeforeState(this);
  540|       |
  541|    391|        undo.m_Removed      = GetText();
  542|    391|        undo.m_RemovedStart = Coordinates(0u, 0u);
  543|    391|        phi::u32 max_line   = GetMaxLineNumber();
  544|    391|        undo.m_RemovedEnd   = Coordinates(max_line, GetLineMaxColumn(max_line));
  545|       |
  546|    391|        m_Lines.clear();
  547|    391|        m_Lines.emplace_back();
  548|    391|        ResetState();
  549|       |
  550|    391|        undo.StoreAfterState(this);
  551|    391|        AddUndo(undo);
  552|    391|    }
_ZN6dlxemu10CodeEditor12SetTextLinesERKNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE:
  555|    825|    {
  556|    825|        m_Lines.clear();
  557|    825|        ResetState();
  558|       |
  559|    825|        if (lines.empty())
  ------------------
  |  Branch (559:13): [True: 225, False: 600]
  ------------------
  560|    225|        {
  561|    225|            m_Lines.emplace_back();
  562|    225|        }
  563|    600|        else
  564|    600|        {
  565|    600|            m_Lines.resize(lines.size());
  566|       |
  567|    600|            phi::usize line_number{0u};
  568|  4.59k|            for (phi::usize index = 0u; index < lines.size(); ++index, ++line_number)
  ------------------
  |  Branch (568:41): [True: 3.99k, False: 600]
  ------------------
  569|  3.99k|            {
  570|  3.99k|                const std::string& line = lines[index.unsafe()];
  571|       |
  572|  3.99k|                m_Lines[line_number.unsafe()].reserve(line.size());
  573|  3.99k|                for (char character : line)
  ------------------
  |  Branch (573:37): [True: 0, False: 3.99k]
  ------------------
  574|      0|                {
  575|      0|                    if (character == '\n')
  ------------------
  |  Branch (575:25): [True: 0, False: 0]
  ------------------
  576|      0|                    {
  577|       |                        // Hang on an extra line at the end
  578|      0|                        m_Lines.emplace_back();
  579|       |
  580|       |                        // Increase line number
  581|      0|                        line_number += 1u;
  582|      0|                    }
  583|      0|                    else
  584|      0|                    {
  585|      0|                        m_Lines[line_number.unsafe()].emplace_back(static_cast<Char>(character),
  586|      0|                                                                   PaletteIndex::Default);
  587|      0|                    }
  588|      0|                }
  589|  3.99k|            }
  590|    600|        }
  591|       |
  592|    825|        m_TextChanged = true;
  593|    825|        m_ScrollToTop = true;
  594|       |
  595|    825|        m_UndoBuffer.clear();
  596|    825|        m_UndoIndex = 0u;
  597|       |
  598|    825|        Colorize();
  599|    825|    }
_ZNK6dlxemu10CodeEditor12GetTextLinesEv:
  602|    287|    {
  603|    287|        std::vector<std::string> result;
  604|       |
  605|    287|        result.reserve(m_Lines.size());
  606|       |
  607|    287|        for (const Line& line : m_Lines)
  ------------------
  |  Branch (607:31): [True: 2.37k, False: 287]
  ------------------
  608|  2.37k|        {
  609|  2.37k|            std::string text;
  610|       |
  611|  2.37k|            text.resize(line.size());
  612|       |
  613|  27.1k|            for (size_t i = 0; i < line.size(); ++i)
  ------------------
  |  Branch (613:32): [True: 24.7k, False: 2.37k]
  ------------------
  614|  24.7k|            {
  615|  24.7k|                text[i] = static_cast<char>(line[i].m_Char);
  616|  24.7k|            }
  617|       |
  618|  2.37k|            result.emplace_back(phi::move(text));
  619|  2.37k|        }
  620|       |
  621|    287|        return result;
  622|    287|    }
_ZNK6dlxemu10CodeEditor15GetSelectedTextEv:
  625|  2.61k|    {
  626|  2.61k|        return GetText(m_State.m_SelectionStart, m_State.m_SelectionEnd);
  627|  2.61k|    }
_ZNK6dlxemu10CodeEditor18GetCurrentLineTextEv:
  630|    483|    {
  631|    483|        const phi::u32 line_length = GetLineMaxColumn(m_State.m_CursorPosition.m_Line);
  632|       |
  633|    483|        return GetText(Coordinates(m_State.m_CursorPosition.m_Line, 0u),
  634|    483|                       Coordinates(m_State.m_CursorPosition.m_Line, line_length));
  635|    483|    }
_ZN6dlxemu10CodeEditor12SetOverwriteEN3phi7booleanE:
  643|    258|    {
  644|    258|        m_Overwrite = overwrite;
  645|    258|    }
_ZN6dlxemu10CodeEditor11SetReadOnlyEN3phi7booleanE:
  658|    305|    {
  659|    305|        m_ReadOnly = value;
  660|    305|    }
_ZNK6dlxemu10CodeEditor10IsReadOnlyEv:
  668|   183k|    {
  669|   183k|        return m_ReadOnly;
  670|   183k|    }
_ZN6dlxemu10CodeEditor18SetColorizerEnableEN3phi7booleanE:
  683|    106|    {
  684|    106|        m_ColorizerEnabled = value;
  685|    106|    }
_ZNK6dlxemu10CodeEditor17GetCursorPositionEv:
  698|  75.0k|    {
  699|  75.0k|        return GetActualCursorCoordinates();
  700|  75.0k|    }
_ZN6dlxemu10CodeEditor17SetCursorPositionERKNS0_11CoordinatesE:
  703|  43.1k|    {
  704|       |        // Sanitize
  705|  43.1k|        const Coordinates new_pos = SanitizeCoordinates(position);
  706|       |
  707|  43.1k|        if (m_State.m_CursorPosition != new_pos)
  ------------------
  |  Branch (707:13): [True: 37.7k, False: 5.44k]
  ------------------
  708|  37.7k|        {
  709|  37.7k|            m_State.m_CursorPosition = new_pos;
  710|  37.7k|            m_CursorPositionChanged  = true;
  711|  37.7k|            EnsureCursorVisible();
  712|  37.7k|        }
  713|  43.1k|    }
_ZN6dlxemu10CodeEditor18SetShowWhitespacesEN3phi7booleanE:
  716|     78|    {
  717|     78|        m_ShowWhitespaces = value;
  718|     78|    }
_ZN6dlxemu10CodeEditor10SetTabSizeEN3phi7integerIhEE:
  731|    328|    {
  732|    328|        new_tab_size = phi::clamp(new_tab_size, MinTabSize, MaxTabSize);
  733|       |
  734|    328|        if (new_tab_size != m_TabSize)
  ------------------
  |  Branch (734:13): [True: 193, False: 135]
  ------------------
  735|    193|        {
  736|       |            // Save old character indexes
  737|    193|            const phi::u32 cursor_char_index          = GetCharacterIndex(m_State.m_CursorPosition);
  738|    193|            const phi::u32 selection_start_char_index = GetCharacterIndex(m_State.m_SelectionStart);
  739|    193|            const phi::u32 selection_end_char_index   = GetCharacterIndex(m_State.m_SelectionEnd);
  740|       |
  741|       |            // Update tab size
  742|    193|            m_TabSize = new_tab_size;
  743|       |
  744|       |            // Set new character indexes
  745|    193|            m_State.m_CursorPosition.m_Column =
  746|    193|                    GetCharacterColumn(m_State.m_CursorPosition.m_Line, cursor_char_index);
  747|    193|            m_State.m_SelectionStart.m_Column =
  748|    193|                    GetCharacterColumn(m_State.m_SelectionStart.m_Line, selection_start_char_index);
  749|    193|            m_State.m_SelectionEnd.m_Column =
  750|    193|                    GetCharacterColumn(m_State.m_SelectionEnd.m_Line, selection_end_char_index);
  751|    193|        }
  752|    328|    }
_ZN6dlxemu10CodeEditor14EnterCharacterEtN3phi7booleanE:
  760|  25.2k|    {
  761|  25.2k|        if (!IsReadOnly() && character != '\0' && IsValidUTF8Sequence(character))
  ------------------
  |  Branch (761:13): [True: 24.9k, False: 353]
  |  Branch (761:13): [True: 24.3k, False: 931]
  |  Branch (761:30): [True: 24.4k, False: 512]
  |  Branch (761:51): [True: 24.3k, False: 66]
  ------------------
  762|  24.3k|        {
  763|  24.3k|            EnterCharacterImpl(character, shift);
  764|  24.3k|        }
  765|  25.2k|    }
_ZN6dlxemu10CodeEditor9BackspaceEv:
  768|  1.20k|    {
  769|  1.20k|        if (!IsReadOnly())
  ------------------
  |  Branch (769:13): [True: 1.13k, False: 72]
  ------------------
  770|  1.13k|        {
  771|  1.13k|            BackspaceImpl();
  772|  1.13k|        }
  773|  1.20k|    }
_ZN6dlxemu10CodeEditor10InsertTextERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  776|    246|    {
  777|    246|        InsertText(value.c_str());
  778|    246|    }
_ZN6dlxemu10CodeEditor10InsertTextEPKc:
  781|  8.20k|    {
  782|  8.20k|        if (value == nullptr || m_ReadOnly)
  ------------------
  |  Branch (782:13): [True: 0, False: 8.20k]
  |  Branch (782:33): [True: 67, False: 8.13k]
  ------------------
  783|     67|        {
  784|     67|            return;
  785|     67|        }
  786|       |
  787|  8.13k|        Coordinates       pos         = GetActualCursorCoordinates();
  788|  8.13k|        const Coordinates start       = HasSelection() ? m_State.m_SelectionStart : pos;
  ------------------
  |  Branch (788:41): [True: 13, False: 8.12k]
  ------------------
  789|  8.13k|        phi::u32          total_lines = pos.m_Line - start.m_Line;
  790|       |
  791|  8.13k|        total_lines += InsertTextAt(pos, value);
  792|       |
  793|  8.13k|        SetSelection(pos, pos);
  794|  8.13k|        SetCursorPosition(pos);
  795|       |
  796|  8.13k|        Colorize(start.m_Line, total_lines);
  797|  8.13k|    }
_ZN6dlxemu10CodeEditor6MoveUpEN3phi7integerIjEENS1_7booleanE:
  800|    979|    {
  801|    979|        if (amount == 0u)
  ------------------
  |  Branch (801:13): [True: 58, False: 921]
  ------------------
  802|     58|        {
  803|     58|            return;
  804|     58|        }
  805|       |
  806|    921|        const Coordinates old_pos = m_State.m_CursorPosition;
  807|       |
  808|       |        // Move cursor to the beginning of the first line
  809|    921|        if (amount > old_pos.m_Line)
  ------------------
  |  Branch (809:13): [True: 901, False: 20]
  ------------------
  810|    901|        {
  811|    901|            m_State.m_CursorPosition.m_Line   = 0u;
  812|    901|            m_State.m_CursorPosition.m_Column = 0u;
  813|    901|        }
  814|     20|        else
  815|     20|        {
  816|     20|            PHI_ASSERT(amount <= m_State.m_CursorPosition.m_Line);
  817|     20|            m_State.m_CursorPosition.m_Line -= amount;
  818|     20|        }
  819|       |
  820|    921|        FixSelectionAfterMove(select, old_pos);
  821|    921|    }
_ZN6dlxemu10CodeEditor8MoveDownEN3phi7integerIjEENS1_7booleanE:
  824|    400|    {
  825|    400|        if (amount == 0u)
  ------------------
  |  Branch (825:13): [True: 64, False: 336]
  ------------------
  826|     64|        {
  827|     64|            return;
  828|     64|        }
  829|       |
  830|    336|        const Coordinates old_pos  = m_State.m_CursorPosition;
  831|    336|        const phi::u32    max_line = GetMaxLineNumber();
  832|       |
  833|    336|        PHI_ASSERT(old_pos.m_Line <= max_line);
  834|       |
  835|       |        // Move cursor to the end of the line after we reached the bottom
  836|    336|        if (amount > max_line - old_pos.m_Line)
  ------------------
  |  Branch (836:13): [True: 315, False: 21]
  ------------------
  837|    315|        {
  838|    315|            m_State.m_CursorPosition.m_Line   = max_line;
  839|    315|            m_State.m_CursorPosition.m_Column = GetLineMaxColumn(max_line);
  840|    315|        }
  841|     21|        else
  842|     21|        {
  843|     21|            m_State.m_CursorPosition.m_Line += amount;
  844|     21|        }
  845|       |
  846|    336|        PHI_ASSERT(m_State.m_CursorPosition.m_Line <= max_line);
  847|       |
  848|    336|        FixSelectionAfterMove(select, old_pos);
  849|    336|    }
_ZN6dlxemu10CodeEditor8MoveLeftEN3phi7integerIjEENS1_7booleanES4_:
  852|  2.81k|    {
  853|  2.81k|        PHI_ASSERT(!m_Lines.empty());
  854|       |
  855|  2.81k|        if (amount == 0u)
  ------------------
  |  Branch (855:13): [True: 71, False: 2.74k]
  ------------------
  856|     71|        {
  857|     71|            return;
  858|     71|        }
  859|       |
  860|  2.74k|        const Coordinates old_pos = m_State.m_CursorPosition;
  861|  2.74k|        m_State.m_CursorPosition  = GetActualCursorCoordinates();
  862|  2.74k|        phi::u32 line             = m_State.m_CursorPosition.m_Line;
  863|  2.74k|        phi::u32 cindex           = GetCharacterIndex(m_State.m_CursorPosition);
  864|       |
  865|  47.2k|        while (amount > 0u)
  ------------------
  |  Branch (865:16): [True: 44.4k, False: 2.74k]
  ------------------
  866|  44.4k|        {
  867|  44.4k|            amount -= 1u;
  868|       |
  869|  44.4k|            if (cindex == 0u)
  ------------------
  |  Branch (869:17): [True: 15.8k, False: 28.6k]
  ------------------
  870|  15.8k|            {
  871|  15.8k|                if (line == 0u)
  ------------------
  |  Branch (871:21): [True: 2.71k, False: 13.1k]
  ------------------
  872|  2.71k|                {
  873|       |                    // We're already on the last line so we can't move further left
  874|  2.71k|                    amount = 0u;
  875|  2.71k|                }
  876|  13.1k|                else
  877|  13.1k|                {
  878|  13.1k|                    line -= 1u;
  879|  13.1k|                    cindex = static_cast<phi::uint32_t>(m_Lines[line.unsafe()].size());
  880|  13.1k|                }
  881|  15.8k|            }
  882|  28.6k|            else
  883|  28.6k|            {
  884|  28.6k|                --cindex;
  885|  28.6k|                if (cindex > 0u && m_Lines.size() > line)
  ------------------
  |  Branch (885:21): [True: 26.3k, False: 2.26k]
  |  Branch (885:21): [True: 26.3k, False: 2.26k]
  |  Branch (885:36): [True: 26.3k, False: 0]
  ------------------
  886|  26.3k|                {
  887|  49.0k|                    while (cindex > 0u &&
  ------------------
  |  Branch (887:28): [True: 44.3k, False: 4.71k]
  |  Branch (887:28): [True: 22.6k, False: 26.3k]
  ------------------
  888|  49.0k|                           IsUTFSequence(m_Lines[line.unsafe()][cindex.unsafe()].m_Char))
  ------------------
  |  Branch (888:28): [True: 22.6k, False: 21.6k]
  ------------------
  889|  22.6k|                    {
  890|  22.6k|                        --cindex;
  891|  22.6k|                    }
  892|  26.3k|                }
  893|  28.6k|            }
  894|       |
  895|  44.4k|            m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  896|  44.4k|            if (word_mode)
  ------------------
  |  Branch (896:17): [True: 29.5k, False: 14.8k]
  ------------------
  897|  29.5k|            {
  898|  29.5k|                m_State.m_CursorPosition = FindWordStart(m_State.m_CursorPosition);
  899|  29.5k|                cindex                   = GetCharacterIndex(m_State.m_CursorPosition);
  900|  29.5k|            }
  901|  44.4k|        }
  902|       |
  903|  2.74k|        m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  904|  2.74k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
  905|       |
  906|  2.74k|        FixSelectionAfterMove(select, old_pos);
  907|  2.74k|    }
_ZN6dlxemu10CodeEditor9MoveRightEN3phi7integerIjEENS1_7booleanES4_:
  911|    468|    {
  912|    468|        const Coordinates old_pos = m_State.m_CursorPosition;
  913|       |
  914|    468|        if (old_pos.m_Line >= m_Lines.size() || amount == 0u)
  ------------------
  |  Branch (914:13): [True: 0, False: 468]
  |  Branch (914:13): [True: 74, False: 394]
  |  Branch (914:49): [True: 74, False: 394]
  ------------------
  915|     74|        {
  916|     74|            return;
  917|     74|        }
  918|       |
  919|    394|        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
  920|  9.58k|        while (amount > 0u)
  ------------------
  |  Branch (920:16): [True: 9.43k, False: 146]
  ------------------
  921|  9.43k|        {
  922|  9.43k|            amount -= 1u;
  923|       |
  924|  9.43k|            const phi::u32 lindex = m_State.m_CursorPosition.m_Line;
  925|  9.43k|            PHI_ASSERT(lindex < m_Lines.size());
  926|  9.43k|            const Line& line = m_Lines[lindex.unsafe()];
  927|       |
  928|  9.43k|            if (cindex >= line.size())
  ------------------
  |  Branch (928:17): [True: 728, False: 8.70k]
  ------------------
  929|    728|            {
  930|    728|                if (m_State.m_CursorPosition.m_Line < GetMaxLineNumber())
  ------------------
  |  Branch (930:21): [True: 480, False: 248]
  ------------------
  931|    480|                {
  932|    480|                    m_State.m_CursorPosition.m_Line =
  933|    480|                            phi::clamp(m_State.m_CursorPosition.m_Line.unsafe() + 1u, 0u,
  934|    480|                                       GetMaxLineNumber().unsafe());
  935|    480|                    m_State.m_CursorPosition.m_Column = 0u;
  936|    480|                }
  937|    248|                else
  938|    248|                {
  939|    248|                    return;
  940|    248|                }
  941|    728|            }
  942|  8.70k|            else
  943|  8.70k|            {
  944|  8.70k|                PHI_ASSERT(cindex < line.size());
  945|  8.70k|                cindex += UTF8CharLength(line[cindex.unsafe()].m_Char);
  946|  8.70k|                m_State.m_CursorPosition = Coordinates(lindex, GetCharacterColumn(lindex, cindex));
  947|       |
  948|  8.70k|                if (word_mode)
  ------------------
  |  Branch (948:21): [True: 8.24k, False: 461]
  ------------------
  949|  8.24k|                {
  950|  8.24k|                    m_State.m_CursorPosition = FindNextWord(m_State.m_CursorPosition);
  951|  8.24k|                }
  952|  8.70k|            }
  953|  9.43k|        }
  954|       |
  955|    146|        FixSelectionAfterMove(select, old_pos);
  956|    146|    }
_ZN6dlxemu10CodeEditor7MoveTopEN3phi7booleanE:
  959|  2.61k|    {
  960|  2.61k|        const Coordinates old_pos = m_State.m_CursorPosition;
  961|  2.61k|        SetCursorPosition(Coordinates(0u, 0u));
  962|       |
  963|  2.61k|        if (select)
  ------------------
  |  Branch (963:13): [True: 242, False: 2.37k]
  ------------------
  964|    242|        {
  965|    242|            m_InteractiveEnd   = old_pos;
  966|    242|            m_InteractiveStart = m_State.m_CursorPosition;
  967|    242|        }
  968|  2.37k|        else
  969|  2.37k|        {
  970|  2.37k|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
  971|  2.37k|        }
  972|       |
  973|  2.61k|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
  974|  2.61k|        EnsureCursorVisible();
  975|  2.61k|    }
_ZN6dlxemu10CodeEditor10MoveBottomEN3phi7booleanE:
  978|    288|    {
  979|    288|        const Coordinates old_pos = GetCursorPosition();
  980|       |
  981|    288|        const phi::u32 end_line = GetMaxLineNumber();
  982|    288|        Coordinates    new_pos  = Coordinates(end_line, GetLineMaxColumn(end_line));
  983|       |
  984|    288|        SetCursorPosition(new_pos);
  985|    288|        if (select)
  ------------------
  |  Branch (985:13): [True: 133, False: 155]
  ------------------
  986|    133|        {
  987|    133|            m_InteractiveStart = old_pos;
  988|    133|            m_InteractiveEnd   = new_pos;
  989|    133|        }
  990|    155|        else
  991|    155|        {
  992|    155|            m_InteractiveStart = m_InteractiveEnd = new_pos;
  993|    155|        }
  994|       |
  995|    288|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
  996|    288|        EnsureCursorVisible();
  997|    288|    }
_ZN6dlxemu10CodeEditor8MoveHomeEN3phi7booleanE:
 1000|    100|    {
 1001|    100|        const Coordinates old_pos = m_State.m_CursorPosition;
 1002|    100|        SetCursorPosition(Coordinates(m_State.m_CursorPosition.m_Line, 0u));
 1003|       |
 1004|    100|        FixSelectionAfterMove(select, old_pos);
 1005|    100|    }
_ZN6dlxemu10CodeEditor7MoveEndEN3phi7booleanE:
 1008|  1.53k|    {
 1009|  1.53k|        Coordinates old_pos = m_State.m_CursorPosition;
 1010|  1.53k|        SetCursorPosition(
 1011|  1.53k|                Coordinates(m_State.m_CursorPosition.m_Line, GetLineMaxColumn(old_pos.m_Line)));
 1012|       |
 1013|  1.53k|        FixSelectionAfterMove(select, old_pos);
 1014|  1.53k|    }
_ZN6dlxemu10CodeEditor17SetSelectionStartERKNS0_11CoordinatesE:
 1017|    156|    {
 1018|    156|        m_State.m_SelectionStart = SanitizeCoordinates(position);
 1019|    156|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1019:13): [True: 123, False: 33]
  ------------------
 1020|    123|        {
 1021|    123|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1022|    123|        }
 1023|    156|    }
_ZN6dlxemu10CodeEditor15SetSelectionEndERKNS0_11CoordinatesE:
 1026|    324|    {
 1027|    324|        m_State.m_SelectionEnd = SanitizeCoordinates(position);
 1028|    324|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1028:13): [True: 50, False: 274]
  ------------------
 1029|     50|        {
 1030|     50|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1031|     50|        }
 1032|    324|    }
_ZN6dlxemu10CodeEditor12SetSelectionERKNS0_11CoordinatesES3_NS0_13SelectionModeE:
 1038|  45.8k|    {
 1039|  45.8k|        const Coordinates old_sel_start = m_State.m_SelectionStart;
 1040|  45.8k|        const Coordinates old_sel_end   = m_State.m_SelectionEnd;
 1041|       |
 1042|  45.8k|        m_State.m_SelectionStart = SanitizeCoordinates(start);
 1043|  45.8k|        m_State.m_SelectionEnd   = SanitizeCoordinates(end);
 1044|  45.8k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1044:13): [True: 391, False: 45.4k]
  ------------------
 1045|    391|        {
 1046|    391|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1047|    391|        }
 1048|       |
 1049|  45.8k|        switch (mode)
 1050|  45.8k|        {
 1051|  45.8k|            case CodeEditor::SelectionMode::Normal:
  ------------------
  |  Branch (1051:13): [True: 45.8k, False: 89]
  ------------------
 1052|  45.8k|                break;
 1053|     54|            case CodeEditor::SelectionMode::Word: {
  ------------------
  |  Branch (1053:13): [True: 54, False: 45.8k]
  ------------------
 1054|     54|                m_State.m_SelectionStart = FindWordStart(m_State.m_SelectionStart);
 1055|     54|                if (!IsOnWordBoundary(m_State.m_SelectionEnd))
  ------------------
  |  Branch (1055:21): [True: 0, False: 54]
  ------------------
 1056|      0|                {
 1057|      0|                    m_State.m_SelectionEnd = FindWordEnd(FindWordStart(m_State.m_SelectionEnd));
 1058|      0|                }
 1059|     54|                break;
 1060|      0|            }
 1061|     35|            case CodeEditor::SelectionMode::Line: {
  ------------------
  |  Branch (1061:13): [True: 35, False: 45.8k]
  ------------------
 1062|     35|                const phi::u32 line_no   = m_State.m_SelectionEnd.m_Line;
 1063|     35|                m_State.m_SelectionStart = Coordinates(m_State.m_SelectionStart.m_Line, 0u);
 1064|     35|                m_State.m_SelectionEnd   = Coordinates(line_no, GetLineMaxColumn(line_no));
 1065|     35|                break;
 1066|      0|            }
 1067|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
 1068|      0|            default:
  ------------------
  |  Branch (1068:13): [True: 0, False: 45.8k]
  ------------------
 1069|      0|                PHI_ASSERT_NOT_REACHED();
 1070|  45.8k|#endif
 1071|  45.8k|        }
 1072|       |
 1073|  45.8k|        if (m_State.m_SelectionStart != old_sel_start || m_State.m_SelectionEnd != old_sel_end)
  ------------------
  |  Branch (1073:13): [True: 12.9k, False: 32.9k]
  |  Branch (1073:13): [True: 15.4k, False: 30.4k]
  |  Branch (1073:58): [True: 2.45k, False: 30.4k]
  ------------------
 1074|  15.4k|        {
 1075|  15.4k|            m_CursorPositionChanged = true;
 1076|  15.4k|        }
 1077|  45.8k|    }
_ZN6dlxemu10CodeEditor21SelectWordUnderCursorEv:
 1082|    663|    {
 1083|    663|        const Coordinates coords = GetCursorPosition();
 1084|    663|        SetSelection(FindWordStart(coords), FindWordEnd(coords));
 1085|    663|    }
_ZN6dlxemu10CodeEditor9SelectAllEv:
 1088|    134|    {
 1089|    134|        SetSelection(Coordinates(0u, 0u),
 1090|    134|                     Coordinates(static_cast<phi::uint32_t>(m_Lines.size()), 0u));
 1091|    134|    }
_ZN6dlxemu10CodeEditor14ClearSelectionEv:
 1094|  26.3k|    {
 1095|  26.3k|        SetSelection(Coordinates(0u, 0u), Coordinates(0u, 0u));
 1096|  26.3k|    }
_ZNK6dlxemu10CodeEditor12HasSelectionEv:
 1099|  77.2k|    {
 1100|  77.2k|        return m_State.m_SelectionEnd > m_State.m_SelectionStart;
 1101|  77.2k|    }
_ZNK6dlxemu10CodeEditor17GetSelectionStartEv:
 1104|  73.7k|    {
 1105|  73.7k|        return m_State.m_SelectionStart;
 1106|  73.7k|    }
_ZNK6dlxemu10CodeEditor15GetSelectionEndEv:
 1109|  73.7k|    {
 1110|  73.7k|        return m_State.m_SelectionEnd;
 1111|  73.7k|    }
_ZNK6dlxemu10CodeEditor4CopyEv:
 1114|  7.08k|    {
 1115|  7.08k|        if (HasSelection())
  ------------------
  |  Branch (1115:13): [True: 857, False: 6.22k]
  ------------------
 1116|    857|        {
 1117|    857|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1118|    857|            m_FuzzingClipboardText = GetSelectedText();
 1119|       |#else
 1120|       |            ImGui::SetClipboardText(GetSelectedText().c_str());
 1121|       |#endif
 1122|    857|        }
 1123|  6.22k|        else
 1124|  6.22k|        {
 1125|  6.22k|            PHI_ASSERT(!m_Lines.empty());
 1126|       |
 1127|  6.22k|            std::string str;
 1128|  6.22k|            const Line& line = m_Lines[GetActualCursorCoordinates().m_Line.unsafe()];
 1129|       |
 1130|  6.22k|            for (const Glyph& glyph : line)
  ------------------
  |  Branch (1130:37): [True: 22.4M, False: 6.22k]
  ------------------
 1131|  22.4M|            {
 1132|  22.4M|                str.push_back(static_cast<char>(glyph.m_Char));
 1133|  22.4M|            }
 1134|       |
 1135|  6.22k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1136|  6.22k|            m_FuzzingClipboardText = str;
 1137|       |#else
 1138|       |            ImGui::SetClipboardText(str.c_str());
 1139|       |#endif
 1140|  6.22k|        }
 1141|  7.08k|    }
_ZN6dlxemu10CodeEditor3CutEv:
 1144|    101|    {
 1145|    101|        if (IsReadOnly())
  ------------------
  |  Branch (1145:13): [True: 29, False: 72]
  ------------------
 1146|     29|        {
 1147|     29|            Copy();
 1148|     29|        }
 1149|     72|        else
 1150|     72|        {
 1151|     72|            if (HasSelection())
  ------------------
  |  Branch (1151:17): [True: 45, False: 27]
  ------------------
 1152|     45|            {
 1153|     45|                UndoRecord undo;
 1154|     45|                undo.StoreBeforeState(this);
 1155|     45|                undo.m_Removed      = GetSelectedText();
 1156|     45|                undo.m_RemovedStart = m_State.m_SelectionStart;
 1157|     45|                undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1158|       |
 1159|     45|                Copy();
 1160|     45|                DeleteSelection();
 1161|       |
 1162|     45|                undo.StoreAfterState(this);
 1163|     45|                AddUndo(undo);
 1164|     45|            }
 1165|     72|        }
 1166|    101|    }
_ZN6dlxemu10CodeEditor5PasteEv:
 1169|  8.74k|    {
 1170|  8.74k|        if (IsReadOnly())
  ------------------
  |  Branch (1170:13): [True: 179, False: 8.56k]
  ------------------
 1171|    179|        {
 1172|    179|            return;
 1173|    179|        }
 1174|       |
 1175|  8.56k|        const char* clip_text =
 1176|  8.56k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1177|  8.56k|                m_FuzzingClipboardText.c_str();
 1178|       |#else
 1179|       |                ImGui::GetClipboardText();
 1180|       |#endif
 1181|  8.56k|        if (phi::string_length(clip_text) == 0u)
  ------------------
  |  Branch (1181:13): [True: 607, False: 7.95k]
  ------------------
 1182|    607|        {
 1183|    607|            return;
 1184|    607|        }
 1185|       |
 1186|  7.95k|        UndoRecord undo;
 1187|  7.95k|        undo.StoreBeforeState(this);
 1188|       |
 1189|  7.95k|        if (HasSelection())
  ------------------
  |  Branch (1189:13): [True: 634, False: 7.32k]
  ------------------
 1190|    634|        {
 1191|    634|            undo.m_Removed      = GetSelectedText();
 1192|    634|            undo.m_RemovedStart = m_State.m_SelectionStart;
 1193|    634|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1194|    634|            DeleteSelection();
 1195|    634|        }
 1196|       |
 1197|  7.95k|        undo.m_Added      = clip_text;
 1198|  7.95k|        undo.m_AddedStart = GetActualCursorCoordinates();
 1199|       |
 1200|  7.95k|        InsertText(clip_text);
 1201|       |
 1202|  7.95k|        undo.m_AddedEnd = GetActualCursorCoordinates();
 1203|  7.95k|        undo.StoreAfterState(this);
 1204|       |
 1205|  7.95k|        AddUndo(undo);
 1206|  7.95k|    }
_ZN6dlxemu10CodeEditor6DeleteEv:
 1209|    870|    {
 1210|    870|        PHI_ASSERT(!m_Lines.empty());
 1211|       |
 1212|    870|        if (m_ReadOnly)
  ------------------
  |  Branch (1212:13): [True: 36, False: 834]
  ------------------
 1213|     36|        {
 1214|     36|            return;
 1215|     36|        }
 1216|       |
 1217|    834|        UndoRecord undo;
 1218|    834|        undo.StoreBeforeState(this);
 1219|       |
 1220|    834|        if (HasSelection())
  ------------------
  |  Branch (1220:13): [True: 137, False: 697]
  ------------------
 1221|    137|        {
 1222|    137|            undo.m_Removed      = GetSelectedText();
 1223|    137|            undo.m_RemovedStart = m_State.m_SelectionStart;
 1224|    137|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1225|       |
 1226|    137|            DeleteSelection();
 1227|    137|        }
 1228|    697|        else
 1229|    697|        {
 1230|    697|            const Coordinates pos = GetActualCursorCoordinates();
 1231|    697|            PHI_ASSERT(pos.m_Line < m_Lines.size());
 1232|    697|            PHI_ASSERT(pos.m_Column <= GetLineMaxColumn(pos.m_Line));
 1233|       |
 1234|    697|            SetCursorPosition(pos);
 1235|    697|            Line& line = m_Lines[pos.m_Line.unsafe()];
 1236|       |
 1237|    697|            if (pos.m_Column == GetLineMaxColumn(pos.m_Line))
  ------------------
  |  Branch (1237:17): [True: 485, False: 212]
  ------------------
 1238|    485|            {
 1239|    485|                if (pos.m_Line == GetMaxLineNumber())
  ------------------
  |  Branch (1239:21): [True: 112, False: 373]
  ------------------
 1240|    112|                {
 1241|    112|                    return;
 1242|    112|                }
 1243|       |
 1244|    373|                undo.m_Removed      = '\n';
 1245|    373|                undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 1246|    373|                Advance(undo.m_RemovedEnd);
 1247|       |
 1248|    373|                PHI_ASSERT(pos.m_Line + 1u < m_Lines.size());
 1249|    373|                const Line& next_line = m_Lines[pos.m_Line.unsafe() + 1];
 1250|    373|                line.insert(line.end(), next_line.begin(), next_line.end());
 1251|       |
 1252|    373|                PHI_ASSERT(pos.m_Line <= m_Lines.size());
 1253|    373|                RemoveLine(pos.m_Line + 1u);
 1254|    373|            }
 1255|    212|            else
 1256|    212|            {
 1257|       |                // Nothing todo when line is empty
 1258|    212|                if (line.empty())
  ------------------
  |  Branch (1258:21): [True: 0, False: 212]
  ------------------
 1259|      0|                {
 1260|      0|                    return;
 1261|      0|                }
 1262|       |
 1263|    212|                const phi::u32 cindex = GetCharacterIndex(pos);
 1264|    212|                PHI_ASSERT(cindex < line.size());
 1265|       |
 1266|    212|                const Coordinates current_cursor_pos = GetActualCursorCoordinates();
 1267|    212|                undo.m_RemovedStart                  = current_cursor_pos;
 1268|    212|                undo.m_RemovedEnd                    = current_cursor_pos;
 1269|    212|                undo.m_RemovedEnd.m_Column++;
 1270|    212|                undo.m_Removed = GetText(undo.m_RemovedStart, undo.m_RemovedEnd);
 1271|       |
 1272|    212|                phi::u8_fast length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1273|    707|                while (length > 0u && cindex < line.size())
  ------------------
  |  Branch (1273:24): [True: 495, False: 212]
  |  Branch (1273:24): [True: 495, False: 212]
  |  Branch (1273:39): [True: 495, False: 0]
  ------------------
 1274|    495|                {
 1275|    495|                    line.erase(line.begin() + cindex.unsafe());
 1276|    495|                    length--;
 1277|    495|                }
 1278|       |
 1279|       |                // Remove any kind of selection if we had any
 1280|    212|                ClearSelection();
 1281|    212|            }
 1282|       |
 1283|    585|            m_TextChanged = true;
 1284|       |
 1285|    585|            Colorize(pos.m_Line, 1);
 1286|    585|        }
 1287|       |
 1288|    722|        undo.StoreAfterState(this);
 1289|    722|        AddUndo(undo);
 1290|    722|    }
_ZNK6dlxemu10CodeEditor7CanUndoEv:
 1293|  3.89k|    {
 1294|  3.89k|        return !m_ReadOnly && m_UndoIndex != 0u;
  ------------------
  |  Branch (1294:16): [True: 3.79k, False: 98]
  |  Branch (1294:31): [True: 3.42k, False: 372]
  ------------------
 1295|  3.89k|    }
_ZN6dlxemu10CodeEditor4UndoEN3phi7integerIjEE:
 1298|  2.05k|    {
 1299|  3.89k|        while (CanUndo() && steps > 0u)
  ------------------
  |  Branch (1299:16): [True: 3.42k, False: 470]
  |  Branch (1299:16): [True: 1.83k, False: 2.05k]
  |  Branch (1299:29): [True: 1.83k, False: 1.58k]
  ------------------
 1300|  1.83k|        {
 1301|  1.83k|            m_UndoIndex -= 1u;
 1302|  1.83k|            m_UndoBuffer[m_UndoIndex.unsafe()].Undo(this);
 1303|  1.83k|            steps -= 1u;
 1304|  1.83k|        }
 1305|  2.05k|    }
_ZNK6dlxemu10CodeEditor7CanRedoEv:
 1308|  2.71k|    {
 1309|  2.71k|        return !m_ReadOnly && m_UndoIndex < m_UndoBuffer.size();
  ------------------
  |  Branch (1309:16): [True: 2.63k, False: 77]
  |  Branch (1309:31): [True: 1.07k, False: 1.55k]
  ------------------
 1310|  2.71k|    }
_ZN6dlxemu10CodeEditor4RedoEN3phi7integerIjEE:
 1313|  1.74k|    {
 1314|  2.71k|        while (CanRedo() && steps > 0u)
  ------------------
  |  Branch (1314:16): [True: 1.07k, False: 1.63k]
  |  Branch (1314:16): [True: 970, False: 1.74k]
  |  Branch (1314:29): [True: 970, False: 109]
  ------------------
 1315|    970|        {
 1316|    970|            m_UndoBuffer[m_UndoIndex.unsafe()].Redo(this);
 1317|    970|            m_UndoIndex += 1u;
 1318|    970|            steps -= 1u;
 1319|    970|        }
 1320|  1.74k|    }
_ZN6dlxemu10CodeEditor13UpdatePaletteEv:
 1471|  6.34k|    {
 1472|  6.34k|        PHI_ASSERT(GImGui && GImGui->Initialized);
 1473|       |
 1474|       |        // Update palette with the current alpha from style
 1475|  95.1k|        for (phi::usize i = 0u; i < phi::to_underlying(PaletteIndex::Max); ++i)
  ------------------
  |  Branch (1475:33): [True: 88.8k, False: 6.34k]
  ------------------
 1476|  88.8k|        {
 1477|  88.8k|            ImVec4 color = ImGui::ColorConvertU32ToFloat4(m_PaletteBase[i]);
 1478|  88.8k|            color.w *= ImGui::GetStyle().Alpha;
 1479|  88.8k|            m_Palette[i] = ImGui::ColorConvertFloat4ToU32(color);
 1480|  88.8k|        }
 1481|  6.34k|    }
_ZNK6dlxemu10CodeEditor19VerifyInternalStateEv:
 1484|  15.9k|    {
 1485|       |        // Lines should never be empty
 1486|  15.9k|        PHI_ASSERT(!m_Lines.empty());
 1487|       |
 1488|       |        // Verify Selection is still in a valid state
 1489|  15.9k|        PHI_ASSERT(m_State.m_SelectionEnd >= m_State.m_SelectionStart);
 1490|  15.9k|        PHI_ASSERT(m_State.m_SelectionStart.m_Line < m_Lines.size());
 1491|  15.9k|        PHI_ASSERT(m_State.m_SelectionStart.m_Column >= 0u);
 1492|  15.9k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Line < m_Lines.size());
 1493|  15.9k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Column >= 0u);
 1494|       |
 1495|       |        // Verify cursor position
 1496|  15.9k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line >= 0u);
 1497|  15.9k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 1498|  15.9k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
 1499|       |
 1500|       |        // This should also always be true. But its implementation is way to slow when fuzzing
 1501|  15.9k|#if defined(DLXEMU_VERIFY_COLUMN)
 1502|  15.9k|        PHI_ASSERT(m_State.m_SelectionStart.m_Column <=
 1503|  15.9k|                   GetLineMaxColumn(m_State.m_SelectionStart.m_Line));
 1504|  15.9k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Column <=
 1505|  15.9k|                   GetLineMaxColumn(m_State.m_SelectionEnd.m_Line));
 1506|  15.9k|#endif
 1507|       |
 1508|       |        // Verify that all breakpoints are on existing lines
 1509|  15.9k|        for (phi::u32 break_point : m_Breakpoints)
  ------------------
  |  Branch (1509:35): [True: 836, False: 15.9k]
  ------------------
 1510|    836|        {
 1511|    836|            PHI_ASSERT(break_point != 0u);
 1512|    836|            PHI_ASSERT(break_point <= m_Lines.size());
 1513|    836|        }
 1514|       |
 1515|       |        // Verify that all error markers are on existing lines
 1516|  15.9k|        for (auto&& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (1516:34): [True: 7.57k, False: 15.9k]
  ------------------
 1517|  7.57k|        {
 1518|  7.57k|            const phi::u32 line_number = error_marker.first;
 1519|       |
 1520|  7.57k|            PHI_ASSERT(line_number != 0u);
 1521|  7.57k|            PHI_ASSERT(line_number <= m_Lines.size());
 1522|  7.57k|        }
 1523|  15.9k|    }
_ZN6dlxemu10CodeEditor14GetDarkPaletteEv:
 1526|  12.6k|    {
 1527|  12.6k|        constexpr const static Palette palette = {{
 1528|  12.6k|                0xff7f7f7f, // Default
 1529|  12.6k|                0xffd69c56, // OpCode
 1530|  12.6k|                0xff00ff00, // Register
 1531|  12.6k|                0xff7070e0, // IntegerLiteral
 1532|  12.6k|                0xff206020, // Comment
 1533|  12.6k|                0xff101010, // Background
 1534|  12.6k|                0xffe0e0e0, // Cursor
 1535|  12.6k|                0x80a06020, // Selection
 1536|  12.6k|                0x800020ff, // ErrorMarker
 1537|  12.6k|                0x40f08000, // Breakpoint
 1538|  12.6k|                0xff707000, // Line number
 1539|  12.6k|                0x40000000, // Current line fill
 1540|  12.6k|                0x40808080, // Current line fill (inactive)
 1541|  12.6k|                0x40a0a0a0, // Current line edge
 1542|  12.6k|        }};
 1543|       |
 1544|  12.6k|        return palette;
 1545|  12.6k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4UndoEPS0_:
 1606|  1.83k|    {
 1607|  1.83k|        PHI_ASSERT(editor != nullptr);
 1608|       |
 1609|  1.83k|        if (!m_Added.empty())
  ------------------
  |  Branch (1609:13): [True: 1.37k, False: 461]
  ------------------
 1610|  1.37k|        {
 1611|  1.37k|            editor->DeleteRange(m_AddedStart, m_AddedEnd);
 1612|  1.37k|            editor->Colorize(m_AddedStart.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1613|  1.37k|        }
 1614|       |
 1615|  1.83k|        if (!m_Removed.empty())
  ------------------
  |  Branch (1615:13): [True: 717, False: 1.11k]
  ------------------
 1616|    717|        {
 1617|    717|            Coordinates start = m_RemovedStart;
 1618|    717|            editor->InsertTextAt(start, m_Removed.c_str());
 1619|    717|            editor->Colorize(start.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1620|    717|        }
 1621|       |
 1622|  1.83k|        ApplyBeforeState(editor);
 1623|  1.83k|        editor->EnsureCursorVisible();
 1624|  1.83k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4RedoEPS0_:
 1627|    970|    {
 1628|    970|        PHI_ASSERT(editor != nullptr);
 1629|       |
 1630|    970|        if (!m_Removed.empty())
  ------------------
  |  Branch (1630:13): [True: 394, False: 576]
  ------------------
 1631|    394|        {
 1632|    394|            editor->DeleteRange(m_RemovedStart, m_RemovedEnd);
 1633|    394|            editor->Colorize(m_RemovedStart.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1634|    394|        }
 1635|       |
 1636|    970|        if (!m_Added.empty())
  ------------------
  |  Branch (1636:13): [True: 720, False: 250]
  ------------------
 1637|    720|        {
 1638|    720|            Coordinates start = m_AddedStart;
 1639|    720|            editor->InsertTextAt(start, m_Added.c_str());
 1640|    720|            editor->Colorize(start.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1641|    720|        }
 1642|       |
 1643|    970|        ApplyAfterState(editor);
 1644|    970|        editor->EnsureCursorVisible();
 1645|    970|    }
_ZN6dlxemu10CodeEditor10UndoRecord16StoreBeforeStateEPS0_:
 1648|  37.1k|    {
 1649|  37.1k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1650|  37.1k|        const Coordinates selection_start = editor->GetSelectionStart();
 1651|  37.1k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1652|       |
 1653|  37.1k|        m_Before.m_CursorPosition = {cursor_position.m_Line,
 1654|  37.1k|                                     editor->GetCharacterIndex(cursor_position)};
 1655|  37.1k|        m_Before.m_SelectionStart = {selection_start.m_Line,
 1656|  37.1k|                                     editor->GetCharacterIndex(selection_start)};
 1657|  37.1k|        m_Before.m_SelectionEnd = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1658|  37.1k|    }
_ZN6dlxemu10CodeEditor10UndoRecord15StoreAfterStateEPS0_:
 1661|  36.6k|    {
 1662|  36.6k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1663|  36.6k|        const Coordinates selection_start = editor->GetSelectionStart();
 1664|  36.6k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1665|       |
 1666|  36.6k|        m_After.m_CursorPosition = {cursor_position.m_Line,
 1667|  36.6k|                                    editor->GetCharacterIndex(cursor_position)};
 1668|  36.6k|        m_After.m_SelectionStart = {selection_start.m_Line,
 1669|  36.6k|                                    editor->GetCharacterIndex(selection_start)};
 1670|  36.6k|        m_After.m_SelectionEnd   = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1671|  36.6k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord16ApplyBeforeStateEPS0_:
 1674|  1.83k|    {
 1675|  1.83k|        Coordinates cursor_position = m_Before.m_CursorPosition;
 1676|  1.83k|        cursor_position.m_Column =
 1677|  1.83k|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1678|  1.83k|        Coordinates selection_start = m_Before.m_SelectionStart;
 1679|  1.83k|        selection_start.m_Column =
 1680|  1.83k|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1681|  1.83k|        Coordinates selection_end = m_Before.m_SelectionEnd;
 1682|  1.83k|        selection_end.m_Column =
 1683|  1.83k|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1684|       |
 1685|  1.83k|        editor->m_State.m_CursorPosition = cursor_position;
 1686|  1.83k|        editor->m_State.m_SelectionStart = selection_start;
 1687|  1.83k|        editor->m_State.m_SelectionEnd   = selection_end;
 1688|  1.83k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord15ApplyAfterStateEPS0_:
 1691|    970|    {
 1692|    970|        Coordinates cursor_position = m_After.m_CursorPosition;
 1693|    970|        cursor_position.m_Column =
 1694|    970|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1695|    970|        Coordinates selection_start = m_After.m_SelectionStart;
 1696|    970|        selection_start.m_Column =
 1697|    970|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1698|    970|        Coordinates selection_end = m_After.m_SelectionEnd;
 1699|    970|        selection_end.m_Column =
 1700|    970|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1701|       |
 1702|    970|        editor->m_State.m_CursorPosition = cursor_position;
 1703|    970|        editor->m_State.m_SelectionStart = selection_start;
 1704|    970|        editor->m_State.m_SelectionEnd   = selection_end;
 1705|    970|    }
_ZN6dlxemu10CodeEditor8ColorizeEN3phi7integerIjEENS2_IlEE:
 1710|  54.0k|    {
 1711|       |        // TODO: This is quite unreadable
 1712|  54.0k|        const phi::u32 to_line =
 1713|  54.0k|                count == -1 ? static_cast<phi::uint32_t>(m_Lines.size()) :
  ------------------
  |  Branch (1713:17): [True: 13.6k, False: 40.3k]
  ------------------
 1714|  54.0k|                              phi::min(static_cast<phi::uint32_t>(m_Lines.size()),
 1715|  40.3k|                                       from_line + static_cast<phi::uint32_t>(count.unsafe()));
 1716|       |
 1717|  54.0k|        m_ColorRangeMin = phi::min(m_ColorRangeMin, from_line);
 1718|  54.0k|        m_ColorRangeMax = phi::max(m_ColorRangeMax, to_line);
 1719|  54.0k|        m_ColorRangeMin = phi::max(0u, m_ColorRangeMin);
 1720|  54.0k|        m_ColorRangeMax = phi::max(m_ColorRangeMin, m_ColorRangeMax);
 1721|  54.0k|    }
_ZNK6dlxemu10CodeEditor23TextDistanceToLineStartERKNS0_11CoordinatesE:
 1724|  77.9k|    {
 1725|  77.9k|        PHI_ASSERT(from.m_Line < m_Lines.size());
 1726|       |
 1727|  77.9k|        const Line& line     = m_Lines[from.m_Line.unsafe()];
 1728|  77.9k|        float       distance = 0.0f;
 1729|  77.9k|        float       space_size =
 1730|  77.9k|                ImGui::GetFont()
 1731|  77.9k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 1732|  77.9k|                        .x;
 1733|  77.9k|        const phi::u32 col_index = GetCharacterIndex(from);
 1734|  6.24M|        for (phi::usize it{0u}; it < line.size() && it < col_index;)
  ------------------
  |  Branch (1734:33): [True: 6.16M, False: 73.0k]
  |  Branch (1734:33): [True: 6.16M, False: 77.9k]
  |  Branch (1734:53): [True: 6.16M, False: 4.87k]
  ------------------
 1735|  6.16M|        {
 1736|  6.16M|            if (line[it.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (1736:17): [True: 57.3k, False: 6.10M]
  ------------------
 1737|  57.3k|            {
 1738|  57.3k|                distance = (1.0f + std::floor((1.0f + distance) /
 1739|  57.3k|                                              (float(m_TabSize.unsafe()) * space_size))) *
 1740|  57.3k|                           (float(m_TabSize.unsafe()) * space_size);
 1741|  57.3k|                ++it;
 1742|  57.3k|            }
 1743|  6.10M|            else
 1744|  6.10M|            {
 1745|  6.10M|                phi::u8_fast        length = UTF8CharLength(line[it.unsafe()].m_Char);
 1746|  6.10M|                phi::array<char, 7> temp_c_string;
 1747|  6.10M|                phi::usize          index = 0u;
 1748|  17.9M|                for (; index < 6u && length > 0u && it < line.size(); ++index, ++it, --length)
  ------------------
  |  Branch (1748:24): [True: 17.9M, False: 0]
  |  Branch (1748:24): [True: 11.8M, False: 6.10M]
  |  Branch (1748:38): [True: 11.8M, False: 6.10M]
  |  Branch (1748:53): [True: 11.8M, False: 0]
  ------------------
 1749|  11.8M|                {
 1750|  11.8M|                    temp_c_string[index] = static_cast<char>(line[it.unsafe()].m_Char);
 1751|  11.8M|                }
 1752|       |
 1753|  6.10M|                temp_c_string[index] = '\0';
 1754|  6.10M|                distance += ImGui::GetFont()
 1755|  6.10M|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 1756|  6.10M|                                                    temp_c_string.data(), nullptr, nullptr)
 1757|  6.10M|                                    .x;
 1758|  6.10M|            }
 1759|  6.16M|        }
 1760|       |
 1761|  77.9k|        return distance;
 1762|  77.9k|    }
_ZN6dlxemu10CodeEditor19EnsureCursorVisibleEv:
 1765|  50.6k|    {
 1766|  50.6k|        m_ScrollToCursor = true;
 1767|  50.6k|    }
_ZN6dlxemu10CodeEditor14ScrollToCursorEv:
 1770|  10.8k|    {
 1771|  10.8k|        PHI_ASSERT(m_ScrollToCursor);
 1772|       |
 1773|  10.8k|        float scroll_x = ImGui::GetScrollX();
 1774|  10.8k|        float scroll_y = ImGui::GetScrollY();
 1775|       |
 1776|  10.8k|        float height = ImGui::GetWindowHeight();
 1777|  10.8k|        float width  = ImGui::GetWindowWidth();
 1778|       |
 1779|  10.8k|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 1780|  10.8k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 1781|  10.8k|        phi::u32 top = 1u + static_cast<phi::uint32_t>(std::ceil(scroll_y / m_CharAdvance.y));
 1782|  10.8k|        phi::u32 bottom =
 1783|  10.8k|                static_cast<phi::uint32_t>(std::ceil((scroll_y + height) / m_CharAdvance.y));
 1784|       |
 1785|  10.8k|        phi::u32 left = static_cast<phi::uint32_t>(std::ceil(scroll_x / m_CharAdvance.x));
 1786|  10.8k|        phi::u32 right =
 1787|  10.8k|                static_cast<phi::uint32_t>(std::ceil((scroll_x + width) / m_CharAdvance.x));
 1788|       |
 1789|  10.8k|        Coordinates pos = GetActualCursorCoordinates();
 1790|  10.8k|        float       len = TextDistanceToLineStart(pos);
 1791|       |
 1792|       |        // TODO: The 4 here seems like it could very well be a constant
 1793|       |
 1794|  10.8k|        if (pos.m_Line < top)
  ------------------
  |  Branch (1794:13): [True: 9.41k, False: 1.45k]
  ------------------
 1795|  9.41k|        {
 1796|  9.41k|            ImGui::SetScrollY(phi::max(0.0f, static_cast<float>(pos.m_Line.unsafe()) - 1.0f) *
 1797|  9.41k|                              m_CharAdvance.y);
 1798|  9.41k|        }
 1799|  10.8k|        if (pos.m_Line > bottom.unsafe() - 4u)
  ------------------
  |  Branch (1799:13): [True: 28, False: 10.8k]
  ------------------
 1800|     28|        {
 1801|     28|            ImGui::SetScrollY(phi::max(
 1802|     28|                    0.0f,
 1803|     28|                    static_cast<float>((pos.m_Line + 4u).unsafe()) * m_CharAdvance.y - height));
 1804|     28|        }
 1805|  10.8k|        if (len + m_TextStart < static_cast<float>((left + 4u).unsafe()))
  ------------------
  |  Branch (1805:13): [True: 211, False: 10.6k]
  ------------------
 1806|    211|        {
 1807|    211|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart - 4.0f));
 1808|    211|        }
 1809|  10.8k|        if (len + m_TextStart > static_cast<float>(right.unsafe()) - 4.0f)
  ------------------
  |  Branch (1809:13): [True: 10.4k, False: 408]
  ------------------
 1810|  10.4k|        {
 1811|  10.4k|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart + 4.0f - width));
 1812|  10.4k|        }
 1813|  10.8k|    }
_ZNK6dlxemu10CodeEditor11GetPageSizeEv:
 1816|    168|    {
 1817|    168|        const float height = ImGui::GetWindowHeight() - 20.0f;
 1818|       |
 1819|    168|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 1820|    168|        const float page_size = std::floor(height / m_CharAdvance.y);
 1821|       |
 1822|    168|        return static_cast<phi::uint32_t>(phi::max(page_size, 5.0f));
 1823|    168|    }
_ZNK6dlxemu10CodeEditor7GetTextERKNS0_11CoordinatesES3_:
 1826|  15.4k|    {
 1827|  15.4k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1828|  15.4k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1829|  15.4k|        PHI_ASSERT(start <= end);
 1830|       |
 1831|  15.4k|        std::string result;
 1832|       |
 1833|  15.4k|        phi::u32   lstart = start.m_Line;
 1834|  15.4k|        phi::u32   lend   = end.m_Line;
 1835|  15.4k|        phi::u32   istart = GetCharacterIndex(start);
 1836|  15.4k|        phi::u32   iend   = phi::min(GetCharacterIndex(end),
 1837|  15.4k|                                     static_cast<phi::uint32_t>(m_Lines[end.m_Line.unsafe()].size()));
 1838|  15.4k|        phi::usize size   = 0u;
 1839|       |
 1840|  88.1k|        for (phi::u32 i = lstart; i <= lend; ++i)
  ------------------
  |  Branch (1840:35): [True: 72.7k, False: 15.4k]
  ------------------
 1841|  72.7k|        {
 1842|  72.7k|            PHI_ASSERT(i < m_Lines.size());
 1843|  72.7k|            size += m_Lines[i.unsafe()].size();
 1844|  72.7k|        }
 1845|       |
 1846|  15.4k|        result.reserve((size + size / 8u).unsafe());
 1847|       |
 1848|  13.7M|        while (istart < iend || lstart < lend)
  ------------------
  |  Branch (1848:16): [True: 13.5M, False: 160k]
  |  Branch (1848:16): [True: 13.7M, False: 15.4k]
  |  Branch (1848:33): [True: 144k, False: 15.4k]
  ------------------
 1849|  13.7M|        {
 1850|  13.7M|            PHI_ASSERT(lstart < m_Lines.size());
 1851|       |
 1852|  13.7M|            const Line& line = m_Lines[lstart.unsafe()];
 1853|  13.7M|            if (istart < line.size())
  ------------------
  |  Branch (1853:17): [True: 13.6M, False: 57.2k]
  ------------------
 1854|  13.6M|            {
 1855|  13.6M|                result += static_cast<char>(line[istart.unsafe()].m_Char);
 1856|  13.6M|                istart++;
 1857|  13.6M|            }
 1858|  57.2k|            else
 1859|  57.2k|            {
 1860|  57.2k|                istart = 0u;
 1861|  57.2k|                ++lstart;
 1862|       |
 1863|  57.2k|                if (lstart != m_Lines.size())
  ------------------
  |  Branch (1863:21): [True: 57.2k, False: 0]
  ------------------
 1864|  57.2k|                {
 1865|  57.2k|                    result += '\n';
 1866|  57.2k|                }
 1867|  57.2k|            }
 1868|  13.7M|        }
 1869|       |
 1870|  15.4k|        return result;
 1871|  15.4k|    }
_ZNK6dlxemu10CodeEditor26GetActualCursorCoordinatesEv:
 1874|   174k|    {
 1875|   174k|        return SanitizeCoordinates(m_State.m_CursorPosition);
 1876|   174k|    }
_ZNK6dlxemu10CodeEditor19SanitizeCoordinatesERKNS0_11CoordinatesE:
 1879|   317k|    {
 1880|   317k|        PHI_ASSERT(!m_Lines.empty());
 1881|       |
 1882|   317k|        phi::u32 line   = value.m_Line;
 1883|   317k|        phi::u32 column = value.m_Column;
 1884|       |
 1885|   317k|        if (line >= m_Lines.size())
  ------------------
  |  Branch (1885:13): [True: 5.31k, False: 312k]
  ------------------
 1886|  5.31k|        {
 1887|  5.31k|            line   = GetMaxLineNumber();
 1888|  5.31k|            column = GetLineMaxColumn(line);
 1889|       |
 1890|  5.31k|            PHI_ASSERT(line < m_Lines.size());
 1891|  5.31k|            PHI_ASSERT(column <= GetLineMaxColumn(line));
 1892|       |
 1893|  5.31k|            return {line, column};
 1894|  5.31k|        }
 1895|       |
 1896|       |        // Sanitize column
 1897|   312k|        const Line& current_line = m_Lines[line.unsafe()];
 1898|   312k|        phi::u32    new_column   = 0u;
 1899|   141M|        for (phi::u32 char_index{0u}; char_index < current_line.size();)
  ------------------
  |  Branch (1899:39): [True: 141M, False: 202k]
  ------------------
 1900|   141M|        {
 1901|   141M|            if (new_column >= column)
  ------------------
  |  Branch (1901:17): [True: 110k, False: 141M]
  ------------------
 1902|   110k|            {
 1903|   110k|                break;
 1904|   110k|            }
 1905|       |
 1906|   141M|            const char current_char = static_cast<char>(current_line[char_index.unsafe()].m_Char);
 1907|   141M|            if (current_char == '\t')
  ------------------
  |  Branch (1907:17): [True: 156k, False: 141M]
  ------------------
 1908|   156k|            {
 1909|   156k|                new_column += GetTabSizeAt(new_column);
 1910|   156k|            }
 1911|   141M|            else
 1912|   141M|            {
 1913|   141M|                ++new_column;
 1914|   141M|            }
 1915|       |
 1916|   141M|            char_index += UTF8CharLength(current_char);
 1917|   141M|        }
 1918|       |
 1919|   312k|        column = new_column;
 1920|       |
 1921|   312k|        PHI_ASSERT(line < m_Lines.size());
 1922|   312k|        PHI_ASSERT(column <= GetLineMaxColumn(line));
 1923|       |
 1924|   312k|        return {line, column};
 1925|   317k|    }
_ZNK6dlxemu10CodeEditor7AdvanceERNS0_11CoordinatesE:
 1928|    711|    {
 1929|    711|        if (coordinates.m_Line >= m_Lines.size())
  ------------------
  |  Branch (1929:13): [True: 0, False: 711]
  ------------------
 1930|      0|        {
 1931|      0|            return;
 1932|      0|        }
 1933|       |
 1934|    711|        const Line& line   = m_Lines[coordinates.m_Line.unsafe()];
 1935|    711|        phi::u32    cindex = GetCharacterIndex(coordinates);
 1936|       |
 1937|    711|        if (cindex + 1u < line.size())
  ------------------
  |  Branch (1937:13): [True: 0, False: 711]
  ------------------
 1938|      0|        {
 1939|      0|            PHI_ASSERT(cindex < line.size());
 1940|      0|            phi::u8_fast delta = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1941|      0|            cindex = phi::min(cindex + delta, static_cast<phi::uint32_t>(line.size() - 1u));
 1942|      0|        }
 1943|    711|        else
 1944|    711|        {
 1945|    711|            ++coordinates.m_Line;
 1946|    711|            cindex = 0u;
 1947|    711|        }
 1948|    711|        coordinates.m_Column = GetCharacterColumn(coordinates.m_Line, cindex);
 1949|    711|    }
_ZN6dlxemu10CodeEditor11DeleteRangeERKNS0_11CoordinatesES3_:
 1952|  3.26k|    {
 1953|  3.26k|        PHI_ASSERT(end > start);
 1954|  3.26k|        PHI_ASSERT(!m_ReadOnly);
 1955|  3.26k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1956|  3.26k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1957|       |
 1958|  3.26k|        const phi::u32 start_index = GetCharacterIndex(start);
 1959|  3.26k|        const phi::u32 end_index   = GetCharacterIndex(end);
 1960|       |
 1961|  3.26k|        if (start.m_Line == end.m_Line)
  ------------------
  |  Branch (1961:13): [True: 1.51k, False: 1.75k]
  ------------------
 1962|  1.51k|        {
 1963|  1.51k|            Line&          line       = m_Lines[start.m_Line.unsafe()];
 1964|  1.51k|            const phi::u32 max_column = GetLineMaxColumn(start.m_Line);
 1965|       |
 1966|  1.51k|            if (end.m_Column >= max_column)
  ------------------
  |  Branch (1966:17): [True: 1.21k, False: 300]
  ------------------
 1967|  1.21k|            {
 1968|  1.21k|                line.erase(line.begin() + start_index.unsafe(), line.end());
 1969|       |
 1970|       |                // Fix selection
 1971|  1.21k|                if (m_State.m_SelectionStart.m_Column > start_index)
  ------------------
  |  Branch (1971:21): [True: 244, False: 967]
  ------------------
 1972|    244|                {
 1973|    244|                    m_State.m_SelectionStart.m_Column = start_index;
 1974|    244|                }
 1975|  1.21k|                if (m_State.m_SelectionEnd.m_Column > start_index)
  ------------------
  |  Branch (1975:21): [True: 696, False: 515]
  ------------------
 1976|    696|                {
 1977|    696|                    m_State.m_SelectionEnd.m_Column = start_index;
 1978|    696|                }
 1979|  1.21k|            }
 1980|    300|            else
 1981|    300|            {
 1982|    300|                const phi::u32 start_column = GetCharacterColumn(start.m_Line, start_index);
 1983|    300|                const phi::u32 end_column   = GetCharacterColumn(end.m_Line, end_index);
 1984|       |
 1985|    300|                line.erase(line.begin() + start_index.unsafe(), line.begin() + end_index.unsafe());
 1986|       |
 1987|       |                // Fix selection
 1988|    300|                if (m_State.m_SelectionStart.m_Column > start_column)
  ------------------
  |  Branch (1988:21): [True: 93, False: 207]
  ------------------
 1989|     93|                {
 1990|     93|                    if (m_State.m_SelectionStart.m_Column <= end_column)
  ------------------
  |  Branch (1990:25): [True: 66, False: 27]
  ------------------
 1991|     66|                    {
 1992|     66|                        m_State.m_SelectionStart.m_Column = start_column;
 1993|     66|                    }
 1994|     27|                    else
 1995|     27|                    {
 1996|     27|                        m_State.m_SelectionStart.m_Column -= (end_column - start_column);
 1997|     27|                    }
 1998|     93|                }
 1999|    300|                if (m_State.m_SelectionEnd.m_Column > start_column)
  ------------------
  |  Branch (1999:21): [True: 196, False: 104]
  ------------------
 2000|    196|                {
 2001|    196|                    if (m_State.m_SelectionEnd.m_Column <= end_column)
  ------------------
  |  Branch (2001:25): [True: 159, False: 37]
  ------------------
 2002|    159|                    {
 2003|    159|                        m_State.m_SelectionEnd.m_Column = start_column;
 2004|    159|                    }
 2005|     37|                    else
 2006|     37|                    {
 2007|     37|                        m_State.m_SelectionEnd.m_Column -= (end_column - start_column);
 2008|     37|                    }
 2009|    196|                }
 2010|    300|            }
 2011|  1.51k|        }
 2012|  1.75k|        else
 2013|  1.75k|        {
 2014|  1.75k|            Line& first_line = m_Lines[start.m_Line.unsafe()];
 2015|  1.75k|            Line& last_line  = m_Lines[end.m_Line.unsafe()];
 2016|       |
 2017|  1.75k|            first_line.erase(first_line.begin() + start_index.unsafe(), first_line.end());
 2018|  1.75k|            last_line.erase(last_line.begin(), last_line.begin() + end_index.unsafe());
 2019|       |
 2020|  1.75k|            if (start.m_Line < end.m_Line)
  ------------------
  |  Branch (2020:17): [True: 1.75k, False: 0]
  ------------------
 2021|  1.75k|            {
 2022|  1.75k|                first_line.insert(first_line.end(), last_line.begin(), last_line.end());
 2023|  1.75k|                RemoveLine(start.m_Line + 1u, end.m_Line + 1u);
 2024|  1.75k|            }
 2025|  1.75k|        }
 2026|       |
 2027|  3.26k|        m_TextChanged = true;
 2028|  3.26k|    }
_ZN6dlxemu10CodeEditor12InsertTextAtERNS0_11CoordinatesEPKc:
 2031|  9.57k|    {
 2032|  9.57k|        PHI_ASSERT(!m_ReadOnly);
 2033|  9.57k|        PHI_ASSERT(where.m_Line < m_Lines.size());
 2034|       |
 2035|  9.57k|        phi::u32 cindex      = GetCharacterIndex(where);
 2036|  9.57k|        phi::u32 total_lines = 0u;
 2037|  7.74M|        while (*value != '\0')
  ------------------
  |  Branch (2037:16): [True: 7.73M, False: 9.57k]
  ------------------
 2038|  7.73M|        {
 2039|  7.73M|            PHI_ASSERT(!m_Lines.empty());
 2040|       |
 2041|  7.73M|            if (*value == '\n')
  ------------------
  |  Branch (2041:17): [True: 21.3k, False: 7.71M]
  ------------------
 2042|  21.3k|            {
 2043|  21.3k|                if (cindex < m_Lines[where.m_Line.unsafe()].size())
  ------------------
  |  Branch (2043:21): [True: 9.40k, False: 11.9k]
  ------------------
 2044|  9.40k|                {
 2045|  9.40k|                    Line& new_line = InsertLine(where.m_Line + 1u);
 2046|  9.40k|                    Line& line     = m_Lines[where.m_Line.unsafe()];
 2047|  9.40k|                    new_line.insert(new_line.begin(), line.begin() + cindex.unsafe(), line.end());
 2048|  9.40k|                    line.erase(line.begin() + cindex.unsafe(), line.end());
 2049|  9.40k|                }
 2050|  11.9k|                else
 2051|  11.9k|                {
 2052|  11.9k|                    InsertLine(where.m_Line + 1u);
 2053|  11.9k|                }
 2054|       |
 2055|  21.3k|                ++where.m_Line;
 2056|  21.3k|                where.m_Column = 0u;
 2057|  21.3k|                cindex         = 0u;
 2058|  21.3k|                ++total_lines;
 2059|  21.3k|                ++value;
 2060|  21.3k|            }
 2061|  7.71M|            else if (*value == '\t')
  ------------------
  |  Branch (2061:22): [True: 13.5k, False: 7.69M]
  ------------------
 2062|  13.5k|            {
 2063|  13.5k|                Line& line = m_Lines[where.m_Line.unsafe()];
 2064|       |
 2065|  13.5k|                line.insert(line.begin() + cindex.unsafe(),
 2066|  13.5k|                            Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2067|  13.5k|                cindex += 1u;
 2068|       |
 2069|  13.5k|                where.m_Column += GetTabSizeAt(where.m_Column);
 2070|  13.5k|            }
 2071|  7.69M|            else
 2072|  7.69M|            {
 2073|  7.69M|                Line& line = m_Lines[where.m_Line.unsafe()];
 2074|       |
 2075|  19.7M|                for (phi::u8_fast length = UTF8CharLength(*value); length > 0u && *value != '\0';
  ------------------
  |  Branch (2075:68): [True: 12.0M, False: 7.69M]
  |  Branch (2075:68): [True: 12.0M, False: 7.69M]
  |  Branch (2075:83): [True: 12.0M, False: 0]
  ------------------
 2076|  12.0M|                     ++cindex, --length)
 2077|  12.0M|                {
 2078|  12.0M|                    line.insert(line.begin() + cindex.unsafe(),
 2079|  12.0M|                                Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2080|  12.0M|                }
 2081|       |
 2082|  7.69M|                ++where.m_Column;
 2083|  7.69M|            }
 2084|       |
 2085|  7.73M|            m_TextChanged = true;
 2086|  7.73M|        }
 2087|       |
 2088|  9.57k|        return total_lines;
 2089|  9.57k|    }
_ZN6dlxemu10CodeEditor7AddUndoERNS0_10UndoRecordE:
 2092|  36.6k|    {
 2093|  36.6k|        PHI_ASSERT(!m_ReadOnly);
 2094|       |
 2095|       |#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2096|       |        VerifyInternalState();
 2097|       |        // Reject empty undos
 2098|       |        PHI_ASSERT(!(value.m_Added.empty() && value.m_Removed.empty()));
 2099|       |        // Start and end are valid
 2100|       |        PHI_ASSERT(value.m_AddedStart <= value.m_AddedEnd);
 2101|       |        PHI_ASSERT(value.m_RemovedStart <= value.m_RemovedEnd);
 2102|       |#endif
 2103|       |
 2104|  36.6k|        m_UndoBuffer.resize((m_UndoIndex + 1u).unsafe());
 2105|  36.6k|        m_UndoBuffer.back() = value;
 2106|  36.6k|        ++m_UndoIndex;
 2107|       |
 2108|       |#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2109|       |        VerifyInternalState();
 2110|       |
 2111|       |        PHI_ASSERT(CanUndo());
 2112|       |
 2113|       |        const std::string text_before          = GetText();
 2114|       |        EditorState       state_before         = m_State;
 2115|       |        state_before.m_CursorPosition.m_Column = GetCharacterIndex(state_before.m_CursorPosition);
 2116|       |        state_before.m_SelectionStart.m_Column = GetCharacterIndex(state_before.m_SelectionStart);
 2117|       |        state_before.m_SelectionEnd.m_Column   = GetCharacterIndex(state_before.m_SelectionEnd);
 2118|       |
 2119|       |        // Test the undo
 2120|       |        Undo();
 2121|       |        VerifyInternalState();
 2122|       |
 2123|       |        const std::string text_after_undo  = GetText();
 2124|       |        EditorState       state_after_undo = m_State;
 2125|       |        state_after_undo.m_CursorPosition.m_Column =
 2126|       |                GetCharacterIndex(state_after_undo.m_CursorPosition);
 2127|       |        state_after_undo.m_SelectionStart.m_Column =
 2128|       |                GetCharacterIndex(state_after_undo.m_SelectionStart);
 2129|       |        state_after_undo.m_SelectionEnd.m_Column =
 2130|       |                GetCharacterIndex(state_after_undo.m_SelectionEnd);
 2131|       |
 2132|       |        PHI_ASSERT(CanRedo());
 2133|       |
 2134|       |        // Test the redo
 2135|       |        Redo();
 2136|       |        VerifyInternalState();
 2137|       |
 2138|       |        const std::string text_after          = GetText();
 2139|       |        EditorState       state_after         = m_State;
 2140|       |        state_after.m_CursorPosition.m_Column = GetCharacterIndex(state_after.m_CursorPosition);
 2141|       |        state_after.m_SelectionStart.m_Column = GetCharacterIndex(state_after.m_SelectionStart);
 2142|       |        state_after.m_SelectionEnd.m_Column   = GetCharacterIndex(state_after.m_SelectionEnd);
 2143|       |
 2144|       |        PHI_ASSERT(text_before == text_after);
 2145|       |        PHI_ASSERT(state_before == state_after);
 2146|       |#endif
 2147|  36.6k|    }
_ZNK6dlxemu10CodeEditor22ScreenPosToCoordinatesERK6ImVec2:
 2151|  6.36k|    {
 2152|  6.36k|        const ImVec2 origin = ImGui::GetCursorScreenPos();
 2153|  6.36k|        const ImVec2 local(position.x - origin.x, position.y - origin.y);
 2154|       |
 2155|  6.36k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 2156|  6.36k|        const phi::u32 line_no =
 2157|  6.36k|                phi::max(0u, static_cast<phi::int32_t>(std::floor(local.y / m_CharAdvance.y)));
 2158|       |
 2159|  6.36k|        phi::u32 column_coord = 0u;
 2160|       |
 2161|  6.36k|        if (line_no >= 0u && line_no < m_Lines.size())
  ------------------
  |  Branch (2161:13): [True: 6.36k, False: 0]
  |  Branch (2161:13): [True: 2.30k, False: 4.06k]
  |  Branch (2161:30): [True: 2.30k, False: 4.06k]
  ------------------
 2162|  2.30k|        {
 2163|  2.30k|            const Line& line = m_Lines[line_no.unsafe()];
 2164|       |
 2165|  2.30k|            phi::u32 column_index = 0u;
 2166|  2.30k|            float    column_x     = 0.0f;
 2167|       |
 2168|  4.30k|            while (column_index < line.size())
  ------------------
  |  Branch (2168:20): [True: 4.08k, False: 216]
  ------------------
 2169|  4.08k|            {
 2170|  4.08k|                float column_width = 0.0f;
 2171|       |
 2172|  4.08k|                if (line[column_index.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2172:21): [True: 1.18k, False: 2.90k]
  ------------------
 2173|  1.18k|                {
 2174|  1.18k|                    float space_size =
 2175|  1.18k|                            ImGui::GetFont()
 2176|  1.18k|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ")
 2177|  1.18k|                                    .x;
 2178|  1.18k|                    float old_x = column_x;
 2179|  1.18k|                    float new_column_x =
 2180|  1.18k|                            (1.0f + std::floor((1.0f + column_x) /
 2181|  1.18k|                                               (float(m_TabSize.unsafe()) * space_size))) *
 2182|  1.18k|                            (float(m_TabSize.unsafe()) * space_size);
 2183|  1.18k|                    column_width = new_column_x - old_x;
 2184|       |
 2185|  1.18k|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2185:25): [True: 269, False: 911]
  ------------------
 2186|    269|                    {
 2187|    269|                        break;
 2188|    269|                    }
 2189|       |
 2190|    911|                    column_x = new_column_x;
 2191|    911|                    column_coord =
 2192|    911|                            (column_coord.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2193|    911|                            m_TabSize.unsafe();
 2194|    911|                    column_index += 1u;
 2195|    911|                }
 2196|  2.90k|                else
 2197|  2.90k|                {
 2198|  2.90k|                    phi::array<char, 7u> buffer;
 2199|  2.90k|                    phi::usize           index = 0u;
 2200|       |
 2201|  2.90k|                    for (phi::u8_fast length = UTF8CharLength(line[column_index.unsafe()].m_Char);
 2202|  7.06k|                         index < 6u && length > 0u; ++index, ++column_index, --length)
  ------------------
  |  Branch (2202:26): [True: 7.06k, False: 0]
  |  Branch (2202:26): [True: 4.15k, False: 2.90k]
  |  Branch (2202:40): [True: 4.15k, False: 2.90k]
  ------------------
 2203|  4.15k|                    {
 2204|  4.15k|                        buffer[index] = static_cast<char>(line[column_index.unsafe()].m_Char);
 2205|  4.15k|                    }
 2206|       |
 2207|  2.90k|                    buffer[index] = '\0';
 2208|  2.90k|                    column_width  = ImGui::GetFont()
 2209|  2.90k|                                           ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 2210|  2.90k|                                                           buffer.data())
 2211|  2.90k|                                           .x;
 2212|  2.90k|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2212:25): [True: 1.81k, False: 1.08k]
  ------------------
 2213|  1.81k|                    {
 2214|  1.81k|                        break;
 2215|  1.81k|                    }
 2216|  1.08k|                    column_x += column_width;
 2217|  1.08k|                    column_coord++;
 2218|  1.08k|                }
 2219|  4.08k|            }
 2220|  2.30k|        }
 2221|       |
 2222|  6.36k|        return SanitizeCoordinates(Coordinates(line_no, column_coord));
 2223|  6.36k|    }
_ZNK6dlxemu10CodeEditor13FindWordStartERKNS0_11CoordinatesE:
 2226|  36.6k|    {
 2227|  36.6k|        if (from.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2227:13): [True: 0, False: 36.6k]
  ------------------
 2228|      0|        {
 2229|      0|            return from;
 2230|      0|        }
 2231|       |
 2232|  36.6k|        const Line& line   = m_Lines[from.m_Line.unsafe()];
 2233|  36.6k|        phi::u32    cindex = GetCharacterIndex(from);
 2234|       |
 2235|  36.6k|        if (cindex >= line.size())
  ------------------
  |  Branch (2235:13): [True: 14.7k, False: 21.8k]
  ------------------
 2236|  14.7k|        {
 2237|  14.7k|            return from;
 2238|  14.7k|        }
 2239|       |
 2240|  39.9k|        while (cindex > 0u && phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2240:16): [True: 29.7k, False: 10.2k]
  |  Branch (2240:16): [True: 18.1k, False: 21.8k]
  |  Branch (2240:31): [True: 18.1k, False: 11.6k]
  ------------------
 2241|  18.1k|        {
 2242|  18.1k|            --cindex;
 2243|  18.1k|        }
 2244|       |
 2245|  21.8k|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2246|   149k|        while (cindex > 0u)
  ------------------
  |  Branch (2246:16): [True: 136k, False: 13.1k]
  ------------------
 2247|   136k|        {
 2248|   136k|            Glyph glyph = line[cindex.unsafe()];
 2249|   136k|            if (!IsUTFSequence(glyph.m_Char))
  ------------------
  |  Branch (2249:17): [True: 73.6k, False: 62.8k]
  ------------------
 2250|  73.6k|            {
 2251|  73.6k|                if (glyph.m_Char <= 32 && phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2251:21): [True: 8.27k, False: 65.3k]
  |  Branch (2251:21): [True: 7.45k, False: 66.1k]
  |  Branch (2251:43): [True: 7.45k, False: 819]
  ------------------
 2252|  7.45k|                {
 2253|  7.45k|                    cindex += 1u;
 2254|  7.45k|                    break;
 2255|  7.45k|                }
 2256|       |
 2257|  66.1k|                if (cstart != line[phi::size_t(cindex.unsafe() - 1u)].m_ColorIndex)
  ------------------
  |  Branch (2257:21): [True: 1.31k, False: 64.8k]
  ------------------
 2258|  1.31k|                {
 2259|  1.31k|                    break;
 2260|  1.31k|                }
 2261|  66.1k|            }
 2262|       |
 2263|   127k|            cindex -= 1u;
 2264|   127k|        }
 2265|       |
 2266|  21.8k|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2267|  36.6k|    }
_ZNK6dlxemu10CodeEditor11FindWordEndERKNS0_11CoordinatesE:
 2270|  7.01k|    {
 2271|  7.01k|        Coordinates at = from;
 2272|  7.01k|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2272:13): [True: 0, False: 7.01k]
  ------------------
 2273|      0|        {
 2274|      0|            return at;
 2275|      0|        }
 2276|       |
 2277|  7.01k|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2278|  7.01k|        phi::u32    cindex = GetCharacterIndex(at);
 2279|       |
 2280|  7.01k|        if (cindex >= line.size())
  ------------------
  |  Branch (2280:13): [True: 4.45k, False: 2.56k]
  ------------------
 2281|  4.45k|        {
 2282|  4.45k|            return at;
 2283|  4.45k|        }
 2284|       |
 2285|  2.56k|        const phi::boolean prevspace =
 2286|  2.56k|                phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char));
 2287|  2.56k|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2288|  14.6k|        while (cindex < line.size())
  ------------------
  |  Branch (2288:16): [True: 12.9k, False: 1.67k]
  ------------------
 2289|  12.9k|        {
 2290|  12.9k|            const Glyph glyph = line[cindex.unsafe()];
 2291|       |
 2292|  12.9k|            if (cstart != line[cindex.unsafe()].m_ColorIndex)
  ------------------
  |  Branch (2292:17): [True: 39, False: 12.9k]
  ------------------
 2293|     39|            {
 2294|     39|                break;
 2295|     39|            }
 2296|       |
 2297|  12.9k|            if (prevspace != phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2297:17): [True: 849, False: 12.1k]
  ------------------
 2298|    849|            {
 2299|    849|                if (phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2299:21): [True: 458, False: 391]
  ------------------
 2300|    458|                {
 2301|  1.49k|                    while (cindex < line.size() &&
  ------------------
  |  Branch (2301:28): [True: 1.40k, False: 86]
  |  Branch (2301:28): [True: 1.03k, False: 458]
  ------------------
 2302|  1.49k|                           phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2302:28): [True: 1.03k, False: 372]
  ------------------
 2303|  1.03k|                    {
 2304|  1.03k|                        cindex += 1u;
 2305|  1.03k|                    }
 2306|    458|                }
 2307|    849|                break;
 2308|    849|            }
 2309|       |
 2310|  12.1k|            cindex += UTF8CharLength(glyph.m_Char);
 2311|  12.1k|        }
 2312|       |
 2313|  2.56k|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2314|  7.01k|    }
_ZNK6dlxemu10CodeEditor12FindNextWordERKNS0_11CoordinatesE:
 2317|  8.24k|    {
 2318|  8.24k|        Coordinates at = from;
 2319|  8.24k|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2319:13): [True: 0, False: 8.24k]
  ------------------
 2320|      0|        {
 2321|      0|            return at;
 2322|      0|        }
 2323|       |
 2324|       |        // skip to the next non-word character
 2325|  8.24k|        phi::u32     cindex  = GetCharacterIndex(from);
 2326|  8.24k|        phi::boolean is_word = false;
 2327|  8.24k|        phi::boolean skip    = false;
 2328|  8.24k|        if (cindex < m_Lines[at.m_Line.unsafe()].size())
  ------------------
  |  Branch (2328:13): [True: 8.14k, False: 104]
  ------------------
 2329|  8.14k|        {
 2330|  8.14k|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2331|  8.14k|            is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2332|  8.14k|            skip    = is_word;
 2333|  8.14k|        }
 2334|       |
 2335|   758k|        while (!is_word || skip)
  ------------------
  |  Branch (2335:16): [True: 751k, False: 6.84k]
  |  Branch (2335:16): [True: 758k, False: 0]
  |  Branch (2335:28): [True: 6.84k, False: 0]
  ------------------
 2336|   758k|        {
 2337|   758k|            if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2337:17): [True: 3.33k, False: 755k]
  ------------------
 2338|  3.33k|            {
 2339|  3.33k|                const phi::u32 line_number = GetMaxLineNumber();
 2340|       |
 2341|  3.33k|                return {line_number, GetLineMaxColumn(line_number)};
 2342|  3.33k|            }
 2343|       |
 2344|   755k|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2345|   755k|            if (cindex < line.size())
  ------------------
  |  Branch (2345:17): [True: 751k, False: 3.35k]
  ------------------
 2346|   751k|            {
 2347|   751k|                is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2348|       |
 2349|   751k|                if (is_word && !skip)
  ------------------
  |  Branch (2349:21): [True: 9.39k, False: 742k]
  |  Branch (2349:21): [True: 4.90k, False: 747k]
  |  Branch (2349:32): [True: 4.90k, False: 4.48k]
  ------------------
 2350|  4.90k|                {
 2351|  4.90k|                    return {at.m_Line, GetCharacterColumn(at.m_Line, cindex)};
 2352|  4.90k|                }
 2353|       |
 2354|   747k|                if (!is_word)
  ------------------
  |  Branch (2354:21): [True: 742k, False: 4.48k]
  ------------------
 2355|   742k|                {
 2356|   742k|                    skip = false;
 2357|   742k|                }
 2358|       |
 2359|   747k|                cindex++;
 2360|   747k|            }
 2361|  3.35k|            else
 2362|  3.35k|            {
 2363|  3.35k|                cindex = 0u;
 2364|  3.35k|                at.m_Line += 1u;
 2365|  3.35k|                skip    = false;
 2366|  3.35k|                is_word = false;
 2367|  3.35k|            }
 2368|   755k|        }
 2369|       |
 2370|      0|        return at;
 2371|  8.24k|    }
_ZNK6dlxemu10CodeEditor9GetWordAtERKNS0_11CoordinatesE:
 2380|  6.35k|    {
 2381|  6.35k|        PHI_ASSERT(coords.m_Line < m_Lines.size());
 2382|       |
 2383|  6.35k|        const Coordinates start = FindWordStart(coords);
 2384|  6.35k|        const Coordinates end   = FindWordEnd(coords);
 2385|       |
 2386|  6.35k|        const phi::u32 istart = GetCharacterIndex(start);
 2387|  6.35k|        const phi::u32 iend   = GetCharacterIndex(end);
 2388|       |
 2389|  6.35k|        std::string result;
 2390|       |
 2391|  15.3k|        for (phi::u32 iterator = istart; iterator < iend; ++iterator)
  ------------------
  |  Branch (2391:42): [True: 8.99k, False: 6.35k]
  ------------------
 2392|  8.99k|        {
 2393|  8.99k|            const Line& line = m_Lines[coords.m_Line.unsafe()];
 2394|       |
 2395|  8.99k|            PHI_ASSERT(iterator < line.size());
 2396|  8.99k|            result.push_back(static_cast<char>(line[iterator.unsafe()].m_Char));
 2397|  8.99k|        }
 2398|       |
 2399|  6.35k|        return result;
 2400|  6.35k|    }
_ZNK6dlxemu10CodeEditor17GetCharacterIndexERKNS0_11CoordinatesE:
 2403|   471k|    {
 2404|   471k|        PHI_ASSERT(coordinates.m_Line < m_Lines.size());
 2405|       |
 2406|   471k|        const Line& line  = m_Lines[coordinates.m_Line.unsafe()];
 2407|   471k|        phi::u32    index = 0u;
 2408|   120M|        for (phi::u32 column{0u}; index < line.size() && column < coordinates.m_Column;)
  ------------------
  |  Branch (2408:35): [True: 119M, False: 273k]
  |  Branch (2408:35): [True: 119M, False: 471k]
  |  Branch (2408:58): [True: 119M, False: 198k]
  ------------------
 2409|   119M|        {
 2410|   119M|            PHI_ASSERT(index < line.size());
 2411|   119M|            const Char character = line[index.unsafe()].m_Char;
 2412|       |
 2413|   119M|            if (character == '\t')
  ------------------
  |  Branch (2413:17): [True: 563k, False: 119M]
  ------------------
 2414|   563k|            {
 2415|   563k|                column = (column / m_TabSize) * m_TabSize + m_TabSize;
 2416|   563k|            }
 2417|   119M|            else
 2418|   119M|            {
 2419|   119M|                ++column;
 2420|   119M|            }
 2421|       |
 2422|   119M|            index += UTF8CharLength(character);
 2423|   119M|        }
 2424|       |
 2425|   471k|        return index;
 2426|   471k|    }
_ZNK6dlxemu10CodeEditor18GetCharacterColumnEN3phi7integerIjEES3_:
 2429|   122k|    {
 2430|   122k|        PHI_ASSERT(line_number < m_Lines.size());
 2431|       |
 2432|   122k|        const Line& line   = m_Lines[line_number.unsafe()];
 2433|   122k|        phi::u32    column = 0u;
 2434|   122k|        phi::u32    i      = 0u;
 2435|       |
 2436|  12.3M|        while (i < index && i < line.size())
  ------------------
  |  Branch (2436:16): [True: 12.2M, False: 122k]
  |  Branch (2436:16): [True: 12.2M, False: 122k]
  |  Branch (2436:29): [True: 12.2M, False: 59]
  ------------------
 2437|  12.2M|        {
 2438|  12.2M|            char character = static_cast<char>(line[static_cast<phi::size_t>(i.unsafe())].m_Char);
 2439|  12.2M|            i += UTF8CharLength(character);
 2440|  12.2M|            if (character == '\t')
  ------------------
  |  Branch (2440:17): [True: 371k, False: 11.8M]
  ------------------
 2441|   371k|            {
 2442|   371k|                column = (column.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2443|   371k|                         m_TabSize.unsafe();
 2444|   371k|            }
 2445|  11.8M|            else
 2446|  11.8M|            {
 2447|  11.8M|                column++;
 2448|  11.8M|            }
 2449|  12.2M|        }
 2450|       |
 2451|   122k|        return column;
 2452|   122k|    }
_ZNK6dlxemu10CodeEditor16GetLineMaxColumnEN3phi7integerIjEE:
 2473|   469k|    {
 2474|   469k|        if (line_number >= m_Lines.size())
  ------------------
  |  Branch (2474:13): [True: 0, False: 469k]
  ------------------
 2475|      0|        {
 2476|      0|            return 0u;
 2477|      0|        }
 2478|       |
 2479|   469k|        const Line& line = m_Lines[line_number.unsafe()];
 2480|   469k|        phi::u32    col  = 0u;
 2481|       |
 2482|   217M|        for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (2482:32): [True: 216M, False: 469k]
  ------------------
 2483|   216M|        {
 2484|   216M|            char character = static_cast<char>(line[i.unsafe()].m_Char);
 2485|   216M|            if (character == '\t')
  ------------------
  |  Branch (2485:17): [True: 295k, False: 216M]
  ------------------
 2486|   295k|            {
 2487|   295k|                col = (col / m_TabSize) * m_TabSize + m_TabSize;
 2488|   295k|            }
 2489|   216M|            else
 2490|   216M|            {
 2491|   216M|                col++;
 2492|   216M|            }
 2493|       |
 2494|   216M|            i += UTF8CharLength(character);
 2495|   216M|        }
 2496|       |
 2497|   469k|        return col;
 2498|   469k|    }
_ZNK6dlxemu10CodeEditor16GetMaxLineNumberEv:
 2501|  48.2k|    {
 2502|  48.2k|        PHI_ASSERT(!m_Lines.empty());
 2503|       |
 2504|  48.2k|        return static_cast<phi::uint32_t>(m_Lines.size() - 1u);
 2505|  48.2k|    }
_ZNK6dlxemu10CodeEditor16IsOnWordBoundaryERKNS0_11CoordinatesE:
 2508|     54|    {
 2509|     54|        if (at.m_Line >= m_Lines.size() || at.m_Column == 0u)
  ------------------
  |  Branch (2509:13): [True: 0, False: 54]
  |  Branch (2509:13): [True: 30, False: 24]
  |  Branch (2509:44): [True: 30, False: 24]
  ------------------
 2510|     30|        {
 2511|     30|            return true;
 2512|     30|        }
 2513|       |
 2514|     24|        PHI_ASSERT(at.m_Line < m_Lines.size());
 2515|     24|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2516|     24|        phi::u32    cindex = GetCharacterIndex(at);
 2517|     24|        if (cindex >= line.size())
  ------------------
  |  Branch (2517:13): [True: 24, False: 0]
  ------------------
 2518|     24|        {
 2519|     24|            return true;
 2520|     24|        }
 2521|       |
 2522|      0|        if (m_ColorizerEnabled)
  ------------------
  |  Branch (2522:13): [True: 0, False: 0]
  ------------------
 2523|      0|        {
 2524|      0|            return line[cindex.unsafe()].m_ColorIndex != line[cindex.unsafe() - 1u].m_ColorIndex;
 2525|      0|        }
 2526|       |
 2527|      0|        PHI_ASSERT(cindex < line.size());
 2528|      0|        return phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)) !=
 2529|      0|               phi::is_space(static_cast<char>(line[(cindex - 1u).unsafe()].m_Char));
 2530|      0|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEES3_:
 2533|  1.75k|    {
 2534|  1.75k|        PHI_ASSERT(!m_ReadOnly);
 2535|  1.75k|        PHI_ASSERT(end >= start);
 2536|  1.75k|        PHI_ASSERT(m_Lines.size() > (end - start));
 2537|       |
 2538|       |        // Remove error markers
 2539|  1.75k|        ErrorMarkers etmp;
 2540|  1.75k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2540:33): [True: 6.68k, False: 1.75k]
  ------------------
 2541|  6.68k|        {
 2542|  6.68k|            if (marker.first >= start && marker.first <= end)
  ------------------
  |  Branch (2542:17): [True: 6.41k, False: 276]
  |  Branch (2542:17): [True: 4.82k, False: 1.86k]
  |  Branch (2542:42): [True: 4.82k, False: 1.58k]
  ------------------
 2543|  4.82k|            {
 2544|  4.82k|                continue;
 2545|  4.82k|            }
 2546|       |
 2547|  1.86k|            ErrorMarkers::value_type error_marker(
 2548|  1.86k|                    marker.first >= start ? phi::max(marker.first - (end - start + 1u), 1u) :
  ------------------
  |  Branch (2548:21): [True: 1.58k, False: 276]
  ------------------
 2549|  1.86k|                                            marker.first,
 2550|  1.86k|                    marker.second);
 2551|       |
 2552|  1.86k|            etmp.insert(error_marker);
 2553|  1.86k|        }
 2554|  1.75k|        m_ErrorMarkers = phi::move(etmp);
 2555|       |
 2556|       |        // Remove breakpoints
 2557|  1.75k|        Breakpoints btmp;
 2558|  1.75k|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2558:37): [True: 205, False: 1.75k]
  ------------------
 2559|    205|        {
 2560|    205|            if (line_number >= start && line_number <= end)
  ------------------
  |  Branch (2560:17): [True: 102, False: 103]
  |  Branch (2560:17): [True: 39, False: 166]
  |  Branch (2560:41): [True: 39, False: 63]
  ------------------
 2561|     39|            {
 2562|     39|                continue;
 2563|     39|            }
 2564|    166|            btmp.insert(line_number >= start ?
  ------------------
  |  Branch (2564:25): [True: 63, False: 103]
  ------------------
 2565|     63|                                phi::max(line_number - (end - start + 1u).unsafe(), 1u) :
 2566|    166|                                line_number);
 2567|    166|        }
 2568|  1.75k|        m_Breakpoints = phi::move(btmp);
 2569|       |
 2570|  1.75k|        m_Lines.erase(m_Lines.begin() + start.unsafe(), m_Lines.begin() + end.unsafe());
 2571|  1.75k|        PHI_ASSERT(!m_Lines.empty());
 2572|       |
 2573|       |        // Fix selection state
 2574|  1.75k|        if (m_State.m_SelectionStart.m_Line >= start)
  ------------------
  |  Branch (2574:13): [True: 508, False: 1.24k]
  ------------------
 2575|    508|        {
 2576|    508|            if (m_State.m_SelectionStart.m_Line < end - start)
  ------------------
  |  Branch (2576:17): [True: 13, False: 495]
  ------------------
 2577|     13|            {
 2578|     13|                m_State.m_SelectionStart.m_Line = 0u;
 2579|     13|            }
 2580|    495|            else
 2581|    495|            {
 2582|    495|                m_State.m_SelectionStart.m_Line -= end - start;
 2583|    495|            }
 2584|    508|        }
 2585|  1.75k|        if (m_State.m_SelectionEnd.m_Line >= start)
  ------------------
  |  Branch (2585:13): [True: 1.61k, False: 133]
  ------------------
 2586|  1.61k|        {
 2587|  1.61k|            if (m_State.m_SelectionEnd.m_Line < end - start)
  ------------------
  |  Branch (2587:17): [True: 10, False: 1.60k]
  ------------------
 2588|     10|            {
 2589|     10|                m_State.m_SelectionEnd.m_Line = 0u;
 2590|     10|            }
 2591|  1.60k|            else
 2592|  1.60k|            {
 2593|  1.60k|                m_State.m_SelectionEnd.m_Line -= end - start;
 2594|  1.60k|            }
 2595|  1.61k|        }
 2596|  1.75k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (2596:13): [True: 88, False: 1.66k]
  ------------------
 2597|     88|        {
 2598|     88|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 2599|     88|        }
 2600|       |
 2601|  1.75k|        m_TextChanged = true;
 2602|  1.75k|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEE:
 2605|    711|    {
 2606|    711|        PHI_ASSERT(!m_ReadOnly);
 2607|    711|        PHI_ASSERT(m_Lines.size() > 1u);
 2608|       |
 2609|       |        // Clear error markers on that line
 2610|    711|        ErrorMarkers etmp;
 2611|    711|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2611:33): [True: 999, False: 711]
  ------------------
 2612|    999|        {
 2613|    999|            ErrorMarkers::value_type error_marker(
 2614|    999|                    marker.first > index ? phi::max(marker.first - 1u, 1u) : marker.first,
  ------------------
  |  Branch (2614:21): [True: 469, False: 530]
  ------------------
 2615|    999|                    marker.second);
 2616|    999|            if ((error_marker.first - 1u) == index)
  ------------------
  |  Branch (2616:17): [True: 65, False: 934]
  ------------------
 2617|     65|            {
 2618|     65|                continue;
 2619|     65|            }
 2620|    934|            etmp.insert(error_marker);
 2621|    934|        }
 2622|    711|        m_ErrorMarkers = phi::move(etmp);
 2623|       |
 2624|       |        // Remove breakpoints on that line
 2625|    711|        Breakpoints btmp;
 2626|    711|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2626:37): [True: 470, False: 711]
  ------------------
 2627|    470|        {
 2628|    470|            if (line_number == index)
  ------------------
  |  Branch (2628:17): [True: 47, False: 423]
  ------------------
 2629|     47|            {
 2630|     47|                continue;
 2631|     47|            }
 2632|       |
 2633|    423|            btmp.insert(line_number >= index ? phi::max(line_number - 1u, 1u) : line_number);
  ------------------
  |  Branch (2633:25): [True: 220, False: 203]
  ------------------
 2634|    423|        }
 2635|    711|        m_Breakpoints = phi::move(btmp);
 2636|       |
 2637|       |        // Fix selection
 2638|    711|        if (m_State.m_SelectionStart.m_Line >= index)
  ------------------
  |  Branch (2638:13): [True: 162, False: 549]
  ------------------
 2639|    162|        {
 2640|    162|            m_State.m_SelectionStart.m_Line--;
 2641|    162|        }
 2642|    711|        if (m_State.m_SelectionEnd.m_Line >= index)
  ------------------
  |  Branch (2642:13): [True: 162, False: 549]
  ------------------
 2643|    162|        {
 2644|    162|            m_State.m_SelectionEnd.m_Line--;
 2645|    162|        }
 2646|       |
 2647|    711|        m_Lines.erase(m_Lines.begin() + index.unsafe());
 2648|    711|        PHI_ASSERT(!m_Lines.empty());
 2649|       |
 2650|    711|        m_TextChanged = true;
 2651|    711|    }
_ZN6dlxemu10CodeEditor10InsertLineEN3phi7integerIjEE:
 2654|  25.8k|    {
 2655|  25.8k|        PHI_ASSERT(!m_ReadOnly);
 2656|       |
 2657|  25.8k|        Line& result = *m_Lines.insert(m_Lines.begin() + index.unsafe(), Line());
 2658|       |
 2659|  25.8k|        ErrorMarkers etmp;
 2660|  25.8k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2660:33): [True: 289k, False: 25.8k]
  ------------------
 2661|   289k|        {
 2662|   289k|            etmp.insert(ErrorMarkers::value_type(
 2663|   289k|                    marker.first >= index ? marker.first + 1u : marker.first, marker.second));
  ------------------
  |  Branch (2663:21): [True: 90.4k, False: 199k]
  ------------------
 2664|   289k|        }
 2665|  25.8k|        m_ErrorMarkers = phi::move(etmp);
 2666|       |
 2667|  25.8k|        Breakpoints btmp;
 2668|  25.8k|        for (const phi::u32 line_number : m_Breakpoints)
  ------------------
  |  Branch (2668:41): [True: 5.97k, False: 25.8k]
  ------------------
 2669|  5.97k|        {
 2670|  5.97k|            btmp.insert(line_number >= index ? line_number.unsafe() + 1u : line_number.unsafe());
  ------------------
  |  Branch (2670:25): [True: 3.90k, False: 2.06k]
  ------------------
 2671|  5.97k|        }
 2672|  25.8k|        m_Breakpoints = phi::move(btmp);
 2673|       |
 2674|  25.8k|        return result;
 2675|  25.8k|    }
_ZN6dlxemu10CodeEditor18EnterCharacterImplEtN3phi7booleanE:
 2678|  26.7k|    {
 2679|  26.7k|        PHI_ASSERT(!m_ReadOnly);
 2680|  26.7k|        PHI_ASSERT(IsValidUTF8Sequence(character));
 2681|  26.7k|        PHI_ASSERT(character != '\0');
 2682|       |
 2683|  26.7k|        UndoRecord undo;
 2684|  26.7k|        undo.StoreBeforeState(this);
 2685|       |
 2686|  26.7k|        phi::boolean removed_selection{false};
 2687|       |
 2688|  26.7k|        if (HasSelection())
  ------------------
  |  Branch (2688:13): [True: 1.30k, False: 25.4k]
  ------------------
 2689|  1.30k|        {
 2690|       |            // Do indenting
 2691|  1.30k|            if (character == '\t' &&
  ------------------
  |  Branch (2691:17): [True: 694, False: 606]
  |  Branch (2691:17): [True: 677, False: 623]
  ------------------
 2692|  1.30k|                (m_State.m_SelectionStart.m_Column == 0u ||
  ------------------
  |  Branch (2692:18): [True: 652, False: 42]
  ------------------
 2693|    694|                 m_State.m_SelectionStart.m_Line != m_State.m_SelectionEnd.m_Line))
  ------------------
  |  Branch (2693:18): [True: 25, False: 17]
  ------------------
 2694|    677|            {
 2695|    677|                Coordinates       start        = m_State.m_SelectionStart;
 2696|    677|                Coordinates       end          = m_State.m_SelectionEnd;
 2697|    677|                const Coordinates original_end = end;
 2698|       |
 2699|    677|                PHI_ASSERT(start < end);
 2700|    677|                start.m_Column = 0u;
 2701|       |                //          end.mColumn = end.mLine < mLines.size() ? mLines[end.mLine].size() : 0;
 2702|    677|                if (end.m_Column == 0u && end.m_Line > 0u)
  ------------------
  |  Branch (2702:21): [True: 180, False: 497]
  |  Branch (2702:21): [True: 180, False: 497]
  |  Branch (2702:43): [True: 180, False: 0]
  ------------------
 2703|    180|                {
 2704|    180|                    --end.m_Line;
 2705|    180|                }
 2706|    677|                if (end.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2706:21): [True: 0, False: 677]
  ------------------
 2707|      0|                {
 2708|      0|                    PHI_ASSERT(!m_Lines.empty());
 2709|      0|                    end.m_Line = GetMaxLineNumber();
 2710|      0|                }
 2711|    677|                end.m_Column = GetLineMaxColumn(end.m_Line);
 2712|       |
 2713|       |                //if (end.mColumn >= GetLineMaxColumn(end.mLine))
 2714|       |                //  end.mColumn = GetLineMaxColumn(end.mLine) - 1;
 2715|       |
 2716|    677|                undo.m_RemovedStart = start;
 2717|    677|                undo.m_RemovedEnd   = end;
 2718|    677|                undo.m_Removed      = GetText(start, end);
 2719|       |
 2720|    677|                phi::boolean modified = false;
 2721|       |
 2722|  6.30k|                for (phi::u32 line_index = start.m_Line; line_index <= end.m_Line; ++line_index)
  ------------------
  |  Branch (2722:58): [True: 5.63k, False: 677]
  ------------------
 2723|  5.63k|                {
 2724|  5.63k|                    PHI_ASSERT(line_index < m_Lines.size());
 2725|  5.63k|                    Line& line = m_Lines[line_index.unsafe()];
 2726|  5.63k|                    if (shift)
  ------------------
  |  Branch (2726:25): [True: 4.37k, False: 1.25k]
  ------------------
 2727|  4.37k|                    {
 2728|       |                        // Remove idention
 2729|  4.37k|                        if (line.empty())
  ------------------
  |  Branch (2729:29): [True: 546, False: 3.83k]
  ------------------
 2730|    546|                        {
 2731|       |                            // Skip already empty lines
 2732|    546|                            continue;
 2733|    546|                        }
 2734|       |
 2735|  3.83k|                        if (line.front().m_Char == '\t')
  ------------------
  |  Branch (2735:29): [True: 2.16k, False: 1.66k]
  ------------------
 2736|  2.16k|                        {
 2737|  2.16k|                            line.erase(line.begin());
 2738|  2.16k|                            modified = true;
 2739|  2.16k|                        }
 2740|  1.66k|                        else
 2741|  1.66k|                        {
 2742|  1.66k|                            for (phi::u32 j = 0u;
 2743|  3.33k|                                 j < m_TabSize && !line.empty() && line.front().m_Char == ' '; ++j)
  ------------------
  |  Branch (2743:34): [True: 2.64k, False: 691]
  |  Branch (2743:34): [True: 1.67k, False: 1.66k]
  |  Branch (2743:51): [True: 2.53k, False: 115]
  |  Branch (2743:68): [True: 1.67k, False: 858]
  ------------------
 2744|  1.67k|                            {
 2745|  1.67k|                                line.erase(line.begin());
 2746|  1.67k|                                modified = true;
 2747|  1.67k|                            }
 2748|  1.66k|                        }
 2749|  3.83k|                    }
 2750|  1.25k|                    else
 2751|  1.25k|                    {
 2752|  1.25k|                        PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
 2753|       |
 2754|       |                        // Add indention
 2755|  1.25k|                        line.insert(line.begin(), Glyph('\t', PaletteIndex::Background));
 2756|  1.25k|                        modified = true;
 2757|       |
 2758|  1.25k|                        PHI_GCC_SUPPRESS_WARNING_POP()
 2759|  1.25k|                    }
 2760|  5.63k|                }
 2761|       |
 2762|    677|                if (modified)
  ------------------
  |  Branch (2762:21): [True: 554, False: 123]
  ------------------
 2763|    554|                {
 2764|    554|                    start = Coordinates(start.m_Line, GetCharacterColumn(start.m_Line, 0u));
 2765|    554|                    Coordinates range_end;
 2766|       |
 2767|    554|                    if (original_end.m_Column != 0u)
  ------------------
  |  Branch (2767:25): [True: 439, False: 115]
  ------------------
 2768|    439|                    {
 2769|    439|                        end          = Coordinates(end.m_Line, GetLineMaxColumn(end.m_Line));
 2770|    439|                        range_end    = end;
 2771|    439|                        undo.m_Added = GetText(start, end);
 2772|    439|                    }
 2773|    115|                    else
 2774|    115|                    {
 2775|    115|                        end       = Coordinates(original_end.m_Line, 0u);
 2776|    115|                        range_end = Coordinates(end.m_Line - 1u, GetLineMaxColumn(end.m_Line - 1u));
 2777|    115|                        undo.m_Added = GetText(start, range_end);
 2778|    115|                    }
 2779|       |
 2780|    554|                    undo.m_AddedStart        = start;
 2781|    554|                    undo.m_AddedEnd          = range_end;
 2782|    554|                    m_State.m_SelectionStart = start;
 2783|    554|                    m_State.m_SelectionEnd   = end;
 2784|       |
 2785|    554|                    undo.StoreAfterState(this);
 2786|    554|                    AddUndo(undo);
 2787|       |
 2788|    554|                    m_TextChanged = true;
 2789|       |
 2790|    554|                    EnsureCursorVisible();
 2791|    554|                }
 2792|       |
 2793|    677|                return;
 2794|    677|            } // c == '\t'
 2795|    623|            else
 2796|    623|            {
 2797|    623|                undo.m_Removed      = GetSelectedText();
 2798|    623|                undo.m_RemovedStart = m_State.m_SelectionStart;
 2799|    623|                undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2800|    623|                DeleteSelection();
 2801|       |
 2802|    623|                removed_selection = true;
 2803|    623|            }
 2804|  1.30k|        } // HasSelection
 2805|  26.0k|        {
 2806|       |            // Reset selection
 2807|  26.0k|            ClearSelection();
 2808|  26.0k|        }
 2809|       |
 2810|  26.0k|        const Coordinates coord = GetActualCursorCoordinates();
 2811|  26.0k|        undo.m_AddedStart       = coord;
 2812|       |
 2813|  26.0k|        PHI_ASSERT(!m_Lines.empty());
 2814|       |
 2815|  26.0k|        if (character == '\n')
  ------------------
  |  Branch (2815:13): [True: 4.53k, False: 21.5k]
  ------------------
 2816|  4.53k|        {
 2817|  4.53k|            InsertLine(coord.m_Line + 1u);
 2818|  4.53k|            undo.m_Added = static_cast<char>(character);
 2819|       |
 2820|  4.53k|            PHI_ASSERT(coord.m_Line < m_Lines.size() - 1u);
 2821|  4.53k|            Line& line     = m_Lines[coord.m_Line.unsafe()];
 2822|  4.53k|            Line& new_line = m_Lines[coord.m_Line.unsafe() + 1u];
 2823|       |
 2824|  9.79k|            for (phi::u32 it{0u}; it < line.size() && it < coord.m_Column &&
  ------------------
  |  Branch (2824:35): [True: 6.94k, False: 2.85k]
  |  Branch (2824:35): [True: 5.26k, False: 4.53k]
  |  Branch (2824:55): [True: 6.54k, False: 398]
  ------------------
 2825|  9.79k|                                  phi::is_blank(static_cast<char>(line[it.unsafe()].m_Char));
  ------------------
  |  Branch (2825:35): [True: 5.26k, False: 1.28k]
  ------------------
 2826|  5.26k|                 ++it)
 2827|  5.26k|            {
 2828|  5.26k|                new_line.push_back(line[it.unsafe()]);
 2829|  5.26k|                undo.m_Added += static_cast<char>(line[it.unsafe()].m_Char);
 2830|  5.26k|            }
 2831|       |
 2832|  4.53k|            const phi::usize whitespace_size = new_line.size();
 2833|  4.53k|            const phi::u32   cindex          = GetCharacterIndex(coord);
 2834|  4.53k|            new_line.insert(new_line.end(), line.begin() + cindex.unsafe(), line.end());
 2835|  4.53k|            line.erase(line.begin() + cindex.unsafe(),
 2836|  4.53k|                       line.begin() + static_cast<phi::int32_t>(line.size()));
 2837|       |
 2838|  4.53k|            SetCursorPosition(Coordinates(
 2839|  4.53k|                    coord.m_Line + 1u,
 2840|  4.53k|                    GetCharacterColumn(coord.m_Line.unsafe() + 1u,
 2841|  4.53k|                                       static_cast<phi::uint32_t>(whitespace_size.unsafe()))));
 2842|  4.53k|        }
 2843|  21.5k|        else
 2844|  21.5k|        {
 2845|  21.5k|            phi::array<char, 5u> buffer{};
 2846|  21.5k|            const phi::u8_fast   length = ImTextCharToUtf8(buffer, character);
 2847|       |
 2848|       |            // We require a valid ut8 sequence
 2849|  21.5k|            PHI_ASSERT(length > 0u);
 2850|       |
 2851|  21.5k|            Line&    line   = m_Lines[phi::narrow_cast<phi::size_t>(coord.m_Line)];
 2852|  21.5k|            phi::u32 cindex = GetCharacterIndex(coord);
 2853|       |
 2854|  21.5k|            if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (2854:17): [True: 786, False: 20.7k]
  |  Branch (2854:17): [True: 488, False: 21.0k]
  |  Branch (2854:32): [True: 488, False: 298]
  ------------------
 2855|    488|            {
 2856|    488|                phi::u8_fast char_length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 2857|       |
 2858|       |                // Only set the start if haven't removed something from deleting the selection beforehand
 2859|    488|                if (removed_selection)
  ------------------
  |  Branch (2859:21): [True: 23, False: 465]
  ------------------
 2860|     23|                {
 2861|     23|                    undo.m_RemovedEnd.m_Column += 1u;
 2862|     23|                }
 2863|    465|                else
 2864|    465|                {
 2865|    465|                    undo.m_RemovedStart = m_State.m_CursorPosition;
 2866|    465|                    undo.m_RemovedEnd   = Coordinates(
 2867|    465|                            coord.m_Line, GetCharacterColumn(coord.m_Line, cindex + char_length));
 2868|    465|                }
 2869|       |
 2870|  1.74k|                for (; char_length > 0u && cindex < line.size(); --char_length)
  ------------------
  |  Branch (2870:24): [True: 1.25k, False: 488]
  |  Branch (2870:24): [True: 1.25k, False: 488]
  |  Branch (2870:44): [True: 1.25k, False: 0]
  ------------------
 2871|  1.25k|                {
 2872|  1.25k|                    undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 2873|  1.25k|                    line.erase(line.begin() + cindex.unsafe());
 2874|  1.25k|                }
 2875|    488|            }
 2876|       |
 2877|  59.4k|            for (char* pointer = buffer.data(); *pointer != '\0'; ++pointer, ++cindex)
  ------------------
  |  Branch (2877:49): [True: 37.8k, False: 21.5k]
  ------------------
 2878|  37.8k|            {
 2879|  37.8k|                line.insert(line.begin() + cindex.unsafe(),
 2880|  37.8k|                            Glyph(static_cast<phi::uint8_t>(*pointer), PaletteIndex::Default));
 2881|  37.8k|            }
 2882|  21.5k|            undo.m_Added = phi::string_view{buffer.data(), length.unsafe()};
 2883|       |
 2884|  21.5k|            SetCursorPosition(Coordinates(coord.m_Line, GetCharacterColumn(coord.m_Line, cindex)));
 2885|  21.5k|        }
 2886|       |
 2887|  26.0k|        m_TextChanged = true;
 2888|       |
 2889|  26.0k|        undo.m_AddedEnd = GetActualCursorCoordinates();
 2890|  26.0k|        undo.StoreAfterState(this);
 2891|       |
 2892|  26.0k|        AddUndo(undo);
 2893|       |
 2894|  26.0k|        Colorize(coord.m_Line, 1u);
 2895|  26.0k|    }
_ZN6dlxemu10CodeEditor13BackspaceImplEv:
 2898|  1.13k|    {
 2899|  1.13k|        PHI_ASSERT(!m_ReadOnly);
 2900|  1.13k|        PHI_ASSERT(!m_Lines.empty());
 2901|       |
 2902|  1.13k|        UndoRecord undo;
 2903|  1.13k|        undo.StoreBeforeState(this);
 2904|       |
 2905|  1.13k|        if (HasSelection())
  ------------------
  |  Branch (2905:13): [True: 54, False: 1.08k]
  ------------------
 2906|     54|        {
 2907|     54|            undo.m_Removed      = GetSelectedText();
 2908|     54|            undo.m_RemovedStart = m_State.m_SelectionStart;
 2909|     54|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2910|       |
 2911|     54|            DeleteSelection();
 2912|     54|        }
 2913|  1.08k|        else
 2914|  1.08k|        {
 2915|  1.08k|            Coordinates pos = GetActualCursorCoordinates();
 2916|  1.08k|            SetCursorPosition(pos);
 2917|       |
 2918|  1.08k|            if (m_State.m_CursorPosition.m_Column == 0u)
  ------------------
  |  Branch (2918:17): [True: 566, False: 517]
  ------------------
 2919|    566|            {
 2920|    566|                if (m_State.m_CursorPosition.m_Line == 0u)
  ------------------
  |  Branch (2920:21): [True: 228, False: 338]
  ------------------
 2921|    228|                {
 2922|    228|                    return;
 2923|    228|                }
 2924|       |
 2925|    338|                undo.m_Removed      = '\n';
 2926|    338|                undo.m_RemovedStart = undo.m_RemovedEnd =
 2927|    338|                        Coordinates(pos.m_Line - 1u, GetLineMaxColumn(pos.m_Line - 1u));
 2928|    338|                Advance(undo.m_RemovedEnd);
 2929|       |
 2930|    338|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2931|    338|                Line& line      = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2932|    338|                Line& prev_line = m_Lines[m_State.m_CursorPosition.m_Line.unsafe() - 1u];
 2933|       |
 2934|    338|                const phi::u32 prev_size = GetLineMaxColumn(m_State.m_CursorPosition.m_Line - 1u);
 2935|    338|                prev_line.insert(prev_line.end(), line.begin(), line.end());
 2936|       |
 2937|    338|                ErrorMarkers etmp;
 2938|    338|                for (auto& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (2938:41): [True: 570, False: 338]
  ------------------
 2939|    570|                {
 2940|    570|                    const phi::u32 error_marker_line = error_marker.first;
 2941|       |
 2942|    570|                    etmp.insert(ErrorMarkers::value_type(
 2943|    570|                            (error_marker_line - 1u) == m_State.m_CursorPosition.m_Line ?
  ------------------
  |  Branch (2943:29): [True: 123, False: 447]
  ------------------
 2944|    123|                                    error_marker_line - 1u :
 2945|    570|                                    error_marker_line,
 2946|    570|                            error_marker.second));
 2947|    570|                }
 2948|    338|                m_ErrorMarkers = phi::move(etmp);
 2949|       |
 2950|    338|                RemoveLine(m_State.m_CursorPosition.m_Line);
 2951|    338|                --m_State.m_CursorPosition.m_Line;
 2952|    338|                m_State.m_CursorPosition.m_Column = prev_size;
 2953|    338|            }
 2954|    517|            else
 2955|    517|            {
 2956|    517|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2957|    517|                Line&    line   = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2958|    517|                phi::u32 cindex = GetCharacterIndex(pos) - 1u;
 2959|       |
 2960|    517|                if (line[cindex.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2960:21): [True: 53, False: 464]
  ------------------
 2961|     53|                {
 2962|     53|                    undo.m_RemovedStart.m_Line = GetActualCursorCoordinates().m_Line;
 2963|     53|                    undo.m_RemovedEnd          = GetActualCursorCoordinates();
 2964|     53|                    undo.m_Removed             = '\t';
 2965|       |
 2966|     53|                    line.erase(line.begin() + cindex.unsafe());
 2967|       |
 2968|       |                    // Move cursor back
 2969|     53|                    m_State.m_CursorPosition.m_Column = GetCharacterColumn(pos.m_Line, cindex);
 2970|     53|                    undo.m_RemovedStart.m_Column      = GetCharacterColumn(pos.m_Line, cindex);
 2971|     53|                }
 2972|    464|                else
 2973|    464|                {
 2974|    464|                    phi::u32 cend = cindex + 1u;
 2975|    963|                    while (cindex > 0u && IsUTFSequence(line[cindex.unsafe()].m_Char))
  ------------------
  |  Branch (2975:28): [True: 824, False: 139]
  |  Branch (2975:28): [True: 499, False: 464]
  |  Branch (2975:43): [True: 499, False: 325]
  ------------------
 2976|    499|                    {
 2977|    499|                        --cindex;
 2978|    499|                    }
 2979|       |
 2980|    464|                    undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 2981|    464|                    --undo.m_RemovedStart.m_Column;
 2982|    464|                    --m_State.m_CursorPosition.m_Column;
 2983|       |
 2984|  1.42k|                    for (; cindex < line.size() && cend > cindex; --cend)
  ------------------
  |  Branch (2984:28): [True: 1.12k, False: 306]
  |  Branch (2984:28): [True: 963, False: 464]
  |  Branch (2984:52): [True: 963, False: 158]
  ------------------
 2985|    963|                    {
 2986|    963|                        undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 2987|    963|                        line.erase(line.begin() + cindex.unsafe());
 2988|    963|                    }
 2989|    464|                }
 2990|    517|            }
 2991|       |
 2992|    855|            m_TextChanged = true;
 2993|       |
 2994|    855|            EnsureCursorVisible();
 2995|    855|            Colorize(m_State.m_CursorPosition.m_Line, 1);
 2996|    855|        }
 2997|       |
 2998|       |        // Correct selection
 2999|    909|        m_State.m_SelectionStart = SanitizeCoordinates(m_State.m_SelectionStart);
 3000|    909|        m_State.m_SelectionEnd   = SanitizeCoordinates(m_State.m_SelectionEnd);
 3001|       |
 3002|    909|        undo.StoreAfterState(this);
 3003|    909|        AddUndo(undo);
 3004|    909|    }
_ZN6dlxemu10CodeEditor15DeleteSelectionEv:
 3007|  1.49k|    {
 3008|  1.49k|        if (m_State.m_SelectionEnd == m_State.m_SelectionStart)
  ------------------
  |  Branch (3008:13): [True: 0, False: 1.49k]
  ------------------
 3009|      0|        {
 3010|      0|            return;
 3011|      0|        }
 3012|       |
 3013|  1.49k|        DeleteRange(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 3014|       |
 3015|  1.49k|        SetSelection(m_State.m_SelectionStart, m_State.m_SelectionStart);
 3016|  1.49k|        SetCursorPosition(m_State.m_SelectionStart);
 3017|  1.49k|        Colorize(m_State.m_SelectionStart.m_Line, 1);
 3018|  1.49k|        m_TextChanged = true;
 3019|  1.49k|    }
_ZNK6dlxemu10CodeEditor13GetGlyphColorERKNS0_5GlyphE:
 3022|  2.10M|    {
 3023|  2.10M|        if (!m_ColorizerEnabled)
  ------------------
  |  Branch (3023:13): [True: 1.65k, False: 2.10M]
  ------------------
 3024|  1.65k|        {
 3025|  1.65k|            return GetPaletteForIndex(PaletteIndex::Default);
 3026|  1.65k|        }
 3027|       |
 3028|  2.10M|        return GetPaletteForIndex(glyph.m_ColorIndex);
 3029|  2.10M|    }
_ZN6dlxemu10CodeEditor20HandleKeyboardInputsEv:
 3032|  25.9k|    {
 3033|  25.9k|        if (!ImGui::IsWindowFocused())
  ------------------
  |  Branch (3033:13): [True: 10.0k, False: 15.8k]
  ------------------
 3034|  10.0k|        {
 3035|  10.0k|            return;
 3036|  10.0k|        }
 3037|       |
 3038|  15.8k|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3039|  15.8k|        const phi::boolean shift    = imgui_io.KeyShift;
 3040|  15.8k|        const phi::boolean ctrl =
 3041|  15.8k|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3041:17): [True: 0, False: 15.8k]
  ------------------
 3042|  15.8k|        const phi::boolean alt =
 3043|  15.8k|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3043:17): [True: 0, False: 15.8k]
  ------------------
 3044|       |
 3045|  15.8k|        if (ImGui::IsWindowHovered())
  ------------------
  |  Branch (3045:13): [True: 41, False: 15.8k]
  ------------------
 3046|     41|        {
 3047|     41|            ImGui::SetMouseCursor(ImGuiMouseCursor_TextInput);
 3048|     41|        }
 3049|       |        //ImGui::CaptureKeyboardFromApp(true);
 3050|       |
 3051|  15.8k|        imgui_io.WantCaptureKeyboard = true;
 3052|  15.8k|        imgui_io.WantTextInput       = true;
 3053|       |
 3054|  15.8k|        if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Z))
  ------------------
  |  Branch (3054:13): [True: 15.4k, False: 375]
  |  Branch (3054:13): [True: 0, False: 15.8k]
  |  Branch (3054:30): [True: 0, False: 15.4k]
  |  Branch (3054:38): [True: 0, False: 0]
  |  Branch (3054:48): [True: 0, False: 0]
  |  Branch (3054:56): [True: 0, False: 0]
  ------------------
 3055|      0|        {
 3056|      0|            Undo();
 3057|      0|        }
 3058|  15.8k|        else if (!IsReadOnly() && !ctrl && !shift && alt && ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3058:18): [True: 15.4k, False: 375]
  |  Branch (3058:18): [True: 0, False: 15.8k]
  |  Branch (3058:35): [True: 15.4k, False: 0]
  |  Branch (3058:44): [True: 15.4k, False: 0]
  |  Branch (3058:54): [True: 0, False: 15.4k]
  |  Branch (3058:61): [True: 0, False: 0]
  ------------------
 3059|      0|        {
 3060|      0|            Undo();
 3061|      0|        }
 3062|  15.8k|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Y))
  ------------------
  |  Branch (3062:18): [True: 15.4k, False: 375]
  |  Branch (3062:18): [True: 0, False: 15.8k]
  |  Branch (3062:35): [True: 0, False: 15.4k]
  |  Branch (3062:43): [True: 0, False: 0]
  |  Branch (3062:53): [True: 0, False: 0]
  |  Branch (3062:61): [True: 0, False: 0]
  ------------------
 3063|      0|        {
 3064|      0|            Redo();
 3065|      0|        }
 3066|  15.8k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_UpArrow))
  ------------------
  |  Branch (3066:18): [True: 15.8k, False: 0]
  |  Branch (3066:18): [True: 682, False: 15.1k]
  |  Branch (3066:27): [True: 15.8k, False: 0]
  |  Branch (3066:35): [True: 682, False: 15.1k]
  ------------------
 3067|    682|        {
 3068|    682|            MoveUp(1u, shift);
 3069|    682|        }
 3070|  15.1k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_DownArrow))
  ------------------
  |  Branch (3070:18): [True: 15.1k, False: 0]
  |  Branch (3070:18): [True: 69, False: 15.1k]
  |  Branch (3070:27): [True: 15.1k, False: 0]
  |  Branch (3070:35): [True: 69, False: 15.1k]
  ------------------
 3071|     69|        {
 3072|     69|            MoveDown(1u, shift);
 3073|     69|        }
 3074|  15.1k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_LeftArrow))
  ------------------
  |  Branch (3074:18): [True: 15.1k, False: 0]
  |  Branch (3074:18): [True: 717, False: 14.4k]
  |  Branch (3074:26): [True: 717, False: 14.4k]
  ------------------
 3075|    717|        {
 3076|    717|            MoveLeft(1u, shift, ctrl);
 3077|    717|        }
 3078|  14.4k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_RightArrow))
  ------------------
  |  Branch (3078:18): [True: 14.4k, False: 0]
  |  Branch (3078:18): [True: 163, False: 14.2k]
  |  Branch (3078:26): [True: 163, False: 14.2k]
  ------------------
 3079|    163|        {
 3080|    163|            MoveRight(1u, shift, ctrl);
 3081|    163|        }
 3082|  14.2k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageUp))
  ------------------
  |  Branch (3082:18): [True: 14.2k, False: 0]
  |  Branch (3082:18): [True: 167, False: 14.0k]
  |  Branch (3082:26): [True: 167, False: 14.0k]
  ------------------
 3083|    167|        {
 3084|    167|            const phi::u32 page_size = GetPageSize();
 3085|    167|            MoveUp(page_size - 4u, shift);
 3086|    167|        }
 3087|  14.0k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageDown))
  ------------------
  |  Branch (3087:18): [True: 14.0k, False: 0]
  |  Branch (3087:18): [True: 1, False: 14.0k]
  |  Branch (3087:26): [True: 1, False: 14.0k]
  ------------------
 3088|      1|        {
 3089|      1|            const phi::u32 page_size = GetPageSize();
 3090|      1|            MoveDown(page_size - 4u, shift);
 3091|      1|        }
 3092|  14.0k|        else if (!alt && ctrl && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3092:18): [True: 14.0k, False: 0]
  |  Branch (3092:18): [True: 0, False: 14.0k]
  |  Branch (3092:26): [True: 0, False: 14.0k]
  |  Branch (3092:34): [True: 0, False: 0]
  ------------------
 3093|      0|        {
 3094|      0|            MoveTop(shift);
 3095|      0|        }
 3096|  14.0k|        else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3096:18): [True: 0, False: 14.0k]
  |  Branch (3096:18): [True: 0, False: 14.0k]
  |  Branch (3096:26): [True: 0, False: 0]
  |  Branch (3096:34): [True: 0, False: 0]
  ------------------
 3097|      0|        {
 3098|      0|            MoveBottom(shift);
 3099|      0|        }
 3100|  14.0k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3100:18): [True: 14.0k, False: 0]
  |  Branch (3100:18): [True: 1, False: 14.0k]
  |  Branch (3100:27): [True: 14.0k, False: 0]
  |  Branch (3100:35): [True: 1, False: 14.0k]
  ------------------
 3101|      1|        {
 3102|      1|            MoveHome(shift);
 3103|      1|        }
 3104|  14.0k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3104:18): [True: 14.0k, False: 0]
  |  Branch (3104:18): [True: 1, False: 14.0k]
  |  Branch (3104:27): [True: 14.0k, False: 0]
  |  Branch (3104:35): [True: 1, False: 14.0k]
  ------------------
 3105|      1|        {
 3106|      1|            MoveEnd(shift);
 3107|      1|        }
 3108|  14.0k|        else if (!IsReadOnly() && !ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3108:18): [True: 13.7k, False: 320]
  |  Branch (3108:18): [True: 1, False: 14.0k]
  |  Branch (3108:35): [True: 13.7k, False: 0]
  |  Branch (3108:44): [True: 13.7k, False: 0]
  |  Branch (3108:54): [True: 13.7k, False: 0]
  |  Branch (3108:62): [True: 1, False: 13.7k]
  ------------------
 3109|      1|        {
 3110|      1|            Delete();
 3111|      1|        }
 3112|  14.0k|        else if (!IsReadOnly() && !ctrl && !shift && !alt &&
  ------------------
  |  Branch (3112:18): [True: 13.7k, False: 320]
  |  Branch (3112:18): [True: 1, False: 14.0k]
  |  Branch (3112:35): [True: 13.7k, False: 0]
  |  Branch (3112:44): [True: 13.7k, False: 0]
  |  Branch (3112:54): [True: 13.7k, False: 0]
  ------------------
 3113|  14.0k|                 ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3113:18): [True: 1, False: 13.7k]
  ------------------
 3114|      1|        {
 3115|      1|            BackspaceImpl();
 3116|      1|        }
 3117|  14.0k|        else if (!ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3117:18): [True: 14.0k, False: 0]
  |  Branch (3117:18): [True: 3, False: 14.0k]
  |  Branch (3117:27): [True: 14.0k, False: 0]
  |  Branch (3117:37): [True: 14.0k, False: 0]
  |  Branch (3117:45): [True: 3, False: 14.0k]
  ------------------
 3118|      3|        {
 3119|      3|            m_Overwrite = !m_Overwrite;
 3120|      3|        }
 3121|  14.0k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3121:18): [True: 0, False: 14.0k]
  |  Branch (3121:18): [True: 0, False: 14.0k]
  |  Branch (3121:26): [True: 0, False: 0]
  |  Branch (3121:36): [True: 0, False: 0]
  |  Branch (3121:44): [True: 0, False: 0]
  ------------------
 3122|      0|        {
 3123|      0|            Copy();
 3124|      0|        }
 3125|  14.0k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_C))
  ------------------
  |  Branch (3125:18): [True: 0, False: 14.0k]
  |  Branch (3125:18): [True: 0, False: 14.0k]
  |  Branch (3125:26): [True: 0, False: 0]
  |  Branch (3125:36): [True: 0, False: 0]
  |  Branch (3125:44): [True: 0, False: 0]
  ------------------
 3126|      0|        {
 3127|      0|            Copy();
 3128|      0|        }
 3129|  14.0k|        else if (!IsReadOnly() && !ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3129:18): [True: 13.7k, False: 320]
  |  Branch (3129:18): [True: 0, False: 14.0k]
  |  Branch (3129:35): [True: 13.7k, False: 0]
  |  Branch (3129:44): [True: 0, False: 13.7k]
  |  Branch (3129:53): [True: 0, False: 0]
  |  Branch (3129:61): [True: 0, False: 0]
  ------------------
 3130|      0|        {
 3131|      0|            Paste();
 3132|      0|        }
 3133|  14.0k|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_V))
  ------------------
  |  Branch (3133:18): [True: 13.7k, False: 320]
  |  Branch (3133:18): [True: 0, False: 14.0k]
  |  Branch (3133:35): [True: 0, False: 13.7k]
  |  Branch (3133:43): [True: 0, False: 0]
  |  Branch (3133:53): [True: 0, False: 0]
  |  Branch (3133:61): [True: 0, False: 0]
  ------------------
 3134|      0|        {
 3135|      0|            Paste();
 3136|      0|        }
 3137|  14.0k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_X))
  ------------------
  |  Branch (3137:18): [True: 0, False: 14.0k]
  |  Branch (3137:18): [True: 0, False: 14.0k]
  |  Branch (3137:26): [True: 0, False: 0]
  |  Branch (3137:36): [True: 0, False: 0]
  |  Branch (3137:44): [True: 0, False: 0]
  ------------------
 3138|      0|        {
 3139|      0|            Cut();
 3140|      0|        }
 3141|  14.0k|        else if (!ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3141:18): [True: 14.0k, False: 0]
  |  Branch (3141:18): [True: 0, False: 14.0k]
  |  Branch (3141:27): [True: 0, False: 14.0k]
  |  Branch (3141:36): [True: 0, False: 0]
  |  Branch (3141:44): [True: 0, False: 0]
  ------------------
 3142|      0|        {
 3143|      0|            Cut();
 3144|      0|        }
 3145|  14.0k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_A))
  ------------------
  |  Branch (3145:18): [True: 0, False: 14.0k]
  |  Branch (3145:18): [True: 0, False: 14.0k]
  |  Branch (3145:26): [True: 0, False: 0]
  |  Branch (3145:36): [True: 0, False: 0]
  |  Branch (3145:44): [True: 0, False: 0]
  ------------------
 3146|      0|        {
 3147|      0|            SelectAll();
 3148|      0|        }
 3149|  14.0k|        else if (!IsReadOnly() && !ctrl && !alt &&
  ------------------
  |  Branch (3149:18): [True: 13.7k, False: 320]
  |  Branch (3149:18): [True: 46, False: 14.0k]
  |  Branch (3149:35): [True: 13.7k, False: 0]
  |  Branch (3149:44): [True: 13.7k, False: 0]
  ------------------
 3150|  14.0k|                 (ImGui::IsKeyPressed(ImGuiKey_Enter) || ImGui::IsKeyPressed(ImGuiKey_KeypadEnter)))
  ------------------
  |  Branch (3150:19): [True: 46, False: 13.6k]
  |  Branch (3150:58): [True: 0, False: 13.6k]
  ------------------
 3151|     46|        {
 3152|     46|            EnterCharacterImpl('\n', shift);
 3153|     46|        }
 3154|  14.0k|        else if (!IsReadOnly() && !ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Tab))
  ------------------
  |  Branch (3154:18): [True: 13.6k, False: 320]
  |  Branch (3154:18): [True: 292, False: 13.7k]
  |  Branch (3154:35): [True: 13.6k, False: 0]
  |  Branch (3154:44): [True: 13.6k, False: 0]
  |  Branch (3154:52): [True: 292, False: 13.4k]
  ------------------
 3155|    292|        {
 3156|    292|            EnterCharacterImpl('\t', shift);
 3157|    292|        }
 3158|       |
 3159|  15.8k|        if (!IsReadOnly() && !imgui_io.InputQueueCharacters.empty())
  ------------------
  |  Branch (3159:13): [True: 15.4k, False: 375]
  |  Branch (3159:13): [True: 1.37k, False: 14.4k]
  |  Branch (3159:30): [True: 1.37k, False: 14.1k]
  ------------------
 3160|  1.37k|        {
 3161|  3.47k|            for (phi::i32 i{0}; i < imgui_io.InputQueueCharacters.Size; ++i)
  ------------------
  |  Branch (3161:33): [True: 2.09k, False: 1.37k]
  ------------------
 3162|  2.09k|            {
 3163|  2.09k|                ImWchar input_char = imgui_io.InputQueueCharacters[i.unsafe()];
 3164|  2.09k|                if (input_char != '\0' && IsValidUTF8Sequence(input_char))
  ------------------
  |  Branch (3164:21): [True: 2.09k, False: 0]
  |  Branch (3164:21): [True: 2.08k, False: 10]
  |  Branch (3164:43): [True: 2.08k, False: 10]
  ------------------
 3165|  2.08k|                {
 3166|  2.08k|                    EnterCharacterImpl(input_char, shift);
 3167|  2.08k|                }
 3168|  2.09k|            }
 3169|       |
 3170|  1.37k|            imgui_io.InputQueueCharacters.resize(0);
 3171|  1.37k|        }
 3172|  15.8k|    }
_ZN6dlxemu10CodeEditor17HandleMouseInputsEv:
 3175|  25.9k|    {
 3176|       |        // Do nothing if our window is not hovered
 3177|  25.9k|        if (!ImGui::IsWindowHovered())
  ------------------
  |  Branch (3177:13): [True: 25.8k, False: 72]
  ------------------
 3178|  25.8k|        {
 3179|  25.8k|            return;
 3180|  25.8k|        }
 3181|       |
 3182|     72|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3183|     72|        const phi::boolean shift    = imgui_io.KeyShift;
 3184|     72|        const phi::boolean ctrl =
 3185|     72|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3185:17): [True: 0, False: 72]
  ------------------
 3186|     72|        const phi::boolean alt =
 3187|     72|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3187:17): [True: 0, False: 72]
  ------------------
 3188|       |
 3189|     72|        if (shift || alt)
  ------------------
  |  Branch (3189:13): [True: 0, False: 72]
  |  Branch (3189:22): [True: 0, False: 72]
  ------------------
 3190|      0|        {
 3191|      0|            return;
 3192|      0|        }
 3193|       |
 3194|       |        // TODO: Maybe theres a smarter way here than suppressing the warning and comparing m_LastClick != -1.0f?
 3195|     72|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3196|       |
 3197|     72|        const phi::boolean click        = ImGui::IsMouseClicked(ImGuiMouseButton_Left);
 3198|     72|        const phi::boolean double_click = ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left);
 3199|     72|        const double       time         = ImGui::GetTime();
 3200|     72|        const phi::boolean triple_click =
 3201|     72|                click && !double_click &&
  ------------------
  |  Branch (3201:17): [True: 15, False: 57]
  |  Branch (3201:26): [True: 6, False: 9]
  ------------------
 3202|     72|                (m_LastClick != -1.0f &&
  ------------------
  |  Branch (3202:18): [True: 0, False: 6]
  ------------------
 3203|      6|                 (static_cast<float>(time) - m_LastClick) < imgui_io.MouseDoubleClickTime);
  ------------------
  |  Branch (3203:18): [True: 0, False: 0]
  ------------------
 3204|       |
 3205|     72|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_POP()
 3206|       |
 3207|       |        /*
 3208|       |            Left mouse button triple click
 3209|       |        */
 3210|       |
 3211|     72|        if (triple_click)
  ------------------
  |  Branch (3211:13): [True: 0, False: 72]
  ------------------
 3212|      0|        {
 3213|      0|            if (!ctrl)
  ------------------
  |  Branch (3213:17): [True: 0, False: 0]
  ------------------
 3214|      0|            {
 3215|      0|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3216|      0|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3217|      0|                m_SelectionMode = SelectionMode::Line;
 3218|      0|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3219|      0|            }
 3220|       |
 3221|      0|            m_LastClick = -1.0f;
 3222|      0|        }
 3223|       |
 3224|       |        /*
 3225|       |            Left mouse button double click
 3226|       |        */
 3227|       |
 3228|     72|        else if (double_click)
  ------------------
  |  Branch (3228:18): [True: 9, False: 63]
  ------------------
 3229|      9|        {
 3230|      9|            if (!ctrl)
  ------------------
  |  Branch (3230:17): [True: 9, False: 0]
  ------------------
 3231|      9|            {
 3232|      9|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3233|      9|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3234|      9|                if (m_SelectionMode == SelectionMode::Line)
  ------------------
  |  Branch (3234:21): [True: 0, False: 9]
  ------------------
 3235|      0|                {
 3236|      0|                    m_SelectionMode = SelectionMode::Normal;
 3237|      0|                }
 3238|      9|                else
 3239|      9|                {
 3240|      9|                    m_SelectionMode = SelectionMode::Word;
 3241|      9|                }
 3242|      9|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3243|      9|            }
 3244|       |
 3245|      9|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3246|      9|        }
 3247|       |
 3248|       |        /*
 3249|       |            Left mouse button click
 3250|       |        */
 3251|       |
 3252|     63|        else if (click)
  ------------------
  |  Branch (3252:18): [True: 6, False: 57]
  ------------------
 3253|      6|        {
 3254|      6|            m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3255|      6|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3256|      6|            if (ctrl)
  ------------------
  |  Branch (3256:17): [True: 0, False: 6]
  ------------------
 3257|      0|            {
 3258|      0|                m_SelectionMode = SelectionMode::Word;
 3259|      0|            }
 3260|      6|            else
 3261|      6|            {
 3262|      6|                m_SelectionMode = SelectionMode::Normal;
 3263|      6|            }
 3264|      6|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3265|       |
 3266|      6|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3267|      6|        }
 3268|       |        // Mouse left button dragging (=> update selection)
 3269|     57|        else if (ImGui::IsMouseDragging(ImGuiMouseButton_Left) &&
  ------------------
  |  Branch (3269:18): [True: 0, False: 57]
  ------------------
 3270|     57|                 ImGui::IsMouseDown(ImGuiMouseButton_Left))
  ------------------
  |  Branch (3270:18): [True: 0, False: 0]
  ------------------
 3271|      0|        {
 3272|      0|            imgui_io.WantCaptureMouse = true;
 3273|      0|            m_State.m_CursorPosition  = m_InteractiveEnd =
 3274|      0|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3275|      0|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3276|      0|        }
 3277|     72|    }
_ZN6dlxemu10CodeEditor14InternalRenderEv:
 3281|  25.9k|    {
 3282|  25.9k|        PHI_ASSERT(m_LineBuffer.empty());
 3283|       |
 3284|  25.9k|        const ImVec2 content_size = ImGui::GetWindowContentRegionMax();
 3285|  25.9k|        ImDrawList*  draw_list    = ImGui::GetWindowDrawList();
 3286|  25.9k|        float        longest      = m_TextStart;
 3287|       |
 3288|  25.9k|        if (m_ScrollToTop)
  ------------------
  |  Branch (3288:13): [True: 166, False: 25.7k]
  ------------------
 3289|    166|        {
 3290|    166|            m_ScrollToTop = false;
 3291|    166|            ImGui::SetScrollY(0.f);
 3292|    166|        }
 3293|       |
 3294|  25.9k|        const ImVec2 cursor_screen_pos = ImGui::GetCursorScreenPos();
 3295|  25.9k|        const float  scroll_x          = ImGui::GetScrollX();
 3296|  25.9k|        const float  scroll_y          = ImGui::GetScrollY();
 3297|       |
 3298|  25.9k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3299|  25.9k|        phi::u32       line_no = static_cast<phi::uint32_t>(std::floor(scroll_y / m_CharAdvance.y));
 3300|  25.9k|        const phi::u32 global_line_max = static_cast<phi::uint32_t>(m_Lines.size());
 3301|       |
 3302|       |        // TODO: This is very unreadable
 3303|  25.9k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3304|  25.9k|        const phi::u32 line_max = static_cast<phi::uint32_t>(phi::clamp(
 3305|  25.9k|                GetMaxLineNumber().unsafe(), 0u,
 3306|  25.9k|                line_no.unsafe() + static_cast<phi::int32_t>(std::floor(
 3307|  25.9k|                                           (scroll_y + content_size.y) / m_CharAdvance.y))));
 3308|       |
 3309|       |        // Deduce m_TextStart by evaluating mLines size (global lineMax) plus two spaces as text width
 3310|  25.9k|        phi::array<char, 16u> buffer;
 3311|  25.9k|        snprintf(buffer.data(), buffer.size().unsafe(), " %u ", global_line_max.unsafe());
 3312|  25.9k|        m_TextStart = ImGui::GetFont()
 3313|  25.9k|                              ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3314|  25.9k|                                              nullptr, nullptr)
 3315|  25.9k|                              .x +
 3316|  25.9k|                      LeftMargin;
 3317|       |
 3318|  25.9k|        PHI_ASSERT(!m_Lines.empty());
 3319|  25.9k|        float space_size =
 3320|  25.9k|                ImGui::GetFont()
 3321|  25.9k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 3322|  25.9k|                        .x;
 3323|       |
 3324|  72.3k|        while (line_no <= line_max)
  ------------------
  |  Branch (3324:16): [True: 46.3k, False: 25.9k]
  ------------------
 3325|  46.3k|        {
 3326|  46.3k|            const ImVec2 line_start_screen_pos = ImVec2(
 3327|  46.3k|                    cursor_screen_pos.x,
 3328|  46.3k|                    cursor_screen_pos.y + static_cast<float>(line_no.unsafe()) * m_CharAdvance.y);
 3329|  46.3k|            const ImVec2 text_screen_pos =
 3330|  46.3k|                    ImVec2(line_start_screen_pos.x + m_TextStart, line_start_screen_pos.y);
 3331|       |
 3332|  46.3k|            PHI_ASSERT(line_no < m_Lines.size());
 3333|  46.3k|            const Line& line = m_Lines[line_no.unsafe()];
 3334|       |
 3335|  46.3k|            longest               = phi::max(m_TextStart + TextDistanceToLineStart(Coordinates(
 3336|  46.3k|                                                     line_no, GetLineMaxColumn(line_no))),
 3337|  46.3k|                                             longest);
 3338|  46.3k|            phi::u32    column_no = 0u;
 3339|  46.3k|            Coordinates line_start_coord(line_no, 0u);
 3340|  46.3k|            Coordinates line_end_coord(line_no, GetLineMaxColumn(line_no));
 3341|       |
 3342|       |            // Draw selection for the current line
 3343|  46.3k|            float sstart = -1.0f;
 3344|  46.3k|            float ssend  = -1.0f;
 3345|       |
 3346|  46.3k|            PHI_ASSERT(m_State.m_SelectionStart <= m_State.m_SelectionEnd);
 3347|  46.3k|            if (m_State.m_SelectionStart <= line_end_coord)
  ------------------
  |  Branch (3347:17): [True: 43.9k, False: 2.43k]
  ------------------
 3348|  43.9k|            {
 3349|  43.9k|                sstart = m_State.m_SelectionStart > line_start_coord ?
  ------------------
  |  Branch (3349:26): [True: 2.96k, False: 41.0k]
  ------------------
 3350|  2.96k|                                 TextDistanceToLineStart(m_State.m_SelectionStart) :
 3351|  43.9k|                                 0.0f;
 3352|  43.9k|            }
 3353|       |
 3354|  46.3k|            if (m_State.m_SelectionEnd > line_start_coord)
  ------------------
  |  Branch (3354:17): [True: 17.7k, False: 28.6k]
  ------------------
 3355|  17.7k|            {
 3356|  17.7k|                ssend = TextDistanceToLineStart(m_State.m_SelectionEnd < line_end_coord ?
  ------------------
  |  Branch (3356:49): [True: 775, False: 16.9k]
  ------------------
 3357|    775|                                                        m_State.m_SelectionEnd :
 3358|  17.7k|                                                        line_end_coord);
 3359|  17.7k|            }
 3360|       |
 3361|  46.3k|            if (m_State.m_SelectionEnd.m_Line > line_no)
  ------------------
  |  Branch (3361:17): [True: 13.7k, False: 32.6k]
  ------------------
 3362|  13.7k|            {
 3363|  13.7k|                ssend += m_CharAdvance.x;
 3364|  13.7k|            }
 3365|       |
 3366|  46.3k|            PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3367|       |
 3368|  46.3k|            if (sstart != -1.0f && ssend != -1.0f && sstart < ssend)
  ------------------
  |  Branch (3368:17): [True: 43.9k, False: 2.43k]
  |  Branch (3368:36): [True: 15.2k, False: 28.6k]
  |  Branch (3368:54): [True: 12.3k, False: 2.91k]
  ------------------
 3369|  12.3k|            {
 3370|  12.3k|                const ImVec2 vstart(line_start_screen_pos.x + m_TextStart + sstart,
 3371|  12.3k|                                    line_start_screen_pos.y);
 3372|  12.3k|                const ImVec2 vend(line_start_screen_pos.x + m_TextStart + ssend,
 3373|  12.3k|                                  line_start_screen_pos.y + m_CharAdvance.y);
 3374|       |
 3375|  12.3k|                draw_list->AddRectFilled(vstart, vend, GetPaletteForIndex(PaletteIndex::Selection));
 3376|  12.3k|            }
 3377|       |
 3378|  46.3k|            PHI_GCC_SUPPRESS_WARNING_POP()
 3379|       |
 3380|       |            // Draw breakpoints
 3381|  46.3k|            const ImVec2 start =
 3382|  46.3k|                    ImVec2(line_start_screen_pos.x + scroll_x, line_start_screen_pos.y);
 3383|       |
 3384|  46.3k|            if (m_Breakpoints.find(line_no.unsafe() + 1u) != m_Breakpoints.end())
  ------------------
  |  Branch (3384:17): [True: 890, False: 45.5k]
  ------------------
 3385|    890|            {
 3386|    890|                const ImVec2 end =
 3387|    890|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3388|    890|                               line_start_screen_pos.y + m_CharAdvance.y);
 3389|       |
 3390|    890|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::Breakpoint));
 3391|    890|            }
 3392|       |
 3393|       |            // Draw error markers
 3394|  46.3k|            auto error_it = m_ErrorMarkers.find(line_no.unsafe() + 1u);
 3395|  46.3k|            if (error_it != m_ErrorMarkers.end())
  ------------------
  |  Branch (3395:17): [True: 22.4k, False: 23.9k]
  ------------------
 3396|  22.4k|            {
 3397|  22.4k|                const ImVec2 end =
 3398|  22.4k|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3399|  22.4k|                               line_start_screen_pos.y + m_CharAdvance.y);
 3400|  22.4k|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::ErrorMarker));
 3401|       |
 3402|  22.4k|                if (GImGui->HoveredWindow == ImGui::GetCurrentWindow() &&
  ------------------
  |  Branch (3402:21): [True: 56, False: 22.3k]
  ------------------
 3403|  22.4k|                    ImGui::IsMouseHoveringRect(line_start_screen_pos, end))
  ------------------
  |  Branch (3403:21): [True: 17, False: 39]
  ------------------
 3404|     17|                {
 3405|     17|                    ImGui::BeginTooltip();
 3406|     17|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.2f, 0.2f, 1.0f));
 3407|     17|                    ImGui::Text("Error at line %u:", error_it->first);
 3408|     17|                    ImGui::PopStyleColor();
 3409|     17|                    ImGui::Separator();
 3410|     17|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.2f, 1.0f));
 3411|     17|                    ImGui::Text("%s", error_it->second.c_str());
 3412|     17|                    ImGui::PopStyleColor();
 3413|     17|                    ImGui::EndTooltip();
 3414|     17|                }
 3415|  22.4k|            }
 3416|       |
 3417|       |            // Highlight PC line
 3418|  46.3k|            const phi::u64 current_execution_line_number = m_Emulator->GetExecutingLineNumber();
 3419|  46.3k|            if (line_no + 1u == current_execution_line_number)
  ------------------
  |  Branch (3419:17): [True: 0, False: 46.3k]
  ------------------
 3420|      0|            {
 3421|      0|                const ImVec2 end =
 3422|      0|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3423|      0|                               line_start_screen_pos.y + m_CharAdvance.y);
 3424|       |                // TODO: Don't hardcode color
 3425|      0|                draw_list->AddRectFilled(start, end, 0x40ffff00);
 3426|      0|            }
 3427|       |
 3428|       |            // Draw line number (right aligned)
 3429|  46.3k|            snprintf(buffer.data(), buffer.size().unsafe(), "%u  ", line_no.unsafe() + 1u);
 3430|       |
 3431|  46.3k|            const float line_no_width =
 3432|  46.3k|                    ImGui::GetFont()
 3433|  46.3k|                            ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3434|  46.3k|                                            nullptr, nullptr)
 3435|  46.3k|                            .x;
 3436|  46.3k|            draw_list->AddText(ImVec2(line_start_screen_pos.x + m_TextStart - line_no_width,
 3437|  46.3k|                                      line_start_screen_pos.y),
 3438|  46.3k|                               GetPaletteForIndex(PaletteIndex::LineNumber), buffer.data());
 3439|       |
 3440|  46.3k|            if (m_State.m_CursorPosition.m_Line == line_no)
  ------------------
  |  Branch (3440:17): [True: 25.3k, False: 21.0k]
  ------------------
 3441|  25.3k|            {
 3442|  25.3k|                const phi::boolean focused = ImGui::IsWindowFocused();
 3443|       |
 3444|       |                // Highlight the current line (where the cursor is)
 3445|  25.3k|                if (!HasSelection())
  ------------------
  |  Branch (3445:21): [True: 23.9k, False: 1.39k]
  ------------------
 3446|  23.9k|                {
 3447|  23.9k|                    const ImVec2 end =
 3448|  23.9k|                            ImVec2(start.x + content_size.x + scroll_x, start.y + m_CharAdvance.y);
 3449|  23.9k|                    draw_list->AddRectFilled(
 3450|  23.9k|                            start, end,
 3451|  23.9k|                            GetPaletteForIndex(focused ? PaletteIndex::CurrentLineFill :
  ------------------
  |  Branch (3451:48): [True: 14.1k, False: 9.73k]
  ------------------
 3452|  23.9k|                                                         PaletteIndex::CurrentLineFillInactive));
 3453|  23.9k|                    draw_list->AddRect(start, end,
 3454|  23.9k|                                       GetPaletteForIndex(PaletteIndex::CurrentLineEdge), 1.0f);
 3455|  23.9k|                }
 3456|       |
 3457|       |                // Render the cursor
 3458|  25.3k|                if (focused)
  ------------------
  |  Branch (3458:21): [True: 15.3k, False: 9.96k]
  ------------------
 3459|  15.3k|                {
 3460|  15.3k|                    phi::uint64_t time_end = static_cast<phi::uint64_t>(
 3461|  15.3k|                            std::chrono::duration_cast<std::chrono::milliseconds>(
 3462|  15.3k|                                    std::chrono::system_clock::now().time_since_epoch())
 3463|  15.3k|                                    .count());
 3464|  15.3k|                    phi::uint64_t elapsed = time_end - m_StartTime;
 3465|  15.3k|                    if (elapsed > 400)
  ------------------
  |  Branch (3465:25): [True: 14, False: 15.3k]
  ------------------
 3466|     14|                    {
 3467|     14|                        float    width  = 1.0f;
 3468|     14|                        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
 3469|     14|                        float    cx     = TextDistanceToLineStart(m_State.m_CursorPosition);
 3470|       |
 3471|     14|                        if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (3471:29): [True: 9, False: 5]
  |  Branch (3471:29): [True: 0, False: 14]
  |  Branch (3471:44): [True: 0, False: 9]
  ------------------
 3472|      0|                        {
 3473|      0|                            char character = static_cast<char>(line[cindex.unsafe()].m_Char);
 3474|      0|                            if (character == '\t')
  ------------------
  |  Branch (3474:33): [True: 0, False: 0]
  ------------------
 3475|      0|                            {
 3476|      0|                                float x = (1.0f +
 3477|      0|                                           std::floor((1.0f + cx) /
 3478|      0|                                                      (float(m_TabSize.unsafe()) * space_size))) *
 3479|      0|                                          (float(m_TabSize.unsafe()) * space_size);
 3480|      0|                                width = x - cx;
 3481|      0|                            }
 3482|      0|                            else
 3483|      0|                            {
 3484|      0|                                phi::array<char, 2u> buffer2;
 3485|      0|                                buffer2[0u] = static_cast<char>(line[cindex.unsafe()].m_Char);
 3486|      0|                                buffer2[1u] = '\0';
 3487|      0|                                width       = ImGui::GetFont()
 3488|      0|                                                ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX,
 3489|      0|                                                                -1.0f, buffer2.data())
 3490|      0|                                                .x;
 3491|      0|                            }
 3492|      0|                        }
 3493|     14|                        const ImVec2 cstart(text_screen_pos.x + cx, line_start_screen_pos.y);
 3494|     14|                        const ImVec2 cend(text_screen_pos.x + cx + width,
 3495|     14|                                          line_start_screen_pos.y + m_CharAdvance.y);
 3496|     14|                        draw_list->AddRectFilled(cstart, cend,
 3497|     14|                                                 GetPaletteForIndex(PaletteIndex::Cursor));
 3498|     14|                        if (elapsed > 800)
  ------------------
  |  Branch (3498:29): [True: 5, False: 9]
  ------------------
 3499|      5|                        {
 3500|      5|                            m_StartTime = time_end;
 3501|      5|                        }
 3502|     14|                    }
 3503|  15.3k|                }
 3504|  25.3k|            }
 3505|       |
 3506|       |            // Render colorized text
 3507|  46.3k|            ImU32  prev_color = line.empty() ? GetPaletteForIndex(PaletteIndex::Default) :
  ------------------
  |  Branch (3507:33): [True: 18.7k, False: 27.6k]
  ------------------
 3508|  46.3k|                                               GetGlyphColor(line[0]);
 3509|  46.3k|            ImVec2 buffer_offset;
 3510|       |
 3511|  2.12M|            for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (3511:36): [True: 2.07M, False: 46.3k]
  ------------------
 3512|  2.07M|            {
 3513|  2.07M|                const CodeEditor::Glyph& glyph = line[i.unsafe()];
 3514|  2.07M|                const ImU32              color = GetGlyphColor(glyph);
 3515|       |
 3516|  2.07M|                if ((color != prev_color || glyph.m_Char == '\t' || glyph.m_Char == ' ') &&
  ------------------
  |  Branch (3516:22): [True: 31.6k, False: 2.04M]
  |  Branch (3516:45): [True: 23.3k, False: 2.02M]
  |  Branch (3516:69): [True: 231k, False: 1.79M]
  ------------------
 3517|  2.07M|                    !m_LineBuffer.empty())
  ------------------
  |  Branch (3517:21): [True: 236k, False: 50.0k]
  ------------------
 3518|   236k|                {
 3519|   236k|                    const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3520|   236k|                                            text_screen_pos.y + buffer_offset.y);
 3521|   236k|                    draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3522|   236k|                    const ImVec2 text_size =
 3523|   236k|                            ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 3524|   236k|                                                            m_LineBuffer.c_str(), nullptr, nullptr);
 3525|   236k|                    buffer_offset.x += text_size.x;
 3526|   236k|                    m_LineBuffer.clear();
 3527|   236k|                }
 3528|  2.07M|                prev_color = color;
 3529|       |
 3530|  2.07M|                if (glyph.m_Char == '\t')
  ------------------
  |  Branch (3530:21): [True: 23.3k, False: 2.05M]
  ------------------
 3531|  23.3k|                {
 3532|  23.3k|                    const float old_x = buffer_offset.x;
 3533|  23.3k|                    buffer_offset.x =
 3534|  23.3k|                            (1.0f + std::floor((1.0f + buffer_offset.x) /
 3535|  23.3k|                                               (float(m_TabSize.unsafe()) * space_size))) *
 3536|  23.3k|                            (float(m_TabSize.unsafe()) * space_size);
 3537|  23.3k|                    ++i;
 3538|       |
 3539|  23.3k|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3539:25): [True: 9.93k, False: 13.4k]
  ------------------
 3540|  9.93k|                    {
 3541|  9.93k|                        const float font_size =
 3542|  9.93k|                                ImGui::GetFont()
 3543|  9.93k|                                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#",
 3544|  9.93k|                                                        nullptr, nullptr)
 3545|  9.93k|                                        .x;
 3546|       |
 3547|  9.93k|                        const float  s  = ImGui::GetFontSize();
 3548|  9.93k|                        const float  x1 = text_screen_pos.x + old_x + 1.0f;
 3549|  9.93k|                        const float  x2 = text_screen_pos.x + buffer_offset.x - 1.0f;
 3550|  9.93k|                        const float  y  = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3551|  9.93k|                        const ImVec2 p1(x1, y);
 3552|  9.93k|                        const ImVec2 p2(x2, y);
 3553|  9.93k|                        const ImVec2 p3(x2 - font_size * 0.2f, y - font_size * 0.2f);
 3554|  9.93k|                        const ImVec2 p4(x2 - font_size * 0.2f, y + font_size * 0.2f);
 3555|       |
 3556|  9.93k|                        PHI_MSVC_SUPPRESS_WARNING_WITH_PUSH(5264) // Unused const variable
 3557|       |
 3558|  9.93k|                        static constexpr const ImU32 whitespace_color{0x90909090};
 3559|       |
 3560|  9.93k|                        PHI_MSVC_SUPPRESS_WARNING_POP()
 3561|       |
 3562|  9.93k|                        draw_list->AddLine(p1, p2, whitespace_color);
 3563|  9.93k|                        draw_list->AddLine(p2, p3, whitespace_color);
 3564|  9.93k|                        draw_list->AddLine(p2, p4, whitespace_color);
 3565|  9.93k|                    }
 3566|  23.3k|                }
 3567|  2.05M|                else if (glyph.m_Char == ' ')
  ------------------
  |  Branch (3567:26): [True: 245k, False: 1.80M]
  ------------------
 3568|   245k|                {
 3569|   245k|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3569:25): [True: 11.2k, False: 234k]
  ------------------
 3570|  11.2k|                    {
 3571|  11.2k|                        const float s = ImGui::GetFontSize();
 3572|  11.2k|                        const float x = text_screen_pos.x + buffer_offset.x + space_size * 0.5f;
 3573|  11.2k|                        const float y = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3574|  11.2k|                        draw_list->AddCircleFilled(ImVec2(x, y), 1.5f, 0x80808080, 4);
 3575|  11.2k|                    }
 3576|   245k|                    buffer_offset.x += space_size;
 3577|   245k|                    i++;
 3578|   245k|                }
 3579|  1.80M|                else
 3580|  1.80M|                {
 3581|  5.53M|                    for (phi::u8_fast length = UTF8CharLength(glyph.m_Char); length > 0u;
  ------------------
  |  Branch (3581:78): [True: 3.72M, False: 1.80M]
  ------------------
 3582|  3.72M|                         ++i, --length)
 3583|  3.72M|                    {
 3584|  3.72M|                        m_LineBuffer.push_back(static_cast<char>(line[i.unsafe()].m_Char));
 3585|  3.72M|                    }
 3586|  1.80M|                }
 3587|  2.07M|                ++column_no;
 3588|  2.07M|            }
 3589|  46.3k|            if (!m_LineBuffer.empty())
  ------------------
  |  Branch (3589:17): [True: 20.9k, False: 25.4k]
  ------------------
 3590|  20.9k|            {
 3591|  20.9k|                const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3592|  20.9k|                                        text_screen_pos.y + buffer_offset.y);
 3593|  20.9k|                draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3594|  20.9k|                m_LineBuffer.clear();
 3595|  20.9k|            }
 3596|       |
 3597|  46.3k|            ++line_no;
 3598|  46.3k|        }
 3599|       |
 3600|       |        // Draw a tooltip on known identifiers/preprocessor symbols
 3601|  25.9k|        if (ImGui::IsMousePosValid())
  ------------------
  |  Branch (3601:13): [True: 6.35k, False: 19.5k]
  ------------------
 3602|  6.35k|        {
 3603|  6.35k|            std::string id = GetWordAt(ScreenPosToCoordinates(ImGui::GetMousePos()));
 3604|  6.35k|            if (!id.empty())
  ------------------
  |  Branch (3604:17): [True: 2.08k, False: 4.26k]
  ------------------
 3605|  2.08k|            {
 3606|       |                /*
 3607|       |                    auto it = m_LanguageDefinition.mIdentifiers.find(id);
 3608|       |                    if (it != m_LanguageDefinition.mIdentifiers.end())
 3609|       |                    {
 3610|       |                        ImGui::BeginTooltip();
 3611|       |                        ImGui::TextUnformatted(it->second.m_Declaration.c_str());
 3612|       |                        ImGui::EndTooltip();
 3613|       |                    }
 3614|       |                    else
 3615|       |                    {
 3616|       |                        auto pi = m_LanguageDefinition.mPreprocIdentifiers.find(id);
 3617|       |                        if (pi != m_LanguageDefinition.mPreprocIdentifiers.end())
 3618|       |                        {
 3619|       |                            ImGui::BeginTooltip();
 3620|       |                            ImGui::TextUnformatted(pi->second.m_Declaration.c_str());
 3621|       |                            ImGui::EndTooltip();
 3622|       |                        }
 3623|       |                    }
 3624|       |                    */
 3625|  2.08k|            }
 3626|  6.35k|        }
 3627|       |
 3628|  25.9k|        ImGui::Dummy(ImVec2((longest + 2), static_cast<float>(m_Lines.size()) * m_CharAdvance.y));
 3629|       |
 3630|  25.9k|        if (m_ScrollToCursor)
  ------------------
  |  Branch (3630:13): [True: 10.8k, False: 15.0k]
  ------------------
 3631|  10.8k|        {
 3632|  10.8k|            ScrollToCursor();
 3633|  10.8k|            ImGui::SetWindowFocus();
 3634|  10.8k|            m_ScrollToCursor = false;
 3635|  10.8k|        }
 3636|  25.9k|    }
_ZN6dlxemu10CodeEditor13ColorizeTokenERKN3dlx5TokenE:
 3639|   517k|    {
 3640|   517k|        PaletteIndex palette_index{PaletteIndex::Default};
 3641|       |
 3642|       |        // Determine palette color
 3643|   517k|        switch (token.GetType())
 3644|   517k|        {
 3645|    215|            case dlx::Token::Type::Comment:
  ------------------
  |  Branch (3645:13): [True: 215, False: 517k]
  ------------------
 3646|    215|                palette_index = PaletteIndex::Comment;
 3647|    215|                break;
 3648|     90|            case dlx::Token::Type::ImmediateInteger:
  ------------------
  |  Branch (3648:13): [True: 90, False: 517k]
  ------------------
 3649|    477|            case dlx::Token::Type::IntegerLiteral:
  ------------------
  |  Branch (3649:13): [True: 387, False: 517k]
  ------------------
 3650|    477|                palette_index = PaletteIndex::IntegerLiteral;
 3651|    477|                break;
 3652|  14.3k|            case dlx::Token::Type::OpCode:
  ------------------
  |  Branch (3652:13): [True: 14.3k, False: 503k]
  ------------------
 3653|  14.3k|                palette_index = PaletteIndex::OpCode;
 3654|  14.3k|                break;
 3655|    804|            case dlx::Token::Type::RegisterFloat:
  ------------------
  |  Branch (3655:13): [True: 804, False: 516k]
  ------------------
 3656|    823|            case dlx::Token::Type::RegisterInt:
  ------------------
  |  Branch (3656:13): [True: 19, False: 517k]
  ------------------
 3657|    823|            case dlx::Token::Type::RegisterStatus:
  ------------------
  |  Branch (3657:13): [True: 0, False: 517k]
  ------------------
 3658|    823|                palette_index = PaletteIndex::Register;
 3659|    823|                break;
 3660|  23.7k|            case dlx::Token::Type::NewLine:
  ------------------
  |  Branch (3660:13): [True: 23.7k, False: 493k]
  ------------------
 3661|  23.7k|                return;
 3662|   477k|            default:
  ------------------
  |  Branch (3662:13): [True: 477k, False: 39.6k]
  ------------------
 3663|   477k|                break;
 3664|   517k|        }
 3665|       |
 3666|   493k|        PHI_ASSERT(token.GetLineNumber() - 1u < m_Lines.size());
 3667|   493k|        Line& line = m_Lines[(token.GetLineNumber() - 1u).unsafe()];
 3668|       |
 3669|   493k|        for (phi::u64 index{token.GetColumn() - 1u};
 3670|  3.66M|             index < token.GetColumn() + token.GetLength() - 1u; ++index)
  ------------------
  |  Branch (3670:14): [True: 3.16M, False: 493k]
  ------------------
 3671|  3.16M|        {
 3672|  3.16M|            PHI_ASSERT(index < line.size());
 3673|  3.16M|            line[index.unsafe()].m_ColorIndex = palette_index;
 3674|  3.16M|        }
 3675|   493k|    }
_ZN6dlxemu10CodeEditor16ColorizeInternalEv:
 3678|  8.22k|    {
 3679|  8.22k|        const dlx::ParsedProgram& program = m_Emulator->GetProgram();
 3680|       |
 3681|  8.22k|        for (const dlx::Token& token : program.m_Tokens)
  ------------------
  |  Branch (3681:38): [True: 517k, False: 8.22k]
  ------------------
 3682|   517k|        {
 3683|   517k|            ColorizeToken(token);
 3684|   517k|        }
 3685|  8.22k|    }
_ZN6dlxemu10CodeEditor10ResetStateEv:
 3688|  1.35k|    {
 3689|  1.35k|        m_State.m_CursorPosition = Coordinates(0u, 0u);
 3690|  1.35k|        m_State.m_SelectionStart = Coordinates(0u, 0u);
 3691|  1.35k|        m_State.m_SelectionEnd   = Coordinates(0u, 0u);
 3692|       |
 3693|       |        // Clear breakpoints and markers
 3694|  1.35k|        ClearBreakPoints();
 3695|  1.35k|        ClearErrorMarkers();
 3696|  1.35k|    }
_ZN6dlxemu10CodeEditor21FixSelectionAfterMoveEN3phi7booleanENS0_11CoordinatesE:
 3699|  5.77k|    {
 3700|  5.77k|        if (select)
  ------------------
  |  Branch (3700:13): [True: 2.69k, False: 3.08k]
  ------------------
 3701|  2.69k|        {
 3702|  2.69k|            if (old_pos == m_InteractiveStart)
  ------------------
  |  Branch (3702:17): [True: 756, False: 1.94k]
  ------------------
 3703|    756|            {
 3704|    756|                m_InteractiveStart = m_State.m_CursorPosition;
 3705|    756|            }
 3706|  1.94k|            else if (old_pos == m_InteractiveEnd)
  ------------------
  |  Branch (3706:22): [True: 333, False: 1.60k]
  ------------------
 3707|    333|            {
 3708|    333|                m_InteractiveEnd = m_State.m_CursorPosition;
 3709|    333|            }
 3710|  1.60k|            else
 3711|  1.60k|            {
 3712|  1.60k|                m_InteractiveStart = m_State.m_CursorPosition;
 3713|  1.60k|                m_InteractiveEnd   = old_pos;
 3714|  1.60k|            }
 3715|  2.69k|        }
 3716|  3.08k|        else
 3717|  3.08k|        {
 3718|  3.08k|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
 3719|  3.08k|        }
 3720|       |
 3721|  5.77k|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
 3722|  5.77k|        EnsureCursorVisible();
 3723|  5.77k|    }
_ZNK6dlxemu10CodeEditor12GetTabSizeAtEN3phi7integerIjEE:
 3726|   169k|    {
 3727|   169k|        return static_cast<phi::uint_fast8_t>(m_TabSize.unsafe() -
 3728|   169k|                                              (column.unsafe() % m_TabSize.unsafe()));
 3729|   169k|    }
_ZNK6dlxemu10CodeEditor18GetPaletteForIndexENS0_12PaletteIndexE:
 3732|  2.28M|    {
 3733|  2.28M|        PHI_ASSERT(index != PaletteIndex::Max);
 3734|       |
 3735|  2.28M|        const phi::size_t int_value = static_cast<phi::size_t>(index);
 3736|  2.28M|        PHI_ASSERT(int_value < m_Palette.size());
 3737|       |
 3738|  2.28M|        return m_Palette[int_value];
 3739|  2.28M|    }
_ZN6dlxemu10CodeEditor18ComputeCharAdvanceEv:
 3742|  25.9k|    {
 3743|       |        // Compute m_CharAdvance regarding to scaled font size (Ctrl + mouse wheel)
 3744|  25.9k|        const float font_size =
 3745|  25.9k|                ImGui::GetFont()
 3746|  25.9k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#", nullptr, nullptr)
 3747|  25.9k|                        .x;
 3748|  25.9k|        m_CharAdvance = ImVec2(font_size, ImGui::GetTextLineHeightWithSpacing() * m_LineSpacing);
 3749|       |
 3750|  25.9k|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 3751|  25.9k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3752|  25.9k|    }
CodeEditor.cpp:_ZL19IsValidUTF8SequenceN3phi7integerIjEE:
  184|  53.2k|{
  185|  53.2k|    return !(character >= 0xdc00u && character < 0xe000u);
  ------------------
  |  Branch (185:14): [True: 3.77k, False: 49.4k]
  |  Branch (185:38): [True: 76, False: 3.70k]
  ------------------
  186|  53.2k|}
CodeEditor.cpp:_ZL13IsUTFSequenceh:
   93|   181k|{
   94|   181k|    return IsUTFSequence(static_cast<char>(character));
   95|   181k|}
CodeEditor.cpp:_ZL13IsUTFSequencec:
   88|   181k|{
   89|   181k|    return (character & 0xC0) == 0x80;
   90|   181k|}
CodeEditor.cpp:_ZL14UTF8CharLengthh:
  132|   127M|{
  133|   127M|    return UTF8CharLength(static_cast<char>(character));
  134|   127M|}
CodeEditor.cpp:_ZL14UTF8CharLengthc:
  102|   505M|{
  103|   505M|    if ((character & 0xFE) == 0xFC)
  ------------------
  |  Branch (103:9): [True: 0, False: 505M]
  ------------------
  104|      0|    {
  105|      0|        return 6_u8;
  106|      0|    }
  107|       |
  108|   505M|    if ((character & 0xFC) == 0xF8)
  ------------------
  |  Branch (108:9): [True: 0, False: 505M]
  ------------------
  109|      0|    {
  110|      0|        return 5_u8;
  111|      0|    }
  112|       |
  113|   505M|    if ((character & 0xF8) == 0xF0)
  ------------------
  |  Branch (113:9): [True: 274k, False: 505M]
  ------------------
  114|   274k|    {
  115|   274k|        return 4_u8;
  116|   274k|    }
  117|       |
  118|   505M|    if ((character & 0xF0) == 0xE0)
  ------------------
  |  Branch (118:9): [True: 80.1M, False: 425M]
  ------------------
  119|  80.1M|    {
  120|  80.1M|        return 3_u8;
  121|  80.1M|    }
  122|       |
  123|   425M|    if ((character & 0xE0) == 0xC0)
  ------------------
  |  Branch (123:9): [True: 130M, False: 294M]
  ------------------
  124|   130M|    {
  125|   130M|        return 2_u8;
  126|   130M|    }
  127|       |
  128|   294M|    return 1_u8;
  129|   425M|}
CodeEditor.cpp:_ZL16ImTextCharToUtf8RN3phi5arrayIcLm5EEENS_7integerIjEE:
  139|  21.5k|{
  140|  21.5k|    if (character < 0x80u)
  ------------------
  |  Branch (140:9): [True: 12.4k, False: 9.06k]
  ------------------
  141|  12.4k|    {
  142|  12.4k|        buffer[0u] = static_cast<char>(character.unsafe());
  143|  12.4k|        buffer[1u] = '\0';
  144|  12.4k|        return 1_u8;
  145|  12.4k|    }
  146|  9.06k|    if (character < 0x800u)
  ------------------
  |  Branch (146:9): [True: 2.17k, False: 6.88k]
  ------------------
  147|  2.17k|    {
  148|  2.17k|        buffer[0u] = static_cast<char>(0xc0 + (character.unsafe() >> 6));
  149|  2.17k|        buffer[1u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  150|  2.17k|        buffer[2u] = '\0';
  151|       |
  152|  2.17k|        return 2_u8;
  153|  2.17k|    }
  154|  6.88k|    if (character >= 0xdc00u && character < 0xe000u)
  ------------------
  |  Branch (154:9): [True: 1.85k, False: 5.03k]
  |  Branch (154:9): [True: 0, False: 6.88k]
  |  Branch (154:33): [True: 0, False: 1.85k]
  ------------------
  155|      0|    {
  156|      0|        buffer[0u] = '\0';
  157|      0|        return 0_u8;
  158|      0|    }
  159|       |
  160|  6.88k|    if (character >= 0xd800u && character < 0xdc00u)
  ------------------
  |  Branch (160:9): [True: 2.24k, False: 4.63k]
  |  Branch (160:9): [True: 397, False: 6.49k]
  |  Branch (160:33): [True: 397, False: 1.85k]
  ------------------
  161|    397|    {
  162|    397|        buffer[0u] = static_cast<char>(0xf0 + (character.unsafe() >> 18));
  163|    397|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 12) & 0x3f));
  164|    397|        buffer[2u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  165|    397|        buffer[3u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  166|    397|        buffer[4u] = '\0';
  167|       |
  168|    397|        return 4_u8;
  169|    397|    }
  170|       |    //else if (character < 0x10000)
  171|  6.49k|    {
  172|  6.49k|        PHI_ASSERT(character.unsafe() < 0x10000);
  173|       |
  174|  6.49k|        buffer[0u] = static_cast<char>(0xe0 + (character.unsafe() >> 12));
  175|  6.49k|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  176|  6.49k|        buffer[2u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  177|  6.49k|        buffer[3u] = '\0';
  178|       |
  179|  6.49k|        return 3_u8;
  180|  6.88k|    }
  181|  6.88k|}

_ZN6dlxemu8EmulatorC2Ev:
   43|  6.34k|    {}
_ZNK6dlxemu8Emulator10GetProgramEv:
  183|  8.22k|    {
  184|  8.22k|        return m_DLXProgram;
  185|  8.22k|    }
_ZN6dlxemu8Emulator12ParseProgramEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  188|  8.22k|    {
  189|  8.22k|        m_DLXProgram = dlx::Parser::Parse(source);
  190|       |
  191|  8.22k|        if (m_DLXProgram.m_ParseErrors.empty())
  ------------------
  |  Branch (191:13): [True: 790, False: 7.43k]
  ------------------
  192|    790|        {
  193|    790|            m_Processor.LoadProgram(m_DLXProgram);
  194|    790|        }
  195|  8.22k|    }
_ZNK6dlxemu8Emulator22GetExecutingLineNumberEv:
  227|  46.3k|    {
  228|  46.3k|        if (m_DLXProgram.IsValid() && !m_Processor.IsHalted() &&
  ------------------
  |  Branch (228:13): [True: 14, False: 46.3k]
  |  Branch (228:13): [True: 0, False: 46.3k]
  |  Branch (228:39): [True: 14, False: 0]
  ------------------
  229|  46.3k|            m_CurrentExecutionMode != ExecutionMode::None)
  ------------------
  |  Branch (229:13): [True: 0, False: 14]
  ------------------
  230|      0|        {
  231|      0|            PHI_ASSERT(m_Processor.GetProgramCounter() < m_DLXProgram.m_Instructions.size());
  232|       |
  233|      0|            const auto& current_instruction =
  234|      0|                    m_DLXProgram.m_Instructions.at(m_Processor.GetProgramCounter().unsafe());
  235|       |
  236|      0|            return current_instruction.GetSourceLine();
  237|      0|        }
  238|       |
  239|       |        // Not valid
  240|  46.3k|        return 0u;
  241|  46.3k|    }

_ZN6dlxemu12MemoryViewerC2EPNS_8EmulatorE:
   13|  6.34k|    {}

_ZN6dlxemu14RegisterViewerC2EPNS_8EmulatorE:
   19|  6.34k|    {}

_ZN6dlxemu6WindowD2Ev:
   38|  6.34k|    {
   39|  6.34k|        Shutdown();
   40|  6.34k|    }
_ZN6dlxemu6Window8ShutdownEv:
  108|  6.34k|    {
  109|  6.34k|        if (imgui_initialized)
  ------------------
  |  Branch (109:13): [True: 0, False: 6.34k]
  ------------------
  110|      0|        {
  111|      0|            ShutdownImGui();
  112|      0|        }
  113|       |
  114|  6.34k|        if (m_Window != nullptr)
  ------------------
  |  Branch (114:13): [True: 0, False: 6.34k]
  ------------------
  115|      0|        {
  116|      0|            glfwDestroyWindow(m_Window);
  117|      0|        }
  118|       |
  119|  6.34k|        if (glfw_initialized)
  ------------------
  |  Branch (119:13): [True: 0, False: 6.34k]
  ------------------
  120|      0|        {
  121|      0|            glfwTerminate();
  122|      0|        }
  123|  6.34k|    }

_ZNK3dlx15InstructionInfo15GetArgumentTypeEN3phi7integerIhEE:
  172|  3.75k|        {
  173|  3.75k|            PHI_ASSERT(index < 3u);
  174|       |
  175|  3.75k|            switch (index.unsafe())
  176|  3.75k|            {
  177|  1.73k|                case 0:
  ------------------
  |  Branch (177:17): [True: 1.73k, False: 2.01k]
  ------------------
  178|  1.73k|                    return m_Arg1Type;
  179|       |
  180|  1.00k|                case 1:
  ------------------
  |  Branch (180:17): [True: 1.00k, False: 2.74k]
  ------------------
  181|  1.00k|                    return m_Arg2Type;
  182|       |
  183|  1.00k|                case 2:
  ------------------
  |  Branch (183:17): [True: 1.00k, False: 2.74k]
  ------------------
  184|  1.00k|                    return m_Arg3Type;
  185|       |
  186|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  187|      0|                default:
  ------------------
  |  Branch (187:17): [True: 0, False: 3.75k]
  ------------------
  188|      0|                    PHI_ASSERT_NOT_REACHED();
  189|      0|                    return m_Arg1Type;
  190|  3.75k|#endif
  191|  3.75k|            }
  192|  3.75k|        }
_ZNK3dlx15InstructionInfo28GetNumberOfRequiredArgumentsEv:
  198|  1.00k|        {
  199|  1.00k|            phi::u8 number_of_argument_required = static_cast<phi::uint8_t>(0u);
  200|       |
  201|       |            // Count the number of argument we need
  202|  1.00k|            if (m_Arg1Type != ArgumentType::None)
  ------------------
  |  Branch (202:17): [True: 1.00k, False: 1]
  ------------------
  203|  1.00k|            {
  204|  1.00k|                number_of_argument_required += static_cast<phi::uint8_t>(1u);
  205|  1.00k|            }
  206|  1.00k|            if (m_Arg2Type != ArgumentType::None)
  ------------------
  |  Branch (206:17): [True: 177, False: 832]
  ------------------
  207|    177|            {
  208|    177|                number_of_argument_required += static_cast<phi::uint8_t>(1u);
  209|    177|            }
  210|  1.00k|            if (m_Arg3Type != ArgumentType::None)
  ------------------
  |  Branch (210:17): [True: 78, False: 931]
  ------------------
  211|     78|            {
  212|     78|                number_of_argument_required += static_cast<phi::uint8_t>(1u);
  213|     78|            }
  214|       |
  215|  1.00k|            return number_of_argument_required;
  216|  1.00k|        }
_ZNK3dlx15InstructionInfo11GetExecutorEv:
  224|  1.00k|        {
  225|  1.00k|            return m_Executor;
  226|  1.00k|        }
_ZN3dlxanENS_12ArgumentTypeES0_:
   37|    549|    {
   38|    549|        using underlying_t = phi::underlying_type_t<ArgumentType>;
   39|       |
   40|    549|        return static_cast<ArgumentType>(static_cast<underlying_t>(lhs) &
   41|    549|                                         static_cast<underlying_t>(rhs));
   42|    549|    }
_ZN3dlx20ArgumentTypeIncludesENS_12ArgumentTypeES0_:
   54|    549|    {
   55|    549|        using underlying_t = std::underlying_type_t<ArgumentType>;
   56|       |
   57|    549|        return static_cast<underlying_t>(type & test) != 0;
   58|    549|    }
_ZN3dlx9enum_nameINS_12ArgumentTypeEEEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEET_:
   66|    120|    {
   67|    120|        switch (phi::to_underlying(value))
   68|    120|        {
   69|      0|#define DLX_ENUM_ARGUMENT_TYPE_IMPL(name, enum_value)                                              \
   70|      0|    case enum_value:                                                                               \
   71|      0|        return #name;
   72|       |
   73|      0|            DLX_ENUM_ARGUMENT_TYPE
  ------------------
  |  |   21|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(Unknown, 0)                                                        \
  |  |  ------------------
  |  |  |  |   70|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 0, False: 120]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|        return #name;
  |  |  ------------------
  |  |   22|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(None, 1)                                                           \
  |  |  ------------------
  |  |  |  |   70|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 0, False: 120]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|        return #name;
  |  |  ------------------
  |  |   23|     22|    DLX_ENUM_ARGUMENT_TYPE_IMPL(IntRegister, 2)                                                    \
  |  |  ------------------
  |  |  |  |   70|     22|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 22, False: 98]
  |  |  |  |  ------------------
  |  |  |  |   71|     22|        return #name;
  |  |  ------------------
  |  |   24|     22|    DLX_ENUM_ARGUMENT_TYPE_IMPL(FloatRegister, 4)                                                  \
  |  |  ------------------
  |  |  |  |   70|     11|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 11, False: 109]
  |  |  |  |  ------------------
  |  |  |  |   71|     11|        return #name;
  |  |  ------------------
  |  |   25|     11|    DLX_ENUM_ARGUMENT_TYPE_IMPL(ImmediateInteger, 8)                                               \
  |  |  ------------------
  |  |  |  |   70|      6|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 6, False: 114]
  |  |  |  |  ------------------
  |  |  |  |   71|      6|        return #name;
  |  |  ------------------
  |  |   26|     60|    DLX_ENUM_ARGUMENT_TYPE_IMPL(Label, 16)                                                         \
  |  |  ------------------
  |  |  |  |   70|     60|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 60, False: 60]
  |  |  |  |  ------------------
  |  |  |  |   71|     60|        return #name;
  |  |  ------------------
  |  |   27|     60|    DLX_ENUM_ARGUMENT_TYPE_IMPL(AddressDisplacement, 32)
  |  |  ------------------
  |  |  |  |   70|      1|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 1, False: 119]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|        return #name;
  |  |  ------------------
  ------------------
   74|       |
   75|      0|#undef DLX_ENUM_ARGUMENT_TYPE_IMPL
   76|       |
   77|       |            // Explicitly handle the combine cases
   78|     20|            case phi::to_underlying(ArgumentType::ImmediateInteger |
  ------------------
  |  Branch (78:13): [True: 20, False: 100]
  ------------------
   79|     20|                                    ArgumentType::AddressDisplacement):
   80|     20|                return "ImmediateInteger/AddressDisplacement";
   81|       |
   82|      0|            default:
  ------------------
  |  Branch (82:13): [True: 0, False: 120]
  ------------------
   83|      0|                PHI_ASSERT_NOT_REACHED();
   84|    120|        }
   85|    120|    }

_ZN3dlx11MemoryBlock10MemoryByteC2Ev:
   17|  6.34M|            {}

_ZN3dlx20IsReservedIdentifierEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   30|  13.9k|    {
   31|  13.9k|        if (StringToIntRegister(token) != IntRegisterID::None)
  ------------------
  |  Branch (31:13): [True: 64, False: 13.8k]
  ------------------
   32|     64|        {
   33|     64|            return true;
   34|     64|        }
   35|       |
   36|  13.8k|        if (StringToFloatRegister(token) != FloatRegisterID::None)
  ------------------
  |  Branch (36:13): [True: 159, False: 13.7k]
  ------------------
   37|    159|        {
   38|    159|            return true;
   39|    159|        }
   40|       |
   41|  13.7k|        if (StringToOpCode(token) != OpCode::NONE)
  ------------------
  |  Branch (41:13): [True: 1.84k, False: 11.8k]
  ------------------
   42|  1.84k|        {
   43|  1.84k|            return true;
   44|  1.84k|        }
   45|       |
   46|  11.8k|        if (IsFPSR(token))
  ------------------
  |  Branch (46:13): [True: 0, False: 11.8k]
  ------------------
   47|      0|        {
   48|      0|            return true;
   49|      0|        }
   50|       |
   51|  11.8k|        return false;
   52|  11.8k|    }
_ZN3dlx17IsValidIdentifierEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   55|  11.8k|    {
   56|  11.8k|        if (token.is_empty())
  ------------------
  |  Branch (56:13): [True: 0, False: 11.8k]
  ------------------
   57|      0|        {
   58|      0|            return false;
   59|      0|        }
   60|       |
   61|  11.8k|        const char first_char = token.at(0u);
   62|       |
   63|  11.8k|        if (token.length() == 1u)
  ------------------
  |  Branch (63:13): [True: 4.25k, False: 7.63k]
  ------------------
   64|  4.25k|        {
   65|  4.25k|            return phi::is_alpha(first_char);
   66|  4.25k|        }
   67|       |
   68|  7.63k|        phi::boolean just_under_scores = (first_char == '_');
   69|  7.63k|        if (!phi::is_alpha(first_char) && (first_char != '_'))
  ------------------
  |  Branch (69:13): [True: 1.42k, False: 6.21k]
  |  Branch (69:13): [True: 1.41k, False: 6.22k]
  |  Branch (69:43): [True: 1.41k, False: 8]
  ------------------
   70|  1.41k|        {
   71|  1.41k|            return false;
   72|  1.41k|        }
   73|       |
   74|  72.8k|        for (phi::size_t index{1u}; index < token.length(); ++index)
  ------------------
  |  Branch (74:37): [True: 69.1k, False: 3.70k]
  ------------------
   75|  69.1k|        {
   76|  69.1k|            const char c{token.at(index)};
   77|       |
   78|  69.1k|            if (phi::is_alpha_numeric(c))
  ------------------
  |  Branch (78:17): [True: 66.5k, False: 2.55k]
  ------------------
   79|  66.5k|            {
   80|  66.5k|                just_under_scores = false;
   81|  66.5k|            }
   82|  2.55k|            else if (c == '_')
  ------------------
  |  Branch (82:22): [True: 31, False: 2.52k]
  ------------------
   83|     31|            {
   84|     31|                continue;
   85|     31|            }
   86|  2.52k|            else
   87|  2.52k|            {
   88|  2.52k|                return false;
   89|  2.52k|            }
   90|  69.1k|        }
   91|       |
   92|  3.70k|        return !just_under_scores;
   93|  6.22k|    }
_ZN3dlx11ParseNumberEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   98|   342k|    {
   99|   342k|        if (token.is_empty())
  ------------------
  |  Branch (99:13): [True: 0, False: 342k]
  ------------------
  100|      0|        {
  101|      0|            return {};
  102|      0|        }
  103|       |
  104|   342k|        if (token.length() == 1u)
  ------------------
  |  Branch (104:13): [True: 18.3k, False: 323k]
  ------------------
  105|  18.3k|        {
  106|  18.3k|            if (phi::is_digit(token.at(0u)))
  ------------------
  |  Branch (106:17): [True: 58, False: 18.2k]
  ------------------
  107|     58|            {
  108|     58|                return static_cast<phi::int16_t>(token.at(0u) - '0');
  109|     58|            }
  110|       |
  111|  18.2k|            return {};
  112|  18.3k|        }
  113|       |
  114|       |        // Disallow trailing separators
  115|   323k|        if (token.at(token.length() - 1u) == '\'')
  ------------------
  |  Branch (115:13): [True: 56, False: 323k]
  ------------------
  116|     56|        {
  117|     56|            return {};
  118|     56|        }
  119|       |
  120|   323k|        phi::int32_t number{0};
  121|   323k|        phi::boolean is_negative{false};
  122|   323k|        phi::boolean starts_with_zero{false};
  123|   323k|        phi::boolean parsing_binary{false};
  124|   323k|        phi::boolean parsing_octal{false};
  125|   323k|        phi::boolean parsing_hexadecimal{false};
  126|   323k|        phi::boolean parsed_something{false};
  127|   323k|        phi::boolean parsed_separator{false};
  128|       |
  129|       |        // TODO: Move x'th character checks out of the for loop
  130|       |
  131|   326k|        for (phi::size_t index{0u}; index < token.length(); ++index)
  ------------------
  |  Branch (131:37): [True: 325k, False: 554]
  ------------------
  132|   325k|        {
  133|   325k|            const char c{token.at(index)};
  134|       |
  135|       |            // First character
  136|   325k|            if (index == 0u)
  ------------------
  |  Branch (136:17): [True: 323k, False: 1.82k]
  ------------------
  137|   323k|            {
  138|   323k|                if (c == '+')
  ------------------
  |  Branch (138:21): [True: 4, False: 323k]
  ------------------
  139|      4|                {
  140|      4|                    continue;
  141|      4|                }
  142|       |
  143|   323k|                if (c == '-')
  ------------------
  |  Branch (143:21): [True: 65, False: 323k]
  ------------------
  144|     65|                {
  145|     65|                    is_negative = true;
  146|     65|                    continue;
  147|     65|                }
  148|       |
  149|   323k|                if (c == '0')
  ------------------
  |  Branch (149:21): [True: 432, False: 323k]
  ------------------
  150|    432|                {
  151|    432|                    starts_with_zero = true;
  152|    432|                    continue;
  153|    432|                }
  154|       |
  155|   323k|                if (c == '\'')
  ------------------
  |  Branch (155:21): [True: 16, False: 323k]
  ------------------
  156|     16|                {
  157|     16|                    return {};
  158|     16|                }
  159|   323k|            }
  160|       |
  161|       |            // Second character
  162|   325k|            if (index == 1u)
  ------------------
  |  Branch (162:17): [True: 897, False: 324k]
  ------------------
  163|    897|            {
  164|    897|                if (starts_with_zero)
  ------------------
  |  Branch (164:21): [True: 432, False: 465]
  ------------------
  165|    432|                {
  166|       |                    // Binary
  167|    432|                    if (c == 'b' || c == 'B')
  ------------------
  |  Branch (167:25): [True: 19, False: 413]
  |  Branch (167:37): [True: 172, False: 241]
  ------------------
  168|    191|                    {
  169|    191|                        parsing_binary = true;
  170|    191|                        continue;
  171|    191|                    }
  172|       |
  173|       |                    // Hexadecimal
  174|    241|                    if (c == 'x' || c == 'X')
  ------------------
  |  Branch (174:25): [True: 16, False: 225]
  |  Branch (174:37): [True: 31, False: 194]
  ------------------
  175|     47|                    {
  176|     47|                        parsing_hexadecimal = true;
  177|     47|                        continue;
  178|     47|                    }
  179|       |
  180|       |                    // Octal
  181|    194|                    parsing_octal = true;
  182|    194|                }
  183|    897|            }
  184|       |
  185|       |            // Handle separators
  186|   324k|            if (c == '\'')
  ------------------
  |  Branch (186:17): [True: 14, False: 324k]
  ------------------
  187|     14|            {
  188|     14|                if (parsed_separator)
  ------------------
  |  Branch (188:21): [True: 1, False: 13]
  ------------------
  189|      1|                {
  190|      1|                    return {};
  191|      1|                }
  192|       |
  193|     13|                parsed_separator = true;
  194|     13|                continue;
  195|     14|            }
  196|       |
  197|       |            // Check for over/underflow
  198|   324k|            if (is_negative && (-number < std::numeric_limits<phi::int16_t>::min()))
  ------------------
  |  Branch (198:17): [True: 81, False: 324k]
  |  Branch (198:32): [True: 0, False: 81]
  ------------------
  199|      0|            {
  200|       |                // Would underflow
  201|      0|                return {};
  202|      0|            }
  203|   324k|            if (!is_negative && (number > std::numeric_limits<phi::int16_t>::max()))
  ------------------
  |  Branch (203:17): [True: 324k, False: 81]
  |  Branch (203:17): [True: 96, False: 324k]
  |  Branch (203:33): [True: 96, False: 324k]
  ------------------
  204|     96|            {
  205|       |                // Would overflow
  206|     96|                return {};
  207|     96|            }
  208|       |
  209|   324k|            parsed_separator = false;
  210|   324k|            parsed_something = true;
  211|       |
  212|   324k|            if (parsing_binary)
  ------------------
  |  Branch (212:17): [True: 79, False: 324k]
  ------------------
  213|     79|            {
  214|     79|                if (!phi::is_binary_digit(c))
  ------------------
  |  Branch (214:21): [True: 38, False: 41]
  ------------------
  215|     38|                {
  216|     38|                    return {};
  217|     38|                }
  218|       |
  219|     41|                number <<= 1;
  220|     41|                number |= (c - '0');
  221|     41|            }
  222|   324k|            else if (parsing_octal)
  ------------------
  |  Branch (222:22): [True: 789, False: 323k]
  ------------------
  223|    789|            {
  224|    789|                if (!phi::is_octal_digit(c))
  ------------------
  |  Branch (224:21): [True: 34, False: 755]
  ------------------
  225|     34|                {
  226|     34|                    return {};
  227|     34|                }
  228|       |
  229|    755|                number <<= 3;
  230|    755|                number |= (c - '0');
  231|    755|            }
  232|   323k|            else if (parsing_hexadecimal)
  ------------------
  |  Branch (232:22): [True: 48, False: 323k]
  ------------------
  233|     48|            {
  234|     48|                if (!phi::is_hex_digit(c))
  ------------------
  |  Branch (234:21): [True: 25, False: 23]
  ------------------
  235|     25|                {
  236|     25|                    return {};
  237|     25|                }
  238|       |
  239|     23|                number <<= 4;
  240|     23|                number |= phi::hex_digit_value(c).unsafe();
  241|     23|            }
  242|   323k|            else
  243|   323k|            {
  244|   323k|                if (!phi::is_digit(c))
  ------------------
  |  Branch (244:21): [True: 323k, False: 823]
  ------------------
  245|   323k|                {
  246|   323k|                    return {};
  247|   323k|                }
  248|       |
  249|       |                // Disallow leading zeros
  250|    823|                if (number == 0 && c == '0')
  ------------------
  |  Branch (250:21): [True: 450, False: 373]
  |  Branch (250:36): [True: 15, False: 435]
  ------------------
  251|     15|                {
  252|     15|                    return {};
  253|     15|                }
  254|       |
  255|    808|                number *= 10;
  256|    808|                number += (c - '0');
  257|    808|            }
  258|   324k|        }
  259|       |
  260|    554|        if (parsed_something)
  ------------------
  |  Branch (260:13): [True: 397, False: 157]
  ------------------
  261|    397|        {
  262|       |            // Check for over/underflow
  263|    397|            if (is_negative && (-number < std::numeric_limits<phi::int16_t>::min()))
  ------------------
  |  Branch (263:17): [True: 38, False: 359]
  |  Branch (263:32): [True: 0, False: 38]
  ------------------
  264|      0|            {
  265|       |                // Would underflow
  266|      0|                return {};
  267|      0|            }
  268|    397|            if (!is_negative && (number > std::numeric_limits<phi::int16_t>::max()))
  ------------------
  |  Branch (268:17): [True: 359, False: 38]
  |  Branch (268:17): [True: 5, False: 392]
  |  Branch (268:33): [True: 5, False: 354]
  ------------------
  269|      5|            {
  270|       |                // Would overflow
  271|      5|                return {};
  272|      5|            }
  273|       |
  274|    392|            if (is_negative)
  ------------------
  |  Branch (274:17): [True: 38, False: 354]
  ------------------
  275|     38|            {
  276|     38|                return static_cast<phi::int16_t>(-number);
  277|     38|            }
  278|       |
  279|    354|            return static_cast<phi::int16_t>(number);
  280|    392|        }
  281|       |
  282|    157|        return {};
  283|    554|    }

_ZN3dlx9enum_nameINS_5Token4TypeEEEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEET_:
   85|   576k|    {
   86|   576k|        switch (value)
   87|   576k|        {
   88|      0|#define DLX_ENUM_TOKEN_TYPE_IMPL(name)                                                             \
   89|      0|    case Token::Type::name:                                                                        \
   90|      0|        return #name;
   91|       |
   92|      0|            DLX_ENUM_TOKEN_TYPE
  ------------------
  |  |   13|      4|    DLX_ENUM_TOKEN_TYPE_IMPL(Comment)                                                              \
  |  |  ------------------
  |  |  |  |   89|      4|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 4, False: 576k]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|        return #name;
  |  |  ------------------
  |  |   14|    163|    DLX_ENUM_TOKEN_TYPE_IMPL(OpCode)                                                               \
  |  |  ------------------
  |  |  |  |   89|    163|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 163, False: 576k]
  |  |  |  |  ------------------
  |  |  |  |   90|    163|        return #name;
  |  |  ------------------
  |  |   15|   136k|    DLX_ENUM_TOKEN_TYPE_IMPL(LabelIdentifier)                                                      \
  |  |  ------------------
  |  |  |  |   89|   136k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 136k, False: 440k]
  |  |  |  |  ------------------
  |  |  |  |   90|   136k|        return #name;
  |  |  ------------------
  |  |   16|   136k|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterInt)                                                          \
  |  |  ------------------
  |  |  |  |   89|     19|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 19, False: 576k]
  |  |  |  |  ------------------
  |  |  |  |   90|     19|        return #name;
  |  |  ------------------
  |  |   17|    804|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterFloat)                                                        \
  |  |  ------------------
  |  |  |  |   89|    804|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 804, False: 575k]
  |  |  |  |  ------------------
  |  |  |  |   90|    804|        return #name;
  |  |  ------------------
  |  |   18|    804|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterStatus)                                                       \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 576k]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   19|   146k|    DLX_ENUM_TOKEN_TYPE_IMPL(Comma)                                                                \
  |  |  ------------------
  |  |  |  |   89|   146k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 146k, False: 429k]
  |  |  |  |  ------------------
  |  |  |  |   90|   146k|        return #name;
  |  |  ------------------
  |  |   20|   146k|    DLX_ENUM_TOKEN_TYPE_IMPL(Colon)                                                                \
  |  |  ------------------
  |  |  |  |   89|  2.84k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 2.84k, False: 573k]
  |  |  |  |  ------------------
  |  |  |  |   90|  2.84k|        return #name;
  |  |  ------------------
  |  |   21|  2.84k|    DLX_ENUM_TOKEN_TYPE_IMPL(OpenBracket)                                                          \
  |  |  ------------------
  |  |  |  |   89|    350|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 350, False: 576k]
  |  |  |  |  ------------------
  |  |  |  |   90|    350|        return #name;
  |  |  ------------------
  |  |   22|    891|    DLX_ENUM_TOKEN_TYPE_IMPL(ClosingBracket)                                                       \
  |  |  ------------------
  |  |  |  |   89|    891|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 891, False: 575k]
  |  |  |  |  ------------------
  |  |  |  |   90|    891|        return #name;
  |  |  ------------------
  |  |   23|   154k|    DLX_ENUM_TOKEN_TYPE_IMPL(NewLine)                                                              \
  |  |  ------------------
  |  |  |  |   89|   154k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 154k, False: 422k]
  |  |  |  |  ------------------
  |  |  |  |   90|   154k|        return #name;
  |  |  ------------------
  |  |   24|   154k|    DLX_ENUM_TOKEN_TYPE_IMPL(ImmediateInteger)                                                     \
  |  |  ------------------
  |  |  |  |   89|     84|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 84, False: 576k]
  |  |  |  |  ------------------
  |  |  |  |   90|     84|        return #name;
  |  |  ------------------
  |  |   25|    386|    DLX_ENUM_TOKEN_TYPE_IMPL(IntegerLiteral)                                                       \
  |  |  ------------------
  |  |  |  |   89|    386|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 386, False: 576k]
  |  |  |  |  ------------------
  |  |  |  |   90|    386|        return #name;
  |  |  ------------------
  |  |   26|   134k|    DLX_ENUM_TOKEN_TYPE_IMPL(Unknown)
  |  |  ------------------
  |  |  |  |   89|   134k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 134k, False: 442k]
  |  |  |  |  ------------------
  |  |  |  |   90|   134k|        return #name;
  |  |  ------------------
  ------------------
   93|       |
   94|      0|#undef DLX_ENUM_TOKEN_TYPE_IMPL
   95|       |
   96|      0|            default:
  ------------------
  |  Branch (96:13): [True: 0, False: 576k]
  ------------------
   97|      0|                PHI_ASSERT_NOT_REACHED();
   98|   576k|        }
   99|   576k|    }

Parser.cpp:_ZNK3dlx11TokenStream19find_first_token_ifIZNS_6Parser5ParseERS0_E3$_0EEPKNS_5TokenET_:
   58|  4.79k|        {
   59|       |#if defined(PHI_DEBUG)
   60|       |            PHI_ASSERT(m_Finalized);
   61|       |#endif
   62|       |
   63|  4.79k|            for (const Token& token : m_Tokens)
  ------------------
  |  Branch (63:37): [True: 11.1k, False: 0]
  ------------------
   64|  11.1k|            {
   65|  11.1k|                if (pred(token))
  ------------------
  |  Branch (65:21): [True: 4.79k, False: 6.39k]
  ------------------
   66|  4.79k|                {
   67|  4.79k|                    return &token;
   68|  4.79k|                }
   69|  11.1k|            }
   70|       |
   71|      0|            return nullptr;
   72|  4.79k|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5Token4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEERNS4_7integerImEESC_EEEvDpOT_:
   24|  26.6k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finalized);
   27|       |#endif
   28|       |
   29|  26.6k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|  26.6k|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5TokenEEEEvDpOT_:
   24|   342k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finalized);
   27|       |#endif
   28|       |
   29|   342k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|   342k|        }
_ZN3dlx11TokenStream12emplace_backIJRNS_5Token4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEERNS5_7integerImEESD_EEEvDpOT_:
   24|   148k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finalized);
   27|       |#endif
   28|       |
   29|   148k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|   148k|        }

_ZN3dlx11InstructionC2ERKNS_15InstructionInfoEN3phi7integerImEE:
   16|  1.00k|    {}
_ZN3dlx11Instruction11SetArgumentEN3phi7integerIhEENS_19InstructionArgumentE:
   21|    127|    {
   22|    127|        PHI_ASSERT(argument_number < 3u);
   23|       |
   24|    127|        switch (argument_number.unsafe())
   25|    127|        {
   26|    127|            case 0u:
  ------------------
  |  Branch (26:13): [True: 127, False: 0]
  ------------------
   27|    127|                m_Arg1 = argument;
   28|    127|                break;
   29|      0|            case 1u:
  ------------------
  |  Branch (29:13): [True: 0, False: 127]
  ------------------
   30|      0|                m_Arg2 = argument;
   31|      0|                break;
   32|      0|            case 2u:
  ------------------
  |  Branch (32:13): [True: 0, False: 127]
  ------------------
   33|      0|                m_Arg3 = argument;
   34|      0|                break;
   35|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
   36|      0|            default:
  ------------------
  |  Branch (36:13): [True: 0, False: 127]
  ------------------
   37|      0|                PHI_ASSERT_NOT_REACHED();
   38|    127|#endif
   39|    127|        }
   40|    127|    }

_ZN3dlx19InstructionArgumentC2Ev:
   21|  3.15k|    {}
_ZN3dlx33ConstructInstructionArgumentLabelEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  200|    127|    {
  201|    127|        InstructionArgument arg;
  202|    127|        arg.m_Type           = ArgumentType::Label;
  203|    127|        arg.label.label_name = label_name;
  204|    127|        return arg;
  205|    127|    }

_ZN3dlx21LookUpInstructionInfoENS_6OpCodeE:
  449|  1.00k|    {
  450|  1.00k|        return instruction_table.at(static_cast<phi::size_t>(instruction));
  451|  1.00k|    }

_ZN3dlx11IntRegisterC2Ev:
   12|   203k|    {}
_ZN3dlx11IntRegister11SetReadOnlyEN3phi7booleanE:
   40|  6.34k|    {
   41|  6.34k|        m_IsReadOnly = read_only;
   42|  6.34k|    }

_ZN3dlx11MemoryBlockC2EN3phi7integerImEES3_:
   12|  6.34k|    {
   13|  6.34k|        m_Values.resize(starting_size.unsafe());
   14|  6.34k|    }

_ZN3dlx14StringToOpCodeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   21|   354k|    {
   22|   354k|        switch (token.length().unsafe())
   23|   354k|        {
   24|       |            // 1 character OpCodes
   25|  22.5k|            case 1: {
  ------------------
  |  Branch (25:13): [True: 22.5k, False: 332k]
  ------------------
   26|  22.5k|                const char c1 = token[0u];
   27|       |
   28|  22.5k|                if (ice(c1, 'J'))
  ------------------
  |  Branch (28:21): [True: 14.1k, False: 8.43k]
  ------------------
   29|  14.1k|                {
   30|  14.1k|                    return OpCode::J;
   31|  14.1k|                }
   32|  8.43k|                break;
   33|  22.5k|            }
   34|       |
   35|       |            // 2 character OpCodes
   36|  11.2k|            case 2: {
  ------------------
  |  Branch (36:13): [True: 11.2k, False: 343k]
  ------------------
   37|  11.2k|                const char c1 = token[0u];
   38|  11.2k|                const char c2 = token[1u];
   39|       |
   40|  11.2k|                switch (c1)
  ------------------
  |  Branch (40:25): [True: 5.56k, False: 5.72k]
  ------------------
   41|  11.2k|                {
   42|  1.28k|                    case 'J':
  ------------------
  |  Branch (42:21): [True: 1.28k, False: 10.0k]
  ------------------
   43|  1.87k|                    case 'j':
  ------------------
  |  Branch (43:21): [True: 587, False: 10.7k]
  ------------------
   44|  1.87k|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (44:29): [True: 25, False: 1.84k]
  ------------------
   45|     25|                        {
   46|     25|                            return OpCode::JR;
   47|     25|                        }
   48|  1.84k|                        break;
   49|       |
   50|  1.84k|                    case 'L':
  ------------------
  |  Branch (50:21): [True: 125, False: 11.1k]
  ------------------
   51|  2.45k|                    case 'l':
  ------------------
  |  Branch (51:21): [True: 2.33k, False: 8.95k]
  ------------------
   52|  2.45k|                        switch (c2)
  ------------------
  |  Branch (52:33): [True: 1.22k, False: 1.23k]
  ------------------
   53|  2.45k|                        {
   54|     47|                            case 'B':
  ------------------
  |  Branch (54:29): [True: 47, False: 2.40k]
  ------------------
   55|     53|                            case 'b':
  ------------------
  |  Branch (55:29): [True: 6, False: 2.45k]
  ------------------
   56|     53|                                return OpCode::LB;
   57|     33|                            case 'D':
  ------------------
  |  Branch (57:29): [True: 33, False: 2.42k]
  ------------------
   58|    725|                            case 'd':
  ------------------
  |  Branch (58:29): [True: 692, False: 1.76k]
  ------------------
   59|    725|                                return OpCode::LD;
   60|      6|                            case 'F':
  ------------------
  |  Branch (60:29): [True: 6, False: 2.45k]
  ------------------
   61|     12|                            case 'f':
  ------------------
  |  Branch (61:29): [True: 6, False: 2.45k]
  ------------------
   62|     12|                                return OpCode::LF;
   63|     12|                            case 'H':
  ------------------
  |  Branch (63:29): [True: 12, False: 2.44k]
  ------------------
   64|     15|                            case 'h':
  ------------------
  |  Branch (64:29): [True: 3, False: 2.45k]
  ------------------
   65|     15|                                return OpCode::LH;
   66|    415|                            case 'W':
  ------------------
  |  Branch (66:29): [True: 415, False: 2.04k]
  ------------------
   67|    426|                            case 'w':
  ------------------
  |  Branch (67:29): [True: 11, False: 2.44k]
  ------------------
   68|    426|                                return OpCode::LW;
   69|  2.45k|                        }
   70|  1.22k|                        break;
   71|  1.22k|                    case 'O':
  ------------------
  |  Branch (71:21): [True: 8, False: 11.2k]
  ------------------
   72|    143|                    case 'o':
  ------------------
  |  Branch (72:21): [True: 135, False: 11.1k]
  ------------------
   73|    143|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (73:29): [True: 9, False: 134]
  ------------------
   74|      9|                        {
   75|      9|                            return OpCode::OR;
   76|      9|                        }
   77|    134|                        break;
   78|    134|                    case 'S':
  ------------------
  |  Branch (78:21): [True: 54, False: 11.2k]
  ------------------
   79|  1.25k|                    case 's':
  ------------------
  |  Branch (79:21): [True: 1.20k, False: 10.0k]
  ------------------
   80|  1.25k|                        switch (c2)
  ------------------
  |  Branch (80:33): [True: 790, False: 465]
  ------------------
   81|  1.25k|                        {
   82|      6|                            case 'B':
  ------------------
  |  Branch (82:29): [True: 6, False: 1.24k]
  ------------------
   83|     89|                            case 'b':
  ------------------
  |  Branch (83:29): [True: 83, False: 1.17k]
  ------------------
   84|     89|                                return OpCode::SB;
   85|     11|                            case 'D':
  ------------------
  |  Branch (85:29): [True: 11, False: 1.24k]
  ------------------
   86|    243|                            case 'd':
  ------------------
  |  Branch (86:29): [True: 232, False: 1.02k]
  ------------------
   87|    243|                                return OpCode::SD;
   88|     88|                            case 'F':
  ------------------
  |  Branch (88:29): [True: 88, False: 1.16k]
  ------------------
   89|     89|                            case 'f':
  ------------------
  |  Branch (89:29): [True: 1, False: 1.25k]
  ------------------
   90|     89|                                return OpCode::SF;
   91|      3|                            case 'H':
  ------------------
  |  Branch (91:29): [True: 3, False: 1.25k]
  ------------------
   92|     22|                            case 'h':
  ------------------
  |  Branch (92:29): [True: 19, False: 1.23k]
  ------------------
   93|     22|                                return OpCode::SH;
   94|      6|                            case 'w':
  ------------------
  |  Branch (94:29): [True: 6, False: 1.24k]
  ------------------
   95|     22|                            case 'W':
  ------------------
  |  Branch (95:29): [True: 16, False: 1.23k]
  ------------------
   96|     22|                                return OpCode::SW;
   97|  1.25k|                        }
   98|    790|                        break;
   99|  11.2k|                }
  100|  9.55k|                break;
  101|  11.2k|            }
  102|       |
  103|       |            // 3 character OpCodes
  104|  98.9k|            case 3: {
  ------------------
  |  Branch (104:13): [True: 98.9k, False: 255k]
  ------------------
  105|  98.9k|                const char c1 = token[0u];
  106|  98.9k|                const char c2 = token[1u];
  107|  98.9k|                const char c3 = token[2u];
  108|       |
  109|  98.9k|                switch (c1)
  ------------------
  |  Branch (109:25): [True: 76.7k, False: 22.1k]
  ------------------
  110|  98.9k|                {
  111|    460|                    case 'A':
  ------------------
  |  Branch (111:21): [True: 460, False: 98.4k]
  ------------------
  112|    474|                    case 'a':
  ------------------
  |  Branch (112:21): [True: 14, False: 98.9k]
  ------------------
  113|    474|                        if (ice(c2, 'D') && ice(c3, 'D'))
  ------------------
  |  Branch (113:29): [True: 237, False: 237]
  |  Branch (113:29): [True: 99, False: 375]
  |  Branch (113:45): [True: 99, False: 138]
  ------------------
  114|     99|                        {
  115|     99|                            return OpCode::ADD;
  116|     99|                        }
  117|    375|                        else if (ice(c2, 'N') && ice(c3, 'D'))
  ------------------
  |  Branch (117:34): [True: 134, False: 241]
  |  Branch (117:34): [True: 6, False: 369]
  |  Branch (117:50): [True: 6, False: 128]
  ------------------
  118|      6|                        {
  119|      6|                            return OpCode::AND;
  120|      6|                        }
  121|    369|                        break;
  122|       |
  123|    369|                    case 'D':
  ------------------
  |  Branch (123:21): [True: 163, False: 98.7k]
  ------------------
  124|    225|                    case 'd':
  ------------------
  |  Branch (124:21): [True: 62, False: 98.8k]
  ------------------
  125|    225|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (125:29): [True: 15, False: 210]
  |  Branch (125:29): [True: 0, False: 225]
  |  Branch (125:45): [True: 0, False: 15]
  ------------------
  126|      0|                        {
  127|      0|                            return OpCode::DIV;
  128|      0|                        }
  129|    225|                        break;
  130|       |
  131|    225|                    case 'E':
  ------------------
  |  Branch (131:21): [True: 91, False: 98.8k]
  ------------------
  132|    211|                    case 'e':
  ------------------
  |  Branch (132:21): [True: 120, False: 98.8k]
  ------------------
  133|    211|                        if (ice(c2, 'Q'))
  ------------------
  |  Branch (133:29): [True: 0, False: 211]
  ------------------
  134|      0|                        {
  135|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (135:33): [True: 0, False: 0]
  ------------------
  136|      0|                            {
  137|      0|                                return OpCode::EQD;
  138|      0|                            }
  139|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (139:38): [True: 0, False: 0]
  ------------------
  140|      0|                            {
  141|      0|                                return OpCode::EQF;
  142|      0|                            }
  143|      0|                        }
  144|    211|                        break;
  145|       |
  146|    211|                    case 'G':
  ------------------
  |  Branch (146:21): [True: 3, False: 98.9k]
  ------------------
  147|     18|                    case 'g':
  ------------------
  |  Branch (147:21): [True: 15, False: 98.9k]
  ------------------
  148|     18|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (148:29): [True: 3, False: 15]
  ------------------
  149|      3|                        {
  150|      3|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (150:33): [True: 1, False: 2]
  ------------------
  151|      1|                            {
  152|      1|                                return OpCode::GED;
  153|      1|                            }
  154|      2|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (154:38): [True: 1, False: 1]
  ------------------
  155|      1|                            {
  156|      1|                                return OpCode::GEF;
  157|      1|                            }
  158|      3|                        }
  159|     15|                        else if (ice(c2, 'T'))
  ------------------
  |  Branch (159:34): [True: 11, False: 4]
  ------------------
  160|     11|                        {
  161|     11|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (161:33): [True: 0, False: 11]
  ------------------
  162|      0|                            {
  163|      0|                                return OpCode::GTD;
  164|      0|                            }
  165|     11|                            if (ice(c3, 'F'))
  ------------------
  |  Branch (165:33): [True: 0, False: 11]
  ------------------
  166|      0|                            {
  167|      0|                                return OpCode::GTF;
  168|      0|                            }
  169|     11|                        }
  170|     16|                        break;
  171|       |
  172|  17.0k|                    case 'J':
  ------------------
  |  Branch (172:21): [True: 17.0k, False: 81.9k]
  ------------------
  173|  17.0k|                    case 'j':
  ------------------
  |  Branch (173:21): [True: 49, False: 98.9k]
  ------------------
  174|  17.0k|                        if (ice(c2, 'A') && ice(c3, 'L'))
  ------------------
  |  Branch (174:29): [True: 85, False: 17.0k]
  |  Branch (174:29): [True: 12, False: 17.0k]
  |  Branch (174:45): [True: 12, False: 73]
  ------------------
  175|     12|                        {
  176|     12|                            return OpCode::JAL;
  177|     12|                        }
  178|  17.0k|                        break;
  179|       |
  180|  17.0k|                    case 'L':
  ------------------
  |  Branch (180:21): [True: 126, False: 98.8k]
  ------------------
  181|  1.79k|                    case 'l':
  ------------------
  |  Branch (181:21): [True: 1.66k, False: 97.2k]
  ------------------
  182|  1.79k|                        switch (c2)
  ------------------
  |  Branch (182:33): [True: 848, False: 947]
  ------------------
  183|  1.79k|                        {
  184|     43|                            case 'B':
  ------------------
  |  Branch (184:29): [True: 43, False: 1.75k]
  ------------------
  185|     49|                            case 'b':
  ------------------
  |  Branch (185:29): [True: 6, False: 1.78k]
  ------------------
  186|     49|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (186:37): [True: 0, False: 49]
  ------------------
  187|      0|                                {
  188|      0|                                    return OpCode::LBU;
  189|      0|                                }
  190|     49|                                break;
  191|       |
  192|    263|                            case 'E':
  ------------------
  |  Branch (192:29): [True: 263, False: 1.53k]
  ------------------
  193|    447|                            case 'e':
  ------------------
  |  Branch (193:29): [True: 184, False: 1.61k]
  ------------------
  194|    447|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (194:37): [True: 27, False: 420]
  ------------------
  195|     27|                                {
  196|     27|                                    return OpCode::LED;
  197|     27|                                }
  198|    420|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (198:42): [True: 11, False: 409]
  ------------------
  199|     11|                                {
  200|     11|                                    return OpCode::LEF;
  201|     11|                                }
  202|    409|                                break;
  203|       |
  204|    409|                            case 'H':
  ------------------
  |  Branch (204:29): [True: 12, False: 1.78k]
  ------------------
  205|     15|                            case 'h':
  ------------------
  |  Branch (205:29): [True: 3, False: 1.79k]
  ------------------
  206|     15|                                if (ice(c3, 'I'))
  ------------------
  |  Branch (206:37): [True: 0, False: 15]
  ------------------
  207|      0|                                {
  208|      0|                                    return OpCode::LHI;
  209|      0|                                }
  210|     15|                                else if (ice(c3, 'U'))
  ------------------
  |  Branch (210:42): [True: 0, False: 15]
  ------------------
  211|      0|                                {
  212|      0|                                    return OpCode::LHU;
  213|      0|                                }
  214|     15|                                break;
  215|       |
  216|     15|                            case 'T':
  ------------------
  |  Branch (216:29): [True: 1, False: 1.79k]
  ------------------
  217|     10|                            case 't':
  ------------------
  |  Branch (217:29): [True: 9, False: 1.78k]
  ------------------
  218|     10|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (218:37): [True: 0, False: 10]
  ------------------
  219|      0|                                {
  220|      0|                                    return OpCode::LTD;
  221|      0|                                }
  222|     10|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (222:42): [True: 0, False: 10]
  ------------------
  223|      0|                                {
  224|      0|                                    return OpCode::LTF;
  225|      0|                                }
  226|     10|                                break;
  227|       |
  228|    415|                            case 'W':
  ------------------
  |  Branch (228:29): [True: 415, False: 1.38k]
  ------------------
  229|    426|                            case 'w':
  ------------------
  |  Branch (229:29): [True: 11, False: 1.78k]
  ------------------
  230|    426|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (230:37): [True: 0, False: 426]
  ------------------
  231|      0|                                {
  232|      0|                                    return OpCode::LWU;
  233|      0|                                }
  234|    426|                                break;
  235|  1.79k|                        }
  236|  1.75k|                        break;
  237|       |
  238|  1.75k|                    case 'N':
  ------------------
  |  Branch (238:21): [True: 4, False: 98.9k]
  ------------------
  239|    571|                    case 'n':
  ------------------
  |  Branch (239:21): [True: 567, False: 98.3k]
  ------------------
  240|    571|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (240:29): [True: 484, False: 87]
  ------------------
  241|    484|                        {
  242|    484|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (242:33): [True: 76, False: 408]
  ------------------
  243|     76|                            {
  244|     76|                                return OpCode::NED;
  245|     76|                            }
  246|    408|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (246:38): [True: 8, False: 400]
  ------------------
  247|      8|                            {
  248|      8|                                return OpCode::NEF;
  249|      8|                            }
  250|    484|                        }
  251|     87|                        else if (ice(c2, 'O') && ice(c3, 'P'))
  ------------------
  |  Branch (251:34): [True: 8, False: 79]
  |  Branch (251:34): [True: 1, False: 86]
  |  Branch (251:50): [True: 1, False: 7]
  ------------------
  252|      1|                        {
  253|      1|                            return OpCode::NOP;
  254|      1|                        }
  255|       |
  256|    486|                        break;
  257|       |
  258|    486|                    case 'O':
  ------------------
  |  Branch (258:21): [True: 6, False: 98.9k]
  ------------------
  259|     51|                    case 'o':
  ------------------
  |  Branch (259:21): [True: 45, False: 98.9k]
  ------------------
  260|     51|                        if (ice(c2, 'R') && ice(c3, 'I'))
  ------------------
  |  Branch (260:29): [True: 5, False: 46]
  |  Branch (260:29): [True: 0, False: 51]
  |  Branch (260:45): [True: 0, False: 5]
  ------------------
  261|      0|                        {
  262|      0|                            return OpCode::ORI;
  263|      0|                        }
  264|     51|                        break;
  265|       |
  266|    580|                    case 'S':
  ------------------
  |  Branch (266:21): [True: 580, False: 98.3k]
  ------------------
  267|  1.70k|                    case 's':
  ------------------
  |  Branch (267:21): [True: 1.12k, False: 97.8k]
  ------------------
  268|  1.70k|                        switch (c2)
  ------------------
  |  Branch (268:33): [True: 1.08k, False: 618]
  ------------------
  269|  1.70k|                        {
  270|      1|                            case 'B':
  ------------------
  |  Branch (270:29): [True: 1, False: 1.70k]
  ------------------
  271|     16|                            case 'b':
  ------------------
  |  Branch (271:29): [True: 15, False: 1.68k]
  ------------------
  272|     16|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (272:37): [True: 0, False: 16]
  ------------------
  273|      0|                                {
  274|      0|                                    return OpCode::SBU;
  275|      0|                                }
  276|     16|                                break;
  277|       |
  278|     16|                            case 'E':
  ------------------
  |  Branch (278:29): [True: 7, False: 1.69k]
  ------------------
  279|     14|                            case 'e':
  ------------------
  |  Branch (279:29): [True: 7, False: 1.69k]
  ------------------
  280|     14|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (280:37): [True: 0, False: 14]
  ------------------
  281|      0|                                {
  282|      0|                                    return OpCode::SEQ;
  283|      0|                                }
  284|     14|                                break;
  285|       |
  286|    199|                            case 'G':
  ------------------
  |  Branch (286:29): [True: 199, False: 1.50k]
  ------------------
  287|    202|                            case 'g':
  ------------------
  |  Branch (287:29): [True: 3, False: 1.69k]
  ------------------
  288|    202|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (288:37): [True: 2, False: 200]
  ------------------
  289|      2|                                {
  290|      2|                                    return OpCode::SGE;
  291|      2|                                }
  292|    200|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (292:42): [True: 0, False: 200]
  ------------------
  293|      0|                                {
  294|      0|                                    return OpCode::SGT;
  295|      0|                                }
  296|    200|                                break;
  297|       |
  298|    200|                            case 'H':
  ------------------
  |  Branch (298:29): [True: 3, False: 1.69k]
  ------------------
  299|     24|                            case 'h':
  ------------------
  |  Branch (299:29): [True: 21, False: 1.68k]
  ------------------
  300|     24|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (300:37): [True: 0, False: 24]
  ------------------
  301|      0|                                {
  302|      0|                                    return OpCode::SHU;
  303|      0|                                }
  304|     24|                                break;
  305|       |
  306|     24|                            case 'L':
  ------------------
  |  Branch (306:29): [True: 8, False: 1.69k]
  ------------------
  307|    278|                            case 'l':
  ------------------
  |  Branch (307:29): [True: 270, False: 1.43k]
  ------------------
  308|    278|                                switch (c3)
  ------------------
  |  Branch (308:41): [True: 258, False: 20]
  ------------------
  309|    278|                                {
  310|      7|                                    case 'A':
  ------------------
  |  Branch (310:37): [True: 7, False: 271]
  ------------------
  311|      7|                                    case 'a':
  ------------------
  |  Branch (311:37): [True: 0, False: 278]
  ------------------
  312|      7|                                        return OpCode::SLA;
  313|       |
  314|      7|                                    case 'E':
  ------------------
  |  Branch (314:37): [True: 7, False: 271]
  ------------------
  315|      8|                                    case 'e':
  ------------------
  |  Branch (315:37): [True: 1, False: 277]
  ------------------
  316|      8|                                        return OpCode::SLE;
  317|       |
  318|      0|                                    case 'L':
  ------------------
  |  Branch (318:37): [True: 0, False: 278]
  ------------------
  319|      4|                                    case 'l':
  ------------------
  |  Branch (319:37): [True: 4, False: 274]
  ------------------
  320|      4|                                        return OpCode::SLL;
  321|       |
  322|      0|                                    case 'T':
  ------------------
  |  Branch (322:37): [True: 0, False: 278]
  ------------------
  323|      1|                                    case 't':
  ------------------
  |  Branch (323:37): [True: 1, False: 277]
  ------------------
  324|      1|                                        return OpCode::SLT;
  325|    278|                                }
  326|    258|                                break;
  327|       |
  328|    258|                            case 'N':
  ------------------
  |  Branch (328:29): [True: 3, False: 1.69k]
  ------------------
  329|     22|                            case 'n':
  ------------------
  |  Branch (329:29): [True: 19, False: 1.68k]
  ------------------
  330|     22|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (330:37): [True: 9, False: 13]
  ------------------
  331|      9|                                {
  332|      9|                                    return OpCode::SNE;
  333|      9|                                }
  334|     13|                                break;
  335|       |
  336|     34|                            case 'R':
  ------------------
  |  Branch (336:29): [True: 34, False: 1.66k]
  ------------------
  337|     35|                            case 'r':
  ------------------
  |  Branch (337:29): [True: 1, False: 1.70k]
  ------------------
  338|     35|                                if (ice(c3, 'A'))
  ------------------
  |  Branch (338:37): [True: 2, False: 33]
  ------------------
  339|      2|                                {
  340|      2|                                    return OpCode::SRA;
  341|      2|                                }
  342|     33|                                else if (ice(c3, 'L'))
  ------------------
  |  Branch (342:42): [True: 1, False: 32]
  ------------------
  343|      1|                                {
  344|      1|                                    return OpCode::SRL;
  345|      1|                                }
  346|     32|                                break;
  347|       |
  348|     32|                            case 'U':
  ------------------
  |  Branch (348:29): [True: 3, False: 1.69k]
  ------------------
  349|      5|                            case 'u':
  ------------------
  |  Branch (349:29): [True: 2, False: 1.70k]
  ------------------
  350|      5|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (350:37): [True: 1, False: 4]
  ------------------
  351|      1|                                {
  352|      1|                                    return OpCode::SUB;
  353|      1|                                }
  354|      4|                                break;
  355|       |
  356|     16|                            case 'W':
  ------------------
  |  Branch (356:29): [True: 16, False: 1.68k]
  ------------------
  357|     22|                            case 'w':
  ------------------
  |  Branch (357:29): [True: 6, False: 1.69k]
  ------------------
  358|     22|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (358:37): [True: 0, False: 22]
  ------------------
  359|      0|                                {
  360|      0|                                    return OpCode::SWU;
  361|      0|                                }
  362|     22|                                break;
  363|  1.70k|                        }
  364|       |
  365|  1.69k|                    case 'X':
  ------------------
  |  Branch (365:21): [True: 25, False: 98.9k]
  ------------------
  366|  1.69k|                    case 'x':
  ------------------
  |  Branch (366:21): [True: 4, False: 98.9k]
  ------------------
  367|  1.69k|                        if (ice(c2, 'O') && ice(c3, 'R'))
  ------------------
  |  Branch (367:29): [True: 52, False: 1.64k]
  |  Branch (367:29): [True: 0, False: 1.69k]
  |  Branch (367:45): [True: 0, False: 52]
  ------------------
  368|      0|                        {
  369|      0|                            return OpCode::XOR;
  370|      0|                        }
  371|  1.69k|                        break;
  372|  98.9k|                }
  373|  98.6k|                break;
  374|  98.9k|            }
  375|       |
  376|       |            // 4 character OpCodes
  377|  98.6k|            case 4: {
  ------------------
  |  Branch (377:13): [True: 13.1k, False: 341k]
  ------------------
  378|  13.1k|                const char c1 = token[0u];
  379|  13.1k|                const char c2 = token[1u];
  380|  13.1k|                const char c3 = token[2u];
  381|  13.1k|                const char c4 = token[3u];
  382|       |
  383|  13.1k|                switch (c1)
  ------------------
  |  Branch (383:25): [True: 6.54k, False: 6.62k]
  ------------------
  384|  13.1k|                {
  385|    244|                    case 'A':
  ------------------
  |  Branch (385:21): [True: 244, False: 12.9k]
  ------------------
  386|    254|                    case 'a':
  ------------------
  |  Branch (386:21): [True: 10, False: 13.1k]
  ------------------
  387|    254|                        switch (c2)
  ------------------
  |  Branch (387:33): [True: 40, False: 214]
  ------------------
  388|    254|                        {
  389|      4|                            case 'D':
  ------------------
  |  Branch (389:29): [True: 4, False: 250]
  ------------------
  390|    151|                            case 'd':
  ------------------
  |  Branch (390:29): [True: 147, False: 107]
  ------------------
  391|    151|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (391:37): [True: 143, False: 8]
  ------------------
  392|    143|                                {
  393|    143|                                    switch (c4)
  ------------------
  |  Branch (393:45): [True: 63, False: 80]
  ------------------
  394|    143|                                    {
  395|      4|                                        case 'D':
  ------------------
  |  Branch (395:41): [True: 4, False: 139]
  ------------------
  396|     12|                                        case 'd':
  ------------------
  |  Branch (396:41): [True: 8, False: 135]
  ------------------
  397|     12|                                            return OpCode::ADDD;
  398|       |
  399|     66|                                        case 'F':
  ------------------
  |  Branch (399:41): [True: 66, False: 77]
  ------------------
  400|     67|                                        case 'f':
  ------------------
  |  Branch (400:41): [True: 1, False: 142]
  ------------------
  401|     67|                                            return OpCode::ADDF;
  402|       |
  403|      0|                                        case 'I':
  ------------------
  |  Branch (403:41): [True: 0, False: 143]
  ------------------
  404|      1|                                        case 'i':
  ------------------
  |  Branch (404:41): [True: 1, False: 142]
  ------------------
  405|      1|                                            return OpCode::ADDI;
  406|       |
  407|      0|                                        case 'U':
  ------------------
  |  Branch (407:41): [True: 0, False: 143]
  ------------------
  408|      0|                                        case 'u':
  ------------------
  |  Branch (408:41): [True: 0, False: 143]
  ------------------
  409|      0|                                            return OpCode::ADDU;
  410|    143|                                    }
  411|    143|                                }
  412|     71|                                break;
  413|       |
  414|     71|                            case 'N':
  ------------------
  |  Branch (414:29): [True: 6, False: 248]
  ------------------
  415|     63|                            case 'n':
  ------------------
  |  Branch (415:29): [True: 57, False: 197]
  ------------------
  416|     63|                                if (ice(c3, 'D') && ice(c4, 'I'))
  ------------------
  |  Branch (416:37): [True: 6, False: 57]
  |  Branch (416:37): [True: 0, False: 63]
  |  Branch (416:53): [True: 0, False: 6]
  ------------------
  417|      0|                                {
  418|      0|                                    return OpCode::ANDI;
  419|      0|                                }
  420|       |
  421|     63|                                break;
  422|    254|                        }
  423|    174|                        break;
  424|       |
  425|    796|                    case 'B':
  ------------------
  |  Branch (425:21): [True: 796, False: 12.3k]
  ------------------
  426|    802|                    case 'b':
  ------------------
  |  Branch (426:21): [True: 6, False: 13.1k]
  ------------------
  427|    802|                        switch (c2)
  ------------------
  |  Branch (427:33): [True: 15, False: 787]
  ------------------
  428|    802|                        {
  429|    710|                            case 'E':
  ------------------
  |  Branch (429:29): [True: 710, False: 92]
  ------------------
  430|    757|                            case 'e':
  ------------------
  |  Branch (430:29): [True: 47, False: 755]
  ------------------
  431|    757|                                if (ice(c3, 'Q') && ice(c4, 'Z'))
  ------------------
  |  Branch (431:37): [True: 0, False: 757]
  |  Branch (431:37): [True: 0, False: 757]
  |  Branch (431:53): [True: 0, False: 0]
  ------------------
  432|      0|                                {
  433|      0|                                    return OpCode::BEQZ;
  434|      0|                                }
  435|    757|                                break;
  436|       |
  437|    757|                            case 'F':
  ------------------
  |  Branch (437:29): [True: 17, False: 785]
  ------------------
  438|     17|                            case 'f':
  ------------------
  |  Branch (438:29): [True: 0, False: 802]
  ------------------
  439|     17|                                if (ice(c3, 'P'))
  ------------------
  |  Branch (439:37): [True: 0, False: 17]
  ------------------
  440|      0|                                {
  441|      0|                                    if (ice(c4, 'F'))
  ------------------
  |  Branch (441:41): [True: 0, False: 0]
  ------------------
  442|      0|                                    {
  443|      0|                                        return OpCode::BFPF;
  444|      0|                                    }
  445|      0|                                    else if (ice(c4, 'T'))
  ------------------
  |  Branch (445:46): [True: 0, False: 0]
  ------------------
  446|      0|                                    {
  447|      0|                                        return OpCode::BFPT;
  448|      0|                                    }
  449|      0|                                }
  450|     17|                                break;
  451|       |
  452|     17|                            case 'N':
  ------------------
  |  Branch (452:29): [True: 3, False: 799]
  ------------------
  453|     13|                            case 'n':
  ------------------
  |  Branch (453:29): [True: 10, False: 792]
  ------------------
  454|     13|                                if (ice(c3, 'E') && ice(c4, 'Z'))
  ------------------
  |  Branch (454:37): [True: 9, False: 4]
  |  Branch (454:37): [True: 0, False: 13]
  |  Branch (454:53): [True: 0, False: 9]
  ------------------
  455|      0|                                {
  456|      0|                                    return OpCode::BNEZ;
  457|      0|                                }
  458|    802|                        }
  459|    802|                        break;
  460|       |
  461|    802|                    case 'D':
  ------------------
  |  Branch (461:21): [True: 145, False: 13.0k]
  ------------------
  462|    215|                    case 'd':
  ------------------
  |  Branch (462:21): [True: 70, False: 13.0k]
  ------------------
  463|    215|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (463:29): [True: 15, False: 200]
  |  Branch (463:29): [True: 0, False: 215]
  |  Branch (463:45): [True: 0, False: 15]
  ------------------
  464|      0|                        {
  465|      0|                            switch (c4)
  ------------------
  |  Branch (465:37): [True: 0, False: 0]
  ------------------
  466|      0|                            {
  467|      0|                                case 'D':
  ------------------
  |  Branch (467:33): [True: 0, False: 0]
  ------------------
  468|      0|                                case 'd':
  ------------------
  |  Branch (468:33): [True: 0, False: 0]
  ------------------
  469|      0|                                    return OpCode::DIVD;
  470|       |
  471|      0|                                case 'F':
  ------------------
  |  Branch (471:33): [True: 0, False: 0]
  ------------------
  472|      0|                                case 'f':
  ------------------
  |  Branch (472:33): [True: 0, False: 0]
  ------------------
  473|      0|                                    return OpCode::DIVF;
  474|       |
  475|      0|                                case 'I':
  ------------------
  |  Branch (475:33): [True: 0, False: 0]
  ------------------
  476|      0|                                case 'i':
  ------------------
  |  Branch (476:33): [True: 0, False: 0]
  ------------------
  477|      0|                                    return OpCode::DIVI;
  478|       |
  479|      0|                                case 'U':
  ------------------
  |  Branch (479:33): [True: 0, False: 0]
  ------------------
  480|      0|                                case 'u':
  ------------------
  |  Branch (480:33): [True: 0, False: 0]
  ------------------
  481|      0|                                    return OpCode::DIVU;
  482|      0|                            }
  483|      0|                        }
  484|    215|                        break;
  485|       |
  486|    215|                    case 'H':
  ------------------
  |  Branch (486:21): [True: 6, False: 13.1k]
  ------------------
  487|     65|                    case 'h':
  ------------------
  |  Branch (487:21): [True: 59, False: 13.1k]
  ------------------
  488|     65|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (488:29): [True: 59, False: 6]
  |  Branch (488:29): [True: 0, False: 65]
  |  Branch (488:45): [True: 55, False: 4]
  |  Branch (488:61): [True: 0, False: 55]
  ------------------
  489|      0|                        {
  490|      0|                            return OpCode::HALT;
  491|      0|                        }
  492|     65|                        break;
  493|       |
  494|  3.59k|                    case 'J':
  ------------------
  |  Branch (494:21): [True: 3.59k, False: 9.57k]
  ------------------
  495|  3.63k|                    case 'j':
  ------------------
  |  Branch (495:21): [True: 34, False: 13.1k]
  ------------------
  496|  3.63k|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'R'))
  ------------------
  |  Branch (496:29): [True: 27, False: 3.60k]
  |  Branch (496:29): [True: 0, False: 3.63k]
  |  Branch (496:45): [True: 17, False: 10]
  |  Branch (496:61): [True: 0, False: 17]
  ------------------
  497|      0|                        {
  498|      0|                            return OpCode::JALR;
  499|      0|                        }
  500|  3.63k|                        break;
  501|       |
  502|  3.63k|                    case 'M':
  ------------------
  |  Branch (502:21): [True: 28, False: 13.1k]
  ------------------
  503|     39|                    case 'm':
  ------------------
  |  Branch (503:21): [True: 11, False: 13.1k]
  ------------------
  504|     39|                        if (ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (504:29): [True: 9, False: 30]
  |  Branch (504:29): [True: 0, False: 39]
  |  Branch (504:45): [True: 0, False: 9]
  ------------------
  505|      0|                        {
  506|      0|                            if (ice(c4, 'D'))
  ------------------
  |  Branch (506:33): [True: 0, False: 0]
  ------------------
  507|      0|                            {
  508|      0|                                return OpCode::MOVD;
  509|      0|                            }
  510|      0|                            else if (ice(c4, 'F'))
  ------------------
  |  Branch (510:38): [True: 0, False: 0]
  ------------------
  511|      0|                            {
  512|      0|                                return OpCode::MOVF;
  513|      0|                            }
  514|      0|                        }
  515|     39|                        else if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (515:34): [True: 0, False: 39]
  |  Branch (515:34): [True: 0, False: 39]
  |  Branch (515:50): [True: 0, False: 0]
  |  Branch (515:66): [True: 0, False: 0]
  ------------------
  516|      0|                        {
  517|      0|                            return OpCode::MULT;
  518|      0|                        }
  519|     39|                        break;
  520|       |
  521|    205|                    case 'S':
  ------------------
  |  Branch (521:21): [True: 205, False: 12.9k]
  ------------------
  522|  1.53k|                    case 's':
  ------------------
  |  Branch (522:21): [True: 1.32k, False: 11.8k]
  ------------------
  523|  1.53k|                        switch (c2)
  ------------------
  |  Branch (523:33): [True: 376, False: 1.15k]
  ------------------
  524|  1.53k|                        {
  525|      3|                            case 'E':
  ------------------
  |  Branch (525:29): [True: 3, False: 1.53k]
  ------------------
  526|      4|                            case 'e':
  ------------------
  |  Branch (526:29): [True: 1, False: 1.53k]
  ------------------
  527|      4|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (527:37): [True: 0, False: 4]
  ------------------
  528|      0|                                {
  529|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (529:41): [True: 0, False: 0]
  ------------------
  530|      0|                                    {
  531|      0|                                        return OpCode::SEQI;
  532|      0|                                    }
  533|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (533:46): [True: 0, False: 0]
  ------------------
  534|      0|                                    {
  535|      0|                                        return OpCode::SEQU;
  536|      0|                                    }
  537|      0|                                }
  538|      4|                                break;
  539|       |
  540|    813|                            case 'G':
  ------------------
  |  Branch (540:29): [True: 813, False: 720]
  ------------------
  541|    819|                            case 'g':
  ------------------
  |  Branch (541:29): [True: 6, False: 1.52k]
  ------------------
  542|    819|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (542:37): [True: 5, False: 814]
  ------------------
  543|      5|                                {
  544|      5|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (544:41): [True: 0, False: 5]
  ------------------
  545|      0|                                    {
  546|      0|                                        return OpCode::SGEI;
  547|      0|                                    }
  548|      5|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (548:46): [True: 1, False: 4]
  ------------------
  549|      1|                                    {
  550|      1|                                        return OpCode::SGEU;
  551|      1|                                    }
  552|      5|                                }
  553|    814|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (553:42): [True: 0, False: 814]
  ------------------
  554|      0|                                {
  555|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (555:41): [True: 0, False: 0]
  ------------------
  556|      0|                                    {
  557|      0|                                        return OpCode::SGTI;
  558|      0|                                    }
  559|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (559:46): [True: 0, False: 0]
  ------------------
  560|      0|                                    {
  561|      0|                                        return OpCode::SGTU;
  562|      0|                                    }
  563|      0|                                }
  564|    818|                                break;
  565|       |
  566|    818|                            case 'L':
  ------------------
  |  Branch (566:29): [True: 9, False: 1.52k]
  ------------------
  567|    277|                            case 'l':
  ------------------
  |  Branch (567:29): [True: 268, False: 1.26k]
  ------------------
  568|    277|                                switch (c3)
  ------------------
  |  Branch (568:41): [True: 251, False: 26]
  ------------------
  569|    277|                                {
  570|      7|                                    case 'A':
  ------------------
  |  Branch (570:37): [True: 7, False: 270]
  ------------------
  571|      7|                                    case 'a':
  ------------------
  |  Branch (571:37): [True: 0, False: 277]
  ------------------
  572|      7|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (572:45): [True: 0, False: 7]
  ------------------
  573|      0|                                        {
  574|      0|                                            return OpCode::SLAI;
  575|      0|                                        }
  576|      7|                                        break;
  577|       |
  578|     11|                                    case 'E':
  ------------------
  |  Branch (578:37): [True: 11, False: 266]
  ------------------
  579|     13|                                    case 'e':
  ------------------
  |  Branch (579:37): [True: 2, False: 275]
  ------------------
  580|     13|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (580:45): [True: 0, False: 13]
  ------------------
  581|      0|                                        {
  582|      0|                                            return OpCode::SLEI;
  583|      0|                                        }
  584|     13|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (584:50): [True: 6, False: 7]
  ------------------
  585|      6|                                        {
  586|      6|                                            return OpCode::SLEU;
  587|      6|                                        }
  588|      7|                                        break;
  589|       |
  590|      7|                                    case 'L':
  ------------------
  |  Branch (590:37): [True: 0, False: 277]
  ------------------
  591|      4|                                    case 'l':
  ------------------
  |  Branch (591:37): [True: 4, False: 273]
  ------------------
  592|      4|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (592:45): [True: 0, False: 4]
  ------------------
  593|      0|                                        {
  594|      0|                                            return OpCode::SLLI;
  595|      0|                                        }
  596|      4|                                        break;
  597|       |
  598|      4|                                    case 'T':
  ------------------
  |  Branch (598:37): [True: 0, False: 277]
  ------------------
  599|      2|                                    case 't':
  ------------------
  |  Branch (599:37): [True: 2, False: 275]
  ------------------
  600|      2|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (600:45): [True: 0, False: 2]
  ------------------
  601|      0|                                        {
  602|      0|                                            return OpCode::SLTI;
  603|      0|                                        }
  604|      2|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (604:50): [True: 0, False: 2]
  ------------------
  605|      0|                                        {
  606|      0|                                            return OpCode::SLTU;
  607|      0|                                        }
  608|      2|                                        break;
  609|    277|                                }
  610|       |
  611|    272|                            case 'N':
  ------------------
  |  Branch (611:29): [True: 1, False: 1.53k]
  ------------------
  612|    313|                            case 'n':
  ------------------
  |  Branch (612:29): [True: 41, False: 1.49k]
  ------------------
  613|    313|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (613:37): [True: 7, False: 306]
  ------------------
  614|      7|                                {
  615|      7|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (615:41): [True: 0, False: 7]
  ------------------
  616|      0|                                    {
  617|      0|                                        return OpCode::SNEI;
  618|      0|                                    }
  619|      7|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (619:46): [True: 0, False: 7]
  ------------------
  620|      0|                                    {
  621|      0|                                        return OpCode::SNEU;
  622|      0|                                    }
  623|      7|                                }
  624|    313|                                break;
  625|       |
  626|    313|                            case 'R':
  ------------------
  |  Branch (626:29): [True: 8, False: 1.52k]
  ------------------
  627|      9|                            case 'r':
  ------------------
  |  Branch (627:29): [True: 1, False: 1.53k]
  ------------------
  628|      9|                                if (ice(c3, 'A') && ice(c4, 'I'))
  ------------------
  |  Branch (628:37): [True: 3, False: 6]
  |  Branch (628:37): [True: 0, False: 9]
  |  Branch (628:53): [True: 0, False: 3]
  ------------------
  629|      0|                                {
  630|      0|                                    return OpCode::SRAI;
  631|      0|                                }
  632|      9|                                else if (ice(c3, 'L') && ice(c4, 'I'))
  ------------------
  |  Branch (632:42): [True: 4, False: 5]
  |  Branch (632:42): [True: 0, False: 9]
  |  Branch (632:58): [True: 0, False: 4]
  ------------------
  633|      0|                                {
  634|      0|                                    return OpCode::SRLI;
  635|      0|                                }
  636|      9|                                break;
  637|       |
  638|      9|                            case 'U':
  ------------------
  |  Branch (638:29): [True: 3, False: 1.53k]
  ------------------
  639|      6|                            case 'u':
  ------------------
  |  Branch (639:29): [True: 3, False: 1.53k]
  ------------------
  640|      6|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (640:37): [True: 2, False: 4]
  ------------------
  641|      2|                                {
  642|      2|                                    switch (c4)
  ------------------
  |  Branch (642:45): [True: 2, False: 0]
  ------------------
  643|      2|                                    {
  644|      0|                                        case 'D':
  ------------------
  |  Branch (644:41): [True: 0, False: 2]
  ------------------
  645|      0|                                        case 'd':
  ------------------
  |  Branch (645:41): [True: 0, False: 2]
  ------------------
  646|      0|                                            return OpCode::SUBD;
  647|       |
  648|      0|                                        case 'F':
  ------------------
  |  Branch (648:41): [True: 0, False: 2]
  ------------------
  649|      0|                                        case 'f':
  ------------------
  |  Branch (649:41): [True: 0, False: 2]
  ------------------
  650|      0|                                            return OpCode::SUBF;
  651|       |
  652|      0|                                        case 'I':
  ------------------
  |  Branch (652:41): [True: 0, False: 2]
  ------------------
  653|      0|                                        case 'i':
  ------------------
  |  Branch (653:41): [True: 0, False: 2]
  ------------------
  654|      0|                                            return OpCode::SUBI;
  655|       |
  656|      0|                                        case 'U':
  ------------------
  |  Branch (656:41): [True: 0, False: 2]
  ------------------
  657|      0|                                        case 'u':
  ------------------
  |  Branch (657:41): [True: 0, False: 2]
  ------------------
  658|      0|                                            return OpCode::SUBU;
  659|      2|                                    }
  660|      2|                                }
  661|      6|                                break;
  662|  1.53k|                        }
  663|  1.52k|                        break;
  664|       |
  665|  1.52k|                    case 'T':
  ------------------
  |  Branch (665:21): [True: 37, False: 13.1k]
  ------------------
  666|     43|                    case 't':
  ------------------
  |  Branch (666:21): [True: 6, False: 13.1k]
  ------------------
  667|     43|                        if (ice(c2, 'R') && ice(c3, 'A') && ice(c4, 'P'))
  ------------------
  |  Branch (667:29): [True: 0, False: 43]
  |  Branch (667:29): [True: 0, False: 43]
  |  Branch (667:45): [True: 0, False: 0]
  |  Branch (667:61): [True: 0, False: 0]
  ------------------
  668|      0|                        {
  669|      0|                            return OpCode::TRAP;
  670|      0|                        }
  671|     43|                        break;
  672|     43|                    case 'X':
  ------------------
  |  Branch (672:21): [True: 34, False: 13.1k]
  ------------------
  673|     41|                    case 'x':
  ------------------
  |  Branch (673:21): [True: 7, False: 13.1k]
  ------------------
  674|     41|                        if (ice(c2, 'O') && ice(c3, 'R') && ice(c4, 'I'))
  ------------------
  |  Branch (674:29): [True: 2, False: 39]
  |  Branch (674:29): [True: 0, False: 41]
  |  Branch (674:45): [True: 0, False: 2]
  |  Branch (674:61): [True: 0, False: 0]
  ------------------
  675|      0|                        {
  676|      0|                            return OpCode::XORI;
  677|      0|                        }
  678|     41|                        break;
  679|  13.1k|                }
  680|  13.0k|                break;
  681|  13.1k|            }
  682|       |
  683|       |            // 5 character OpCodes
  684|  13.0k|            case 5: {
  ------------------
  |  Branch (684:13): [True: 5.91k, False: 348k]
  ------------------
  685|  5.91k|                const char c1 = token[0u];
  686|  5.91k|                const char c2 = token[1u];
  687|  5.91k|                const char c3 = token[2u];
  688|  5.91k|                const char c4 = token[3u];
  689|  5.91k|                const char c5 = token[4u];
  690|       |
  691|  5.91k|                switch (c1)
  ------------------
  |  Branch (691:25): [True: 4.79k, False: 1.12k]
  ------------------
  692|  5.91k|                {
  693|     84|                    case 'A':
  ------------------
  |  Branch (693:21): [True: 84, False: 5.83k]
  ------------------
  694|    112|                    case 'a':
  ------------------
  |  Branch (694:21): [True: 28, False: 5.88k]
  ------------------
  695|    112|                        if (ice(c2, 'D') && ice(c3, 'D') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (695:29): [True: 71, False: 41]
  |  Branch (695:29): [True: 0, False: 112]
  |  Branch (695:45): [True: 66, False: 5]
  |  Branch (695:61): [True: 0, False: 66]
  |  Branch (695:77): [True: 0, False: 0]
  ------------------
  696|      0|                        {
  697|      0|                            return OpCode::ADDUI;
  698|      0|                        }
  699|    112|                        break;
  700|       |
  701|    112|                    case 'D':
  ------------------
  |  Branch (701:21): [True: 3, False: 5.91k]
  ------------------
  702|     67|                    case 'd':
  ------------------
  |  Branch (702:21): [True: 64, False: 5.85k]
  ------------------
  703|     67|                        if (ice(c2, 'I') && ice(c3, 'V') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (703:29): [True: 14, False: 53]
  |  Branch (703:29): [True: 0, False: 67]
  |  Branch (703:45): [True: 0, False: 14]
  |  Branch (703:61): [True: 0, False: 0]
  |  Branch (703:77): [True: 0, False: 0]
  ------------------
  704|      0|                        {
  705|      0|                            return OpCode::DIVUI;
  706|      0|                        }
  707|     67|                        break;
  708|       |
  709|     67|                    case 'M':
  ------------------
  |  Branch (709:21): [True: 12, False: 5.90k]
  ------------------
  710|     24|                    case 'm':
  ------------------
  |  Branch (710:21): [True: 12, False: 5.90k]
  ------------------
  711|     24|                        if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (711:29): [True: 0, False: 24]
  |  Branch (711:29): [True: 0, False: 24]
  |  Branch (711:45): [True: 0, False: 0]
  |  Branch (711:61): [True: 0, False: 0]
  ------------------
  712|      0|                        {
  713|      0|                            switch (c5)
  ------------------
  |  Branch (713:37): [True: 0, False: 0]
  ------------------
  714|      0|                            {
  715|      0|                                case 'D':
  ------------------
  |  Branch (715:33): [True: 0, False: 0]
  ------------------
  716|      0|                                case 'd':
  ------------------
  |  Branch (716:33): [True: 0, False: 0]
  ------------------
  717|      0|                                    return OpCode::MULTD;
  718|       |
  719|      0|                                case 'F':
  ------------------
  |  Branch (719:33): [True: 0, False: 0]
  ------------------
  720|      0|                                case 'f':
  ------------------
  |  Branch (720:33): [True: 0, False: 0]
  ------------------
  721|      0|                                    return OpCode::MULTF;
  722|       |
  723|      0|                                case 'I':
  ------------------
  |  Branch (723:33): [True: 0, False: 0]
  ------------------
  724|      0|                                case 'i':
  ------------------
  |  Branch (724:33): [True: 0, False: 0]
  ------------------
  725|      0|                                    return OpCode::MULTI;
  726|       |
  727|      0|                                case 'U':
  ------------------
  |  Branch (727:33): [True: 0, False: 0]
  ------------------
  728|      0|                                case 'u':
  ------------------
  |  Branch (728:33): [True: 0, False: 0]
  ------------------
  729|      0|                                    return OpCode::MULTU;
  730|      0|                            }
  731|      0|                        }
  732|     24|                        break;
  733|       |
  734|    494|                    case 'S':
  ------------------
  |  Branch (734:21): [True: 494, False: 5.42k]
  ------------------
  735|    917|                    case 's':
  ------------------
  |  Branch (735:21): [True: 423, False: 5.49k]
  ------------------
  736|    917|                        switch (c2)
  ------------------
  |  Branch (736:33): [True: 526, False: 391]
  ------------------
  737|    917|                        {
  738|      1|                            case 'E':
  ------------------
  |  Branch (738:29): [True: 1, False: 916]
  ------------------
  739|     10|                            case 'e':
  ------------------
  |  Branch (739:29): [True: 9, False: 908]
  ------------------
  740|     10|                                if (ice(c3, 'Q') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (740:37): [True: 0, False: 10]
  |  Branch (740:37): [True: 0, False: 10]
  |  Branch (740:53): [True: 0, False: 0]
  |  Branch (740:69): [True: 0, False: 0]
  ------------------
  741|      0|                                {
  742|      0|                                    return OpCode::SEQUI;
  743|      0|                                }
  744|     10|                                break;
  745|       |
  746|     22|                            case 'G':
  ------------------
  |  Branch (746:29): [True: 22, False: 895]
  ------------------
  747|     25|                            case 'g':
  ------------------
  |  Branch (747:29): [True: 3, False: 914]
  ------------------
  748|     25|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (748:37): [True: 2, False: 23]
  |  Branch (748:37): [True: 0, False: 25]
  |  Branch (748:53): [True: 1, False: 1]
  |  Branch (748:69): [True: 0, False: 1]
  ------------------
  749|      0|                                {
  750|      0|                                    return OpCode::SGEUI;
  751|      0|                                }
  752|     25|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (752:42): [True: 0, False: 25]
  |  Branch (752:42): [True: 0, False: 25]
  |  Branch (752:58): [True: 0, False: 0]
  |  Branch (752:74): [True: 0, False: 0]
  ------------------
  753|      0|                                {
  754|      0|                                    return OpCode::SGTUI;
  755|      0|                                }
  756|     25|                                break;
  757|       |
  758|    284|                            case 'L':
  ------------------
  |  Branch (758:29): [True: 284, False: 633]
  ------------------
  759|    305|                            case 'l':
  ------------------
  |  Branch (759:29): [True: 21, False: 896]
  ------------------
  760|    305|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (760:37): [True: 7, False: 298]
  |  Branch (760:37): [True: 0, False: 305]
  |  Branch (760:53): [True: 1, False: 6]
  |  Branch (760:69): [True: 0, False: 1]
  ------------------
  761|      0|                                {
  762|      0|                                    return OpCode::SLEUI;
  763|      0|                                }
  764|    305|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (764:42): [True: 0, False: 305]
  |  Branch (764:42): [True: 0, False: 305]
  |  Branch (764:58): [True: 0, False: 0]
  |  Branch (764:74): [True: 0, False: 0]
  ------------------
  765|      0|                                {
  766|      0|                                    return OpCode::SLTUI;
  767|      0|                                }
  768|    305|                                break;
  769|       |
  770|    305|                            case 'N':
  ------------------
  |  Branch (770:29): [True: 1, False: 916]
  ------------------
  771|     49|                            case 'n':
  ------------------
  |  Branch (771:29): [True: 48, False: 869]
  ------------------
  772|     49|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (772:37): [True: 8, False: 41]
  |  Branch (772:37): [True: 0, False: 49]
  |  Branch (772:53): [True: 0, False: 8]
  |  Branch (772:69): [True: 0, False: 0]
  ------------------
  773|      0|                                {
  774|      0|                                    return OpCode::SNEUI;
  775|      0|                                }
  776|     49|                                break;
  777|       |
  778|     49|                            case 'U':
  ------------------
  |  Branch (778:29): [True: 1, False: 916]
  ------------------
  779|      2|                            case 'u':
  ------------------
  |  Branch (779:29): [True: 1, False: 916]
  ------------------
  780|      2|                                if (ice(c3, 'B') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (780:37): [True: 0, False: 2]
  |  Branch (780:37): [True: 0, False: 2]
  |  Branch (780:53): [True: 0, False: 0]
  |  Branch (780:69): [True: 0, False: 0]
  ------------------
  781|      0|                                {
  782|      0|                                    return OpCode::SUBUI;
  783|      0|                                }
  784|      2|                                break;
  785|    917|                        }
  786|       |
  787|    917|                        break;
  788|  5.91k|                }
  789|       |
  790|  5.91k|                break;
  791|  5.91k|            }
  792|       |
  793|       |            // 6 character OpCodes
  794|  15.0k|            case 6: {
  ------------------
  |  Branch (794:13): [True: 15.0k, False: 339k]
  ------------------
  795|  15.0k|                const char c1 = token[0u];
  796|  15.0k|                const char c2 = token[1u];
  797|  15.0k|                const char c3 = token[2u];
  798|  15.0k|                const char c4 = token[3u];
  799|  15.0k|                const char c5 = token[4u];
  800|  15.0k|                const char c6 = token[5u];
  801|       |
  802|  15.0k|                if (ice(c1, 'C') && ice(c2, 'V') && ice(c3, 'T'))
  ------------------
  |  Branch (802:21): [True: 7, False: 15.0k]
  |  Branch (802:21): [True: 0, False: 15.0k]
  |  Branch (802:37): [True: 0, False: 7]
  |  Branch (802:53): [True: 0, False: 0]
  ------------------
  803|      0|                {
  804|      0|                    switch (c4)
  ------------------
  |  Branch (804:29): [True: 0, False: 0]
  ------------------
  805|      0|                    {
  806|      0|                        case 'D':
  ------------------
  |  Branch (806:25): [True: 0, False: 0]
  ------------------
  807|      0|                        case 'd':
  ------------------
  |  Branch (807:25): [True: 0, False: 0]
  ------------------
  808|      0|                            if (c5 == '2')
  ------------------
  |  Branch (808:33): [True: 0, False: 0]
  ------------------
  809|      0|                            {
  810|      0|                                if (ice(c6, 'F'))
  ------------------
  |  Branch (810:37): [True: 0, False: 0]
  ------------------
  811|      0|                                {
  812|      0|                                    return OpCode::CVTD2F;
  813|      0|                                }
  814|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (814:42): [True: 0, False: 0]
  ------------------
  815|      0|                                {
  816|      0|                                    return OpCode::CVTD2I;
  817|      0|                                }
  818|      0|                            }
  819|      0|                            break;
  820|       |
  821|      0|                        case 'F':
  ------------------
  |  Branch (821:25): [True: 0, False: 0]
  ------------------
  822|      0|                        case 'f':
  ------------------
  |  Branch (822:25): [True: 0, False: 0]
  ------------------
  823|      0|                            if (c5 == '2')
  ------------------
  |  Branch (823:33): [True: 0, False: 0]
  ------------------
  824|      0|                            {
  825|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (825:37): [True: 0, False: 0]
  ------------------
  826|      0|                                {
  827|      0|                                    return OpCode::CVTF2D;
  828|      0|                                }
  829|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (829:42): [True: 0, False: 0]
  ------------------
  830|      0|                                {
  831|      0|                                    return OpCode::CVTF2I;
  832|      0|                                }
  833|      0|                            }
  834|      0|                            break;
  835|       |
  836|      0|                        case 'I':
  ------------------
  |  Branch (836:25): [True: 0, False: 0]
  ------------------
  837|      0|                        case 'i':
  ------------------
  |  Branch (837:25): [True: 0, False: 0]
  ------------------
  838|      0|                            if (c5 == '2')
  ------------------
  |  Branch (838:33): [True: 0, False: 0]
  ------------------
  839|      0|                            {
  840|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (840:37): [True: 0, False: 0]
  ------------------
  841|      0|                                {
  842|      0|                                    return OpCode::CVTI2D;
  843|      0|                                }
  844|      0|                                else if (ice(c6, 'F'))
  ------------------
  |  Branch (844:42): [True: 0, False: 0]
  ------------------
  845|      0|                                {
  846|      0|                                    return OpCode::CVTI2F;
  847|      0|                                }
  848|      0|                            }
  849|      0|                    }
  850|      0|                }
  851|  15.0k|                else if (ice(c1, 'M') && ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T') &&
  ------------------
  |  Branch (851:26): [True: 23, False: 15.0k]
  |  Branch (851:26): [True: 0, False: 15.0k]
  |  Branch (851:42): [True: 0, False: 23]
  |  Branch (851:58): [True: 0, False: 0]
  |  Branch (851:74): [True: 0, False: 0]
  ------------------
  852|  15.0k|                         ice(c5, 'U') && ice(c6, 'I'))
  ------------------
  |  Branch (852:26): [True: 0, False: 0]
  |  Branch (852:42): [True: 0, False: 0]
  ------------------
  853|      0|                {
  854|      0|                    return OpCode::MULTUI;
  855|      0|                }
  856|  15.0k|                break;
  857|  15.0k|            }
  858|       |
  859|       |            // 7 character OpCodes
  860|  15.0k|            case 7: {
  ------------------
  |  Branch (860:13): [True: 3.89k, False: 350k]
  ------------------
  861|  3.89k|                const char c1 = token[0u];
  862|  3.89k|                const char c2 = token[1u];
  863|  3.89k|                const char c3 = token[2u];
  864|  3.89k|                const char c4 = token[3u];
  865|  3.89k|                const char c5 = token[4u];
  866|  3.89k|                const char c6 = token[5u];
  867|  3.89k|                const char c7 = token[6u];
  868|       |
  869|  3.89k|                if (ice(c1, 'M') && ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (869:21): [True: 43, False: 3.84k]
  |  Branch (869:21): [True: 0, False: 3.89k]
  |  Branch (869:37): [True: 9, False: 34]
  |  Branch (869:53): [True: 0, False: 9]
  ------------------
  870|      0|                {
  871|      0|                    if (ice(c4, 'I') && c5 == '2' && ice(c6, 'F') && ice(c7, 'P'))
  ------------------
  |  Branch (871:25): [True: 0, False: 0]
  |  Branch (871:25): [True: 0, False: 0]
  |  Branch (871:41): [True: 0, False: 0]
  |  Branch (871:54): [True: 0, False: 0]
  |  Branch (871:70): [True: 0, False: 0]
  ------------------
  872|      0|                    {
  873|      0|                        return OpCode::MOVI2FP;
  874|      0|                    }
  875|      0|                    if (ice(c4, 'F') && ice(c5, 'P') && c6 == '2' && ice(c7, 'I'))
  ------------------
  |  Branch (875:25): [True: 0, False: 0]
  |  Branch (875:25): [True: 0, False: 0]
  |  Branch (875:41): [True: 0, False: 0]
  |  Branch (875:57): [True: 0, False: 0]
  |  Branch (875:70): [True: 0, False: 0]
  ------------------
  876|      0|                    {
  877|      0|                        return OpCode::MOVFP2I;
  878|      0|                    }
  879|      0|                }
  880|  3.89k|                break;
  881|  3.89k|            }
  882|       |
  883|   183k|            default: {
  ------------------
  |  Branch (883:13): [True: 183k, False: 170k]
  ------------------
  884|   183k|                break;
  885|  3.89k|            }
  886|   354k|        }
  887|       |
  888|       |        // None found
  889|   338k|        return OpCode::NONE;
  890|   354k|    }
_ZN3dlx3iceEcc:
   15|  91.2k|    {
   16|  91.2k|        constexpr const char diff = 'a' - 'A';
   17|  91.2k|        return (c == t) || (c == t + diff);
  ------------------
  |  Branch (17:16): [True: 14.0k, False: 77.2k]
  |  Branch (17:28): [True: 2.00k, False: 75.2k]
  ------------------
   18|  91.2k|    }

_ZN3dlx10ParseErrorC2Ev:
   18|   492k|    {}
_ZNK3dlx10ParseError13GetLineNumberEv:
   26|   492k|    {
   27|   492k|        return m_LineNumber;
   28|   492k|    }
_ZNK3dlx10ParseError16ConstructMessageEv:
   41|   492k|    {
   42|   492k|        switch (m_Type)
   43|   492k|        {
   44|     60|            case Type::UnexpectedArgumentType: {
  ------------------
  |  Branch (44:13): [True: 60, False: 492k]
  ------------------
   45|     60|                const UnexpectedArgumentType& detail = GetUnexpectedArgumentType();
   46|       |
   47|     60|                return fmt::format("Expected {:s} but got {:s}",
   48|     60|                                   dlx::enum_name(detail.expected_type).data(),
   49|     60|                                   dlx::enum_name(detail.actual_type).data());
   50|      0|            }
   51|       |
   52|      0|            case Type::InvalidNumber: {
  ------------------
  |  Branch (52:13): [True: 0, False: 492k]
  ------------------
   53|      0|                const InvalidNumber& detail = GetInvalidNumber();
   54|       |
   55|      0|                return fmt::format("'{:s}' is not a valid number", detail.text.data());
   56|      0|            }
   57|       |
   58|      0|            case Type::TooFewArgumentsAddressDisplacement: {
  ------------------
  |  Branch (58:13): [True: 0, False: 492k]
  ------------------
   59|      0|                return fmt::format("Not enough arguments left to parse address displacement");
   60|      0|            }
   61|       |
   62|   288k|            case Type::UnexpectedToken: {
  ------------------
  |  Branch (62:13): [True: 288k, False: 204k]
  ------------------
   63|   288k|                const UnexpectedToken& detail = GetUnexpectedToken();
   64|       |
   65|   288k|                return fmt::format("Expected token of type {:s} but got {:s}",
   66|   288k|                                   dlx::enum_name(detail.expected_type).data(),
   67|   288k|                                   dlx::enum_name(detail.actual_type).data());
   68|      0|            }
   69|       |
   70|  2.06k|            case Type::ReservedIdentifier: {
  ------------------
  |  Branch (70:13): [True: 2.06k, False: 490k]
  ------------------
   71|  2.06k|                const ReservedIdentifier& detail = GetReserverIdentifier();
   72|       |
   73|  2.06k|                return fmt::format("'{:s}' is a reserved identifier", detail.identifier.data());
   74|      0|            }
   75|       |
   76|   180k|            case Type::InvalidLabelIdentifier: {
  ------------------
  |  Branch (76:13): [True: 180k, False: 311k]
  ------------------
   77|   180k|                const InvalidLabelIdentifier& detail = GetInvalidLabelIdentifier();
   78|       |
   79|   180k|                return fmt::format("'{:s}' is not a valid label identifier",
   80|   180k|                                   detail.identifier.data());
   81|      0|            }
   82|       |
   83|  4.79k|            case Type::LabelAlreadyDefined: {
  ------------------
  |  Branch (83:13): [True: 4.79k, False: 487k]
  ------------------
   84|  4.79k|                const LabelAlreadyDefined& detail = GetLabelAlreadyDefined();
   85|       |
   86|  4.79k|                return fmt::format("Label '{:s}' was already defined at {:d}:{:d}",
   87|  4.79k|                                   detail.label_name.data(), detail.at_line, detail.at_column);
   88|      0|            }
   89|       |
   90|  13.1k|            case Type::OneInstructionPerLine: {
  ------------------
  |  Branch (90:13): [True: 13.1k, False: 479k]
  ------------------
   91|  13.1k|                return fmt::format("You may only place one instruction per line");
   92|      0|            }
   93|       |
   94|    282|            case Type::TooFewArgument: {
  ------------------
  |  Branch (94:13): [True: 282, False: 492k]
  ------------------
   95|    282|                const TooFewArguments& detail = GetTooFewArguments();
   96|       |
   97|    282|                return fmt::format(
   98|    282|                        "Not enough arguments provided. Required {:d}, provided only {:d}",
   99|    282|                        detail.required, detail.provided);
  100|      0|            }
  101|       |
  102|  2.68k|            case Type::EmptyLabel: {
  ------------------
  |  Branch (102:13): [True: 2.68k, False: 489k]
  ------------------
  103|  2.68k|                const EmptyLabel& detail = GetEmptyLabel();
  104|       |
  105|  2.68k|                return fmt::format("Label '{:s}' does not have any instruction",
  106|  2.68k|                                   detail.label_name.data());
  107|      0|            }
  108|       |
  109|     57|            case Type::TooManyComma: {
  ------------------
  |  Branch (109:13): [True: 57, False: 492k]
  ------------------
  110|     57|                return fmt::format("Only one comma is allowed");
  111|      0|            }
  112|       |
  113|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  114|      0|            default:
  ------------------
  |  Branch (114:13): [True: 0, False: 492k]
  ------------------
  115|      0|                PHI_ASSERT_NOT_REACHED();
  116|   492k|#endif
  117|   492k|        }
  118|   492k|    }
_ZNK3dlx10ParseError25GetUnexpectedArgumentTypeEv:
  124|     60|    {
  125|     60|        PHI_ASSERT(m_Type == Type::UnexpectedArgumentType);
  126|       |
  127|     60|        return unexpected_argument_type;
  128|     60|    }
_ZNK3dlx10ParseError18GetUnexpectedTokenEv:
  138|   288k|    {
  139|   288k|        PHI_ASSERT(m_Type == Type::UnexpectedToken);
  140|       |
  141|   288k|        return unexpected_token;
  142|   288k|    }
_ZNK3dlx10ParseError21GetReserverIdentifierEv:
  146|  2.06k|    {
  147|  2.06k|        PHI_ASSERT(m_Type == Type::ReservedIdentifier);
  148|       |
  149|  2.06k|        return reserved_identifier;
  150|  2.06k|    }
_ZNK3dlx10ParseError25GetInvalidLabelIdentifierEv:
  153|   180k|    {
  154|   180k|        PHI_ASSERT(m_Type == Type::InvalidLabelIdentifier);
  155|       |
  156|   180k|        return invalid_label_identifier;
  157|   180k|    }
_ZNK3dlx10ParseError22GetLabelAlreadyDefinedEv:
  160|  4.79k|    {
  161|  4.79k|        PHI_ASSERT(m_Type == Type::LabelAlreadyDefined);
  162|       |
  163|  4.79k|        return label_already_defined;
  164|  4.79k|    }
_ZNK3dlx10ParseError18GetTooFewArgumentsEv:
  167|    282|    {
  168|    282|        PHI_ASSERT(m_Type == Type::TooFewArgument);
  169|       |
  170|    282|        return too_few_arguments;
  171|    282|    }
_ZNK3dlx10ParseError13GetEmptyLabelEv:
  174|  2.68k|    {
  175|  2.68k|        PHI_ASSERT(m_Type == Type::EmptyLabel);
  176|       |
  177|  2.68k|        return empty_label;
  178|  2.68k|    }
_ZN3dlx41ConstructUnexpectedArgumentTypeParseErrorEmmNS_12ArgumentTypeES0_:
  186|     60|    {
  187|     60|        ParseError err;
  188|       |
  189|     60|        err.m_Type                                 = ParseError::Type::UnexpectedArgumentType;
  190|     60|        err.m_LineNumber                           = line_number;
  191|     60|        err.m_Column                               = column;
  192|     60|        err.unexpected_argument_type.expected_type = expected_type;
  193|     60|        err.unexpected_argument_type.actual_type   = actual_type;
  194|       |
  195|     60|        return err;
  196|     60|    }
_ZN3dlx41ConstructUnexpectedArgumentTypeParseErrorERKNS_5TokenENS_12ArgumentTypeES3_:
  201|     60|    {
  202|     60|        return ConstructUnexpectedArgumentTypeParseError(token.GetLineNumber().unsafe(),
  203|     60|                                                         token.GetColumn().unsafe(), expected_type,
  204|     60|                                                         actual_type);
  205|     60|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorEmmNS_5Token4TypeES1_:
  247|   288k|    {
  248|   288k|        ParseError err;
  249|       |
  250|   288k|        err.m_Type                         = ParseError::Type::UnexpectedToken;
  251|   288k|        err.m_LineNumber                   = line_number;
  252|   288k|        err.m_Column                       = column;
  253|   288k|        err.unexpected_token.expected_type = expected_type;
  254|   288k|        err.unexpected_token.actual_type   = actual_type;
  255|       |
  256|   288k|        return err;
  257|   288k|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorERKNS_5TokenENS0_4TypeE:
  261|   288k|    {
  262|   288k|        return ConstructUnexpectedTokenParseError(token.GetLineNumber().unsafe(),
  263|   288k|                                                  token.GetColumn().unsafe(), expected_type,
  264|   288k|                                                  token.GetType());
  265|   288k|    }
_ZN3dlx37ConstructReservedIdentifierParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  270|  2.06k|    {
  271|  2.06k|        ParseError err;
  272|       |
  273|  2.06k|        err.m_Type                         = ParseError::Type::ReservedIdentifier;
  274|  2.06k|        err.m_LineNumber                   = line_number;
  275|  2.06k|        err.m_Column                       = column;
  276|  2.06k|        err.reserved_identifier.identifier = identifier;
  277|       |
  278|  2.06k|        return err;
  279|  2.06k|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  290|   180k|    {
  291|   180k|        ParseError err;
  292|       |
  293|   180k|        err.m_Type                              = ParseError::Type::InvalidLabelIdentifier;
  294|   180k|        err.m_LineNumber                        = line_number;
  295|   180k|        err.m_Column                            = column;
  296|   180k|        err.invalid_label_identifier.identifier = identifier;
  297|       |
  298|   180k|        return err;
  299|   180k|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorERKNS_5TokenE:
  302|   180k|    {
  303|   180k|        return ConstructInvalidLabelIdentifierParseError(
  304|   180k|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText());
  305|   180k|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEEmm:
  312|  4.79k|    {
  313|  4.79k|        ParseError err;
  314|       |
  315|  4.79k|        err.m_Type                           = ParseError::Type::LabelAlreadyDefined;
  316|  4.79k|        err.m_LineNumber                     = line_number;
  317|  4.79k|        err.m_Column                         = column;
  318|  4.79k|        err.label_already_defined.label_name = label_name;
  319|  4.79k|        err.label_already_defined.at_line    = at_line;
  320|  4.79k|        err.label_already_defined.at_column  = at_column;
  321|       |
  322|  4.79k|        return err;
  323|  4.79k|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorERKNS_5TokenES2_:
  327|  4.79k|    {
  328|  4.79k|        return ConstructLabelAlreadyDefinedParseError(
  329|  4.79k|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText(),
  330|  4.79k|                first_definition.GetLineNumber().unsafe(), first_definition.GetColumn().unsafe());
  331|  4.79k|    }
_ZN3dlx40ConstructOneInstructionPerLineParseErrorEmm:
  335|  13.1k|    {
  336|  13.1k|        ParseError err;
  337|       |
  338|  13.1k|        err.m_Type       = ParseError::Type::OneInstructionPerLine;
  339|  13.1k|        err.m_LineNumber = line_number;
  340|  13.1k|        err.m_Column     = column;
  341|       |
  342|  13.1k|        return err;
  343|  13.1k|    }
_ZN3dlx40ConstructOneInstructionPerLineParseErrorERKNS_5TokenE:
  346|  13.1k|    {
  347|  13.1k|        return ConstructOneInstructionPerLineParseError(token.GetLineNumber().unsafe(),
  348|  13.1k|                                                        token.GetColumn().unsafe());
  349|  13.1k|    }
_ZN3dlx34ConstructTooFewArgumentsParseErrorEmmhh:
  354|    282|    {
  355|    282|        ParseError err;
  356|       |
  357|    282|        err.m_Type                     = ParseError::Type::TooFewArgument;
  358|    282|        err.m_LineNumber               = line_number;
  359|    282|        err.m_Column                   = column;
  360|    282|        err.too_few_arguments.required = required;
  361|    282|        err.too_few_arguments.provided = provided;
  362|       |
  363|    282|        return err;
  364|    282|    }
_ZN3dlx34ConstructTooFewArgumentsParseErrorERKNS_5TokenEhh:
  368|    282|    {
  369|    282|        return ConstructTooFewArgumentsParseError(token.GetLineNumber().unsafe(),
  370|    282|                                                  token.GetColumn().unsafe(), required, provided);
  371|    282|    }
_ZN3dlx29ConstructEmptyLabelParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  375|  2.68k|    {
  376|  2.68k|        ParseError err;
  377|       |
  378|  2.68k|        err.m_Type                 = ParseError::Type::EmptyLabel;
  379|  2.68k|        err.m_LineNumber           = line_number;
  380|  2.68k|        err.m_Column               = column;
  381|  2.68k|        err.empty_label.label_name = label_name;
  382|       |
  383|  2.68k|        return err;
  384|  2.68k|    }
_ZN3dlx29ConstructEmptyLabelParseErrorERKNS_5TokenE:
  387|  2.68k|    {
  388|  2.68k|        return ConstructEmptyLabelParseError(
  389|  2.68k|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(),
  390|  2.68k|                (token.GetText().back() == ':') ?
  ------------------
  |  Branch (390:17): [True: 2.32k, False: 365]
  ------------------
  391|  2.32k|                        token.GetText().substring_view(0u, token.GetText().length() - 1u) :
  392|  2.68k|                        token.GetText());
  393|  2.68k|    }
_ZN3dlx31ConstructTooManyCommaParseErrorEmm:
  397|     57|    {
  398|     57|        ParseError err;
  399|       |
  400|     57|        err.m_Type       = ParseError::Type::TooManyComma;
  401|     57|        err.m_LineNumber = line_number;
  402|     57|        err.m_Column     = column;
  403|       |
  404|     57|        return err;
  405|     57|    }
_ZN3dlx31ConstructTooManyCommaParseErrorERKNS_5TokenE:
  408|     57|    {
  409|     57|        return ConstructTooManyCommaParseError(token.GetLineNumber().unsafe(),
  410|     57|                                               token.GetColumn().unsafe());
  411|     57|    }

_ZN3dlx13ParsedProgram13AddParseErrorEONS_10ParseErrorE:
   16|   492k|    {
   17|   492k|        m_ParseErrors.emplace_back(phi::move(error));
   18|   492k|    }
_ZNK3dlx13ParsedProgram7IsValidEv:
   21|  46.3k|    {
   22|  46.3k|        return m_ParseErrors.empty() && !m_Instructions.empty();
  ------------------
  |  Branch (22:16): [True: 14.7k, False: 31.6k]
  |  Branch (22:41): [True: 14, False: 14.7k]
  ------------------
   23|  46.3k|    }

_ZN3dlx6Parser5ParseERNS_11TokenStreamE:
  180|  8.22k|    {
  181|  8.22k|        ParsedProgram program;
  182|       |
  183|  8.22k|        program.m_Tokens = tokens;
  184|       |
  185|  8.22k|        phi::boolean line_has_instruction{false};
  186|  8.22k|        phi::usize   label_count{0u};
  187|       |
  188|   524k|        while (tokens.has_more())
  ------------------
  |  Branch (188:16): [True: 516k, False: 8.22k]
  ------------------
  189|   516k|        {
  190|   516k|            const Token& current_token = tokens.consume();
  191|       |
  192|       |            //DLX_INFO("Parsing '{}'", current_token.DebugInfo());
  193|       |
  194|   516k|            switch (current_token.GetType())
  195|   516k|            {
  196|       |                // Ignore comments
  197|    211|                case Token::Type::Comment:
  ------------------
  |  Branch (197:17): [True: 211, False: 516k]
  ------------------
  198|       |                    //DLX_DEBUG("Ignoring comment");
  199|    211|                    break;
  200|       |
  201|  23.7k|                case Token::Type::NewLine:
  ------------------
  |  Branch (201:17): [True: 23.7k, False: 492k]
  ------------------
  202|       |                    //DLX_DEBUG("Ignoring newline");
  203|  23.7k|                    line_has_instruction = false;
  204|  23.7k|                    break;
  205|       |
  206|   326k|                case Token::Type::LabelIdentifier: {
  ------------------
  |  Branch (206:17): [True: 326k, False: 190k]
  ------------------
  207|   326k|                    if (line_has_instruction)
  ------------------
  |  Branch (207:25): [True: 136k, False: 190k]
  ------------------
  208|   136k|                    {
  209|   136k|                        program.AddParseError(ConstructUnexpectedTokenParseError(
  210|   136k|                                current_token, Token::Type::NewLine));
  211|   136k|                        break;
  212|   136k|                    }
  213|       |
  214|       |                    // Handle jump labels
  215|       |                    // Check if the last character of the identifier is a colon
  216|   190k|                    if (current_token.GetText().back() != ':')
  ------------------
  |  Branch (216:25): [True: 176k, False: 13.4k]
  ------------------
  217|   176k|                    {
  218|   176k|                        program.AddParseError(
  219|   176k|                                ConstructInvalidLabelIdentifierParseError(current_token));
  220|   176k|                        break;
  221|   176k|                    }
  222|       |
  223|  13.4k|                    phi::string_view label_name = current_token.GetText();
  224|  13.4k|                    label_name.remove_suffix(1u);
  225|       |
  226|  13.4k|                    if (IsReservedIdentifier(label_name))
  ------------------
  |  Branch (226:25): [True: 2.06k, False: 11.4k]
  ------------------
  227|  2.06k|                    {
  228|  2.06k|                        program.AddParseError(ConstructReservedIdentifierParseError(
  229|  2.06k|                                current_token.GetLineNumber().unsafe(),
  230|  2.06k|                                current_token.GetColumn().unsafe(), label_name));
  231|  2.06k|                        break;
  232|  2.06k|                    }
  233|       |
  234|  11.4k|                    if (!IsValidIdentifier(label_name))
  ------------------
  |  Branch (234:25): [True: 3.90k, False: 7.49k]
  ------------------
  235|  3.90k|                    {
  236|  3.90k|                        program.AddParseError(
  237|  3.90k|                                ConstructInvalidLabelIdentifierParseError(current_token));
  238|  3.90k|                        break;
  239|  3.90k|                    }
  240|       |
  241|       |                    // Check if label was already defined
  242|  7.49k|                    if (program.m_JumpData.find(label_name) != program.m_JumpData.end())
  ------------------
  |  Branch (242:25): [True: 4.79k, False: 2.70k]
  ------------------
  243|  4.79k|                    {
  244|       |                        // Find first defintions of label
  245|  4.79k|                        const Token* first_label_definition =
  246|  4.79k|                                tokens.find_first_token_if([&](const Token& t) {
  247|  4.79k|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  248|  4.79k|                                    {
  249|  4.79k|                                        phi::string_view token_label_name = t.GetText();
  250|  4.79k|                                        token_label_name.remove_suffix(1u);
  251|       |
  252|  4.79k|                                        if (token_label_name == label_name)
  253|  4.79k|                                        {
  254|  4.79k|                                            return true;
  255|  4.79k|                                        }
  256|  4.79k|                                    }
  257|       |
  258|  4.79k|                                    return false;
  259|  4.79k|                                });
  260|       |
  261|  4.79k|                        PHI_ASSERT(first_label_definition);
  262|       |
  263|  4.79k|                        program.AddParseError(ConstructLabelAlreadyDefinedParseError(
  264|  4.79k|                                current_token, *first_label_definition));
  265|  4.79k|                        break;
  266|  4.79k|                    }
  267|       |
  268|  2.70k|                    program.m_JumpData[label_name] =
  269|  2.70k|                            static_cast<phi::uint32_t>(program.m_Instructions.size());
  270|  2.70k|                    label_count += 1u;
  271|       |
  272|       |                    //DLX_INFO("Added jump label {} -> {}", label_name,
  273|       |                    //             program.m_Instructions.size());
  274|       |
  275|  2.70k|                    break;
  276|  7.49k|                }
  277|       |
  278|  14.1k|                case Token::Type::OpCode: {
  ------------------
  |  Branch (278:17): [True: 14.1k, False: 502k]
  ------------------
  279|  14.1k|                    if (line_has_instruction)
  ------------------
  |  Branch (279:25): [True: 13.1k, False: 1.00k]
  ------------------
  280|  13.1k|                    {
  281|  13.1k|                        program.AddParseError(
  282|  13.1k|                                ConstructOneInstructionPerLineParseError(current_token));
  283|  13.1k|                        break;
  284|  13.1k|                    }
  285|       |
  286|  1.00k|                    label_count = 0u;
  287|       |
  288|       |                    // Handle normal instructions
  289|  1.00k|                    PHI_ASSERT(current_token.HasHint());
  290|  1.00k|                    OpCode opcode = static_cast<OpCode>(current_token.GetHint());
  291|       |
  292|       |                    //DLX_INFO("Instruction opcode: {}", dlx::enum_name(opcode));
  293|       |
  294|  1.00k|                    const InstructionInfo& info = LookUpInstructionInfo(opcode);
  295|       |
  296|       |                    // Make sure we got no problems here
  297|  1.00k|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  298|  1.00k|                    PHI_ASSERT(info.GetArgumentType(1_u8) != ArgumentType::Unknown);
  299|  1.00k|                    PHI_ASSERT(info.GetArgumentType(2_u8) != ArgumentType::Unknown);
  300|  1.00k|                    PHI_ASSERT(info.GetExecutor());
  301|       |
  302|  1.00k|                    const phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  303|       |                    //DLX_INFO("Instruction requires {} arguments",
  304|       |                    //             number_of_argument_required.unsafe());
  305|       |
  306|       |                    // Create instruction
  307|  1.00k|                    Instruction  instruction(info, current_token.GetLineNumber());
  308|  1.00k|                    phi::boolean consumed_comma{false};
  309|       |
  310|       |                    // Parse arguments
  311|  1.37k|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  ------------------
  |  Branch (311:54): [True: 1.24k, False: 128]
  ------------------
  312|  1.24k|                    {
  313|       |                        // Get next token
  314|  1.24k|                        if (!tokens.has_more())
  ------------------
  |  Branch (314:29): [True: 230, False: 1.01k]
  ------------------
  315|    230|                        {
  316|    230|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  317|    230|                                    current_token, number_of_argument_required.unsafe(),
  318|    230|                                    argument_num.unsafe()));
  319|    230|                            break;
  320|    230|                        }
  321|       |
  322|  1.01k|                        const Token& token = tokens.consume();
  323|       |
  324|       |                        // Skip commas
  325|  1.01k|                        if (token.GetType() == Token::Type::Comma)
  ------------------
  |  Branch (325:29): [True: 240, False: 778]
  ------------------
  326|    240|                        {
  327|    240|                            if (consumed_comma)
  ------------------
  |  Branch (327:33): [True: 57, False: 183]
  ------------------
  328|     57|                            {
  329|     57|                                program.AddParseError(ConstructTooManyCommaParseError(token));
  330|     57|                            }
  331|       |
  332|    240|                            consumed_comma = true;
  333|       |                            //DLX_DEBUG("Skipping comma");
  334|    240|                            continue;
  335|    240|                        }
  336|       |
  337|    778|                        if (token.GetType() == Token::Type::NewLine)
  ------------------
  |  Branch (337:29): [True: 52, False: 726]
  ------------------
  338|     52|                        {
  339|     52|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  340|     52|                                    token, number_of_argument_required.unsafe(),
  341|     52|                                    argument_num.unsafe()));
  342|     52|                            break;
  343|     52|                        }
  344|       |
  345|    726|                        phi::optional<InstructionArgument> optional_parsed_argument =
  346|    726|                                parse_instruction_argument(
  347|    726|                                        token, info.GetArgumentType(argument_num), tokens, program);
  348|    726|                        if (!optional_parsed_argument.has_value())
  ------------------
  |  Branch (348:29): [True: 599, False: 127]
  ------------------
  349|    599|                        {
  350|       |                            // The parse_instruction_argument function should already have added a parse error with more detail
  351|    599|                            break;
  352|    599|                        }
  353|       |
  354|       |                        // Successfully parsed one argument
  355|    127|                        InstructionArgument parsed_argument = optional_parsed_argument.value();
  356|       |
  357|    127|                        instruction.SetArgument(argument_num, parsed_argument);
  358|    127|                        argument_num++;
  359|    127|                        consumed_comma = false;
  360|       |
  361|       |                        //DLX_INFO("Successfully parsed argument {}", argument_num.unsafe());
  362|    127|                    }
  363|       |
  364|       |                    //DLX_INFO("Successfully parsed instruction '{}'",
  365|       |                    //            instruction.DebugInfo());
  366|  1.00k|                    program.m_Instructions.emplace_back(instruction);
  367|  1.00k|                    line_has_instruction = true;
  368|  1.00k|                    break;
  369|  14.1k|                }
  370|       |
  371|   152k|                default:
  ------------------
  |  Branch (371:17): [True: 152k, False: 364k]
  ------------------
  372|   152k|                    Token::Type expected_token_type = Token::Type::Unknown;
  373|   152k|                    if (line_has_instruction)
  ------------------
  |  Branch (373:25): [True: 18.2k, False: 133k]
  ------------------
  374|  18.2k|                    {
  375|  18.2k|                        expected_token_type = Token::Type::NewLine;
  376|  18.2k|                    }
  377|       |
  378|   152k|                    program.AddParseError(
  379|   152k|                            ConstructUnexpectedTokenParseError(current_token, expected_token_type));
  380|   152k|                    break;
  381|   516k|            }
  382|   516k|        }
  383|       |
  384|       |        // Check for empty labels
  385|  8.22k|        if (label_count > 0u)
  ------------------
  |  Branch (385:13): [True: 1.27k, False: 6.95k]
  ------------------
  386|  1.27k|        {
  387|  4.87k|            for (auto it = tokens.rbegin(); label_count > 0u; ++it)
  ------------------
  |  Branch (387:45): [True: 3.60k, False: 1.27k]
  ------------------
  388|  3.60k|            {
  389|  3.60k|                PHI_ASSERT(it != tokens.rend(), "Iterator should never reach the end");
  390|       |
  391|  3.60k|                const Token& token = *it;
  392|  3.60k|                if (token.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (392:21): [True: 2.68k, False: 916]
  ------------------
  393|  2.68k|                {
  394|  2.68k|                    program.AddParseError(ConstructEmptyLabelParseError(token));
  395|  2.68k|                    --label_count;
  396|  2.68k|                }
  397|  3.60k|            }
  398|  1.27k|        }
  399|       |
  400|  8.22k|        return program;
  401|  8.22k|    }
_ZN3dlx6Parser5ParseEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  404|  8.22k|    {
  405|  8.22k|        TokenStream tokens = Tokenize(source);
  406|  8.22k|        return Parse(tokens);
  407|  8.22k|    }
Parser.cpp:_ZN3dlxL26parse_instruction_argumentERKNS_5TokenENS_12ArgumentTypeERNS_11TokenStreamERNS_13ParsedProgramE:
   32|    726|    {
   33|       |        // DLX_INFO("Parsing argument with token '{}' and expected type '{}'", token.DebugInfo(),
   34|       |        //              dlx::enum_name(expected_argument_type));
   35|       |
   36|    726|        switch (token.GetType())
   37|    726|        {
   38|      1|            case Token::Type::IntegerLiteral: {
  ------------------
  |  Branch (38:13): [True: 1, False: 725]
  ------------------
   39|      1|                if (!ArgumentTypeIncludes(expected_argument_type,
  ------------------
  |  Branch (39:21): [True: 1, False: 0]
  ------------------
   40|      1|                                          ArgumentType::AddressDisplacement))
   41|      1|                {
   42|      1|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
   43|      1|                            token, expected_argument_type, ArgumentType::AddressDisplacement));
   44|       |
   45|      1|                    return {};
   46|      1|                }
   47|       |
   48|       |                // Get address displacement
   49|      0|                PHI_ASSERT(token.HasHint());
   50|       |
   51|      0|                phi::int16_t value = static_cast<phi::int16_t>(token.GetHint());
   52|       |
   53|      0|                if (!tokens.has_x_more(3u))
  ------------------
  |  Branch (53:21): [True: 0, False: 0]
  ------------------
   54|      0|                {
   55|      0|                    program.AddParseError(
   56|      0|                            ConstructTooFewArgumentsAddressDisplacementParseError(token));
   57|      0|                    return {};
   58|      0|                }
   59|       |
   60|      0|                auto         it           = tokens.current_position();
   61|      0|                const Token& first_token  = tokens.consume();
   62|      0|                const Token& second_token = tokens.consume();
   63|      0|                const Token& third_token  = tokens.consume();
   64|       |
   65|      0|                if (first_token.GetType() != Token::Type::OpenBracket)
  ------------------
  |  Branch (65:21): [True: 0, False: 0]
  ------------------
   66|      0|                {
   67|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   68|      0|                            first_token, Token::Type::OpenBracket));
   69|      0|                    return {};
   70|      0|                }
   71|       |
   72|       |                // Second token is the register
   73|      0|                if (second_token.GetType() != Token::Type::RegisterInt)
  ------------------
  |  Branch (73:21): [True: 0, False: 0]
  ------------------
   74|      0|                {
   75|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   76|      0|                            second_token, Token::Type::RegisterInt));
   77|      0|                    return {};
   78|      0|                }
   79|       |
   80|      0|                if (third_token.GetType() != Token::Type::ClosingBracket)
  ------------------
  |  Branch (80:21): [True: 0, False: 0]
  ------------------
   81|      0|                {
   82|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   83|      0|                            third_token, Token::Type::ClosingBracket));
   84|      0|                    return {};
   85|      0|                }
   86|       |
   87|       |                // Consume the 3 tokens
   88|      0|                tokens.set_position(it + 3u);
   89|       |
   90|       |                //DLX_INFO("Parsed address displacement with '{}' displacement and Register '{}'",
   91|       |                //             value, dlx::enum_name(reg_id));
   92|       |
   93|      0|                return ConstructInstructionArgumentAddressDisplacement(
   94|      0|                        static_cast<IntRegisterID>(second_token.GetHint()), value);
   95|      0|            }
   96|      0|            case Token::Type::RegisterInt: {
  ------------------
  |  Branch (96:13): [True: 0, False: 726]
  ------------------
   97|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::IntRegister))
  ------------------
  |  Branch (97:21): [True: 0, False: 0]
  ------------------
   98|      0|                {
   99|      0|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  100|      0|                            token, expected_argument_type, ArgumentType::IntRegister));
  101|      0|                    return {};
  102|      0|                }
  103|       |
  104|       |                //DLX_INFO("Parsed identifier as int register {}",
  105|       |                //             dlx::enum_name(reg_id));
  106|       |
  107|      0|                return ConstructInstructionArgumentRegisterInt(
  108|      0|                        static_cast<IntRegisterID>(token.GetHint()));
  109|      0|            }
  110|      0|            case Token::Type::RegisterFloat: {
  ------------------
  |  Branch (110:13): [True: 0, False: 726]
  ------------------
  111|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::FloatRegister))
  ------------------
  |  Branch (111:21): [True: 0, False: 0]
  ------------------
  112|      0|                {
  113|      0|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  114|      0|                            token, expected_argument_type, ArgumentType::FloatRegister));
  115|      0|                    return {};
  116|      0|                }
  117|       |
  118|       |                //DLX_INFO("Parsed identifier as float register {}",
  119|       |                //             dlx::enum_name(float_reg_id));
  120|       |
  121|      0|                return ConstructInstructionArgumentRegisterFloat(
  122|      0|                        static_cast<FloatRegisterID>(token.GetHint()));
  123|      0|            }
  124|      0|            case Token::Type::RegisterStatus: {
  ------------------
  |  Branch (124:13): [True: 0, False: 726]
  ------------------
  125|      0|                program.AddParseError(ConstructReservedIdentifierParseError(token));
  126|       |
  127|      0|                return {};
  128|      0|            }
  129|    542|            case Token::Type::LabelIdentifier: {
  ------------------
  |  Branch (129:13): [True: 542, False: 184]
  ------------------
  130|       |                // Parse as Label
  131|    542|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::Label))
  ------------------
  |  Branch (131:21): [True: 53, False: 489]
  ------------------
  132|     53|                {
  133|     53|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  134|     53|                            token, expected_argument_type, ArgumentType::Label));
  135|     53|                    return {};
  136|     53|                }
  137|       |
  138|    489|                if (IsReservedIdentifier(token.GetText()))
  ------------------
  |  Branch (138:21): [True: 0, False: 489]
  ------------------
  139|      0|                {
  140|      0|                    program.AddParseError(ConstructReservedIdentifierParseError(token));
  141|      0|                    return {};
  142|      0|                }
  143|       |
  144|    489|                if (!IsValidIdentifier(token.GetText()))
  ------------------
  |  Branch (144:21): [True: 362, False: 127]
  ------------------
  145|    362|                {
  146|    362|                    program.AddParseError(ConstructInvalidLabelIdentifierParseError(token));
  147|    362|                    return {};
  148|    362|                }
  149|       |
  150|       |                //DLX_INFO("Parsed Label identifier as '{}'", token.GetText());
  151|       |
  152|    127|                return ConstructInstructionArgumentLabel(token.GetText());
  153|    489|            }
  154|      6|            case Token::Type::ImmediateInteger: {
  ------------------
  |  Branch (154:13): [True: 6, False: 720]
  ------------------
  155|      6|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::ImmediateInteger))
  ------------------
  |  Branch (155:21): [True: 6, False: 0]
  ------------------
  156|      6|                {
  157|      6|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  158|      6|                            token, expected_argument_type, ArgumentType::ImmediateInteger));
  159|      6|                    return {};
  160|      6|                }
  161|       |
  162|      0|                if (token.HasHint())
  ------------------
  |  Branch (162:21): [True: 0, False: 0]
  ------------------
  163|      0|                {
  164|      0|                    return ConstructInstructionArgumentImmediateValue(
  165|      0|                            static_cast<phi::int16_t>(token.GetHint()));
  166|      0|                }
  167|       |
  168|      0|                program.AddParseError(ConstructInvalidNumberParseError(token));
  169|      0|                return {};
  170|      0|            }
  171|       |
  172|    177|            default:
  ------------------
  |  Branch (172:13): [True: 177, False: 549]
  ------------------
  173|    177|                program.AddParseError(
  174|    177|                        ConstructUnexpectedTokenParseError(token, Token::Type::Unknown));
  175|    177|                return {};
  176|    726|        }
  177|    726|    }
Parser.cpp:_ZZN3dlx6Parser5ParseERNS_11TokenStreamEENK3$_0clERKNS_5TokenE:
  246|  11.1k|                                tokens.find_first_token_if([&](const Token& t) {
  247|  11.1k|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (247:41): [True: 9.47k, False: 1.70k]
  ------------------
  248|  9.47k|                                    {
  249|  9.47k|                                        phi::string_view token_label_name = t.GetText();
  250|  9.47k|                                        token_label_name.remove_suffix(1u);
  251|       |
  252|  9.47k|                                        if (token_label_name == label_name)
  ------------------
  |  Branch (252:45): [True: 4.79k, False: 4.68k]
  ------------------
  253|  4.79k|                                        {
  254|  4.79k|                                            return true;
  255|  4.79k|                                        }
  256|  9.47k|                                    }
  257|       |
  258|  6.39k|                                    return false;
  259|  11.1k|                                });

_ZN3dlx9ProcessorC2Ev:
   62|  6.34k|    {
   63|       |        // Mark R0 as ready only
   64|  6.34k|        m_IntRegisters[0].SetReadOnly(true);
   65|  6.34k|    }
_ZN3dlx9Processor11LoadProgramERNS_13ParsedProgramE:
  349|    790|    {
  350|    790|        if (!program.m_ParseErrors.empty())
  ------------------
  |  Branch (350:13): [True: 0, False: 790]
  ------------------
  351|      0|        {
  352|      0|            DLX_WARN("Trying to load program with parsing errors");
  ------------------
  |  |    8|      0|#define DLX_WARN(...)     PHI_EMPTY_MACRO()
  ------------------
  353|      0|            return false;
  354|      0|        }
  355|       |
  356|    790|        m_CurrentProgram = &program;
  357|       |
  358|    790|        m_ProgramCounter               = 0u;
  359|    790|        m_Halted                       = false;
  360|    790|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  361|    790|        m_LastRaisedException          = Exception::None;
  362|    790|        m_CurrentStepCount             = 0u;
  363|       |
  364|    790|        return true;
  365|    790|    }
_ZNK3dlx9Processor8IsHaltedEv:
  543|     14|    {
  544|     14|        return m_Halted;
  545|     14|    }

_ZN3dlx19StringToIntRegisterEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   10|   355k|    {
   11|   355k|        if (token.length() == 2u)
  ------------------
  |  Branch (11:13): [True: 12.2k, False: 343k]
  ------------------
   12|  12.2k|        {
   13|  12.2k|            const char first_char = token[0u];
   14|  12.2k|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (14:17): [True: 10, False: 12.2k]
  |  Branch (14:38): [True: 82, False: 12.1k]
  ------------------
   15|     92|            {
   16|     92|                const char second_char = token[1u];
   17|     92|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (17:21): [True: 83, False: 9]
  |  Branch (17:43): [True: 70, False: 13]
  ------------------
   18|     70|                {
   19|     70|                    return static_cast<IntRegisterID>(second_char - '0');
   20|     70|                }
   21|     92|            }
   22|  12.2k|        }
   23|   343k|        else if (token.length() == 3u)
  ------------------
  |  Branch (23:18): [True: 99.0k, False: 244k]
  ------------------
   24|  99.0k|        {
   25|  99.0k|            const char first_char = token[0u];
   26|  99.0k|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (26:17): [True: 4, False: 99.0k]
  |  Branch (26:38): [True: 86, False: 98.9k]
  ------------------
   27|     90|            {
   28|     90|                const char second_char = token[1u];
   29|     90|                const char third_char  = token[2u];
   30|       |
   31|     90|                switch (second_char)
   32|     90|                {
   33|     56|                    case '1': {
  ------------------
  |  Branch (33:21): [True: 56, False: 34]
  ------------------
   34|     56|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (34:29): [True: 55, False: 1]
  |  Branch (34:50): [True: 3, False: 52]
  ------------------
   35|      3|                        {
   36|      3|                            return static_cast<IntRegisterID>(third_char - '0' + 10);
   37|      3|                        }
   38|     53|                        break;
   39|     56|                    }
   40|     53|                    case '2': {
  ------------------
  |  Branch (40:21): [True: 11, False: 79]
  ------------------
   41|     11|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (41:29): [True: 10, False: 1]
  |  Branch (41:50): [True: 3, False: 7]
  ------------------
   42|      3|                        {
   43|      3|                            return static_cast<IntRegisterID>(third_char - '0' + 20);
   44|      3|                        }
   45|      8|                        break;
   46|     11|                    }
   47|     14|                    case '3': {
  ------------------
  |  Branch (47:21): [True: 14, False: 76]
  ------------------
   48|     14|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (48:29): [True: 3, False: 11]
  |  Branch (48:50): [True: 4, False: 7]
  ------------------
   49|      7|                        {
   50|      7|                            return static_cast<IntRegisterID>(third_char - '0' + 30);
   51|      7|                        }
   52|      7|                        break;
   53|     14|                    }
   54|      9|                    default: {
  ------------------
  |  Branch (54:21): [True: 9, False: 81]
  ------------------
   55|      9|                        break;
   56|     14|                    }
   57|     90|                }
   58|     90|            }
   59|  99.0k|        }
   60|       |
   61|   355k|        return IntRegisterID::None;
   62|   355k|    }
_ZN3dlx21StringToFloatRegisterEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   65|   355k|    {
   66|   355k|        if (token.length() == 2u)
  ------------------
  |  Branch (66:13): [True: 12.1k, False: 343k]
  ------------------
   67|  12.1k|        {
   68|  12.1k|            const char first_char = token[0u];
   69|  12.1k|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (69:17): [True: 1.10k, False: 11.0k]
  |  Branch (69:38): [True: 54, False: 11.0k]
  ------------------
   70|  1.15k|            {
   71|  1.15k|                const char second_char = token[1u];
   72|  1.15k|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (72:21): [True: 1.14k, False: 11]
  |  Branch (72:43): [True: 892, False: 253]
  ------------------
   73|    892|                {
   74|    892|                    return static_cast<FloatRegisterID>(second_char - '0');
   75|    892|                }
   76|  1.15k|            }
   77|  12.1k|        }
   78|   343k|        else if (token.length() == 3u)
  ------------------
  |  Branch (78:18): [True: 99.0k, False: 244k]
  ------------------
   79|  99.0k|        {
   80|  99.0k|            const char first_char = token[0u];
   81|  99.0k|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (81:17): [True: 301, False: 98.7k]
  |  Branch (81:38): [True: 9, False: 98.7k]
  ------------------
   82|    310|            {
   83|    310|                const char second_char = token[1u];
   84|    310|                const char third_char  = token[2u];
   85|       |
   86|    310|                switch (second_char)
   87|    310|                {
   88|     31|                    case '1': {
  ------------------
  |  Branch (88:21): [True: 31, False: 279]
  ------------------
   89|     31|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (89:29): [True: 24, False: 7]
  |  Branch (89:50): [True: 11, False: 13]
  ------------------
   90|     11|                        {
   91|     11|                            return static_cast<FloatRegisterID>(third_char - '0' + 10);
   92|     11|                        }
   93|     20|                        break;
   94|     31|                    }
   95|     70|                    case '2': {
  ------------------
  |  Branch (95:21): [True: 70, False: 240]
  ------------------
   96|     70|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (96:29): [True: 67, False: 3]
  |  Branch (96:50): [True: 3, False: 64]
  ------------------
   97|      3|                        {
   98|      3|                            return static_cast<FloatRegisterID>(third_char - '0' + 20);
   99|      3|                        }
  100|     67|                        break;
  101|     70|                    }
  102|     72|                    case '3': {
  ------------------
  |  Branch (102:21): [True: 72, False: 238]
  ------------------
  103|     72|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (103:29): [True: 38, False: 34]
  |  Branch (103:50): [True: 19, False: 15]
  ------------------
  104|     57|                        {
  105|     57|                            return static_cast<FloatRegisterID>(third_char - '0' + 30);
  106|     57|                        }
  107|     15|                        break;
  108|     72|                    }
  109|    137|                    default: {
  ------------------
  |  Branch (109:21): [True: 137, False: 173]
  ------------------
  110|    137|                        break;
  111|     72|                    }
  112|    310|                }
  113|    310|            }
  114|  99.0k|        }
  115|       |
  116|   354k|        return FloatRegisterID::None;
  117|   355k|    }
_ZN3dlx6IsFPSREN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  120|   353k|    {
  121|   353k|        if (token.length() == 4u)
  ------------------
  |  Branch (121:13): [True: 13.1k, False: 340k]
  ------------------
  122|  13.1k|        {
  123|  13.1k|            const char c1 = token[0u];
  124|  13.1k|            const char c2 = token[1u];
  125|  13.1k|            const char c3 = token[2u];
  126|  13.1k|            const char c4 = token[3u];
  127|       |
  128|  13.1k|            return (c1 == 'F' || c1 == 'f') && (c2 == 'P' || c2 == 'p') &&
  ------------------
  |  Branch (128:21): [True: 151, False: 12.9k]
  |  Branch (128:34): [True: 11, False: 12.9k]
  |  Branch (128:49): [True: 0, False: 162]
  |  Branch (128:62): [True: 11, False: 151]
  ------------------
  129|  13.1k|                   (c3 == 'S' || c3 == 's') && (c4 == 'R' || c4 == 'r');
  ------------------
  |  Branch (129:21): [True: 0, False: 11]
  |  Branch (129:34): [True: 0, False: 11]
  |  Branch (129:49): [True: 0, False: 0]
  |  Branch (129:62): [True: 0, False: 0]
  ------------------
  130|  13.1k|        }
  131|       |
  132|   340k|        return false;
  133|   353k|    }

_ZN3dlx5TokenC2ENS0_4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS2_7integerImEES9_:
   26|   501k|    {}
_ZN3dlx5TokenC2ENS0_4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS2_7integerImEES9_j:
   36|  15.6k|    {}
_ZNK3dlx5Token7GetTypeEv:
   39|  1.33M|    {
   40|  1.33M|        return m_Type;
   41|  1.33M|    }
_ZNK3dlx5Token13GetLineNumberEv:
   49|  1.48M|    {
   50|  1.48M|        return m_LineNumber;
   51|  1.48M|    }
_ZNK3dlx5Token9GetColumnEv:
   54|  4.65M|    {
   55|  4.65M|        return m_Column;
   56|  4.65M|    }
_ZNK3dlx5Token9GetLengthEv:
   59|  3.66M|    {
   60|  3.66M|        return m_Text.length();
   61|  3.66M|    }
_ZNK3dlx5Token7GetTextEv:
   64|   407k|    {
   65|   407k|        return m_Text;
   66|   407k|    }
_ZNK3dlx5Token7HasHintEv:
   78|  1.00k|    {
   79|  1.00k|        return m_HasHint;
   80|  1.00k|    }
_ZNK3dlx5Token7GetHintEv:
   83|  1.00k|    {
   84|  1.00k|        PHI_ASSERT(m_Type == Type::RegisterInt || m_Type == Type::RegisterFloat ||
   85|  1.00k|                   m_Type == Type::IntegerLiteral || m_Type == Type::OpCode ||
   86|  1.00k|                   m_Type == Type::ImmediateInteger);
   87|  1.00k|        PHI_ASSERT(m_HasHint);
   88|       |
   89|  1.00k|        return m_Hint;
   90|  1.00k|    }

_ZN3dlx11TokenStream8finalizeEv:
   28|  8.22k|    {
   29|       |#if defined(PHI_DEBUG)
   30|       |        PHI_ASSERT(!m_Finalized);
   31|       |#endif
   32|       |
   33|  8.22k|        m_Iterator = 0u;
   34|       |#if defined(PHI_DEBUG)
   35|       |        m_Finalized = true;
   36|       |#endif
   37|  8.22k|    }
_ZNK3dlx11TokenStream8has_moreEv:
   54|   525k|    {
   55|   525k|        return m_Iterator < m_Tokens.size();
   56|   525k|    }
_ZNK3dlx11TokenStream11reached_endEv:
   59|   517k|    {
   60|   517k|        return m_Iterator >= m_Tokens.size();
   61|   517k|    }
_ZN3dlx11TokenStream7consumeEv:
   74|   517k|    {
   75|   517k|        PHI_ASSERT(!reached_end());
   76|       |#if defined(PHI_DEBUG)
   77|       |        PHI_ASSERT(m_Finalized);
   78|       |#endif
   79|       |
   80|   517k|        return m_Tokens.at(m_Iterator++.unsafe());
   81|   517k|    }
_ZNK3dlx11TokenStream5beginEv:
  168|  8.22k|    {
  169|       |#if defined(PHI_DEBUG)
  170|       |        //PHI_ASSERT(m_Finalized);
  171|       |#endif
  172|       |
  173|  8.22k|        return m_Tokens.begin();
  174|  8.22k|    }
_ZNK3dlx11TokenStream3endEv:
  186|  8.22k|    {
  187|       |#if defined(PHI_DEBUG)
  188|       |        //PHI_ASSERT(m_Finalized);
  189|       |#endif
  190|       |
  191|  8.22k|        return m_Tokens.end();
  192|  8.22k|    }
_ZNK3dlx11TokenStream6rbeginEv:
  204|  1.27k|    {
  205|       |#if defined(PHI_DEBUG)
  206|       |        //PHI_ASSERT(m_Finalized);
  207|       |#endif
  208|       |
  209|  1.27k|        return m_Tokens.rbegin();
  210|  1.27k|    }
_ZNK3dlx11TokenStream4rendEv:
  213|  3.60k|    {
  214|       |#if defined(PHI_DEBUG)
  215|       |        //PHI_ASSERT(m_Finalized);
  216|       |#endif
  217|       |
  218|  3.60k|        return m_Tokens.rend();
  219|  3.60k|    }

_ZN3dlx8TokenizeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   65|  8.22k|    {
   66|  8.22k|        TokenStream tokens;
   67|       |
   68|  8.22k|        phi::string_view current_token;
   69|       |
   70|  8.22k|        phi::u64 current_line_number{1u};
   71|  8.22k|        phi::u64 current_column{1u};
   72|  8.22k|        phi::u64 token_begin{0u};
   73|       |
   74|  8.22k|        phi::boolean parsing_comment{false};
   75|       |
   76|  3.43M|        for (phi::usize i{0u}; i < source.length(); ++i)
  ------------------
  |  Branch (76:32): [True: 3.42M, False: 8.22k]
  ------------------
   77|  3.42M|        {
   78|  3.42M|            const char c{source.at(i)};
   79|       |
   80|  3.42M|            if (c == '\n')
  ------------------
  |  Branch (80:17): [True: 23.7k, False: 3.40M]
  ------------------
   81|  23.7k|            {
   82|  23.7k|                if (current_token.is_empty())
  ------------------
  |  Branch (82:21): [True: 12.0k, False: 11.7k]
  ------------------
   83|  12.0k|                {
   84|       |                    // Skip empty lines
   85|  12.0k|                    tokens.emplace_back(Token::Type::NewLine, source.substring_view(i, 1u),
   86|  12.0k|                                        current_line_number, current_column);
   87|       |
   88|  12.0k|                    parsing_comment = false;
   89|  12.0k|                    current_line_number += 1u;
   90|  12.0k|                    current_column = 1u;
   91|  12.0k|                    continue;
   92|  12.0k|                }
   93|       |
   94|       |                // Otherwise a new line separates tokens
   95|  11.7k|                tokens.emplace_back(ParseToken(
   96|  11.7k|                        source.substring_view(
   97|  11.7k|                                phi::narrow_cast<phi::string_view::size_type>(token_begin),
   98|  11.7k|                                current_token.length()),
   99|  11.7k|                        current_line_number, current_column - current_token.length()));
  100|       |
  101|  11.7k|                tokens.emplace_back(Token::Type::NewLine, source.substring_view(i, 1u),
  102|  11.7k|                                    current_line_number, current_column);
  103|       |
  104|  11.7k|                current_token   = phi::string_view{};
  105|  11.7k|                parsing_comment = false;
  106|  11.7k|                current_line_number += 1u;
  107|  11.7k|                current_column = 0u;
  108|  11.7k|            }
  109|       |            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  110|  3.40M|            else if (c == '/' || c == ';')
  ------------------
  |  Branch (110:22): [True: 110, False: 3.40M]
  |  Branch (110:34): [True: 330, False: 3.39M]
  ------------------
  111|    440|            {
  112|    440|                if (current_token.is_empty())
  ------------------
  |  Branch (112:21): [True: 80, False: 360]
  ------------------
  113|     80|                {
  114|     80|                    token_begin = i;
  115|     80|                }
  116|    360|                else if (!parsing_comment)
  ------------------
  |  Branch (116:26): [True: 135, False: 225]
  ------------------
  117|    135|                {
  118|    135|                    tokens.emplace_back(ParseToken(
  119|    135|                            source.substring_view(
  120|    135|                                    phi::narrow_cast<phi::string_view::size_type>(token_begin),
  121|    135|                                    current_token.length()),
  122|    135|                            current_line_number, current_column - current_token.length()));
  123|    135|                    token_begin   = i;
  124|    135|                    current_token = phi::string_view{};
  125|    135|                }
  126|       |
  127|    440|                parsing_comment = true;
  128|    440|                current_token   = source.substring_view(
  129|    440|                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  130|    440|                        current_token.length() + 1u);
  131|    440|            }
  132|  3.39M|            else if (parsing_comment)
  ------------------
  |  Branch (132:22): [True: 1.22k, False: 3.39M]
  ------------------
  133|  1.22k|            {
  134|       |                // simply append the character
  135|  1.22k|                current_token = source.substring_view(
  136|  1.22k|                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  137|  1.22k|                        current_token.length() + 1u);
  138|  1.22k|            }
  139|  3.39M|            else
  140|  3.39M|            {
  141|       |                // Not parsing a comment
  142|  3.39M|                switch (c)
  143|  3.39M|                {
  144|   210k|                    case ' ':
  ------------------
  |  Branch (144:21): [True: 210k, False: 3.18M]
  ------------------
  145|   232k|                    case '\t':
  ------------------
  |  Branch (145:21): [True: 22.6k, False: 3.37M]
  ------------------
  146|   232k|                    case '\v':
  ------------------
  |  Branch (146:21): [True: 47, False: 3.39M]
  ------------------
  147|   232k|                        if (current_token.is_empty())
  ------------------
  |  Branch (147:29): [True: 38.7k, False: 194k]
  ------------------
  148|  38.7k|                        {
  149|  38.7k|                            current_column += 1u;
  150|       |                            // We haven't found any usable character for the current token so just skip the whitespace.
  151|  38.7k|                            continue;
  152|  38.7k|                        }
  153|       |
  154|       |                        // Otherwise a whitespace separates tokens
  155|   194k|                        tokens.emplace_back(ParseToken(
  156|   194k|                                source.substring_view(
  157|   194k|                                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  158|   194k|                                        current_token.length()),
  159|   194k|                                current_line_number, current_column - current_token.length()));
  160|   194k|                        current_token = phi::string_view{};
  161|   194k|                        break;
  162|  16.3k|                    case ':':
  ------------------
  |  Branch (162:21): [True: 16.3k, False: 3.38M]
  ------------------
  163|       |                        // Need to parse label names together with their colon
  164|  16.3k|                        if (!current_token.is_empty())
  ------------------
  |  Branch (164:29): [True: 13.4k, False: 2.84k]
  ------------------
  165|  13.4k|                        {
  166|  13.4k|                            current_token = source.substring_view(
  167|  13.4k|                                    phi::narrow_cast<phi::string_view::size_type>(token_begin),
  168|  13.4k|                                    current_token.length() + 1u);
  169|  13.4k|                            tokens.emplace_back(ParseToken(
  170|  13.4k|                                    source.substring_view(
  171|  13.4k|                                            phi::narrow_cast<phi::string_view::size_type>(
  172|  13.4k|                                                    token_begin),
  173|  13.4k|                                            current_token.length()),
  174|  13.4k|                                    current_line_number,
  175|  13.4k|                                    current_column + 1u - current_token.length()));
  176|       |
  177|  13.4k|                            current_token = phi::string_view{};
  178|  13.4k|                        }
  179|  2.84k|                        else
  180|  2.84k|                        {
  181|       |                            // Orphan colon
  182|  2.84k|                            token_begin = i;
  183|       |
  184|  2.84k|                            tokens.emplace_back(
  185|  2.84k|                                    Token::Type::Colon,
  186|  2.84k|                                    source.substring_view(
  187|  2.84k|                                            phi::narrow_cast<phi::string_view::size_type>(
  188|  2.84k|                                                    token_begin),
  189|  2.84k|                                            1u),
  190|  2.84k|                                    current_line_number, current_column);
  191|  2.84k|                        }
  192|  16.3k|                        break;
  193|   147k|                    case ',':
  ------------------
  |  Branch (193:21): [True: 147k, False: 3.25M]
  ------------------
  194|   147k|                    case '(':
  ------------------
  |  Branch (194:21): [True: 350, False: 3.39M]
  ------------------
  195|   148k|                    case ')':
  ------------------
  |  Branch (195:21): [True: 891, False: 3.39M]
  ------------------
  196|   148k|                        if (!current_token.is_empty())
  ------------------
  |  Branch (196:29): [True: 118k, False: 29.5k]
  ------------------
  197|   118k|                        {
  198|   118k|                            tokens.emplace_back(ParseToken(
  199|   118k|                                    source.substring_view(
  200|   118k|                                            phi::narrow_cast<phi::string_view::size_type>(
  201|   118k|                                                    token_begin),
  202|   118k|                                            current_token.length()),
  203|   118k|                                    current_line_number, current_column - current_token.length()));
  204|       |
  205|   118k|                            current_token = phi::string_view{};
  206|   118k|                        }
  207|       |
  208|   148k|                        Token::Type type;
  209|   148k|                        switch (c)
  210|   148k|                        {
  211|   147k|                            case ',':
  ------------------
  |  Branch (211:29): [True: 147k, False: 1.24k]
  ------------------
  212|   147k|                                type = Token::Type::Comma;
  213|   147k|                                break;
  214|    350|                            case '(':
  ------------------
  |  Branch (214:29): [True: 350, False: 147k]
  ------------------
  215|    350|                                type = Token::Type::OpenBracket;
  216|    350|                                break;
  217|    891|                            case ')':
  ------------------
  |  Branch (217:29): [True: 891, False: 147k]
  ------------------
  218|    891|                                type = Token::Type::ClosingBracket;
  219|    891|                                break;
  220|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  221|      0|                            default:
  ------------------
  |  Branch (221:29): [True: 0, False: 148k]
  ------------------
  222|      0|                                PHI_ASSERT_NOT_REACHED();
  223|      0|                                break;
  224|   148k|#endif
  225|   148k|                        }
  226|       |
  227|   148k|                        token_begin = i;
  228|       |
  229|   148k|                        tokens.emplace_back(
  230|   148k|                                type,
  231|   148k|                                source.substring_view(
  232|   148k|                                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  233|   148k|                                        1u),
  234|   148k|                                current_line_number, current_column);
  235|   148k|                        break;
  236|       |
  237|  3.00M|                    default:
  ------------------
  |  Branch (237:21): [True: 3.00M, False: 397k]
  ------------------
  238|  3.00M|                        if (current_token.is_empty())
  ------------------
  |  Branch (238:29): [True: 342k, False: 2.65M]
  ------------------
  239|   342k|                        {
  240|   342k|                            token_begin = i;
  241|   342k|                        }
  242|       |
  243|       |                        // simply append the character
  244|  3.00M|                        current_token = source.substring_view(
  245|  3.00M|                                phi::narrow_cast<phi::string_view::size_type>(token_begin),
  246|  3.00M|                                current_token.length() + 1u);
  247|  3.39M|                }
  248|  3.39M|            }
  249|       |
  250|  3.37M|            current_column += 1u;
  251|  3.37M|        }
  252|       |
  253|       |        // Checked the entire string. Parse whats left if anything
  254|  8.22k|        if (!current_token.is_empty())
  ------------------
  |  Branch (254:13): [True: 4.30k, False: 3.92k]
  ------------------
  255|  4.30k|        {
  256|  4.30k|            tokens.emplace_back(
  257|  4.30k|                    ParseToken(source.substring_view(
  258|  4.30k|                                       phi::narrow_cast<phi::string_view::size_type>(token_begin),
  259|  4.30k|                                       current_token.length()),
  260|  4.30k|                               current_line_number, current_column - current_token.length()));
  261|  4.30k|        }
  262|       |
  263|       |        // Finalize token stream
  264|  8.22k|        tokens.finalize();
  265|       |
  266|  8.22k|        return tokens;
  267|  8.22k|    }
Tokenize.cpp:_ZN3dlxL10ParseTokenEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS0_7integerImEES7_:
   13|   342k|    {
   14|   342k|        if (token.at(0u) == '#' && token.length() > 1u)
  ------------------
  |  Branch (14:13): [True: 113, False: 342k]
  |  Branch (14:13): [True: 90, False: 342k]
  |  Branch (14:36): [True: 90, False: 23]
  ------------------
   15|     90|        {
   16|     90|            auto number = ParseNumber(token.substring_view(1u));
   17|       |
   18|     90|            if (number)
  ------------------
  |  Branch (18:17): [True: 63, False: 27]
  ------------------
   19|     63|            {
   20|     63|                return {Token::Type::ImmediateInteger, token, line_number, column,
   21|     63|                        static_cast<phi::uint32_t>(number.value().unsafe())};
   22|     63|            }
   23|       |
   24|     27|            return {Token::Type::ImmediateInteger, token, line_number, column};
   25|     90|        }
   26|       |
   27|   342k|        if (token.at(0u) == '/' || token.at(0u) == ';')
  ------------------
  |  Branch (27:13): [True: 49, False: 342k]
  |  Branch (27:13): [True: 215, False: 342k]
  |  Branch (27:36): [True: 166, False: 342k]
  ------------------
   28|    215|        {
   29|    215|            return {Token::Type::Comment, token, line_number, column};
   30|    215|        }
   31|       |
   32|   342k|        if (phi::optional<phi::i16> number = ParseNumber(token); number.has_value())
  ------------------
  |  Branch (32:66): [True: 387, False: 341k]
  ------------------
   33|    387|        {
   34|    387|            return {Token::Type::IntegerLiteral, token, line_number, column,
   35|    387|                    static_cast<phi::uint32_t>(number->unsafe())};
   36|    387|        }
   37|       |
   38|   341k|        if (IsFPSR(token))
  ------------------
  |  Branch (38:13): [True: 0, False: 341k]
  ------------------
   39|      0|        {
   40|      0|            return {Token::Type::RegisterStatus, token, line_number, column};
   41|      0|        }
   42|       |
   43|   341k|        if (IntRegisterID id = StringToIntRegister(token); id != IntRegisterID::None)
  ------------------
  |  Branch (43:60): [True: 19, False: 341k]
  ------------------
   44|     19|        {
   45|     19|            return {Token::Type::RegisterInt, token, line_number, column,
   46|     19|                    static_cast<phi::uint32_t>(id)};
   47|     19|        }
   48|       |
   49|   341k|        if (FloatRegisterID id = StringToFloatRegister(token); id != FloatRegisterID::None)
  ------------------
  |  Branch (49:64): [True: 804, False: 341k]
  ------------------
   50|    804|        {
   51|    804|            return {Token::Type::RegisterFloat, token, line_number, column,
   52|    804|                    static_cast<phi::uint32_t>(id)};
   53|    804|        }
   54|       |
   55|   341k|        if (OpCode opcode = StringToOpCode(token); opcode != OpCode::NONE)
  ------------------
  |  Branch (55:52): [True: 14.3k, False: 326k]
  ------------------
   56|  14.3k|        {
   57|  14.3k|            return {Token::Type::OpCode, token, line_number, column,
   58|  14.3k|                    static_cast<phi::uint32_t>(opcode)};
   59|  14.3k|        }
   60|       |
   61|   326k|        return {Token::Type::LabelIdentifier, token, line_number, column};
   62|   341k|    }

_ZN3fmt3v106detail11to_unsignedIiEENSt3__113make_unsignedIT_E4typeES5_:
  377|   777k|    typename std::make_unsigned<Int>::type {
  378|   777k|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  336|  1.55M|      fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (336:35): [Folded - Ignored]
  |  |  |  Branch (336:35): [True: 777k, False: 0]
  |  |  ------------------
  ------------------
  379|   777k|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  380|   777k|}
_ZN3fmt3v106detail13ignore_unusedIJbA15_cEEEvDpRKT_:
  304|  5.45M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt3v1017basic_string_viewIcE4sizeEv:
  445|  2.72M|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt3v106detail13ignore_unusedIJbA1_cEEEvDpRKT_:
  304|   777k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt3v106detail6bufferIcE4sizeEv:
  840|  1.07M|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt3v106detail6bufferIcEC2EPcmm:
  812|   492k|      : ptr_(p), size_(sz), capacity_(cap) {}
_ZN3fmt3v106detail6bufferIcE3setEPcm:
  818|   781k|  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  819|   781k|    ptr_ = buf_data;
  820|   781k|    capacity_ = buf_capacity;
  821|   781k|  }
_ZN3fmt3v106detail13ignore_unusedIJbEEEvDpRKT_:
  304|   289k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt3v106detail6bufferIcE8capacityEv:
  843|   437k|  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
_ZN3fmt3v106detail6bufferIcE4dataEv:
  846|   781k|  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
_ZNK3fmt3v1017basic_string_viewIcE5beginEv:
  447|   976k|  constexpr auto begin() const noexcept -> iterator { return data_; }
_ZNK3fmt3v1017basic_string_viewIcE3endEv:
  448|   976k|  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
_ZN3fmt3v1017basic_string_viewIcEC2EPKc:
  428|   767k|                  : std::char_traits<Char>::length(s)) {}
_ZN3fmt3v106detail10locale_refC2Ev:
 1536|  1.25M|  constexpr FMT_INLINE locale_ref() : locale_(nullptr) {}
_ZNK3fmt3v1019basic_format_stringIcJEEcvNS0_17basic_string_viewIcEEEv:
 2759|  13.2k|  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
_ZN3fmt3v1016make_format_argsINS0_20basic_format_contextINS0_8appenderEcEEJEEENS0_16format_arg_storeIT_JDpNSt3__19remove_cvINS7_16remove_referenceIT0_E4typeEE4typeEEEEDpRSA_:
 1827|  13.2k|    -> format_arg_store<Context, remove_cvref_t<T>...> {
 1828|  13.2k|  return {args...};
 1829|  13.2k|}
_ZN3fmt3v1016format_arg_storeINS0_20basic_format_contextINS0_8appenderEcEEJEEC2IJEEEDpRT_:
 1810|  13.2k|        data_{detail::make_arg<is_packed, Context>(args)...} {
 1811|  13.2k|    if (detail::const_check(num_named_args != 0))
  ------------------
  |  Branch (1811:9): [Folded - Ignored]
  ------------------
 1812|      0|      detail::init_named_args(data_.named_args(), 0, 0, args...);
 1813|  13.2k|  }
_ZN3fmt3v106detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EEC2IJEEEDpRKT_:
 1170|  13.2k|  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
_ZN3fmt3v106detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1263|   790k|  constexpr FMT_INLINE value() : no_value() {}
_ZN3fmt3v109monostateC2Ev:
  279|   790k|  constexpr monostate() {}
_ZN3fmt3v1017basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEC2IJEEERKNS0_16format_arg_storeIS4_JDpT_EEE:
 1911|  13.2k|                          store.data_.args()) {}
_ZNK3fmt3v106detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm0ELm0EE4argsEv:
 1171|  13.2k|  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
_ZN3fmt3v1017basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEC2EyPKNS0_6detail5valueIS4_EE:
 1895|   492k|      : desc_(desc), values_(values) {}
_ZNK3fmt3v1017basic_string_viewIcE4dataEv:
  442|  1.25M|  constexpr auto data() const noexcept -> const Char* { return data_; }
_ZN3fmt3v1017basic_string_viewIcEC2EPKcm:
  413|   976k|      : data_(s), size_(count) {}
_ZN3fmt3v106detail11to_unsignedIlEENSt3__113make_unsignedIT_E4typeES5_:
  377|  4.67M|    typename std::make_unsigned<Int>::type {
  378|  4.67M|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  336|  9.34M|      fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (336:35): [Folded - Ignored]
  |  |  |  Branch (336:35): [True: 4.67M, False: 0]
  |  |  ------------------
  ------------------
  379|  4.67M|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  380|  4.67M|}
_ZN3fmt3v106detail6bufferIcE11try_reserveEm:
  863|  1.75M|  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
  864|  1.75M|    if (new_capacity > capacity_) grow(new_capacity);
  ------------------
  |  Branch (864:9): [True: 289k, False: 1.46M]
  ------------------
  865|  1.75M|  }
_ZNK3fmt3v1017basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE3getEi:
 1933|   777k|  FMT_CONSTEXPR auto get(int id) const -> format_arg {
 1934|   777k|    format_arg arg;
 1935|   777k|    if (!is_packed()) {
  ------------------
  |  Branch (1935:9): [True: 0, False: 777k]
  ------------------
 1936|      0|      if (id < max_size()) arg = args_[id];
  ------------------
  |  Branch (1936:11): [True: 0, False: 0]
  ------------------
 1937|      0|      return arg;
 1938|      0|    }
 1939|   777k|    if (id >= detail::max_packed_args) return arg;
  ------------------
  |  Branch (1939:9): [True: 0, False: 777k]
  ------------------
 1940|   777k|    arg.type_ = type(id);
 1941|   777k|    if (arg.type_ == detail::type::none_type) return arg;
  ------------------
  |  Branch (1941:9): [True: 0, False: 777k]
  ------------------
 1942|   777k|    arg.value_ = values_[id];
 1943|   777k|    return arg;
 1944|   777k|  }
_ZN3fmt3v1016basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1644|   777k|  constexpr basic_format_arg() : type_(detail::type::none_type) {}
_ZNK3fmt3v1017basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE9is_packedEv:
 1880|   777k|  constexpr auto is_packed() const -> bool {
 1881|   777k|    return (desc_ & detail::is_unpacked_bit) == 0;
 1882|   777k|  }
_ZNK3fmt3v1017basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE4typeEi:
 1887|   777k|  FMT_CONSTEXPR auto type(int index) const -> detail::type {
 1888|   777k|    int shift = index * detail::packed_arg_bits;
 1889|   777k|    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
 1890|   777k|    return static_cast<detail::type>((desc_ >> shift) & mask);
 1891|   777k|  }
_ZNK3fmt3v1016basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEcvbEv:
 1646|   777k|  constexpr explicit operator bool() const noexcept {
 1647|   777k|    return type_ != detail::type::none_type;
 1648|   777k|  }
_ZN3fmt3v106detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EE:
  768|  1.75M|    -> Container& {
  769|  1.75M|  using base = std::back_insert_iterator<Container>;
  770|  1.75M|  struct accessor : base {
  771|  1.75M|    accessor(base b) : base(b) {}
  772|  1.75M|    using base::container;
  773|  1.75M|  };
  774|  1.75M|  return *accessor(it).container;
  775|  1.75M|}
_ZZN3fmt3v106detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EEEN8accessorC2ENS8_IS4_EE:
  771|  1.75M|    accessor(base b) : base(b) {}
_ZN3fmt3v106detail13ignore_unusedIJbA20_cEEEvDpRKT_:
  304|  10.1k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt3v106detail8copy_strIcPcEENS0_8appenderET0_S5_S4_:
 1490|  10.1k|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1491|  10.1k|  get_container(out).append(begin, end);
 1492|  10.1k|  return out;
 1493|  10.1k|}
_ZNK3fmt3v106detail6fill_tIcE4sizeEv:
 2011|   767k|  constexpr auto size() const -> size_t { return size_; }
_ZN3fmt3v106detail8copy_strIcPKcEENS0_8appenderET0_S6_S5_:
 1490|  1.74M|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1491|  1.74M|  get_container(out).append(begin, end);
 1492|  1.74M|  return out;
 1493|  1.74M|}
_ZN3fmt3v1012format_specsIcEC2Ev:
 2061|   777k|        localized(false) {}
_ZN3fmt3v1026basic_format_parse_contextIcEC2ENS0_17basic_string_viewIcEEi:
  671|   492k|      : format_str_(format_str), next_arg_id_(next_arg_id) {}
_ZN3fmt3v1020basic_format_contextINS0_8appenderEcEC2ES2_NS0_17basic_format_argsIS3_EENS0_6detail10locale_refE:
 1733|   492k|      : out_(out), args_(ctx_args), loc_(loc) {}
_ZN3fmt3v1020basic_format_contextINS0_8appenderEcE3outEv:
 1748|  1.75M|  FMT_CONSTEXPR auto out() -> iterator { return out_; }
_ZN3fmt3v106detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_:
 2490|   492k|    basic_string_view<Char> format_str, Handler&& handler) {
 2491|   492k|  auto begin = format_str.data();
 2492|   492k|  auto end = begin + format_str.size();
 2493|   492k|  if (end - begin < 32) {
  ------------------
  |  Branch (2493:7): [True: 2.18k, False: 490k]
  ------------------
 2494|       |    // Use a simple loop instead of memchr for small strings.
 2495|  2.18k|    const Char* p = begin;
 2496|  62.6k|    while (p != end) {
  ------------------
  |  Branch (2496:12): [True: 60.4k, False: 2.18k]
  ------------------
 2497|  60.4k|      auto c = *p++;
 2498|  60.4k|      if (c == '{') {
  ------------------
  |  Branch (2498:11): [True: 2.18k, False: 58.2k]
  ------------------
 2499|  2.18k|        handler.on_text(begin, p - 1);
 2500|  2.18k|        begin = p = parse_replacement_field(p - 1, end, handler);
 2501|  58.2k|      } else if (c == '}') {
  ------------------
  |  Branch (2501:18): [True: 0, False: 58.2k]
  ------------------
 2502|      0|        if (p == end || *p != '}')
  ------------------
  |  Branch (2502:13): [True: 0, False: 0]
  |  Branch (2502:25): [True: 0, False: 0]
  ------------------
 2503|      0|          return handler.on_error("unmatched '}' in format string");
 2504|      0|        handler.on_text(begin, p);
 2505|      0|        begin = ++p;
 2506|      0|      }
 2507|  60.4k|    }
 2508|  2.18k|    handler.on_text(begin, end);
 2509|  2.18k|    return;
 2510|  2.18k|  }
 2511|   490k|  struct writer {
 2512|   490k|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2513|   490k|      if (from == to) return;
 2514|   490k|      for (;;) {
 2515|   490k|        const Char* p = nullptr;
 2516|   490k|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
 2517|   490k|          return handler_.on_text(from, to);
 2518|   490k|        ++p;
 2519|   490k|        if (p == to || *p != '}')
 2520|   490k|          return handler_.on_error("unmatched '}' in format string");
 2521|   490k|        handler_.on_text(from, p);
 2522|   490k|        from = p + 1;
 2523|   490k|      }
 2524|   490k|    }
 2525|   490k|    Handler& handler_;
 2526|   490k|  } write = {handler};
 2527|  1.26M|  while (begin != end) {
  ------------------
  |  Branch (2527:10): [True: 972k, False: 293k]
  ------------------
 2528|       |    // Doing two passes with memchr (one for '{' and another for '}') is up to
 2529|       |    // 2.5x faster than the naive one-pass implementation on big format strings.
 2530|   972k|    const Char* p = begin;
 2531|   972k|    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
  ------------------
  |  Branch (2531:9): [True: 972k, False: 0]
  |  Branch (2531:26): [True: 196k, False: 775k]
  ------------------
 2532|   196k|      return write(begin, end);
 2533|   775k|    write(begin, p);
 2534|   775k|    begin = parse_replacement_field(p, end, handler);
 2535|   775k|  }
 2536|   490k|}
_ZN3fmt3v1020basic_format_contextINS0_8appenderEcE10advance_toES2_:
 1751|  1.75M|  void advance_to(iterator it) {
 1752|  1.75M|    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
  ------------------
  |  Branch (1752:9): [Folded - Ignored]
  ------------------
 1753|  1.75M|  }
_ZN3fmt3v106detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_:
 2453|   777k|                                           Handler&& handler) -> const Char* {
 2454|   777k|  struct id_adapter {
 2455|   777k|    Handler& handler;
 2456|   777k|    int arg_id;
 2457|       |
 2458|   777k|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
 2459|   777k|    FMT_CONSTEXPR void on_index(int id) { arg_id = handler.on_arg_id(id); }
 2460|   777k|    FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
 2461|   777k|      arg_id = handler.on_arg_id(id);
 2462|   777k|    }
 2463|   777k|  };
 2464|       |
 2465|   777k|  ++begin;
 2466|   777k|  if (begin == end) return handler.on_error("invalid format string"), end;
  ------------------
  |  Branch (2466:7): [True: 0, False: 777k]
  ------------------
 2467|   777k|  if (*begin == '}') {
  ------------------
  |  Branch (2467:7): [True: 0, False: 777k]
  ------------------
 2468|      0|    handler.on_replacement_field(handler.on_arg_id(), begin);
 2469|   777k|  } else if (*begin == '{') {
  ------------------
  |  Branch (2469:14): [True: 0, False: 777k]
  ------------------
 2470|      0|    handler.on_text(begin, begin + 1);
 2471|   777k|  } else {
 2472|   777k|    auto adapter = id_adapter{handler, 0};
 2473|   777k|    begin = parse_arg_id(begin, end, adapter);
 2474|   777k|    Char c = begin != end ? *begin : Char();
  ------------------
  |  Branch (2474:14): [True: 777k, False: 0]
  ------------------
 2475|   777k|    if (c == '}') {
  ------------------
  |  Branch (2475:9): [True: 0, False: 777k]
  ------------------
 2476|      0|      handler.on_replacement_field(adapter.arg_id, begin);
 2477|   777k|    } else if (c == ':') {
  ------------------
  |  Branch (2477:16): [True: 777k, False: 0]
  ------------------
 2478|   777k|      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
 2479|   777k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (2479:11): [True: 0, False: 777k]
  |  Branch (2479:27): [True: 0, False: 777k]
  ------------------
 2480|      0|        return handler.on_error("unknown format specifier"), end;
 2481|   777k|    } else {
 2482|      0|      return handler.on_error("missing '}' in format string"), end;
 2483|      0|    }
 2484|   777k|  }
 2485|   777k|  return begin + 1;
 2486|   777k|}
_ZNK3fmt3v1020basic_format_contextINS0_8appenderEcE3argEi:
 1735|   777k|  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
_ZN3fmt3v1020basic_format_contextINS0_8appenderEcE6localeEv:
 1755|   777k|  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
_ZN3fmt3v1026basic_format_parse_contextIcE11next_arg_idEv:
  695|   777k|  FMT_CONSTEXPR auto next_arg_id() -> int {
  696|   777k|    if (next_arg_id_ < 0) {
  ------------------
  |  Branch (696:9): [True: 0, False: 777k]
  ------------------
  697|      0|      detail::throw_format_error(
  698|      0|          "cannot switch from manual to automatic argument indexing");
  699|      0|      return 0;
  700|      0|    }
  701|   777k|    int id = next_arg_id_++;
  702|   777k|    do_check_arg_id(id);
  703|   777k|    return id;
  704|   777k|  }
_ZN3fmt3v1026basic_format_parse_contextIcE15do_check_arg_idEi:
 1042|   777k|FMT_CONSTEXPR void basic_format_parse_context<Char>::do_check_arg_id(int id) {
 1043|       |  // Argument id is only checked at compile-time during parsing because
 1044|       |  // formatting has its own validation.
 1045|   777k|  if (detail::is_constant_evaluated() &&
  ------------------
  |  Branch (1045:7): [Folded - Ignored]
  ------------------
 1046|   777k|      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   33|      0|#  define FMT_GCC_VERSION 0
  ------------------
                    (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   33|      0|#  define FMT_GCC_VERSION 0
  ------------------
  |  Branch (1046:8): [Folded - Ignored]
  |  Branch (1046:28): [Folded - Ignored]
  ------------------
 1047|      0|    using context = detail::compile_parse_context<Char>;
 1048|      0|    if (id >= static_cast<context*>(this)->num_args())
  ------------------
  |  Branch (1048:9): [True: 0, False: 0]
  ------------------
 1049|      0|      detail::throw_format_error("argument not found");
 1050|      0|  }
 1051|   777k|}
_ZN3fmt3v106detail12parse_arg_idIcRZNS1_23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS6_EENS1_12vformat_argsIS6_E4typeENS1_10locale_refEE14format_handlerEEPKS6_SI_SI_OT0_E10id_adapterEESI_SI_SI_SK_:
 2209|   777k|                                           Handler&& handler) -> const Char* {
 2210|   777k|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  336|   777k|      fmt::detail::ignore_unused((condition), (message))
  ------------------
 2211|   777k|  Char c = *begin;
 2212|   777k|  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
  ------------------
  |  Branch (2212:7): [True: 777k, False: 0]
  |  Branch (2212:19): [True: 0, False: 777k]
  ------------------
 2213|   777k|  handler.on_auto();
 2214|   777k|  return begin;
 2215|   777k|}
_ZZN3fmt3v106detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_EN10id_adapter7on_autoEv:
 2458|   777k|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
_ZNK3fmt3v1016basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEE4typeEv:
 1650|  1.55M|  auto type() const -> detail::type { return type_; }
_ZN3fmt3v106detail7arg_refIcEC2Ev:
 2070|  1.55M|  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
_ZN3fmt3v106detail7arg_refIcE5valueC2Ei:
 2085|  1.55M|    FMT_CONSTEXPR value(int idx = 0) : index(idx) {}
_ZN3fmt3v106detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeE:
 2279|   777k|    basic_format_parse_context<Char>& ctx, type arg_type) -> const Char* {
 2280|   777k|  auto c = '\0';
 2281|   777k|  if (end - begin > 1) {
  ------------------
  |  Branch (2281:7): [True: 777k, False: 0]
  ------------------
 2282|   777k|    auto next = to_ascii(begin[1]);
 2283|   777k|    c = parse_align(next) == align::none ? to_ascii(*begin) : '\0';
  ------------------
  |  Branch (2283:9): [True: 777k, False: 0]
  ------------------
 2284|   777k|  } else {
 2285|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2285:9): [True: 0, False: 0]
  ------------------
 2286|      0|    c = to_ascii(*begin);
 2287|      0|  }
 2288|       |
 2289|   777k|  struct {
 2290|   777k|    state current_state = state::start;
 2291|   777k|    FMT_CONSTEXPR void operator()(state s, bool valid = true) {
 2292|   777k|      if (current_state >= s || !valid)
 2293|   777k|        throw_format_error("invalid format specifier");
 2294|   777k|      current_state = s;
 2295|   777k|    }
 2296|   777k|  } enter_state;
 2297|       |
 2298|   777k|  using pres = presentation_type;
 2299|   777k|  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
 2300|   777k|  struct {
 2301|   777k|    const Char*& begin;
 2302|   777k|    dynamic_format_specs<Char>& specs;
 2303|   777k|    type arg_type;
 2304|       |
 2305|   777k|    FMT_CONSTEXPR auto operator()(pres pres_type, int set) -> const Char* {
 2306|   777k|      if (!in(arg_type, set)) {
 2307|   777k|        if (arg_type == type::none_type) return begin;
 2308|   777k|        throw_format_error("invalid format specifier");
 2309|   777k|      }
 2310|   777k|      specs.type = pres_type;
 2311|   777k|      return begin + 1;
 2312|   777k|    }
 2313|   777k|  } parse_presentation_type{begin, specs, arg_type};
 2314|       |
 2315|   777k|  for (;;) {
 2316|   777k|    switch (c) {
 2317|      0|    case '<':
  ------------------
  |  Branch (2317:5): [True: 0, False: 777k]
  ------------------
 2318|      0|    case '>':
  ------------------
  |  Branch (2318:5): [True: 0, False: 777k]
  ------------------
 2319|      0|    case '^':
  ------------------
  |  Branch (2319:5): [True: 0, False: 777k]
  ------------------
 2320|      0|      enter_state(state::align);
 2321|      0|      specs.align = parse_align(c);
 2322|      0|      ++begin;
 2323|      0|      break;
 2324|      0|    case '+':
  ------------------
  |  Branch (2324:5): [True: 0, False: 777k]
  ------------------
 2325|      0|    case '-':
  ------------------
  |  Branch (2325:5): [True: 0, False: 777k]
  ------------------
 2326|      0|    case ' ':
  ------------------
  |  Branch (2326:5): [True: 0, False: 777k]
  ------------------
 2327|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2327:11): [True: 0, False: 0]
  ------------------
 2328|      0|      enter_state(state::sign, in(arg_type, sint_set | float_set));
 2329|      0|      switch (c) {
  ------------------
  |  Branch (2329:15): [True: 0, False: 0]
  ------------------
 2330|      0|      case '+':
  ------------------
  |  Branch (2330:7): [True: 0, False: 0]
  ------------------
 2331|      0|        specs.sign = sign::plus;
 2332|      0|        break;
 2333|      0|      case '-':
  ------------------
  |  Branch (2333:7): [True: 0, False: 0]
  ------------------
 2334|      0|        specs.sign = sign::minus;
 2335|      0|        break;
 2336|      0|      case ' ':
  ------------------
  |  Branch (2336:7): [True: 0, False: 0]
  ------------------
 2337|      0|        specs.sign = sign::space;
 2338|      0|        break;
 2339|      0|      }
 2340|      0|      ++begin;
 2341|      0|      break;
 2342|      0|    case '#':
  ------------------
  |  Branch (2342:5): [True: 0, False: 777k]
  ------------------
 2343|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2343:11): [True: 0, False: 0]
  ------------------
 2344|      0|      enter_state(state::hash, is_arithmetic_type(arg_type));
 2345|      0|      specs.alt = true;
 2346|      0|      ++begin;
 2347|      0|      break;
 2348|      0|    case '0':
  ------------------
  |  Branch (2348:5): [True: 0, False: 777k]
  ------------------
 2349|      0|      enter_state(state::zero);
 2350|      0|      if (!is_arithmetic_type(arg_type)) {
  ------------------
  |  Branch (2350:11): [True: 0, False: 0]
  ------------------
 2351|      0|        if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2351:13): [True: 0, False: 0]
  ------------------
 2352|      0|        throw_format_error("format specifier requires numeric argument");
 2353|      0|      }
 2354|      0|      if (specs.align == align::none) {
  ------------------
  |  Branch (2354:11): [True: 0, False: 0]
  ------------------
 2355|       |        // Ignore 0 if align is specified for compatibility with std::format.
 2356|      0|        specs.align = align::numeric;
 2357|      0|        specs.fill[0] = Char('0');
 2358|      0|      }
 2359|      0|      ++begin;
 2360|      0|      break;
 2361|      0|    case '1':
  ------------------
  |  Branch (2361:5): [True: 0, False: 777k]
  ------------------
 2362|      0|    case '2':
  ------------------
  |  Branch (2362:5): [True: 0, False: 777k]
  ------------------
 2363|      0|    case '3':
  ------------------
  |  Branch (2363:5): [True: 0, False: 777k]
  ------------------
 2364|      0|    case '4':
  ------------------
  |  Branch (2364:5): [True: 0, False: 777k]
  ------------------
 2365|      0|    case '5':
  ------------------
  |  Branch (2365:5): [True: 0, False: 777k]
  ------------------
 2366|      0|    case '6':
  ------------------
  |  Branch (2366:5): [True: 0, False: 777k]
  ------------------
 2367|      0|    case '7':
  ------------------
  |  Branch (2367:5): [True: 0, False: 777k]
  ------------------
 2368|      0|    case '8':
  ------------------
  |  Branch (2368:5): [True: 0, False: 777k]
  ------------------
 2369|      0|    case '9':
  ------------------
  |  Branch (2369:5): [True: 0, False: 777k]
  ------------------
 2370|      0|    case '{':
  ------------------
  |  Branch (2370:5): [True: 0, False: 777k]
  ------------------
 2371|      0|      enter_state(state::width);
 2372|      0|      begin = parse_dynamic_spec(begin, end, specs.width, specs.width_ref, ctx);
 2373|      0|      break;
 2374|      0|    case '.':
  ------------------
  |  Branch (2374:5): [True: 0, False: 777k]
  ------------------
 2375|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2375:11): [True: 0, False: 0]
  ------------------
 2376|      0|      enter_state(state::precision,
 2377|      0|                  in(arg_type, float_set | string_set | cstring_set));
 2378|      0|      begin = parse_precision(begin, end, specs.precision, specs.precision_ref,
 2379|      0|                              ctx);
 2380|      0|      break;
 2381|      0|    case 'L':
  ------------------
  |  Branch (2381:5): [True: 0, False: 777k]
  ------------------
 2382|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2382:11): [True: 0, False: 0]
  ------------------
 2383|      0|      enter_state(state::locale, is_arithmetic_type(arg_type));
 2384|      0|      specs.localized = true;
 2385|      0|      ++begin;
 2386|      0|      break;
 2387|  10.1k|    case 'd':
  ------------------
  |  Branch (2387:5): [True: 10.1k, False: 767k]
  ------------------
 2388|  10.1k|      return parse_presentation_type(pres::dec, integral_set);
 2389|      0|    case 'o':
  ------------------
  |  Branch (2389:5): [True: 0, False: 777k]
  ------------------
 2390|      0|      return parse_presentation_type(pres::oct, integral_set);
 2391|      0|    case 'x':
  ------------------
  |  Branch (2391:5): [True: 0, False: 777k]
  ------------------
 2392|      0|      return parse_presentation_type(pres::hex_lower, integral_set);
 2393|      0|    case 'X':
  ------------------
  |  Branch (2393:5): [True: 0, False: 777k]
  ------------------
 2394|      0|      return parse_presentation_type(pres::hex_upper, integral_set);
 2395|      0|    case 'b':
  ------------------
  |  Branch (2395:5): [True: 0, False: 777k]
  ------------------
 2396|      0|      return parse_presentation_type(pres::bin_lower, integral_set);
 2397|      0|    case 'B':
  ------------------
  |  Branch (2397:5): [True: 0, False: 777k]
  ------------------
 2398|      0|      return parse_presentation_type(pres::bin_upper, integral_set);
 2399|      0|    case 'a':
  ------------------
  |  Branch (2399:5): [True: 0, False: 777k]
  ------------------
 2400|      0|      return parse_presentation_type(pres::hexfloat_lower, float_set);
 2401|      0|    case 'A':
  ------------------
  |  Branch (2401:5): [True: 0, False: 777k]
  ------------------
 2402|      0|      return parse_presentation_type(pres::hexfloat_upper, float_set);
 2403|      0|    case 'e':
  ------------------
  |  Branch (2403:5): [True: 0, False: 777k]
  ------------------
 2404|      0|      return parse_presentation_type(pres::exp_lower, float_set);
 2405|      0|    case 'E':
  ------------------
  |  Branch (2405:5): [True: 0, False: 777k]
  ------------------
 2406|      0|      return parse_presentation_type(pres::exp_upper, float_set);
 2407|      0|    case 'f':
  ------------------
  |  Branch (2407:5): [True: 0, False: 777k]
  ------------------
 2408|      0|      return parse_presentation_type(pres::fixed_lower, float_set);
 2409|      0|    case 'F':
  ------------------
  |  Branch (2409:5): [True: 0, False: 777k]
  ------------------
 2410|      0|      return parse_presentation_type(pres::fixed_upper, float_set);
 2411|      0|    case 'g':
  ------------------
  |  Branch (2411:5): [True: 0, False: 777k]
  ------------------
 2412|      0|      return parse_presentation_type(pres::general_lower, float_set);
 2413|      0|    case 'G':
  ------------------
  |  Branch (2413:5): [True: 0, False: 777k]
  ------------------
 2414|      0|      return parse_presentation_type(pres::general_upper, float_set);
 2415|      0|    case 'c':
  ------------------
  |  Branch (2415:5): [True: 0, False: 777k]
  ------------------
 2416|      0|      return parse_presentation_type(pres::chr, integral_set);
 2417|   767k|    case 's':
  ------------------
  |  Branch (2417:5): [True: 767k, False: 10.1k]
  ------------------
 2418|   767k|      return parse_presentation_type(pres::string,
 2419|   767k|                                     bool_set | string_set | cstring_set);
 2420|      0|    case 'p':
  ------------------
  |  Branch (2420:5): [True: 0, False: 777k]
  ------------------
 2421|      0|      return parse_presentation_type(pres::pointer, pointer_set | cstring_set);
 2422|      0|    case '?':
  ------------------
  |  Branch (2422:5): [True: 0, False: 777k]
  ------------------
 2423|      0|      return parse_presentation_type(pres::debug,
 2424|      0|                                     char_set | string_set | cstring_set);
 2425|      0|    case '}':
  ------------------
  |  Branch (2425:5): [True: 0, False: 777k]
  ------------------
 2426|      0|      return begin;
 2427|      0|    default: {
  ------------------
  |  Branch (2427:5): [True: 0, False: 777k]
  ------------------
 2428|      0|      if (*begin == '}') return begin;
  ------------------
  |  Branch (2428:11): [True: 0, False: 0]
  ------------------
 2429|       |      // Parse fill and alignment.
 2430|      0|      auto fill_end = begin + code_point_length(begin);
 2431|      0|      if (end - fill_end <= 0) {
  ------------------
  |  Branch (2431:11): [True: 0, False: 0]
  ------------------
 2432|      0|        throw_format_error("invalid format specifier");
 2433|      0|        return begin;
 2434|      0|      }
 2435|      0|      if (*begin == '{') {
  ------------------
  |  Branch (2435:11): [True: 0, False: 0]
  ------------------
 2436|      0|        throw_format_error("invalid fill character '{'");
 2437|      0|        return begin;
 2438|      0|      }
 2439|      0|      auto align = parse_align(to_ascii(*fill_end));
 2440|      0|      enter_state(state::align, align != align::none);
 2441|      0|      specs.fill = {begin, to_unsigned(fill_end - begin)};
 2442|      0|      specs.align = align;
 2443|      0|      begin = fill_end + 1;
 2444|      0|    }
 2445|   777k|    }
 2446|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2446:9): [True: 0, False: 0]
  ------------------
 2447|      0|    c = to_ascii(*begin);
 2448|      0|  }
 2449|   777k|}
_ZN3fmt3v106detail8to_asciiIcLi0EEEcT_:
 2104|  1.55M|constexpr auto to_ascii(Char c) -> char {
 2105|  1.55M|  return c <= 0xff ? static_cast<char>(c) : '\0';
  ------------------
  |  Branch (2105:10): [True: 1.55M, False: 0]
  ------------------
 2106|  1.55M|}
_ZN3fmt3v106detail11parse_alignEc:
 2162|   777k|FMT_CONSTEXPR inline auto parse_align(char c) -> align_t {
 2163|   777k|  switch (c) {
  ------------------
  |  Branch (2163:11): [True: 777k, False: 0]
  ------------------
 2164|      0|  case '<':
  ------------------
  |  Branch (2164:3): [True: 0, False: 777k]
  ------------------
 2165|      0|    return align::left;
 2166|      0|  case '>':
  ------------------
  |  Branch (2166:3): [True: 0, False: 777k]
  ------------------
 2167|      0|    return align::right;
 2168|      0|  case '^':
  ------------------
  |  Branch (2168:3): [True: 0, False: 777k]
  ------------------
 2169|      0|    return align::center;
 2170|   777k|  }
 2171|   777k|  return align::none;
 2172|   777k|}
_ZN3fmt3v106detail2inENS1_4typeEi:
  613|   777k|constexpr auto in(type t, int set) -> bool {
  614|   777k|  return ((set >> static_cast<int>(t)) & 1) != 0;
  615|   777k|}
_ZZN3fmt3v106detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeEENUt0_clENS0_17presentation_typeEi:
 2305|   777k|    FMT_CONSTEXPR auto operator()(pres pres_type, int set) -> const Char* {
 2306|   777k|      if (!in(arg_type, set)) {
  ------------------
  |  Branch (2306:11): [True: 0, False: 777k]
  ------------------
 2307|      0|        if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2307:13): [True: 0, False: 0]
  ------------------
 2308|      0|        throw_format_error("invalid format specifier");
 2309|      0|      }
 2310|   777k|      specs.type = pres_type;
 2311|   777k|      return begin + 1;
 2312|   777k|    }
_ZN3fmt3v1016visit_format_argIRNS0_6detail13arg_formatterIcEENS0_20basic_format_contextINS0_8appenderEcEEEEDTclfp_Li0EEEOT_RKNS0_16basic_format_argIT0_EE:
 1668|   777k|    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
 1669|   777k|  switch (arg.type_) {
  ------------------
  |  Branch (1669:11): [True: 0, False: 777k]
  ------------------
 1670|      0|  case detail::type::none_type:
  ------------------
  |  Branch (1670:3): [True: 0, False: 777k]
  ------------------
 1671|      0|    break;
 1672|      0|  case detail::type::int_type:
  ------------------
  |  Branch (1672:3): [True: 0, False: 777k]
  ------------------
 1673|      0|    return vis(arg.value_.int_value);
 1674|    564|  case detail::type::uint_type:
  ------------------
  |  Branch (1674:3): [True: 564, False: 776k]
  ------------------
 1675|    564|    return vis(arg.value_.uint_value);
 1676|      0|  case detail::type::long_long_type:
  ------------------
  |  Branch (1676:3): [True: 0, False: 777k]
  ------------------
 1677|      0|    return vis(arg.value_.long_long_value);
 1678|  9.58k|  case detail::type::ulong_long_type:
  ------------------
  |  Branch (1678:3): [True: 9.58k, False: 767k]
  ------------------
 1679|  9.58k|    return vis(arg.value_.ulong_long_value);
 1680|      0|  case detail::type::int128_type:
  ------------------
  |  Branch (1680:3): [True: 0, False: 777k]
  ------------------
 1681|      0|    return vis(detail::convert_for_visit(arg.value_.int128_value));
 1682|      0|  case detail::type::uint128_type:
  ------------------
  |  Branch (1682:3): [True: 0, False: 777k]
  ------------------
 1683|      0|    return vis(detail::convert_for_visit(arg.value_.uint128_value));
 1684|      0|  case detail::type::bool_type:
  ------------------
  |  Branch (1684:3): [True: 0, False: 777k]
  ------------------
 1685|      0|    return vis(arg.value_.bool_value);
 1686|      0|  case detail::type::char_type:
  ------------------
  |  Branch (1686:3): [True: 0, False: 777k]
  ------------------
 1687|      0|    return vis(arg.value_.char_value);
 1688|      0|  case detail::type::float_type:
  ------------------
  |  Branch (1688:3): [True: 0, False: 777k]
  ------------------
 1689|      0|    return vis(arg.value_.float_value);
 1690|      0|  case detail::type::double_type:
  ------------------
  |  Branch (1690:3): [True: 0, False: 777k]
  ------------------
 1691|      0|    return vis(arg.value_.double_value);
 1692|      0|  case detail::type::long_double_type:
  ------------------
  |  Branch (1692:3): [True: 0, False: 777k]
  ------------------
 1693|      0|    return vis(arg.value_.long_double_value);
 1694|   767k|  case detail::type::cstring_type:
  ------------------
  |  Branch (1694:3): [True: 767k, False: 10.1k]
  ------------------
 1695|   767k|    return vis(arg.value_.string.data);
 1696|      0|  case detail::type::string_type:
  ------------------
  |  Branch (1696:3): [True: 0, False: 777k]
  ------------------
 1697|      0|    using sv = basic_string_view<typename Context::char_type>;
 1698|      0|    return vis(sv(arg.value_.string.data, arg.value_.string.size));
 1699|      0|  case detail::type::pointer_type:
  ------------------
  |  Branch (1699:3): [True: 0, False: 777k]
  ------------------
 1700|      0|    return vis(arg.value_.pointer);
 1701|      0|  case detail::type::custom_type:
  ------------------
  |  Branch (1701:3): [True: 0, False: 777k]
  ------------------
 1702|      0|    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
 1703|   777k|  }
 1704|      0|  return vis(monostate());
 1705|   777k|}
_ZN3fmt3v106detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ej:
 1265|    564|  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
_ZN3fmt3v106detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ey:
 1267|  9.58k|  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
_ZN3fmt3v106detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEh:
 1341|    564|  FMT_CONSTEXPR FMT_INLINE auto map(unsigned char val) -> unsigned {
 1342|    564|    return val;
 1343|    564|  }
_ZN3fmt3v106detail4findILb0EcPKcEEbT1_S5_T0_RS5_:
 2131|  1.94M|                              const char*& out) -> bool {
 2132|  1.94M|  out = static_cast<const char*>(
 2133|  1.94M|      std::memchr(first, value, to_unsigned(last - first)));
 2134|  1.94M|  return out != nullptr;
 2135|  1.94M|}
_ZZN3fmt3v106detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_EN6writerclEPKcSL_:
 2512|   972k|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2513|   972k|      if (from == to) return;
  ------------------
  |  Branch (2513:11): [True: 0, False: 972k]
  ------------------
 2514|   972k|      for (;;) {
 2515|   972k|        const Char* p = nullptr;
 2516|   972k|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
  ------------------
  |  Branch (2516:13): [True: 972k, False: 0]
  ------------------
 2517|   972k|          return handler_.on_text(from, to);
 2518|      0|        ++p;
 2519|      0|        if (p == to || *p != '}')
  ------------------
  |  Branch (2519:13): [True: 0, False: 0]
  |  Branch (2519:24): [True: 0, False: 0]
  ------------------
 2520|      0|          return handler_.on_error("unmatched '}' in format string");
 2521|      0|        handler_.on_text(from, p);
 2522|      0|        from = p + 1;
 2523|      0|      }
 2524|   972k|    }
_ZN3fmt3v106detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEPKc:
 1393|   767k|  FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
 1394|   767k|    return val;
 1395|   767k|  }
_ZN3fmt3v106detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2EPKc:
 1275|   767k|  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
 1276|   767k|    string.data = val;
 1277|   767k|    if (is_constant_evaluated()) string.size = {};
  ------------------
  |  Branch (1277:9): [Folded - Ignored]
  ------------------
 1278|   767k|  }
_ZN3fmt3v106detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EEC2IJS7_S7_EEEDpRKT_:
 1170|   288k|  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
_ZNK3fmt3v106detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EE4argsEv:
 1171|   288k|  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
_ZNK3fmt3v106detail6bufferIcE4dataEv:
  847|   492k|  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }

_ZN3fmt3v107vformatENS0_17basic_string_viewIcEENS0_17basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEE:
 1420|   492k|FMT_FUNC std::string vformat(string_view fmt, format_args args) {
 1421|       |  // Don't optimize the "{}" case to keep the binary size small and because it
 1422|       |  // can be better optimized in fmt::format anyway.
 1423|   492k|  auto buffer = memory_buffer();
 1424|   492k|  detail::vformat_to(buffer, fmt, args);
 1425|   492k|  return to_string(buffer);
 1426|   492k|}

_ZN3fmt3v106detail6bufferIcE6appendIcEEvPKT_S7_:
  875|  1.75M|void buffer<T>::append(const U* begin, const U* end) {
  876|  3.50M|  while (begin != end) {
  ------------------
  |  Branch (876:10): [True: 1.75M, False: 1.75M]
  ------------------
  877|  1.75M|    auto count = to_unsigned(end - begin);
  878|  1.75M|    try_reserve(size_ + count);
  879|  1.75M|    auto free_cap = capacity_ - size_;
  880|  1.75M|    if (free_cap < count) count = free_cap;
  ------------------
  |  Branch (880:9): [True: 0, False: 1.75M]
  ------------------
  881|  1.75M|    std::uninitialized_copy_n(begin, count, ptr_ + size_);
  882|  1.75M|    size_ += count;
  883|  1.75M|    begin += count;
  884|  1.75M|  }
  885|  1.75M|}
_ZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refE:
 4375|   492k|                typename vformat_args<Char>::type args, locale_ref loc) {
 4376|   492k|  auto out = buffer_appender<Char>(buf);
 4377|   492k|  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
  ------------------
  |  Branch (4377:7): [True: 0, False: 492k]
  |  Branch (4377:26): [True: 0, False: 0]
  ------------------
 4378|      0|    auto arg = args.get(0);
 4379|      0|    if (!arg) error_handler().on_error("argument not found");
  ------------------
  |  Branch (4379:9): [True: 0, False: 0]
  ------------------
 4380|      0|    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
 4381|      0|    return;
 4382|      0|  }
 4383|       |
 4384|   492k|  struct format_handler : error_handler {
 4385|   492k|    basic_format_parse_context<Char> parse_context;
 4386|   492k|    buffer_context<Char> context;
 4387|       |
 4388|   492k|    format_handler(buffer_appender<Char> p_out, basic_string_view<Char> str,
 4389|   492k|                   basic_format_args<buffer_context<Char>> p_args,
 4390|   492k|                   locale_ref p_loc)
 4391|   492k|        : parse_context(str), context(p_out, p_args, p_loc) {}
 4392|       |
 4393|   492k|    void on_text(const Char* begin, const Char* end) {
 4394|   492k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4395|   492k|      context.advance_to(write<Char>(context.out(), text));
 4396|   492k|    }
 4397|       |
 4398|   492k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4399|   492k|      return parse_context.next_arg_id();
 4400|   492k|    }
 4401|   492k|    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
 4402|   492k|      return parse_context.check_arg_id(id), id;
 4403|   492k|    }
 4404|   492k|    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
 4405|   492k|      int arg_id = context.arg_id(id);
 4406|   492k|      if (arg_id < 0) on_error("argument not found");
 4407|   492k|      return arg_id;
 4408|   492k|    }
 4409|       |
 4410|   492k|    FMT_INLINE void on_replacement_field(int id, const Char*) {
 4411|   492k|      auto arg = get_arg(context, id);
 4412|   492k|      context.advance_to(visit_format_arg(
 4413|   492k|          default_arg_formatter<Char>{context.out(), context.args(),
 4414|   492k|                                      context.locale()},
 4415|   492k|          arg));
 4416|   492k|    }
 4417|       |
 4418|   492k|    auto on_format_specs(int id, const Char* begin, const Char* end)
 4419|   492k|        -> const Char* {
 4420|   492k|      auto arg = get_arg(context, id);
 4421|   492k|      if (arg.type() == type::custom_type) {
 4422|   492k|        parse_context.advance_to(begin);
 4423|   492k|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4424|   492k|        return parse_context.begin();
 4425|   492k|      }
 4426|   492k|      auto specs = detail::dynamic_format_specs<Char>();
 4427|   492k|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4428|   492k|      detail::handle_dynamic_spec<detail::width_checker>(
 4429|   492k|          specs.width, specs.width_ref, context);
 4430|   492k|      detail::handle_dynamic_spec<detail::precision_checker>(
 4431|   492k|          specs.precision, specs.precision_ref, context);
 4432|   492k|      if (begin == end || *begin != '}')
 4433|   492k|        on_error("missing '}' in format string");
 4434|   492k|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4435|   492k|      context.advance_to(visit_format_arg(f, arg));
 4436|   492k|      return begin;
 4437|   492k|    }
 4438|   492k|  };
 4439|   492k|  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
 4440|   492k|}
_ZN3fmt3v106detail12count_digitsEj:
 1278|  1.12k|FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
 1279|  1.12k|#ifdef FMT_BUILTIN_CLZ
 1280|  1.12k|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1280:7): [Folded - Ignored]
  ------------------
 1281|  1.12k|    return do_count_digits(n);
 1282|  1.12k|  }
 1283|      0|#endif
 1284|      0|  return count_digits_fallback(n);
 1285|  1.12k|}
_ZN3fmt3v106detail15do_count_digitsEj:
 1255|  1.12k|FMT_INLINE auto do_count_digits(uint32_t n) -> int {
 1256|       |// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
 1257|       |// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
 1259|  1.12k|  static constexpr uint64_t table[] = {
 1260|  1.12k|      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1261|  1.12k|      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1262|  1.12k|      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1263|  1.12k|      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1264|  1.12k|      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1265|  1.12k|      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1266|  1.12k|      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1267|  1.12k|      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1268|  1.12k|      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1269|  1.12k|      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1270|       |      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1258|  1.12k|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1271|  1.12k|  };
 1272|  1.12k|  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
  ------------------
  |  |  180|  1.12k|#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
  ------------------
 1273|  1.12k|  return static_cast<int>((n + inc) >> 32);
 1274|  1.12k|}
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEEC2ERKS4_:
  965|   492k|      : alloc_(alloc) {
  966|   492k|    this->set(store_, SIZE);
  967|   492k|    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  ------------------
  |  Branch (967:9): [Folded - Ignored]
  ------------------
  968|   492k|  }
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEE4growEm:
  936|   289k|  FMT_CONSTEXPR20 void grow(size_t size) override {
  937|   289k|    detail::abort_fuzzing_if(size > 5000);
  938|   289k|    const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
  939|   289k|    size_t old_capacity = this->capacity();
  940|   289k|    size_t new_capacity = old_capacity + old_capacity / 2;
  941|   289k|    if (size > new_capacity)
  ------------------
  |  Branch (941:9): [True: 140k, False: 149k]
  ------------------
  942|   140k|      new_capacity = size;
  943|   149k|    else if (new_capacity > max_size)
  ------------------
  |  Branch (943:14): [True: 0, False: 149k]
  ------------------
  944|      0|      new_capacity = size > max_size ? size : max_size;
  ------------------
  |  Branch (944:22): [True: 0, False: 0]
  ------------------
  945|   289k|    T* old_data = this->data();
  946|   289k|    T* new_data =
  947|   289k|        std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
  948|       |    // Suppress a bogus -Wstringop-overflow in gcc 13.1 (#3481).
  949|   289k|    detail::assume(this->size() <= new_capacity);
  950|       |    // The following code doesn't throw, so the raw pointer above doesn't leak.
  951|   289k|    std::uninitialized_copy_n(old_data, this->size(), new_data);
  952|   289k|    this->set(new_data, new_capacity);
  953|       |    // deallocate must not throw according to the standard, but even if it does,
  954|       |    // the buffer already uses the new storage and will deallocate it in
  955|       |    // destructor.
  956|   289k|    if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
  ------------------
  |  Branch (956:9): [True: 141k, False: 148k]
  ------------------
  957|   289k|  }
_ZN3fmt3v106detail16abort_fuzzing_ifEb:
  295|   289k|FMT_CONSTEXPR inline void abort_fuzzing_if(bool condition) {
  296|   289k|  ignore_unused(condition);
  297|       |#ifdef FMT_FUZZ
  298|       |  if (condition) throw std::runtime_error("fuzzing limit reached");
  299|       |#endif
  300|   289k|}
_ZN3fmt3v106detail6assumeEb:
  544|   781k|FMT_INLINE void assume(bool condition) {
  545|   781k|  (void)condition;
  546|   781k|#if FMT_HAS_BUILTIN(__builtin_assume) && !FMT_ICC_VERSION
  547|   781k|  __builtin_assume(condition);
  548|       |#elif FMT_GCC_VERSION
  549|       |  if (!condition) __builtin_unreachable();
  550|       |#endif
  551|   781k|}
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEED2Ev:
  969|   492k|  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEE10deallocateEv:
  930|   492k|  FMT_CONSTEXPR20 void deallocate() {
  931|   492k|    T* data = this->data();
  932|   492k|    if (data != store_) alloc_.deallocate(data, this->capacity());
  ------------------
  |  Branch (932:9): [True: 148k, False: 344k]
  ------------------
  933|   492k|  }
_ZN3fmt3v106detail7reserveINS0_8appenderEEERT_S5_m:
  591|  1.75M|constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
  592|  1.75M|  return it;
  593|  1.75M|}
_ZN3fmt3v106detail14format_decimalIcjEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1348|    564|    -> format_decimal_result<Char*> {
 1349|    564|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  336|    564|      fmt::detail::ignore_unused((condition), (message))
  ------------------
 1350|    564|  out += size;
 1351|    564|  Char* end = out;
 1352|    564|  while (value >= 100) {
  ------------------
  |  Branch (1352:10): [True: 0, False: 564]
  ------------------
 1353|       |    // Integer division is slow so do it for a group of two digits instead
 1354|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1355|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1356|      0|    out -= 2;
 1357|      0|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1358|      0|    value /= 100;
 1359|      0|  }
 1360|    564|  if (value < 10) {
  ------------------
  |  Branch (1360:7): [True: 564, False: 0]
  ------------------
 1361|    564|    *--out = static_cast<Char>('0' + value);
 1362|    564|    return {out, end};
 1363|    564|  }
 1364|      0|  out -= 2;
 1365|      0|  copy2(out, digits2(static_cast<size_t>(value)));
 1366|      0|  return {out, end};
 1367|    564|}
_ZN3fmt3v106detail5copy2IcEEvPT_PKc:
 1329|    270|FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
 1330|    270|  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
  ------------------
  |  Branch (1330:7): [Folded - Ignored]
  |  Branch (1330:35): [Folded - Ignored]
  ------------------
 1331|    270|    memcpy(dst, src, 2);
 1332|    270|    return;
 1333|    270|  }
 1334|      0|  *dst++ = static_cast<Char>(*src++);
 1335|      0|  *dst = static_cast<Char>(*src);
 1336|      0|}
_ZN3fmt3v106detail7digits2Em:
 1166|    270|constexpr const char* digits2(size_t value) {
 1167|       |  // GCC generates slightly better code when value is pointer-size.
 1168|    270|  return &"0001020304050607080910111213141516171819"
 1169|    270|         "2021222324252627282930313233343536373839"
 1170|    270|         "4041424344454647484950515253545556575859"
 1171|    270|         "6061626364656667686970717273747576777879"
 1172|    270|         "8081828384858687888990919293949596979899"[value * 2];
 1173|    270|}
_ZN3fmt3v106detail14format_decimalIcjNS0_8appenderELi0EEENS1_21format_decimal_resultIT1_EES5_T0_i:
 1372|    564|    -> format_decimal_result<Iterator> {
 1373|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1374|    564|  Char buffer[digits10<UInt>() + 1] = {};
 1375|    564|  auto end = format_decimal(buffer, value, size).end;
 1376|    564|  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
 1377|    564|}
_ZN3fmt3v106detail17copy_str_noinlineIcPcNS0_8appenderEEET1_T0_S6_S5_:
  648|  10.1k|                                                  OutputIt out) -> OutputIt {
  649|  10.1k|  return copy_str<OutChar>(begin, end, out);
  650|  10.1k|}
_ZN3fmt3v106detail13base_iteratorINS0_8appenderEEET_S4_S4_:
  619|  1.75M|constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
  620|  1.75M|  return it;
  621|  1.75M|}
_ZN3fmt3v106detail11is_negativeIjLi0EEEbT_:
 1138|    564|constexpr auto is_negative(T) -> bool {
 1139|    564|  return false;
 1140|    564|}
_ZN3fmt3v106detail12count_digitsEm:
 1226|  19.1k|FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
 1227|  19.1k|#ifdef FMT_BUILTIN_CLZLL
 1228|  19.1k|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1228:7): [Folded - Ignored]
  ------------------
 1229|  19.1k|    return do_count_digits(n);
 1230|  19.1k|  }
 1231|      0|#endif
 1232|      0|  return count_digits_fallback(n);
 1233|  19.1k|}
_ZN3fmt3v106detail15do_count_digitsEm:
 1206|  19.1k|inline auto do_count_digits(uint64_t n) -> int {
 1207|       |  // This has comparable performance to the version by Kendall Willets
 1208|       |  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
 1209|       |  // but uses smaller tables.
 1210|       |  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
 1211|  19.1k|  static constexpr uint8_t bsr2log10[] = {
 1212|  19.1k|      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
 1213|  19.1k|      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
 1214|  19.1k|      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
 1215|  19.1k|      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
 1216|  19.1k|  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
  ------------------
  |  |  183|  19.1k|#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
  ------------------
 1217|  19.1k|  static constexpr const uint64_t zero_or_powers_of_10[] = {
 1218|  19.1k|      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1161|  19.1k|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1162|  19.1k|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1163|  19.1k|      (factor)*1000000000
  ------------------
                    0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1161|  19.1k|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1162|  19.1k|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1163|  19.1k|      (factor)*1000000000
  ------------------
 1219|  19.1k|      10000000000000000000ULL};
 1220|  19.1k|  return t - (n < zero_or_powers_of_10[t]);
 1221|  19.1k|}
_ZN3fmt3v106detail14format_decimalIcmEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1348|  9.58k|    -> format_decimal_result<Char*> {
 1349|  9.58k|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  336|  9.58k|      fmt::detail::ignore_unused((condition), (message))
  ------------------
 1350|  9.58k|  out += size;
 1351|  9.58k|  Char* end = out;
 1352|  9.67k|  while (value >= 100) {
  ------------------
  |  Branch (1352:10): [True: 95, False: 9.58k]
  ------------------
 1353|       |    // Integer division is slow so do it for a group of two digits instead
 1354|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1355|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1356|     95|    out -= 2;
 1357|     95|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1358|     95|    value /= 100;
 1359|     95|  }
 1360|  9.58k|  if (value < 10) {
  ------------------
  |  Branch (1360:7): [True: 9.40k, False: 175]
  ------------------
 1361|  9.40k|    *--out = static_cast<Char>('0' + value);
 1362|  9.40k|    return {out, end};
 1363|  9.40k|  }
 1364|    175|  out -= 2;
 1365|    175|  copy2(out, digits2(static_cast<size_t>(value)));
 1366|    175|  return {out, end};
 1367|  9.58k|}
_ZN3fmt3v106detail14format_decimalIcmNS0_8appenderELi0EEENS1_21format_decimal_resultIT1_EES5_T0_i:
 1372|  9.58k|    -> format_decimal_result<Iterator> {
 1373|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1374|  9.58k|  Char buffer[digits10<UInt>() + 1] = {};
 1375|  9.58k|  auto end = format_decimal(buffer, value, size).end;
 1376|  9.58k|  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
 1377|  9.58k|}
_ZN3fmt3v106detail11is_negativeIyLi0EEEbT_:
 1138|  9.58k|constexpr auto is_negative(T) -> bool {
 1139|  9.58k|  return false;
 1140|  9.58k|}
_ZN3fmt3v106detail18write_int_noinlineIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2246|    564|    locale_ref loc) -> OutputIt {
 2247|    564|  return write_int(out, arg, specs, loc);
 2248|    564|}
_ZN3fmt3v106detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2190|    564|                                        locale_ref) -> OutputIt {
 2191|    564|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2192|    564|  auto abs_value = arg.abs_value;
 2193|    564|  auto prefix = arg.prefix;
 2194|    564|  switch (specs.type) {
 2195|      0|  case presentation_type::none:
  ------------------
  |  Branch (2195:3): [True: 0, False: 564]
  ------------------
 2196|    564|  case presentation_type::dec: {
  ------------------
  |  Branch (2196:3): [True: 564, False: 0]
  ------------------
 2197|    564|    auto num_digits = count_digits(abs_value);
 2198|    564|    return write_int(
 2199|    564|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2200|    564|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2201|    564|        });
 2202|      0|  }
 2203|      0|  case presentation_type::hex_lower:
  ------------------
  |  Branch (2203:3): [True: 0, False: 564]
  ------------------
 2204|      0|  case presentation_type::hex_upper: {
  ------------------
  |  Branch (2204:3): [True: 0, False: 564]
  ------------------
 2205|      0|    bool upper = specs.type == presentation_type::hex_upper;
 2206|      0|    if (specs.alt)
  ------------------
  |  Branch (2206:9): [True: 0, False: 0]
  ------------------
 2207|      0|      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2207:38): [True: 0, False: 0]
  ------------------
 2208|      0|    int num_digits = count_digits<4>(abs_value);
 2209|      0|    return write_int(
 2210|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2211|      0|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2212|      0|        });
 2213|      0|  }
 2214|      0|  case presentation_type::bin_lower:
  ------------------
  |  Branch (2214:3): [True: 0, False: 564]
  ------------------
 2215|      0|  case presentation_type::bin_upper: {
  ------------------
  |  Branch (2215:3): [True: 0, False: 564]
  ------------------
 2216|      0|    bool upper = specs.type == presentation_type::bin_upper;
 2217|      0|    if (specs.alt)
  ------------------
  |  Branch (2217:9): [True: 0, False: 0]
  ------------------
 2218|      0|      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2218:38): [True: 0, False: 0]
  ------------------
 2219|      0|    int num_digits = count_digits<1>(abs_value);
 2220|      0|    return write_int(out, num_digits, prefix, specs,
 2221|      0|                     [=](reserve_iterator<OutputIt> it) {
 2222|      0|                       return format_uint<1, Char>(it, abs_value, num_digits);
 2223|      0|                     });
 2224|      0|  }
 2225|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2225:3): [True: 0, False: 564]
  ------------------
 2226|      0|    int num_digits = count_digits<3>(abs_value);
 2227|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2228|       |    // is not greater than the number of digits.
 2229|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2229:9): [True: 0, False: 0]
  |  Branch (2229:22): [True: 0, False: 0]
  |  Branch (2229:55): [True: 0, False: 0]
  ------------------
 2230|      0|      prefix_append(prefix, '0');
 2231|      0|    return write_int(out, num_digits, prefix, specs,
 2232|      0|                     [=](reserve_iterator<OutputIt> it) {
 2233|      0|                       return format_uint<3, Char>(it, abs_value, num_digits);
 2234|      0|                     });
 2235|      0|  }
 2236|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2236:3): [True: 0, False: 564]
  ------------------
 2237|      0|    return write_char(out, static_cast<Char>(abs_value), specs);
 2238|      0|  default:
  ------------------
  |  Branch (2238:3): [True: 0, False: 564]
  ------------------
 2239|      0|    throw_format_error("invalid format specifier");
 2240|    564|  }
 2241|      0|  return out;
 2242|    564|}
_ZN3fmt3v106detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_jEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E_EESA_SA_ijRKNS9_IS5_EES7_:
 2025|    564|                                        W write_digits) -> OutputIt {
 2026|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 2027|    564|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (2027:7): [True: 564, False: 0]
  ------------------
 2028|    564|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 2029|    564|    if (prefix != 0) {
  ------------------
  |  Branch (2029:9): [True: 0, False: 564]
  ------------------
 2030|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (2030:44): [True: 0, False: 0]
  ------------------
 2031|      0|        *it++ = static_cast<Char>(p & 0xff);
 2032|      0|    }
 2033|    564|    return base_iterator(out, write_digits(it));
 2034|    564|  }
 2035|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 2036|      0|  return write_padded<align::right>(
 2037|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 2038|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 2039|      0|          *it++ = static_cast<Char>(p & 0xff);
 2040|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 2041|      0|        return write_digits(it);
 2042|      0|      });
 2043|    564|}
_ZZN3fmt3v106detail9write_intIcNS0_8appenderEjEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEENKUlS3_E_clES3_:
 2199|    564|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2200|    564|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2201|    564|        });
_ZN3fmt3v106detail17copy_str_noinlineIcPKcNS0_8appenderEEET1_T0_S7_S6_:
  648|   976k|                                                  OutputIt out) -> OutputIt {
  649|   976k|  return copy_str<OutChar>(begin, end, out);
  650|   976k|}
_ZN3fmt3v106detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EE:
 3680|   976k|    -> OutputIt {
 3681|   976k|  auto it = reserve(out, value.size());
 3682|   976k|  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
 3683|   976k|  return base_iterator(out, it);
 3684|   976k|}
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler7on_textEPKcSF_:
 4393|   976k|    void on_text(const Char* begin, const Char* end) {
 4394|   976k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4395|   976k|      context.advance_to(write<Char>(context.out(), text));
 4396|   976k|    }
_ZN3fmt3v106detail7get_argINS0_20basic_format_contextINS0_8appenderEcEEiEEDTcldtfp_3argfp0_EERT_T0_:
 3858|   777k|FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) -> decltype(ctx.arg(id)) {
 3859|   777k|  auto arg = ctx.arg(id);
 3860|   777k|  if (!arg) ctx.on_error("argument not found");
  ------------------
  |  Branch (3860:7): [True: 0, False: 777k]
  ------------------
 3861|   777k|  return arg;
 3862|   777k|}
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler9on_arg_idEv:
 4398|   777k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4399|   777k|      return parse_context.next_arg_id();
 4400|   777k|    }
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler15on_format_specsEiPKcSF_:
 4419|   777k|        -> const Char* {
 4420|   777k|      auto arg = get_arg(context, id);
 4421|   777k|      if (arg.type() == type::custom_type) {
  ------------------
  |  Branch (4421:11): [True: 0, False: 777k]
  ------------------
 4422|      0|        parse_context.advance_to(begin);
 4423|      0|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4424|      0|        return parse_context.begin();
 4425|      0|      }
 4426|   777k|      auto specs = detail::dynamic_format_specs<Char>();
 4427|   777k|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4428|   777k|      detail::handle_dynamic_spec<detail::width_checker>(
 4429|   777k|          specs.width, specs.width_ref, context);
 4430|   777k|      detail::handle_dynamic_spec<detail::precision_checker>(
 4431|   777k|          specs.precision, specs.precision_ref, context);
 4432|   777k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (4432:11): [True: 0, False: 777k]
  |  Branch (4432:27): [True: 0, False: 777k]
  ------------------
 4433|      0|        on_error("missing '}' in format string");
 4434|   777k|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4435|   777k|      context.advance_to(visit_format_arg(f, arg));
 4436|   777k|      return begin;
 4437|   777k|    }
_ZN3fmt3v106detail19handle_dynamic_specINS1_13width_checkerENS0_20basic_format_contextINS0_8appenderEcEEEEvRiNS1_7arg_refINT0_9char_typeEEERS9_:
 3867|   777k|                                       Context& ctx) {
 3868|   777k|  switch (ref.kind) {
  ------------------
  |  Branch (3868:11): [True: 0, False: 777k]
  ------------------
 3869|   777k|  case arg_id_kind::none:
  ------------------
  |  Branch (3869:3): [True: 777k, False: 0]
  ------------------
 3870|   777k|    break;
 3871|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (3871:3): [True: 0, False: 777k]
  ------------------
 3872|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index),
 3873|      0|                                              ctx.error_handler());
 3874|      0|    break;
 3875|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (3875:3): [True: 0, False: 777k]
  ------------------
 3876|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name),
 3877|      0|                                              ctx.error_handler());
 3878|      0|    break;
 3879|   777k|  }
 3880|   777k|}
_ZN3fmt3v106detail19handle_dynamic_specINS1_17precision_checkerENS0_20basic_format_contextINS0_8appenderEcEEEEvRiNS1_7arg_refINT0_9char_typeEEERS9_:
 3867|   777k|                                       Context& ctx) {
 3868|   777k|  switch (ref.kind) {
  ------------------
  |  Branch (3868:11): [True: 0, False: 777k]
  ------------------
 3869|   777k|  case arg_id_kind::none:
  ------------------
  |  Branch (3869:3): [True: 777k, False: 0]
  ------------------
 3870|   777k|    break;
 3871|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (3871:3): [True: 0, False: 777k]
  ------------------
 3872|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index),
 3873|      0|                                              ctx.error_handler());
 3874|      0|    break;
 3875|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (3875:3): [True: 0, False: 777k]
  ------------------
 3876|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name),
 3877|      0|                                              ctx.error_handler());
 3878|      0|    break;
 3879|   777k|  }
 3880|   777k|}
_ZN3fmt3v106detail13arg_formatterIcEclIjEENS0_8appenderET_:
 3788|    564|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3789|    564|    return detail::write(out, value, specs, locale);
 3790|    564|  }
_ZN3fmt3v106detail5writeIcNS0_8appenderEjLi0EEET0_S4_T1_RKNS0_12format_specsIT_EENS1_10locale_refE:
 2255|    564|                                    locale_ref loc) -> OutputIt {
 2256|    564|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2256:7): [True: 0, False: 564]
  |  Branch (2256:26): [True: 0, False: 0]
  ------------------
 2257|    564|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2258|    564|                            loc);
 2259|    564|}
_ZN3fmt3v106detail18make_write_int_argIjEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2152|    564|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2153|    564|  auto prefix = 0u;
 2154|    564|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2155|    564|  if (is_negative(value)) {
  ------------------
  |  Branch (2155:7): [True: 0, False: 564]
  ------------------
 2156|      0|    prefix = 0x01000000 | '-';
 2157|      0|    abs_value = 0 - abs_value;
 2158|    564|  } else {
 2159|    564|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2160|    564|                                            0x1000000u | ' '};
 2161|    564|    prefix = prefixes[sign];
 2162|    564|  }
 2163|    564|  return {abs_value, prefix};
 2164|    564|}
_ZN3fmt3v106detail18write_int_noinlineIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2246|  9.58k|    locale_ref loc) -> OutputIt {
 2247|  9.58k|  return write_int(out, arg, specs, loc);
 2248|  9.58k|}
_ZN3fmt3v106detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2190|  9.58k|                                        locale_ref) -> OutputIt {
 2191|  9.58k|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2192|  9.58k|  auto abs_value = arg.abs_value;
 2193|  9.58k|  auto prefix = arg.prefix;
 2194|  9.58k|  switch (specs.type) {
 2195|      0|  case presentation_type::none:
  ------------------
  |  Branch (2195:3): [True: 0, False: 9.58k]
  ------------------
 2196|  9.58k|  case presentation_type::dec: {
  ------------------
  |  Branch (2196:3): [True: 9.58k, False: 0]
  ------------------
 2197|  9.58k|    auto num_digits = count_digits(abs_value);
 2198|  9.58k|    return write_int(
 2199|  9.58k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2200|  9.58k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2201|  9.58k|        });
 2202|      0|  }
 2203|      0|  case presentation_type::hex_lower:
  ------------------
  |  Branch (2203:3): [True: 0, False: 9.58k]
  ------------------
 2204|      0|  case presentation_type::hex_upper: {
  ------------------
  |  Branch (2204:3): [True: 0, False: 9.58k]
  ------------------
 2205|      0|    bool upper = specs.type == presentation_type::hex_upper;
 2206|      0|    if (specs.alt)
  ------------------
  |  Branch (2206:9): [True: 0, False: 0]
  ------------------
 2207|      0|      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2207:38): [True: 0, False: 0]
  ------------------
 2208|      0|    int num_digits = count_digits<4>(abs_value);
 2209|      0|    return write_int(
 2210|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2211|      0|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2212|      0|        });
 2213|      0|  }
 2214|      0|  case presentation_type::bin_lower:
  ------------------
  |  Branch (2214:3): [True: 0, False: 9.58k]
  ------------------
 2215|      0|  case presentation_type::bin_upper: {
  ------------------
  |  Branch (2215:3): [True: 0, False: 9.58k]
  ------------------
 2216|      0|    bool upper = specs.type == presentation_type::bin_upper;
 2217|      0|    if (specs.alt)
  ------------------
  |  Branch (2217:9): [True: 0, False: 0]
  ------------------
 2218|      0|      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2218:38): [True: 0, False: 0]
  ------------------
 2219|      0|    int num_digits = count_digits<1>(abs_value);
 2220|      0|    return write_int(out, num_digits, prefix, specs,
 2221|      0|                     [=](reserve_iterator<OutputIt> it) {
 2222|      0|                       return format_uint<1, Char>(it, abs_value, num_digits);
 2223|      0|                     });
 2224|      0|  }
 2225|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2225:3): [True: 0, False: 9.58k]
  ------------------
 2226|      0|    int num_digits = count_digits<3>(abs_value);
 2227|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2228|       |    // is not greater than the number of digits.
 2229|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2229:9): [True: 0, False: 0]
  |  Branch (2229:22): [True: 0, False: 0]
  |  Branch (2229:55): [True: 0, False: 0]
  ------------------
 2230|      0|      prefix_append(prefix, '0');
 2231|      0|    return write_int(out, num_digits, prefix, specs,
 2232|      0|                     [=](reserve_iterator<OutputIt> it) {
 2233|      0|                       return format_uint<3, Char>(it, abs_value, num_digits);
 2234|      0|                     });
 2235|      0|  }
 2236|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2236:3): [True: 0, False: 9.58k]
  ------------------
 2237|      0|    return write_char(out, static_cast<Char>(abs_value), specs);
 2238|      0|  default:
  ------------------
  |  Branch (2238:3): [True: 0, False: 9.58k]
  ------------------
 2239|      0|    throw_format_error("invalid format specifier");
 2240|  9.58k|  }
 2241|      0|  return out;
 2242|  9.58k|}
_ZN3fmt3v106detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_mEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E_EESA_SA_ijRKNS9_IS5_EES7_:
 2025|  9.58k|                                        W write_digits) -> OutputIt {
 2026|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 2027|  9.58k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (2027:7): [True: 9.58k, False: 0]
  ------------------
 2028|  9.58k|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 2029|  9.58k|    if (prefix != 0) {
  ------------------
  |  Branch (2029:9): [True: 0, False: 9.58k]
  ------------------
 2030|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (2030:44): [True: 0, False: 0]
  ------------------
 2031|      0|        *it++ = static_cast<Char>(p & 0xff);
 2032|      0|    }
 2033|  9.58k|    return base_iterator(out, write_digits(it));
 2034|  9.58k|  }
 2035|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 2036|      0|  return write_padded<align::right>(
 2037|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 2038|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 2039|      0|          *it++ = static_cast<Char>(p & 0xff);
 2040|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 2041|      0|        return write_digits(it);
 2042|      0|      });
 2043|  9.58k|}
_ZZN3fmt3v106detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEENKUlS3_E_clES3_:
 2199|  9.58k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2200|  9.58k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2201|  9.58k|        });
_ZN3fmt3v106detail13arg_formatterIcEclIyEENS0_8appenderET_:
 3788|  9.58k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3789|  9.58k|    return detail::write(out, value, specs, locale);
 3790|  9.58k|  }
_ZN3fmt3v106detail5writeIcNS0_8appenderEyLi0EEET0_S4_T1_RKNS0_12format_specsIT_EENS1_10locale_refE:
 2255|  9.58k|                                    locale_ref loc) -> OutputIt {
 2256|  9.58k|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2256:7): [True: 0, False: 9.58k]
  |  Branch (2256:26): [True: 0, False: 0]
  ------------------
 2257|  9.58k|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2258|  9.58k|                            loc);
 2259|  9.58k|}
_ZN3fmt3v106detail18make_write_int_argIyEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2152|  9.58k|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2153|  9.58k|  auto prefix = 0u;
 2154|  9.58k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2155|  9.58k|  if (is_negative(value)) {
  ------------------
  |  Branch (2155:7): [True: 0, False: 9.58k]
  ------------------
 2156|      0|    prefix = 0x01000000 | '-';
 2157|      0|    abs_value = 0 - abs_value;
 2158|  9.58k|  } else {
 2159|  9.58k|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2160|  9.58k|                                            0x1000000u | ' '};
 2161|  9.58k|    prefix = prefixes[sign];
 2162|  9.58k|  }
 2163|  9.58k|  return {abs_value, prefix};
 2164|  9.58k|}
_ZN3fmt3v106detail13arg_formatterIcEclIPKcEENS0_8appenderET_:
 3788|   767k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3789|   767k|    return detail::write(out, value, specs, locale);
 3790|   767k|  }
_ZN3fmt3v106detail5writeIcNS0_8appenderEEET0_S4_PKT_RKNS0_12format_specsIS5_EENS1_10locale_refE:
 2343|   767k|    -> OutputIt {
 2344|   767k|  return specs.type != presentation_type::pointer
  ------------------
  |  Branch (2344:10): [True: 767k, False: 0]
  ------------------
 2345|   767k|             ? write(out, basic_string_view<Char>(s), specs, {})
 2346|   767k|             : write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
 2347|   767k|}
_ZN3fmt3v106detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewINS0_13type_identityIT_E4typeEEERKNS0_12format_specsIS7_EENS1_10locale_refE:
 2337|   767k|    -> OutputIt {
 2338|   767k|  return write(out, s, specs);
 2339|   767k|}
_ZN3fmt3v106detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS6_EE:
 2314|   767k|                         const format_specs<Char>& specs) -> OutputIt {
 2315|   767k|  auto data = s.data();
 2316|   767k|  auto size = s.size();
 2317|   767k|  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
  ------------------
  |  Branch (2317:7): [True: 0, False: 767k]
  |  Branch (2317:31): [True: 0, False: 0]
  ------------------
 2318|      0|    size = code_point_index(s, to_unsigned(specs.precision));
 2319|   767k|  bool is_debug = specs.type == presentation_type::debug;
 2320|   767k|  size_t width = 0;
 2321|   767k|  if (specs.width != 0) {
  ------------------
  |  Branch (2321:7): [True: 0, False: 767k]
  ------------------
 2322|      0|    if (is_debug)
  ------------------
  |  Branch (2322:9): [True: 0, False: 0]
  ------------------
 2323|      0|      width = write_escaped_string(counting_iterator{}, s).count();
 2324|      0|    else
 2325|      0|      width = compute_width(basic_string_view<Char>(data, size));
 2326|      0|  }
 2327|   767k|  return write_padded(out, specs, size, width,
 2328|   767k|                      [=](reserve_iterator<OutputIt> it) {
 2329|   767k|                        if (is_debug) return write_escaped_string(it, s);
 2330|   767k|                        return copy_str<Char>(data, data + size, it);
 2331|   767k|                      });
 2332|   767k|}
_ZN3fmt3v106detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcZNS1_5writeIcS5_EET0_S7_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS9_EEEUlS5_E_EES7_S7_RKNSB_IT1_EEmmOT2_:
 1769|   767k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1770|   767k|  static_assert(align == align::left || align == align::right, "");
 1771|   767k|  unsigned spec_width = to_unsigned(specs.width);
 1772|   767k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1772:20): [True: 0, False: 767k]
  ------------------
 1773|       |  // Shifts are encoded as string literals because static constexpr is not
 1774|       |  // supported in constexpr functions.
 1775|   767k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1775:18): [Folded - Ignored]
  ------------------
 1776|   767k|  size_t left_padding = padding >> shifts[specs.align];
 1777|   767k|  size_t right_padding = padding - left_padding;
 1778|   767k|  auto it = reserve(out, size + padding * specs.fill.size());
 1779|   767k|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1779:7): [True: 0, False: 767k]
  ------------------
 1780|   767k|  it = f(it);
 1781|   767k|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1781:7): [True: 0, False: 767k]
  ------------------
 1782|   767k|  return base_iterator(out, it);
 1783|   767k|}
_ZZN3fmt3v106detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS6_EEENKUlS3_E_clES3_:
 2328|   767k|                      [=](reserve_iterator<OutputIt> it) {
 2329|   767k|                        if (is_debug) return write_escaped_string(it, s);
  ------------------
  |  Branch (2329:29): [True: 0, False: 767k]
  ------------------
 2330|   767k|                        return copy_str<Char>(data, data + size, it);
 2331|   767k|                      });
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handlerC2ENS0_8appenderENS7_IcEENS0_17basic_format_argsINS0_20basic_format_contextISE_cEEEESC_:
 4391|   492k|        : parse_context(str), context(p_out, p_args, p_loc) {}
_ZN3fmt3v109to_stringIcLm500EEENSt3__112basic_stringIT_NS2_11char_traitsIS4_EENS2_9allocatorIS4_EEEERKNS0_19basic_memory_bufferIS4_XT0_ES8_EE:
 4357|   492k|    -> std::basic_string<Char> {
 4358|   492k|  auto size = buf.size();
 4359|   492k|  detail::assume(size < std::basic_string<Char>().max_size());
 4360|   492k|  return std::basic_string<Char>(buf.data(), size);
 4361|   492k|}

_ZN10ImGuiStyleC2Ev:
 1183|      1|{
 1184|      1|    Alpha                   = 1.0f;             // Global alpha applies to everything in Dear ImGui.
 1185|      1|    DisabledAlpha           = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
 1186|      1|    WindowPadding           = ImVec2(8,8);      // Padding within a window
 1187|      1|    WindowRounding          = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
 1188|      1|    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1189|      1|    WindowMinSize           = ImVec2(32,32);    // Minimum window size
 1190|      1|    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
 1191|      1|    WindowMenuButtonPosition= ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
 1192|      1|    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
 1193|      1|    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1194|      1|    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
 1195|      1|    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1196|      1|    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
 1197|      1|    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
 1198|      1|    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
 1199|      1|    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
 1200|      1|    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
 1201|      1|    CellPadding             = ImVec2(4,2);      // Padding within a table cell. CellPadding.y may be altered between different rows.
 1202|      1|    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
 1203|      1|    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
 1204|      1|    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
 1205|      1|    ScrollbarSize           = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
 1206|      1|    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
 1207|      1|    GrabMinSize             = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar
 1208|      1|    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
 1209|      1|    LogSliderDeadzone       = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
 1210|      1|    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
 1211|      1|    TabBorderSize           = 0.0f;             // Thickness of border around tabs.
 1212|      1|    TabMinWidthForCloseButton = 0.0f;           // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
 1213|      1|    TabBarBorderSize        = 1.0f;             // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
 1214|      1|    ColorButtonPosition     = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
 1215|      1|    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
 1216|      1|    SelectableTextAlign     = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
 1217|      1|    SeparatorTextBorderSize = 3.0f;             // Thickkness of border in SeparatorText()
 1218|      1|    SeparatorTextAlign      = ImVec2(0.0f,0.5f);// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
 1219|      1|    SeparatorTextPadding    = ImVec2(20.0f,3.f);// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
 1220|      1|    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
 1221|      1|    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
 1222|      1|    DockingSeparatorSize    = 2.0f;             // Thickness of resizing border between docked windows
 1223|      1|    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
 1224|      1|    AntiAliasedLines        = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
 1225|      1|    AntiAliasedLinesUseTex  = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
 1226|      1|    AntiAliasedFill         = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
 1227|      1|    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
 1228|      1|    CircleTessellationMaxError = 0.30f;         // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
 1229|       |
 1230|       |    // Behaviors
 1231|      1|    HoverStationaryDelay    = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
 1232|      1|    HoverDelayShort         = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
 1233|      1|    HoverDelayNormal        = 0.40f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
 1234|      1|    HoverFlagsForTooltipMouse = ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_AllowWhenDisabled;    // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
 1235|      1|    HoverFlagsForTooltipNav = ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_AllowWhenDisabled;  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
 1236|       |
 1237|       |    // Default theme
 1238|      1|    ImGui::StyleColorsDark(this);
 1239|      1|}
_ZN7ImGuiIOC2Ev:
 1273|      1|{
 1274|       |    // Most fields are initialized with zero
 1275|      1|    memset(this, 0, sizeof(*this));
 1276|      1|    IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);
  ------------------
  |  |  254|      1|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
 1277|       |
 1278|       |    // Settings
 1279|      1|    ConfigFlags = ImGuiConfigFlags_None;
 1280|      1|    BackendFlags = ImGuiBackendFlags_None;
 1281|      1|    DisplaySize = ImVec2(-1.0f, -1.0f);
 1282|      1|    DeltaTime = 1.0f / 60.0f;
 1283|      1|    IniSavingRate = 5.0f;
 1284|      1|    IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
 1285|      1|    LogFilename = "imgui_log.txt";
 1286|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1287|       |    for (int i = 0; i < ImGuiKey_COUNT; i++)
 1288|       |        KeyMap[i] = -1;
 1289|       |#endif
 1290|      1|    UserData = NULL;
 1291|       |
 1292|      1|    Fonts = NULL;
 1293|      1|    FontGlobalScale = 1.0f;
 1294|      1|    FontDefault = NULL;
 1295|      1|    FontAllowUserScaling = false;
 1296|      1|    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
 1297|       |
 1298|       |    // Docking options (when ImGuiConfigFlags_DockingEnable is set)
 1299|      1|    ConfigDockingNoSplit = false;
 1300|      1|    ConfigDockingWithShift = false;
 1301|      1|    ConfigDockingAlwaysTabBar = false;
 1302|      1|    ConfigDockingTransparentPayload = false;
 1303|       |
 1304|       |    // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
 1305|      1|    ConfigViewportsNoAutoMerge = false;
 1306|      1|    ConfigViewportsNoTaskBarIcon = false;
 1307|      1|    ConfigViewportsNoDecoration = true;
 1308|      1|    ConfigViewportsNoDefaultParent = false;
 1309|       |
 1310|       |    // Miscellaneous options
 1311|      1|    MouseDrawCursor = false;
 1312|       |#ifdef __APPLE__
 1313|       |    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
 1314|       |#else
 1315|      1|    ConfigMacOSXBehaviors = false;
 1316|      1|#endif
 1317|      1|    ConfigInputTrickleEventQueue = true;
 1318|      1|    ConfigInputTextCursorBlink = true;
 1319|      1|    ConfigInputTextEnterKeepActive = false;
 1320|      1|    ConfigDragClickToInputText = false;
 1321|      1|    ConfigWindowsResizeFromEdges = true;
 1322|      1|    ConfigWindowsMoveFromTitleBarOnly = false;
 1323|      1|    ConfigMemoryCompactTimer = 60.0f;
 1324|      1|    ConfigDebugBeginReturnValueOnce = false;
 1325|      1|    ConfigDebugBeginReturnValueLoop = false;
 1326|       |
 1327|       |    // Inputs Behaviors
 1328|      1|    MouseDoubleClickTime = 0.30f;
 1329|      1|    MouseDoubleClickMaxDist = 6.0f;
 1330|      1|    MouseDragThreshold = 6.0f;
 1331|      1|    KeyRepeatDelay = 0.275f;
 1332|      1|    KeyRepeatRate = 0.050f;
 1333|       |
 1334|       |    // Platform Functions
 1335|       |    // Note: Initialize() will setup default clipboard/ime handlers.
 1336|      1|    BackendPlatformName = BackendRendererName = NULL;
 1337|      1|    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
 1338|      1|    PlatformLocaleDecimalPoint = '.';
 1339|       |
 1340|       |    // Input (NB: we already have memset zero the entire structure!)
 1341|      1|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1342|      1|    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
 1343|      1|    MouseSource = ImGuiMouseSource_Mouse;
 1344|      6|    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
  ------------------
  |  |   88|      6|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1344:21): [True: 5, False: 1]
  ------------------
 1345|    141|    for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
  ------------------
  |  |   88|    141|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1345:21): [True: 140, False: 1]
  ------------------
 1346|      1|    AppAcceptingEvents = true;
 1347|      1|    BackendUsingLegacyKeyArrays = (ImS8)-1;
 1348|      1|    BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
 1349|      1|}
_ZN7ImGuiIO17AddInputCharacterEj:
 1356|  4.15k|{
 1357|  4.15k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  4.15k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1358|  4.15k|    ImGuiContext& g = *Ctx;
 1359|  4.15k|    if (c == 0 || !AppAcceptingEvents)
  ------------------
  |  Branch (1359:9): [True: 241, False: 3.91k]
  |  Branch (1359:19): [True: 0, False: 3.91k]
  ------------------
 1360|    241|        return;
 1361|       |
 1362|  3.91k|    ImGuiInputEvent e;
 1363|  3.91k|    e.Type = ImGuiInputEventType_Text;
 1364|  3.91k|    e.Source = ImGuiInputSource_Keyboard;
 1365|  3.91k|    e.EventId = g.InputEventsNextEventId++;
 1366|  3.91k|    e.Text.Char = c;
 1367|  3.91k|    g.InputEventsQueue.push_back(e);
 1368|  3.91k|}
_ZN7ImGuiIO22AddInputCharacterUTF16Et:
 1373|  3.99k|{
 1374|  3.99k|    if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
  ------------------
  |  Branch (1374:10): [True: 328, False: 3.66k]
  |  Branch (1374:20): [True: 238, False: 90]
  |  Branch (1374:49): [True: 0, False: 3.75k]
  ------------------
 1375|    238|        return;
 1376|       |
 1377|  3.75k|    if ((c & 0xFC00) == 0xD800) // High surrogate, must save
  ------------------
  |  Branch (1377:9): [True: 442, False: 3.31k]
  ------------------
 1378|    442|    {
 1379|    442|        if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1379:13): [True: 246, False: 196]
  ------------------
 1380|    246|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2379|    246|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1381|    442|        InputQueueSurrogate = c;
 1382|    442|        return;
 1383|    442|    }
 1384|       |
 1385|  3.31k|    ImWchar cp = c;
 1386|  3.31k|    if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1386:9): [True: 184, False: 3.13k]
  ------------------
 1387|    184|    {
 1388|    184|        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
  ------------------
  |  Branch (1388:13): [True: 150, False: 34]
  ------------------
 1389|    150|        {
 1390|    150|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2379|    150|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1391|    150|        }
 1392|     34|        else
 1393|     34|        {
 1394|     34|#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF
 1395|     34|            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
  ------------------
  |  | 2379|     34|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1396|       |#else
 1397|       |            cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
 1398|       |#endif
 1399|     34|        }
 1400|       |
 1401|    184|        InputQueueSurrogate = 0;
 1402|    184|    }
 1403|  3.31k|    AddInputCharacter((unsigned)cp);
 1404|  3.31k|}
_ZN7ImGuiIO22AddInputCharactersUTF8EPKc:
 1407|     48|{
 1408|     48|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1408:9): [True: 0, False: 48]
  ------------------
 1409|      0|        return;
 1410|     48|    while (*utf8_chars != 0)
  ------------------
  |  Branch (1410:12): [True: 0, False: 48]
  ------------------
 1411|      0|    {
 1412|      0|        unsigned int c = 0;
 1413|      0|        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
 1414|      0|        AddInputCharacter(c);
 1415|      0|    }
 1416|     48|}
_ZN7ImGuiIO14ClearInputKeysEv:
 1428|  6.54k|{
 1429|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1430|       |    memset(KeysDown, 0, sizeof(KeysDown));
 1431|       |#endif
 1432|   922k|    for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++)
  ------------------
  |  |   88|   922k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1432:21): [True: 916k, False: 6.54k]
  ------------------
 1433|   916k|    {
 1434|   916k|        KeysData[n].Down             = false;
 1435|   916k|        KeysData[n].DownDuration     = -1.0f;
 1436|   916k|        KeysData[n].DownDurationPrev = -1.0f;
 1437|   916k|    }
 1438|  6.54k|    KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
 1439|  6.54k|    KeyMods = ImGuiMod_None;
 1440|  6.54k|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1441|  39.2k|    for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)
  ------------------
  |  |   88|  39.2k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1441:21): [True: 32.7k, False: 6.54k]
  ------------------
 1442|  32.7k|    {
 1443|  32.7k|        MouseDown[n] = false;
 1444|  32.7k|        MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
 1445|  32.7k|    }
 1446|  6.54k|    MouseWheel = MouseWheelH = 0.0f;
 1447|  6.54k|    InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().
 1448|  6.54k|}
_ZN7ImGuiIO17AddKeyAnalogEventE8ImGuiKeybf:
 1483|  2.36k|{
 1484|       |    //if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
 1485|  2.36k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  2.36k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1486|  2.36k|    if (key == ImGuiKey_None || !AppAcceptingEvents)
  ------------------
  |  Branch (1486:9): [True: 0, False: 2.36k]
  |  Branch (1486:33): [True: 0, False: 2.36k]
  ------------------
 1487|      0|        return;
 1488|  2.36k|    ImGuiContext& g = *Ctx;
 1489|  2.36k|    IM_ASSERT(ImGui::IsNamedKeyOrModKey(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
  ------------------
  |  |   23|  2.36k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1490|  2.36k|    IM_ASSERT(ImGui::IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.
  ------------------
  |  |   23|  2.36k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1491|  2.36k|    IM_ASSERT(key != ImGuiMod_Shortcut); // We could easily support the translation here but it seems saner to not accept it (TestEngine perform a translation itself)
  ------------------
  |  |   23|  2.36k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1492|       |
 1493|       |    // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
 1494|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1495|       |    IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1496|       |    if (BackendUsingLegacyKeyArrays == -1)
 1497|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 1498|       |            IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1499|       |    BackendUsingLegacyKeyArrays = 0;
 1500|       |#endif
 1501|  2.36k|    if (ImGui::IsGamepadKey(key))
  ------------------
  |  Branch (1501:9): [True: 56, False: 2.31k]
  ------------------
 1502|     56|        BackendUsingLegacyNavInputArray = false;
 1503|       |
 1504|       |    // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
 1505|  2.36k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)key);
 1506|  2.36k|    const ImGuiKeyData* key_data = ImGui::GetKeyData(&g, key);
 1507|  2.36k|    const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
  ------------------
  |  Branch (1507:34): [True: 818, False: 1.54k]
  ------------------
 1508|  2.36k|    const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
  ------------------
  |  Branch (1508:37): [True: 818, False: 1.54k]
  ------------------
 1509|  2.36k|    if (latest_key_down == down && latest_key_analog == analog_value)
  ------------------
  |  Branch (1509:9): [True: 663, False: 1.70k]
  |  Branch (1509:36): [True: 436, False: 227]
  ------------------
 1510|    436|        return;
 1511|       |
 1512|       |    // Add event
 1513|  1.93k|    ImGuiInputEvent e;
 1514|  1.93k|    e.Type = ImGuiInputEventType_Key;
 1515|  1.93k|    e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
  ------------------
  |  Branch (1515:16): [True: 54, False: 1.87k]
  ------------------
 1516|  1.93k|    e.EventId = g.InputEventsNextEventId++;
 1517|  1.93k|    e.Key.Key = key;
 1518|  1.93k|    e.Key.Down = down;
 1519|  1.93k|    e.Key.AnalogValue = analog_value;
 1520|  1.93k|    g.InputEventsQueue.push_back(e);
 1521|  1.93k|}
_ZN7ImGuiIO11AddKeyEventE8ImGuiKeyb:
 1524|  2.00k|{
 1525|  2.00k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1525:9): [True: 0, False: 2.00k]
  ------------------
 1526|      0|        return;
 1527|  2.00k|    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
  ------------------
  |  Branch (1527:34): [True: 1.53k, False: 466]
  ------------------
 1528|  2.00k|}
_ZN7ImGuiIO16AddMousePosEventEff:
 1563|  1.90k|{
 1564|  1.90k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  1.90k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1565|  1.90k|    ImGuiContext& g = *Ctx;
 1566|  1.90k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1566:9): [True: 0, False: 1.90k]
  ------------------
 1567|      0|        return;
 1568|       |
 1569|       |    // Apply same flooring as UpdateMouseInputs()
 1570|  1.90k|    ImVec2 pos((x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y);
  ------------------
  |  Branch (1570:16): [True: 1.90k, False: 0]
  |  Branch (1570:49): [True: 1.90k, False: 0]
  ------------------
 1571|       |
 1572|       |    // Filter duplicate
 1573|  1.90k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MousePos);
 1574|  1.90k|    const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
  ------------------
  |  Branch (1574:31): [True: 850, False: 1.05k]
  ------------------
 1575|  1.90k|    if (latest_pos.x == pos.x && latest_pos.y == pos.y)
  ------------------
  |  Branch (1575:9): [True: 653, False: 1.25k]
  |  Branch (1575:34): [True: 477, False: 176]
  ------------------
 1576|    477|        return;
 1577|       |
 1578|  1.43k|    ImGuiInputEvent e;
 1579|  1.43k|    e.Type = ImGuiInputEventType_MousePos;
 1580|  1.43k|    e.Source = ImGuiInputSource_Mouse;
 1581|  1.43k|    e.EventId = g.InputEventsNextEventId++;
 1582|  1.43k|    e.MousePos.PosX = pos.x;
 1583|  1.43k|    e.MousePos.PosY = pos.y;
 1584|  1.43k|    e.MousePos.MouseSource = g.InputEventsNextMouseSource;
 1585|  1.43k|    g.InputEventsQueue.push_back(e);
 1586|  1.43k|}
_ZN7ImGuiIO19AddMouseButtonEventEib:
 1589|  3.08k|{
 1590|  3.08k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  3.08k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1591|  3.08k|    ImGuiContext& g = *Ctx;
 1592|  3.08k|    IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  3.08k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1593|  3.08k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1593:9): [True: 0, False: 3.08k]
  ------------------
 1594|      0|        return;
 1595|       |
 1596|       |    // Filter duplicate
 1597|  3.08k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseButton, (int)mouse_button);
 1598|  3.08k|    const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
  ------------------
  |  Branch (1598:37): [True: 909, False: 2.17k]
  ------------------
 1599|  3.08k|    if (latest_button_down == down)
  ------------------
  |  Branch (1599:9): [True: 1.28k, False: 1.79k]
  ------------------
 1600|  1.28k|        return;
 1601|       |
 1602|  1.79k|    ImGuiInputEvent e;
 1603|  1.79k|    e.Type = ImGuiInputEventType_MouseButton;
 1604|  1.79k|    e.Source = ImGuiInputSource_Mouse;
 1605|  1.79k|    e.EventId = g.InputEventsNextEventId++;
 1606|  1.79k|    e.MouseButton.Button = mouse_button;
 1607|  1.79k|    e.MouseButton.Down = down;
 1608|  1.79k|    e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
 1609|  1.79k|    g.InputEventsQueue.push_back(e);
 1610|  1.79k|}
_ZN7ImGuiIO18AddMouseWheelEventEff:
 1614|    772|{
 1615|    772|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|    772|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1616|    772|    ImGuiContext& g = *Ctx;
 1617|       |
 1618|       |    // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
 1619|    772|    if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
  ------------------
  |  Branch (1619:9): [True: 0, False: 772]
  |  Branch (1619:33): [True: 125, False: 647]
  |  Branch (1619:52): [True: 19, False: 106]
  ------------------
 1620|     19|        return;
 1621|       |
 1622|    753|    ImGuiInputEvent e;
 1623|    753|    e.Type = ImGuiInputEventType_MouseWheel;
 1624|    753|    e.Source = ImGuiInputSource_Mouse;
 1625|    753|    e.EventId = g.InputEventsNextEventId++;
 1626|    753|    e.MouseWheel.WheelX = wheel_x;
 1627|    753|    e.MouseWheel.WheelY = wheel_y;
 1628|    753|    e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
 1629|    753|    g.InputEventsQueue.push_back(e);
 1630|    753|}
_ZN7ImGuiIO13AddFocusEventEb:
 1663|    604|{
 1664|    604|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|    604|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1665|    604|    ImGuiContext& g = *Ctx;
 1666|       |
 1667|       |    // Filter duplicate
 1668|    604|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Focus);
 1669|    604|    const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
  ------------------
  |  Branch (1669:33): [True: 184, False: 420]
  ------------------
 1670|    604|    if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))
  ------------------
  |  Branch (1670:9): [True: 245, False: 359]
  |  Branch (1670:39): [True: 0, False: 359]
  |  Branch (1670:69): [True: 0, False: 0]
  ------------------
 1671|    245|        return;
 1672|       |
 1673|    359|    ImGuiInputEvent e;
 1674|    359|    e.Type = ImGuiInputEventType_Focus;
 1675|    359|    e.EventId = g.InputEventsNextEventId++;
 1676|    359|    e.AppFocused.Focused = focused;
 1677|    359|    g.InputEventsQueue.push_back(e);
 1678|    359|}
_Z8ImStrdupPKc:
 1829|      4|{
 1830|      4|    size_t len = strlen(str);
 1831|      4|    void* buf = IM_ALLOC(len + 1);
  ------------------
  |  | 1880|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 1832|      4|    return (char*)memcpy(buf, (const void*)str, len + 1);
 1833|      4|}
_Z14ImFormatStringPcmPKcz:
 1947|     18|{
 1948|     18|    va_list args;
 1949|     18|    va_start(args, fmt);
 1950|       |#ifdef IMGUI_USE_STB_SPRINTF
 1951|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 1952|       |#else
 1953|     18|    int w = vsnprintf(buf, buf_size, fmt, args);
 1954|     18|#endif
 1955|     18|    va_end(args);
 1956|     18|    if (buf == NULL)
  ------------------
  |  Branch (1956:9): [True: 0, False: 18]
  ------------------
 1957|      0|        return w;
 1958|     18|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (1958:9): [True: 0, False: 18]
  |  Branch (1958:20): [True: 0, False: 18]
  ------------------
 1959|      0|        w = (int)buf_size - 1;
 1960|     18|    buf[w] = 0;
 1961|     18|    return w;
 1962|     18|}
_Z15ImFormatStringVPcmPKcP13__va_list_tag:
 1965|  25.9k|{
 1966|       |#ifdef IMGUI_USE_STB_SPRINTF
 1967|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 1968|       |#else
 1969|  25.9k|    int w = vsnprintf(buf, buf_size, fmt, args);
 1970|  25.9k|#endif
 1971|  25.9k|    if (buf == NULL)
  ------------------
  |  Branch (1971:9): [True: 0, False: 25.9k]
  ------------------
 1972|      0|        return w;
 1973|  25.9k|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (1973:9): [True: 0, False: 25.9k]
  |  Branch (1973:20): [True: 0, False: 25.9k]
  ------------------
 1974|      0|        w = (int)buf_size - 1;
 1975|  25.9k|    buf[w] = 0;
 1976|  25.9k|    return w;
 1977|  25.9k|}
_Z26ImFormatStringToTempBufferPPKcS1_S0_z:
 1981|  25.9k|{
 1982|  25.9k|    va_list args;
 1983|  25.9k|    va_start(args, fmt);
 1984|  25.9k|    ImFormatStringToTempBufferV(out_buf, out_buf_end, fmt, args);
 1985|  25.9k|    va_end(args);
 1986|  25.9k|}
_Z27ImFormatStringToTempBufferVPPKcS1_S0_P13__va_list_tag:
 1989|  25.9k|{
 1990|  25.9k|    ImGuiContext& g = *GImGui;
 1991|  25.9k|    if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0)
  ------------------
  |  Branch (1991:9): [True: 25.9k, False: 17]
  |  Branch (1991:26): [True: 25.9k, False: 0]
  |  Branch (1991:43): [True: 17, False: 25.9k]
  ------------------
 1992|     17|    {
 1993|     17|        const char* buf = va_arg(args, const char*); // Skip formatting when using "%s"
 1994|     17|        *out_buf = buf;
 1995|     17|        if (out_buf_end) { *out_buf_end = buf + strlen(buf); }
  ------------------
  |  Branch (1995:13): [True: 17, False: 0]
  ------------------
 1996|     17|    }
 1997|  25.9k|    else if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 's' && fmt[4] == 0)
  ------------------
  |  Branch (1997:14): [True: 25.9k, False: 17]
  |  Branch (1997:31): [True: 0, False: 25.9k]
  |  Branch (1997:48): [True: 0, False: 0]
  |  Branch (1997:65): [True: 0, False: 0]
  |  Branch (1997:82): [True: 0, False: 0]
  ------------------
 1998|      0|    {
 1999|      0|        int buf_len = va_arg(args, int); // Skip formatting when using "%.*s"
 2000|      0|        const char* buf = va_arg(args, const char*);
 2001|      0|        *out_buf = buf;
 2002|      0|        *out_buf_end = buf + buf_len; // Disallow not passing 'out_buf_end' here. User is expected to use it.
 2003|      0|    }
 2004|  25.9k|    else
 2005|  25.9k|    {
 2006|  25.9k|        int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
 2007|  25.9k|        *out_buf = g.TempBuffer.Data;
 2008|  25.9k|        if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }
  ------------------
  |  Branch (2008:13): [True: 17, False: 25.9k]
  ------------------
 2009|  25.9k|    }
 2010|  25.9k|}
_Z10ImHashDataPKvmj:
 2039|  25.9k|{
 2040|  25.9k|    ImU32 crc = ~seed;
 2041|  25.9k|    const unsigned char* data = (const unsigned char*)data_p;
 2042|  25.9k|    const ImU32* crc32_lut = GCrc32LookupTable;
 2043|   129k|    while (data_size-- != 0)
  ------------------
  |  Branch (2043:12): [True: 103k, False: 25.9k]
  ------------------
 2044|   103k|        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
 2045|  25.9k|    return ~crc;
 2046|  25.9k|}
_Z9ImHashStrPKcmj:
 2055|   303k|{
 2056|   303k|    seed = ~seed;
 2057|   303k|    ImU32 crc = seed;
 2058|   303k|    const unsigned char* data = (const unsigned char*)data_p;
 2059|   303k|    const ImU32* crc32_lut = GCrc32LookupTable;
 2060|   303k|    if (data_size != 0)
  ------------------
  |  Branch (2060:9): [True: 0, False: 303k]
  ------------------
 2061|      0|    {
 2062|      0|        while (data_size-- != 0)
  ------------------
  |  Branch (2062:16): [True: 0, False: 0]
  ------------------
 2063|      0|        {
 2064|      0|            unsigned char c = *data++;
 2065|      0|            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (2065:17): [True: 0, False: 0]
  |  Branch (2065:29): [True: 0, False: 0]
  |  Branch (2065:47): [True: 0, False: 0]
  |  Branch (2065:65): [True: 0, False: 0]
  ------------------
 2066|      0|                crc = seed;
 2067|      0|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 2068|      0|        }
 2069|      0|    }
 2070|   303k|    else
 2071|   303k|    {
 2072|  4.08M|        while (unsigned char c = *data++)
  ------------------
  |  Branch (2072:30): [True: 3.77M, False: 303k]
  ------------------
 2073|  3.77M|        {
 2074|  3.77M|            if (c == '#' && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (2074:17): [True: 335k, False: 3.44M]
  |  Branch (2074:29): [True: 114k, False: 221k]
  |  Branch (2074:47): [True: 29.3k, False: 84.7k]
  ------------------
 2075|  29.3k|                crc = seed;
 2076|  3.77M|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 2077|  3.77M|        }
 2078|   303k|    }
 2079|   303k|    return ~crc;
 2080|   303k|}
_Z18ImTextCharFromUtf8PjPKcS1_:
 2166|  3.94M|{
 2167|  3.94M|    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
 2168|  3.94M|    static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
 2169|  3.94M|    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
 2170|  3.94M|    static const int shiftc[] = { 0, 18, 12, 6, 0 };
 2171|  3.94M|    static const int shifte[] = { 0, 6, 4, 2, 0 };
 2172|  3.94M|    int len = lengths[*(const unsigned char*)in_text >> 3];
 2173|  3.94M|    int wanted = len + (len ? 0 : 1);
  ------------------
  |  Branch (2173:25): [True: 3.94M, False: 0]
  ------------------
 2174|       |
 2175|  3.94M|    if (in_text_end == NULL)
  ------------------
  |  Branch (2175:9): [True: 0, False: 3.94M]
  ------------------
 2176|      0|        in_text_end = in_text + wanted; // Max length, nulls will be taken into account.
 2177|       |
 2178|       |    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
 2179|       |    // so it is fast even with excessive branching.
 2180|  3.94M|    unsigned char s[4];
 2181|  3.94M|    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
  ------------------
  |  Branch (2181:12): [True: 3.94M, False: 0]
  ------------------
 2182|  3.94M|    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
  ------------------
  |  Branch (2182:12): [True: 3.94M, False: 0]
  ------------------
 2183|  3.94M|    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
  ------------------
  |  Branch (2183:12): [True: 3.47M, False: 470k]
  ------------------
 2184|  3.94M|    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;
  ------------------
  |  Branch (2184:12): [True: 823k, False: 3.12M]
  ------------------
 2185|       |
 2186|       |    // Assume a four-byte character and load four bytes. Unused bits are shifted out.
 2187|  3.94M|    *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
 2188|  3.94M|    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
 2189|  3.94M|    *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
 2190|  3.94M|    *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
 2191|  3.94M|    *out_char >>= shiftc[len];
 2192|       |
 2193|       |    // Accumulate the various error conditions.
 2194|  3.94M|    int e = 0;
 2195|  3.94M|    e  = (*out_char < mins[len]) << 6; // non-canonical encoding
 2196|  3.94M|    e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
 2197|  3.94M|    e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
  ------------------
  |  | 2383|  3.94M|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
 2198|  3.94M|    e |= (s[1] & 0xc0) >> 2;
 2199|  3.94M|    e |= (s[2] & 0xc0) >> 4;
 2200|  3.94M|    e |= (s[3]       ) >> 6;
 2201|  3.94M|    e ^= 0x2a; // top two bits of each tail byte correct?
 2202|  3.94M|    e >>= shifte[len];
 2203|       |
 2204|  3.94M|    if (e)
  ------------------
  |  Branch (2204:9): [True: 5.64k, False: 3.93M]
  ------------------
 2205|  5.64k|    {
 2206|       |        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
 2207|       |        // One byte is consumed in case of invalid first byte of in_text.
 2208|       |        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
 2209|       |        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
 2210|  5.64k|        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
 2211|  5.64k|        *out_char = IM_UNICODE_CODEPOINT_INVALID;
  ------------------
  |  | 2379|  5.64k|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 2212|  5.64k|    }
 2213|       |
 2214|  3.94M|    return wanted;
 2215|  3.94M|}
_ZN5ImGui23ColorConvertU32ToFloat4Ej:
 2362|   118k|{
 2363|   118k|    float s = 1.0f / 255.0f;
 2364|   118k|    return ImVec4(
 2365|   118k|        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2579|   118k|#define IM_COL32_R_SHIFT    0
  ------------------
 2366|   118k|        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2580|   118k|#define IM_COL32_G_SHIFT    8
  ------------------
 2367|   118k|        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2581|   118k|#define IM_COL32_B_SHIFT    16
  ------------------
 2368|   118k|        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
  ------------------
  |  | 2582|   118k|#define IM_COL32_A_SHIFT    24
  ------------------
 2369|   118k|}
_ZN5ImGui23ColorConvertFloat4ToU32ERK6ImVec4:
 2372|   587k|{
 2373|   587k|    ImU32 out;
 2374|   587k|    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  |  283|   587k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  | 2579|   587k|#define IM_COL32_R_SHIFT    0
  ------------------
 2375|   587k|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  |  283|   587k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  | 2580|   587k|#define IM_COL32_G_SHIFT    8
  ------------------
 2376|   587k|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  |  283|   587k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  | 2581|   587k|#define IM_COL32_B_SHIFT    16
  ------------------
 2377|   587k|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  |  283|   587k|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  | 2582|   587k|#define IM_COL32_A_SHIFT    24
  ------------------
 2378|   587k|    return out;
 2379|   587k|}
_ZNK12ImGuiStorage10GetVoidPtrEj:
 2498|  84.6k|{
 2499|  84.6k|    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
 2500|  84.6k|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2500:9): [True: 1, False: 84.6k]
  |  Branch (2500:29): [True: 3, False: 84.6k]
  ------------------
 2501|      4|        return NULL;
 2502|  84.6k|    return it->val_p;
 2503|  84.6k|}
_ZN12ImGuiStorage10SetVoidPtrEjPv:
 2564|      4|{
 2565|      4|    ImGuiStoragePair* it = LowerBound(Data, key);
 2566|      4|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2566:9): [True: 1, False: 3]
  |  Branch (2566:29): [True: 3, False: 0]
  ------------------
 2567|      4|    {
 2568|      4|        Data.insert(it, ImGuiStoragePair(key, val));
 2569|      4|        return;
 2570|      4|    }
 2571|      0|    it->val_p = val;
 2572|      0|}
_ZN5ImGui8GetStyleEv:
 3101|  88.8k|{
 3102|  88.8k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|  88.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3103|  88.8k|    return GImGui->Style;
 3104|  88.8k|}
_ZN5ImGui11GetColorU32Eif:
 3107|   498k|{
 3108|   498k|    ImGuiStyle& style = GImGui->Style;
 3109|   498k|    ImVec4 c = style.Colors[idx];
 3110|   498k|    c.w *= style.Alpha * alpha_mul;
 3111|   498k|    return ColorConvertFloat4ToU32(c);
 3112|   498k|}
_ZN5ImGui14PushStyleColorEiRK6ImVec4:
 3150|  29.4k|{
 3151|  29.4k|    ImGuiContext& g = *GImGui;
 3152|  29.4k|    ImGuiColorMod backup;
 3153|  29.4k|    backup.Col = idx;
 3154|  29.4k|    backup.BackupValue = g.Style.Colors[idx];
 3155|  29.4k|    g.ColorStack.push_back(backup);
 3156|  29.4k|    g.Style.Colors[idx] = col;
 3157|  29.4k|}
_ZN5ImGui13PopStyleColorEi:
 3160|  29.4k|{
 3161|  29.4k|    ImGuiContext& g = *GImGui;
 3162|  29.4k|    if (g.ColorStack.Size < count)
  ------------------
  |  Branch (3162:9): [True: 0, False: 29.4k]
  ------------------
 3163|      0|    {
 3164|      0|        IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
  ------------------
  |  |  268|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3165|      0|        count = g.ColorStack.Size;
 3166|      0|    }
 3167|  58.8k|    while (count > 0)
  ------------------
  |  Branch (3167:12): [True: 29.4k, False: 29.4k]
  ------------------
 3168|  29.4k|    {
 3169|  29.4k|        ImGuiColorMod& backup = g.ColorStack.back();
 3170|  29.4k|        g.Style.Colors[backup.Col] = backup.BackupValue;
 3171|  29.4k|        g.ColorStack.pop_back();
 3172|  29.4k|        count--;
 3173|  29.4k|    }
 3174|  29.4k|}
_ZN5ImGui15GetStyleVarInfoEi:
 3216|  58.7k|{
 3217|  58.7k|    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
  ------------------
  |  |   23|  58.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3218|  58.7k|    IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
  ------------------
  |  |  254|  58.7k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
 3219|  58.7k|    return &GStyleVarInfo[idx];
 3220|  58.7k|}
_ZN5ImGui12PushStyleVarEiRK6ImVec2:
 3237|  29.3k|{
 3238|  29.3k|    ImGuiContext& g = *GImGui;
 3239|  29.3k|    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
 3240|  29.3k|    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
  ------------------
  |  Branch (3240:9): [True: 29.3k, False: 0]
  |  Branch (3240:50): [True: 29.3k, False: 0]
  ------------------
 3241|  29.3k|    {
 3242|  29.3k|        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
 3243|  29.3k|        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
 3244|  29.3k|        *pvar = val;
 3245|  29.3k|        return;
 3246|  29.3k|    }
 3247|      0|    IM_ASSERT_USER_ERROR(0, "Called PushStyleVar() variant with wrong type!");
  ------------------
  |  |  268|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3248|      0|}
_ZN5ImGui11PopStyleVarEi:
 3251|  29.3k|{
 3252|  29.3k|    ImGuiContext& g = *GImGui;
 3253|  29.3k|    if (g.StyleVarStack.Size < count)
  ------------------
  |  Branch (3253:9): [True: 0, False: 29.3k]
  ------------------
 3254|      0|    {
 3255|      0|        IM_ASSERT_USER_ERROR(g.StyleVarStack.Size > count, "Calling PopStyleVar() too many times: stack underflow.");
  ------------------
  |  |  268|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3256|      0|        count = g.StyleVarStack.Size;
 3257|      0|    }
 3258|  58.7k|    while (count > 0)
  ------------------
  |  Branch (3258:12): [True: 29.3k, False: 29.3k]
  ------------------
 3259|  29.3k|    {
 3260|       |        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
 3261|  29.3k|        ImGuiStyleMod& backup = g.StyleVarStack.back();
 3262|  29.3k|        const ImGuiDataVarInfo* info = GetStyleVarInfo(backup.VarIdx);
 3263|  29.3k|        void* data = info->GetVarPtr(&g.Style);
 3264|  29.3k|        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
  ------------------
  |  Branch (3264:13): [True: 29.3k, False: 0]
  |  Branch (3264:50): [True: 0, False: 29.3k]
  ------------------
 3265|  29.3k|        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
  ------------------
  |  Branch (3265:18): [True: 29.3k, False: 0]
  |  Branch (3265:55): [True: 29.3k, False: 0]
  ------------------
 3266|  29.3k|        g.StyleVarStack.pop_back();
 3267|  29.3k|        count--;
 3268|  29.3k|    }
 3269|  29.3k|}
_ZN5ImGui19FindRenderedTextEndEPKcS1_:
 3345|   117k|{
 3346|   117k|    const char* text_display_end = text;
 3347|   117k|    if (!text_end)
  ------------------
  |  Branch (3347:9): [True: 117k, False: 0]
  ------------------
 3348|   117k|        text_end = (const char*)-1;
 3349|       |
 3350|  1.05M|    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
  ------------------
  |  Branch (3350:12): [True: 1.05M, False: 0]
  |  Branch (3350:43): [True: 998k, False: 58.7k]
  |  Branch (3350:73): [True: 939k, False: 58.7k]
  |  Branch (3350:103): [True: 0, False: 58.7k]
  ------------------
 3351|   939k|        text_display_end++;
 3352|   117k|    return text_display_end;
 3353|   117k|}
_ZN5ImGui17RenderTextWrappedE6ImVec2PKcS2_f:
 3384|     24|{
 3385|     24|    ImGuiContext& g = *GImGui;
 3386|     24|    ImGuiWindow* window = g.CurrentWindow;
 3387|       |
 3388|     24|    if (!text_end)
  ------------------
  |  Branch (3388:9): [True: 0, False: 24]
  ------------------
 3389|      0|        text_end = text + strlen(text); // FIXME-OPT
 3390|       |
 3391|     24|    if (text != text_end)
  ------------------
  |  Branch (3391:9): [True: 24, False: 0]
  ------------------
 3392|     24|    {
 3393|     24|        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
 3394|     24|        if (g.LogEnabled)
  ------------------
  |  Branch (3394:13): [True: 0, False: 24]
  ------------------
 3395|      0|            LogRenderedText(&pos, text, text_end);
 3396|     24|    }
 3397|     24|}
_ZN5ImGui19RenderTextClippedExEP10ImDrawListRK6ImVec2S4_PKcS6_PS3_S4_PK6ImRect:
 3405|  58.7k|{
 3406|       |    // Perform CPU side clipping for single clipped element to avoid using scissor state
 3407|  58.7k|    ImVec2 pos = pos_min;
 3408|  58.7k|    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);
  ------------------
  |  Branch (3408:30): [True: 58.7k, False: 0]
  ------------------
 3409|       |
 3410|  58.7k|    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
  ------------------
  |  Branch (3410:30): [True: 58.7k, False: 0]
  ------------------
 3411|  58.7k|    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
  ------------------
  |  Branch (3411:30): [True: 58.7k, False: 0]
  ------------------
 3412|  58.7k|    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
  ------------------
  |  Branch (3412:26): [True: 1, False: 58.7k]
  |  Branch (3412:66): [True: 0, False: 58.7k]
  ------------------
 3413|  58.7k|    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
  ------------------
  |  Branch (3413:9): [True: 58.7k, False: 0]
  ------------------
 3414|  58.7k|        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);
  ------------------
  |  Branch (3414:26): [True: 0, False: 58.7k]
  |  Branch (3414:51): [True: 0, False: 58.7k]
  ------------------
 3415|       |
 3416|       |    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
 3417|  58.7k|    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
  ------------------
  |  Branch (3417:9): [True: 0, False: 58.7k]
  ------------------
 3418|  58.7k|    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
  ------------------
  |  Branch (3418:9): [True: 58.7k, False: 0]
  ------------------
 3419|       |
 3420|       |    // Render
 3421|  58.7k|    if (need_clipping)
  ------------------
  |  Branch (3421:9): [True: 1, False: 58.7k]
  ------------------
 3422|      1|    {
 3423|      1|        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
 3424|      1|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
 3425|      1|    }
 3426|  58.7k|    else
 3427|  58.7k|    {
 3428|  58.7k|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
 3429|  58.7k|    }
 3430|  58.7k|}
_ZN5ImGui17RenderTextClippedERK6ImVec2S2_PKcS4_PS1_S2_PK6ImRect:
 3433|  58.7k|{
 3434|       |    // Hide anything after a '##' string
 3435|  58.7k|    const char* text_display_end = FindRenderedTextEnd(text, text_end);
 3436|  58.7k|    const int text_len = (int)(text_display_end - text);
 3437|  58.7k|    if (text_len == 0)
  ------------------
  |  Branch (3437:9): [True: 0, False: 58.7k]
  ------------------
 3438|      0|        return;
 3439|       |
 3440|  58.7k|    ImGuiContext& g = *GImGui;
 3441|  58.7k|    ImGuiWindow* window = g.CurrentWindow;
 3442|  58.7k|    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
 3443|  58.7k|    if (g.LogEnabled)
  ------------------
  |  Branch (3443:9): [True: 0, False: 58.7k]
  ------------------
 3444|      0|        LogRenderedText(&pos_min, text, text_display_end);
 3445|  58.7k|}
_ZN5ImGui11RenderFrameE6ImVec2S0_jbf:
 3508|  3.41k|{
 3509|  3.41k|    ImGuiContext& g = *GImGui;
 3510|  3.41k|    ImGuiWindow* window = g.CurrentWindow;
 3511|  3.41k|    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
 3512|  3.41k|    const float border_size = g.Style.FrameBorderSize;
 3513|  3.41k|    if (border && border_size > 0.0f)
  ------------------
  |  Branch (3513:9): [True: 3.41k, False: 0]
  |  Branch (3513:19): [True: 3.41k, False: 0]
  ------------------
 3514|  3.41k|    {
 3515|  3.41k|        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
 3516|  3.41k|        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
 3517|  3.41k|    }
 3518|  3.41k|}
_ZN5ImGui18RenderNavHighlightERK6ImRectji:
 3533|  41.3k|{
 3534|  41.3k|    ImGuiContext& g = *GImGui;
 3535|  41.3k|    if (id != g.NavId)
  ------------------
  |  Branch (3535:9): [True: 21.3k, False: 20.0k]
  ------------------
 3536|  21.3k|        return;
 3537|  20.0k|    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
  ------------------
  |  Branch (3537:9): [True: 683, False: 19.3k]
  |  Branch (3537:34): [True: 683, False: 0]
  ------------------
 3538|    683|        return;
 3539|  19.3k|    ImGuiWindow* window = g.CurrentWindow;
 3540|  19.3k|    if (window->DC.NavHideHighlightOneFrame)
  ------------------
  |  Branch (3540:9): [True: 0, False: 19.3k]
  ------------------
 3541|      0|        return;
 3542|       |
 3543|  19.3k|    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
  ------------------
  |  Branch (3543:22): [True: 0, False: 19.3k]
  ------------------
 3544|  19.3k|    ImRect display_rect = bb;
 3545|  19.3k|    display_rect.ClipWith(window->ClipRect);
 3546|  19.3k|    if (flags & ImGuiNavHighlightFlags_TypeDefault)
  ------------------
  |  Branch (3546:9): [True: 2.13k, False: 17.2k]
  ------------------
 3547|  2.13k|    {
 3548|  2.13k|        const float THICKNESS = 2.0f;
 3549|  2.13k|        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
 3550|  2.13k|        display_rect.Expand(ImVec2(DISTANCE, DISTANCE));
 3551|  2.13k|        bool fully_visible = window->ClipRect.Contains(display_rect);
 3552|  2.13k|        if (!fully_visible)
  ------------------
  |  Branch (3552:13): [True: 1.01k, False: 1.12k]
  ------------------
 3553|  1.01k|            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
 3554|  2.13k|        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, 0, THICKNESS);
 3555|  2.13k|        if (!fully_visible)
  ------------------
  |  Branch (3555:13): [True: 1.01k, False: 1.12k]
  ------------------
 3556|  1.01k|            window->DrawList->PopClipRect();
 3557|  2.13k|    }
 3558|  19.3k|    if (flags & ImGuiNavHighlightFlags_TypeThin)
  ------------------
  |  Branch (3558:9): [True: 17.2k, False: 2.13k]
  ------------------
 3559|  17.2k|    {
 3560|  17.2k|        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, 1.0f);
 3561|  17.2k|    }
 3562|  19.3k|}
_ZN5ImGui17GetCurrentContextEv:
 3597|      1|{
 3598|      1|    return GImGui;
 3599|      1|}
_ZN5ImGui17SetCurrentContextEP12ImGuiContext:
 3602|      1|{
 3603|       |#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
 3604|       |    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
 3605|       |#else
 3606|      1|    GImGui = ctx;
 3607|      1|#endif
 3608|      1|}
_ZN5ImGui13CreateContextEP11ImFontAtlas:
 3626|      1|{
 3627|      1|    ImGuiContext* prev_ctx = GetCurrentContext();
 3628|      1|    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
  ------------------
  |  | 1883|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3629|      1|    SetCurrentContext(ctx);
 3630|      1|    Initialize();
 3631|      1|    if (prev_ctx != NULL)
  ------------------
  |  Branch (3631:9): [True: 0, False: 1]
  ------------------
 3632|      0|        SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
 3633|      1|    return ctx;
 3634|      1|}
_ZN5ImGui10InitializeEv:
 3663|      1|{
 3664|      1|    ImGuiContext& g = *GImGui;
 3665|      1|    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3666|       |
 3667|       |    // Add .ini handle for ImGuiWindow and ImGuiTable types
 3668|      1|    {
 3669|      1|        ImGuiSettingsHandler ini_handler;
 3670|      1|        ini_handler.TypeName = "Window";
 3671|      1|        ini_handler.TypeHash = ImHashStr("Window");
 3672|      1|        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
 3673|      1|        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
 3674|      1|        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
 3675|      1|        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
 3676|      1|        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
 3677|      1|        AddSettingsHandler(&ini_handler);
 3678|      1|    }
 3679|      1|    TableSettingsAddSettingsHandler();
 3680|       |
 3681|       |    // Setup default localization table
 3682|      1|    LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));
  ------------------
  |  |   88|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3683|       |
 3684|       |    // Setup default platform clipboard/IME handlers.
 3685|      1|    g.IO.GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;    // Platform dependent default implementations
 3686|      1|    g.IO.SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
 3687|      1|    g.IO.ClipboardUserData = (void*)&g;                          // Default implementation use the ImGuiContext as user data (ideally those would be arguments to the function)
 3688|      1|    g.IO.SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;
 3689|       |
 3690|       |    // Create default viewport
 3691|      1|    ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 1883|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3692|      1|    viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
 3693|      1|    viewport->Idx = 0;
 3694|      1|    viewport->PlatformWindowCreated = true;
 3695|      1|    viewport->Flags = ImGuiViewportFlags_OwnedByApp;
 3696|      1|    g.Viewports.push_back(viewport);
 3697|      1|    g.TempBuffer.resize(1024 * 3 + 1, 0);
 3698|      1|    g.ViewportCreatedCount++;
 3699|      1|    g.PlatformIO.Viewports.push_back(g.Viewports[0]);
 3700|       |
 3701|      1|#ifdef IMGUI_HAS_DOCK
 3702|       |    // Initialize Docking
 3703|      1|    DockContextInitialize(&g);
 3704|      1|#endif
 3705|       |
 3706|      1|    g.Initialized = true;
 3707|      1|}
_ZN5ImGui16CallContextHooksEP12ImGuiContext20ImGuiContextHookType:
 3818|   176k|{
 3819|   176k|    ImGuiContext& g = *ctx;
 3820|   176k|    for (ImGuiContextHook& hook : g.Hooks)
  ------------------
  |  Branch (3820:33): [True: 0, False: 176k]
  ------------------
 3821|      0|        if (hook.Type == hook_type)
  ------------------
  |  Branch (3821:13): [True: 0, False: 0]
  ------------------
 3822|      0|            hook.Callback(&g, &hook);
 3823|   176k|}
_ZN11ImGuiWindowC2EP12ImGuiContextPKc:
 3832|      4|{
 3833|      4|    memset(this, 0, sizeof(*this));
 3834|      4|    Ctx = ctx;
 3835|      4|    Name = ImStrdup(name);
 3836|      4|    NameBufLen = (int)strlen(name) + 1;
 3837|      4|    ID = ImHashStr(name);
 3838|      4|    IDStack.push_back(ID);
 3839|      4|    ViewportAllowPlatformMonitorExtend = -1;
 3840|      4|    ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
 3841|      4|    MoveId = GetID("#MOVE");
 3842|      4|    TabId = GetID("#TAB");
 3843|      4|    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 3844|      4|    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
 3845|      4|    AutoFitFramesX = AutoFitFramesY = -1;
 3846|      4|    AutoPosLastDirection = ImGuiDir_None;
 3847|      4|    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = 0;
 3848|      4|    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
 3849|      4|    LastFrameActive = -1;
 3850|      4|    LastFrameJustFocused = -1;
 3851|      4|    LastTimeActive = -1.0f;
 3852|      4|    FontWindowScale = FontDpiScale = 1.0f;
 3853|      4|    SettingsOffset = -1;
 3854|      4|    DockOrder = -1;
 3855|      4|    DrawList = &DrawListInst;
 3856|      4|    DrawList->_Data = &Ctx->DrawListSharedData;
 3857|      4|    DrawList->_OwnerName = Name;
 3858|      4|    NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX);
 3859|      4|    IM_PLACEMENT_NEW(&WindowClass) ImGuiWindowClass();
  ------------------
  |  | 1882|      8|#define IM_PLACEMENT_NEW(_PTR)              new(ImNewWrapper(), _PTR)
  ------------------
 3860|      4|}
_ZN11ImGuiWindow5GetIDEPKcS1_:
 3870|   162k|{
 3871|   162k|    ImGuiID seed = IDStack.back();
 3872|   162k|    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
  ------------------
  |  Branch (3872:33): [True: 0, False: 162k]
  ------------------
 3873|   162k|    ImGuiContext& g = *Ctx;
 3874|   162k|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (3874:9): [True: 0, False: 162k]
  ------------------
 3875|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
 3876|   162k|    return id;
 3877|   162k|}
_ZN11ImGuiWindow5GetIDEi:
 3890|  25.9k|{
 3891|  25.9k|    ImGuiID seed = IDStack.back();
 3892|  25.9k|    ImGuiID id = ImHashData(&n, sizeof(n), seed);
 3893|  25.9k|    ImGuiContext& g = *Ctx;
 3894|  25.9k|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (3894:9): [True: 0, False: 25.9k]
  ------------------
 3895|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
 3896|  25.9k|    return id;
 3897|  25.9k|}
_ZN5ImGui31GcCompactTransientWindowBuffersEP11ImGuiWindow:
 3933|      2|{
 3934|      2|    window->MemoryCompacted = true;
 3935|      2|    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
 3936|      2|    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
 3937|      2|    window->IDStack.clear();
 3938|      2|    window->DrawList->_ClearFreeMemory();
 3939|      2|    window->DC.ChildWindows.clear();
 3940|      2|    window->DC.ItemWidthStack.clear();
 3941|      2|    window->DC.TextWrapPosStack.clear();
 3942|      2|}
_ZN5ImGui29GcAwakeTransientWindowBuffersEP11ImGuiWindow:
 3945|      1|{
 3946|       |    // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
 3947|       |    // The other buffers tends to amortize much faster.
 3948|      1|    window->MemoryCompacted = false;
 3949|      1|    window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
 3950|      1|    window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
 3951|      1|    window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
 3952|      1|}
_ZN5ImGui11SetActiveIDEjP11ImGuiWindow:
 3955|    173|{
 3956|    173|    ImGuiContext& g = *GImGui;
 3957|       |
 3958|       |    // Clear previous active id
 3959|    173|    if (g.ActiveId != 0)
  ------------------
  |  Branch (3959:9): [True: 57, False: 116]
  ------------------
 3960|     57|    {
 3961|       |        // While most behaved code would make an effort to not steal active id during window move/drag operations,
 3962|       |        // we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
 3963|       |        // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
 3964|     57|        if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)
  ------------------
  |  Branch (3964:13): [True: 0, False: 57]
  |  Branch (3964:39): [True: 0, False: 0]
  ------------------
 3965|      0|        {
 3966|      0|            IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
  ------------------
  |  |  243|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (243:50): [True: 0, False: 0]
  |  |  |  Branch (243:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3967|      0|            g.MovingWindow = NULL;
 3968|      0|        }
 3969|       |
 3970|       |        // This could be written in a more general way (e.g associate a hook to ActiveId),
 3971|       |        // but since this is currently quite an exception we'll leave it as is.
 3972|       |        // One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveId()
 3973|     57|        if (g.InputTextState.ID == g.ActiveId)
  ------------------
  |  Branch (3973:13): [True: 0, False: 57]
  ------------------
 3974|      0|            InputTextDeactivateHook(g.ActiveId);
 3975|     57|    }
 3976|       |
 3977|       |    // Set active id
 3978|    173|    g.ActiveIdIsJustActivated = (g.ActiveId != id);
 3979|    173|    if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (3979:9): [True: 114, False: 59]
  ------------------
 3980|    114|    {
 3981|    114|        IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
  ------------------
  |  |  243|    114|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (243:50): [True: 0, False: 114]
  |  |  |  Branch (243:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3982|    114|        g.ActiveIdTimer = 0.0f;
 3983|    114|        g.ActiveIdHasBeenPressedBefore = false;
 3984|    114|        g.ActiveIdHasBeenEditedBefore = false;
 3985|    114|        g.ActiveIdMouseButton = -1;
 3986|    114|        if (id != 0)
  ------------------
  |  Branch (3986:13): [True: 57, False: 57]
  ------------------
 3987|     57|        {
 3988|     57|            g.LastActiveId = id;
 3989|     57|            g.LastActiveIdTimer = 0.0f;
 3990|     57|        }
 3991|    114|    }
 3992|    173|    g.ActiveId = id;
 3993|    173|    g.ActiveIdAllowOverlap = false;
 3994|    173|    g.ActiveIdNoClearOnFocusLoss = false;
 3995|    173|    g.ActiveIdWindow = window;
 3996|    173|    g.ActiveIdHasBeenEditedThisFrame = false;
 3997|    173|    if (id)
  ------------------
  |  Branch (3997:9): [True: 57, False: 116]
  ------------------
 3998|     57|    {
 3999|     57|        g.ActiveIdIsAlive = id;
 4000|     57|        g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
  ------------------
  |  Branch (4000:29): [True: 0, False: 57]
  |  Branch (4000:54): [True: 0, False: 57]
  ------------------
 4001|     57|        IM_ASSERT(g.ActiveIdSource != ImGuiInputSource_None);
  ------------------
  |  |   23|     57|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4002|     57|    }
 4003|       |
 4004|       |    // Clear declaration of inputs claimed by the widget
 4005|       |    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
 4006|    173|    g.ActiveIdUsingNavDirMask = 0x00;
 4007|    173|    g.ActiveIdUsingAllKeyboardKeys = false;
 4008|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4009|       |    g.ActiveIdUsingNavInputMask = 0x00;
 4010|       |#endif
 4011|    173|}
_ZN5ImGui13ClearActiveIDEv:
 4014|    116|{
 4015|    116|    SetActiveID(0, NULL); // g.ActiveId = 0;
 4016|    116|}
_ZN5ImGui12SetHoveredIDEj:
 4019|    193|{
 4020|    193|    ImGuiContext& g = *GImGui;
 4021|    193|    g.HoveredId = id;
 4022|    193|    g.HoveredIdAllowOverlap = false;
 4023|    193|    if (id != 0 && g.HoveredIdPreviousFrame != id)
  ------------------
  |  Branch (4023:9): [True: 193, False: 0]
  |  Branch (4023:20): [True: 38, False: 155]
  ------------------
 4024|     38|        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
 4025|    193|}
_ZN5ImGui11KeepAliveIDEj:
 4036|   138k|{
 4037|   138k|    ImGuiContext& g = *GImGui;
 4038|   138k|    if (g.ActiveId == id)
  ------------------
  |  Branch (4038:9): [True: 86, False: 138k]
  ------------------
 4039|     86|        g.ActiveIdIsAlive = id;
 4040|   138k|    if (g.ActiveIdPreviousFrame == id)
  ------------------
  |  Branch (4040:9): [True: 86, False: 138k]
  ------------------
 4041|     86|        g.ActiveIdPreviousFrameIsAlive = true;
 4042|   138k|}
_ZN5ImGui24IsWindowContentHoverableEP11ImGuiWindowi:
 4066|    306|{
 4067|       |    // An active popup disable hovering on other windows (apart from its own children)
 4068|       |    // FIXME-OPT: This could be cached/stored within the window.
 4069|    306|    ImGuiContext& g = *GImGui;
 4070|    306|    if (g.NavWindow)
  ------------------
  |  Branch (4070:9): [True: 90, False: 216]
  ------------------
 4071|     90|        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindowDockTree)
  ------------------
  |  Branch (4071:26): [True: 90, False: 0]
  ------------------
 4072|     90|            if (focused_root_window->WasActive && focused_root_window != window->RootWindowDockTree)
  ------------------
  |  Branch (4072:17): [True: 90, False: 0]
  |  Branch (4072:51): [True: 0, False: 90]
  ------------------
 4073|      0|            {
 4074|       |                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
 4075|       |                // NB: The 'else' is important because Modal windows are also Popups.
 4076|      0|                bool want_inhibit = false;
 4077|      0|                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (4077:21): [True: 0, False: 0]
  ------------------
 4078|      0|                    want_inhibit = true;
 4079|      0|                else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
  ------------------
  |  Branch (4079:26): [True: 0, False: 0]
  |  Branch (4079:83): [True: 0, False: 0]
  ------------------
 4080|      0|                    want_inhibit = true;
 4081|       |
 4082|       |                // Inhibit hover unless the window is within the stack of our modal/popup
 4083|      0|                if (want_inhibit)
  ------------------
  |  Branch (4083:21): [True: 0, False: 0]
  ------------------
 4084|      0|                    if (!IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))
  ------------------
  |  Branch (4084:25): [True: 0, False: 0]
  ------------------
 4085|      0|                        return false;
 4086|      0|            }
 4087|       |
 4088|       |    // Filter by viewport
 4089|    306|    if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (4089:9): [True: 0, False: 306]
  ------------------
 4090|      0|        if (g.MovingWindow == NULL || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree)
  ------------------
  |  Branch (4090:13): [True: 0, False: 0]
  |  Branch (4090:39): [True: 0, False: 0]
  ------------------
 4091|      0|            return false;
 4092|       |
 4093|    306|    return true;
 4094|    306|}
_ZN5ImGui13ItemHoverableERK6ImRectji:
 4206|   115k|{
 4207|   115k|    ImGuiContext& g = *GImGui;
 4208|   115k|    ImGuiWindow* window = g.CurrentWindow;
 4209|   115k|    if (g.HoveredWindow != window)
  ------------------
  |  Branch (4209:9): [True: 114k, False: 1.03k]
  ------------------
 4210|   114k|        return false;
 4211|  1.03k|    if (!IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (4211:9): [True: 845, False: 193]
  ------------------
 4212|    845|        return false;
 4213|       |
 4214|    193|    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
  ------------------
  |  Branch (4214:9): [True: 0, False: 193]
  |  Branch (4214:29): [True: 0, False: 0]
  |  Branch (4214:50): [True: 0, False: 0]
  ------------------
 4215|      0|        return false;
 4216|    193|    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (4216:9): [True: 0, False: 193]
  |  Branch (4216:28): [True: 0, False: 0]
  |  Branch (4216:48): [True: 0, False: 0]
  ------------------
 4217|      0|        return false;
 4218|       |
 4219|       |    // Done with rectangle culling so we can perform heavier checks now.
 4220|    193|    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
  ------------------
  |  Branch (4220:9): [True: 193, False: 0]
  |  Branch (4220:66): [True: 0, False: 193]
  ------------------
 4221|      0|    {
 4222|      0|        g.HoveredIdDisabled = true;
 4223|      0|        return false;
 4224|      0|    }
 4225|       |
 4226|       |    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
 4227|       |    // hover test in widgets code. We could also decide to split this function is two.
 4228|    193|    if (id != 0)
  ------------------
  |  Branch (4228:9): [True: 193, False: 0]
  ------------------
 4229|    193|    {
 4230|       |        // Drag source doesn't report as hovered
 4231|    193|        if (g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
  ------------------
  |  Branch (4231:13): [True: 0, False: 193]
  |  Branch (4231:33): [True: 0, False: 0]
  |  Branch (4231:69): [True: 0, False: 0]
  ------------------
 4232|      0|            return false;
 4233|       |
 4234|    193|        SetHoveredID(id);
 4235|       |
 4236|       |        // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
 4237|       |        // This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
 4238|    193|        if (item_flags & ImGuiItemFlags_AllowOverlap)
  ------------------
  |  Branch (4238:13): [True: 0, False: 193]
  ------------------
 4239|      0|        {
 4240|      0|            g.HoveredIdAllowOverlap = true;
 4241|      0|            if (g.HoveredIdPreviousFrame != id)
  ------------------
  |  Branch (4241:17): [True: 0, False: 0]
  ------------------
 4242|      0|                return false;
 4243|      0|        }
 4244|    193|    }
 4245|       |
 4246|       |    // When disabled we'll return false but still set HoveredId
 4247|    193|    if (item_flags & ImGuiItemFlags_Disabled)
  ------------------
  |  Branch (4247:9): [True: 0, False: 193]
  ------------------
 4248|      0|    {
 4249|       |        // Release active id if turning disabled
 4250|      0|        if (g.ActiveId == id && id != 0)
  ------------------
  |  Branch (4250:13): [True: 0, False: 0]
  |  Branch (4250:33): [True: 0, False: 0]
  ------------------
 4251|      0|            ClearActiveID();
 4252|      0|        g.HoveredIdDisabled = true;
 4253|      0|        return false;
 4254|      0|    }
 4255|       |
 4256|    193|    if (id != 0)
  ------------------
  |  Branch (4256:9): [True: 193, False: 0]
  ------------------
 4257|    193|    {
 4258|       |        // [DEBUG] Item Picker tool!
 4259|       |        // We perform the check here because SetHoveredID() is not frequently called (1~ time a frame), making
 4260|       |        // the cost of this tool near-zero. We can get slightly better call-stack and support picking non-hovered
 4261|       |        // items if we performed the test in ItemAdd(), but that would incur a small runtime cost.
 4262|    193|        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
  ------------------
  |  Branch (4262:13): [True: 0, False: 193]
  |  Branch (4262:40): [True: 0, False: 0]
  ------------------
 4263|      0|            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
  ------------------
  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 4264|    193|        if (g.DebugItemPickerBreakId == id)
  ------------------
  |  Branch (4264:13): [True: 0, False: 193]
  ------------------
 4265|      0|            IM_DEBUG_BREAK();
  ------------------
  |  |  313|      0|#define IM_DEBUG_BREAK()    __builtin_debugtrap()
  ------------------
 4266|    193|    }
 4267|       |
 4268|    193|    if (g.NavDisableMouseHover)
  ------------------
  |  Branch (4268:9): [True: 30, False: 163]
  ------------------
 4269|     30|        return false;
 4270|       |
 4271|    163|    return true;
 4272|    193|}
_ZN5ImGui15SetLastItemDataEjiiRK6ImRect:
 4289|  84.6k|{
 4290|  84.6k|    ImGuiContext& g = *GImGui;
 4291|  84.6k|    g.LastItemData.ID = item_id;
 4292|  84.6k|    g.LastItemData.InFlags = in_flags;
 4293|  84.6k|    g.LastItemData.StatusFlags = item_flags;
 4294|  84.6k|    g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;
 4295|  84.6k|}
_ZN5ImGui8MemAllocEm:
 4323|  1.24k|{
 4324|  1.24k|    void* ptr = (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
 4325|  1.24k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 4326|  1.24k|    if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4326:23): [True: 1.24k, False: 2]
  ------------------
 4327|  1.24k|        DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);
 4328|  1.24k|#endif
 4329|  1.24k|    return ptr;
 4330|  1.24k|}
_ZN5ImGui7MemFreeEPv:
 4334|  1.19k|{
 4335|  1.19k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 4336|  1.19k|    if (ptr != NULL)
  ------------------
  |  Branch (4336:9): [True: 1.18k, False: 9]
  ------------------
 4337|  1.18k|        if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4337:27): [True: 1.18k, False: 0]
  ------------------
 4338|  1.18k|            DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);
 4339|  1.19k|#endif
 4340|  1.19k|    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
 4341|  1.19k|}
_ZN5ImGui14DebugAllocHookEP19ImGuiDebugAllocInfoiPvm:
 4345|  2.42k|{
 4346|  2.42k|    ImGuiDebugAllocEntry* entry = &info->LastEntriesBuf[info->LastEntriesIdx];
 4347|  2.42k|    IM_UNUSED(ptr);
  ------------------
  |  |   89|  2.42k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 4348|  2.42k|    if (entry->FrameCount != frame_count)
  ------------------
  |  Branch (4348:9): [True: 36, False: 2.38k]
  ------------------
 4349|     36|    {
 4350|     36|        info->LastEntriesIdx = (info->LastEntriesIdx + 1) % IM_ARRAYSIZE(info->LastEntriesBuf);
  ------------------
  |  |   88|     36|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4351|     36|        entry = &info->LastEntriesBuf[info->LastEntriesIdx];
 4352|     36|        entry->FrameCount = frame_count;
 4353|     36|        entry->AllocCount = entry->FreeCount = 0;
 4354|     36|    }
 4355|  2.42k|    if (size != (size_t)-1)
  ------------------
  |  Branch (4355:9): [True: 1.24k, False: 1.18k]
  ------------------
 4356|  1.24k|    {
 4357|  1.24k|        entry->AllocCount++;
 4358|  1.24k|        info->TotalAllocCount++;
 4359|       |        //printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, size, ptr);
 4360|  1.24k|    }
 4361|  1.18k|    else
 4362|  1.18k|    {
 4363|  1.18k|        entry->FreeCount++;
 4364|  1.18k|        info->TotalFreeCount++;
 4365|       |        //printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
 4366|  1.18k|    }
 4367|  2.42k|}
_ZN5ImGui5GetIOEv:
 4388|   100k|{
 4389|   100k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|   100k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4390|   100k|    return GImGui->IO;
 4391|   100k|}
_ZN5ImGui11GetDrawDataEv:
 4401|  29.3k|{
 4402|  29.3k|    ImGuiContext& g = *GImGui;
 4403|  29.3k|    ImGuiViewportP* viewport = g.Viewports[0];
 4404|  29.3k|    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
  ------------------
  |  Branch (4404:12): [True: 29.3k, False: 0]
  ------------------
 4405|  29.3k|}
_ZN5ImGui7GetTimeEv:
 4408|     87|{
 4409|     87|    return GImGui->Time;
 4410|     87|}
_ZN5ImGui22StartMouseMovingWindowEP11ImGuiWindow:
 4469|     38|{
 4470|       |    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
 4471|       |    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
 4472|       |    // This is because we want ActiveId to be set even when the window is not permitted to move.
 4473|     38|    ImGuiContext& g = *GImGui;
 4474|     38|    FocusWindow(window);
 4475|     38|    SetActiveID(window->MoveId, window);
 4476|     38|    g.NavDisableHighlight = true;
 4477|     38|    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;
 4478|     38|    g.ActiveIdNoClearOnFocusLoss = true;
 4479|     38|    SetActiveIdUsingAllKeyboardKeys();
 4480|       |
 4481|     38|    bool can_move_window = true;
 4482|     38|    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4482:9): [True: 12, False: 26]
  |  Branch (4482:54): [True: 0, False: 26]
  ------------------
 4483|     12|        can_move_window = false;
 4484|     38|    if (ImGuiDockNode* node = window->DockNodeAsHost)
  ------------------
  |  Branch (4484:24): [True: 0, False: 38]
  ------------------
 4485|      0|        if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4485:13): [True: 0, False: 0]
  |  Branch (4485:36): [True: 0, False: 0]
  ------------------
 4486|      0|            can_move_window = false;
 4487|     38|    if (can_move_window)
  ------------------
  |  Branch (4487:9): [True: 26, False: 12]
  ------------------
 4488|     26|        g.MovingWindow = window;
 4489|     38|}
_ZN5ImGui31UpdateMouseMovingWindowNewFrameEv:
 4523|  29.3k|{
 4524|  29.3k|    ImGuiContext& g = *GImGui;
 4525|  29.3k|    if (g.MovingWindow != NULL)
  ------------------
  |  Branch (4525:9): [True: 50, False: 29.3k]
  ------------------
 4526|     50|    {
 4527|       |        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
 4528|       |        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
 4529|     50|        KeepAliveID(g.ActiveId);
 4530|     50|        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
  ------------------
  |  |   23|     50|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4531|     50|        ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
 4532|       |
 4533|       |        // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
 4534|     50|        const bool window_disappared = (!moving_window->WasActive && !moving_window->Active);
  ------------------
  |  Branch (4534:41): [True: 0, False: 50]
  |  Branch (4534:70): [True: 0, False: 0]
  ------------------
 4535|     50|        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared)
  ------------------
  |  Branch (4535:13): [True: 24, False: 26]
  |  Branch (4535:34): [True: 24, False: 0]
  |  Branch (4535:69): [True: 24, False: 0]
  ------------------
 4536|     24|        {
 4537|     24|            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
 4538|     24|            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
  ------------------
  |  Branch (4538:17): [True: 1, False: 23]
  |  Branch (4538:50): [True: 1, False: 22]
  ------------------
 4539|      2|            {
 4540|      2|                SetWindowPos(moving_window, pos, ImGuiCond_Always);
 4541|      2|                if (moving_window->Viewport && moving_window->ViewportOwned) // Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
  ------------------
  |  Branch (4541:21): [True: 2, False: 0]
  |  Branch (4541:48): [True: 0, False: 2]
  ------------------
 4542|      0|                {
 4543|      0|                    moving_window->Viewport->Pos = pos;
 4544|      0|                    moving_window->Viewport->UpdateWorkRect();
 4545|      0|                }
 4546|      2|            }
 4547|     24|            FocusWindow(g.MovingWindow);
 4548|     24|        }
 4549|     26|        else
 4550|     26|        {
 4551|     26|            if (!window_disappared)
  ------------------
  |  Branch (4551:17): [True: 26, False: 0]
  ------------------
 4552|     26|            {
 4553|       |                // Try to merge the window back into the main viewport.
 4554|       |                // This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
 4555|     26|                if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (4555:21): [True: 0, False: 26]
  ------------------
 4556|      0|                    UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport);
 4557|       |
 4558|       |                // Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
 4559|     26|                if (moving_window->Viewport && !IsDragDropPayloadBeingAccepted())
  ------------------
  |  Branch (4559:21): [True: 26, False: 0]
  |  Branch (4559:48): [True: 26, False: 0]
  ------------------
 4560|     26|                    g.MouseViewport = moving_window->Viewport;
 4561|       |
 4562|       |                // Clear the NoInput window flag set by the Viewport system
 4563|     26|                if (moving_window->Viewport)
  ------------------
  |  Branch (4563:21): [True: 26, False: 0]
  ------------------
 4564|     26|                    moving_window->Viewport->Flags &= ~ImGuiViewportFlags_NoInputs;
 4565|     26|            }
 4566|       |
 4567|     26|            g.MovingWindow = NULL;
 4568|     26|            ClearActiveID();
 4569|     26|        }
 4570|     50|    }
 4571|  29.3k|    else
 4572|  29.3k|    {
 4573|       |        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
 4574|  29.3k|        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
  ------------------
  |  Branch (4574:13): [True: 49, False: 29.2k]
  |  Branch (4574:33): [True: 36, False: 13]
  ------------------
 4575|     36|        {
 4576|     36|            KeepAliveID(g.ActiveId);
 4577|     36|            if (!g.IO.MouseDown[0])
  ------------------
  |  Branch (4577:17): [True: 12, False: 24]
  ------------------
 4578|     12|                ClearActiveID();
 4579|     36|        }
 4580|  29.3k|    }
 4581|  29.3k|}
_ZN5ImGui31UpdateMouseMovingWindowEndFrameEv:
 4586|  29.3k|{
 4587|  29.3k|    ImGuiContext& g = *GImGui;
 4588|  29.3k|    if (g.ActiveId != 0 || g.HoveredId != 0)
  ------------------
  |  Branch (4588:9): [True: 67, False: 29.3k]
  |  Branch (4588:28): [True: 193, False: 29.1k]
  ------------------
 4589|    260|        return;
 4590|       |
 4591|       |    // Unless we just made a window/popup appear
 4592|  29.1k|    if (g.NavWindow && g.NavWindow->Appearing)
  ------------------
  |  Branch (4592:9): [True: 21.1k, False: 7.99k]
  |  Branch (4592:24): [True: 1, False: 21.1k]
  ------------------
 4593|      1|        return;
 4594|       |
 4595|       |    // Click on empty space to focus window and start moving
 4596|       |    // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
 4597|  29.1k|    if (g.IO.MouseClicked[0])
  ------------------
  |  Branch (4597:9): [True: 529, False: 28.5k]
  ------------------
 4598|    529|    {
 4599|       |        // Handle the edge case of a popup being closed while clicking in its empty space.
 4600|       |        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
 4601|    529|        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
  ------------------
  |  Branch (4601:36): [True: 38, False: 491]
  ------------------
 4602|    529|        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);
  ------------------
  |  Branch (4602:38): [True: 38, False: 491]
  |  Branch (4602:53): [True: 0, False: 38]
  |  Branch (4602:102): [True: 0, False: 0]
  ------------------
 4603|       |
 4604|    529|        if (root_window != NULL && !is_closed_popup)
  ------------------
  |  Branch (4604:13): [True: 38, False: 491]
  |  Branch (4604:36): [True: 38, False: 0]
  ------------------
 4605|     38|        {
 4606|     38|            StartMouseMovingWindow(g.HoveredWindow); //-V595
 4607|       |
 4608|       |            // Cancel moving if clicked outside of title bar
 4609|     38|            if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
  ------------------
  |  Branch (4609:17): [True: 0, False: 38]
  ------------------
 4610|      0|                if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
  ------------------
  |  Branch (4610:21): [True: 0, False: 0]
  |  Branch (4610:76): [True: 0, False: 0]
  ------------------
 4611|      0|                    if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
  ------------------
  |  Branch (4611:25): [True: 0, False: 0]
  ------------------
 4612|      0|                        g.MovingWindow = NULL;
 4613|       |
 4614|       |            // Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
 4615|     38|            if (g.HoveredIdDisabled)
  ------------------
  |  Branch (4615:17): [True: 0, False: 38]
  ------------------
 4616|      0|                g.MovingWindow = NULL;
 4617|     38|        }
 4618|    491|        else if (root_window == NULL && g.NavWindow != NULL)
  ------------------
  |  Branch (4618:18): [True: 491, False: 0]
  |  Branch (4618:41): [True: 108, False: 383]
  ------------------
 4619|    108|        {
 4620|       |            // Clicking on void disable focus
 4621|    108|            FocusWindow(NULL, ImGuiFocusRequestFlags_UnlessBelowModal);
 4622|    108|        }
 4623|    529|    }
 4624|       |
 4625|       |    // With right mouse button we close popups without changing focus based on where the mouse is aimed
 4626|       |    // Instead, focus will be restored to the window under the bottom-most closed popup.
 4627|       |    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
 4628|  29.1k|    if (g.IO.MouseClicked[1])
  ------------------
  |  Branch (4628:9): [True: 109, False: 28.9k]
  ------------------
 4629|    109|    {
 4630|       |        // Find the top-most window between HoveredWindow and the top-most Modal Window.
 4631|       |        // This is where we can trim the popup stack.
 4632|    109|        ImGuiWindow* modal = GetTopMostPopupModal();
 4633|    109|        bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
  ------------------
  |  Branch (4633:43): [True: 13, False: 96]
  |  Branch (4633:63): [True: 13, False: 0]
  |  Branch (4633:80): [True: 0, False: 0]
  ------------------
 4634|    109|        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
  ------------------
  |  Branch (4634:31): [True: 13, False: 96]
  ------------------
 4635|    109|    }
 4636|  29.1k|}
_ZN5ImGui34UpdateHoveredWindowAndCaptureFlagsEv:
 4668|  29.3k|{
 4669|  29.3k|    ImGuiContext& g = *GImGui;
 4670|  29.3k|    ImGuiIO& io = g.IO;
 4671|  29.3k|    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));
 4672|       |
 4673|       |    // Find the window hovered by mouse:
 4674|       |    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
 4675|       |    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
 4676|       |    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
 4677|  29.3k|    bool clear_hovered_windows = false;
 4678|  29.3k|    FindHoveredWindow();
 4679|  29.3k|    IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4680|       |
 4681|       |    // Modal windows prevents mouse from hovering behind them.
 4682|  29.3k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
 4683|  29.3k|    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window)) // FIXME-MERGE: RootWindowDockTree ?
  ------------------
  |  Branch (4683:9): [True: 0, False: 29.3k]
  |  Branch (4683:25): [True: 0, False: 0]
  |  Branch (4683:44): [True: 0, False: 0]
  ------------------
 4684|      0|        clear_hovered_windows = true;
 4685|       |
 4686|       |    // Disabled mouse?
 4687|  29.3k|    if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
  ------------------
  |  Branch (4687:9): [True: 0, False: 29.3k]
  ------------------
 4688|      0|        clear_hovered_windows = true;
 4689|       |
 4690|       |    // We track click ownership. When clicked outside of a window the click is owned by the application and
 4691|       |    // won't report hovering nor request capture even while dragging over our windows afterward.
 4692|  29.3k|    const bool has_open_popup = (g.OpenPopupStack.Size > 0);
 4693|  29.3k|    const bool has_open_modal = (modal_window != NULL);
 4694|  29.3k|    int mouse_earliest_down = -1;
 4695|  29.3k|    bool mouse_any_down = false;
 4696|   176k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   88|   176k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4696:21): [True: 146k, False: 29.3k]
  ------------------
 4697|   146k|    {
 4698|   146k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (4698:13): [True: 1.10k, False: 145k]
  ------------------
 4699|  1.10k|        {
 4700|  1.10k|            io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
  ------------------
  |  Branch (4700:36): [True: 78, False: 1.03k]
  |  Branch (4700:65): [True: 0, False: 1.03k]
  ------------------
 4701|  1.10k|            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
  ------------------
  |  Branch (4701:52): [True: 78, False: 1.03k]
  |  Branch (4701:81): [True: 0, False: 1.03k]
  ------------------
 4702|  1.10k|        }
 4703|   146k|        mouse_any_down |= io.MouseDown[i];
 4704|   146k|        if (io.MouseDown[i])
  ------------------
  |  Branch (4704:13): [True: 8.49k, False: 138k]
  ------------------
 4705|  8.49k|            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
  ------------------
  |  Branch (4705:17): [True: 4.51k, False: 3.97k]
  |  Branch (4705:46): [True: 1.50k, False: 2.47k]
  ------------------
 4706|  6.02k|                mouse_earliest_down = i;
 4707|   146k|    }
 4708|  29.3k|    const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
  ------------------
  |  Branch (4708:30): [True: 24.8k, False: 4.51k]
  |  Branch (4708:61): [True: 186, False: 4.33k]
  ------------------
 4709|  29.3k|    const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];
  ------------------
  |  Branch (4709:49): [True: 24.8k, False: 4.51k]
  |  Branch (4709:80): [True: 186, False: 4.33k]
  ------------------
 4710|       |
 4711|       |    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
 4712|       |    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
 4713|  29.3k|    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
  ------------------
  |  Branch (4713:48): [True: 0, False: 29.3k]
  |  Branch (4713:68): [True: 0, False: 0]
  ------------------
 4714|  29.3k|    if (!mouse_avail && !mouse_dragging_extern_payload)
  ------------------
  |  Branch (4714:9): [True: 4.33k, False: 25.0k]
  |  Branch (4714:25): [True: 4.33k, False: 0]
  ------------------
 4715|  4.33k|        clear_hovered_windows = true;
 4716|       |
 4717|  29.3k|    if (clear_hovered_windows)
  ------------------
  |  Branch (4717:9): [True: 4.33k, False: 25.0k]
  ------------------
 4718|  4.33k|        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
 4719|       |
 4720|       |    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
 4721|       |    // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
 4722|  29.3k|    if (g.WantCaptureMouseNextFrame != -1)
  ------------------
  |  Branch (4722:9): [True: 0, False: 29.3k]
  ------------------
 4723|      0|    {
 4724|      0|        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
 4725|      0|    }
 4726|  29.3k|    else
 4727|  29.3k|    {
 4728|  29.3k|        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
  ------------------
  |  Branch (4728:32): [True: 25.0k, False: 4.33k]
  |  Branch (4728:48): [True: 545, False: 24.4k]
  |  Branch (4728:75): [True: 52, False: 24.4k]
  |  Branch (4728:95): [True: 0, False: 28.7k]
  ------------------
 4729|  29.3k|        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
  ------------------
  |  Branch (4729:48): [True: 25.0k, False: 4.33k]
  |  Branch (4729:83): [True: 545, False: 24.4k]
  |  Branch (4729:110): [True: 52, False: 24.4k]
  |  Branch (4729:130): [True: 0, False: 28.7k]
  ------------------
 4730|  29.3k|    }
 4731|       |
 4732|       |    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
 4733|  29.3k|    if (g.WantCaptureKeyboardNextFrame != -1)
  ------------------
  |  Branch (4733:9): [True: 0, False: 29.3k]
  ------------------
 4734|      0|        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
 4735|  29.3k|    else
 4736|  29.3k|        io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
  ------------------
  |  Branch (4736:34): [True: 99, False: 29.2k]
  |  Branch (4736:55): [True: 0, False: 29.2k]
  ------------------
 4737|  29.3k|    if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
  ------------------
  |  Branch (4737:9): [True: 18.3k, False: 11.0k]
  |  Branch (4737:25): [True: 18.3k, False: 0]
  |  Branch (4737:82): [True: 18.3k, False: 0]
  ------------------
 4738|  18.3k|        io.WantCaptureKeyboard = true;
 4739|       |
 4740|       |    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
 4741|  29.3k|    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
  ------------------
  |  Branch (4741:24): [True: 0, False: 29.3k]
  ------------------
 4742|  29.3k|}
_ZN5ImGui8NewFrameEv:
 4745|  29.3k|{
 4746|  29.3k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4747|  29.3k|    ImGuiContext& g = *GImGui;
 4748|       |
 4749|       |    // Remove pending delete hooks before frame start.
 4750|       |    // This deferred removal avoid issues of removal while iterating the hook vector
 4751|  29.3k|    for (int n = g.Hooks.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (4751:36): [True: 0, False: 29.3k]
  ------------------
 4752|      0|        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
  ------------------
  |  Branch (4752:13): [True: 0, False: 0]
  ------------------
 4753|      0|            g.Hooks.erase(&g.Hooks[n]);
 4754|       |
 4755|  29.3k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);
 4756|       |
 4757|       |    // Check and assert for various common IO and Configuration mistakes
 4758|  29.3k|    g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
 4759|  29.3k|    ErrorCheckNewFrameSanityChecks();
 4760|  29.3k|    g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;
 4761|       |
 4762|       |    // Load settings on first frame, save settings when modified (after a delay)
 4763|  29.3k|    UpdateSettings();
 4764|       |
 4765|  29.3k|    g.Time += g.IO.DeltaTime;
 4766|  29.3k|    g.WithinFrameScope = true;
 4767|  29.3k|    g.FrameCount += 1;
 4768|  29.3k|    g.TooltipOverrideCount = 0;
 4769|  29.3k|    g.WindowsActiveCount = 0;
 4770|  29.3k|    g.MenusIdSubmittedThisFrame.resize(0);
 4771|       |
 4772|       |    // Calculate frame-rate for the user, as a purely luxurious feature
 4773|  29.3k|    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
 4774|  29.3k|    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
 4775|  29.3k|    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
  ------------------
  |  |   88|  29.3k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4776|  29.3k|    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
  ------------------
  |  |   88|  29.3k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4777|  29.3k|    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;
  ------------------
  |  Branch (4777:22): [True: 29.3k, False: 0]
  ------------------
 4778|       |
 4779|       |    // Process input queue (trickle as many events as possible), turn events into writes to IO structure
 4780|  29.3k|    g.InputEventsTrail.resize(0);
 4781|  29.3k|    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);
 4782|       |
 4783|       |    // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
 4784|  29.3k|    UpdateViewportsNewFrame();
 4785|       |
 4786|       |    // Setup current font and draw list shared data
 4787|       |    // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
 4788|  29.3k|    g.IO.Fonts->Locked = true;
 4789|  29.3k|    SetCurrentFont(GetDefaultFont());
 4790|  29.3k|    IM_ASSERT(g.Font->IsLoaded());
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4791|  29.3k|    ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
 4792|  29.3k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (4792:35): [True: 29.3k, False: 29.3k]
  ------------------
 4793|  29.3k|        virtual_space.Add(viewport->GetMainRect());
 4794|  29.3k|    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
 4795|  29.3k|    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
 4796|  29.3k|    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
 4797|  29.3k|    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
 4798|  29.3k|    if (g.Style.AntiAliasedLines)
  ------------------
  |  Branch (4798:9): [True: 29.3k, False: 0]
  ------------------
 4799|  29.3k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
 4800|  29.3k|    if (g.Style.AntiAliasedLinesUseTex && !(g.Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (4800:9): [True: 29.3k, False: 0]
  |  Branch (4800:43): [True: 29.3k, False: 0]
  ------------------
 4801|  29.3k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
 4802|  29.3k|    if (g.Style.AntiAliasedFill)
  ------------------
  |  Branch (4802:9): [True: 29.3k, False: 0]
  ------------------
 4803|  29.3k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
 4804|  29.3k|    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
  ------------------
  |  Branch (4804:9): [True: 0, False: 29.3k]
  ------------------
 4805|      0|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
 4806|       |
 4807|       |    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
 4808|  29.3k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (4808:35): [True: 29.3k, False: 29.3k]
  ------------------
 4809|  29.3k|    {
 4810|  29.3k|        viewport->DrawData = NULL;
 4811|  29.3k|        viewport->DrawDataP.Valid = false;
 4812|  29.3k|    }
 4813|       |
 4814|       |    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
 4815|  29.3k|    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
  ------------------
  |  Branch (4815:9): [True: 0, False: 29.3k]
  |  Branch (4815:29): [True: 0, False: 0]
  ------------------
 4816|      0|        KeepAliveID(g.DragDropPayload.SourceId);
 4817|       |
 4818|       |    // Update HoveredId data
 4819|  29.3k|    if (!g.HoveredIdPreviousFrame)
  ------------------
  |  Branch (4819:9): [True: 29.1k, False: 193]
  ------------------
 4820|  29.1k|        g.HoveredIdTimer = 0.0f;
 4821|  29.3k|    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
  ------------------
  |  Branch (4821:9): [True: 29.1k, False: 193]
  |  Branch (4821:39): [True: 155, False: 38]
  |  Branch (4821:54): [True: 0, False: 155]
  ------------------
 4822|  29.1k|        g.HoveredIdNotActiveTimer = 0.0f;
 4823|  29.3k|    if (g.HoveredId)
  ------------------
  |  Branch (4823:9): [True: 193, False: 29.1k]
  ------------------
 4824|    193|        g.HoveredIdTimer += g.IO.DeltaTime;
 4825|  29.3k|    if (g.HoveredId && g.ActiveId != g.HoveredId)
  ------------------
  |  Branch (4825:9): [True: 193, False: 29.1k]
  |  Branch (4825:24): [True: 193, False: 0]
  ------------------
 4826|    193|        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
 4827|  29.3k|    g.HoveredIdPreviousFrame = g.HoveredId;
 4828|  29.3k|    g.HoveredId = 0;
 4829|  29.3k|    g.HoveredIdAllowOverlap = false;
 4830|  29.3k|    g.HoveredIdDisabled = false;
 4831|       |
 4832|       |    // Clear ActiveID if the item is not alive anymore.
 4833|       |    // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
 4834|       |    // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
 4835|  29.3k|    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
  ------------------
  |  Branch (4835:9): [True: 103, False: 29.2k]
  |  Branch (4835:28): [True: 0, False: 103]
  |  Branch (4835:63): [True: 0, False: 0]
  ------------------
 4836|      0|    {
 4837|      0|        IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
  ------------------
  |  |  243|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (243:50): [True: 0, False: 0]
  |  |  |  Branch (243:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4838|      0|        ClearActiveID();
 4839|      0|    }
 4840|       |
 4841|       |    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
 4842|  29.3k|    if (g.ActiveId)
  ------------------
  |  Branch (4842:9): [True: 103, False: 29.2k]
  ------------------
 4843|    103|        g.ActiveIdTimer += g.IO.DeltaTime;
 4844|  29.3k|    g.LastActiveIdTimer += g.IO.DeltaTime;
 4845|  29.3k|    g.ActiveIdPreviousFrame = g.ActiveId;
 4846|  29.3k|    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
 4847|  29.3k|    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
 4848|  29.3k|    g.ActiveIdIsAlive = 0;
 4849|  29.3k|    g.ActiveIdHasBeenEditedThisFrame = false;
 4850|  29.3k|    g.ActiveIdPreviousFrameIsAlive = false;
 4851|  29.3k|    g.ActiveIdIsJustActivated = false;
 4852|  29.3k|    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
  ------------------
  |  Branch (4852:9): [True: 0, False: 29.3k]
  |  Branch (4852:31): [True: 0, False: 0]
  ------------------
 4853|      0|        g.TempInputId = 0;
 4854|  29.3k|    if (g.ActiveId == 0)
  ------------------
  |  Branch (4854:9): [True: 29.2k, False: 103]
  ------------------
 4855|  29.2k|    {
 4856|  29.2k|        g.ActiveIdUsingNavDirMask = 0x00;
 4857|  29.2k|        g.ActiveIdUsingAllKeyboardKeys = false;
 4858|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4859|       |        g.ActiveIdUsingNavInputMask = 0x00;
 4860|       |#endif
 4861|  29.2k|    }
 4862|       |
 4863|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4864|       |    if (g.ActiveId == 0)
 4865|       |        g.ActiveIdUsingNavInputMask = 0;
 4866|       |    else if (g.ActiveIdUsingNavInputMask != 0)
 4867|       |    {
 4868|       |        // If your custom widget code used:                 { g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel); }
 4869|       |        // Since IMGUI_VERSION_NUM >= 18804 it should be:   { SetKeyOwner(ImGuiKey_Escape, g.ActiveId); SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId); }
 4870|       |        if (g.ActiveIdUsingNavInputMask & (1 << ImGuiNavInput_Cancel))
 4871|       |            SetKeyOwner(ImGuiKey_Escape, g.ActiveId);
 4872|       |        if (g.ActiveIdUsingNavInputMask & ~(1 << ImGuiNavInput_Cancel))
 4873|       |            IM_ASSERT(0); // Other values unsupported
 4874|       |    }
 4875|       |#endif
 4876|       |
 4877|       |    // Record when we have been stationary as this state is preserved while over same item.
 4878|       |    // FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
 4879|       |    // To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
 4880|  29.3k|    if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
  ------------------
  |  Branch (4880:9): [True: 0, False: 29.3k]
  |  Branch (4880:36): [True: 0, False: 0]
  ------------------
 4881|      0|        g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
 4882|  29.3k|    else if (g.HoverItemDelayId == 0)
  ------------------
  |  Branch (4882:14): [True: 29.3k, False: 0]
  ------------------
 4883|  29.3k|        g.HoverItemUnlockedStationaryId = 0;
 4884|  29.3k|    if (g.HoveredWindow != NULL && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
  ------------------
  |  Branch (4884:9): [True: 545, False: 28.8k]
  |  Branch (4884:36): [True: 491, False: 54]
  ------------------
 4885|    491|        g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;
 4886|  28.8k|    else if (g.HoveredWindow == NULL)
  ------------------
  |  Branch (4886:14): [True: 28.8k, False: 54]
  ------------------
 4887|  28.8k|        g.HoverWindowUnlockedStationaryId = 0;
 4888|       |
 4889|       |    // Update hover delay for IsItemHovered() with delays and tooltips
 4890|  29.3k|    g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
 4891|  29.3k|    if (g.HoverItemDelayId != 0)
  ------------------
  |  Branch (4891:9): [True: 0, False: 29.3k]
  ------------------
 4892|      0|    {
 4893|      0|        g.HoverItemDelayTimer += g.IO.DeltaTime;
 4894|      0|        g.HoverItemDelayClearTimer = 0.0f;
 4895|      0|        g.HoverItemDelayId = 0;
 4896|      0|    }
 4897|  29.3k|    else if (g.HoverItemDelayTimer > 0.0f)
  ------------------
  |  Branch (4897:14): [True: 0, False: 29.3k]
  ------------------
 4898|      0|    {
 4899|       |        // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
 4900|       |        // We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
 4901|      0|        g.HoverItemDelayClearTimer += g.IO.DeltaTime;
 4902|      0|        if (g.HoverItemDelayClearTimer >= ImMax(0.25f, g.IO.DeltaTime * 2.0f)) // ~7 frames at 30 Hz + allow for low framerate
  ------------------
  |  Branch (4902:13): [True: 0, False: 0]
  ------------------
 4903|      0|            g.HoverItemDelayTimer = g.HoverItemDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
 4904|      0|    }
 4905|       |
 4906|       |    // Drag and drop
 4907|  29.3k|    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
 4908|  29.3k|    g.DragDropAcceptIdCurr = 0;
 4909|  29.3k|    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
 4910|  29.3k|    g.DragDropWithinSource = false;
 4911|  29.3k|    g.DragDropWithinTarget = false;
 4912|  29.3k|    g.DragDropHoldJustPressedId = 0;
 4913|       |
 4914|       |    // Close popups on focus lost (currently wip/opt-in)
 4915|       |    //if (g.IO.AppFocusLost)
 4916|       |    //    ClosePopupsExceptModals();
 4917|       |
 4918|       |    // Update keyboard input state
 4919|  29.3k|    UpdateKeyboardInputs();
 4920|       |
 4921|       |    //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
 4922|       |    //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
 4923|       |    //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
 4924|       |    //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));
 4925|       |
 4926|       |    // Update gamepad/keyboard navigation
 4927|  29.3k|    NavUpdate();
 4928|       |
 4929|       |    // Update mouse input state
 4930|  29.3k|    UpdateMouseInputs();
 4931|       |
 4932|       |    // Undocking
 4933|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
 4934|  29.3k|    DockContextNewFrameUpdateUndocking(&g);
 4935|       |
 4936|       |    // Find hovered window
 4937|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
 4938|  29.3k|    UpdateHoveredWindowAndCaptureFlags();
 4939|       |
 4940|       |    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
 4941|  29.3k|    UpdateMouseMovingWindowNewFrame();
 4942|       |
 4943|       |    // Background darkening/whitening
 4944|  29.3k|    if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
  ------------------
  |  Branch (4944:9): [True: 0, False: 29.3k]
  |  Branch (4944:44): [True: 0, False: 29.3k]
  |  Branch (4944:76): [True: 0, False: 0]
  ------------------
 4945|      0|        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
 4946|  29.3k|    else
 4947|  29.3k|        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);
 4948|       |
 4949|  29.3k|    g.MouseCursor = ImGuiMouseCursor_Arrow;
 4950|  29.3k|    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
 4951|       |
 4952|       |    // Platform IME data: reset for the frame
 4953|  29.3k|    g.PlatformImeDataPrev = g.PlatformImeData;
 4954|  29.3k|    g.PlatformImeData.WantVisible = false;
 4955|       |
 4956|       |    // Mouse wheel scrolling, scale
 4957|  29.3k|    UpdateMouseWheel();
 4958|       |
 4959|       |    // Mark all windows as not visible and compact unused memory.
 4960|  29.3k|    IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4961|  29.3k|    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
  ------------------
  |  Branch (4961:46): [True: 0, False: 29.3k]
  |  Branch (4961:64): [True: 0, False: 29.3k]
  ------------------
 4962|  29.3k|    for (ImGuiWindow* window : g.Windows)
  ------------------
  |  Branch (4962:30): [True: 115k, False: 29.3k]
  ------------------
 4963|   115k|    {
 4964|   115k|        window->WasActive = window->Active;
 4965|   115k|        window->Active = false;
 4966|   115k|        window->WriteAccessed = false;
 4967|   115k|        window->BeginCountPreviousFrame = window->BeginCount;
 4968|   115k|        window->BeginCount = 0;
 4969|       |
 4970|       |        // Garbage collect transient buffers of recently unused windows
 4971|   115k|        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (4971:13): [True: 60.6k, False: 55.3k]
  |  Branch (4971:35): [True: 43.0k, False: 17.5k]
  |  Branch (4971:63): [True: 2, False: 43.0k]
  ------------------
 4972|      2|            GcCompactTransientWindowBuffers(window);
 4973|   115k|    }
 4974|       |
 4975|       |    // Garbage collect transient buffers of recently unused tables
 4976|  29.3k|    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
  ------------------
  |  Branch (4976:21): [True: 0, False: 29.3k]
  ------------------
 4977|      0|        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
  ------------------
  |  Branch (4977:13): [True: 0, False: 0]
  |  Branch (4977:50): [True: 0, False: 0]
  ------------------
 4978|      0|            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
 4979|  29.3k|    for (ImGuiTableTempData& table_temp_data : g.TablesTempData)
  ------------------
  |  Branch (4979:46): [True: 0, False: 29.3k]
  ------------------
 4980|      0|        if (table_temp_data.LastTimeActive >= 0.0f && table_temp_data.LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (4980:13): [True: 0, False: 0]
  |  Branch (4980:55): [True: 0, False: 0]
  ------------------
 4981|      0|            TableGcCompactTransientBuffers(&table_temp_data);
 4982|  29.3k|    if (g.GcCompactAll)
  ------------------
  |  Branch (4982:9): [True: 0, False: 29.3k]
  ------------------
 4983|      0|        GcCompactTransientMiscBuffers();
 4984|  29.3k|    g.GcCompactAll = false;
 4985|       |
 4986|       |    // Closing the focused window restore focus to the first active root window in descending z-order
 4987|  29.3k|    if (g.NavWindow && !g.NavWindow->WasActive)
  ------------------
  |  Branch (4987:9): [True: 18.3k, False: 11.0k]
  |  Branch (4987:24): [True: 0, False: 18.3k]
  ------------------
 4988|      0|        FocusTopMostWindowUnderOne(NULL, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild);
 4989|       |
 4990|       |    // No window should be open at the beginning of the frame.
 4991|       |    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
 4992|  29.3k|    g.CurrentWindowStack.resize(0);
 4993|  29.3k|    g.BeginPopupStack.resize(0);
 4994|  29.3k|    g.ItemFlagsStack.resize(0);
 4995|  29.3k|    g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
 4996|  29.3k|    g.GroupStack.resize(0);
 4997|       |
 4998|       |    // Docking
 4999|  29.3k|    DockContextNewFrameUpdateDocking(&g);
 5000|       |
 5001|       |    // [DEBUG] Update debug features
 5002|  29.3k|    UpdateDebugToolItemPicker();
 5003|  29.3k|    UpdateDebugToolStackQueries();
 5004|  29.3k|    if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
  ------------------
  |  Branch (5004:9): [True: 0, False: 29.3k]
  |  Branch (5004:36): [True: 0, False: 0]
  ------------------
 5005|      0|        g.DebugLocateId = 0;
 5006|  29.3k|    if (g.DebugLogClipperAutoDisableFrames > 0 && --g.DebugLogClipperAutoDisableFrames == 0)
  ------------------
  |  Branch (5006:9): [True: 0, False: 29.3k]
  |  Branch (5006:51): [True: 0, False: 0]
  ------------------
 5007|      0|    {
 5008|      0|        DebugLog("(Auto-disabled ImGuiDebugLogFlags_EventClipper to avoid spamming)\n");
 5009|      0|        g.DebugLogFlags &= ~ImGuiDebugLogFlags_EventClipper;
 5010|      0|    }
 5011|       |
 5012|       |    // Create implicit/fallback window - which we will only render it if the user has added something to it.
 5013|       |    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
 5014|       |    // This fallback is particularly important as it prevents ImGui:: calls from crashing.
 5015|  29.3k|    g.WithinFrameScopeWithImplicitWindow = true;
 5016|  29.3k|    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
 5017|  29.3k|    Begin("Debug##Default");
 5018|  29.3k|    IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5019|       |
 5020|       |    // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
 5021|       |    // allowing to validate correct Begin/End behavior in user code.
 5022|  29.3k|    if (g.IO.ConfigDebugBeginReturnValueLoop)
  ------------------
  |  Branch (5022:9): [True: 0, False: 29.3k]
  ------------------
 5023|      0|        g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);
  ------------------
  |  Branch (5023:44): [True: 0, False: 0]
  |  Branch (5023:129): [True: 0, False: 0]
  ------------------
 5024|  29.3k|    else
 5025|  29.3k|        g.DebugBeginReturnValueCullDepth = -1;
 5026|       |
 5027|  29.3k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
 5028|  29.3k|}
_ZN5ImGui12PushClipRectERK6ImVec2S2_b:
 5135|   169k|{
 5136|   169k|    ImGuiWindow* window = GetCurrentWindow();
 5137|   169k|    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
 5138|   169k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 5139|   169k|}
_ZN5ImGui11PopClipRectEv:
 5142|  84.6k|{
 5143|  84.6k|    ImGuiWindow* window = GetCurrentWindow();
 5144|  84.6k|    window->DrawList->PopClipRect();
 5145|  84.6k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 5146|  84.6k|}
_ZN5ImGui8EndFrameEv:
 5273|  58.7k|{
 5274|  58.7k|    ImGuiContext& g = *GImGui;
 5275|  58.7k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  58.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5276|       |
 5277|       |    // Don't process EndFrame() multiple times.
 5278|  58.7k|    if (g.FrameCountEnded == g.FrameCount)
  ------------------
  |  Branch (5278:9): [True: 29.3k, False: 29.3k]
  ------------------
 5279|  29.3k|        return;
 5280|  29.3k|    IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5281|       |
 5282|  29.3k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);
 5283|       |
 5284|  29.3k|    ErrorCheckEndFrameSanityChecks();
 5285|       |
 5286|       |    // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
 5287|  29.3k|    ImGuiPlatformImeData* ime_data = &g.PlatformImeData;
 5288|  29.3k|    if (g.IO.SetPlatformImeDataFn && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
  ------------------
  |  Branch (5288:9): [True: 29.3k, False: 0]
  |  Branch (5288:38): [True: 0, False: 29.3k]
  ------------------
 5289|      0|    {
 5290|      0|        ImGuiViewport* viewport = FindViewportByID(g.PlatformImeViewport);
 5291|      0|        IMGUI_DEBUG_LOG_IO("[io] Calling io.SetPlatformImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);
  ------------------
  |  |  249|      0|#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (249:50): [True: 0, False: 0]
  |  |  |  Branch (249:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5292|      0|        if (viewport == NULL)
  ------------------
  |  Branch (5292:13): [True: 0, False: 0]
  ------------------
 5293|      0|            viewport = GetMainViewport();
 5294|       |#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
 5295|       |        if (viewport->PlatformHandleRaw == NULL && g.IO.ImeWindowHandle != NULL)
 5296|       |        {
 5297|       |            viewport->PlatformHandleRaw = g.IO.ImeWindowHandle;
 5298|       |            g.IO.SetPlatformImeDataFn(viewport, ime_data);
 5299|       |            viewport->PlatformHandleRaw = NULL;
 5300|       |        }
 5301|       |        else
 5302|       |#endif
 5303|      0|        {
 5304|      0|            g.IO.SetPlatformImeDataFn(viewport, ime_data);
 5305|      0|        }
 5306|      0|    }
 5307|       |
 5308|       |    // Hide implicit/fallback "Debug" window if it hasn't been used
 5309|  29.3k|    g.WithinFrameScopeWithImplicitWindow = false;
 5310|  29.3k|    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
  ------------------
  |  Branch (5310:9): [True: 29.3k, False: 0]
  |  Branch (5310:28): [True: 29.3k, False: 0]
  ------------------
 5311|  29.3k|        g.CurrentWindow->Active = false;
 5312|  29.3k|    End();
 5313|       |
 5314|       |    // Update navigation: CTRL+Tab, wrap-around requests
 5315|  29.3k|    NavEndFrame();
 5316|       |
 5317|       |    // Update docking
 5318|  29.3k|    DockContextEndFrame(&g);
 5319|       |
 5320|  29.3k|    SetCurrentViewport(NULL, NULL);
 5321|       |
 5322|       |    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
 5323|  29.3k|    if (g.DragDropActive)
  ------------------
  |  Branch (5323:9): [True: 0, False: 29.3k]
  ------------------
 5324|      0|    {
 5325|      0|        bool is_delivered = g.DragDropPayload.Delivery;
 5326|      0|        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
  ------------------
  |  Branch (5326:27): [True: 0, False: 0]
  |  Branch (5326:85): [True: 0, False: 0]
  |  Branch (5326:157): [True: 0, False: 0]
  ------------------
 5327|      0|        if (is_delivered || is_elapsed)
  ------------------
  |  Branch (5327:13): [True: 0, False: 0]
  |  Branch (5327:29): [True: 0, False: 0]
  ------------------
 5328|      0|            ClearDragDrop();
 5329|      0|    }
 5330|       |
 5331|       |    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
 5332|  29.3k|    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (5332:9): [True: 0, False: 29.3k]
  |  Branch (5332:29): [True: 0, False: 0]
  |  Branch (5332:74): [True: 0, False: 0]
  ------------------
 5333|      0|    {
 5334|      0|        g.DragDropWithinSource = true;
 5335|      0|        SetTooltip("...");
 5336|      0|        g.DragDropWithinSource = false;
 5337|      0|    }
 5338|       |
 5339|       |    // End frame
 5340|  29.3k|    g.WithinFrameScope = false;
 5341|  29.3k|    g.FrameCountEnded = g.FrameCount;
 5342|       |
 5343|       |    // Initiate moving window + handle left-click and right-click focus
 5344|  29.3k|    UpdateMouseMovingWindowEndFrame();
 5345|       |
 5346|       |    // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
 5347|  29.3k|    UpdateViewportsEndFrame();
 5348|       |
 5349|       |    // Sort the window list so that all child windows are after their parent
 5350|       |    // We cannot do that on FocusWindow() because children may not exist yet
 5351|  29.3k|    g.WindowsTempSortBuffer.resize(0);
 5352|  29.3k|    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
 5353|  29.3k|    for (ImGuiWindow* window : g.Windows)
  ------------------
  |  Branch (5353:30): [True: 115k, False: 29.3k]
  ------------------
 5354|   115k|    {
 5355|   115k|        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
  ------------------
  |  Branch (5355:13): [True: 55.3k, False: 60.6k]
  |  Branch (5355:31): [True: 25.9k, False: 29.3k]
  ------------------
 5356|  25.9k|            continue;
 5357|  90.0k|        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
 5358|  90.0k|    }
 5359|       |
 5360|       |    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
 5361|  29.3k|    IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5362|  29.3k|    g.Windows.swap(g.WindowsTempSortBuffer);
 5363|  29.3k|    g.IO.MetricsActiveWindows = g.WindowsActiveCount;
 5364|       |
 5365|       |    // Unlock font atlas
 5366|  29.3k|    g.IO.Fonts->Locked = false;
 5367|       |
 5368|       |    // Clear Input data for next frame
 5369|  29.3k|    g.IO.MousePosPrev = g.IO.MousePos;
 5370|  29.3k|    g.IO.AppFocusLost = false;
 5371|  29.3k|    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
 5372|  29.3k|    g.IO.InputQueueCharacters.resize(0);
 5373|       |
 5374|  29.3k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
 5375|  29.3k|}
_ZN5ImGui6RenderEv:
 5381|  29.3k|{
 5382|  29.3k|    ImGuiContext& g = *GImGui;
 5383|  29.3k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5384|       |
 5385|  29.3k|    if (g.FrameCountEnded != g.FrameCount)
  ------------------
  |  Branch (5385:9): [True: 29.3k, False: 0]
  ------------------
 5386|  29.3k|        EndFrame();
 5387|  29.3k|    if (g.FrameCountRendered == g.FrameCount)
  ------------------
  |  Branch (5387:9): [True: 0, False: 29.3k]
  ------------------
 5388|      0|        return;
 5389|  29.3k|    g.FrameCountRendered = g.FrameCount;
 5390|       |
 5391|  29.3k|    g.IO.MetricsRenderWindows = 0;
 5392|  29.3k|    CallContextHooks(&g, ImGuiContextHookType_RenderPre);
 5393|       |
 5394|       |    // Add background ImDrawList (for each active viewport)
 5395|  29.3k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (5395:35): [True: 29.3k, False: 29.3k]
  ------------------
 5396|  29.3k|    {
 5397|  29.3k|        InitViewportDrawData(viewport);
 5398|  29.3k|        if (viewport->BgFgDrawLists[0] != NULL)
  ------------------
  |  Branch (5398:13): [True: 0, False: 29.3k]
  ------------------
 5399|      0|            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
 5400|  29.3k|    }
 5401|       |
 5402|       |    // Draw modal/window whitening backgrounds
 5403|  29.3k|    RenderDimmedBackgrounds();
 5404|       |
 5405|       |    // Add ImDrawList to render
 5406|  29.3k|    ImGuiWindow* windows_to_render_top_most[2];
 5407|  29.3k|    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
  ------------------
  |  Branch (5407:38): [True: 0, False: 29.3k]
  |  Branch (5407:62): [True: 0, False: 0]
  ------------------
 5408|  29.3k|    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
  ------------------
  |  Branch (5408:38): [True: 0, False: 29.3k]
  ------------------
 5409|  29.3k|    for (ImGuiWindow* window : g.Windows)
  ------------------
  |  Branch (5409:30): [True: 115k, False: 29.3k]
  ------------------
 5410|   115k|    {
 5411|   115k|        IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
 5412|   115k|        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
  ------------------
  |  Branch (5412:13): [True: 42.0k, False: 73.8k]
  |  Branch (5412:49): [True: 29.3k, False: 12.7k]
  |  Branch (5412:104): [True: 29.3k, False: 0]
  |  Branch (5412:147): [True: 29.3k, False: 0]
  ------------------
 5413|  29.3k|            AddRootWindowToDrawData(window);
 5414|   115k|    }
 5415|  88.1k|    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
  ------------------
  |  |   88|  88.1k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5415:21): [True: 58.7k, False: 29.3k]
  ------------------
 5416|  58.7k|        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
  ------------------
  |  Branch (5416:13): [True: 0, False: 58.7k]
  |  Branch (5416:46): [True: 0, False: 0]
  ------------------
 5417|      0|            AddRootWindowToDrawData(windows_to_render_top_most[n]);
 5418|       |
 5419|       |    // Draw software mouse cursor if requested by io.MouseDrawCursor flag
 5420|  29.3k|    if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)
  ------------------
  |  Branch (5420:9): [True: 0, False: 29.3k]
  |  Branch (5420:33): [True: 0, False: 0]
  ------------------
 5421|      0|        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2587|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2588|      0|#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
  |  |  ------------------
  |  |  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 5422|       |
 5423|       |    // Setup ImDrawData structures for end-user
 5424|  29.3k|    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
 5425|  29.3k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (5425:35): [True: 29.3k, False: 29.3k]
  ------------------
 5426|  29.3k|    {
 5427|  29.3k|        FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);
 5428|       |
 5429|       |        // Add foreground ImDrawList (for each active viewport)
 5430|  29.3k|        if (viewport->BgFgDrawLists[1] != NULL)
  ------------------
  |  Branch (5430:13): [True: 0, False: 29.3k]
  ------------------
 5431|      0|            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
 5432|       |
 5433|       |        // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
 5434|  29.3k|        ImDrawData* draw_data = &viewport->DrawDataP;
 5435|  29.3k|        IM_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5436|  29.3k|        for (ImDrawList* draw_list : draw_data->CmdLists)
  ------------------
  |  Branch (5436:36): [True: 42.0k, False: 29.3k]
  ------------------
 5437|  42.0k|            draw_list->_PopUnusedDrawCmd();
 5438|       |
 5439|  29.3k|        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
 5440|  29.3k|        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
 5441|  29.3k|    }
 5442|       |
 5443|  29.3k|    CallContextHooks(&g, ImGuiContextHookType_RenderPost);
 5444|  29.3k|}
_ZN5ImGui12CalcTextSizeEPKcS1_bf:
 5449|  58.7k|{
 5450|  58.7k|    ImGuiContext& g = *GImGui;
 5451|       |
 5452|  58.7k|    const char* text_display_end;
 5453|  58.7k|    if (hide_text_after_double_hash)
  ------------------
  |  Branch (5453:9): [True: 58.7k, False: 34]
  ------------------
 5454|  58.7k|        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
 5455|     34|    else
 5456|     34|        text_display_end = text_end;
 5457|       |
 5458|  58.7k|    ImFont* font = g.Font;
 5459|  58.7k|    const float font_size = g.FontSize;
 5460|  58.7k|    if (text == text_display_end)
  ------------------
  |  Branch (5460:9): [True: 0, False: 58.7k]
  ------------------
 5461|      0|        return ImVec2(0.0f, font_size);
 5462|  58.7k|    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);
 5463|       |
 5464|       |    // Round
 5465|       |    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
 5466|       |    // FIXME: Investigate using ceilf or e.g.
 5467|       |    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
 5468|       |    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
 5469|  58.7k|    text_size.x = IM_TRUNC(text_size.x + 0.99999f);
  ------------------
  |  |  284|  58.7k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 5470|       |
 5471|  58.7k|    return text_size;
 5472|  58.7k|}
_ZN5ImGui12IsItemActiveEv:
 5538|  58.7k|{
 5539|  58.7k|    ImGuiContext& g = *GImGui;
 5540|  58.7k|    if (g.ActiveId)
  ------------------
  |  Branch (5540:9): [True: 122, False: 58.6k]
  ------------------
 5541|    122|        return g.ActiveId == g.LastItemData.ID;
 5542|  58.6k|    return false;
 5543|  58.7k|}
_ZN5ImGui31SetActiveIdUsingAllKeyboardKeysEv:
 5658|     59|{
 5659|     59|    ImGuiContext& g = *GImGui;
 5660|     59|    IM_ASSERT(g.ActiveId != 0);
  ------------------
  |  |   23|     59|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5661|     59|    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
 5662|     59|    g.ActiveIdUsingAllKeyboardKeys = true;
 5663|     59|    NavMoveRequestCancel();
 5664|     59|}
_ZN5ImGui12BeginChildExEPKcjRK6ImVec2bi:
 5691|  25.9k|{
 5692|  25.9k|    ImGuiContext& g = *GImGui;
 5693|  25.9k|    ImGuiWindow* parent_window = g.CurrentWindow;
 5694|       |
 5695|  25.9k|    flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoDocking;
 5696|  25.9k|    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag
 5697|       |
 5698|       |    // Size
 5699|  25.9k|    const ImVec2 content_avail = GetContentRegionAvail();
 5700|  25.9k|    ImVec2 size = ImTrunc(size_arg);
 5701|  25.9k|    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
  ------------------
  |  Branch (5701:34): [True: 23.1k, False: 2.80k]
  |  Branch (5701:83): [True: 22.7k, False: 3.19k]
  ------------------
 5702|  25.9k|    if (size.x <= 0.0f)
  ------------------
  |  Branch (5702:9): [True: 23.1k, False: 2.80k]
  ------------------
 5703|  23.1k|        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too many issues)
 5704|  25.9k|    if (size.y <= 0.0f)
  ------------------
  |  Branch (5704:9): [True: 22.7k, False: 3.19k]
  ------------------
 5705|  22.7k|        size.y = ImMax(content_avail.y + size.y, 4.0f);
 5706|  25.9k|    SetNextWindowSize(size);
 5707|       |
 5708|       |    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
 5709|  25.9k|    const char* temp_window_name;
 5710|  25.9k|    if (name)
  ------------------
  |  Branch (5710:9): [True: 25.9k, False: 0]
  ------------------
 5711|  25.9k|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s_%08X", parent_window->Name, name, id);
 5712|      0|    else
 5713|      0|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%08X", parent_window->Name, id);
 5714|       |
 5715|  25.9k|    const float backup_border_size = g.Style.ChildBorderSize;
 5716|  25.9k|    if (!border)
  ------------------
  |  Branch (5716:9): [True: 12.4k, False: 13.4k]
  ------------------
 5717|  12.4k|        g.Style.ChildBorderSize = 0.0f;
 5718|  25.9k|    bool ret = Begin(temp_window_name, NULL, flags);
 5719|  25.9k|    g.Style.ChildBorderSize = backup_border_size;
 5720|       |
 5721|  25.9k|    ImGuiWindow* child_window = g.CurrentWindow;
 5722|  25.9k|    child_window->ChildId = id;
 5723|  25.9k|    child_window->AutoFitChildAxises = (ImS8)auto_fit_axises;
 5724|       |
 5725|       |    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
 5726|       |    // While this is not really documented/defined, it seems that the expected thing to do.
 5727|  25.9k|    if (child_window->BeginCount == 1)
  ------------------
  |  Branch (5727:9): [True: 25.9k, False: 0]
  ------------------
 5728|  25.9k|        parent_window->DC.CursorPos = child_window->Pos;
 5729|       |
 5730|       |    // Process navigation-in immediately so NavInit can run on first frame
 5731|       |    // Can enter a child if (A) it has navigatable items or (B) it can be scrolled.
 5732|  25.9k|    const ImGuiID temp_id_for_activation = ImHashStr("##Child", 0, id);
 5733|  25.9k|    if (g.ActiveId == temp_id_for_activation)
  ------------------
  |  Branch (5733:9): [True: 13, False: 25.9k]
  ------------------
 5734|     13|        ClearActiveID();
 5735|  25.9k|    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY))
  ------------------
  |  Branch (5735:9): [True: 20, False: 25.9k]
  |  Branch (5735:34): [True: 20, False: 0]
  |  Branch (5735:79): [True: 0, False: 20]
  |  Branch (5735:124): [True: 19, False: 1]
  ------------------
 5736|     19|    {
 5737|     19|        FocusWindow(child_window);
 5738|     19|        NavInitWindow(child_window, false);
 5739|     19|        SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
 5740|     19|        g.ActiveIdSource = g.NavInputSource;
 5741|     19|    }
 5742|  25.9k|    return ret;
 5743|  25.9k|}
_ZN5ImGui10BeginChildEPKcRK6ImVec2bi:
 5746|  25.9k|{
 5747|  25.9k|    ImGuiWindow* window = GetCurrentWindow();
 5748|  25.9k|    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
 5749|  25.9k|}
_ZN5ImGui8EndChildEv:
 5758|  25.9k|{
 5759|  25.9k|    ImGuiContext& g = *GImGui;
 5760|  25.9k|    ImGuiWindow* window = g.CurrentWindow;
 5761|       |
 5762|  25.9k|    IM_ASSERT(g.WithinEndChild == false);
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5763|  25.9k|    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() calls
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5764|       |
 5765|  25.9k|    g.WithinEndChild = true;
 5766|  25.9k|    if (window->BeginCount > 1)
  ------------------
  |  Branch (5766:9): [True: 0, False: 25.9k]
  ------------------
 5767|      0|    {
 5768|      0|        End();
 5769|      0|    }
 5770|  25.9k|    else
 5771|  25.9k|    {
 5772|  25.9k|        ImVec2 sz = window->Size;
 5773|  25.9k|        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
  ------------------
  |  Branch (5773:13): [True: 23.1k, False: 2.80k]
  ------------------
 5774|  23.1k|            sz.x = ImMax(4.0f, sz.x);
 5775|  25.9k|        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
  ------------------
  |  Branch (5775:13): [True: 22.7k, False: 3.19k]
  ------------------
 5776|  22.7k|            sz.y = ImMax(4.0f, sz.y);
 5777|  25.9k|        End();
 5778|       |
 5779|  25.9k|        ImGuiWindow* parent_window = g.CurrentWindow;
 5780|  25.9k|        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
 5781|  25.9k|        ItemSize(sz);
 5782|  25.9k|        if ((window->DC.NavLayersActiveMask != 0 || window->DC.NavWindowHasScrollY) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
  ------------------
  |  Branch (5782:14): [True: 0, False: 25.9k]
  |  Branch (5782:53): [True: 23.5k, False: 2.42k]
  |  Branch (5782:88): [True: 23.5k, False: 0]
  ------------------
 5783|  23.5k|        {
 5784|  23.5k|            ItemAdd(bb, window->ChildId);
 5785|  23.5k|            RenderNavHighlight(bb, window->ChildId);
 5786|       |
 5787|       |            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
 5788|  23.5k|            if (window->DC.NavLayersActiveMask == 0 && window == g.NavWindow)
  ------------------
  |  Branch (5788:17): [True: 23.5k, False: 0]
  |  Branch (5788:56): [True: 17.8k, False: 5.65k]
  ------------------
 5789|  17.8k|                RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
 5790|  23.5k|        }
 5791|  2.42k|        else
 5792|  2.42k|        {
 5793|       |            // Not navigable into
 5794|  2.42k|            ItemAdd(bb, 0);
 5795|       |
 5796|       |            // But when flattened we directly reach items, adjust active layer mask accordingly
 5797|  2.42k|            if (window->Flags & ImGuiWindowFlags_NavFlattened)
  ------------------
  |  Branch (5797:17): [True: 0, False: 2.42k]
  ------------------
 5798|      0|                parent_window->DC.NavLayersActiveMaskNext |= window->DC.NavLayersActiveMaskNext;
 5799|  2.42k|        }
 5800|  25.9k|        if (g.HoveredWindow == window)
  ------------------
  |  Branch (5800:13): [True: 72, False: 25.8k]
  ------------------
 5801|     72|            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
 5802|  25.9k|    }
 5803|  25.9k|    g.WithinEndChild = false;
 5804|  25.9k|    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
 5805|  25.9k|}
_ZN5ImGui14FindWindowByIDEj:
 5836|  84.6k|{
 5837|  84.6k|    ImGuiContext& g = *GImGui;
 5838|  84.6k|    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
 5839|  84.6k|}
_ZN5ImGui16FindWindowByNameEPKc:
 5842|  84.6k|{
 5843|  84.6k|    ImGuiID id = ImHashStr(name);
 5844|  84.6k|    return FindWindowByID(id);
 5845|  84.6k|}
_ZN5ImGui30UpdateWindowParentAndRootLinksEP11ImGuiWindowiS1_:
 6574|  84.6k|{
 6575|  84.6k|    window->ParentWindow = parent_window;
 6576|  84.6k|    window->RootWindow = window->RootWindowPopupTree = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
 6577|  84.6k|    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (6577:9): [True: 25.9k, False: 58.7k]
  |  Branch (6577:26): [True: 25.9k, False: 0]
  |  Branch (6577:68): [True: 25.9k, False: 0]
  ------------------
 6578|  25.9k|    {
 6579|  25.9k|        window->RootWindowDockTree = parent_window->RootWindowDockTree;
 6580|  25.9k|        if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6580:13): [True: 25.9k, False: 0]
  |  Branch (6580:38): [True: 25.9k, False: 0]
  ------------------
 6581|  25.9k|            window->RootWindow = parent_window->RootWindow;
 6582|  25.9k|    }
 6583|  84.6k|    if (parent_window && (flags & ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (6583:9): [True: 25.9k, False: 58.7k]
  |  Branch (6583:26): [True: 0, False: 25.9k]
  ------------------
 6584|      0|        window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
 6585|  84.6k|    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) // FIXME: simply use _NoTitleBar ?
  ------------------
  |  Branch (6585:9): [True: 25.9k, False: 58.7k]
  |  Branch (6585:26): [True: 25.9k, False: 0]
  |  Branch (6585:63): [True: 25.9k, False: 0]
  ------------------
 6586|  25.9k|        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
 6587|  84.6k|    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
  ------------------
  |  Branch (6587:12): [True: 0, False: 84.6k]
  ------------------
 6588|      0|    {
 6589|      0|        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6590|      0|        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
 6591|      0|    }
 6592|  84.6k|}
_ZN5ImGui17FindBlockingModalEP11ImGuiWindow:
 6608|    110|{
 6609|    110|    ImGuiContext& g = *GImGui;
 6610|    110|    if (g.OpenPopupStack.Size <= 0)
  ------------------
  |  Branch (6610:9): [True: 110, False: 0]
  ------------------
 6611|    110|        return NULL;
 6612|       |
 6613|       |    // Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
 6614|      0|    for (ImGuiPopupData& popup_data : g.OpenPopupStack)
  ------------------
  |  Branch (6614:37): [True: 0, False: 0]
  ------------------
 6615|      0|    {
 6616|      0|        ImGuiWindow* popup_window = popup_data.Window;
 6617|      0|        if (popup_window == NULL || !(popup_window->Flags & ImGuiWindowFlags_Modal))
  ------------------
  |  Branch (6617:13): [True: 0, False: 0]
  |  Branch (6617:37): [True: 0, False: 0]
  ------------------
 6618|      0|            continue;
 6619|      0|        if (!popup_window->Active && !popup_window->WasActive)      // Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
  ------------------
  |  Branch (6619:13): [True: 0, False: 0]
  |  Branch (6619:38): [True: 0, False: 0]
  ------------------
 6620|      0|            continue;
 6621|      0|        if (window == NULL)                                         // FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
  ------------------
  |  Branch (6621:13): [True: 0, False: 0]
  ------------------
 6622|      0|            return popup_window;
 6623|      0|        if (IsWindowWithinBeginStackOf(window, popup_window))       // Window may be over modal
  ------------------
  |  Branch (6623:13): [True: 0, False: 0]
  ------------------
 6624|      0|            continue;
 6625|      0|        return popup_window;                                        // Place window right below first block modal
 6626|      0|    }
 6627|      0|    return NULL;
 6628|      0|}
_ZN5ImGui5BeginEPKcPbi:
 6638|  84.6k|{
 6639|  84.6k|    ImGuiContext& g = *GImGui;
 6640|  84.6k|    const ImGuiStyle& style = g.Style;
 6641|  84.6k|    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6642|  84.6k|    IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6643|  84.6k|    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6644|       |
 6645|       |    // Find or create
 6646|  84.6k|    ImGuiWindow* window = FindWindowByName(name);
 6647|  84.6k|    const bool window_just_created = (window == NULL);
 6648|  84.6k|    if (window_just_created)
  ------------------
  |  Branch (6648:9): [True: 4, False: 84.6k]
  ------------------
 6649|      4|        window = CreateNewWindow(name, flags);
 6650|       |
 6651|       |    // Automatically disable manual moving/resizing when NoInputs is set
 6652|  84.6k|    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
  ------------------
  |  Branch (6652:9): [True: 17, False: 84.6k]
  ------------------
 6653|     17|        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
 6654|       |
 6655|  84.6k|    if (flags & ImGuiWindowFlags_NavFlattened)
  ------------------
  |  Branch (6655:9): [True: 0, False: 84.6k]
  ------------------
 6656|  84.6k|        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6657|       |
 6658|  84.6k|    const int current_frame = g.FrameCount;
 6659|  84.6k|    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
 6660|  84.6k|    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);
  ------------------
  |  Branch (6660:33): [True: 29.3k, False: 55.3k]
  |  Branch (6660:67): [True: 29.3k, False: 0]
  ------------------
 6661|       |
 6662|       |    // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
 6663|  84.6k|    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
 6664|  84.6k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6664:9): [True: 0, False: 84.6k]
  ------------------
 6665|      0|    {
 6666|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 6667|      0|        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
 6668|      0|        window_just_activated_by_user |= (window != popup_ref.Window);
 6669|      0|    }
 6670|       |
 6671|       |    // Update Flags, LastFrameActive, BeginOrderXXX fields
 6672|  84.6k|    const bool window_was_appearing = window->Appearing;
 6673|  84.6k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6673:9): [True: 84.6k, False: 0]
  ------------------
 6674|  84.6k|    {
 6675|  84.6k|        UpdateWindowInFocusOrderList(window, window_just_created, flags);
 6676|  84.6k|        window->Appearing = window_just_activated_by_user;
 6677|  84.6k|        if (window->Appearing)
  ------------------
  |  Branch (6677:13): [True: 15, False: 84.6k]
  ------------------
 6678|     15|            SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6679|  84.6k|        window->FlagsPreviousFrame = window->Flags;
 6680|  84.6k|        window->Flags = (ImGuiWindowFlags)flags;
 6681|  84.6k|        window->LastFrameActive = current_frame;
 6682|  84.6k|        window->LastTimeActive = (float)g.Time;
 6683|  84.6k|        window->BeginOrderWithinParent = 0;
 6684|  84.6k|        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
 6685|  84.6k|    }
 6686|      0|    else
 6687|      0|    {
 6688|      0|        flags = window->Flags;
 6689|      0|    }
 6690|       |
 6691|       |    // Docking
 6692|       |    // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
 6693|  84.6k|    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6694|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
  ------------------
  |  Branch (6694:9): [True: 0, False: 84.6k]
  ------------------
 6695|      0|        SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
 6696|  84.6k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6696:9): [True: 84.6k, False: 0]
  ------------------
 6697|  84.6k|    {
 6698|  84.6k|        bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
  ------------------
  |  Branch (6698:31): [True: 0, False: 84.6k]
  |  Branch (6698:54): [True: 0, False: 84.6k]
  ------------------
 6699|  84.6k|        bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
  ------------------
  |  Branch (6699:35): [True: 84.6k, False: 0]
  |  Branch (6699:53): [True: 0, False: 84.6k]
  ------------------
 6700|  84.6k|        bool dock_node_was_visible = window->DockNodeIsVisible;
 6701|  84.6k|        bool dock_tab_was_visible = window->DockTabIsVisible;
 6702|  84.6k|        if (has_dock_node || new_auto_dock_node)
  ------------------
  |  Branch (6702:13): [True: 0, False: 84.6k]
  |  Branch (6702:30): [True: 0, False: 84.6k]
  ------------------
 6703|      0|        {
 6704|      0|            BeginDocked(window, p_open);
 6705|      0|            flags = window->Flags;
 6706|      0|            if (window->DockIsActive)
  ------------------
  |  Branch (6706:17): [True: 0, False: 0]
  ------------------
 6707|      0|            {
 6708|      0|                IM_ASSERT(window->DockNode != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6709|      0|                g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
 6710|      0|            }
 6711|       |
 6712|       |            // Amend the Appearing flag
 6713|      0|            if (window->DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window->Appearing && !window_was_appearing)
  ------------------
  |  Branch (6713:17): [True: 0, False: 0]
  |  Branch (6713:45): [True: 0, False: 0]
  |  Branch (6713:70): [True: 0, False: 0]
  |  Branch (6713:95): [True: 0, False: 0]
  |  Branch (6713:117): [True: 0, False: 0]
  ------------------
 6714|      0|            {
 6715|      0|                window->Appearing = true;
 6716|      0|                SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6717|      0|            }
 6718|      0|        }
 6719|  84.6k|        else
 6720|  84.6k|        {
 6721|  84.6k|            window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
 6722|  84.6k|        }
 6723|  84.6k|    }
 6724|       |
 6725|       |    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
 6726|  84.6k|    ImGuiWindow* parent_window_in_stack = (window->DockIsActive && window->DockNode->HostWindow) ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
  ------------------
  |  Branch (6726:44): [True: 0, False: 84.6k]
  |  Branch (6726:68): [True: 0, False: 0]
  |  Branch (6726:131): [True: 29.3k, False: 55.3k]
  ------------------
 6727|  84.6k|    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
  ------------------
  |  Branch (6727:34): [True: 84.6k, False: 0]
  |  Branch (6727:62): [True: 25.9k, False: 58.7k]
  ------------------
 6728|  84.6k|    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6729|       |
 6730|       |    // We allow window memory to be compacted so recreate the base stack when needed.
 6731|  84.6k|    if (window->IDStack.Size == 0)
  ------------------
  |  Branch (6731:9): [True: 1, False: 84.6k]
  ------------------
 6732|      1|        window->IDStack.push_back(window->ID);
 6733|       |
 6734|       |    // Add to stack
 6735|       |    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
 6736|  84.6k|    g.CurrentWindow = window;
 6737|  84.6k|    ImGuiWindowStackData window_stack_data;
 6738|  84.6k|    window_stack_data.Window = window;
 6739|  84.6k|    window_stack_data.ParentLastItemDataBackup = g.LastItemData;
 6740|  84.6k|    window_stack_data.StackSizesOnBegin.SetToContextState(&g);
 6741|  84.6k|    g.CurrentWindowStack.push_back(window_stack_data);
 6742|  84.6k|    if (flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (6742:9): [True: 0, False: 84.6k]
  ------------------
 6743|      0|        g.BeginMenuCount++;
 6744|       |
 6745|       |    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
 6746|  84.6k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6746:9): [True: 84.6k, False: 0]
  ------------------
 6747|  84.6k|    {
 6748|  84.6k|        UpdateWindowParentAndRootLinks(window, flags, parent_window);
 6749|  84.6k|        window->ParentWindowInBeginStack = parent_window_in_stack;
 6750|  84.6k|    }
 6751|       |
 6752|       |    // Add to focus scope stack
 6753|  84.6k|    PushFocusScope(window->ID);
 6754|  84.6k|    window->NavRootFocusScopeId = g.CurrentFocusScopeId;
 6755|  84.6k|    g.CurrentWindow = NULL;
 6756|       |
 6757|       |    // Add to popup stack
 6758|  84.6k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6758:9): [True: 0, False: 84.6k]
  ------------------
 6759|      0|    {
 6760|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 6761|      0|        popup_ref.Window = window;
 6762|      0|        popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
 6763|      0|        g.BeginPopupStack.push_back(popup_ref);
 6764|      0|        window->PopupId = popup_ref.PopupId;
 6765|      0|    }
 6766|       |
 6767|       |    // Process SetNextWindow***() calls
 6768|       |    // (FIXME: Consider splitting the HasXXX flags into X/Y components
 6769|  84.6k|    bool window_pos_set_by_api = false;
 6770|  84.6k|    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
 6771|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
  ------------------
  |  Branch (6771:9): [True: 0, False: 84.6k]
  ------------------
 6772|      0|    {
 6773|      0|        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
 6774|      0|        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
  ------------------
  |  Branch (6774:13): [True: 0, False: 0]
  |  Branch (6774:38): [True: 0, False: 0]
  ------------------
 6775|      0|        {
 6776|       |            // May be processed on the next frame if this is our first frame and we are measuring size
 6777|       |            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
 6778|      0|            window->SetWindowPosVal = g.NextWindowData.PosVal;
 6779|      0|            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
 6780|      0|            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 6781|      0|        }
 6782|      0|        else
 6783|      0|        {
 6784|      0|            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
 6785|      0|        }
 6786|      0|    }
 6787|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
  ------------------
  |  Branch (6787:9): [True: 55.3k, False: 29.3k]
  ------------------
 6788|  55.3k|    {
 6789|  55.3k|        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
  ------------------
  |  Branch (6789:36): [True: 25.9k, False: 29.3k]
  |  Branch (6789:106): [True: 25.9k, False: 0]
  ------------------
 6790|  55.3k|        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
  ------------------
  |  Branch (6790:36): [True: 25.9k, False: 29.3k]
  |  Branch (6790:106): [True: 25.9k, False: 0]
  ------------------
 6791|  55.3k|        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
 6792|  55.3k|    }
 6793|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
  ------------------
  |  Branch (6793:9): [True: 0, False: 84.6k]
  ------------------
 6794|      0|    {
 6795|      0|        if (g.NextWindowData.ScrollVal.x >= 0.0f)
  ------------------
  |  Branch (6795:13): [True: 0, False: 0]
  ------------------
 6796|      0|        {
 6797|      0|            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
 6798|      0|            window->ScrollTargetCenterRatio.x = 0.0f;
 6799|      0|        }
 6800|      0|        if (g.NextWindowData.ScrollVal.y >= 0.0f)
  ------------------
  |  Branch (6800:13): [True: 0, False: 0]
  ------------------
 6801|      0|        {
 6802|      0|            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
 6803|      0|            window->ScrollTargetCenterRatio.y = 0.0f;
 6804|      0|        }
 6805|      0|    }
 6806|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
  ------------------
  |  Branch (6806:9): [True: 0, False: 84.6k]
  ------------------
 6807|      0|        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
 6808|  84.6k|    else if (first_begin_of_the_frame)
  ------------------
  |  Branch (6808:14): [True: 84.6k, False: 0]
  ------------------
 6809|  84.6k|        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
 6810|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
  ------------------
  |  Branch (6810:9): [True: 0, False: 84.6k]
  ------------------
 6811|      0|        window->WindowClass = g.NextWindowData.WindowClass;
 6812|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
  ------------------
  |  Branch (6812:9): [True: 0, False: 84.6k]
  ------------------
 6813|      0|        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
 6814|  84.6k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
  ------------------
  |  Branch (6814:9): [True: 0, False: 84.6k]
  ------------------
 6815|      0|        FocusWindow(window);
 6816|  84.6k|    if (window->Appearing)
  ------------------
  |  Branch (6816:9): [True: 15, False: 84.6k]
  ------------------
 6817|     15|        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);
 6818|       |
 6819|       |    // When reusing window again multiple times a frame, just append content (don't need to setup again)
 6820|  84.6k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6820:9): [True: 84.6k, False: 0]
  ------------------
 6821|  84.6k|    {
 6822|       |        // Initialize
 6823|  84.6k|        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
  ------------------
  |  Branch (6823:46): [True: 25.9k, False: 58.7k]
  |  Branch (6823:88): [True: 0, False: 25.9k]
  ------------------
 6824|  84.6k|        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
 6825|  84.6k|        window->Active = true;
 6826|  84.6k|        window->HasCloseButton = (p_open != NULL);
 6827|  84.6k|        window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
 6828|  84.6k|        window->IDStack.resize(1);
 6829|  84.6k|        window->DrawList->_ResetForNewFrame();
 6830|  84.6k|        window->DC.CurrentTableIdx = -1;
 6831|  84.6k|        if (flags & ImGuiWindowFlags_DockNodeHost)
  ------------------
  |  Branch (6831:13): [True: 0, False: 84.6k]
  ------------------
 6832|      0|        {
 6833|      0|            window->DrawList->ChannelsSplit(2);
 6834|      0|            window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
  ------------------
  |  | 1692|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 6835|      0|        }
 6836|       |
 6837|       |        // Restore buffer capacity when woken from a compacted state, to avoid
 6838|  84.6k|        if (window->MemoryCompacted)
  ------------------
  |  Branch (6838:13): [True: 1, False: 84.6k]
  ------------------
 6839|      1|            GcAwakeTransientWindowBuffers(window);
 6840|       |
 6841|       |        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
 6842|       |        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
 6843|  84.6k|        bool window_title_visible_elsewhere = false;
 6844|  84.6k|        if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
  ------------------
  |  Branch (6844:14): [True: 84.6k, False: 4]
  |  Branch (6844:34): [True: 0, False: 84.6k]
  |  Branch (6844:73): [True: 0, False: 84.6k]
  ------------------
 6845|      0|            window_title_visible_elsewhere = true;
 6846|  84.6k|        else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
  ------------------
  |  Branch (6846:18): [True: 0, False: 84.6k]
  |  Branch (6846:54): [True: 0, False: 0]
  ------------------
 6847|      0|            window_title_visible_elsewhere = true;
 6848|  84.6k|        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
  ------------------
  |  Branch (6848:13): [True: 0, False: 84.6k]
  |  Branch (6848:47): [True: 0, False: 0]
  |  Branch (6848:71): [True: 0, False: 0]
  ------------------
 6849|      0|        {
 6850|      0|            size_t buf_len = (size_t)window->NameBufLen;
 6851|      0|            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
 6852|      0|            window->NameBufLen = (int)buf_len;
 6853|      0|        }
 6854|       |
 6855|       |        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
 6856|       |
 6857|       |        // Update contents size from last frame for auto-fitting (or use explicit size)
 6858|  84.6k|        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
 6859|       |
 6860|       |        // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
 6861|       |        // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
 6862|       |        // it has a single usage before this code block and may be set below before it is finally checked.
 6863|  84.6k|        if (window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (6863:13): [True: 13.2k, False: 71.4k]
  ------------------
 6864|  13.2k|            window->HiddenFramesCanSkipItems--;
 6865|  84.6k|        if (window->HiddenFramesCannotSkipItems > 0)
  ------------------
  |  Branch (6865:13): [True: 12, False: 84.6k]
  ------------------
 6866|     12|            window->HiddenFramesCannotSkipItems--;
 6867|  84.6k|        if (window->HiddenFramesForRenderOnly > 0)
  ------------------
  |  Branch (6867:13): [True: 0, False: 84.6k]
  ------------------
 6868|      0|            window->HiddenFramesForRenderOnly--;
 6869|       |
 6870|       |        // Hide new windows for one frame until they calculate their size
 6871|  84.6k|        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
  ------------------
  |  Branch (6871:13): [True: 4, False: 84.6k]
  |  Branch (6871:37): [True: 2, False: 2]
  |  Branch (6871:66): [True: 0, False: 2]
  ------------------
 6872|      2|            window->HiddenFramesCannotSkipItems = 1;
 6873|       |
 6874|       |        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
 6875|       |        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
 6876|  84.6k|        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
  ------------------
  |  Branch (6876:13): [True: 15, False: 84.6k]
  |  Branch (6876:46): [True: 10, False: 5]
  ------------------
 6877|     10|        {
 6878|     10|            window->HiddenFramesCannotSkipItems = 1;
 6879|     10|            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
  ------------------
  |  Branch (6879:17): [True: 10, False: 0]
  ------------------
 6880|     10|            {
 6881|     10|                if (!window_size_x_set_by_api)
  ------------------
  |  Branch (6881:21): [True: 10, False: 0]
  ------------------
 6882|     10|                    window->Size.x = window->SizeFull.x = 0.f;
 6883|     10|                if (!window_size_y_set_by_api)
  ------------------
  |  Branch (6883:21): [True: 10, False: 0]
  ------------------
 6884|     10|                    window->Size.y = window->SizeFull.y = 0.f;
 6885|     10|                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
 6886|     10|            }
 6887|     10|        }
 6888|       |
 6889|       |        // SELECT VIEWPORT
 6890|       |        // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.
 6891|       |
 6892|  84.6k|        WindowSelectViewport(window);
 6893|  84.6k|        SetCurrentViewport(window, window->Viewport);
 6894|  84.6k|        window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (6894:32): [True: 0, False: 84.6k]
  ------------------
 6895|  84.6k|        SetCurrentWindow(window);
 6896|  84.6k|        flags = window->Flags;
 6897|       |
 6898|       |        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
 6899|       |        // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.
 6900|       |
 6901|  84.6k|        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (6901:13): [True: 84.6k, False: 0]
  |  Branch (6901:38): [True: 25.9k, False: 58.7k]
  ------------------
 6902|  25.9k|            window->WindowBorderSize = style.ChildBorderSize;
 6903|  58.7k|        else
 6904|  58.7k|            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
  ------------------
  |  Branch (6904:41): [True: 17, False: 58.7k]
  |  Branch (6904:106): [True: 17, False: 0]
  ------------------
 6905|  84.6k|        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
  ------------------
  |  Branch (6905:13): [True: 84.6k, False: 0]
  |  Branch (6905:38): [True: 25.9k, False: 58.7k]
  |  Branch (6905:80): [True: 25.9k, False: 0]
  |  Branch (6905:161): [True: 12.4k, False: 13.4k]
  ------------------
 6906|  12.4k|            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
  ------------------
  |  Branch (6906:50): [True: 0, False: 12.4k]
  ------------------
 6907|  72.2k|        else
 6908|  72.2k|            window->WindowPadding = style.WindowPadding;
 6909|       |
 6910|       |        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
 6911|  84.6k|        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
 6912|  84.6k|        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
 6913|       |
 6914|  84.6k|        bool use_current_size_for_scrollbar_x = window_just_created;
 6915|  84.6k|        bool use_current_size_for_scrollbar_y = window_just_created;
 6916|       |
 6917|       |        // Collapse window by double-clicking on title bar
 6918|       |        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
 6919|  84.6k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
  ------------------
  |  Branch (6919:13): [True: 58.7k, False: 25.9k]
  |  Branch (6919:55): [True: 58.7k, False: 0]
  |  Branch (6919:97): [True: 58.7k, False: 0]
  ------------------
 6920|  58.7k|        {
 6921|       |            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
 6922|  58.7k|            ImRect title_bar_rect = window->TitleBarRect();
 6923|  58.7k|            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseClickedCount[0] == 2)
  ------------------
  |  Branch (6923:17): [True: 473, False: 58.2k]
  |  Branch (6923:46): [True: 473, False: 0]
  |  Branch (6923:66): [True: 318, False: 155]
  |  Branch (6923:99): [True: 176, False: 142]
  |  Branch (6923:162): [True: 4, False: 172]
  ------------------
 6924|      4|                window->WantCollapseToggle = true;
 6925|  58.7k|            if (window->WantCollapseToggle)
  ------------------
  |  Branch (6925:17): [True: 4, False: 58.7k]
  ------------------
 6926|      4|            {
 6927|      4|                window->Collapsed = !window->Collapsed;
 6928|      4|                if (!window->Collapsed)
  ------------------
  |  Branch (6928:21): [True: 2, False: 2]
  ------------------
 6929|      2|                    use_current_size_for_scrollbar_y = true;
 6930|      4|                MarkIniSettingsDirty(window);
 6931|      4|            }
 6932|  58.7k|        }
 6933|  25.9k|        else
 6934|  25.9k|        {
 6935|  25.9k|            window->Collapsed = false;
 6936|  25.9k|        }
 6937|  84.6k|        window->WantCollapseToggle = false;
 6938|       |
 6939|       |        // SIZE
 6940|       |
 6941|       |        // Outer Decoration Sizes
 6942|       |        // (we need to clear ScrollbarSize immediatly as CalcWindowAutoFitSize() needs it and can be called from other locations).
 6943|  84.6k|        const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
 6944|  84.6k|        window->DecoOuterSizeX1 = 0.0f;
 6945|  84.6k|        window->DecoOuterSizeX2 = 0.0f;
 6946|  84.6k|        window->DecoOuterSizeY1 = window->TitleBarHeight() + window->MenuBarHeight();
 6947|  84.6k|        window->DecoOuterSizeY2 = 0.0f;
 6948|  84.6k|        window->ScrollbarSizes = ImVec2(0.0f, 0.0f);
 6949|       |
 6950|       |        // Calculate auto-fit size, handle automatic resize
 6951|  84.6k|        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
 6952|  84.6k|        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
  ------------------
  |  Branch (6952:13): [True: 17, False: 84.6k]
  |  Branch (6952:60): [True: 17, False: 0]
  ------------------
 6953|     17|        {
 6954|       |            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
 6955|     17|            if (!window_size_x_set_by_api)
  ------------------
  |  Branch (6955:17): [True: 17, False: 0]
  ------------------
 6956|     17|            {
 6957|     17|                window->SizeFull.x = size_auto_fit.x;
 6958|     17|                use_current_size_for_scrollbar_x = true;
 6959|     17|            }
 6960|     17|            if (!window_size_y_set_by_api)
  ------------------
  |  Branch (6960:17): [True: 17, False: 0]
  ------------------
 6961|     17|            {
 6962|     17|                window->SizeFull.y = size_auto_fit.y;
 6963|     17|                use_current_size_for_scrollbar_y = true;
 6964|     17|            }
 6965|     17|        }
 6966|  84.6k|        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6966:18): [True: 2, False: 84.6k]
  |  Branch (6966:48): [True: 0, False: 84.6k]
  ------------------
 6967|      2|        {
 6968|       |            // Auto-fit may only grow window during the first few frames
 6969|       |            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
 6970|      2|            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
  ------------------
  |  Branch (6970:17): [True: 2, False: 0]
  |  Branch (6970:46): [True: 2, False: 0]
  ------------------
 6971|      2|            {
 6972|      2|                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
  ------------------
  |  Branch (6972:38): [True: 2, False: 0]
  ------------------
 6973|      2|                use_current_size_for_scrollbar_x = true;
 6974|      2|            }
 6975|      2|            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6975:17): [True: 2, False: 0]
  |  Branch (6975:46): [True: 2, False: 0]
  ------------------
 6976|      2|            {
 6977|      2|                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
  ------------------
  |  Branch (6977:38): [True: 2, False: 0]
  ------------------
 6978|      2|                use_current_size_for_scrollbar_y = true;
 6979|      2|            }
 6980|      2|            if (!window->Collapsed)
  ------------------
  |  Branch (6980:17): [True: 2, False: 0]
  ------------------
 6981|      2|                MarkIniSettingsDirty(window);
 6982|      2|        }
 6983|       |
 6984|       |        // Apply minimum/maximum window size constraints and final size
 6985|  84.6k|        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
 6986|  84.6k|        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;
  ------------------
  |  Branch (6986:24): [True: 3.41k, False: 81.2k]
  |  Branch (6986:45): [True: 3.41k, False: 0]
  ------------------
 6987|       |
 6988|       |        // POSITION
 6989|       |
 6990|       |        // Popup latch its initial position, will position itself when it appears next frame
 6991|  84.6k|        if (window_just_activated_by_user)
  ------------------
  |  Branch (6991:13): [True: 15, False: 84.6k]
  ------------------
 6992|     15|        {
 6993|     15|            window->AutoPosLastDirection = ImGuiDir_None;
 6994|     15|            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
  ------------------
  |  Branch (6994:17): [True: 0, False: 15]
  |  Branch (6994:58): [True: 0, False: 0]
  |  Branch (6994:95): [True: 0, False: 0]
  ------------------
 6995|      0|                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
 6996|     15|        }
 6997|       |
 6998|       |        // Position child window
 6999|  84.6k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (6999:13): [True: 25.9k, False: 58.7k]
  ------------------
 7000|  25.9k|        {
 7001|  25.9k|            IM_ASSERT(parent_window && parent_window->Active);
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7002|  25.9k|            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
 7003|  25.9k|            parent_window->DC.ChildWindows.push_back(window);
 7004|  25.9k|            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (7004:17): [True: 25.9k, False: 0]
  |  Branch (7004:54): [True: 25.9k, False: 0]
  |  Branch (7004:80): [True: 25.9k, False: 0]
  ------------------
 7005|  25.9k|                window->Pos = parent_window->DC.CursorPos;
 7006|  25.9k|        }
 7007|       |
 7008|  84.6k|        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
  ------------------
  |  Branch (7008:45): [True: 0, False: 84.6k]
  |  Branch (7008:85): [True: 0, False: 0]
  ------------------
 7009|  84.6k|        if (window_pos_with_pivot)
  ------------------
  |  Branch (7009:13): [True: 0, False: 84.6k]
  ------------------
 7010|      0|            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
 7011|  84.6k|        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
  ------------------
  |  Branch (7011:18): [True: 0, False: 84.6k]
  ------------------
 7012|      0|            window->Pos = FindBestWindowPosForPopup(window);
 7013|  84.6k|        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
  ------------------
  |  Branch (7013:18): [True: 0, False: 84.6k]
  |  Branch (7013:59): [True: 0, False: 0]
  |  Branch (7013:85): [True: 0, False: 0]
  ------------------
 7014|      0|            window->Pos = FindBestWindowPosForPopup(window);
 7015|  84.6k|        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (7015:18): [True: 17, False: 84.6k]
  |  Branch (7015:61): [True: 17, False: 0]
  |  Branch (7015:87): [True: 17, False: 0]
  ------------------
 7016|     17|            window->Pos = FindBestWindowPosForPopup(window);
 7017|       |
 7018|       |        // Late create viewport if we don't fit within our current host viewport.
 7019|  84.6k|        if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_IsMinimized))
  ------------------
  |  Branch (7019:13): [True: 0, False: 84.6k]
  |  Branch (7019:64): [True: 0, False: 0]
  |  Branch (7019:90): [True: 0, False: 0]
  ------------------
 7020|      0|            if (!window->Viewport->GetMainRect().Contains(window->Rect()))
  ------------------
  |  Branch (7020:17): [True: 0, False: 0]
  ------------------
 7021|      0|            {
 7022|       |                // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
 7023|       |                //ImGuiViewport* old_viewport = window->Viewport;
 7024|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
 7025|       |
 7026|       |                // FIXME-DPI
 7027|       |                //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
 7028|      0|                SetCurrentViewport(window, window->Viewport);
 7029|      0|                window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (7029:40): [True: 0, False: 0]
  ------------------
 7030|      0|                SetCurrentWindow(window);
 7031|      0|            }
 7032|       |
 7033|  84.6k|        if (window->ViewportOwned)
  ------------------
  |  Branch (7033:13): [True: 0, False: 84.6k]
  ------------------
 7034|      0|            WindowSyncOwnedViewport(window, parent_window_in_stack);
 7035|       |
 7036|       |        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
 7037|       |        // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
 7038|  84.6k|        ImRect viewport_rect(window->Viewport->GetMainRect());
 7039|  84.6k|        ImRect viewport_work_rect(window->Viewport->GetWorkRect());
 7040|  84.6k|        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
 7041|  84.6k|        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);
 7042|       |
 7043|       |        // Clamp position/size so window stays visible within its viewport or monitor
 7044|       |        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
 7045|       |        // FIXME: Similar to code in GetWindowAllowedExtentRect()
 7046|  84.6k|        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (7046:13): [True: 84.6k, False: 0]
  |  Branch (7046:39): [True: 58.7k, False: 25.9k]
  ------------------
 7047|  58.7k|        {
 7048|  58.7k|            if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
  ------------------
  |  Branch (7048:17): [True: 58.7k, False: 0]
  |  Branch (7048:43): [True: 58.7k, False: 0]
  |  Branch (7048:75): [True: 58.7k, False: 0]
  ------------------
 7049|  58.7k|            {
 7050|  58.7k|                ClampWindowPos(window, visibility_rect);
 7051|  58.7k|            }
 7052|      0|            else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
  ------------------
  |  Branch (7052:22): [True: 0, False: 0]
  |  Branch (7052:47): [True: 0, False: 0]
  ------------------
 7053|      0|            {
 7054|       |                // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
 7055|      0|                const ImGuiPlatformMonitor* monitor = GetViewportPlatformMonitor(window->Viewport);
 7056|      0|                visibility_rect.Min = monitor->WorkPos + visibility_padding;
 7057|      0|                visibility_rect.Max = monitor->WorkPos + monitor->WorkSize - visibility_padding;
 7058|      0|                ClampWindowPos(window, visibility_rect);
 7059|      0|            }
 7060|  58.7k|        }
 7061|  84.6k|        window->Pos = ImTrunc(window->Pos);
 7062|       |
 7063|       |        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
 7064|       |        // Large values tend to lead to variety of artifacts and are not recommended.
 7065|  84.6k|        if (window->ViewportOwned || window->DockIsActive)
  ------------------
  |  Branch (7065:13): [True: 0, False: 84.6k]
  |  Branch (7065:38): [True: 0, False: 84.6k]
  ------------------
 7066|      0|            window->WindowRounding = 0.0f;
 7067|  84.6k|        else
 7068|  84.6k|            window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
  ------------------
  |  Branch (7068:38): [True: 25.9k, False: 58.7k]
  |  Branch (7068:102): [True: 0, False: 58.7k]
  |  Branch (7068:138): [True: 0, False: 0]
  ------------------
 7069|       |
 7070|       |        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
 7071|       |        //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
 7072|       |        //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);
 7073|       |
 7074|       |        // Apply window focus (new and reactivated windows are moved to front)
 7075|  84.6k|        bool want_focus = false;
 7076|  84.6k|        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
  ------------------
  |  Branch (7076:13): [True: 15, False: 84.6k]
  |  Branch (7076:46): [True: 15, False: 0]
  ------------------
 7077|     15|        {
 7078|     15|            if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (7078:17): [True: 0, False: 15]
  ------------------
 7079|      0|                want_focus = true;
 7080|     15|            else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (7080:23): [True: 0, False: 15]
  |  Branch (7080:47): [True: 12, False: 3]
  |  Branch (7080:95): [True: 2, False: 10]
  ------------------
 7081|      2|                want_focus = true;
 7082|     15|        }
 7083|       |
 7084|       |        // [Test Engine] Register whole window in the item system (before submitting further decorations)
 7085|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 7086|       |        if (g.TestEngineHookItems)
 7087|       |        {
 7088|       |            IM_ASSERT(window->IDStack.Size == 1);
 7089|       |            window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
 7090|       |            IMGUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);
 7091|       |            IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
 7092|       |            window->IDStack.Size = 1;
 7093|       |        }
 7094|       |#endif
 7095|       |
 7096|       |        // Decide if we are going to handle borders and resize grips
 7097|  84.6k|        const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);
  ------------------
  |  Branch (7097:55): [True: 0, False: 84.6k]
  |  Branch (7097:81): [True: 84.6k, False: 0]
  ------------------
 7098|       |
 7099|       |        // Handle manual resize: Resize Grips, Borders, Gamepad
 7100|  84.6k|        int border_held = -1;
 7101|  84.6k|        ImU32 resize_grip_col[4] = {};
 7102|  84.6k|        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
  ------------------
  |  Branch (7102:39): [True: 0, False: 84.6k]
  ------------------
 7103|  84.6k|        const float resize_grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  284|  84.6k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 7104|  84.6k|        if (handle_borders_and_resize_grips && !window->Collapsed)
  ------------------
  |  Branch (7104:13): [True: 84.6k, False: 0]
  |  Branch (7104:48): [True: 81.2k, False: 3.41k]
  ------------------
 7105|  81.2k|            if (UpdateWindowManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
  ------------------
  |  Branch (7105:17): [True: 0, False: 81.2k]
  ------------------
 7106|      0|                use_current_size_for_scrollbar_x = use_current_size_for_scrollbar_y = true;
 7107|  84.6k|        window->ResizeBorderHeld = (signed char)border_held;
 7108|       |
 7109|       |        // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
 7110|  84.6k|        if (window->ViewportOwned)
  ------------------
  |  Branch (7110:13): [True: 0, False: 84.6k]
  ------------------
 7111|      0|        {
 7112|      0|            if (!window->Viewport->PlatformRequestMove)
  ------------------
  |  Branch (7112:17): [True: 0, False: 0]
  ------------------
 7113|      0|                window->Viewport->Pos = window->Pos;
 7114|      0|            if (!window->Viewport->PlatformRequestResize)
  ------------------
  |  Branch (7114:17): [True: 0, False: 0]
  ------------------
 7115|      0|                window->Viewport->Size = window->Size;
 7116|      0|            window->Viewport->UpdateWorkRect();
 7117|      0|            viewport_rect = window->Viewport->GetMainRect();
 7118|      0|        }
 7119|       |
 7120|       |        // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
 7121|  84.6k|        window->ViewportPos = window->Viewport->Pos;
 7122|       |
 7123|       |        // SCROLLBAR VISIBILITY
 7124|       |
 7125|       |        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
 7126|  84.6k|        if (!window->Collapsed)
  ------------------
  |  Branch (7126:13): [True: 81.2k, False: 3.41k]
  ------------------
 7127|  81.2k|        {
 7128|       |            // When reading the current size we need to read it after size constraints have been applied.
 7129|       |            // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
 7130|       |            // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
 7131|  81.2k|            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
 7132|  81.2k|            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
 7133|  81.2k|            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
  ------------------
  |  Branch (7133:50): [True: 4, False: 81.2k]
  ------------------
 7134|  81.2k|            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
  ------------------
  |  Branch (7134:43): [True: 21, False: 81.2k]
  ------------------
 7135|  81.2k|            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
  ------------------
  |  Branch (7135:43): [True: 23, False: 81.2k]
  ------------------
 7136|       |            //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
 7137|  81.2k|            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
  ------------------
  |  Branch (7137:34): [True: 0, False: 81.2k]
  |  Branch (7137:89): [True: 26.3k, False: 54.8k]
  |  Branch (7137:148): [True: 26.3k, False: 0]
  ------------------
 7138|  81.2k|            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
  ------------------
  |  Branch (7138:34): [True: 25.9k, False: 55.3k]
  |  Branch (7138:91): [True: 3.56k, False: 51.7k]
  |  Branch (7138:149): [True: 3.05k, False: 52.2k]
  |  Branch (7138:202): [True: 3.56k, False: 0]
  |  Branch (7138:245): [True: 0, False: 3.56k]
  ------------------
 7139|  81.2k|            if (window->ScrollbarX && !window->ScrollbarY)
  ------------------
  |  Branch (7139:17): [True: 25.9k, False: 55.3k]
  |  Branch (7139:39): [True: 2.60k, False: 23.3k]
  ------------------
 7140|  2.60k|                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar);
  ------------------
  |  Branch (7140:38): [True: 0, False: 2.60k]
  |  Branch (7140:97): [True: 0, False: 0]
  ------------------
 7141|  81.2k|            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
  ------------------
  |  Branch (7141:45): [True: 26.3k, False: 54.8k]
  |  Branch (7141:94): [True: 25.9k, False: 55.3k]
  ------------------
 7142|       |
 7143|       |            // Amend the partially filled window->DecorationXXX values.
 7144|  81.2k|            window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
 7145|  81.2k|            window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
 7146|  81.2k|        }
 7147|       |
 7148|       |        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
 7149|       |        // Update various regions. Variables they depend on should be set above in this function.
 7150|       |        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.
 7151|       |
 7152|       |        // Outer rectangle
 7153|       |        // Not affected by window border size. Used by:
 7154|       |        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
 7155|       |        // - Begin() initial clipping rect for drawing window background and borders.
 7156|       |        // - Begin() clipping whole child
 7157|  84.6k|        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
  ------------------
  |  Branch (7157:35): [True: 25.9k, False: 58.7k]
  |  Branch (7157:77): [True: 25.9k, False: 0]
  |  Branch (7157:114): [True: 25.9k, False: 0]
  ------------------
 7158|  84.6k|        const ImRect outer_rect = window->Rect();
 7159|  84.6k|        const ImRect title_bar_rect = window->TitleBarRect();
 7160|  84.6k|        window->OuterRectClipped = outer_rect;
 7161|  84.6k|        if (window->DockIsActive)
  ------------------
  |  Branch (7161:13): [True: 0, False: 84.6k]
  ------------------
 7162|      0|            window->OuterRectClipped.Min.y += window->TitleBarHeight();
 7163|  84.6k|        window->OuterRectClipped.ClipWith(host_rect);
 7164|       |
 7165|       |        // Inner rectangle
 7166|       |        // Not affected by window border size. Used by:
 7167|       |        // - InnerClipRect
 7168|       |        // - ScrollToRectEx()
 7169|       |        // - NavUpdatePageUpPageDown()
 7170|       |        // - Scrollbar()
 7171|  84.6k|        window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
 7172|  84.6k|        window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
 7173|  84.6k|        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
 7174|  84.6k|        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;
 7175|       |
 7176|       |        // Inner clipping rectangle.
 7177|       |        // Will extend a little bit outside the normal work region.
 7178|       |        // This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
 7179|       |        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
 7180|       |        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
 7181|       |        // Affected by window/frame border size. Used by:
 7182|       |        // - Begin() initial clip rect
 7183|  84.6k|        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
  ------------------
  |  Branch (7183:35): [True: 0, False: 84.6k]
  |  Branch (7183:73): [True: 58.7k, False: 25.9k]
  ------------------
 7184|  84.6k|        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(ImTrunc(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
 7185|  84.6k|        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
 7186|  84.6k|        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(ImTrunc(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
 7187|  84.6k|        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
 7188|  84.6k|        window->InnerClipRect.ClipWithFull(host_rect);
 7189|       |
 7190|       |        // Default item width. Make it proportional to window size if window manually resizes
 7191|  84.6k|        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
  ------------------
  |  Branch (7191:13): [True: 84.6k, False: 0]
  |  Branch (7191:38): [True: 84.6k, False: 17]
  |  Branch (7191:77): [True: 84.6k, False: 0]
  ------------------
 7192|  84.6k|            window->ItemWidthDefault = ImTrunc(window->Size.x * 0.65f);
 7193|     17|        else
 7194|     17|            window->ItemWidthDefault = ImTrunc(g.FontSize * 16.0f);
 7195|       |
 7196|       |        // SCROLLING
 7197|       |
 7198|       |        // Lock down maximum scrolling
 7199|       |        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
 7200|       |        // for right/bottom aligned items without creating a scrollbar.
 7201|  84.6k|        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
 7202|  84.6k|        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());
 7203|       |
 7204|       |        // Apply scrolling
 7205|  84.6k|        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
 7206|  84.6k|        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 7207|  84.6k|        window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;
 7208|       |
 7209|       |        // DRAWING
 7210|       |
 7211|       |        // Setup draw list and outer clipping rectangle
 7212|  84.6k|        IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7213|  84.6k|        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
 7214|  84.6k|        PushClipRect(host_rect.Min, host_rect.Max, false);
 7215|       |
 7216|       |        // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
 7217|       |        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
 7218|       |        // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
 7219|  84.6k|        const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
  ------------------
  |  Branch (7219:52): [True: 84.6k, False: 0]
  |  Branch (7219:77): [True: 0, False: 0]
  ------------------
 7220|  84.6k|        if (is_undocked_or_docked_visible)
  ------------------
  |  Branch (7220:13): [True: 84.6k, False: 0]
  ------------------
 7221|  84.6k|        {
 7222|  84.6k|            bool render_decorations_in_parent = false;
 7223|  84.6k|            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
  ------------------
  |  Branch (7223:17): [True: 25.9k, False: 58.7k]
  |  Branch (7223:59): [True: 25.9k, False: 0]
  |  Branch (7223:96): [True: 25.9k, False: 0]
  ------------------
 7224|  25.9k|            {
 7225|       |                // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
 7226|       |                // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
 7227|  25.9k|                ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
  ------------------
  |  Branch (7227:47): [True: 0, False: 25.9k]
  ------------------
 7228|  25.9k|                bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
  ------------------
  |  Branch (7228:51): [True: 0, False: 25.9k]
  ------------------
 7229|  25.9k|                bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);
 7230|  25.9k|                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && !parent_is_empty && !previous_child_overlapping)
  ------------------
  |  Branch (7230:21): [True: 25.9k, False: 0]
  |  Branch (7230:74): [True: 25.9k, False: 0]
  |  Branch (7230:94): [True: 25.9k, False: 0]
  ------------------
 7231|  25.9k|                    render_decorations_in_parent = true;
 7232|  25.9k|            }
 7233|  84.6k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (7233:17): [True: 25.9k, False: 58.7k]
  ------------------
 7234|  25.9k|                window->DrawList = parent_window->DrawList;
 7235|       |
 7236|       |            // Handle title bar, scrollbar, resize grips and resize borders
 7237|  84.6k|            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
  ------------------
  |  Branch (7237:54): [True: 0, False: 84.6k]
  ------------------
 7238|  84.6k|            const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
  ------------------
  |  Branch (7238:49): [True: 2, False: 84.6k]
  |  Branch (7238:64): [True: 55.0k, False: 29.6k]
  |  Branch (7238:88): [True: 36.6k, False: 18.3k]
  |  Branch (7238:186): [True: 0, False: 18.3k]
  |  Branch (7238:206): [True: 0, False: 0]
  ------------------
 7239|  84.6k|            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);
 7240|       |
 7241|  84.6k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (7241:17): [True: 25.9k, False: 58.7k]
  ------------------
 7242|  25.9k|                window->DrawList = &window->DrawListInst;
 7243|  84.6k|        }
 7244|       |
 7245|       |        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)
 7246|       |
 7247|       |        // Work rectangle.
 7248|       |        // Affected by window padding and border size. Used by:
 7249|       |        // - Columns() for right-most edge
 7250|       |        // - TreeNode(), CollapsingHeader() for right-most edge
 7251|       |        // - BeginTabBar() for right-most edge
 7252|  84.6k|        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
  ------------------
  |  Branch (7252:40): [True: 84.6k, False: 0]
  |  Branch (7252:83): [True: 25.9k, False: 58.7k]
  ------------------
 7253|  84.6k|        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
 7254|  84.6k|        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (7254:41): [True: 0, False: 84.6k]
  |  Branch (7254:119): [True: 25.9k, False: 58.7k]
  ------------------
 7255|  84.6k|        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (7255:41): [True: 0, False: 84.6k]
  |  Branch (7255:119): [True: 84.6k, False: 0]
  ------------------
 7256|  84.6k|        window->WorkRect.Min.x = ImTrunc(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
 7257|  84.6k|        window->WorkRect.Min.y = ImTrunc(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
 7258|  84.6k|        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
 7259|  84.6k|        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
 7260|  84.6k|        window->ParentWorkRect = window->WorkRect;
 7261|       |
 7262|       |        // [LEGACY] Content Region
 7263|       |        // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
 7264|       |        // Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
 7265|       |        // Used by:
 7266|       |        // - Mouse wheel scrolling + many other things
 7267|  84.6k|        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
 7268|  84.6k|        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
 7269|  84.6k|        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (7269:78): [True: 0, False: 84.6k]
  ------------------
 7270|  84.6k|        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (7270:78): [True: 0, False: 84.6k]
  ------------------
 7271|       |
 7272|       |        // Setup drawing context
 7273|       |        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
 7274|  84.6k|        window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
 7275|  84.6k|        window->DC.GroupOffset.x = 0.0f;
 7276|  84.6k|        window->DC.ColumnsOffset.x = 0.0f;
 7277|       |
 7278|       |        // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
 7279|       |        // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
 7280|  84.6k|        double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
 7281|  84.6k|        double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
 7282|  84.6k|        window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
 7283|  84.6k|        window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
 7284|  84.6k|        window->DC.CursorPos = window->DC.CursorStartPos;
 7285|  84.6k|        window->DC.CursorPosPrevLine = window->DC.CursorPos;
 7286|  84.6k|        window->DC.CursorMaxPos = window->DC.CursorStartPos;
 7287|  84.6k|        window->DC.IdealMaxPos = window->DC.CursorStartPos;
 7288|  84.6k|        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
 7289|  84.6k|        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
 7290|  84.6k|        window->DC.IsSameLine = window->DC.IsSetPos = false;
 7291|       |
 7292|  84.6k|        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 7293|  84.6k|        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
 7294|  84.6k|        window->DC.NavLayersActiveMaskNext = 0x00;
 7295|  84.6k|        window->DC.NavIsScrollPushableX = true;
 7296|  84.6k|        window->DC.NavHideHighlightOneFrame = false;
 7297|  84.6k|        window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);
 7298|       |
 7299|  84.6k|        window->DC.MenuBarAppending = false;
 7300|  84.6k|        window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
 7301|  84.6k|        window->DC.TreeDepth = 0;
 7302|  84.6k|        window->DC.TreeJumpToParentOnPopMask = 0x00;
 7303|  84.6k|        window->DC.ChildWindows.resize(0);
 7304|  84.6k|        window->DC.StateStorage = &window->StateStorage;
 7305|  84.6k|        window->DC.CurrentColumns = NULL;
 7306|  84.6k|        window->DC.LayoutType = ImGuiLayoutType_Vertical;
 7307|  84.6k|        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
  ------------------
  |  Branch (7307:39): [True: 25.9k, False: 58.7k]
  ------------------
 7308|       |
 7309|  84.6k|        window->DC.ItemWidth = window->ItemWidthDefault;
 7310|  84.6k|        window->DC.TextWrapPos = -1.0f; // disabled
 7311|  84.6k|        window->DC.ItemWidthStack.resize(0);
 7312|  84.6k|        window->DC.TextWrapPosStack.resize(0);
 7313|       |
 7314|  84.6k|        if (window->AutoFitFramesX > 0)
  ------------------
  |  Branch (7314:13): [True: 4, False: 84.6k]
  ------------------
 7315|      4|            window->AutoFitFramesX--;
 7316|  84.6k|        if (window->AutoFitFramesY > 0)
  ------------------
  |  Branch (7316:13): [True: 4, False: 84.6k]
  ------------------
 7317|      4|            window->AutoFitFramesY--;
 7318|       |
 7319|       |        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
 7320|       |        // We ImGuiFocusRequestFlags_UnlessBelowModal to:
 7321|       |        // - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
 7322|       |        // - Position window behind the modal that is not a begin-parent of this window.
 7323|  84.6k|        if (want_focus)
  ------------------
  |  Branch (7323:13): [True: 2, False: 84.6k]
  ------------------
 7324|      2|            FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
 7325|  84.6k|        if (want_focus && window == g.NavWindow)
  ------------------
  |  Branch (7325:13): [True: 2, False: 84.6k]
  |  Branch (7325:27): [True: 2, False: 0]
  ------------------
 7326|      2|            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
 7327|       |
 7328|       |        // Close requested by platform window (apply to all windows in this viewport)
 7329|  84.6k|        if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
  ------------------
  |  Branch (7329:13): [True: 0, False: 84.6k]
  |  Branch (7329:31): [True: 0, False: 0]
  |  Branch (7329:73): [True: 0, False: 0]
  ------------------
 7330|      0|        {
 7331|      0|            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' closed by PlatformRequestClose\n", window->Name);
  ------------------
  |  |  251|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (251:50): [True: 0, False: 0]
  |  |  |  Branch (251:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7332|      0|            *p_open = false;
 7333|      0|            g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
 7334|      0|        }
 7335|       |
 7336|       |        // Title bar
 7337|  84.6k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (7337:13): [True: 58.7k, False: 25.9k]
  |  Branch (7337:55): [True: 58.7k, False: 0]
  ------------------
 7338|  58.7k|            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);
 7339|       |
 7340|       |        // Clear hit test shape every frame
 7341|  84.6k|        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
 7342|       |
 7343|       |        // Pressing CTRL+C while holding on a window copy its content to the clipboard
 7344|       |        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
 7345|       |        // Maybe we can support CTRL+C on every element?
 7346|       |        /*
 7347|       |        //if (g.NavWindow == window && g.ActiveId == 0)
 7348|       |        if (g.ActiveId == window->MoveId)
 7349|       |            if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
 7350|       |                LogToClipboard();
 7351|       |        */
 7352|       |
 7353|  84.6k|        if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
  ------------------
  |  Branch (7353:13): [True: 84.6k, False: 0]
  ------------------
 7354|  84.6k|        {
 7355|       |            // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
 7356|       |            // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
 7357|  84.6k|            if (g.MovingWindow == window && (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
  ------------------
  |  Branch (7357:17): [True: 24, False: 84.6k]
  |  Branch (7357:45): [True: 24, False: 0]
  ------------------
 7358|     24|                BeginDockableDragDropSource(window);
 7359|       |
 7360|       |            // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
 7361|  84.6k|            if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
  ------------------
  |  Branch (7361:17): [True: 0, False: 84.6k]
  |  Branch (7361:37): [True: 0, False: 0]
  ------------------
 7362|      0|                if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
  ------------------
  |  Branch (7362:21): [True: 0, False: 0]
  |  Branch (7362:47): [True: 0, False: 0]
  ------------------
 7363|      0|                    if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (7363:25): [True: 0, False: 0]
  |  Branch (7363:67): [True: 0, False: 0]
  ------------------
 7364|      0|                        BeginDockableDragDropTarget(window);
 7365|  84.6k|        }
 7366|       |
 7367|       |        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
 7368|       |        // This is useful to allow creating context menus on title bar only, etc.
 7369|  84.6k|        if (window->DockIsActive)
  ------------------
  |  Branch (7369:13): [True: 0, False: 84.6k]
  ------------------
 7370|      0|            SetLastItemData(window->MoveId, g.CurrentItemFlags, window->DockTabItemStatusFlags, window->DockTabItemRect);
 7371|  84.6k|        else
 7372|  84.6k|            SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, title_bar_rect);
  ------------------
  |  Branch (7372:65): [True: 894, False: 83.8k]
  ------------------
 7373|       |
 7374|       |        // [DEBUG]
 7375|  84.6k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 7376|  84.6k|        if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
  ------------------
  |  Branch (7376:13): [True: 0, False: 84.6k]
  |  Branch (7376:38): [True: 0, False: 0]
  |  Branch (7376:71): [True: 0, False: 0]
  ------------------
 7377|      0|            DebugLocateItemResolveWithLastItem();
 7378|  84.6k|#endif
 7379|       |
 7380|       |        // [Test Engine] Register title bar / tab with MoveId.
 7381|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 7382|       |        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
 7383|       |            IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);
 7384|       |#endif
 7385|  84.6k|    }
 7386|      0|    else
 7387|      0|    {
 7388|       |        // Append
 7389|      0|        SetCurrentViewport(window, window->Viewport);
 7390|      0|        SetCurrentWindow(window);
 7391|      0|    }
 7392|       |
 7393|  84.6k|    if (!(flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (7393:9): [True: 84.6k, False: 0]
  ------------------
 7394|  84.6k|        PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);
 7395|       |
 7396|       |    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
 7397|  84.6k|    window->WriteAccessed = false;
 7398|  84.6k|    window->BeginCount++;
 7399|  84.6k|    g.NextWindowData.ClearFlags();
 7400|       |
 7401|       |    // Update visibility
 7402|  84.6k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (7402:9): [True: 84.6k, False: 0]
  ------------------
 7403|  84.6k|    {
 7404|       |        // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
 7405|       |        // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
 7406|       |        // This is analogous to regular windows being hidden from one frame.
 7407|       |        // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
 7408|  84.6k|        if (window->DockIsActive && !window->DockTabIsVisible)
  ------------------
  |  Branch (7408:13): [True: 0, False: 84.6k]
  |  Branch (7408:37): [True: 0, False: 0]
  ------------------
 7409|      0|        {
 7410|      0|            if (window->LastFrameJustFocused == g.FrameCount)
  ------------------
  |  Branch (7410:17): [True: 0, False: 0]
  ------------------
 7411|      0|                window->HiddenFramesCannotSkipItems = 1;
 7412|      0|            else
 7413|      0|                window->HiddenFramesCanSkipItems = 1;
 7414|      0|        }
 7415|       |
 7416|  84.6k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (7416:13): [True: 25.9k, False: 58.7k]
  ------------------
 7417|  25.9k|        {
 7418|       |            // Child window can be out of sight and have "negative" clip windows.
 7419|       |            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
 7420|  25.9k|            IM_ASSERT((flags& ImGuiWindowFlags_NoTitleBar) != 0 || (window->DockIsActive));
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7421|  25.9k|            if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0) // FIXME: Doesn't make sense for ChildWindow??
  ------------------
  |  Branch (7421:17): [True: 25.9k, False: 0]
  |  Branch (7421:65): [True: 25.9k, False: 0]
  |  Branch (7421:96): [True: 25.9k, False: 0]
  ------------------
 7422|  25.9k|            {
 7423|  25.9k|                const bool nav_request = (flags & ImGuiWindowFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
  ------------------
  |  Branch (7423:42): [True: 0, False: 25.9k]
  |  Branch (7423:86): [True: 0, False: 0]
  |  Branch (7423:105): [True: 0, False: 0]
  |  Branch (7423:120): [True: 0, False: 0]
  ------------------
 7424|  25.9k|                if (!g.LogEnabled && !nav_request)
  ------------------
  |  Branch (7424:21): [True: 25.9k, False: 0]
  |  Branch (7424:38): [True: 25.9k, False: 0]
  ------------------
 7425|  25.9k|                    if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
  ------------------
  |  Branch (7425:25): [True: 0, False: 25.9k]
  |  Branch (7425:93): [True: 13.2k, False: 12.7k]
  ------------------
 7426|  13.2k|                        window->HiddenFramesCanSkipItems = 1;
 7427|  25.9k|            }
 7428|       |
 7429|       |            // Hide along with parent or if parent is collapsed
 7430|  25.9k|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
  ------------------
  |  Branch (7430:17): [True: 25.9k, False: 0]
  |  Branch (7430:35): [True: 0, False: 25.9k]
  |  Branch (7430:63): [True: 0, False: 25.9k]
  ------------------
 7431|      0|                window->HiddenFramesCanSkipItems = 1;
 7432|  25.9k|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
  ------------------
  |  Branch (7432:17): [True: 25.9k, False: 0]
  |  Branch (7432:35): [True: 0, False: 25.9k]
  |  Branch (7432:63): [True: 1, False: 25.9k]
  ------------------
 7433|      1|                window->HiddenFramesCannotSkipItems = 1;
 7434|  25.9k|        }
 7435|       |
 7436|       |        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
 7437|  84.6k|        if (style.Alpha <= 0.0f)
  ------------------
  |  Branch (7437:13): [True: 0, False: 84.6k]
  ------------------
 7438|      0|            window->HiddenFramesCanSkipItems = 1;
 7439|       |
 7440|       |        // Update the Hidden flag
 7441|  84.6k|        bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
  ------------------
  |  Branch (7441:31): [True: 13.2k, False: 71.4k]
  |  Branch (7441:73): [True: 12, False: 71.4k]
  ------------------
 7442|  84.6k|        window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);
  ------------------
  |  Branch (7442:26): [True: 13.2k, False: 71.4k]
  |  Branch (7442:44): [True: 0, False: 71.4k]
  ------------------
 7443|       |
 7444|       |        // Disable inputs for requested number of frames
 7445|  84.6k|        if (window->DisableInputsFrames > 0)
  ------------------
  |  Branch (7445:13): [True: 0, False: 84.6k]
  ------------------
 7446|      0|        {
 7447|      0|            window->DisableInputsFrames--;
 7448|      0|            window->Flags |= ImGuiWindowFlags_NoInputs;
 7449|      0|        }
 7450|       |
 7451|       |        // Update the SkipItems flag, used to early out of all items functions (no layout required)
 7452|  84.6k|        bool skip_items = false;
 7453|  84.6k|        if (window->Collapsed || !window->Active || hidden_regular)
  ------------------
  |  Branch (7453:13): [True: 3.41k, False: 81.2k]
  |  Branch (7453:34): [True: 0, False: 81.2k]
  |  Branch (7453:53): [True: 13.2k, False: 68.0k]
  ------------------
 7454|  16.6k|            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
  ------------------
  |  Branch (7454:17): [True: 16.6k, False: 2]
  |  Branch (7454:48): [True: 16.6k, False: 0]
  |  Branch (7454:79): [True: 16.6k, False: 10]
  ------------------
 7455|  16.6k|                skip_items = true;
 7456|  84.6k|        window->SkipItems = skip_items;
 7457|       |
 7458|       |        // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
 7459|  84.6k|        if (window->SkipItems)
  ------------------
  |  Branch (7459:13): [True: 16.6k, False: 68.0k]
  ------------------
 7460|  16.6k|            window->DC.NavLayersActiveMaskNext = window->DC.NavLayersActiveMask;
 7461|       |
 7462|       |        // Sanity check: there are two spots which can set Appearing = true
 7463|       |        // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
 7464|       |        // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
 7465|  84.6k|        if (window->SkipItems && !window->Appearing)
  ------------------
  |  Branch (7465:13): [True: 16.6k, False: 68.0k]
  |  Branch (7465:34): [True: 16.6k, False: 0]
  ------------------
 7466|  84.6k|            IM_ASSERT(window->Appearing == false); // Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7467|  84.6k|    }
 7468|       |
 7469|       |    // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
 7470|       |    // (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
 7471|  84.6k|    if (!window->IsFallbackWindow && ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size)))
  ------------------
  |  Branch (7471:9): [True: 55.3k, False: 29.3k]
  |  Branch (7471:40): [True: 0, False: 55.3k]
  |  Branch (7471:80): [True: 0, False: 0]
  |  Branch (7471:105): [True: 0, False: 55.3k]
  |  Branch (7471:145): [True: 0, False: 0]
  ------------------
 7472|      0|    {
 7473|      0|        if (window->AutoFitFramesX > 0) { window->AutoFitFramesX++; }
  ------------------
  |  Branch (7473:13): [True: 0, False: 0]
  ------------------
 7474|      0|        if (window->AutoFitFramesY > 0) { window->AutoFitFramesY++; }
  ------------------
  |  Branch (7474:13): [True: 0, False: 0]
  ------------------
 7475|      0|        return false;
 7476|      0|    }
 7477|       |
 7478|  84.6k|    return !window->SkipItems;
 7479|  84.6k|}
_ZN5ImGui3EndEv:
 7482|  84.6k|{
 7483|  84.6k|    ImGuiContext& g = *GImGui;
 7484|  84.6k|    ImGuiWindow* window = g.CurrentWindow;
 7485|       |
 7486|       |    // Error checking: verify that user hasn't called End() too many times!
 7487|  84.6k|    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
  ------------------
  |  Branch (7487:9): [True: 29.3k, False: 55.3k]
  |  Branch (7487:43): [True: 0, False: 29.3k]
  ------------------
 7488|      0|    {
 7489|      0|        IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
  ------------------
  |  |  268|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7490|      0|        return;
 7491|      0|    }
 7492|  84.6k|    IM_ASSERT(g.CurrentWindowStack.Size > 0);
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7493|       |
 7494|       |    // Error checking: verify that user doesn't directly call End() on a child window.
 7495|  84.6k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
  ------------------
  |  Branch (7495:9): [True: 25.9k, False: 58.7k]
  |  Branch (7495:59): [True: 25.9k, False: 0]
  |  Branch (7495:111): [True: 25.9k, False: 0]
  ------------------
 7496|  84.6k|        IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");
  ------------------
  |  |  268|  84.6k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7497|       |
 7498|       |    // Close anything that is open
 7499|  84.6k|    if (window->DC.CurrentColumns)
  ------------------
  |  Branch (7499:9): [True: 0, False: 84.6k]
  ------------------
 7500|      0|        EndColumns();
 7501|  84.6k|    if (!(window->Flags & ImGuiWindowFlags_DockNodeHost))   // Pop inner window clip rectangle
  ------------------
  |  Branch (7501:9): [True: 84.6k, False: 0]
  ------------------
 7502|  84.6k|        PopClipRect();
 7503|  84.6k|    PopFocusScope();
 7504|       |
 7505|       |    // Stop logging
 7506|  84.6k|    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
  ------------------
  |  Branch (7506:9): [True: 58.7k, False: 25.9k]
  ------------------
 7507|  58.7k|        LogFinish();
 7508|       |
 7509|  84.6k|    if (window->DC.IsSetPos)
  ------------------
  |  Branch (7509:9): [True: 0, False: 84.6k]
  ------------------
 7510|      0|        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
 7511|       |
 7512|       |    // Docking: report contents sizes to parent to allow for auto-resize
 7513|  84.6k|    if (window->DockNode && window->DockTabIsVisible)
  ------------------
  |  Branch (7513:9): [True: 0, False: 84.6k]
  |  Branch (7513:29): [True: 0, False: 0]
  ------------------
 7514|      0|        if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
  ------------------
  |  Branch (7514:26): [True: 0, False: 0]
  ------------------
 7515|      0|            host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;
 7516|       |
 7517|       |    // Pop from window stack
 7518|  84.6k|    g.LastItemData = g.CurrentWindowStack.back().ParentLastItemDataBackup;
 7519|  84.6k|    if (window->Flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (7519:9): [True: 0, False: 84.6k]
  ------------------
 7520|      0|        g.BeginMenuCount--;
 7521|  84.6k|    if (window->Flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (7521:9): [True: 0, False: 84.6k]
  ------------------
 7522|      0|        g.BeginPopupStack.pop_back();
 7523|  84.6k|    g.CurrentWindowStack.back().StackSizesOnBegin.CompareWithContextState(&g);
 7524|  84.6k|    g.CurrentWindowStack.pop_back();
 7525|  84.6k|    SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
  ------------------
  |  Branch (7525:22): [True: 29.3k, False: 55.3k]
  ------------------
 7526|  84.6k|    if (g.CurrentWindow)
  ------------------
  |  Branch (7526:9): [True: 55.3k, False: 29.3k]
  ------------------
 7527|  55.3k|        SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
 7528|  84.6k|}
_ZN5ImGui23BringWindowToFocusFrontEP11ImGuiWindow:
 7531|  11.2k|{
 7532|  11.2k|    ImGuiContext& g = *GImGui;
 7533|  11.2k|    IM_ASSERT(window == window->RootWindow);
  ------------------
  |  |   23|  11.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7534|       |
 7535|  11.2k|    const int cur_order = window->FocusOrder;
 7536|  11.2k|    IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
  ------------------
  |  |   23|  11.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7537|  11.2k|    if (g.WindowsFocusOrder.back() == window)
  ------------------
  |  Branch (7537:9): [True: 11.2k, False: 1]
  ------------------
 7538|  11.2k|        return;
 7539|       |
 7540|      1|    const int new_order = g.WindowsFocusOrder.Size - 1;
 7541|      2|    for (int n = cur_order; n < new_order; n++)
  ------------------
  |  Branch (7541:29): [True: 1, False: 1]
  ------------------
 7542|      1|    {
 7543|      1|        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
 7544|      1|        g.WindowsFocusOrder[n]->FocusOrder--;
 7545|      1|        IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7546|      1|    }
 7547|      1|    g.WindowsFocusOrder[new_order] = window;
 7548|      1|    window->FocusOrder = (short)new_order;
 7549|      1|}
_ZN5ImGui25BringWindowToDisplayFrontEP11ImGuiWindow:
 7552|  11.2k|{
 7553|  11.2k|    ImGuiContext& g = *GImGui;
 7554|  11.2k|    ImGuiWindow* current_front_window = g.Windows.back();
 7555|  11.2k|    if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
  ------------------
  |  Branch (7555:9): [True: 2, False: 11.2k]
  |  Branch (7555:43): [True: 11.2k, False: 1]
  ------------------
 7556|  11.2k|        return;
 7557|      2|    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
  ------------------
  |  Branch (7557:38): [True: 2, False: 0]
  ------------------
 7558|      2|        if (g.Windows[i] == window)
  ------------------
  |  Branch (7558:13): [True: 1, False: 1]
  ------------------
 7559|      1|        {
 7560|      1|            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
 7561|      1|            g.Windows[g.Windows.Size - 1] = window;
 7562|      1|            break;
 7563|      1|        }
 7564|      1|}
_ZN5ImGui11FocusWindowEP11ImGuiWindowi:
 7610|  17.6k|{
 7611|  17.6k|    ImGuiContext& g = *GImGui;
 7612|       |
 7613|       |    // Modal check?
 7614|  17.6k|    if ((flags & ImGuiFocusRequestFlags_UnlessBelowModal) && (g.NavWindow != window)) // Early out in common case.
  ------------------
  |  Branch (7614:9): [True: 110, False: 17.5k]
  |  Branch (7614:62): [True: 110, False: 0]
  ------------------
 7615|    110|        if (ImGuiWindow* blocking_modal = FindBlockingModal(window))
  ------------------
  |  Branch (7615:26): [True: 0, False: 110]
  ------------------
 7616|      0|        {
 7617|      0|            IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window->Name : "<NULL>", blocking_modal->Name);
  ------------------
  |  |  244|      0|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (244:50): [True: 0, False: 0]
  |  |  |  Branch (244:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7618|      0|            if (window && window == window->RootWindow && (window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
  ------------------
  |  Branch (7618:17): [True: 0, False: 0]
  |  Branch (7618:27): [True: 0, False: 0]
  |  Branch (7618:59): [True: 0, False: 0]
  ------------------
 7619|      0|                BringWindowToDisplayBehind(window, blocking_modal); // Still bring to right below modal.
 7620|      0|            return;
 7621|      0|        }
 7622|       |
 7623|       |    // Find last focused child (if any) and focus it instead.
 7624|  17.6k|    if ((flags & ImGuiFocusRequestFlags_RestoreFocusedChild) && window != NULL)
  ------------------
  |  Branch (7624:9): [True: 0, False: 17.6k]
  |  Branch (7624:65): [True: 0, False: 0]
  ------------------
 7625|      0|        window = NavRestoreLastChildNavWindow(window);
 7626|       |
 7627|       |    // Apply focus
 7628|  17.6k|    if (g.NavWindow != window)
  ------------------
  |  Branch (7628:9): [True: 6.15k, False: 11.5k]
  ------------------
 7629|  6.15k|    {
 7630|  6.15k|        SetNavWindow(window);
 7631|  6.15k|        if (window && g.NavDisableMouseHover)
  ------------------
  |  Branch (7631:13): [True: 3.30k, False: 2.85k]
  |  Branch (7631:23): [True: 1.26k, False: 2.04k]
  ------------------
 7632|  1.26k|            g.NavMousePosDirty = true;
 7633|  6.15k|        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
  ------------------
  |  Branch (7633:19): [True: 3.30k, False: 2.85k]
  ------------------
 7634|  6.15k|        g.NavLayer = ImGuiNavLayer_Main;
 7635|  6.15k|        g.NavFocusScopeId = window ? window->NavRootFocusScopeId : 0;
  ------------------
  |  Branch (7635:29): [True: 3.30k, False: 2.85k]
  ------------------
 7636|  6.15k|        g.NavIdIsAlive = false;
 7637|  6.15k|        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1681|  6.15k|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
 7638|       |
 7639|       |        // Close popups if any
 7640|  6.15k|        ClosePopupsOverWindow(window, false);
 7641|  6.15k|    }
 7642|       |
 7643|       |    // Move the root window to the top of the pile
 7644|  17.6k|    IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
  ------------------
  |  |   23|  17.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7645|  17.6k|    ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
  ------------------
  |  Branch (7645:39): [True: 11.2k, False: 6.45k]
  ------------------
 7646|  17.6k|    ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
  ------------------
  |  Branch (7646:41): [True: 11.2k, False: 6.45k]
  ------------------
 7647|  17.6k|    ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
  ------------------
  |  Branch (7647:32): [True: 11.2k, False: 6.45k]
  ------------------
 7648|  17.6k|    bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);
  ------------------
  |  Branch (7648:48): [True: 80, False: 17.6k]
  |  Branch (7648:68): [True: 0, False: 80]
  |  Branch (7648:81): [True: 0, False: 0]
  ------------------
 7649|       |
 7650|       |    // Steal active widgets. Some of the cases it triggers includes:
 7651|       |    // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
 7652|       |    // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
 7653|       |    // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
 7654|  17.6k|    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
  ------------------
  |  Branch (7654:9): [True: 80, False: 17.6k]
  |  Branch (7654:28): [True: 80, False: 0]
  |  Branch (7654:48): [True: 39, False: 41]
  ------------------
 7655|     39|        if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
  ------------------
  |  Branch (7655:13): [True: 2, False: 37]
  |  Branch (7655:46): [True: 2, False: 0]
  ------------------
 7656|      2|            ClearActiveID();
 7657|       |
 7658|       |    // Passing NULL allow to disable keyboard focus
 7659|  17.6k|    if (!window)
  ------------------
  |  Branch (7659:9): [True: 6.45k, False: 11.2k]
  ------------------
 7660|  6.45k|        return;
 7661|  11.2k|    window->LastFrameJustFocused = g.FrameCount;
 7662|       |
 7663|       |    // Select in dock node
 7664|       |    // For #2304 we avoid applying focus immediately before the tabbar is visible.
 7665|       |    //if (dock_node && dock_node->TabBar)
 7666|       |    //    dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;
 7667|       |
 7668|       |    // Bring to front
 7669|  11.2k|    BringWindowToFocusFront(focus_front_window);
 7670|  11.2k|    if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
  ------------------
  |  Branch (7670:9): [True: 11.2k, False: 0]
  ------------------
 7671|  11.2k|        BringWindowToDisplayFront(display_front_window);
 7672|  11.2k|}
_ZN5ImGui14SetCurrentFontEP6ImFont:
 7714|  29.3k|{
 7715|  29.3k|    ImGuiContext& g = *GImGui;
 7716|  29.3k|    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7717|  29.3k|    IM_ASSERT(font->Scale > 0.0f);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7718|  29.3k|    g.Font = font;
 7719|  29.3k|    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
 7720|  29.3k|    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
  ------------------
  |  Branch (7720:18): [True: 0, False: 29.3k]
  ------------------
 7721|       |
 7722|  29.3k|    ImFontAtlas* atlas = g.Font->ContainerAtlas;
 7723|  29.3k|    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
 7724|  29.3k|    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
 7725|  29.3k|    g.DrawListSharedData.Font = g.Font;
 7726|  29.3k|    g.DrawListSharedData.FontSize = g.FontSize;
 7727|  29.3k|}
_ZN5ImGui12PushItemFlagEib:
 7748|  25.9k|{
 7749|  25.9k|    ImGuiContext& g = *GImGui;
 7750|  25.9k|    ImGuiItemFlags item_flags = g.CurrentItemFlags;
 7751|  25.9k|    IM_ASSERT(item_flags == g.ItemFlagsStack.back());
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7752|  25.9k|    if (enabled)
  ------------------
  |  Branch (7752:9): [True: 0, False: 25.9k]
  ------------------
 7753|      0|        item_flags |= option;
 7754|  25.9k|    else
 7755|  25.9k|        item_flags &= ~option;
 7756|  25.9k|    g.CurrentItemFlags = item_flags;
 7757|  25.9k|    g.ItemFlagsStack.push_back(item_flags);
 7758|  25.9k|}
_ZN5ImGui11PopItemFlagEv:
 7761|  25.9k|{
 7762|  25.9k|    ImGuiContext& g = *GImGui;
 7763|  25.9k|    IM_ASSERT(g.ItemFlagsStack.Size > 1); // Too many calls to PopItemFlag() - we always leave a 0 at the bottom of the stack.
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7764|  25.9k|    g.ItemFlagsStack.pop_back();
 7765|  25.9k|    g.CurrentItemFlags = g.ItemFlagsStack.back();
 7766|  25.9k|}
_ZN5ImGui11PushTabStopEb:
 7803|  25.9k|{
 7804|  25.9k|    PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop);
 7805|  25.9k|}
_ZN5ImGui10PopTabStopEv:
 7808|  25.9k|{
 7809|  25.9k|    PopItemFlag();
 7810|  25.9k|}
_ZN5ImGui15IsWindowHoveredEi:
 7901|  41.8k|{
 7902|  41.8k|    IM_ASSERT((flags & ~ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == 0 && "Invalid flags for IsWindowHovered()!");
  ------------------
  |  |   23|  41.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7903|       |
 7904|  41.8k|    ImGuiContext& g = *GImGui;
 7905|  41.8k|    ImGuiWindow* ref_window = g.HoveredWindow;
 7906|  41.8k|    ImGuiWindow* cur_window = g.CurrentWindow;
 7907|  41.8k|    if (ref_window == NULL)
  ------------------
  |  Branch (7907:9): [True: 41.2k, False: 574]
  ------------------
 7908|  41.2k|        return false;
 7909|       |
 7910|    574|    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
  ------------------
  |  Branch (7910:9): [True: 574, False: 0]
  ------------------
 7911|    574|    {
 7912|    574|        IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|    574|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7913|    574|        const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
 7914|    574|        const bool dock_hierarchy = (flags & ImGuiHoveredFlags_DockHierarchy) != 0;
 7915|    574|        if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (7915:13): [True: 0, False: 574]
  ------------------
 7916|      0|            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 7917|       |
 7918|    574|        bool result;
 7919|    574|        if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (7919:13): [True: 0, False: 574]
  ------------------
 7920|      0|            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 7921|    574|        else
 7922|    574|            result = (ref_window == cur_window);
 7923|    574|        if (!result)
  ------------------
  |  Branch (7923:13): [True: 461, False: 113]
  ------------------
 7924|    461|            return false;
 7925|    574|    }
 7926|       |
 7927|    113|    if (!IsWindowContentHoverable(ref_window, flags))
  ------------------
  |  Branch (7927:9): [True: 0, False: 113]
  ------------------
 7928|      0|        return false;
 7929|    113|    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (7929:9): [True: 113, False: 0]
  ------------------
 7930|    113|        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)
  ------------------
  |  Branch (7930:13): [True: 3, False: 110]
  |  Branch (7930:32): [True: 3, False: 0]
  |  Branch (7930:59): [True: 0, False: 3]
  ------------------
 7931|      0|            return false;
 7932|       |
 7933|       |    // When changing hovered window we requires a bit of stationary delay before activating hover timer.
 7934|       |    // FIXME: We don't support delay other than stationary one for now, other delay would need a way
 7935|       |    // to fullfill the possibility that multiple IsWindowHovered() with varying flag could return true
 7936|       |    // for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
 7937|       |    // We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
 7938|    113|    if (flags & ImGuiHoveredFlags_ForTooltip)
  ------------------
  |  Branch (7938:9): [True: 0, False: 113]
  ------------------
 7939|      0|        flags |= g.Style.HoverFlagsForTooltipMouse;
 7940|    113|    if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverWindowUnlockedStationaryId != ref_window->ID)
  ------------------
  |  Branch (7940:9): [True: 0, False: 113]
  |  Branch (7940:56): [True: 0, False: 0]
  ------------------
 7941|      0|        return false;
 7942|       |
 7943|    113|    return true;
 7944|    113|}
_ZN5ImGui15IsWindowFocusedEi:
 7947|  51.2k|{
 7948|  51.2k|    ImGuiContext& g = *GImGui;
 7949|  51.2k|    ImGuiWindow* ref_window = g.NavWindow;
 7950|  51.2k|    ImGuiWindow* cur_window = g.CurrentWindow;
 7951|       |
 7952|  51.2k|    if (ref_window == NULL)
  ------------------
  |  Branch (7952:9): [True: 15.1k, False: 36.1k]
  ------------------
 7953|  15.1k|        return false;
 7954|  36.1k|    if (flags & ImGuiFocusedFlags_AnyWindow)
  ------------------
  |  Branch (7954:9): [True: 0, False: 36.1k]
  ------------------
 7955|      0|        return true;
 7956|       |
 7957|  36.1k|    IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|  36.1k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7958|  36.1k|    const bool popup_hierarchy = (flags & ImGuiFocusedFlags_NoPopupHierarchy) == 0;
 7959|  36.1k|    const bool dock_hierarchy = (flags & ImGuiFocusedFlags_DockHierarchy) != 0;
 7960|  36.1k|    if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (7960:9): [True: 0, False: 36.1k]
  ------------------
 7961|      0|        cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 7962|       |
 7963|  36.1k|    if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (7963:9): [True: 0, False: 36.1k]
  ------------------
 7964|      0|        return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 7965|  36.1k|    else
 7966|  36.1k|        return (ref_window == cur_window);
 7967|  36.1k|}
_ZN5ImGui14GetWindowWidthEv:
 7990|  10.8k|{
 7991|  10.8k|    ImGuiWindow* window = GImGui->CurrentWindow;
 7992|  10.8k|    return window->Size.x;
 7993|  10.8k|}
_ZN5ImGui15GetWindowHeightEv:
 7996|  11.0k|{
 7997|  11.0k|    ImGuiWindow* window = GImGui->CurrentWindow;
 7998|  11.0k|    return window->Size.y;
 7999|  11.0k|}
_ZN5ImGui12SetWindowPosEP11ImGuiWindowRK6ImVec2i:
 8009|      2|{
 8010|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 8011|      2|    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
  ------------------
  |  Branch (8011:9): [True: 2, False: 0]
  |  Branch (8011:17): [True: 0, False: 2]
  ------------------
 8012|      0|        return;
 8013|       |
 8014|      2|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8015|      2|    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 8016|      2|    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);
 8017|       |
 8018|       |    // Set
 8019|      2|    const ImVec2 old_pos = window->Pos;
 8020|      2|    window->Pos = ImTrunc(pos);
 8021|      2|    ImVec2 offset = window->Pos - old_pos;
 8022|      2|    if (offset.x == 0.0f && offset.y == 0.0f)
  ------------------
  |  Branch (8022:9): [True: 1, False: 1]
  |  Branch (8022:29): [True: 0, False: 1]
  ------------------
 8023|      0|        return;
 8024|      2|    MarkIniSettingsDirty(window);
 8025|       |    // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
 8026|      2|    window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
 8027|      2|    window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
 8028|      2|    window->DC.IdealMaxPos += offset;
 8029|      2|    window->DC.CursorStartPos += offset;
 8030|      2|}
_ZN5ImGui13SetWindowSizeEP11ImGuiWindowRK6ImVec2i:
 8051|  55.3k|{
 8052|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 8053|  55.3k|    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
  ------------------
  |  Branch (8053:9): [True: 55.3k, False: 0]
  |  Branch (8053:17): [True: 29.3k, False: 25.9k]
  ------------------
 8054|  29.3k|        return;
 8055|       |
 8056|  25.9k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8057|  25.9k|    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 8058|       |
 8059|       |    // Set
 8060|  25.9k|    ImVec2 old_size = window->SizeFull;
 8061|  25.9k|    window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (8061:30): [True: 0, False: 25.9k]
  ------------------
 8062|  25.9k|    window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (8062:30): [True: 0, False: 25.9k]
  ------------------
 8063|  25.9k|    if (size.x <= 0.0f)
  ------------------
  |  Branch (8063:9): [True: 0, False: 25.9k]
  ------------------
 8064|      0|        window->AutoFitOnlyGrows = false;
 8065|  25.9k|    else
 8066|  25.9k|        window->SizeFull.x = IM_TRUNC(size.x);
  ------------------
  |  |  284|  25.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 8067|  25.9k|    if (size.y <= 0.0f)
  ------------------
  |  Branch (8067:9): [True: 0, False: 25.9k]
  ------------------
 8068|      0|        window->AutoFitOnlyGrows = false;
 8069|  25.9k|    else
 8070|  25.9k|        window->SizeFull.y = IM_TRUNC(size.y);
  ------------------
  |  |  284|  25.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 8071|  25.9k|    if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
  ------------------
  |  Branch (8071:9): [True: 4.00k, False: 21.9k]
  |  Branch (8071:45): [True: 1.94k, False: 20.0k]
  ------------------
 8072|  5.94k|        MarkIniSettingsDirty(window);
 8073|  25.9k|}
_ZN5ImGui14SetWindowFocusEv:
 8134|  10.8k|{
 8135|  10.8k|    FocusWindow(GImGui->CurrentWindow);
 8136|  10.8k|}
_ZN5ImGui17SetNextWindowSizeERK6ImVec2i:
 8163|  55.3k|{
 8164|  55.3k|    ImGuiContext& g = *GImGui;
 8165|  55.3k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  55.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8166|  55.3k|    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
 8167|  55.3k|    g.NextWindowData.SizeVal = size;
 8168|  55.3k|    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
  ------------------
  |  Branch (8168:33): [True: 29.3k, False: 25.9k]
  ------------------
 8169|  55.3k|}
_ZN5ImGui17GetWindowDrawListEv:
 8242|  25.9k|{
 8243|  25.9k|    ImGuiWindow* window = GetCurrentWindow();
 8244|  25.9k|    return window->DrawList;
 8245|  25.9k|}
_ZN5ImGui7GetFontEv:
 8261|  6.55M|{
 8262|  6.55M|    return GImGui->Font;
 8263|  6.55M|}
_ZN5ImGui11GetFontSizeEv:
 8266|  6.57M|{
 8267|  6.57M|    return GImGui->FontSize;
 8268|  6.57M|}
_ZN5ImGui14PushFocusScopeEj:
 8285|  84.6k|{
 8286|  84.6k|    ImGuiContext& g = *GImGui;
 8287|  84.6k|    g.FocusScopeStack.push_back(id);
 8288|  84.6k|    g.CurrentFocusScopeId = id;
 8289|  84.6k|}
_ZN5ImGui13PopFocusScopeEv:
 8292|  84.6k|{
 8293|  84.6k|    ImGuiContext& g = *GImGui;
 8294|  84.6k|    IM_ASSERT(g.FocusScopeStack.Size > 0); // Too many PopFocusScope() ?
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8295|  84.6k|    g.FocusScopeStack.pop_back();
 8296|  84.6k|    g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back() : 0;
  ------------------
  |  Branch (8296:29): [True: 55.3k, False: 29.3k]
  ------------------
 8297|  84.6k|}
_ZN5ImGui6PushIDEPKc:
 8391|  25.9k|{
 8392|  25.9k|    ImGuiContext& g = *GImGui;
 8393|  25.9k|    ImGuiWindow* window = g.CurrentWindow;
 8394|  25.9k|    ImGuiID id = window->GetID(str_id);
 8395|  25.9k|    window->IDStack.push_back(id);
 8396|  25.9k|}
_ZN5ImGui5PopIDEv:
 8454|  25.9k|{
 8455|  25.9k|    ImGuiWindow* window = GImGui->CurrentWindow;
 8456|  25.9k|    IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8457|  25.9k|    window->IDStack.pop_back();
 8458|  25.9k|}
_ZN5ImGui10GetKeyDataEP12ImGuiContext8ImGuiKey:
 8556|  1.08M|{
 8557|  1.08M|    ImGuiContext& g = *ctx;
 8558|       |
 8559|       |    // Special storage location for mods
 8560|  1.08M|    if (key & ImGuiMod_Mask_)
  ------------------
  |  Branch (8560:9): [True: 264k, False: 815k]
  ------------------
 8561|   264k|        key = ConvertSingleModFlagToKey(ctx, key);
 8562|       |
 8563|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 8564|       |    IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
 8565|       |    if (IsLegacyKey(key) && g.IO.KeyMap[key] != -1)
 8566|       |        key = (ImGuiKey)g.IO.KeyMap[key];  // Remap native->imgui or imgui->native
 8567|       |#else
 8568|  1.08M|    IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
  ------------------
  |  |   23|  1.08M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8569|  1.08M|#endif
 8570|  1.08M|    return &g.IO.KeysData[key - ImGuiKey_KeysData_OFFSET];
 8571|  1.08M|}
_ZN5ImGui25CalcTypematicRepeatAmountEffff:
 8651|  12.6k|{
 8652|  12.6k|    if (t1 == 0.0f)
  ------------------
  |  Branch (8652:9): [True: 0, False: 12.6k]
  ------------------
 8653|      0|        return 1;
 8654|  12.6k|    if (t0 >= t1)
  ------------------
  |  Branch (8654:9): [True: 0, False: 12.6k]
  ------------------
 8655|      0|        return 0;
 8656|  12.6k|    if (repeat_rate <= 0.0f)
  ------------------
  |  Branch (8656:9): [True: 0, False: 12.6k]
  ------------------
 8657|      0|        return (t0 < repeat_delay) && (t1 >= repeat_delay);
  ------------------
  |  Branch (8657:16): [True: 0, False: 0]
  |  Branch (8657:39): [True: 0, False: 0]
  ------------------
 8658|  12.6k|    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (8658:26): [True: 706, False: 11.9k]
  ------------------
 8659|  12.6k|    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (8659:26): [True: 0, False: 12.6k]
  ------------------
 8660|  12.6k|    const int count = count_t1 - count_t0;
 8661|  12.6k|    return count;
 8662|  12.6k|}
_ZN5ImGui22GetTypematicRepeatRateEiPfS0_:
 8665|  22.9k|{
 8666|  22.9k|    ImGuiContext& g = *GImGui;
 8667|  22.9k|    switch (flags & ImGuiInputFlags_RepeatRateMask_)
 8668|  22.9k|    {
 8669|  9.23k|    case ImGuiInputFlags_RepeatRateNavMove:             *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.80f; return;
  ------------------
  |  Branch (8669:5): [True: 9.23k, False: 13.7k]
  ------------------
 8670|      0|    case ImGuiInputFlags_RepeatRateNavTweak:            *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.30f; return;
  ------------------
  |  Branch (8670:5): [True: 0, False: 22.9k]
  ------------------
 8671|  13.7k|    case ImGuiInputFlags_RepeatRateDefault: default:    *repeat_delay = g.IO.KeyRepeatDelay * 1.00f; *repeat_rate = g.IO.KeyRepeatRate * 1.00f; return;
  ------------------
  |  Branch (8671:5): [True: 0, False: 22.9k]
  |  Branch (8671:45): [True: 13.7k, False: 9.23k]
  ------------------
 8672|  22.9k|    }
 8673|  22.9k|}
_ZN5ImGui19GetKeyPressedAmountE8ImGuiKeyff:
 8678|  12.6k|{
 8679|  12.6k|    ImGuiContext& g = *GImGui;
 8680|  12.6k|    const ImGuiKeyData* key_data = GetKeyData(key);
 8681|  12.6k|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8681:9): [True: 0, False: 12.6k]
  ------------------
 8682|      0|        return 0;
 8683|  12.6k|    const float t = key_data->DownDuration;
 8684|  12.6k|    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
 8685|  12.6k|}
_ZN5ImGui18SetShortcutRoutingEiji:
 8834|  58.7k|{
 8835|  58.7k|    ImGuiContext& g = *GImGui;
 8836|  58.7k|    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
  ------------------
  |  Branch (8836:9): [True: 0, False: 58.7k]
  ------------------
 8837|      0|        flags |= ImGuiInputFlags_RouteGlobalHigh; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
 8838|  58.7k|    else
 8839|  58.7k|        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteMask_)); // Check that only 1 routing flag is used
  ------------------
  |  |   23|  58.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8840|       |
 8841|  58.7k|    if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
  ------------------
  |  Branch (8841:9): [True: 0, False: 58.7k]
  ------------------
 8842|      0|        if (g.NavWindow == NULL)
  ------------------
  |  Branch (8842:13): [True: 0, False: 0]
  ------------------
 8843|      0|            return false;
 8844|  58.7k|    if (flags & ImGuiInputFlags_RouteAlways)
  ------------------
  |  Branch (8844:9): [True: 58.7k, False: 0]
  ------------------
 8845|  58.7k|        return true;
 8846|       |
 8847|      0|    const int score = CalcRoutingScore(g.CurrentWindow, owner_id, flags);
 8848|      0|    if (score == 255)
  ------------------
  |  Branch (8848:9): [True: 0, False: 0]
  ------------------
 8849|      0|        return false;
 8850|       |
 8851|       |    // Submit routing for NEXT frame (assuming score is sufficient)
 8852|       |    // FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
 8853|      0|    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);
 8854|      0|    const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
 8855|       |    //const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
 8856|      0|    if (score < routing_data->RoutingNextScore)
  ------------------
  |  Branch (8856:9): [True: 0, False: 0]
  ------------------
 8857|      0|    {
 8858|      0|        routing_data->RoutingNext = routing_id;
 8859|      0|        routing_data->RoutingNextScore = (ImU8)score;
 8860|      0|    }
 8861|       |
 8862|       |    // Return routing state for CURRENT frame
 8863|      0|    return routing_data->RoutingCurr == routing_id;
 8864|      0|}
_ZN5ImGui9IsKeyDownE8ImGuiKey:
 8878|   445k|{
 8879|   445k|    return IsKeyDown(key, ImGuiKeyOwner_Any);
  ------------------
  |  | 1384|   445k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
 8880|   445k|}
_ZN5ImGui9IsKeyDownE8ImGuiKeyj:
 8883|   476k|{
 8884|   476k|    const ImGuiKeyData* key_data = GetKeyData(key);
 8885|   476k|    if (!key_data->Down)
  ------------------
  |  Branch (8885:9): [True: 459k, False: 17.6k]
  ------------------
 8886|   459k|        return false;
 8887|  17.6k|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (8887:9): [True: 26, False: 17.6k]
  ------------------
 8888|     26|        return false;
 8889|  17.6k|    return true;
 8890|  17.6k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyb:
 8893|   200k|{
 8894|   200k|    return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
  ------------------
  |  | 1384|   200k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8894:49): [True: 200k, False: 79]
  ------------------
 8895|   200k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyji:
 8899|   380k|{
 8900|   380k|    const ImGuiKeyData* key_data = GetKeyData(key);
 8901|   380k|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8901:9): [True: 352k, False: 28.7k]
  ------------------
 8902|   352k|        return false;
 8903|  28.7k|    const float t = key_data->DownDuration;
 8904|  28.7k|    if (t < 0.0f)
  ------------------
  |  Branch (8904:9): [True: 0, False: 28.7k]
  ------------------
 8905|      0|        return false;
 8906|  28.7k|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|  28.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8907|       |
 8908|  28.7k|    bool pressed = (t == 0.0f);
 8909|  28.7k|    if (!pressed && ((flags & ImGuiInputFlags_Repeat) != 0))
  ------------------
  |  Branch (8909:9): [True: 27.8k, False: 855]
  |  Branch (8909:21): [True: 22.9k, False: 4.90k]
  ------------------
 8910|  22.9k|    {
 8911|  22.9k|        float repeat_delay, repeat_rate;
 8912|  22.9k|        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
 8913|  22.9k|        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
  ------------------
  |  Branch (8913:19): [True: 12.6k, False: 10.2k]
  |  Branch (8913:41): [True: 5.14k, False: 7.53k]
  ------------------
 8914|  22.9k|    }
 8915|  28.7k|    if (!pressed)
  ------------------
  |  Branch (8915:9): [True: 22.7k, False: 5.99k]
  ------------------
 8916|  22.7k|        return false;
 8917|  5.99k|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (8917:9): [True: 0, False: 5.99k]
  ------------------
 8918|      0|        return false;
 8919|  5.99k|    return true;
 8920|  5.99k|}
_ZN5ImGui14IsMouseClickedEib:
 8952|     72|{
 8953|     72|    return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
  ------------------
  |  | 1384|     72|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8953:54): [True: 0, False: 72]
  ------------------
 8954|     72|}
_ZN5ImGui14IsMouseClickedEiji:
 8957|    235|{
 8958|    235|    ImGuiContext& g = *GImGui;
 8959|    235|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    235|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8960|    235|    if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8960:9): [True: 220, False: 15]
  ------------------
 8961|    220|        return false;
 8962|     15|    const float t = g.IO.MouseDownDuration[button];
 8963|     15|    if (t < 0.0f)
  ------------------
  |  Branch (8963:9): [True: 0, False: 15]
  ------------------
 8964|      0|        return false;
 8965|     15|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|     15|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8966|       |
 8967|     15|    const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
 8968|     15|    const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
  ------------------
  |  Branch (8968:26): [True: 15, False: 0]
  |  Branch (8968:42): [True: 0, False: 0]
  |  Branch (8968:52): [True: 0, False: 0]
  |  Branch (8968:79): [True: 0, False: 0]
  ------------------
 8969|     15|    if (!pressed)
  ------------------
  |  Branch (8969:9): [True: 0, False: 15]
  ------------------
 8970|      0|        return false;
 8971|       |
 8972|     15|    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
  ------------------
  |  Branch (8972:9): [True: 0, False: 15]
  ------------------
 8973|      0|        return false;
 8974|       |
 8975|     15|    return true;
 8976|     15|}
_ZN5ImGui15IsMouseReleasedEij:
 8986|    163|{
 8987|    163|    ImGuiContext& g = *GImGui;
 8988|    163|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    163|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8989|    163|    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
  ------------------
  |  Branch (8989:12): [True: 0, False: 163]
  |  Branch (8989:42): [True: 0, False: 0]
  ------------------
 8990|    163|}
_ZN5ImGui20IsMouseDoubleClickedEi:
 8993|     72|{
 8994|     72|    ImGuiContext& g = *GImGui;
 8995|     72|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|     72|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8996|     72|    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any);
  ------------------
  |  | 1384|      9|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8996:12): [True: 9, False: 63]
  |  Branch (8996:51): [True: 9, False: 0]
  ------------------
 8997|     72|}
_ZN5ImGui19IsMouseHoveringRectERK6ImVec2S2_b:
 9010|   185k|{
 9011|   185k|    ImGuiContext& g = *GImGui;
 9012|       |
 9013|       |    // Clip
 9014|   185k|    ImRect rect_clipped(r_min, r_max);
 9015|   185k|    if (clip)
  ------------------
  |  Branch (9015:9): [True: 100k, False: 84.6k]
  ------------------
 9016|   100k|        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);
 9017|       |
 9018|       |    // Hit testing, expanded for touch input
 9019|   185k|    if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
  ------------------
  |  Branch (9019:9): [True: 183k, False: 1.88k]
  ------------------
 9020|   183k|        return false;
 9021|  1.88k|    if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
  ------------------
  |  Branch (9021:9): [True: 0, False: 1.88k]
  ------------------
 9022|      0|        return false;
 9023|  1.88k|    return true;
 9024|  1.88k|}
_ZN5ImGui24IsMouseDragPastThresholdEif:
 9029|     21|{
 9030|     21|    ImGuiContext& g = *GImGui;
 9031|     21|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|     21|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9032|     21|    if (lock_threshold < 0.0f)
  ------------------
  |  Branch (9032:9): [True: 21, False: 0]
  ------------------
 9033|     21|        lock_threshold = g.IO.MouseDragThreshold;
 9034|     21|    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
 9035|     21|}
_ZN5ImGui15IsMouseDraggingEif:
 9038|     78|{
 9039|     78|    ImGuiContext& g = *GImGui;
 9040|     78|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|     78|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9041|     78|    if (!g.IO.MouseDown[button])
  ------------------
  |  Branch (9041:9): [True: 57, False: 21]
  ------------------
 9042|     57|        return false;
 9043|     21|    return IsMouseDragPastThreshold(button, lock_threshold);
 9044|     78|}
_ZN5ImGui11GetMousePosEv:
 9047|  6.36k|{
 9048|  6.36k|    ImGuiContext& g = *GImGui;
 9049|  6.36k|    return g.IO.MousePos;
 9050|  6.36k|}
_ZN5ImGui15IsMousePosValidEPK6ImVec2:
 9074|  99.4k|{
 9075|       |    // The assert is only to silence a false-positive in XCode Static Analysis.
 9076|       |    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
 9077|  99.4k|    IM_ASSERT(GImGui != NULL);
  ------------------
  |  |   23|  99.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9078|  99.4k|    const float MOUSE_INVALID = -256000.0f;
 9079|  99.4k|    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
  ------------------
  |  Branch (9079:16): [True: 73.4k, False: 25.9k]
  ------------------
 9080|  99.4k|    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
  ------------------
  |  Branch (9080:12): [True: 28.5k, False: 70.8k]
  |  Branch (9080:36): [True: 28.5k, False: 0]
  ------------------
 9081|  99.4k|}
_ZN5ImGui14SetMouseCursorEi:
 9128|     41|{
 9129|     41|    ImGuiContext& g = *GImGui;
 9130|     41|    g.MouseCursor = cursor_type;
 9131|     41|}
_ZN5ImGui17UpdateInputEventsEb:
 9535|  29.3k|{
 9536|  29.3k|    ImGuiContext& g = *GImGui;
 9537|  29.3k|    ImGuiIO& io = g.IO;
 9538|       |
 9539|       |    // Only trickle chars<>key when working with InputText()
 9540|       |    // FIXME: InputText() could parse event trail?
 9541|       |    // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
 9542|  29.3k|    const bool trickle_interleaved_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);
  ------------------
  |  Branch (9542:53): [True: 29.3k, False: 0]
  |  Branch (9542:76): [True: 0, False: 29.3k]
  ------------------
 9543|       |
 9544|  29.3k|    bool mouse_moved = false, mouse_wheeled = false, key_changed = false, text_inputted = false;
 9545|  29.3k|    int  mouse_button_changed = 0x00;
 9546|  29.3k|    ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;
 9547|       |
 9548|  29.3k|    int event_n = 0;
 9549|  37.8k|    for (; event_n < g.InputEventsQueue.Size; event_n++)
  ------------------
  |  Branch (9549:12): [True: 9.90k, False: 27.9k]
  ------------------
 9550|  9.90k|    {
 9551|  9.90k|        ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
 9552|  9.90k|        if (e->Type == ImGuiInputEventType_MousePos)
  ------------------
  |  Branch (9552:13): [True: 1.47k, False: 8.42k]
  ------------------
 9553|  1.47k|        {
 9554|  1.47k|            if (g.IO.WantSetMousePos)
  ------------------
  |  Branch (9554:17): [True: 0, False: 1.47k]
  ------------------
 9555|      0|                continue;
 9556|       |            // Trickling Rule: Stop processing queued events if we already handled a mouse button change
 9557|  1.47k|            ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
 9558|  1.47k|            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
  ------------------
  |  Branch (9558:17): [True: 1.47k, False: 0]
  |  Branch (9558:41): [True: 58, False: 1.41k]
  |  Branch (9558:70): [True: 90, False: 1.32k]
  |  Branch (9558:87): [True: 55, False: 1.27k]
  |  Branch (9558:102): [True: 0, False: 1.27k]
  ------------------
 9559|    203|                break;
 9560|  1.27k|            io.MousePos = event_pos;
 9561|  1.27k|            io.MouseSource = e->MousePos.MouseSource;
 9562|  1.27k|            mouse_moved = true;
 9563|  1.27k|        }
 9564|  8.42k|        else if (e->Type == ImGuiInputEventType_MouseButton)
  ------------------
  |  Branch (9564:18): [True: 1.98k, False: 6.44k]
  ------------------
 9565|  1.98k|        {
 9566|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
 9567|  1.98k|            const ImGuiMouseButton button = e->MouseButton.Button;
 9568|  1.98k|            IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  1.98k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9569|  1.98k|            if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
  ------------------
  |  Branch (9569:17): [True: 1.98k, False: 0]
  |  Branch (9569:41): [True: 440, False: 1.54k]
  |  Branch (9569:83): [True: 39, False: 1.51k]
  ------------------
 9570|    479|                break;
 9571|  1.51k|            if (trickle_fast_inputs && e->MouseButton.MouseSource == ImGuiMouseSource_TouchScreen && mouse_moved) // #2702: TouchScreen have no initial hover.
  ------------------
  |  Branch (9571:17): [True: 1.51k, False: 0]
  |  Branch (9571:40): [True: 0, False: 1.51k]
  |  Branch (9571:102): [True: 0, False: 0]
  ------------------
 9572|      0|                break;
 9573|  1.51k|            io.MouseDown[button] = e->MouseButton.Down;
 9574|  1.51k|            io.MouseSource = e->MouseButton.MouseSource;
 9575|  1.51k|            mouse_button_changed |= (1 << button);
 9576|  1.51k|        }
 9577|  6.44k|        else if (e->Type == ImGuiInputEventType_MouseWheel)
  ------------------
  |  Branch (9577:18): [True: 631, False: 5.80k]
  ------------------
 9578|    631|        {
 9579|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the event
 9580|    631|            if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
  ------------------
  |  Branch (9580:17): [True: 631, False: 0]
  |  Branch (9580:41): [True: 98, False: 533]
  |  Branch (9580:56): [True: 53, False: 480]
  ------------------
 9581|    151|                break;
 9582|    480|            io.MouseWheelH += e->MouseWheel.WheelX;
 9583|    480|            io.MouseWheel += e->MouseWheel.WheelY;
 9584|    480|            io.MouseSource = e->MouseWheel.MouseSource;
 9585|    480|            mouse_wheeled = true;
 9586|    480|        }
 9587|  5.80k|        else if (e->Type == ImGuiInputEventType_MouseViewport)
  ------------------
  |  Branch (9587:18): [True: 0, False: 5.80k]
  ------------------
 9588|      0|        {
 9589|      0|            io.MouseHoveredViewport = e->MouseViewport.HoveredViewportID;
 9590|      0|        }
 9591|  5.80k|        else if (e->Type == ImGuiInputEventType_Key)
  ------------------
  |  Branch (9591:18): [True: 2.00k, False: 3.80k]
  ------------------
 9592|  2.00k|        {
 9593|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
 9594|  2.00k|            ImGuiKey key = e->Key.Key;
 9595|  2.00k|            IM_ASSERT(key != ImGuiKey_None);
  ------------------
  |  |   23|  2.00k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9596|  2.00k|            ImGuiKeyData* key_data = GetKeyData(key);
 9597|  2.00k|            const int key_data_index = (int)(key_data - g.IO.KeysData);
 9598|  2.00k|            if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || text_inputted || mouse_button_changed != 0))
  ------------------
  |  Branch (9598:17): [True: 2.00k, False: 0]
  |  Branch (9598:40): [True: 1.84k, False: 165]
  |  Branch (9598:74): [True: 388, False: 1.45k]
  |  Branch (9598:118): [True: 0, False: 1.45k]
  |  Branch (9598:135): [True: 2, False: 1.45k]
  ------------------
 9599|    390|                break;
 9600|  1.61k|            key_data->Down = e->Key.Down;
 9601|  1.61k|            key_data->AnalogValue = e->Key.AnalogValue;
 9602|  1.61k|            key_changed = true;
 9603|  1.61k|            key_changed_mask.SetBit(key_data_index);
 9604|       |
 9605|       |            // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
 9606|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9607|       |            io.KeysDown[key_data_index] = key_data->Down;
 9608|       |            if (io.KeyMap[key_data_index] != -1)
 9609|       |                io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
 9610|       |#endif
 9611|  1.61k|        }
 9612|  3.80k|        else if (e->Type == ImGuiInputEventType_Text)
  ------------------
  |  Branch (9612:18): [True: 3.49k, False: 303]
  ------------------
 9613|  3.49k|        {
 9614|       |            // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
 9615|  3.49k|            if (trickle_fast_inputs && ((key_changed && trickle_interleaved_keys_and_text) || mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
  ------------------
  |  Branch (9615:17): [True: 3.49k, False: 0]
  |  Branch (9615:42): [True: 68, False: 3.43k]
  |  Branch (9615:57): [True: 0, False: 68]
  |  Branch (9615:95): [True: 28, False: 3.47k]
  |  Branch (9615:124): [True: 142, False: 3.32k]
  |  Branch (9615:139): [True: 59, False: 3.26k]
  ------------------
 9616|    229|                break;
 9617|  3.26k|            unsigned int c = e->Text.Char;
 9618|  3.26k|            io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2383|  3.26k|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
                          io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2379|  3.51k|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
  |  Branch (9618:47): [True: 3.02k, False: 245]
  ------------------
 9619|  3.26k|            if (trickle_interleaved_keys_and_text)
  ------------------
  |  Branch (9619:17): [True: 0, False: 3.26k]
  ------------------
 9620|      0|                text_inputted = true;
 9621|  3.26k|        }
 9622|    303|        else if (e->Type == ImGuiInputEventType_Focus)
  ------------------
  |  Branch (9622:18): [True: 303, False: 0]
  ------------------
 9623|    303|        {
 9624|       |            // We intentionally overwrite this and process in NewFrame(), in order to give a chance
 9625|       |            // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
 9626|    303|            const bool focus_lost = !e->AppFocused.Focused;
 9627|    303|            io.AppFocusLost = focus_lost;
 9628|    303|        }
 9629|      0|        else
 9630|      0|        {
 9631|      0|            IM_ASSERT(0 && "Unknown event!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9632|      0|        }
 9633|  9.90k|    }
 9634|       |
 9635|       |    // Record trail (for domain-specific applications wanting to access a precise trail)
 9636|       |    //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
 9637|  37.8k|    for (int n = 0; n < event_n; n++)
  ------------------
  |  Branch (9637:21): [True: 8.45k, False: 29.3k]
  ------------------
 9638|  8.45k|        g.InputEventsTrail.push_back(g.InputEventsQueue[n]);
 9639|       |
 9640|       |    // [DEBUG]
 9641|  29.3k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 9642|  29.3k|    if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
  ------------------
  |  Branch (9642:9): [True: 5.69k, False: 23.6k]
  |  Branch (9642:25): [True: 0, False: 5.69k]
  ------------------
 9643|      0|        for (int n = 0; n < g.InputEventsQueue.Size; n++)
  ------------------
  |  Branch (9643:25): [True: 0, False: 0]
  ------------------
 9644|      0|            DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
  ------------------
  |  Branch (9644:34): [True: 0, False: 0]
  ------------------
 9645|  29.3k|#endif
 9646|       |
 9647|       |    // Remaining events will be processed on the next frame
 9648|  29.3k|    if (event_n == g.InputEventsQueue.Size)
  ------------------
  |  Branch (9648:9): [True: 27.9k, False: 1.45k]
  ------------------
 9649|  27.9k|        g.InputEventsQueue.resize(0);
 9650|  1.45k|    else
 9651|  1.45k|        g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
 9652|       |
 9653|       |    // Clear buttons state when focus is lost
 9654|       |    // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
 9655|       |    // - we clear in EndFrame() and not now in order allow application/user code polling this flag
 9656|       |    //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
 9657|  29.3k|    if (g.IO.AppFocusLost)
  ------------------
  |  Branch (9657:9): [True: 199, False: 29.1k]
  ------------------
 9658|    199|        g.IO.ClearInputKeys();
 9659|  29.3k|}
_ZN5ImGui12TestKeyOwnerE8ImGuiKeyj:
 9682|  82.4k|{
 9683|  82.4k|    if (!IsNamedKeyOrModKey(key))
  ------------------
  |  Branch (9683:9): [True: 0, False: 82.4k]
  ------------------
 9684|      0|        return true;
 9685|       |
 9686|  82.4k|    ImGuiContext& g = *GImGui;
 9687|  82.4k|    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
  ------------------
  |  | 1384|    126|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9687:9): [True: 126, False: 82.2k]
  |  Branch (9687:43): [True: 126, False: 0]
  |  Branch (9687:69): [True: 122, False: 4]
  ------------------
 9688|    122|        if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1311|    244|#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
  ------------------
                      if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1312|    122|#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
  ------------------
  |  Branch (9688:13): [True: 122, False: 0]
  |  Branch (9688:47): [True: 26, False: 96]
  ------------------
 9689|     26|            return false;
 9690|       |
 9691|  82.3k|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
 9692|  82.3k|    if (owner_id == ImGuiKeyOwner_Any)
  ------------------
  |  | 1384|  82.3k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9692:9): [True: 18.9k, False: 63.4k]
  ------------------
 9693|  18.9k|        return (owner_data->LockThisFrame == false);
 9694|       |
 9695|       |    // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
 9696|       |    // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
 9697|       |    // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
 9698|  63.4k|    if (owner_data->OwnerCurr != owner_id)
  ------------------
  |  Branch (9698:9): [True: 0, False: 63.4k]
  ------------------
 9699|      0|    {
 9700|      0|        if (owner_data->LockThisFrame)
  ------------------
  |  Branch (9700:13): [True: 0, False: 0]
  ------------------
 9701|      0|            return false;
 9702|      0|        if (owner_data->OwnerCurr != ImGuiKeyOwner_None)
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9702:13): [True: 0, False: 0]
  ------------------
 9703|      0|            return false;
 9704|      0|    }
 9705|       |
 9706|  63.4k|    return true;
 9707|  63.4k|}
_ZN5ImGui8ShortcutEiji:
 9762|  58.7k|{
 9763|  58.7k|    ImGuiContext& g = *GImGui;
 9764|       |
 9765|       |    // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
 9766|  58.7k|    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
  ------------------
  |  Branch (9766:9): [True: 58.7k, False: 0]
  ------------------
 9767|  58.7k|        flags |= ImGuiInputFlags_RouteFocused;
 9768|  58.7k|    if (!SetShortcutRouting(key_chord, owner_id, flags))
  ------------------
  |  Branch (9768:9): [True: 0, False: 58.7k]
  ------------------
 9769|      0|        return false;
 9770|       |
 9771|  58.7k|    if (key_chord & ImGuiMod_Shortcut)
  ------------------
  |  Branch (9771:9): [True: 0, False: 58.7k]
  ------------------
 9772|      0|        key_chord = ConvertShortcutMod(key_chord);
 9773|  58.7k|    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
 9774|  58.7k|    if (g.IO.KeyMods != mods)
  ------------------
  |  Branch (9774:9): [True: 58.7k, False: 0]
  ------------------
 9775|  58.7k|        return false;
 9776|       |
 9777|       |    // Special storage location for mods
 9778|      0|    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
 9779|      0|    if (key == ImGuiKey_None)
  ------------------
  |  Branch (9779:9): [True: 0, False: 0]
  ------------------
 9780|      0|        key = ConvertSingleModFlagToKey(&g, mods);
 9781|       |
 9782|      0|    if (!IsKeyPressed(key, owner_id, (flags & (ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateMask_))))
  ------------------
  |  Branch (9782:9): [True: 0, False: 0]
  ------------------
 9783|      0|        return false;
 9784|      0|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9785|       |
 9786|      0|    return true;
 9787|      0|}
_ZN5ImGui30DebugCheckVersionAndDataLayoutEPKcmmmmmm:
 9803|      1|{
 9804|      1|    bool error = false;
 9805|      1|    if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   26|      1|#define IMGUI_VERSION       "1.90 WIP"
  ------------------
                  if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9805:9): [True: 0, False: 1]
  ------------------
 9806|      1|    if (sz_io != sizeof(ImGuiIO)) { error = true; IM_ASSERT(sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9806:9): [True: 0, False: 1]
  ------------------
 9807|      1|    if (sz_style != sizeof(ImGuiStyle)) { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9807:9): [True: 0, False: 1]
  ------------------
 9808|      1|    if (sz_vec2 != sizeof(ImVec2)) { error = true; IM_ASSERT(sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9808:9): [True: 0, False: 1]
  ------------------
 9809|      1|    if (sz_vec4 != sizeof(ImVec4)) { error = true; IM_ASSERT(sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9809:9): [True: 0, False: 1]
  ------------------
 9810|      1|    if (sz_vert != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9810:9): [True: 0, False: 1]
  ------------------
 9811|      1|    if (sz_idx != sizeof(ImDrawIdx)) { error = true; IM_ASSERT(sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9811:9): [True: 0, False: 1]
  ------------------
 9812|      1|    return !error;
 9813|      1|}
_ZN15ImGuiStackSizes17SetToContextStateEP12ImGuiContext:
10068|  84.6k|{
10069|  84.6k|    ImGuiContext& g = *ctx;
10070|  84.6k|    ImGuiWindow* window = g.CurrentWindow;
10071|  84.6k|    SizeOfIDStack = (short)window->IDStack.Size;
10072|  84.6k|    SizeOfColorStack = (short)g.ColorStack.Size;
10073|  84.6k|    SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
10074|  84.6k|    SizeOfFontStack = (short)g.FontStack.Size;
10075|  84.6k|    SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
10076|  84.6k|    SizeOfGroupStack = (short)g.GroupStack.Size;
10077|  84.6k|    SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
10078|  84.6k|    SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
10079|  84.6k|    SizeOfDisabledStack = (short)g.DisabledStackSize;
10080|  84.6k|}
_ZN15ImGuiStackSizes23CompareWithContextStateEP12ImGuiContext:
10084|  84.6k|{
10085|  84.6k|    ImGuiContext& g = *ctx;
10086|  84.6k|    ImGuiWindow* window = g.CurrentWindow;
10087|  84.6k|    IM_UNUSED(window);
  ------------------
  |  |   89|  84.6k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
10088|       |
10089|       |    // Window stacks
10090|       |    // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
10091|  84.6k|    IM_ASSERT(SizeOfIDStack         == window->IDStack.Size     && "PushID/PopID or TreeNode/TreePop Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10092|       |
10093|       |    // Global stacks
10094|       |    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
10095|  84.6k|    IM_ASSERT(SizeOfGroupStack      == g.GroupStack.Size        && "BeginGroup/EndGroup Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10096|  84.6k|    IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size   && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10097|  84.6k|    IM_ASSERT(SizeOfDisabledStack   == g.DisabledStackSize      && "BeginDisabled/EndDisabled Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10098|  84.6k|    IM_ASSERT(SizeOfItemFlagsStack  >= g.ItemFlagsStack.Size    && "PushItemFlag/PopItemFlag Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10099|  84.6k|    IM_ASSERT(SizeOfColorStack      >= g.ColorStack.Size        && "PushStyleColor/PopStyleColor Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10100|  84.6k|    IM_ASSERT(SizeOfStyleVarStack   >= g.StyleVarStack.Size     && "PushStyleVar/PopStyleVar Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10101|  84.6k|    IM_ASSERT(SizeOfFontStack       >= g.FontStack.Size         && "PushFont/PopFont Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10102|  84.6k|    IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size   && "PushFocusScope/PopFocusScope Mismatch!");
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10103|  84.6k|}
_ZN5ImGui8ItemSizeERK6ImVec2f:
10142|  38.7k|{
10143|  38.7k|    ImGuiContext& g = *GImGui;
10144|  38.7k|    ImGuiWindow* window = g.CurrentWindow;
10145|  38.7k|    if (window->SkipItems)
  ------------------
  |  Branch (10145:9): [True: 0, False: 38.7k]
  ------------------
10146|      0|        return;
10147|       |
10148|       |    // We increase the height in this function to accommodate for baseline offset.
10149|       |    // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
10150|       |    // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
10151|  38.7k|    const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
  ------------------
  |  Branch (10151:46): [True: 34, False: 38.6k]
  ------------------
10152|       |
10153|  38.7k|    const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
  ------------------
  |  Branch (10153:27): [True: 0, False: 38.7k]
  ------------------
10154|  38.7k|    const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/window->DC.CursorPos.y - line_y1/*, 0.0f)*/ + size.y + offset_to_match_baseline_y);
10155|       |
10156|       |    // Always align ourselves on pixel boundaries
10157|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
10158|  38.7k|    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
10159|  38.7k|    window->DC.CursorPosPrevLine.y = line_y1;
10160|  38.7k|    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
  ------------------
  |  |  284|  38.7k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
10161|  38.7k|    window->DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
  ------------------
  |  |  284|  38.7k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
10162|  38.7k|    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
10163|  38.7k|    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
10164|       |    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
10165|       |
10166|  38.7k|    window->DC.PrevLineSize.y = line_height;
10167|  38.7k|    window->DC.CurrLineSize.y = 0.0f;
10168|  38.7k|    window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
10169|  38.7k|    window->DC.CurrLineTextBaseOffset = 0.0f;
10170|  38.7k|    window->DC.IsSameLine = window->DC.IsSetPos = false;
10171|       |
10172|       |    // Horizontal layout mode
10173|  38.7k|    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
  ------------------
  |  Branch (10173:9): [True: 0, False: 38.7k]
  ------------------
10174|      0|        SameLine();
10175|  38.7k|}
_ZN5ImGui7ItemAddERK6ImRectjPS1_i:
10181|   153k|{
10182|   153k|    ImGuiContext& g = *GImGui;
10183|   153k|    ImGuiWindow* window = g.CurrentWindow;
10184|       |
10185|       |    // Set item data
10186|       |    // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
10187|   153k|    g.LastItemData.ID = id;
10188|   153k|    g.LastItemData.Rect = bb;
10189|   153k|    g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
  ------------------
  |  Branch (10189:30): [True: 0, False: 153k]
  ------------------
10190|   153k|    g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
10191|   153k|    g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
10192|       |    // Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.
10193|       |
10194|       |    // Directional navigation processing
10195|   153k|    if (id != 0)
  ------------------
  |  Branch (10195:9): [True: 138k, False: 15.1k]
  ------------------
10196|   138k|    {
10197|   138k|        KeepAliveID(id);
10198|       |
10199|       |        // Runs prior to clipping early-out
10200|       |        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
10201|       |        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
10202|       |        //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
10203|       |        //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
10204|       |        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
10205|       |        //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
10206|       |        // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
10207|       |        // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
10208|   138k|        if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
  ------------------
  |  Branch (10208:13): [True: 82.2k, False: 56.4k]
  ------------------
10209|  82.2k|        {
10210|  82.2k|            window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
10211|  82.2k|            if (g.NavId == id || g.NavAnyRequest)
  ------------------
  |  Branch (10211:17): [True: 2.15k, False: 80.1k]
  |  Branch (10211:34): [True: 8.61k, False: 71.4k]
  ------------------
10212|  10.7k|                if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
  ------------------
  |  Branch (10212:21): [True: 2.47k, False: 8.29k]
  ------------------
10213|  2.47k|                    if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
  ------------------
  |  Branch (10213:25): [True: 2.47k, False: 0]
  |  Branch (10213:50): [True: 0, False: 0]
  ------------------
10214|  2.47k|                        NavProcessItem();
10215|  82.2k|        }
10216|       |
10217|       |        // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
10218|       |        // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
10219|       |        // READ THE FAQ: https://dearimgui.com/faq
10220|   138k|        IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
  ------------------
  |  |   23|   138k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10221|   138k|    }
10222|   153k|    g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
10223|   153k|    g.NextItemData.ItemFlags = ImGuiItemFlags_None;
10224|       |
10225|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
10226|       |    if (id != 0)
10227|       |        IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
10228|       |#endif
10229|       |
10230|       |    // Clipping test
10231|       |    // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
10232|       |    //const bool is_clipped = IsClippedEx(bb, id);
10233|       |    //if (is_clipped)
10234|       |    //    return false;
10235|   153k|    const bool is_rect_visible = bb.Overlaps(window->ClipRect);
10236|   153k|    if (!is_rect_visible)
  ------------------
  |  Branch (10236:9): [True: 55.4k, False: 98.4k]
  ------------------
10237|  55.4k|        if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId))
  ------------------
  |  Branch (10237:13): [True: 13.1k, False: 42.3k]
  |  Branch (10237:25): [True: 42.3k, False: 0]
  |  Branch (10237:45): [True: 42.3k, False: 0]
  |  Branch (10237:78): [True: 41.4k, False: 910]
  ------------------
10238|  54.5k|            if (!g.LogEnabled)
  ------------------
  |  Branch (10238:17): [True: 54.5k, False: 0]
  ------------------
10239|  54.5k|                return false;
10240|       |
10241|       |    // [DEBUG]
10242|  99.3k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
10243|  99.3k|    if (id != 0 && id == g.DebugLocateId)
  ------------------
  |  Branch (10243:9): [True: 97.3k, False: 2.07k]
  |  Branch (10243:20): [True: 0, False: 97.3k]
  ------------------
10244|      0|        DebugLocateItemResolveWithLastItem();
10245|  99.3k|#endif
10246|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
10247|       |    //if ((g.LastItemData.InFlags & ImGuiItemFlags_NoNav) == 0)
10248|       |    //    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
10249|       |
10250|       |    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
10251|  99.3k|    if (is_rect_visible)
  ------------------
  |  Branch (10251:9): [True: 98.4k, False: 910]
  ------------------
10252|  98.4k|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
10253|  99.3k|    if (IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (10253:9): [True: 608, False: 98.7k]
  ------------------
10254|    608|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
10255|  99.3k|    return true;
10256|   153k|}
_ZN5ImGui18GetCursorScreenPosEv:
10290|  32.3k|{
10291|  32.3k|    ImGuiWindow* window = GetCurrentWindowRead();
10292|  32.3k|    return window->DC.CursorPos;
10293|  32.3k|}
_ZN5ImGui28GetTextLineHeightWithSpacingEv:
10462|  25.9k|{
10463|  25.9k|    ImGuiContext& g = *GImGui;
10464|  25.9k|    return g.FontSize + g.Style.ItemSpacing.y;
10465|  25.9k|}
_ZN5ImGui14GetFrameHeightEv:
10468|     24|{
10469|     24|    ImGuiContext& g = *GImGui;
10470|     24|    return g.FontSize + g.Style.FramePadding.y * 2.0f;
10471|     24|}
_ZN5ImGui22GetContentRegionMaxAbsEv:
10492|  25.9k|{
10493|  25.9k|    ImGuiContext& g = *GImGui;
10494|  25.9k|    ImGuiWindow* window = g.CurrentWindow;
10495|  25.9k|    ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;
  ------------------
  |  Branch (10495:18): [True: 0, False: 25.9k]
  |  Branch (10495:47): [True: 0, False: 25.9k]
  ------------------
10496|  25.9k|    return mx;
10497|  25.9k|}
_ZN5ImGui21GetContentRegionAvailEv:
10500|  25.9k|{
10501|  25.9k|    ImGuiWindow* window = GImGui->CurrentWindow;
10502|  25.9k|    return GetContentRegionMaxAbs() - window->DC.CursorPos;
10503|  25.9k|}
_ZN5ImGui25GetWindowContentRegionMaxEv:
10513|  25.9k|{
10514|  25.9k|    ImGuiWindow* window = GImGui->CurrentWindow;
10515|  25.9k|    return window->ContentRegionRect.Max - window->Pos;
10516|  25.9k|}
_ZN5ImGui14ScrollToRectExEP11ImGuiWindowRK6ImRecti:
10673|     59|{
10674|     59|    ImGuiContext& g = *GImGui;
10675|     59|    ImRect scroll_rect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1));
10676|     59|    scroll_rect.Min.x = ImMin(scroll_rect.Min.x + window->DecoInnerSizeX1, scroll_rect.Max.x);
10677|     59|    scroll_rect.Min.y = ImMin(scroll_rect.Min.y + window->DecoInnerSizeY1, scroll_rect.Max.y);
10678|       |    //GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max, IM_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
10679|       |    //GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max, IM_COL32_WHITE); // [DEBUG]
10680|       |
10681|       |    // Check that only one behavior is selected per axis
10682|     59|    IM_ASSERT((flags & ImGuiScrollFlags_MaskX_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskX_));
  ------------------
  |  |   23|     59|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10683|     59|    IM_ASSERT((flags & ImGuiScrollFlags_MaskY_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskY_));
  ------------------
  |  |   23|     59|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10684|       |
10685|       |    // Defaults
10686|     59|    ImGuiScrollFlags in_flags = flags;
10687|     59|    if ((flags & ImGuiScrollFlags_MaskX_) == 0 && window->ScrollbarX)
  ------------------
  |  Branch (10687:9): [True: 26, False: 33]
  |  Branch (10687:51): [True: 0, False: 26]
  ------------------
10688|      0|        flags |= ImGuiScrollFlags_KeepVisibleEdgeX;
10689|     59|    if ((flags & ImGuiScrollFlags_MaskY_) == 0)
  ------------------
  |  Branch (10689:9): [True: 26, False: 33]
  ------------------
10690|     26|        flags |= window->Appearing ? ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeY;
  ------------------
  |  Branch (10690:18): [True: 0, False: 26]
  ------------------
10691|       |
10692|     59|    const bool fully_visible_x = item_rect.Min.x >= scroll_rect.Min.x && item_rect.Max.x <= scroll_rect.Max.x;
  ------------------
  |  Branch (10692:34): [True: 59, False: 0]
  |  Branch (10692:74): [True: 59, False: 0]
  ------------------
10693|     59|    const bool fully_visible_y = item_rect.Min.y >= scroll_rect.Min.y && item_rect.Max.y <= scroll_rect.Max.y;
  ------------------
  |  Branch (10693:34): [True: 59, False: 0]
  |  Branch (10693:74): [True: 58, False: 1]
  ------------------
10694|     59|    const bool can_be_fully_visible_x = (item_rect.GetWidth() + g.Style.ItemSpacing.x * 2.0f) <= scroll_rect.GetWidth() || (window->AutoFitFramesX > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;
  ------------------
  |  Branch (10694:41): [True: 59, False: 0]
  |  Branch (10694:124): [True: 0, False: 0]
  |  Branch (10694:156): [True: 0, False: 0]
  ------------------
10695|     59|    const bool can_be_fully_visible_y = (item_rect.GetHeight() + g.Style.ItemSpacing.y * 2.0f) <= scroll_rect.GetHeight() || (window->AutoFitFramesY > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;
  ------------------
  |  Branch (10695:41): [True: 58, False: 1]
  |  Branch (10695:126): [True: 0, False: 1]
  |  Branch (10695:158): [True: 0, False: 1]
  ------------------
10696|       |
10697|     59|    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeX) && !fully_visible_x)
  ------------------
  |  Branch (10697:9): [True: 33, False: 26]
  |  Branch (10697:56): [True: 0, False: 33]
  ------------------
10698|      0|    {
10699|      0|        if (item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x)
  ------------------
  |  Branch (10699:13): [True: 0, False: 0]
  |  Branch (10699:52): [True: 0, False: 0]
  ------------------
10700|      0|            SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window->Pos.x, 0.0f);
10701|      0|        else if (item_rect.Max.x >= scroll_rect.Max.x)
  ------------------
  |  Branch (10701:18): [True: 0, False: 0]
  ------------------
10702|      0|            SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window->Pos.x, 1.0f);
10703|      0|    }
10704|     59|    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterX) && !fully_visible_x) || (flags & ImGuiScrollFlags_AlwaysCenterX))
  ------------------
  |  Branch (10704:15): [True: 0, False: 59]
  |  Branch (10704:64): [True: 0, False: 0]
  |  Branch (10704:85): [True: 0, False: 59]
  ------------------
10705|      0|    {
10706|      0|        if (can_be_fully_visible_x)
  ------------------
  |  Branch (10706:13): [True: 0, False: 0]
  ------------------
10707|      0|            SetScrollFromPosX(window, ImTrunc((item_rect.Min.x + item_rect.Max.x) * 0.5f) - window->Pos.x, 0.5f);
10708|      0|        else
10709|      0|            SetScrollFromPosX(window, item_rect.Min.x - window->Pos.x, 0.0f);
10710|      0|    }
10711|       |
10712|     59|    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeY) && !fully_visible_y)
  ------------------
  |  Branch (10712:9): [True: 59, False: 0]
  |  Branch (10712:56): [True: 1, False: 58]
  ------------------
10713|      1|    {
10714|      1|        if (item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y)
  ------------------
  |  Branch (10714:13): [True: 0, False: 1]
  |  Branch (10714:52): [True: 1, False: 0]
  ------------------
10715|      1|            SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window->Pos.y, 0.0f);
10716|      0|        else if (item_rect.Max.y >= scroll_rect.Max.y)
  ------------------
  |  Branch (10716:18): [True: 0, False: 0]
  ------------------
10717|      0|            SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window->Pos.y, 1.0f);
10718|      1|    }
10719|     58|    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterY) && !fully_visible_y) || (flags & ImGuiScrollFlags_AlwaysCenterY))
  ------------------
  |  Branch (10719:15): [True: 0, False: 58]
  |  Branch (10719:64): [True: 0, False: 0]
  |  Branch (10719:85): [True: 0, False: 58]
  ------------------
10720|      0|    {
10721|      0|        if (can_be_fully_visible_y)
  ------------------
  |  Branch (10721:13): [True: 0, False: 0]
  ------------------
10722|      0|            SetScrollFromPosY(window, ImTrunc((item_rect.Min.y + item_rect.Max.y) * 0.5f) - window->Pos.y, 0.5f);
10723|      0|        else
10724|      0|            SetScrollFromPosY(window, item_rect.Min.y - window->Pos.y, 0.0f);
10725|      0|    }
10726|       |
10727|     59|    ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
10728|     59|    ImVec2 delta_scroll = next_scroll - window->Scroll;
10729|       |
10730|       |    // Also scroll parent window to keep us into view if necessary
10731|     59|    if (!(flags & ImGuiScrollFlags_NoScrollParent) && (window->Flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (10731:9): [True: 59, False: 0]
  |  Branch (10731:55): [True: 0, False: 59]
  ------------------
10732|      0|    {
10733|       |        // FIXME-SCROLL: May be an option?
10734|      0|        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_KeepVisibleCenterX)) != 0)
  ------------------
  |  Branch (10734:13): [True: 0, False: 0]
  ------------------
10735|      0|            in_flags = (in_flags & ~ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_KeepVisibleEdgeX;
10736|      0|        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_KeepVisibleCenterY)) != 0)
  ------------------
  |  Branch (10736:13): [True: 0, False: 0]
  ------------------
10737|      0|            in_flags = (in_flags & ~ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_KeepVisibleEdgeY;
10738|      0|        delta_scroll += ScrollToRectEx(window->ParentWindow, ImRect(item_rect.Min - delta_scroll, item_rect.Max - delta_scroll), in_flags);
10739|      0|    }
10740|       |
10741|     59|    return delta_scroll;
10742|     59|}
_ZN5ImGui10GetScrollXEv:
10745|  36.8k|{
10746|  36.8k|    ImGuiWindow* window = GImGui->CurrentWindow;
10747|  36.8k|    return window->Scroll.x;
10748|  36.8k|}
_ZN5ImGui10GetScrollYEv:
10751|  36.8k|{
10752|  36.8k|    ImGuiWindow* window = GImGui->CurrentWindow;
10753|  36.8k|    return window->Scroll.y;
10754|  36.8k|}
_ZN5ImGui10SetScrollXEP11ImGuiWindowf:
10769|  11.8k|{
10770|  11.8k|    window->ScrollTarget.x = scroll_x;
10771|  11.8k|    window->ScrollTargetCenterRatio.x = 0.0f;
10772|  11.8k|    window->ScrollTargetEdgeSnapDist.x = 0.0f;
10773|  11.8k|}
_ZN5ImGui10SetScrollYEP11ImGuiWindowf:
10776|  10.9k|{
10777|  10.9k|    window->ScrollTarget.y = scroll_y;
10778|  10.9k|    window->ScrollTargetCenterRatio.y = 0.0f;
10779|  10.9k|    window->ScrollTargetEdgeSnapDist.y = 0.0f;
10780|  10.9k|}
_ZN5ImGui10SetScrollXEf:
10783|  10.6k|{
10784|  10.6k|    ImGuiContext& g = *GImGui;
10785|  10.6k|    SetScrollX(g.CurrentWindow, scroll_x);
10786|  10.6k|}
_ZN5ImGui10SetScrollYEf:
10789|  9.60k|{
10790|  9.60k|    ImGuiContext& g = *GImGui;
10791|  9.60k|    SetScrollY(g.CurrentWindow, scroll_y);
10792|  9.60k|}
_ZN5ImGui17SetScrollFromPosYEP11ImGuiWindowff:
10813|      1|{
10814|      1|    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10815|      1|    window->ScrollTarget.y = IM_TRUNC(local_y - window->DecoOuterSizeY1 - window->DecoInnerSizeY1 + window->Scroll.y); // Convert local position to scroll offset
  ------------------
  |  |  284|      1|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
10816|      1|    window->ScrollTargetCenterRatio.y = center_y_ratio;
10817|      1|    window->ScrollTargetEdgeSnapDist.y = 0.0f;
10818|      1|}
_ZN5ImGui12BeginTooltipEv:
10863|     17|{
10864|     17|    return BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
10865|     17|}
_ZN5ImGui14BeginTooltipExEii:
10875|     17|{
10876|     17|    ImGuiContext& g = *GImGui;
10877|       |
10878|     17|    if (g.DragDropWithinSource || g.DragDropWithinTarget)
  ------------------
  |  Branch (10878:9): [True: 0, False: 17]
  |  Branch (10878:35): [True: 0, False: 17]
  ------------------
10879|      0|    {
10880|       |        // Drag and Drop tooltips are positioning differently than other tooltips:
10881|       |        // - offset visibility to increase visibility around mouse.
10882|       |        // - never clamp within outer viewport boundary.
10883|       |        // We call SetNextWindowPos() to enforce position and disable clamping.
10884|       |        // See FindBestWindowPosForPopup() for positionning logic of other tooltips (not drag and drop ones).
10885|       |        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
10886|      0|        ImVec2 tooltip_pos = g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET * g.Style.MouseCursorScale;
10887|      0|        SetNextWindowPos(tooltip_pos);
10888|      0|        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
10889|       |        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
10890|      0|        tooltip_flags |= ImGuiTooltipFlags_OverridePrevious;
10891|      0|    }
10892|       |
10893|     17|    char window_name[16];
10894|     17|    ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);
  ------------------
  |  |   88|     17|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
10895|     17|    if (tooltip_flags & ImGuiTooltipFlags_OverridePrevious)
  ------------------
  |  Branch (10895:9): [True: 0, False: 17]
  ------------------
10896|      0|        if (ImGuiWindow* window = FindWindowByName(window_name))
  ------------------
  |  Branch (10896:26): [True: 0, False: 0]
  ------------------
10897|      0|            if (window->Active)
  ------------------
  |  Branch (10897:17): [True: 0, False: 0]
  ------------------
10898|      0|            {
10899|       |                // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
10900|      0|                SetWindowHiddendAndSkipItemsForCurrentFrame(window);
10901|      0|                ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
  ------------------
  |  |   88|      0|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
10902|      0|            }
10903|     17|    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDocking;
10904|     17|    Begin(window_name, NULL, flags | extra_window_flags);
10905|       |    // 2023-03-09: Added bool return value to the API, but currently always returning true.
10906|       |    // If this ever returns false we need to update BeginDragDropSource() accordingly.
10907|       |    //if (!ret)
10908|       |    //    End();
10909|       |    //return ret;
10910|     17|    return true;
10911|     17|}
_ZN5ImGui10EndTooltipEv:
10914|     17|{
10915|     17|    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
  ------------------
  |  |   23|     17|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10916|     17|    End();
10917|     17|}
_ZN5ImGui20GetTopMostPopupModalEv:
11000|  88.2k|{
11001|  88.2k|    ImGuiContext& g = *GImGui;
11002|  88.2k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (11002:45): [True: 0, False: 88.2k]
  ------------------
11003|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (11003:26): [True: 0, False: 0]
  ------------------
11004|      0|            if (popup->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (11004:17): [True: 0, False: 0]
  ------------------
11005|      0|                return popup;
11006|  88.2k|    return NULL;
11007|  88.2k|}
_ZN5ImGui30GetTopMostAndVisiblePopupModalEv:
11011|  29.3k|{
11012|  29.3k|    ImGuiContext& g = *GImGui;
11013|  29.3k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (11013:45): [True: 0, False: 29.3k]
  ------------------
11014|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (11014:26): [True: 0, False: 0]
  ------------------
11015|      0|            if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
  ------------------
  |  Branch (11015:17): [True: 0, False: 0]
  |  Branch (11015:60): [True: 0, False: 0]
  ------------------
11016|      0|                return popup;
11017|  29.3k|    return NULL;
11018|  29.3k|}
_ZN5ImGui21ClosePopupsOverWindowEP11ImGuiWindowb:
11087|  6.26k|{
11088|  6.26k|    ImGuiContext& g = *GImGui;
11089|  6.26k|    if (g.OpenPopupStack.Size == 0)
  ------------------
  |  Branch (11089:9): [True: 6.26k, False: 0]
  ------------------
11090|  6.26k|        return;
11091|       |
11092|       |    // Don't close our own child popup windows.
11093|      0|    int popup_count_to_keep = 0;
11094|      0|    if (ref_window)
  ------------------
  |  Branch (11094:9): [True: 0, False: 0]
  ------------------
11095|      0|    {
11096|       |        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
11097|      0|        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
  ------------------
  |  Branch (11097:16): [True: 0, False: 0]
  ------------------
11098|      0|        {
11099|      0|            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
11100|      0|            if (!popup.Window)
  ------------------
  |  Branch (11100:17): [True: 0, False: 0]
  ------------------
11101|      0|                continue;
11102|      0|            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11103|      0|            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (11103:17): [True: 0, False: 0]
  ------------------
11104|      0|                continue;
11105|       |
11106|       |            // Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
11107|       |            // - With this stack of window, clicking/focusing Popup1 will close Popup2 and Popup3:
11108|       |            //     Window -> Popup1 -> Popup2 -> Popup3
11109|       |            // - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
11110|       |            //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
11111|      0|            bool ref_window_is_descendent_of_popup = false;
11112|      0|            for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
  ------------------
  |  Branch (11112:47): [True: 0, False: 0]
  ------------------
11113|      0|                if (ImGuiWindow* popup_window = g.OpenPopupStack[n].Window)
  ------------------
  |  Branch (11113:34): [True: 0, False: 0]
  ------------------
11114|       |                    //if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree) // FIXME-MERGE
11115|      0|                    if (IsWindowWithinBeginStackOf(ref_window, popup_window))
  ------------------
  |  Branch (11115:25): [True: 0, False: 0]
  ------------------
11116|      0|                    {
11117|      0|                        ref_window_is_descendent_of_popup = true;
11118|      0|                        break;
11119|      0|                    }
11120|      0|            if (!ref_window_is_descendent_of_popup)
  ------------------
  |  Branch (11120:17): [True: 0, False: 0]
  ------------------
11121|      0|                break;
11122|      0|        }
11123|      0|    }
11124|      0|    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
  ------------------
  |  Branch (11124:9): [True: 0, False: 0]
  ------------------
11125|      0|    {
11126|      0|        IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
  ------------------
  |  |  245|      0|#define IMGUI_DEBUG_LOG_POPUP(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (245:50): [True: 0, False: 0]
  |  |  |  Branch (245:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11127|      0|        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
11128|      0|    }
11129|      0|}
_ZN5ImGui27FindBestWindowPosForPopupExERK6ImVec2S2_PiRK6ImRectS6_24ImGuiPopupPositionPolicy:
11367|     17|{
11368|     17|    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
11369|       |    //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
11370|       |    //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));
11371|       |
11372|       |    // Combo Box policy (we want a connecting edge)
11373|     17|    if (policy == ImGuiPopupPositionPolicy_ComboBox)
  ------------------
  |  Branch (11373:9): [True: 0, False: 17]
  ------------------
11374|      0|    {
11375|      0|        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
11376|      0|        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
  ------------------
  |  Branch (11376:22): [True: 0, False: 0]
  |  Branch (11376:61): [True: 0, False: 0]
  ------------------
11377|      0|        {
11378|      0|            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
  ------------------
  |  Branch (11378:34): [True: 0, False: 0]
  ------------------
11379|      0|            if (n != -1 && dir == *last_dir) // Already tried this direction?
  ------------------
  |  Branch (11379:17): [True: 0, False: 0]
  |  Branch (11379:28): [True: 0, False: 0]
  ------------------
11380|      0|                continue;
11381|      0|            ImVec2 pos;
11382|      0|            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
  ------------------
  |  Branch (11382:17): [True: 0, False: 0]
  ------------------
11383|      0|            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
  ------------------
  |  Branch (11383:17): [True: 0, False: 0]
  ------------------
11384|      0|            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
  ------------------
  |  Branch (11384:17): [True: 0, False: 0]
  ------------------
11385|      0|            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
  ------------------
  |  Branch (11385:17): [True: 0, False: 0]
  ------------------
11386|      0|            if (!r_outer.Contains(ImRect(pos, pos + size)))
  ------------------
  |  Branch (11386:17): [True: 0, False: 0]
  ------------------
11387|      0|                continue;
11388|      0|            *last_dir = dir;
11389|      0|            return pos;
11390|      0|        }
11391|      0|    }
11392|       |
11393|       |    // Tooltip and Default popup policy
11394|       |    // (Always first try the direction we used on the last frame, if any)
11395|     17|    if (policy == ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy_Default)
  ------------------
  |  Branch (11395:9): [True: 17, False: 0]
  |  Branch (11395:55): [True: 0, False: 0]
  ------------------
11396|     17|    {
11397|     17|        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
11398|     17|        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
  ------------------
  |  Branch (11398:22): [True: 7, False: 10]
  |  Branch (11398:61): [True: 17, False: 0]
  ------------------
11399|     17|        {
11400|     17|            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
  ------------------
  |  Branch (11400:34): [True: 7, False: 10]
  ------------------
11401|     17|            if (n != -1 && dir == *last_dir) // Already tried this direction?
  ------------------
  |  Branch (11401:17): [True: 10, False: 7]
  |  Branch (11401:28): [True: 0, False: 10]
  ------------------
11402|      0|                continue;
11403|       |
11404|     17|            const float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
  ------------------
  |  Branch (11404:36): [True: 0, False: 17]
  |  Branch (11404:93): [True: 17, False: 0]
  ------------------
11405|     17|            const float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);
  ------------------
  |  Branch (11405:36): [True: 0, False: 17]
  |  Branch (11405:91): [True: 0, False: 17]
  ------------------
11406|       |
11407|       |            // If there's not enough room on one axis, there's no point in positioning on a side on this axis (e.g. when not enough width, use a top/bottom position to maximize available width)
11408|     17|            if (avail_w < size.x && (dir == ImGuiDir_Left || dir == ImGuiDir_Right))
  ------------------
  |  Branch (11408:17): [True: 0, False: 17]
  |  Branch (11408:38): [True: 0, False: 0]
  |  Branch (11408:62): [True: 0, False: 0]
  ------------------
11409|      0|                continue;
11410|     17|            if (avail_h < size.y && (dir == ImGuiDir_Up || dir == ImGuiDir_Down))
  ------------------
  |  Branch (11410:17): [True: 0, False: 17]
  |  Branch (11410:38): [True: 0, False: 0]
  |  Branch (11410:60): [True: 0, False: 0]
  ------------------
11411|      0|                continue;
11412|       |
11413|     17|            ImVec2 pos;
11414|     17|            pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
  ------------------
  |  Branch (11414:21): [True: 0, False: 17]
  |  Branch (11414:71): [True: 17, False: 0]
  ------------------
11415|     17|            pos.y = (dir == ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y;
  ------------------
  |  Branch (11415:21): [True: 0, False: 17]
  |  Branch (11415:69): [True: 0, False: 17]
  ------------------
11416|       |
11417|       |            // Clamp top-left corner of popup
11418|     17|            pos.x = ImMax(pos.x, r_outer.Min.x);
11419|     17|            pos.y = ImMax(pos.y, r_outer.Min.y);
11420|       |
11421|     17|            *last_dir = dir;
11422|     17|            return pos;
11423|     17|        }
11424|     17|    }
11425|       |
11426|       |    // Fallback when not enough room:
11427|      0|    *last_dir = ImGuiDir_None;
11428|       |
11429|       |    // For tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
11430|      0|    if (policy == ImGuiPopupPositionPolicy_Tooltip)
  ------------------
  |  Branch (11430:9): [True: 0, False: 0]
  ------------------
11431|      0|        return ref_pos + ImVec2(2, 2);
11432|       |
11433|       |    // Otherwise try to keep within display
11434|      0|    ImVec2 pos = ref_pos;
11435|      0|    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
11436|      0|    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
11437|      0|    return pos;
11438|      0|}
_ZN5ImGui25GetPopupAllowedExtentRectEP11ImGuiWindow:
11442|     17|{
11443|     17|    ImGuiContext& g = *GImGui;
11444|     17|    ImRect r_screen;
11445|     17|    if (window->ViewportAllowPlatformMonitorExtend >= 0)
  ------------------
  |  Branch (11445:9): [True: 0, False: 17]
  ------------------
11446|      0|    {
11447|       |        // Extent with be in the frame of reference of the given viewport (so Min is likely to be negative here)
11448|      0|        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[window->ViewportAllowPlatformMonitorExtend];
11449|      0|        r_screen.Min = monitor.WorkPos;
11450|      0|        r_screen.Max = monitor.WorkPos + monitor.WorkSize;
11451|      0|    }
11452|     17|    else
11453|     17|    {
11454|       |        // Use the full viewport area (not work area) for popups
11455|     17|        r_screen = window->Viewport->GetMainRect();
11456|     17|    }
11457|     17|    ImVec2 padding = g.Style.DisplaySafeAreaPadding;
11458|     17|    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
  ------------------
  |  Branch (11458:28): [True: 17, False: 0]
  |  Branch (11458:87): [True: 17, False: 0]
  ------------------
11459|     17|    return r_screen;
11460|     17|}
_ZN5ImGui25FindBestWindowPosForPopupEP11ImGuiWindow:
11463|     17|{
11464|     17|    ImGuiContext& g = *GImGui;
11465|       |
11466|     17|    ImRect r_outer = GetPopupAllowedExtentRect(window);
11467|     17|    if (window->Flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (11467:9): [True: 0, False: 17]
  ------------------
11468|      0|    {
11469|       |        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
11470|       |        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
11471|      0|        ImGuiWindow* parent_window = window->ParentWindow;
11472|      0|        float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
11473|      0|        ImRect r_avoid;
11474|      0|        if (parent_window->DC.MenuBarAppending)
  ------------------
  |  Branch (11474:13): [True: 0, False: 0]
  ------------------
11475|      0|            r_avoid = ImRect(-FLT_MAX, parent_window->ClipRect.Min.y, FLT_MAX, parent_window->ClipRect.Max.y); // Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
11476|      0|        else
11477|      0|            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
11478|      0|        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Default);
11479|      0|    }
11480|     17|    if (window->Flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (11480:9): [True: 0, False: 17]
  ------------------
11481|      0|    {
11482|      0|        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, ImRect(window->Pos, window->Pos), ImGuiPopupPositionPolicy_Default); // Ideally we'd disable r_avoid here
11483|      0|    }
11484|     17|    if (window->Flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (11484:9): [True: 17, False: 0]
  ------------------
11485|     17|    {
11486|       |        // Position tooltip (always follows mouse + clamp within outer boundaries)
11487|       |        // Note that drag and drop tooltips are NOT using this path: BeginTooltipEx() manually sets their position.
11488|       |        // In theory we could handle both cases in same location, but requires a bit of shuffling as drag and drop tooltips are calling SetWindowPos() leading to 'window_pos_set_by_api' being set in Begin()
11489|     17|        IM_ASSERT(g.CurrentWindow == window);
  ------------------
  |  |   23|     17|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11490|     17|        const float scale = g.Style.MouseCursorScale;
11491|     17|        const ImVec2 ref_pos = NavCalcPreferredRefPos();
11492|     17|        const ImVec2 tooltip_pos = ref_pos + TOOLTIP_DEFAULT_OFFSET * scale;
11493|     17|        ImRect r_avoid;
11494|     17|        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
  ------------------
  |  Branch (11494:13): [True: 15, False: 2]
  |  Branch (11494:39): [True: 0, False: 15]
  |  Branch (11494:65): [True: 0, False: 0]
  ------------------
11495|      0|            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
11496|     17|        else
11497|     17|            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * scale, ref_pos.y + 24 * scale); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
11498|       |        //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255, 0, 255, 255));
11499|     17|        return FindBestWindowPosForPopupEx(tooltip_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Tooltip);
11500|     17|    }
11501|      0|    IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11502|      0|    return window->Pos;
11503|     17|}
_ZN5ImGui12SetNavWindowEP11ImGuiWindow:
11514|  6.15k|{
11515|  6.15k|    ImGuiContext& g = *GImGui;
11516|  6.15k|    if (g.NavWindow != window)
  ------------------
  |  Branch (11516:9): [True: 6.15k, False: 0]
  ------------------
11517|  6.15k|    {
11518|  6.15k|        IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
  ------------------
  |  |  244|  6.15k|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (244:50): [True: 0, False: 6.15k]
  |  |  |  Branch (244:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11519|  6.15k|        g.NavWindow = window;
11520|  6.15k|        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1681|  6.15k|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
11521|  6.15k|    }
11522|  6.15k|    g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11523|  6.15k|    NavUpdateAnyRequestFlag();
11524|  6.15k|}
_ZN5ImGui27NavClearPreferredPosForAxisE9ImGuiAxis:
11527|  3.45k|{
11528|  3.45k|    ImGuiContext& g = *GImGui;
11529|  3.45k|    g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;
11530|  3.45k|}
_ZN5ImGui8SetNavIDEj13ImGuiNavLayerjRK6ImRect:
11533|    375|{
11534|    375|    ImGuiContext& g = *GImGui;
11535|    375|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|    375|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11536|    375|    IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|    375|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11537|    375|    g.NavId = id;
11538|    375|    g.NavLayer = nav_layer;
11539|    375|    g.NavFocusScopeId = focus_scope_id;
11540|    375|    g.NavWindow->NavLastIds[nav_layer] = id;
11541|    375|    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
11542|       |
11543|       |    // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
11544|    375|    NavClearPreferredPosForAxis(ImGuiAxis_X);
11545|    375|    NavClearPreferredPosForAxis(ImGuiAxis_Y);
11546|    375|}
_ZN5ImGui39NavUpdateCurrentWindowIsScrollPushableXEv:
11750|   140k|{
11751|   140k|    ImGuiContext& g = *GImGui;
11752|   140k|    ImGuiWindow* window = g.CurrentWindow;
11753|   140k|    window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);
  ------------------
  |  Branch (11753:40): [True: 140k, False: 0]
  |  Branch (11753:66): [True: 140k, False: 0]
  ------------------
11754|   140k|}
_ZN5ImGui28NavMoveRequestButNoResultYetEv:
11893|  21.1k|{
11894|  21.1k|    ImGuiContext& g = *GImGui;
11895|  21.1k|    return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
  ------------------
  |  Branch (11895:12): [True: 2.92k, False: 18.2k]
  |  Branch (11895:37): [True: 2.89k, False: 34]
  |  Branch (11895:69): [True: 2.89k, False: 0]
  ------------------
11896|  21.1k|}
_ZN5ImGui20NavMoveRequestSubmitEiiii:
11900|  3.00k|{
11901|  3.00k|    ImGuiContext& g = *GImGui;
11902|  3.00k|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|  3.00k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11903|       |
11904|  3.00k|    if (move_flags & ImGuiNavMoveFlags_IsTabbing)
  ------------------
  |  Branch (11904:9): [True: 409, False: 2.59k]
  ------------------
11905|    409|        move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;
11906|       |
11907|  3.00k|    g.NavMoveSubmitted = g.NavMoveScoringItems = true;
11908|  3.00k|    g.NavMoveDir = move_dir;
11909|  3.00k|    g.NavMoveDirForDebug = move_dir;
11910|  3.00k|    g.NavMoveClipDir = clip_dir;
11911|  3.00k|    g.NavMoveFlags = move_flags;
11912|  3.00k|    g.NavMoveScrollFlags = scroll_flags;
11913|  3.00k|    g.NavMoveForwardToNextFrame = false;
11914|  3.00k|    g.NavMoveKeyMods = g.IO.KeyMods;
11915|  3.00k|    g.NavMoveResultLocal.Clear();
11916|  3.00k|    g.NavMoveResultLocalVisible.Clear();
11917|  3.00k|    g.NavMoveResultOther.Clear();
11918|  3.00k|    g.NavTabbingCounter = 0;
11919|  3.00k|    g.NavTabbingResultFirst.Clear();
11920|  3.00k|    NavUpdateAnyRequestFlag();
11921|  3.00k|}
_ZN5ImGui20NavMoveRequestCancelEv:
11945|     59|{
11946|     59|    ImGuiContext& g = *GImGui;
11947|     59|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11948|     59|    NavUpdateAnyRequestFlag();
11949|     59|}
_ZN5ImGui28NavRestoreHighlightAfterMoveEv:
12024|    467|{
12025|    467|    ImGuiContext& g = *GImGui;
12026|    467|    g.NavDisableHighlight = false;
12027|    467|    g.NavDisableMouseHover = g.NavMousePosDirty = true;
12028|    467|}
_ZN5ImGui13NavInitWindowEP11ImGuiWindowb:
12040|     21|{
12041|       |    // FIXME: ChildWindow test here is wrong for docking
12042|     21|    ImGuiContext& g = *GImGui;
12043|     21|    IM_ASSERT(window == g.NavWindow);
  ------------------
  |  |   23|     21|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12044|       |
12045|     21|    if (window->Flags & ImGuiWindowFlags_NoNavInputs)
  ------------------
  |  Branch (12045:9): [True: 0, False: 21]
  ------------------
12046|      0|    {
12047|      0|        g.NavId = 0;
12048|      0|        g.NavFocusScopeId = window->NavRootFocusScopeId;
12049|      0|        return;
12050|      0|    }
12051|       |
12052|     21|    bool init_for_nav = false;
12053|     21|    if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
  ------------------
  |  Branch (12053:9): [True: 2, False: 19]
  |  Branch (12053:41): [True: 0, False: 19]
  |  Branch (12053:85): [True: 19, False: 0]
  |  Branch (12053:117): [True: 0, False: 0]
  ------------------
12054|     21|        init_for_nav = true;
12055|     21|    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
  ------------------
  |  |  246|     21|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 21]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12056|     21|    if (init_for_nav)
  ------------------
  |  Branch (12056:9): [True: 21, False: 0]
  ------------------
12057|     21|    {
12058|     21|        SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
12059|     21|        g.NavInitRequest = true;
12060|     21|        g.NavInitRequestFromMove = false;
12061|     21|        g.NavInitResult.ID = 0;
12062|     21|        NavUpdateAnyRequestFlag();
12063|     21|    }
12064|      0|    else
12065|      0|    {
12066|      0|        g.NavId = window->NavLastIds[0];
12067|      0|        g.NavFocusScopeId = window->NavRootFocusScopeId;
12068|      0|    }
12069|     21|}
_ZN5ImGui25NavInitRequestApplyResultEv:
12281|     11|{
12282|       |    // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
12283|     11|    ImGuiContext& g = *GImGui;
12284|     11|    if (!g.NavWindow)
  ------------------
  |  Branch (12284:9): [True: 1, False: 10]
  ------------------
12285|      1|        return;
12286|       |
12287|     10|    ImGuiNavItemData* result = &g.NavInitResult;
12288|     10|    if (g.NavId != result->ID)
  ------------------
  |  Branch (12288:9): [True: 10, False: 0]
  ------------------
12289|     10|    {
12290|     10|        g.NavJustMovedToId = result->ID;
12291|     10|        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
12292|     10|        g.NavJustMovedToKeyMods = 0;
12293|     10|    }
12294|       |
12295|       |    // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
12296|       |    // FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
12297|     10|    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
  ------------------
  |  |  246|     10|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 10]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12298|     10|    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
12299|     10|    g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
12300|     10|    if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
  ------------------
  |  | 1681|     10|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
  |  Branch (12300:9): [True: 0, False: 10]
  ------------------
12301|      0|        g.NavLastValidSelectionUserData = result->SelectionUserData;
12302|     10|    if (g.NavInitRequestFromMove)
  ------------------
  |  Branch (12302:9): [True: 10, False: 0]
  ------------------
12303|     10|        NavRestoreHighlightAfterMove();
12304|     10|}
_ZN5ImGui25NavMoveRequestApplyResultEv:
12476|  2.76k|{
12477|  2.76k|    ImGuiContext& g = *GImGui;
12478|       |#if IMGUI_DEBUG_NAV_SCORING
12479|       |    if (g.NavMoveFlags & ImGuiNavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items in NavWindow at all times
12480|       |        return;
12481|       |#endif
12482|       |
12483|       |    // Select which result to use
12484|  2.76k|    ImGuiNavItemData* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : NULL;
  ------------------
  |  Branch (12484:32): [True: 26, False: 2.73k]
  |  Branch (12484:89): [True: 0, False: 2.73k]
  ------------------
12485|       |
12486|       |    // Tabbing forward wrap
12487|  2.76k|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && result == NULL)
  ------------------
  |  Branch (12487:9): [True: 334, False: 2.43k]
  |  Branch (12487:59): [True: 334, False: 0]
  ------------------
12488|    334|        if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID)
  ------------------
  |  Branch (12488:14): [True: 33, False: 301]
  |  Branch (12488:42): [True: 8, False: 293]
  |  Branch (12488:67): [True: 33, False: 8]
  ------------------
12489|     33|            result = &g.NavTabbingResultFirst;
12490|       |
12491|       |    // In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
12492|  2.76k|    const ImGuiAxis axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
  ------------------
  |  Branch (12492:29): [True: 1.03k, False: 1.72k]
  |  Branch (12492:60): [True: 129, False: 1.59k]
  ------------------
12493|  2.76k|    if (result == NULL)
  ------------------
  |  Branch (12493:9): [True: 2.70k, False: 59]
  ------------------
12494|  2.70k|    {
12495|  2.70k|        if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
  ------------------
  |  Branch (12495:13): [True: 301, False: 2.40k]
  ------------------
12496|    301|            g.NavMoveFlags |= ImGuiNavMoveFlags_NoSetNavHighlight;
12497|  2.70k|        if (g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavHighlight) == 0)
  ------------------
  |  Branch (12497:13): [True: 116, False: 2.59k]
  |  Branch (12497:29): [True: 113, False: 3]
  ------------------
12498|    113|            NavRestoreHighlightAfterMove();
12499|  2.70k|        NavClearPreferredPosForAxis(axis); // On a failed move, clear preferred pos for this axis.
12500|  2.70k|        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveSubmitted but not led to a result!\n");
  ------------------
  |  |  246|  2.70k|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 2.70k]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12501|  2.70k|        return;
12502|  2.70k|    }
12503|       |
12504|       |    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
12505|     59|    if (g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
  ------------------
  |  Branch (12505:9): [True: 20, False: 39]
  ------------------
12506|     20|        if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId)
  ------------------
  |  Branch (12506:13): [True: 6, False: 14]
  |  Branch (12506:52): [True: 0, False: 6]
  ------------------
12507|      0|            result = &g.NavMoveResultLocalVisible;
12508|       |
12509|       |    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
12510|     59|    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (12510:9): [True: 59, False: 0]
  |  Branch (12510:44): [True: 0, False: 59]
  |  Branch (12510:76): [True: 0, False: 0]
  ------------------
12511|      0|        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
  ------------------
  |  Branch (12511:13): [True: 0, False: 0]
  |  Branch (12511:66): [True: 0, False: 0]
  |  Branch (12511:117): [True: 0, False: 0]
  ------------------
12512|      0|            result = &g.NavMoveResultOther;
12513|     59|    IM_ASSERT(g.NavWindow && result->Window);
  ------------------
  |  |   23|     59|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12514|       |
12515|       |    // Scroll to keep newly navigated item fully into view.
12516|     59|    if (g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (12516:9): [True: 59, False: 0]
  ------------------
12517|     59|    {
12518|     59|        ImRect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
12519|     59|        ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);
12520|       |
12521|     59|        if (g.NavMoveFlags & ImGuiNavMoveFlags_ScrollToEdgeY)
  ------------------
  |  Branch (12521:13): [True: 0, False: 59]
  ------------------
12522|      0|        {
12523|       |            // FIXME: Should remove this? Or make more precise: use ScrollToRectEx() with edge?
12524|      0|            float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
  ------------------
  |  Branch (12524:35): [True: 0, False: 0]
  ------------------
12525|      0|            SetScrollY(result->Window, scroll_target);
12526|      0|        }
12527|     59|    }
12528|       |
12529|     59|    if (g.NavWindow != result->Window)
  ------------------
  |  Branch (12529:9): [True: 0, False: 59]
  ------------------
12530|      0|    {
12531|      0|        IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result->Window->Name);
  ------------------
  |  |  244|      0|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (244:50): [True: 0, False: 0]
  |  |  |  Branch (244:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12532|      0|        g.NavWindow = result->Window;
12533|      0|        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1681|      0|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
12534|      0|    }
12535|     59|    if (g.ActiveId != result->ID)
  ------------------
  |  Branch (12535:9): [True: 59, False: 0]
  ------------------
12536|     59|        ClearActiveID();
12537|       |
12538|       |    // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
12539|       |    // PageUp/PageDown however sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking Windows behavior.
12540|     59|    if ((g.NavId != result->ID || (g.NavMoveFlags & ImGuiNavMoveFlags_IsPageMove)) && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSelect) == 0)
  ------------------
  |  Branch (12540:10): [True: 0, False: 59]
  |  Branch (12540:35): [True: 20, False: 39]
  |  Branch (12540:87): [True: 20, False: 0]
  ------------------
12541|     20|    {
12542|     20|        g.NavJustMovedToId = result->ID;
12543|     20|        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
12544|     20|        g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
12545|     20|    }
12546|       |
12547|       |    // Apply new NavID/Focus
12548|     59|    IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
  ------------------
  |  |  246|     59|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 59]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12549|     59|    ImVec2 preferred_scoring_pos_rel = g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer];
12550|     59|    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
12551|     59|    if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
  ------------------
  |  | 1681|     59|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
  |  Branch (12551:9): [True: 0, False: 59]
  ------------------
12552|      0|        g.NavLastValidSelectionUserData = result->SelectionUserData;
12553|       |
12554|       |    // Restore last preferred position for current axis
12555|       |    // (storing in RootWindowForNav-> as the info is desirable at the beginning of a Move Request. In theory all storage should use RootWindowForNav..)
12556|     59|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) == 0)
  ------------------
  |  Branch (12556:9): [True: 26, False: 33]
  ------------------
12557|     26|    {
12558|     26|        preferred_scoring_pos_rel[axis] = result->RectRel.GetCenter()[axis];
12559|     26|        g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer] = preferred_scoring_pos_rel;
12560|     26|    }
12561|       |
12562|       |    // Tabbing: Activates Inputable, otherwise only Focus
12563|     59|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && (result->InFlags & ImGuiItemFlags_Inputable) == 0)
  ------------------
  |  Branch (12563:9): [True: 33, False: 26]
  |  Branch (12563:59): [True: 33, False: 0]
  ------------------
12564|     33|        g.NavMoveFlags &= ~ImGuiNavMoveFlags_Activate;
12565|       |
12566|       |    // Activate
12567|     59|    if (g.NavMoveFlags & ImGuiNavMoveFlags_Activate)
  ------------------
  |  Branch (12567:9): [True: 0, False: 59]
  ------------------
12568|      0|    {
12569|      0|        g.NavNextActivateId = result->ID;
12570|      0|        g.NavNextActivateFlags = ImGuiActivateFlags_None;
12571|      0|        if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
  ------------------
  |  Branch (12571:13): [True: 0, False: 0]
  ------------------
12572|      0|            g.NavNextActivateFlags |= ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState;
12573|      0|    }
12574|       |
12575|       |    // Enable nav highlight
12576|     59|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavHighlight) == 0)
  ------------------
  |  Branch (12576:9): [True: 59, False: 0]
  ------------------
12577|     59|        NavRestoreHighlightAfterMove();
12578|     59|}
_ZN5ImGui19BeginDragDropSourceEi:
13102|     21|{
13103|     21|    ImGuiContext& g = *GImGui;
13104|     21|    ImGuiWindow* window = g.CurrentWindow;
13105|       |
13106|       |    // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
13107|       |    // in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
13108|     21|    ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;
13109|       |
13110|     21|    bool source_drag_active = false;
13111|     21|    ImGuiID source_id = 0;
13112|     21|    ImGuiID source_parent_id = 0;
13113|     21|    if (!(flags & ImGuiDragDropFlags_SourceExtern))
  ------------------
  |  Branch (13113:9): [True: 21, False: 0]
  ------------------
13114|     21|    {
13115|     21|        source_id = g.LastItemData.ID;
13116|     21|        if (source_id != 0)
  ------------------
  |  Branch (13116:13): [True: 21, False: 0]
  ------------------
13117|     21|        {
13118|       |            // Common path: items with ID
13119|     21|            if (g.ActiveId != source_id)
  ------------------
  |  Branch (13119:17): [True: 0, False: 21]
  ------------------
13120|      0|                return false;
13121|     21|            if (g.ActiveIdMouseButton != -1)
  ------------------
  |  Branch (13121:17): [True: 0, False: 21]
  ------------------
13122|      0|                mouse_button = g.ActiveIdMouseButton;
13123|     21|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (13123:17): [True: 0, False: 21]
  |  Branch (13123:58): [True: 0, False: 21]
  ------------------
13124|      0|                return false;
13125|     21|            g.ActiveIdAllowOverlap = false;
13126|     21|        }
13127|      0|        else
13128|      0|        {
13129|       |            // Uncommon path: items without ID
13130|      0|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (13130:17): [True: 0, False: 0]
  |  Branch (13130:58): [True: 0, False: 0]
  ------------------
13131|      0|                return false;
13132|      0|            if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
  ------------------
  |  Branch (13132:17): [True: 0, False: 0]
  |  Branch (13132:90): [True: 0, False: 0]
  |  Branch (13132:109): [True: 0, False: 0]
  ------------------
13133|      0|                return false;
13134|       |
13135|       |            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
13136|       |            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
13137|      0|            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
  ------------------
  |  Branch (13137:17): [True: 0, False: 0]
  ------------------
13138|      0|            {
13139|      0|                IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13140|      0|                return false;
13141|      0|            }
13142|       |
13143|       |            // Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
13144|       |            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
13145|       |            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
13146|       |            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
13147|       |            // Rely on keeping other window->LastItemXXX fields intact.
13148|      0|            source_id = g.LastItemData.ID = window->GetIDFromRectangle(g.LastItemData.Rect);
13149|      0|            KeepAliveID(source_id);
13150|      0|            bool is_hovered = ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.InFlags);
13151|      0|            if (is_hovered && g.IO.MouseClicked[mouse_button])
  ------------------
  |  Branch (13151:17): [True: 0, False: 0]
  |  Branch (13151:31): [True: 0, False: 0]
  ------------------
13152|      0|            {
13153|      0|                SetActiveID(source_id, window);
13154|      0|                FocusWindow(window);
13155|      0|            }
13156|      0|            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
  ------------------
  |  Branch (13156:17): [True: 0, False: 0]
  ------------------
13157|      0|                g.ActiveIdAllowOverlap = is_hovered;
13158|      0|        }
13159|     21|        if (g.ActiveId != source_id)
  ------------------
  |  Branch (13159:13): [True: 0, False: 21]
  ------------------
13160|      0|            return false;
13161|     21|        source_parent_id = window->IDStack.back();
13162|     21|        source_drag_active = IsMouseDragging(mouse_button);
13163|       |
13164|       |        // Disable navigation and key inputs while dragging + cancel existing request if any
13165|     21|        SetActiveIdUsingAllKeyboardKeys();
13166|     21|    }
13167|      0|    else
13168|      0|    {
13169|      0|        window = NULL;
13170|      0|        source_id = ImHashStr("#SourceExtern");
13171|      0|        source_drag_active = true;
13172|      0|    }
13173|       |
13174|     21|    if (source_drag_active)
  ------------------
  |  Branch (13174:9): [True: 0, False: 21]
  ------------------
13175|      0|    {
13176|      0|        if (!g.DragDropActive)
  ------------------
  |  Branch (13176:13): [True: 0, False: 0]
  ------------------
13177|      0|        {
13178|      0|            IM_ASSERT(source_id != 0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13179|      0|            ClearDragDrop();
13180|      0|            ImGuiPayload& payload = g.DragDropPayload;
13181|      0|            payload.SourceId = source_id;
13182|      0|            payload.SourceParentId = source_parent_id;
13183|      0|            g.DragDropActive = true;
13184|      0|            g.DragDropSourceFlags = flags;
13185|      0|            g.DragDropMouseButton = mouse_button;
13186|      0|            if (payload.SourceId == g.ActiveId)
  ------------------
  |  Branch (13186:17): [True: 0, False: 0]
  ------------------
13187|      0|                g.ActiveIdNoClearOnFocusLoss = true;
13188|      0|        }
13189|      0|        g.DragDropSourceFrameCount = g.FrameCount;
13190|      0|        g.DragDropWithinSource = true;
13191|       |
13192|      0|        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (13192:13): [True: 0, False: 0]
  ------------------
13193|      0|        {
13194|       |            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
13195|       |            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
13196|      0|            bool ret;
13197|      0|            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
  ------------------
  |  Branch (13197:17): [True: 0, False: 0]
  |  Branch (13197:43): [True: 0, False: 0]
  ------------------
13198|      0|                ret = BeginTooltipHidden();
13199|      0|            else
13200|      0|                ret = BeginTooltip();
13201|      0|            IM_ASSERT(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to Begin("##Hidden", NULL, ImGuiWindowFlags_NoSavedSettings) + SetWindowHiddendAndSkipItemsForCurrentFrame().
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13202|      0|            IM_UNUSED(ret);
  ------------------
  |  |   89|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
13203|      0|        }
13204|       |
13205|      0|        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
  ------------------
  |  Branch (13205:13): [True: 0, False: 0]
  |  Branch (13205:67): [True: 0, False: 0]
  ------------------
13206|      0|            g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;
13207|       |
13208|      0|        return true;
13209|      0|    }
13210|     21|    return false;
13211|     21|}
_ZN5ImGui30IsDragDropPayloadBeingAcceptedEv:
13331|     26|{
13332|     26|    ImGuiContext& g = *GImGui;
13333|     26|    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
  ------------------
  |  Branch (13333:12): [True: 0, False: 26]
  |  Branch (13333:32): [True: 0, False: 0]
  ------------------
13334|     26|}
_ZN5ImGui9LogFinishEv:
13591|  58.7k|{
13592|  58.7k|    ImGuiContext& g = *GImGui;
13593|  58.7k|    if (!g.LogEnabled)
  ------------------
  |  Branch (13593:9): [True: 58.7k, False: 0]
  ------------------
13594|  58.7k|        return;
13595|       |
13596|      0|    LogText(IM_NEWLINE);
  ------------------
  |  |  276|      0|#define IM_NEWLINE                      "\n"
  ------------------
13597|      0|    switch (g.LogType)
  ------------------
  |  Branch (13597:13): [True: 0, False: 0]
  ------------------
13598|      0|    {
13599|      0|    case ImGuiLogType_TTY:
  ------------------
  |  Branch (13599:5): [True: 0, False: 0]
  ------------------
13600|      0|#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
13601|      0|        fflush(g.LogFile);
13602|      0|#endif
13603|      0|        break;
13604|      0|    case ImGuiLogType_File:
  ------------------
  |  Branch (13604:5): [True: 0, False: 0]
  ------------------
13605|      0|        ImFileClose(g.LogFile);
13606|      0|        break;
13607|      0|    case ImGuiLogType_Buffer:
  ------------------
  |  Branch (13607:5): [True: 0, False: 0]
  ------------------
13608|      0|        break;
13609|      0|    case ImGuiLogType_Clipboard:
  ------------------
  |  Branch (13609:5): [True: 0, False: 0]
  ------------------
13610|      0|        if (!g.LogBuffer.empty())
  ------------------
  |  Branch (13610:13): [True: 0, False: 0]
  ------------------
13611|      0|            SetClipboardText(g.LogBuffer.begin());
13612|      0|        break;
13613|      0|    case ImGuiLogType_None:
  ------------------
  |  Branch (13613:5): [True: 0, False: 0]
  ------------------
13614|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13615|      0|        break;
13616|      0|    }
13617|       |
13618|      0|    g.LogEnabled = false;
13619|      0|    g.LogType = ImGuiLogType_None;
13620|      0|    g.LogFile = NULL;
13621|      0|    g.LogBuffer.clear();
13622|      0|}
_ZN5ImGui20MarkIniSettingsDirtyEP11ImGuiWindow:
13709|  5.95k|{
13710|  5.95k|    ImGuiContext& g = *GImGui;
13711|  5.95k|    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (13711:9): [True: 9, False: 5.94k]
  ------------------
13712|      9|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (13712:13): [True: 6, False: 3]
  ------------------
13713|      6|            g.SettingsDirtyTimer = g.IO.IniSavingRate;
13714|  5.95k|}
_ZN5ImGui18AddSettingsHandlerEPK20ImGuiSettingsHandler:
13717|      2|{
13718|      2|    ImGuiContext& g = *GImGui;
13719|      2|    IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13720|      2|    g.SettingsHandlers.push_back(*handler);
13721|      2|}
_ZN5ImGui19FindSettingsHandlerEPKc:
13731|      2|{
13732|      2|    ImGuiContext& g = *GImGui;
13733|      2|    const ImGuiID type_hash = ImHashStr(type_name);
13734|      2|    for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
  ------------------
  |  Branch (13734:40): [True: 1, False: 2]
  ------------------
13735|      1|        if (handler.TypeHash == type_hash)
  ------------------
  |  Branch (13735:13): [True: 0, False: 1]
  ------------------
13736|      0|            return &handler;
13737|      2|    return NULL;
13738|      2|}
_ZN5ImGui22FindWindowSettingsByIDEj:
13889|      2|{
13890|      2|    ImGuiContext& g = *GImGui;
13891|      2|    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
  ------------------
  |  Branch (13891:69): [True: 0, False: 2]
  ------------------
13892|      0|        if (settings->ID == id && !settings->WantDelete)
  ------------------
  |  Branch (13892:13): [True: 0, False: 0]
  |  Branch (13892:35): [True: 0, False: 0]
  ------------------
13893|      0|            return settings;
13894|      2|    return NULL;
13895|      2|}
_ZN5ImGui26FindWindowSettingsByWindowEP11ImGuiWindow:
13899|      2|{
13900|      2|    ImGuiContext& g = *GImGui;
13901|      2|    if (window->SettingsOffset != -1)
  ------------------
  |  Branch (13901:9): [True: 0, False: 2]
  ------------------
13902|      0|        return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
13903|      2|    return FindWindowSettingsByID(window->ID);
13904|      2|}
_ZN5ImGui23LocalizeRegisterEntriesEPK13ImGuiLocEntryi:
14040|      1|{
14041|      1|    ImGuiContext& g = *GImGui;
14042|     11|    for (int n = 0; n < count; n++)
  ------------------
  |  Branch (14042:21): [True: 10, False: 1]
  ------------------
14043|     10|        g.LocalizationTable[entries[n].Key] = entries[n].Text;
14044|      1|}
_ZN5ImGui15GetMainViewportEv:
14076|  84.7k|{
14077|  84.7k|    ImGuiContext& g = *GImGui;
14078|  84.7k|    return g.Viewports[0];
14079|  84.7k|}
_ZN5ImGui16FindViewportByIDEj:
14083|  29.3k|{
14084|  29.3k|    ImGuiContext& g = *GImGui;
14085|  29.3k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (14085:35): [True: 29.3k, False: 0]
  ------------------
14086|  29.3k|        if (viewport->ID == id)
  ------------------
  |  Branch (14086:13): [True: 29.3k, False: 0]
  ------------------
14087|  29.3k|            return viewport;
14088|      0|    return NULL;
14089|  29.3k|}
_ZN5ImGui18SetCurrentViewportEP11ImGuiWindowP14ImGuiViewportP:
14101|   169k|{
14102|   169k|    ImGuiContext& g = *GImGui;
14103|   169k|    (void)current_window;
14104|       |
14105|   169k|    if (viewport)
  ------------------
  |  Branch (14105:9): [True: 140k, False: 29.3k]
  ------------------
14106|   140k|        viewport->LastFrameActive = g.FrameCount;
14107|   169k|    if (g.CurrentViewport == viewport)
  ------------------
  |  Branch (14107:9): [True: 110k, False: 58.7k]
  ------------------
14108|   110k|        return;
14109|  58.7k|    g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (14109:25): [True: 29.3k, False: 29.3k]
  ------------------
14110|  58.7k|    g.CurrentViewport = viewport;
14111|       |    //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
14112|       |
14113|       |    // Notify platform layer of viewport changes
14114|       |    // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
14115|  58.7k|    if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
  ------------------
  |  Branch (14115:9): [True: 29.3k, False: 29.3k]
  |  Branch (14115:30): [True: 0, False: 29.3k]
  ------------------
14116|      0|        g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
14117|  58.7k|}
_ZN5ImGui17SetWindowViewportEP11ImGuiWindowP14ImGuiViewportP:
14120|  84.6k|{
14121|       |    // Abandon viewport
14122|  84.6k|    if (window->ViewportOwned && window->Viewport->Window == window)
  ------------------
  |  Branch (14122:9): [True: 0, False: 84.6k]
  |  Branch (14122:34): [True: 0, False: 0]
  ------------------
14123|      0|        window->Viewport->Size = ImVec2(0.0f, 0.0f);
14124|       |
14125|  84.6k|    window->Viewport = viewport;
14126|  84.6k|    window->ViewportId = viewport->ID;
14127|  84.6k|    window->ViewportOwned = (viewport->Window == window);
14128|  84.6k|}
_ZN5ImGui21DockContextInitializeEP12ImGuiContext:
15259|      1|{
15260|      1|    ImGuiContext& g = *ctx;
15261|       |
15262|       |    // Add .ini handle for persistent docking data
15263|      1|    ImGuiSettingsHandler ini_handler;
15264|      1|    ini_handler.TypeName = "Docking";
15265|      1|    ini_handler.TypeHash = ImHashStr("Docking");
15266|      1|    ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
15267|      1|    ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
15268|      1|    ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
15269|      1|    ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
15270|      1|    ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
15271|      1|    ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
15272|      1|    g.SettingsHandlers.push_back(ini_handler);
15273|       |
15274|      1|    g.DockNodeWindowMenuHandler = &DockNodeWindowMenuHandler_Default;
15275|      1|}
_ZN5ImGui34DockContextNewFrameUpdateUndockingEP12ImGuiContext:
15309|  29.3k|{
15310|  29.3k|    ImGuiContext& g = *ctx;
15311|  29.3k|    ImGuiDockContext* dc = &ctx->DockContext;
15312|  29.3k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (15312:9): [True: 0, False: 29.3k]
  ------------------
15313|      0|    {
15314|      0|        if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
  ------------------
  |  Branch (15314:13): [True: 0, False: 0]
  |  Branch (15314:40): [True: 0, False: 0]
  ------------------
15315|      0|            DockContextClearNodes(ctx, 0, true);
15316|      0|        return;
15317|      0|    }
15318|       |
15319|       |    // Setting NoSplit at runtime merges all nodes
15320|  29.3k|    if (g.IO.ConfigDockingNoSplit)
  ------------------
  |  Branch (15320:9): [True: 0, False: 29.3k]
  ------------------
15321|      0|        for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (15321:25): [True: 0, False: 0]
  ------------------
15322|      0|            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (15322:32): [True: 0, False: 0]
  ------------------
15323|      0|                if (node->IsRootNode() && node->IsSplitNode())
  ------------------
  |  Branch (15323:21): [True: 0, False: 0]
  |  Branch (15323:43): [True: 0, False: 0]
  ------------------
15324|      0|                {
15325|      0|                    DockBuilderRemoveNodeChildNodes(node->ID);
15326|       |                    //dc->WantFullRebuild = true;
15327|      0|                }
15328|       |
15329|       |    // Process full rebuild
15330|       |#if 0
15331|       |    if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
15332|       |        dc->WantFullRebuild = true;
15333|       |#endif
15334|  29.3k|    if (dc->WantFullRebuild)
  ------------------
  |  Branch (15334:9): [True: 0, False: 29.3k]
  ------------------
15335|      0|    {
15336|      0|        DockContextRebuildNodes(ctx);
15337|      0|        dc->WantFullRebuild = false;
15338|      0|    }
15339|       |
15340|       |    // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
15341|  29.3k|    for (ImGuiDockRequest& req : dc->Requests)
  ------------------
  |  Branch (15341:32): [True: 0, False: 29.3k]
  ------------------
15342|      0|    {
15343|      0|        if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetWindow)
  ------------------
  |  Branch (15343:13): [True: 0, False: 0]
  |  Branch (15343:56): [True: 0, False: 0]
  ------------------
15344|      0|            DockContextProcessUndockWindow(ctx, req.UndockTargetWindow);
15345|      0|        else if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetNode)
  ------------------
  |  Branch (15345:18): [True: 0, False: 0]
  |  Branch (15345:61): [True: 0, False: 0]
  ------------------
15346|      0|            DockContextProcessUndockNode(ctx, req.UndockTargetNode);
15347|      0|    }
15348|  29.3k|}
_ZN5ImGui32DockContextNewFrameUpdateDockingEP12ImGuiContext:
15352|  29.3k|{
15353|  29.3k|    ImGuiContext& g = *ctx;
15354|  29.3k|    ImGuiDockContext* dc  = &ctx->DockContext;
15355|  29.3k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (15355:9): [True: 0, False: 29.3k]
  ------------------
15356|      0|        return;
15357|       |
15358|       |    // [DEBUG] Store hovered dock node.
15359|       |    // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
15360|       |    // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
15361|  29.3k|    g.DebugHoveredDockNode = NULL;
15362|  29.3k|    if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
  ------------------
  |  Branch (15362:22): [True: 495, False: 28.8k]
  ------------------
15363|    495|    {
15364|    495|        if (hovered_window->DockNodeAsHost)
  ------------------
  |  Branch (15364:13): [True: 0, False: 495]
  ------------------
15365|      0|            g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
15366|    495|        else if (hovered_window->RootWindow->DockNode)
  ------------------
  |  Branch (15366:18): [True: 0, False: 495]
  ------------------
15367|      0|            g.DebugHoveredDockNode = hovered_window->RootWindow->DockNode;
15368|    495|    }
15369|       |
15370|       |    // Process Docking requests
15371|  29.3k|    for (ImGuiDockRequest& req : dc->Requests)
  ------------------
  |  Branch (15371:32): [True: 0, False: 29.3k]
  ------------------
15372|      0|        if (req.Type == ImGuiDockRequestType_Dock)
  ------------------
  |  Branch (15372:13): [True: 0, False: 0]
  ------------------
15373|      0|            DockContextProcessDock(ctx, &req);
15374|  29.3k|    dc->Requests.resize(0);
15375|       |
15376|       |    // Create windows for each automatic docking nodes
15377|       |    // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
15378|  29.3k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (15378:21): [True: 0, False: 29.3k]
  ------------------
15379|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (15379:28): [True: 0, False: 0]
  ------------------
15380|      0|            if (node->IsFloatingNode())
  ------------------
  |  Branch (15380:17): [True: 0, False: 0]
  ------------------
15381|      0|                DockNodeUpdate(node);
15382|  29.3k|}
_ZN5ImGui19DockContextEndFrameEP12ImGuiContext:
15385|  29.3k|{
15386|       |    // Draw backgrounds of node missing their window
15387|  29.3k|    ImGuiContext& g = *ctx;
15388|  29.3k|    ImGuiDockContext* dc = &g.DockContext;
15389|  29.3k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (15389:21): [True: 0, False: 29.3k]
  ------------------
15390|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (15390:28): [True: 0, False: 0]
  ------------------
15391|      0|            if (node->LastFrameActive == g.FrameCount && node->IsVisible && node->HostWindow && node->IsLeafNode() && !node->IsBgDrawnThisFrame)
  ------------------
  |  Branch (15391:17): [True: 0, False: 0]
  |  Branch (15391:58): [True: 0, False: 0]
  |  Branch (15391:77): [True: 0, False: 0]
  |  Branch (15391:97): [True: 0, False: 0]
  |  Branch (15391:119): [True: 0, False: 0]
  ------------------
15392|      0|            {
15393|      0|                ImRect bg_rect(node->Pos + ImVec2(0.0f, GetFrameHeight()), node->Pos + node->Size);
15394|      0|                ImDrawFlags bg_rounding_flags = CalcRoundingFlagsForRectInRect(bg_rect, node->HostWindow->Rect(), g.Style.DockingSeparatorSize);
15395|      0|                node->HostWindow->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1691|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
15396|      0|                node->HostWindow->DrawList->AddRectFilled(bg_rect.Min, bg_rect.Max, node->LastBgColor, node->HostWindow->WindowRounding, bg_rounding_flags);
15397|      0|            }
15398|  29.3k|}
_ZN5ImGui28GetWindowAlwaysWantOwnTabBarEP11ImGuiWindow:
18451|  84.6k|{
18452|  84.6k|    ImGuiContext& g = *GImGui;
18453|  84.6k|    if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
  ------------------
  |  Branch (18453:9): [True: 0, False: 84.6k]
  |  Branch (18453:43): [True: 0, False: 84.6k]
  ------------------
18454|      0|        if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
  ------------------
  |  Branch (18454:13): [True: 0, False: 0]
  ------------------
18455|      0|            if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
  ------------------
  |  Branch (18455:17): [True: 0, False: 0]
  ------------------
18456|      0|                return true;
18457|  84.6k|    return false;
18458|  84.6k|}
_ZN5ImGui27BeginDockableDragDropSourceEP11ImGuiWindow:
18631|     24|{
18632|     24|    ImGuiContext& g = *GImGui;
18633|     24|    IM_ASSERT(g.ActiveId == window->MoveId);
  ------------------
  |  |   23|     24|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18634|     24|    IM_ASSERT(g.MovingWindow == window);
  ------------------
  |  |   23|     24|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18635|     24|    IM_ASSERT(g.CurrentWindow == window);
  ------------------
  |  |   23|     24|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18636|       |
18637|       |    // 0: Hold SHIFT to disable docking, 1: Hold SHIFT to enable docking.
18638|     24|    if (g.IO.ConfigDockingWithShift != g.IO.KeyShift)
  ------------------
  |  Branch (18638:9): [True: 0, False: 24]
  ------------------
18639|      0|    {
18640|       |        // When ConfigDockingWithShift is set, display a tooltip to increase UI affordance.
18641|       |        // We cannot set for HoveredWindowUnderMovingWindow != NULL here, as it is only valid/useful when drag and drop is already active
18642|       |        // (because of the 'is_mouse_dragging_with_an_expected_destination' logic in UpdateViewportsNewFrame() function)
18643|      0|        if (g.IO.ConfigDockingWithShift && g.MouseStationaryTimer >= 1.0f && g.ActiveId >= 1.0f)
  ------------------
  |  Branch (18643:13): [True: 0, False: 0]
  |  Branch (18643:44): [True: 0, False: 0]
  |  Branch (18643:78): [True: 0, False: 0]
  ------------------
18644|      0|            SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey_DockingHoldShiftToDock));
18645|      0|        return;
18646|      0|    }
18647|       |
18648|     24|    g.LastItemData.ID = window->MoveId;
18649|     24|    window = window->RootWindowDockTree;
18650|     24|    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
  ------------------
  |  |   23|     24|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18651|     24|    bool is_drag_docking = (g.IO.ConfigDockingWithShift) || ImRect(0, 0, window->SizeFull.x, GetFrameHeight()).Contains(g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
  ------------------
  |  Branch (18651:28): [True: 0, False: 24]
  |  Branch (18651:61): [True: 21, False: 3]
  ------------------
18652|     24|    if (is_drag_docking && BeginDragDropSource(ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_SourceAutoExpirePayload))
  ------------------
  |  Branch (18652:9): [True: 21, False: 3]
  |  Branch (18652:28): [True: 0, False: 21]
  ------------------
18653|      0|    {
18654|      0|        SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
  ------------------
  |  |  225|      0|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
18655|      0|        EndDragDropSource();
18656|       |
18657|       |        // Store style overrides
18658|      0|        for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
  ------------------
  |  Branch (18658:31): [True: 0, False: 0]
  ------------------
18659|      0|            window->DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
18660|      0|    }
18661|     24|}
imgui.cpp:_ZL20FindLatestInputEventP12ImGuiContext19ImGuiInputEventTypei:
 1460|  7.96k|{
 1461|  7.96k|    ImGuiContext& g = *ctx;
 1462|  12.1k|    for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (1462:47): [True: 6.92k, False: 5.20k]
  ------------------
 1463|  6.92k|    {
 1464|  6.92k|        ImGuiInputEvent* e = &g.InputEventsQueue[n];
 1465|  6.92k|        if (e->Type != type)
  ------------------
  |  Branch (1465:13): [True: 2.42k, False: 4.50k]
  ------------------
 1466|  2.42k|            continue;
 1467|  4.50k|        if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
  ------------------
  |  Branch (1467:13): [True: 1.42k, False: 3.08k]
  |  Branch (1467:48): [True: 603, False: 818]
  ------------------
 1468|    603|            continue;
 1469|  3.90k|        if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
  ------------------
  |  Branch (1469:13): [True: 2.05k, False: 1.85k]
  |  Branch (1469:56): [True: 1.14k, False: 909]
  ------------------
 1470|  1.14k|            continue;
 1471|  2.76k|        return e;
 1472|  3.90k|    }
 1473|  5.20k|    return NULL;
 1474|  7.96k|}
imgui.cpp:_ZL10LowerBoundR8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEj:
 2439|  84.7k|{
 2440|  84.7k|    ImGuiStorage::ImGuiStoragePair* first = data.Data;
 2441|  84.7k|    ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
 2442|  84.7k|    size_t count = (size_t)(last - first);
 2443|   306k|    while (count > 0)
  ------------------
  |  Branch (2443:12): [True: 221k, False: 84.7k]
  ------------------
 2444|   221k|    {
 2445|   221k|        size_t count2 = count >> 1;
 2446|   221k|        ImGuiStorage::ImGuiStoragePair* mid = first + count2;
 2447|   221k|        if (mid->key < key)
  ------------------
  |  Branch (2447:13): [True: 55.3k, False: 166k]
  ------------------
 2448|  55.3k|        {
 2449|  55.3k|            first = ++mid;
 2450|  55.3k|            count -= count2 + 1;
 2451|  55.3k|        }
 2452|   166k|        else
 2453|   166k|        {
 2454|   166k|            count = count2;
 2455|   166k|        }
 2456|   221k|    }
 2457|  84.7k|    return first;
 2458|  84.7k|}
imgui.cpp:_ZL13MallocWrappermPv:
 1168|  1.24k|static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
  ------------------
  |  |   89|  1.24k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL11FreeWrapperPvS_:
 1169|  1.19k|static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
  ------------------
  |  |   89|  1.19k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL24IsWindowActiveAndVisibleP11ImGuiWindow:
 4662|   141k|{
 4663|   141k|    return (window->Active) && (!window->Hidden);
  ------------------
  |  Branch (4663:12): [True: 81.2k, False: 60.6k]
  |  Branch (4663:32): [True: 54.8k, False: 26.4k]
  ------------------
 4664|   141k|}
imgui.cpp:_ZL21GetWindowDisplayLayerP11ImGuiWindow:
 5073|  29.3k|{
 5074|  29.3k|    return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
  ------------------
  |  Branch (5074:12): [True: 7, False: 29.3k]
  ------------------
 5075|  29.3k|}
imgui.cpp:_ZL21AddWindowToSortBufferP8ImVectorIP11ImGuiWindowES1_:
 5043|   115k|{
 5044|   115k|    out_sorted_windows->push_back(window);
 5045|   115k|    if (window->Active)
  ------------------
  |  Branch (5045:9): [True: 55.3k, False: 60.6k]
  ------------------
 5046|  55.3k|    {
 5047|  55.3k|        int count = window->DC.ChildWindows.Size;
 5048|  55.3k|        ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
 5049|  81.2k|        for (int i = 0; i < count; i++)
  ------------------
  |  Branch (5049:25): [True: 25.9k, False: 55.3k]
  ------------------
 5050|  25.9k|        {
 5051|  25.9k|            ImGuiWindow* child = window->DC.ChildWindows[i];
 5052|  25.9k|            if (child->Active)
  ------------------
  |  Branch (5052:17): [True: 25.9k, False: 0]
  ------------------
 5053|  25.9k|                AddWindowToSortBuffer(out_sorted_windows, child);
 5054|  25.9k|        }
 5055|  55.3k|    }
 5056|   115k|}
imgui.cpp:_ZL20InitViewportDrawDataP14ImGuiViewportP:
 5102|  29.3k|{
 5103|  29.3k|    ImGuiIO& io = ImGui::GetIO();
 5104|  29.3k|    ImDrawData* draw_data = &viewport->DrawDataP;
 5105|       |
 5106|  29.3k|    viewport->DrawData = draw_data; // Make publicly accessible
 5107|  29.3k|    viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;
 5108|  29.3k|    viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;
 5109|  29.3k|    viewport->DrawDataBuilder.Layers[0]->resize(0);
 5110|  29.3k|    viewport->DrawDataBuilder.Layers[1]->resize(0);
 5111|       |
 5112|       |    // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
 5113|       |    // and to allow applications/backends to easily skip rendering.
 5114|       |    // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
 5115|       |    // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
 5116|       |    // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
 5117|  29.3k|    const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0;
 5118|       |
 5119|  29.3k|    draw_data->Valid = true;
 5120|  29.3k|    draw_data->CmdListsCount = 0;
 5121|  29.3k|    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
 5122|  29.3k|    draw_data->DisplayPos = viewport->Pos;
 5123|  29.3k|    draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
  ------------------
  |  Branch (5123:30): [True: 0, False: 29.3k]
  ------------------
 5124|  29.3k|    draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
 5125|  29.3k|    draw_data->OwnerViewport = viewport;
 5126|  29.3k|}
imgui.cpp:_ZN5ImGuiL23RenderDimmedBackgroundsEv:
 5215|  29.3k|{
 5216|  29.3k|    ImGuiContext& g = *GImGui;
 5217|  29.3k|    ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
 5218|  29.3k|    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (5218:9): [True: 29.3k, False: 0]
  |  Branch (5218:33): [True: 29.3k, False: 0]
  ------------------
 5219|  29.3k|        return;
 5220|      0|    const bool dim_bg_for_modal = (modal_window != NULL);
 5221|      0|    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
  ------------------
  |  Branch (5221:42): [True: 0, False: 0]
  |  Branch (5221:78): [True: 0, False: 0]
  ------------------
 5222|      0|    if (!dim_bg_for_modal && !dim_bg_for_window_list)
  ------------------
  |  Branch (5222:9): [True: 0, False: 0]
  |  Branch (5222:30): [True: 0, False: 0]
  ------------------
 5223|      0|        return;
 5224|       |
 5225|      0|    ImGuiViewport* viewports_already_dimmed[2] = { NULL, NULL };
 5226|      0|    if (dim_bg_for_modal)
  ------------------
  |  Branch (5226:9): [True: 0, False: 0]
  ------------------
 5227|      0|    {
 5228|       |        // Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
 5229|      0|        ImGuiWindow* dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);
 5230|      0|        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(ImGuiCol_ModalWindowDimBg, g.DimBgRatio));
 5231|      0|        viewports_already_dimmed[0] = modal_window->Viewport;
 5232|      0|    }
 5233|      0|    else if (dim_bg_for_window_list)
  ------------------
  |  Branch (5233:14): [True: 0, False: 0]
  ------------------
 5234|      0|    {
 5235|       |        // Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
 5236|      0|        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5237|      0|        if (g.NavWindowingListWindow != NULL && g.NavWindowingListWindow->Viewport && g.NavWindowingListWindow->Viewport != g.NavWindowingTargetAnim->Viewport)
  ------------------
  |  Branch (5237:13): [True: 0, False: 0]
  |  Branch (5237:49): [True: 0, False: 0]
  |  Branch (5237:87): [True: 0, False: 0]
  ------------------
 5238|      0|            RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5239|      0|        viewports_already_dimmed[0] = g.NavWindowingTargetAnim->Viewport;
 5240|      0|        viewports_already_dimmed[1] = g.NavWindowingListWindow ? g.NavWindowingListWindow->Viewport : NULL;
  ------------------
  |  Branch (5240:39): [True: 0, False: 0]
  ------------------
 5241|       |
 5242|       |        // Draw border around CTRL+Tab target window
 5243|      0|        ImGuiWindow* window = g.NavWindowingTargetAnim;
 5244|      0|        ImGuiViewport* viewport = window->Viewport;
 5245|      0|        float distance = g.FontSize;
 5246|      0|        ImRect bb = window->Rect();
 5247|      0|        bb.Expand(distance);
 5248|      0|        if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
  ------------------
  |  Branch (5248:13): [True: 0, False: 0]
  |  Branch (5248:50): [True: 0, False: 0]
  ------------------
 5249|      0|            bb.Expand(-distance - 1.0f); // If a window fits the entire viewport, adjust its highlight inward
 5250|      0|        window->DrawList->ChannelsMerge();
 5251|      0|        if (window->DrawList->CmdBuffer.Size == 0)
  ------------------
  |  Branch (5251:13): [True: 0, False: 0]
  ------------------
 5252|      0|            window->DrawList->AddDrawCmd();
 5253|      0|        window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);
 5254|      0|        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);
 5255|      0|        window->DrawList->PopClipRect();
 5256|      0|    }
 5257|       |
 5258|       |    // Draw dimming background on _other_ viewports than the ones our windows are in
 5259|      0|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (5259:35): [True: 0, False: 0]
  ------------------
 5260|      0|    {
 5261|      0|        if (viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1])
  ------------------
  |  Branch (5261:13): [True: 0, False: 0]
  |  Branch (5261:56): [True: 0, False: 0]
  ------------------
 5262|      0|            continue;
 5263|      0|        if (modal_window && viewport->Window && IsWindowAbove(viewport->Window, modal_window))
  ------------------
  |  Branch (5263:13): [True: 0, False: 0]
  |  Branch (5263:29): [True: 0, False: 0]
  |  Branch (5263:49): [True: 0, False: 0]
  ------------------
 5264|      0|            continue;
 5265|      0|        ImDrawList* draw_list = GetForegroundDrawList(viewport);
 5266|      0|        const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
  ------------------
  |  Branch (5266:46): [True: 0, False: 0]
  ------------------
 5267|      0|        draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
 5268|      0|    }
 5269|      0|}
imgui.cpp:_ZL23AddRootWindowToDrawDataP11ImGuiWindow:
 5079|  29.3k|{
 5080|  29.3k|    AddWindowToDrawData(window, GetWindowDisplayLayer(window));
 5081|  29.3k|}
imgui.cpp:_ZL19AddWindowToDrawDataP11ImGuiWindowi:
 5059|  42.0k|{
 5060|  42.0k|    ImGuiContext& g = *GImGui;
 5061|  42.0k|    ImGuiViewportP* viewport = window->Viewport;
 5062|  42.0k|    IM_ASSERT(viewport != NULL);
  ------------------
  |  |   23|  42.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5063|  42.0k|    g.IO.MetricsRenderWindows++;
 5064|  42.0k|    if (window->DrawList->_Splitter._Count > 1)
  ------------------
  |  Branch (5064:9): [True: 0, False: 42.0k]
  ------------------
 5065|      0|        window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
 5066|  42.0k|    ImGui::AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[layer], window->DrawList);
 5067|  42.0k|    for (ImGuiWindow* child : window->DC.ChildWindows)
  ------------------
  |  Branch (5067:29): [True: 25.9k, False: 42.0k]
  ------------------
 5068|  25.9k|        if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
  ------------------
  |  Branch (5068:13): [True: 12.7k, False: 13.2k]
  ------------------
 5069|  12.7k|            AddWindowToDrawData(child, layer);
 5070|  42.0k|}
imgui.cpp:_ZL30FlattenDrawDataIntoSingleLayerP17ImDrawDataBuilder:
 5084|  29.3k|{
 5085|  29.3k|    int n = builder->Layers[0]->Size;
 5086|  29.3k|    int full_size = n;
 5087|  58.7k|    for (int i = 1; i < IM_ARRAYSIZE(builder->Layers); i++)
  ------------------
  |  |   88|  58.7k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5087:21): [True: 29.3k, False: 29.3k]
  ------------------
 5088|  29.3k|        full_size += builder->Layers[i]->Size;
 5089|  29.3k|    builder->Layers[0]->resize(full_size);
 5090|  58.7k|    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(builder->Layers); layer_n++)
  ------------------
  |  |   88|  58.7k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5090:27): [True: 29.3k, False: 29.3k]
  ------------------
 5091|  29.3k|    {
 5092|  29.3k|        ImVector<ImDrawList*>* layer = builder->Layers[layer_n];
 5093|  29.3k|        if (layer->empty())
  ------------------
  |  Branch (5093:13): [True: 29.3k, False: 7]
  ------------------
 5094|  29.3k|            continue;
 5095|      7|        memcpy(builder->Layers[0]->Data + n, layer->Data, layer->Size * sizeof(ImDrawList*));
 5096|      7|        n += layer->Size;
 5097|      7|        layer->resize(0);
 5098|      7|    }
 5099|  29.3k|}
imgui.cpp:_ZL17FindHoveredWindowv:
 5479|  29.3k|{
 5480|  29.3k|    ImGuiContext& g = *GImGui;
 5481|       |
 5482|       |    // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
 5483|  29.3k|    ImGuiViewportP* moving_window_viewport = g.MovingWindow ? g.MovingWindow->Viewport : NULL;
  ------------------
  |  Branch (5483:46): [True: 50, False: 29.3k]
  ------------------
 5484|  29.3k|    if (g.MovingWindow)
  ------------------
  |  Branch (5484:9): [True: 50, False: 29.3k]
  ------------------
 5485|     50|        g.MovingWindow->Viewport = g.MouseViewport;
 5486|       |
 5487|  29.3k|    ImGuiWindow* hovered_window = NULL;
 5488|  29.3k|    ImGuiWindow* hovered_window_ignoring_moving_window = NULL;
 5489|  29.3k|    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (5489:9): [True: 50, False: 29.3k]
  |  Branch (5489:27): [True: 50, False: 0]
  ------------------
 5490|     50|        hovered_window = g.MovingWindow;
 5491|       |
 5492|  29.3k|    ImVec2 padding_regular = g.Style.TouchExtraPadding;
 5493|  29.3k|    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
  ------------------
  |  Branch (5493:33): [True: 0, False: 29.3k]
  ------------------
 5494|   143k|    for (int i = g.Windows.Size - 1; i >= 0; i--)
  ------------------
  |  Branch (5494:38): [True: 114k, False: 28.8k]
  ------------------
 5495|   114k|    {
 5496|   114k|        ImGuiWindow* window = g.Windows[i];
 5497|   114k|        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5498|   114k|        if (!window->Active || window->Hidden)
  ------------------
  |  Branch (5498:13): [True: 59.7k, False: 55.2k]
  |  Branch (5498:32): [True: 13.2k, False: 42.0k]
  ------------------
 5499|  72.9k|            continue;
 5500|  42.0k|        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
  ------------------
  |  Branch (5500:13): [True: 4, False: 42.0k]
  ------------------
 5501|      4|            continue;
 5502|  42.0k|        IM_ASSERT(window->Viewport);
  ------------------
  |  |   23|  42.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5503|  42.0k|        if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (5503:13): [True: 0, False: 42.0k]
  ------------------
 5504|      0|            continue;
 5505|       |
 5506|       |        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
 5507|  42.0k|        ImVec2 hit_padding = (window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;
  ------------------
  |  Branch (5507:30): [True: 12.7k, False: 29.2k]
  ------------------
 5508|  42.0k|        if (!window->OuterRectClipped.ContainsWithPad(g.IO.MousePos, hit_padding))
  ------------------
  |  Branch (5508:13): [True: 41.4k, False: 530]
  ------------------
 5509|  41.4k|            continue;
 5510|       |
 5511|       |        // Support for one rectangular hole in any given window
 5512|       |        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
 5513|    530|        if (window->HitTestHoleSize.x != 0)
  ------------------
  |  Branch (5513:13): [True: 0, False: 530]
  ------------------
 5514|      0|        {
 5515|      0|            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
 5516|      0|            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
 5517|      0|            if (ImRect(hole_pos, hole_pos + hole_size).Contains(g.IO.MousePos))
  ------------------
  |  Branch (5517:17): [True: 0, False: 0]
  ------------------
 5518|      0|                continue;
 5519|      0|        }
 5520|       |
 5521|    530|        if (hovered_window == NULL)
  ------------------
  |  Branch (5521:13): [True: 495, False: 35]
  ------------------
 5522|    495|            hovered_window = window;
 5523|    530|        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5524|    530|        if (hovered_window_ignoring_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
  ------------------
  |  Branch (5524:13): [True: 530, False: 0]
  |  Branch (5524:63): [True: 495, False: 35]
  |  Branch (5524:82): [True: 0, False: 35]
  ------------------
 5525|    495|            hovered_window_ignoring_moving_window = window;
 5526|    530|        if (hovered_window && hovered_window_ignoring_moving_window)
  ------------------
  |  Branch (5526:13): [True: 530, False: 0]
  |  Branch (5526:31): [True: 495, False: 35]
  ------------------
 5527|    495|            break;
 5528|    530|    }
 5529|       |
 5530|  29.3k|    g.HoveredWindow = hovered_window;
 5531|  29.3k|    g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;
 5532|       |
 5533|  29.3k|    if (g.MovingWindow)
  ------------------
  |  Branch (5533:9): [True: 50, False: 29.3k]
  ------------------
 5534|     50|        g.MovingWindow->Viewport = moving_window_viewport;
 5535|  29.3k|}
imgui.cpp:_ZL22CalcWindowContentSizesP11ImGuiWindowP6ImVec2S2_:
 5989|  84.6k|{
 5990|  84.6k|    bool preserve_old_content_sizes = false;
 5991|  84.6k|    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
  ------------------
  |  Branch (5991:9): [True: 3.41k, False: 81.2k]
  |  Branch (5991:30): [True: 3.41k, False: 0]
  |  Branch (5991:61): [True: 3.41k, False: 0]
  ------------------
 5992|  3.41k|        preserve_old_content_sizes = true;
 5993|  81.2k|    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (5993:14): [True: 13.2k, False: 68.0k]
  |  Branch (5993:32): [True: 13.2k, False: 12]
  |  Branch (5993:76): [True: 13.2k, False: 0]
  ------------------
 5994|  13.2k|        preserve_old_content_sizes = true;
 5995|  84.6k|    if (preserve_old_content_sizes)
  ------------------
  |  Branch (5995:9): [True: 16.6k, False: 68.0k]
  ------------------
 5996|  16.6k|    {
 5997|  16.6k|        *content_size_current = window->ContentSize;
 5998|  16.6k|        *content_size_ideal = window->ContentSizeIdeal;
 5999|  16.6k|        return;
 6000|  16.6k|    }
 6001|       |
 6002|  68.0k|    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
  ------------------
  |  |  284|   136k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6002:31): [True: 0, False: 68.0k]
  ------------------
 6003|  68.0k|    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
  ------------------
  |  |  284|   136k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6003:31): [True: 0, False: 68.0k]
  ------------------
 6004|  68.0k|    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
  ------------------
  |  |  284|   136k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6004:29): [True: 0, False: 68.0k]
  ------------------
 6005|  68.0k|    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
  ------------------
  |  |  284|   136k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6005:29): [True: 0, False: 68.0k]
  ------------------
 6006|  68.0k|}
imgui.cpp:_ZL21CalcWindowAutoFitSizeP11ImGuiWindowRK6ImVec2:
 6009|  84.6k|{
 6010|  84.6k|    ImGuiContext& g = *GImGui;
 6011|  84.6k|    ImGuiStyle& style = g.Style;
 6012|  84.6k|    const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
 6013|  84.6k|    const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
 6014|  84.6k|    ImVec2 size_pad = window->WindowPadding * 2.0f;
 6015|  84.6k|    ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
 6016|  84.6k|    if (window->Flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (6016:9): [True: 17, False: 84.6k]
  ------------------
 6017|     17|    {
 6018|       |        // Tooltip always resize
 6019|     17|        return size_desired;
 6020|     17|    }
 6021|  84.6k|    else
 6022|  84.6k|    {
 6023|       |        // Maximum window size is determined by the viewport size or monitor size
 6024|  84.6k|        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
 6025|  84.6k|        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
 6026|  84.6k|        ImVec2 size_min = style.WindowMinSize;
 6027|  84.6k|        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
  ------------------
  |  Branch (6027:13): [True: 0, False: 84.6k]
  |  Branch (6027:25): [True: 0, False: 84.6k]
  ------------------
 6028|      0|            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));
 6029|       |
 6030|  84.6k|        ImVec2 avail_size = window->Viewport->WorkSize;
 6031|  84.6k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6031:13): [True: 0, False: 84.6k]
  ------------------
 6032|      0|            avail_size = ImVec2(FLT_MAX, FLT_MAX);
 6033|  84.6k|        const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
 6034|  84.6k|        if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
  ------------------
  |  Branch (6034:13): [True: 0, False: 84.6k]
  |  Branch (6034:33): [True: 0, False: 0]
  ------------------
 6035|      0|            avail_size = g.PlatformIO.Monitors[monitor_idx].WorkSize;
 6036|  84.6k|        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, avail_size - style.DisplaySafeAreaPadding * 2.0f));
 6037|       |
 6038|       |        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
 6039|       |        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
 6040|  84.6k|        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 6041|  84.6k|        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x  && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
  ------------------
  |  Branch (6041:39): [True: 206, False: 84.4k]
  |  Branch (6041:141): [True: 206, False: 0]
  |  Branch (6041:192): [True: 191, False: 15]
  |  Branch (6041:251): [True: 25.7k, False: 58.7k]
  ------------------
 6042|  84.6k|        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
  ------------------
  |  Branch (6042:39): [True: 2.90k, False: 81.7k]
  |  Branch (6042:140): [True: 2.90k, False: 0]
  |  Branch (6042:192): [True: 0, False: 81.7k]
  ------------------
 6043|  84.6k|        if (will_have_scrollbar_x)
  ------------------
  |  Branch (6043:13): [True: 25.9k, False: 58.7k]
  ------------------
 6044|  25.9k|            size_auto_fit.y += style.ScrollbarSize;
 6045|  84.6k|        if (will_have_scrollbar_y)
  ------------------
  |  Branch (6045:13): [True: 2.90k, False: 81.7k]
  ------------------
 6046|  2.90k|            size_auto_fit.x += style.ScrollbarSize;
 6047|  84.6k|        return size_auto_fit;
 6048|  84.6k|    }
 6049|  84.6k|}
imgui.cpp:_ZL29CalcWindowSizeAfterConstraintP11ImGuiWindowRK6ImVec2:
 5954|   169k|{
 5955|   169k|    ImGuiContext& g = *GImGui;
 5956|   169k|    ImVec2 new_size = size_desired;
 5957|   169k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
  ------------------
  |  Branch (5957:9): [True: 0, False: 169k]
  ------------------
 5958|      0|    {
 5959|       |        // Using -1,-1 on either X/Y axis to preserve the current size.
 5960|      0|        ImRect cr = g.NextWindowData.SizeConstraintRect;
 5961|      0|        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
  ------------------
  |  Branch (5961:23): [True: 0, False: 0]
  |  Branch (5961:40): [True: 0, False: 0]
  ------------------
 5962|      0|        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
  ------------------
  |  Branch (5962:23): [True: 0, False: 0]
  |  Branch (5962:40): [True: 0, False: 0]
  ------------------
 5963|      0|        if (g.NextWindowData.SizeCallback)
  ------------------
  |  Branch (5963:13): [True: 0, False: 0]
  ------------------
 5964|      0|        {
 5965|      0|            ImGuiSizeCallbackData data;
 5966|      0|            data.UserData = g.NextWindowData.SizeCallbackUserData;
 5967|      0|            data.Pos = window->Pos;
 5968|      0|            data.CurrentSize = window->SizeFull;
 5969|      0|            data.DesiredSize = new_size;
 5970|      0|            g.NextWindowData.SizeCallback(&data);
 5971|      0|            new_size = data.DesiredSize;
 5972|      0|        }
 5973|      0|        new_size.x = IM_TRUNC(new_size.x);
  ------------------
  |  |  284|      0|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 5974|      0|        new_size.y = IM_TRUNC(new_size.y);
  ------------------
  |  |  284|      0|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 5975|      0|    }
 5976|       |
 5977|       |    // Minimum size
 5978|   169k|    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
  ------------------
  |  Branch (5978:9): [True: 117k, False: 51.9k]
  ------------------
 5979|   117k|    {
 5980|   117k|        ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
 5981|   117k|        new_size = ImMax(new_size, g.Style.WindowMinSize);
 5982|   117k|        const float minimum_height = window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f);
 5983|   117k|        new_size.y = ImMax(new_size.y, minimum_height); // Reduce artifacts with very small windows
 5984|   117k|    }
 5985|   169k|    return new_size;
 5986|   169k|}
imgui.cpp:_ZL30GetWindowForTitleAndMenuHeightP11ImGuiWindow:
 5949|   117k|{
 5950|   117k|    return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
  ------------------
  |  Branch (5950:13): [True: 0, False: 117k]
  |  Branch (5950:39): [True: 0, False: 0]
  ------------------
 5951|   117k|}
imgui.cpp:_ZL15CreateNewWindowPKci:
 5920|      4|{
 5921|       |    // Create window the first time
 5922|       |    //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
 5923|      4|    ImGuiContext& g = *GImGui;
 5924|      4|    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
  ------------------
  |  | 1883|      8|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 5925|      4|    window->Flags = flags;
 5926|      4|    g.WindowsById.SetVoidPtr(window->ID, window);
 5927|       |
 5928|      4|    ImGuiWindowSettings* settings = NULL;
 5929|      4|    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (5929:9): [True: 2, False: 2]
  ------------------
 5930|      2|        if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)
  ------------------
  |  Branch (5930:13): [True: 0, False: 2]
  ------------------
 5931|      0|            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
 5932|       |
 5933|      4|    InitOrLoadWindowSettings(window, settings);
 5934|       |
 5935|      4|    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
  ------------------
  |  Branch (5935:9): [True: 0, False: 4]
  ------------------
 5936|      0|        g.Windows.push_front(window); // Quite slow but rare and only once
 5937|      4|    else
 5938|      4|        g.Windows.push_back(window);
 5939|       |
 5940|      4|    return window;
 5941|      4|}
imgui.cpp:_ZL28UpdateWindowInFocusOrderListP11ImGuiWindowbi:
 5865|  84.6k|{
 5866|  84.6k|    ImGuiContext& g = *GImGui;
 5867|       |
 5868|  84.6k|    const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
  ------------------
  |  Branch (5868:40): [True: 25.9k, False: 58.7k]
  |  Branch (5868:92): [True: 25.9k, False: 0]
  |  Branch (5868:137): [True: 0, False: 0]
  ------------------
 5869|  84.6k|    const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
 5870|  84.6k|    if ((just_created || child_flag_changed) && !new_is_explicit_child)
  ------------------
  |  Branch (5870:10): [True: 4, False: 84.6k]
  |  Branch (5870:26): [True: 0, False: 84.6k]
  |  Branch (5870:49): [True: 3, False: 1]
  ------------------
 5871|      3|    {
 5872|      3|        IM_ASSERT(!g.WindowsFocusOrder.contains(window));
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5873|      3|        g.WindowsFocusOrder.push_back(window);
 5874|      3|        window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
 5875|      3|    }
 5876|  84.6k|    else if (!just_created && child_flag_changed && new_is_explicit_child)
  ------------------
  |  Branch (5876:14): [True: 84.6k, False: 1]
  |  Branch (5876:31): [True: 0, False: 84.6k]
  |  Branch (5876:53): [True: 0, False: 0]
  ------------------
 5877|      0|    {
 5878|      0|        IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5879|      0|        for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
  ------------------
  |  Branch (5879:46): [True: 0, False: 0]
  ------------------
 5880|      0|            g.WindowsFocusOrder[n]->FocusOrder--;
 5881|      0|        g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
 5882|      0|        window->FocusOrder = -1;
 5883|      0|    }
 5884|  84.6k|    window->IsExplicitChild = new_is_explicit_child;
 5885|  84.6k|}
imgui.cpp:_ZL28SetWindowConditionAllowFlagsP11ImGuiWindowib:
 5828|     30|{
 5829|     30|    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
  ------------------
  |  Branch (5829:44): [True: 15, False: 15]
  ------------------
 5830|     30|    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
  ------------------
  |  Branch (5830:44): [True: 15, False: 15]
  ------------------
 5831|     30|    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
  ------------------
  |  Branch (5831:44): [True: 15, False: 15]
  ------------------
 5832|     30|    window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
  ------------------
  |  Branch (5832:44): [True: 15, False: 15]
  ------------------
 5833|     30|}
imgui.cpp:_ZL16SetCurrentWindowP11ImGuiWindow:
 3909|   169k|{
 3910|   169k|    ImGuiContext& g = *GImGui;
 3911|   169k|    g.CurrentWindow = window;
 3912|   169k|    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
  ------------------
  |  Branch (3912:22): [True: 140k, False: 29.3k]
  |  Branch (3912:32): [True: 0, False: 140k]
  ------------------
 3913|   169k|    if (window)
  ------------------
  |  Branch (3913:9): [True: 140k, False: 29.3k]
  ------------------
 3914|   140k|    {
 3915|   140k|        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
 3916|   140k|        ImGui::NavUpdateCurrentWindowIsScrollPushableX();
 3917|   140k|    }
 3918|   169k|}
imgui.cpp:_ZL14ClampWindowPosP11ImGuiWindowRK6ImRect:
 6306|  58.7k|{
 6307|  58.7k|    ImGuiContext& g = *GImGui;
 6308|  58.7k|    ImVec2 size_for_clamping = window->Size;
 6309|  58.7k|    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && (!(window->Flags & ImGuiWindowFlags_NoTitleBar) || window->DockNodeAsHost))
  ------------------
  |  Branch (6309:9): [True: 0, False: 58.7k]
  |  Branch (6309:52): [True: 0, False: 0]
  |  Branch (6309:102): [True: 0, False: 0]
  ------------------
 6310|      0|        size_for_clamping.y = ImGui::GetFrameHeight(); // Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
 6311|  58.7k|    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
 6312|  58.7k|}
imgui.cpp:_ZN5ImGuiL24UpdateWindowManualResizeEP11ImGuiWindowRK6ImVec2PiiPjRK6ImRect:
 6151|  81.2k|{
 6152|  81.2k|    ImGuiContext& g = *GImGui;
 6153|  81.2k|    ImGuiWindowFlags flags = window->Flags;
 6154|       |
 6155|  81.2k|    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6155:9): [True: 25.9k, False: 55.3k]
  |  Branch (6155:48): [True: 0, False: 55.3k]
  |  Branch (6155:95): [True: 2, False: 55.3k]
  |  Branch (6155:125): [True: 0, False: 55.3k]
  ------------------
 6156|  25.9k|        return false;
 6157|  55.3k|    if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
  ------------------
  |  Branch (6157:9): [True: 29.3k, False: 25.9k]
  ------------------
 6158|  29.3k|        return false;
 6159|       |
 6160|  25.9k|    bool ret_auto_fit = false;
 6161|  25.9k|    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
  ------------------
  |  Branch (6161:37): [True: 0, False: 25.9k]
  ------------------
 6162|  25.9k|    const float grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  284|  25.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 6163|  25.9k|    const float grip_hover_inner_size = IM_TRUNC(grip_draw_size * 0.75f);
  ------------------
  |  |  284|  25.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 6164|  25.9k|    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;
  ------------------
  |  Branch (6164:41): [True: 0, False: 25.9k]
  ------------------
 6165|       |
 6166|  25.9k|    ImRect clamp_rect = visibility_rect;
 6167|  25.9k|    const bool window_move_from_title_bar = g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar);
  ------------------
  |  Branch (6167:45): [True: 0, False: 25.9k]
  |  Branch (6167:87): [True: 0, False: 0]
  ------------------
 6168|  25.9k|    if (window_move_from_title_bar)
  ------------------
  |  Branch (6168:9): [True: 0, False: 25.9k]
  ------------------
 6169|      0|        clamp_rect.Min.y -= window->TitleBarHeight();
 6170|       |
 6171|  25.9k|    ImVec2 pos_target(FLT_MAX, FLT_MAX);
 6172|  25.9k|    ImVec2 size_target(FLT_MAX, FLT_MAX);
 6173|       |
 6174|       |    // Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
 6175|       |    // - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
 6176|       |    //   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
 6177|       |    // - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
 6178|       |    // - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
 6179|       |    // We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
 6180|  25.9k|    const bool clip_with_viewport_rect = !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport) || (g.IO.MouseHoveredViewport != window->ViewportId) || !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration);
  ------------------
  |  Branch (6180:42): [True: 25.9k, False: 0]
  |  Branch (6180:110): [True: 0, False: 0]
  |  Branch (6180:163): [True: 0, False: 0]
  ------------------
 6181|  25.9k|    if (clip_with_viewport_rect)
  ------------------
  |  Branch (6181:9): [True: 25.9k, False: 0]
  ------------------
 6182|  25.9k|        window->ClipRect = window->Viewport->GetMainRect();
 6183|       |
 6184|       |    // Resize grips and borders are on layer 1
 6185|  25.9k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 6186|       |
 6187|       |    // Manual resize grips
 6188|  25.9k|    PushID("#RESIZE");
 6189|  51.8k|    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (6189:33): [True: 25.9k, False: 25.9k]
  ------------------
 6190|  25.9k|    {
 6191|  25.9k|        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];
 6192|  25.9k|        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);
 6193|       |
 6194|       |        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
 6195|  25.9k|        bool hovered, held;
 6196|  25.9k|        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
 6197|  25.9k|        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
  ------------------
  |  Branch (6197:13): [True: 25.9k, False: 0]
  ------------------
 6198|  25.9k|        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
  ------------------
  |  Branch (6198:13): [True: 25.9k, False: 0]
  ------------------
 6199|  25.9k|        ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
 6200|  25.9k|        ItemAdd(resize_rect, resize_grip_id, NULL, ImGuiItemFlags_NoNav);
 6201|  25.9k|        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 6202|       |        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
 6203|  25.9k|        if (hovered || held)
  ------------------
  |  Branch (6203:13): [True: 0, False: 25.9k]
  |  Branch (6203:24): [True: 0, False: 25.9k]
  ------------------
 6204|      0|            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;
  ------------------
  |  Branch (6204:29): [True: 0, False: 0]
  ------------------
 6205|       |
 6206|  25.9k|        if (held && g.IO.MouseClickedCount[0] == 2 && resize_grip_n == 0)
  ------------------
  |  Branch (6206:13): [True: 0, False: 25.9k]
  |  Branch (6206:21): [True: 0, False: 0]
  |  Branch (6206:55): [True: 0, False: 0]
  ------------------
 6207|      0|        {
 6208|       |            // Manual auto-fit when double-clicking
 6209|      0|            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 6210|      0|            ret_auto_fit = true;
 6211|      0|            ClearActiveID();
 6212|      0|        }
 6213|  25.9k|        else if (held)
  ------------------
  |  Branch (6213:18): [True: 0, False: 25.9k]
  ------------------
 6214|      0|        {
 6215|       |            // Resize from any of the four corners
 6216|       |            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
 6217|      0|            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? clamp_rect.Min.x : -FLT_MAX, (def.CornerPosN.y == 1.0f || (def.CornerPosN.y == 0.0f && window_move_from_title_bar)) ? clamp_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (6217:39): [True: 0, False: 0]
  |  Branch (6217:96): [True: 0, False: 0]
  |  Branch (6217:125): [True: 0, False: 0]
  |  Branch (6217:153): [True: 0, False: 0]
  ------------------
 6218|      0|            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? clamp_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? clamp_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (6218:39): [True: 0, False: 0]
  |  Branch (6218:95): [True: 0, False: 0]
  ------------------
 6219|      0|            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
 6220|      0|            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
 6221|      0|            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
 6222|      0|        }
 6223|       |
 6224|       |        // Only lower-left grip is visible before hovering/activating
 6225|  25.9k|        if (resize_grip_n == 0 || held || hovered)
  ------------------
  |  Branch (6225:13): [True: 25.9k, False: 0]
  |  Branch (6225:35): [True: 0, False: 0]
  |  Branch (6225:43): [True: 0, False: 0]
  ------------------
 6226|  25.9k|            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
  ------------------
  |  Branch (6226:58): [True: 0, False: 25.9k]
  |  Branch (6226:93): [True: 0, False: 25.9k]
  ------------------
 6227|  25.9k|    }
 6228|  25.9k|    for (int border_n = 0; border_n < resize_border_count; border_n++)
  ------------------
  |  Branch (6228:28): [True: 0, False: 25.9k]
  ------------------
 6229|      0|    {
 6230|      0|        const ImGuiResizeBorderDef& def = resize_border_def[border_n];
 6231|      0|        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
  ------------------
  |  Branch (6231:33): [True: 0, False: 0]
  |  Branch (6231:62): [True: 0, False: 0]
  ------------------
 6232|       |
 6233|      0|        bool hovered, held;
 6234|      0|        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
 6235|      0|        ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
 6236|      0|        ItemAdd(border_rect, border_id, NULL, ImGuiItemFlags_NoNav);
 6237|      0|        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 6238|       |        //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
 6239|      0|        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
  ------------------
  |  Branch (6239:14): [True: 0, False: 0]
  |  Branch (6239:25): [True: 0, False: 0]
  |  Branch (6239:89): [True: 0, False: 0]
  ------------------
 6240|      0|        {
 6241|      0|            g.MouseCursor = (axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
  ------------------
  |  Branch (6241:29): [True: 0, False: 0]
  ------------------
 6242|      0|            if (held)
  ------------------
  |  Branch (6242:17): [True: 0, False: 0]
  ------------------
 6243|      0|                *border_held = border_n;
 6244|      0|        }
 6245|      0|        if (held)
  ------------------
  |  Branch (6245:13): [True: 0, False: 0]
  ------------------
 6246|      0|        {
 6247|      0|            ImVec2 clamp_min(border_n == ImGuiDir_Right ? clamp_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down || (border_n == ImGuiDir_Up && window_move_from_title_bar) ? clamp_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (6247:30): [True: 0, False: 0]
  |  Branch (6247:88): [True: 0, False: 0]
  |  Branch (6247:118): [True: 0, False: 0]
  |  Branch (6247:145): [True: 0, False: 0]
  ------------------
 6248|      0|            ImVec2 clamp_max(border_n == ImGuiDir_Left ? clamp_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up ? clamp_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (6248:30): [True: 0, False: 0]
  |  Branch (6248:87): [True: 0, False: 0]
  ------------------
 6249|      0|            ImVec2 border_target = window->Pos;
 6250|      0|            border_target[axis] = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING;
 6251|      0|            border_target = ImClamp(border_target, clamp_min, clamp_max);
 6252|      0|            CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
 6253|      0|        }
 6254|      0|    }
 6255|  25.9k|    PopID();
 6256|       |
 6257|       |    // Restore nav layer
 6258|  25.9k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 6259|       |
 6260|       |    // Navigation resize (keyboard/gamepad)
 6261|       |    // FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
 6262|       |    // Not even sure the callback works here.
 6263|  25.9k|    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindowDockTree == window)
  ------------------
  |  Branch (6263:9): [True: 0, False: 25.9k]
  |  Branch (6263:33): [True: 0, False: 0]
  ------------------
 6264|      0|    {
 6265|      0|        ImVec2 nav_resize_dir;
 6266|      0|        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
  ------------------
  |  Branch (6266:13): [True: 0, False: 0]
  |  Branch (6266:62): [True: 0, False: 0]
  ------------------
 6267|      0|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
 6268|      0|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (6268:13): [True: 0, False: 0]
  ------------------
 6269|      0|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);
 6270|      0|        if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f)
  ------------------
  |  Branch (6270:13): [True: 0, False: 0]
  |  Branch (6270:41): [True: 0, False: 0]
  ------------------
 6271|      0|        {
 6272|      0|            const float NAV_RESIZE_SPEED = 600.0f;
 6273|      0|            const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
 6274|      0|            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
 6275|      0|            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window->Pos - window->Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window->Pos - window->Size
 6276|      0|            g.NavWindowingToggleLayer = false;
 6277|      0|            g.NavDisableMouseHover = true;
 6278|      0|            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
 6279|      0|            ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaSize);
 6280|      0|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (6280:17): [True: 0, False: 0]
  |  Branch (6280:44): [True: 0, False: 0]
  ------------------
 6281|      0|            {
 6282|       |                // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
 6283|      0|                size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);
 6284|      0|                g.NavWindowingAccumDeltaSize -= accum_floored;
 6285|      0|            }
 6286|      0|        }
 6287|      0|    }
 6288|       |
 6289|       |    // Apply back modified position/size to window
 6290|  25.9k|    if (size_target.x != FLT_MAX)
  ------------------
  |  Branch (6290:9): [True: 0, False: 25.9k]
  ------------------
 6291|      0|    {
 6292|      0|        window->SizeFull = size_target;
 6293|      0|        MarkIniSettingsDirty(window);
 6294|      0|    }
 6295|  25.9k|    if (pos_target.x != FLT_MAX)
  ------------------
  |  Branch (6295:9): [True: 0, False: 25.9k]
  ------------------
 6296|      0|    {
 6297|      0|        window->Pos = ImTrunc(pos_target);
 6298|      0|        MarkIniSettingsDirty(window);
 6299|      0|    }
 6300|       |
 6301|  25.9k|    window->Size = window->SizeFull;
 6302|  25.9k|    return ret_auto_fit;
 6303|  55.3k|}
imgui.cpp:_ZN5ImGuiL23RenderWindowDecorationsEP11ImGuiWindowRK6ImRectbbiPKjf:
 6341|  84.6k|{
 6342|  84.6k|    ImGuiContext& g = *GImGui;
 6343|  84.6k|    ImGuiStyle& style = g.Style;
 6344|  84.6k|    ImGuiWindowFlags flags = window->Flags;
 6345|       |
 6346|       |    // Ensure that ScrollBar doesn't read last frame's SkipItems
 6347|  84.6k|    IM_ASSERT(window->BeginCount == 0);
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6348|  84.6k|    window->SkipItems = false;
 6349|       |
 6350|       |    // Draw window + handle manual resize
 6351|       |    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
 6352|  84.6k|    const float window_rounding = window->WindowRounding;
 6353|  84.6k|    const float window_border_size = window->WindowBorderSize;
 6354|  84.6k|    if (window->Collapsed)
  ------------------
  |  Branch (6354:9): [True: 3.41k, False: 81.2k]
  ------------------
 6355|  3.41k|    {
 6356|       |        // Title bar only
 6357|  3.41k|        const float backup_border_size = style.FrameBorderSize;
 6358|  3.41k|        g.Style.FrameBorderSize = window->WindowBorderSize;
 6359|  3.41k|        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
  ------------------
  |  Branch (6359:44): [True: 12, False: 3.40k]
  |  Branch (6359:70): [True: 0, False: 12]
  ------------------
 6360|  3.41k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6360:13): [True: 0, False: 3.41k]
  ------------------
 6361|      0|            title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
  ------------------
  |  | 2583|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6362|  3.41k|        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
 6363|  3.41k|        g.Style.FrameBorderSize = backup_border_size;
 6364|  3.41k|    }
 6365|  81.2k|    else
 6366|  81.2k|    {
 6367|       |        // Window background
 6368|  81.2k|        if (!(flags & ImGuiWindowFlags_NoBackground))
  ------------------
  |  Branch (6368:13): [True: 81.2k, False: 0]
  ------------------
 6369|  81.2k|        {
 6370|  81.2k|            bool is_docking_transparent_payload = false;
 6371|  81.2k|            if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
  ------------------
  |  Branch (6371:17): [True: 0, False: 81.2k]
  |  Branch (6371:37): [True: 0, False: 0]
  |  Branch (6371:89): [True: 0, False: 0]
  ------------------
 6372|      0|                if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
  ------------------
  |  |  225|      0|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (6372:21): [True: 0, False: 0]
  |  Branch (6372:80): [True: 0, False: 0]
  ------------------
 6373|      0|                    is_docking_transparent_payload = true;
 6374|       |
 6375|  81.2k|            ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
 6376|  81.2k|            if (window->ViewportOwned)
  ------------------
  |  Branch (6376:17): [True: 0, False: 81.2k]
  ------------------
 6377|      0|            {
 6378|      0|                bg_col |= IM_COL32_A_MASK; // No alpha
  ------------------
  |  | 2583|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6379|      0|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6379:21): [True: 0, False: 0]
  ------------------
 6380|      0|                    window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
 6381|      0|            }
 6382|  81.2k|            else
 6383|  81.2k|            {
 6384|       |                // Adjust alpha. For docking
 6385|  81.2k|                bool override_alpha = false;
 6386|  81.2k|                float alpha = 1.0f;
 6387|  81.2k|                if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
  ------------------
  |  Branch (6387:21): [True: 0, False: 81.2k]
  ------------------
 6388|      0|                {
 6389|      0|                    alpha = g.NextWindowData.BgAlphaVal;
 6390|      0|                    override_alpha = true;
 6391|      0|                }
 6392|  81.2k|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6392:21): [True: 0, False: 81.2k]
  ------------------
 6393|      0|                {
 6394|      0|                    alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
 6395|      0|                    override_alpha = true;
 6396|      0|                }
 6397|  81.2k|                if (override_alpha)
  ------------------
  |  Branch (6397:21): [True: 0, False: 81.2k]
  ------------------
 6398|      0|                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2583|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  |  283|      0|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  ------------------
 6399|  81.2k|            }
 6400|       |
 6401|       |            // Render, for docked windows and host windows we ensure bg goes before decorations
 6402|  81.2k|            if (window->DockIsActive)
  ------------------
  |  Branch (6402:17): [True: 0, False: 81.2k]
  ------------------
 6403|      0|                window->DockNode->LastBgColor = bg_col;
 6404|  81.2k|            ImDrawList* bg_draw_list = window->DockIsActive ? window->DockNode->HostWindow->DrawList : window->DrawList;
  ------------------
  |  Branch (6404:40): [True: 0, False: 81.2k]
  ------------------
 6405|  81.2k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6405:17): [True: 0, False: 81.2k]
  |  Branch (6405:41): [True: 0, False: 81.2k]
  ------------------
 6406|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1691|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
 6407|  81.2k|            bg_draw_list->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
  ------------------
  |  Branch (6407:145): [True: 25.9k, False: 55.3k]
  ------------------
 6408|  81.2k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6408:17): [True: 0, False: 81.2k]
  |  Branch (6408:41): [True: 0, False: 81.2k]
  ------------------
 6409|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
  ------------------
  |  | 1692|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 6410|  81.2k|        }
 6411|  81.2k|        if (window->DockIsActive)
  ------------------
  |  Branch (6411:13): [True: 0, False: 81.2k]
  ------------------
 6412|      0|            window->DockNode->IsBgDrawnThisFrame = true;
 6413|       |
 6414|       |        // Title bar
 6415|       |        // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
 6416|       |        // in order for their pos/size to be matching their undocking state.)
 6417|  81.2k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6417:13): [True: 55.3k, False: 25.9k]
  |  Branch (6417:55): [True: 55.3k, False: 0]
  ------------------
 6418|  55.3k|        {
 6419|  55.3k|            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
  ------------------
  |  Branch (6419:47): [True: 18.3k, False: 36.9k]
  ------------------
 6420|  55.3k|            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
 6421|  55.3k|        }
 6422|       |
 6423|       |        // Menu bar
 6424|  81.2k|        if (flags & ImGuiWindowFlags_MenuBar)
  ------------------
  |  Branch (6424:13): [True: 0, False: 81.2k]
  ------------------
 6425|      0|        {
 6426|      0|            ImRect menu_bar_rect = window->MenuBarRect();
 6427|      0|            menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
 6428|      0|            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
  ------------------
  |  Branch (6428:180): [True: 0, False: 0]
  ------------------
 6429|      0|            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
  ------------------
  |  Branch (6429:17): [True: 0, False: 0]
  |  Branch (6429:49): [True: 0, False: 0]
  ------------------
 6430|      0|                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
 6431|      0|        }
 6432|       |
 6433|       |        // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
 6434|  81.2k|        ImGuiDockNode* node = window->DockNode;
 6435|  81.2k|        if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
  ------------------
  |  Branch (6435:13): [True: 0, False: 81.2k]
  |  Branch (6435:37): [True: 0, False: 0]
  |  Branch (6435:63): [True: 0, False: 0]
  ------------------
 6436|      0|        {
 6437|      0|            float unhide_sz_draw = ImTrunc(g.FontSize * 0.70f);
 6438|      0|            float unhide_sz_hit = ImTrunc(g.FontSize * 0.55f);
 6439|      0|            ImVec2 p = node->Pos;
 6440|      0|            ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
 6441|      0|            ImGuiID unhide_id = window->GetID("#UNHIDE");
 6442|      0|            KeepAliveID(unhide_id);
 6443|      0|            bool hovered, held;
 6444|      0|            if (ButtonBehavior(r, unhide_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren))
  ------------------
  |  Branch (6444:17): [True: 0, False: 0]
  ------------------
 6445|      0|                node->WantHiddenTabBarToggle = true;
 6446|      0|            else if (held && IsMouseDragging(0))
  ------------------
  |  Branch (6446:22): [True: 0, False: 0]
  |  Branch (6446:30): [True: 0, False: 0]
  ------------------
 6447|      0|                StartMouseMovingWindowOrNode(window, node, true);
 6448|       |
 6449|       |            // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
 6450|      0|            ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (6450:39): [True: 0, False: 0]
  |  Branch (6450:47): [True: 0, False: 0]
  |  Branch (6450:60): [True: 0, False: 0]
  |  Branch (6450:79): [True: 0, False: 0]
  |  Branch (6450:116): [True: 0, False: 0]
  ------------------
 6451|      0|            window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
 6452|      0|        }
 6453|       |
 6454|       |        // Scrollbars
 6455|  81.2k|        if (window->ScrollbarX)
  ------------------
  |  Branch (6455:13): [True: 25.9k, False: 55.3k]
  ------------------
 6456|  25.9k|            Scrollbar(ImGuiAxis_X);
 6457|  81.2k|        if (window->ScrollbarY)
  ------------------
  |  Branch (6457:13): [True: 26.3k, False: 54.8k]
  ------------------
 6458|  26.3k|            Scrollbar(ImGuiAxis_Y);
 6459|       |
 6460|       |        // Render resize grips (after their input handling so we don't have a frame of latency)
 6461|  81.2k|        if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
  ------------------
  |  Branch (6461:13): [True: 81.2k, False: 0]
  |  Branch (6461:48): [True: 55.3k, False: 25.9k]
  ------------------
 6462|  55.3k|        {
 6463|   110k|            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (6463:41): [True: 55.3k, False: 55.3k]
  ------------------
 6464|  55.3k|            {
 6465|  55.3k|                const ImU32 col = resize_grip_col[resize_grip_n];
 6466|  55.3k|                if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|  55.3k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (6466:21): [True: 29.3k, False: 25.9k]
  ------------------
 6467|  29.3k|                    continue;
 6468|  25.9k|                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
 6469|  25.9k|                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
 6470|  25.9k|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
  ------------------
  |  Branch (6470:72): [True: 0, False: 25.9k]
  ------------------
 6471|  25.9k|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
  ------------------
  |  Branch (6471:72): [True: 0, False: 25.9k]
  ------------------
 6472|  25.9k|                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
 6473|  25.9k|                window->DrawList->PathFillConvex(col);
 6474|  25.9k|            }
 6475|  55.3k|        }
 6476|       |
 6477|       |        // Borders (for dock node host they will be rendered over after the tab bar)
 6478|  81.2k|        if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
  ------------------
  |  Branch (6478:13): [True: 81.2k, False: 0]
  |  Branch (6478:48): [True: 81.2k, False: 0]
  ------------------
 6479|  81.2k|            RenderWindowOuterBorders(window);
 6480|  81.2k|    }
 6481|  84.6k|}
imgui.cpp:_ZL19GetWindowBgColorIdxP11ImGuiWindow:
 6062|  81.2k|{
 6063|  81.2k|    if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (6063:9): [True: 17, False: 81.2k]
  ------------------
 6064|     17|        return ImGuiCol_PopupBg;
 6065|  81.2k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !window->DockIsActive)
  ------------------
  |  Branch (6065:9): [True: 25.9k, False: 55.3k]
  |  Branch (6065:59): [True: 25.9k, False: 0]
  ------------------
 6066|  25.9k|        return ImGuiCol_ChildBg;
 6067|  55.3k|    return ImGuiCol_WindowBg;
 6068|  81.2k|}
imgui.cpp:_ZN5ImGuiL24RenderWindowOuterBordersEP11ImGuiWindow:
 6315|  81.2k|{
 6316|  81.2k|    ImGuiContext& g = *GImGui;
 6317|  81.2k|    float rounding = window->WindowRounding;
 6318|  81.2k|    float border_size = window->WindowBorderSize;
 6319|  81.2k|    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))
  ------------------
  |  Branch (6319:9): [True: 68.7k, False: 12.4k]
  |  Branch (6319:31): [True: 68.7k, False: 0]
  ------------------
 6320|  68.7k|        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
 6321|       |
 6322|  81.2k|    int border_held = window->ResizeBorderHeld;
 6323|  81.2k|    if (border_held != -1)
  ------------------
  |  Branch (6323:9): [True: 0, False: 81.2k]
  ------------------
 6324|      0|    {
 6325|      0|        const ImGuiResizeBorderDef& def = resize_border_def[border_held];
 6326|      0|        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
 6327|      0|        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
  ------------------
  |  |  272|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 6328|      0|        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
  ------------------
  |  |  272|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 6329|      0|        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), 0, ImMax(2.0f, border_size)); // Thicker than usual
 6330|      0|    }
 6331|  81.2k|    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6331:9): [True: 0, False: 81.2k]
  |  Branch (6331:40): [True: 0, False: 0]
  |  Branch (6331:90): [True: 0, False: 0]
  ------------------
 6332|      0|    {
 6333|      0|        float y = window->Pos.y + window->TitleBarHeight() - 1;
 6334|      0|        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);
 6335|      0|    }
 6336|  81.2k|}
imgui.cpp:_ZN5ImGuiL28RenderWindowTitleBarContentsEP11ImGuiWindowRK6ImRectPKcPb:
 6486|  58.7k|{
 6487|  58.7k|    ImGuiContext& g = *GImGui;
 6488|  58.7k|    ImGuiStyle& style = g.Style;
 6489|  58.7k|    ImGuiWindowFlags flags = window->Flags;
 6490|       |
 6491|  58.7k|    const bool has_close_button = (p_open != NULL);
 6492|  58.7k|    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);
  ------------------
  |  Branch (6492:38): [True: 58.7k, False: 0]
  |  Branch (6492:80): [True: 58.7k, False: 0]
  ------------------
 6493|       |
 6494|       |    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
 6495|       |    // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
 6496|  58.7k|    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
 6497|  58.7k|    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
 6498|  58.7k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 6499|       |
 6500|       |    // Layout buttons
 6501|       |    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
 6502|  58.7k|    float pad_l = style.FramePadding.x;
 6503|  58.7k|    float pad_r = style.FramePadding.x;
 6504|  58.7k|    float button_sz = g.FontSize;
 6505|  58.7k|    ImVec2 close_button_pos;
 6506|  58.7k|    ImVec2 collapse_button_pos;
 6507|  58.7k|    if (has_close_button)
  ------------------
  |  Branch (6507:9): [True: 0, False: 58.7k]
  ------------------
 6508|      0|    {
 6509|      0|        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
 6510|      0|        pad_r += button_sz + style.ItemInnerSpacing.x;
 6511|      0|    }
 6512|  58.7k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
  ------------------
  |  Branch (6512:9): [True: 58.7k, False: 0]
  |  Branch (6512:32): [True: 0, False: 58.7k]
  ------------------
 6513|      0|    {
 6514|      0|        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
 6515|      0|        pad_r += button_sz + style.ItemInnerSpacing.x;
 6516|      0|    }
 6517|  58.7k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
  ------------------
  |  Branch (6517:9): [True: 58.7k, False: 0]
  |  Branch (6517:32): [True: 58.7k, False: 0]
  ------------------
 6518|  58.7k|    {
 6519|  58.7k|        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y);
 6520|  58.7k|        pad_l += button_sz + style.ItemInnerSpacing.x;
 6521|  58.7k|    }
 6522|       |
 6523|       |    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
 6524|  58.7k|    if (has_collapse_button)
  ------------------
  |  Branch (6524:9): [True: 58.7k, False: 0]
  ------------------
 6525|  58.7k|        if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
  ------------------
  |  Branch (6525:13): [True: 0, False: 58.7k]
  ------------------
 6526|      0|            window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
 6527|       |
 6528|       |    // Close button
 6529|  58.7k|    if (has_close_button)
  ------------------
  |  Branch (6529:9): [True: 0, False: 58.7k]
  ------------------
 6530|      0|        if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
  ------------------
  |  Branch (6530:13): [True: 0, False: 0]
  ------------------
 6531|      0|            *p_open = false;
 6532|       |
 6533|  58.7k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 6534|  58.7k|    g.CurrentItemFlags = item_flags_backup;
 6535|       |
 6536|       |    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
 6537|       |    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
 6538|  58.7k|    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
  ------------------
  |  Branch (6538:33): [True: 0, False: 58.7k]
  ------------------
 6539|  58.7k|    const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
 6540|       |
 6541|       |    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
 6542|       |    // while uncentered title text will still reach edges correctly.
 6543|  58.7k|    if (pad_l > style.FramePadding.x)
  ------------------
  |  Branch (6543:9): [True: 58.7k, False: 0]
  ------------------
 6544|  58.7k|        pad_l += g.Style.ItemInnerSpacing.x;
 6545|  58.7k|    if (pad_r > style.FramePadding.x)
  ------------------
  |  Branch (6545:9): [True: 0, False: 58.7k]
  ------------------
 6546|      0|        pad_r += g.Style.ItemInnerSpacing.x;
 6547|  58.7k|    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
  ------------------
  |  Branch (6547:9): [True: 0, False: 58.7k]
  |  Branch (6547:44): [True: 0, False: 0]
  ------------------
 6548|      0|    {
 6549|      0|        float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
  ------------------
  |  |  446|      0|#define ImFabs(X)           fabsf(X)
  ------------------
 6550|      0|        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
 6551|      0|        pad_l = ImMax(pad_l, pad_extend * centerness);
 6552|      0|        pad_r = ImMax(pad_r, pad_extend * centerness);
 6553|      0|    }
 6554|       |
 6555|  58.7k|    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
 6556|  58.7k|    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
 6557|  58.7k|    if (flags & ImGuiWindowFlags_UnsavedDocument)
  ------------------
  |  Branch (6557:9): [True: 0, False: 58.7k]
  ------------------
 6558|      0|    {
 6559|      0|        ImVec2 marker_pos;
 6560|      0|        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
 6561|      0|        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
 6562|      0|        if (marker_pos.x > layout_r.Min.x)
  ------------------
  |  Branch (6562:13): [True: 0, False: 0]
  ------------------
 6563|      0|        {
 6564|      0|            RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
 6565|      0|            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
 6566|      0|        }
 6567|      0|    }
 6568|       |    //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6569|       |    //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6570|  58.7k|    RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
 6571|  58.7k|}
imgui.cpp:_ZN5ImGuiL20UpdateKeyboardInputsEv:
 9153|  29.3k|{
 9154|  29.3k|    ImGuiContext& g = *GImGui;
 9155|  29.3k|    ImGuiIO& io = g.IO;
 9156|       |
 9157|       |    // Import legacy keys or verify they are not used
 9158|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9159|       |    if (io.BackendUsingLegacyKeyArrays == 0)
 9160|       |    {
 9161|       |        // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
 9162|       |        for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
 9163|       |            IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 9164|       |    }
 9165|       |    else
 9166|       |    {
 9167|       |        if (g.FrameCount == 0)
 9168|       |            for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 9169|       |                IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");
 9170|       |
 9171|       |        // Build reverse KeyMap (Named -> Legacy)
 9172|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 9173|       |            if (io.KeyMap[n] != -1)
 9174|       |            {
 9175|       |                IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
 9176|       |                io.KeyMap[io.KeyMap[n]] = n;
 9177|       |            }
 9178|       |
 9179|       |        // Import legacy keys into new ones
 9180|       |        for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 9181|       |            if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
 9182|       |            {
 9183|       |                const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
 9184|       |                IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
 9185|       |                io.KeysData[key].Down = io.KeysDown[n];
 9186|       |                if (key != n)
 9187|       |                    io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
 9188|       |                io.BackendUsingLegacyKeyArrays = 1;
 9189|       |            }
 9190|       |        if (io.BackendUsingLegacyKeyArrays == 1)
 9191|       |        {
 9192|       |            GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
 9193|       |            GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
 9194|       |            GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
 9195|       |            GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
 9196|       |        }
 9197|       |    }
 9198|       |
 9199|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9200|       |    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
 9201|       |    if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
 9202|       |    {
 9203|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)           do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1]; } while (0)
 9204|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)    do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]); } while (0)
 9205|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
 9206|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
 9207|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
 9208|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
 9209|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
 9210|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadRight, ImGuiNavInput_DpadRight);
 9211|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadUp, ImGuiNavInput_DpadUp);
 9212|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadDown, ImGuiNavInput_DpadDown);
 9213|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadL1, ImGuiNavInput_FocusPrev, ImGuiNavInput_TweakSlow);
 9214|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadR1, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakFast);
 9215|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickLeft, ImGuiNavInput_LStickLeft);
 9216|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickRight, ImGuiNavInput_LStickRight);
 9217|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
 9218|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
 9219|       |        #undef NAV_MAP_KEY
 9220|       |    }
 9221|       |#endif
 9222|       |#endif
 9223|       |
 9224|       |    // Update aliases
 9225|   176k|    for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
  ------------------
  |  Branch (9225:21): [True: 146k, False: 29.3k]
  ------------------
 9226|   146k|        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
  ------------------
  |  Branch (9226:62): [True: 8.49k, False: 138k]
  ------------------
 9227|  29.3k|    UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
 9228|  29.3k|    UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);
 9229|       |
 9230|       |    // Synchronize io.KeyMods and io.KeyXXX values.
 9231|       |    // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 9232|       |    // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 9233|       |    // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
 9234|  29.3k|    io.KeyMods = GetMergedModsFromKeys();
 9235|  29.3k|    io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
 9236|  29.3k|    io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
 9237|  29.3k|    io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
 9238|  29.3k|    io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
 9239|       |
 9240|       |    // Clear gamepad data if disabled
 9241|  29.3k|    if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
  ------------------
  |  Branch (9241:9): [True: 29.3k, False: 0]
  ------------------
 9242|   734k|        for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1313|  29.3k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                      for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1314|   734k|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (9242:46): [True: 704k, False: 29.3k]
  ------------------
 9243|   704k|        {
 9244|   704k|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
 9245|   704k|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
 9246|   704k|        }
 9247|       |
 9248|       |    // Update keys
 9249|  4.14M|    for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
  ------------------
  |  Branch (9249:21): [True: 4.11M, False: 29.3k]
  ------------------
 9250|  4.11M|    {
 9251|  4.11M|        ImGuiKeyData* key_data = &io.KeysData[i];
 9252|  4.11M|        key_data->DownDurationPrev = key_data->DownDuration;
 9253|  4.11M|        key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (9253:34): [True: 29.8k, False: 4.08M]
  |  Branch (9253:52): [True: 2.72k, False: 27.0k]
  ------------------
 9254|  4.11M|    }
 9255|       |
 9256|       |    // Update keys/input owner (named keys only): one entry per key
 9257|  4.14M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (9257:50): [True: 4.11M, False: 29.3k]
  ------------------
 9258|  4.11M|    {
 9259|  4.11M|        ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
 9260|  4.11M|        ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
 9261|  4.11M|        owner_data->OwnerCurr = owner_data->OwnerNext;
 9262|  4.11M|        if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
  ------------------
  |  Branch (9262:13): [True: 4.08M, False: 29.8k]
  ------------------
 9263|  4.08M|            owner_data->OwnerNext = ImGuiKeyOwner_None;
  ------------------
  |  | 1385|  4.08M|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 9264|  4.11M|        owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;  // Clear LockUntilRelease when key is not Down anymore
  ------------------
  |  Branch (9264:68): [True: 0, False: 4.11M]
  |  Branch (9264:100): [True: 0, False: 0]
  ------------------
 9265|  4.11M|    }
 9266|       |
 9267|  29.3k|    UpdateKeyRoutingTable(&g.KeysRoutingTable);
 9268|  29.3k|}
imgui.cpp:_ZL14UpdateAliasKey8ImGuiKeybf:
 9134|   205k|{
 9135|   205k|    IM_ASSERT(ImGui::IsAliasKey(key));
  ------------------
  |  |   23|   205k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9136|   205k|    ImGuiKeyData* key_data = ImGui::GetKeyData(key);
 9137|   205k|    key_data->Down = v;
 9138|   205k|    key_data->AnalogValue = analog_value;
 9139|   205k|}
imgui.cpp:_ZL21GetMergedModsFromKeysv:
 9143|  58.7k|{
 9144|  58.7k|    ImGuiKeyChord mods = 0;
 9145|  58.7k|    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }
  ------------------
  |  Branch (9145:9): [True: 0, False: 58.7k]
  ------------------
 9146|  58.7k|    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }
  ------------------
  |  Branch (9146:9): [True: 0, False: 58.7k]
  ------------------
 9147|  58.7k|    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }
  ------------------
  |  Branch (9147:9): [True: 0, False: 58.7k]
  ------------------
 9148|  58.7k|    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }
  ------------------
  |  Branch (9148:9): [True: 0, False: 58.7k]
  ------------------
 9149|  58.7k|    return mods;
 9150|  58.7k|}
imgui.cpp:_ZN5ImGuiL21UpdateKeyRoutingTableEP20ImGuiKeyRoutingTable:
 8700|  29.3k|{
 8701|  29.3k|    ImGuiContext& g = *GImGui;
 8702|  29.3k|    rt->EntriesNext.resize(0);
 8703|  4.14M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (8703:50): [True: 4.11M, False: 29.3k]
  ------------------
 8704|  4.11M|    {
 8705|  4.11M|        const int new_routing_start_idx = rt->EntriesNext.Size;
 8706|  4.11M|        ImGuiKeyRoutingData* routing_entry;
 8707|  4.11M|        for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
  ------------------
  |  Branch (8707:78): [True: 0, False: 4.11M]
  ------------------
 8708|      0|        {
 8709|      0|            routing_entry = &rt->Entries[old_routing_idx];
 8710|      0|            routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
 8711|      0|            routing_entry->RoutingNext = ImGuiKeyOwner_None;
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 8712|      0|            routing_entry->RoutingNextScore = 255;
 8713|      0|            if (routing_entry->RoutingCurr == ImGuiKeyOwner_None)
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (8713:17): [True: 0, False: 0]
  ------------------
 8714|      0|                continue;
 8715|      0|            rt->EntriesNext.push_back(*routing_entry); // Write alive ones into new buffer
 8716|       |
 8717|       |            // Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
 8718|      0|            if (routing_entry->Mods == g.IO.KeyMods)
  ------------------
  |  Branch (8718:17): [True: 0, False: 0]
  ------------------
 8719|      0|            {
 8720|      0|                ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
 8721|      0|                if (owner_data->OwnerCurr == ImGuiKeyOwner_None)
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (8721:21): [True: 0, False: 0]
  ------------------
 8722|      0|                    owner_data->OwnerCurr = routing_entry->RoutingCurr;
 8723|      0|            }
 8724|      0|        }
 8725|       |
 8726|       |        // Rewrite linked-list
 8727|  4.11M|        rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
  ------------------
  |  Branch (8727:75): [True: 0, False: 4.11M]
  ------------------
 8728|  4.11M|        for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
  ------------------
  |  Branch (8728:45): [True: 0, False: 4.11M]
  ------------------
 8729|      0|            rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
  ------------------
  |  Branch (8729:72): [True: 0, False: 0]
  ------------------
 8730|  4.11M|    }
 8731|  29.3k|    rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
 8732|  29.3k|}
imgui.cpp:_ZN5ImGuiL17UpdateMouseInputsEv:
 9271|  29.3k|{
 9272|  29.3k|    ImGuiContext& g = *GImGui;
 9273|  29.3k|    ImGuiIO& io = g.IO;
 9274|       |
 9275|       |    // Mouse Wheel swapping flag
 9276|       |    // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
 9277|       |    // - We avoid doing it on OSX as it the OS input layer handles this already.
 9278|       |    // - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
 9279|       |    // - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
 9280|  29.3k|    io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;
  ------------------
  |  Branch (9280:36): [True: 0, False: 29.3k]
  |  Branch (9280:51): [True: 0, False: 0]
  ------------------
 9281|       |
 9282|       |    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
 9283|  29.3k|    if (IsMousePosValid(&io.MousePos))
  ------------------
  |  Branch (9283:9): [True: 6.71k, False: 22.6k]
  ------------------
 9284|  6.71k|        io.MousePos = g.MouseLastValidPos = ImFloor(io.MousePos);
 9285|       |
 9286|       |    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
 9287|  29.3k|    if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (9287:9): [True: 6.71k, False: 22.6k]
  |  Branch (9287:42): [True: 6.18k, False: 527]
  ------------------
 9288|  6.18k|        io.MouseDelta = io.MousePos - io.MousePosPrev;
 9289|  23.1k|    else
 9290|  23.1k|        io.MouseDelta = ImVec2(0.0f, 0.0f);
 9291|       |
 9292|       |    // Update stationary timer.
 9293|       |    // FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
 9294|  29.3k|    const float mouse_stationary_threshold = (io.MouseSource == ImGuiMouseSource_Mouse) ? 2.0f : 3.0f; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
  ------------------
  |  Branch (9294:46): [True: 29.3k, False: 0]
  ------------------
 9295|  29.3k|    const bool mouse_stationary = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold);
 9296|  29.3k|    g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0f;
  ------------------
  |  Branch (9296:30): [True: 29.2k, False: 152]
  ------------------
 9297|       |    //IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);
 9298|       |
 9299|       |    // If mouse moved we re-enable mouse hovering in case it was disabled by gamepad/keyboard. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
 9300|  29.3k|    if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
  ------------------
  |  Branch (9300:9): [True: 224, False: 29.1k]
  |  Branch (9300:36): [True: 63, False: 29.0k]
  ------------------
 9301|    287|        g.NavDisableMouseHover = false;
 9302|       |
 9303|   176k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   88|   176k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (9303:21): [True: 146k, False: 29.3k]
  ------------------
 9304|   146k|    {
 9305|   146k|        io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
  ------------------
  |  Branch (9305:30): [True: 8.49k, False: 138k]
  |  Branch (9305:49): [True: 1.10k, False: 7.38k]
  ------------------
 9306|   146k|        io.MouseClickedCount[i] = 0; // Will be filled below
 9307|   146k|        io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
  ------------------
  |  Branch (9307:31): [True: 138k, False: 8.49k]
  |  Branch (9307:51): [True: 394, False: 137k]
  ------------------
 9308|   146k|        io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
 9309|   146k|        io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (9309:35): [True: 8.49k, False: 138k]
  |  Branch (9309:54): [True: 1.10k, False: 7.38k]
  ------------------
 9310|   146k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (9310:13): [True: 1.10k, False: 145k]
  ------------------
 9311|  1.10k|        {
 9312|  1.10k|            bool is_repeated_click = false;
 9313|  1.10k|            if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
  ------------------
  |  Branch (9313:17): [True: 570, False: 538]
  ------------------
 9314|    570|            {
 9315|    570|                ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (9315:47): [True: 329, False: 241]
  ------------------
 9316|    570|                if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
  ------------------
  |  Branch (9316:21): [True: 469, False: 101]
  ------------------
 9317|    469|                    is_repeated_click = true;
 9318|    570|            }
 9319|  1.10k|            if (is_repeated_click)
  ------------------
  |  Branch (9319:17): [True: 469, False: 639]
  ------------------
 9320|    469|                io.MouseClickedLastCount[i]++;
 9321|    639|            else
 9322|    639|                io.MouseClickedLastCount[i] = 1;
 9323|  1.10k|            io.MouseClickedTime[i] = g.Time;
 9324|  1.10k|            io.MouseClickedPos[i] = io.MousePos;
 9325|  1.10k|            io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
 9326|  1.10k|            io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
 9327|  1.10k|            io.MouseDragMaxDistanceSqr[i] = 0.0f;
 9328|  1.10k|        }
 9329|   145k|        else if (io.MouseDown[i])
  ------------------
  |  Branch (9329:18): [True: 7.38k, False: 138k]
  ------------------
 9330|  7.38k|        {
 9331|       |            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
 9332|  7.38k|            ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (9332:43): [True: 2.21k, False: 5.17k]
  ------------------
 9333|  7.38k|            io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
 9334|  7.38k|            io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
  ------------------
  |  Branch (9334:86): [True: 180, False: 7.20k]
  ------------------
 9335|  7.38k|            io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
  ------------------
  |  Branch (9335:86): [True: 183, False: 7.20k]
  ------------------
 9336|  7.38k|        }
 9337|       |
 9338|       |        // We provide io.MouseDoubleClicked[] as a legacy service
 9339|   146k|        io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);
 9340|       |
 9341|       |        // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
 9342|   146k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (9342:13): [True: 1.10k, False: 145k]
  ------------------
 9343|  1.10k|            g.NavDisableMouseHover = false;
 9344|   146k|    }
 9345|  29.3k|}
imgui.cpp:_ZN5ImGuiL16UpdateMouseWheelEv:
 9407|  29.3k|{
 9408|       |    // Reset the locked window if we move the mouse or after the timer elapses.
 9409|       |    // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
 9410|  29.3k|    ImGuiContext& g = *GImGui;
 9411|  29.3k|    if (g.WheelingWindow != NULL)
  ------------------
  |  Branch (9411:9): [True: 8, False: 29.3k]
  ------------------
 9412|      8|    {
 9413|      8|        g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
 9414|      8|        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
  ------------------
  |  Branch (9414:13): [True: 8, False: 0]
  |  Branch (9414:13): [True: 7, False: 1]
  |  Branch (9414:34): [True: 7, False: 1]
  ------------------
 9415|      7|            g.WheelingWindowReleaseTimer = 0.0f;
 9416|      8|        if (g.WheelingWindowReleaseTimer <= 0.0f)
  ------------------
  |  Branch (9416:13): [True: 8, False: 0]
  ------------------
 9417|      8|            LockWheelingWindow(NULL, 0.0f);
 9418|      8|    }
 9419|       |
 9420|  29.3k|    ImVec2 wheel;
 9421|  29.3k|    wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_None) ? g.IO.MouseWheelH : 0.0f;
  ------------------
  |  | 1385|  29.3k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9421:15): [True: 29.3k, False: 0]
  ------------------
 9422|  29.3k|    wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_None) ? g.IO.MouseWheel : 0.0f;
  ------------------
  |  | 1385|  29.3k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9422:15): [True: 29.3k, False: 0]
  ------------------
 9423|       |
 9424|       |    //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
 9425|  29.3k|    ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
  ------------------
  |  Branch (9425:33): [True: 0, False: 29.3k]
  ------------------
 9426|  29.3k|    if (!mouse_window || mouse_window->Collapsed)
  ------------------
  |  Branch (9426:9): [True: 28.8k, False: 545]
  |  Branch (9426:26): [True: 80, False: 465]
  ------------------
 9427|  28.9k|        return;
 9428|       |
 9429|       |    // Zoom / Scale window
 9430|       |    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
 9431|    465|    if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
  ------------------
  |  Branch (9431:9): [True: 20, False: 445]
  |  Branch (9431:28): [True: 0, False: 20]
  |  Branch (9431:44): [True: 0, False: 0]
  ------------------
 9432|      0|    {
 9433|      0|        LockWheelingWindow(mouse_window, wheel.y);
 9434|      0|        ImGuiWindow* window = mouse_window;
 9435|      0|        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
 9436|      0|        const float scale = new_font_scale / window->FontWindowScale;
 9437|      0|        window->FontWindowScale = new_font_scale;
 9438|      0|        if (window == window->RootWindow)
  ------------------
  |  Branch (9438:13): [True: 0, False: 0]
  ------------------
 9439|      0|        {
 9440|      0|            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
 9441|      0|            SetWindowPos(window, window->Pos + offset, 0);
 9442|      0|            window->Size = ImTrunc(window->Size * scale);
 9443|      0|            window->SizeFull = ImTrunc(window->SizeFull * scale);
 9444|      0|        }
 9445|      0|        return;
 9446|      0|    }
 9447|    465|    if (g.IO.KeyCtrl)
  ------------------
  |  Branch (9447:9): [True: 0, False: 465]
  ------------------
 9448|      0|        return;
 9449|       |
 9450|       |    // Mouse wheel scrolling
 9451|       |    // Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
 9452|    465|    if (g.IO.MouseWheelRequestAxisSwap)
  ------------------
  |  Branch (9452:9): [True: 0, False: 465]
  ------------------
 9453|      0|        wheel = ImVec2(wheel.y, 0.0f);
 9454|       |
 9455|       |    // Maintain a rough average of moving magnitude on both axises
 9456|       |    // FIXME: should by based on wall clock time rather than frame-counter
 9457|    465|    g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
 9458|    465|    g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);
 9459|       |
 9460|       |    // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
 9461|    465|    wheel += g.WheelingWindowWheelRemainder;
 9462|    465|    g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
 9463|    465|    if (wheel.x == 0.0f && wheel.y == 0.0f)
  ------------------
  |  Branch (9463:9): [True: 444, False: 21]
  |  Branch (9463:28): [True: 444, False: 0]
  ------------------
 9464|    444|        return;
 9465|       |
 9466|       |    // Mouse wheel scrolling: find target and apply
 9467|       |    // - don't renew lock if axis doesn't apply on the window.
 9468|       |    // - select a main axis when both axises are being moved.
 9469|     21|    if (ImGuiWindow* window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
  ------------------
  |  Branch (9469:22): [True: 21, False: 0]
  ------------------
 9470|     21|        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (9470:13): [True: 21, False: 0]
  |  Branch (9470:70): [True: 21, False: 0]
  ------------------
 9471|     21|        {
 9472|     21|            bool do_scroll[2] = { wheel.x != 0.0f && window->ScrollMax.x != 0.0f, wheel.y != 0.0f && window->ScrollMax.y != 0.0f };
  ------------------
  |  Branch (9472:35): [True: 21, False: 0]
  |  Branch (9472:54): [True: 8, False: 13]
  |  Branch (9472:83): [True: 20, False: 1]
  |  Branch (9472:102): [True: 7, False: 13]
  ------------------
 9473|     21|            if (do_scroll[ImGuiAxis_X] && do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (9473:17): [True: 8, False: 13]
  |  Branch (9473:43): [True: 7, False: 1]
  ------------------
 9474|      7|                do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis_Y : ImGuiAxis_X] = false;
  ------------------
  |  Branch (9474:27): [True: 0, False: 7]
  ------------------
 9475|     21|            if (do_scroll[ImGuiAxis_X])
  ------------------
  |  Branch (9475:17): [True: 1, False: 20]
  ------------------
 9476|      1|            {
 9477|      1|                LockWheelingWindow(window, wheel.x);
 9478|      1|                float max_step = window->InnerRect.GetWidth() * 0.67f;
 9479|      1|                float scroll_step = ImTrunc(ImMin(2 * window->CalcFontSize(), max_step));
 9480|      1|                SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
 9481|      1|            }
 9482|     21|            if (do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (9482:17): [True: 7, False: 14]
  ------------------
 9483|      7|            {
 9484|      7|                LockWheelingWindow(window, wheel.y);
 9485|      7|                float max_step = window->InnerRect.GetHeight() * 0.67f;
 9486|      7|                float scroll_step = ImTrunc(ImMin(5 * window->CalcFontSize(), max_step));
 9487|      7|                SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
 9488|      7|            }
 9489|     21|        }
 9490|     21|}
imgui.cpp:_ZL18LockWheelingWindowP11ImGuiWindowf:
 9348|     16|{
 9349|     16|    ImGuiContext& g = *GImGui;
 9350|     16|    if (window)
  ------------------
  |  Branch (9350:9): [True: 8, False: 8]
  ------------------
 9351|      8|        g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
 9352|      8|    else
 9353|      8|        g.WheelingWindowReleaseTimer = 0.0f;
 9354|     16|    if (g.WheelingWindow == window)
  ------------------
  |  Branch (9354:9): [True: 0, False: 16]
  ------------------
 9355|      0|        return;
 9356|     16|    IMGUI_DEBUG_LOG_IO("[io] LockWheelingWindow() \"%s\"\n", window ? window->Name : "NULL");
  ------------------
  |  |  249|     16|#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (249:50): [True: 0, False: 16]
  |  |  |  Branch (249:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 9357|     16|    g.WheelingWindow = window;
 9358|     16|    g.WheelingWindowRefMousePos = g.IO.MousePos;
 9359|     16|    if (window == NULL)
  ------------------
  |  Branch (9359:9): [True: 8, False: 8]
  ------------------
 9360|      8|    {
 9361|      8|        g.WheelingWindowStartFrame = -1;
 9362|      8|        g.WheelingAxisAvg = ImVec2(0.0f, 0.0f);
 9363|      8|    }
 9364|     16|}
imgui.cpp:_ZL22FindBestWheelingWindowRK6ImVec2:
 9367|     21|{
 9368|       |    // For each axis, find window in the hierarchy that may want to use scrolling
 9369|     21|    ImGuiContext& g = *GImGui;
 9370|     21|    ImGuiWindow* windows[2] = { NULL, NULL };
 9371|     63|    for (int axis = 0; axis < 2; axis++)
  ------------------
  |  Branch (9371:24): [True: 42, False: 21]
  ------------------
 9372|     42|        if (wheel[axis] != 0.0f)
  ------------------
  |  Branch (9372:13): [True: 41, False: 1]
  ------------------
 9373|     63|            for (ImGuiWindow* window = windows[axis] = g.HoveredWindow; window->Flags & ImGuiWindowFlags_ChildWindow; window = windows[axis] = window->ParentWindow)
  ------------------
  |  Branch (9373:73): [True: 22, False: 41]
  ------------------
 9374|     22|            {
 9375|       |                // Bubble up into parent window if:
 9376|       |                // - a child window doesn't allow any scrolling.
 9377|       |                // - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
 9378|       |                //// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
 9379|     22|                const bool has_scrolling = (window->ScrollMax[axis] != 0.0f);
 9380|     22|                const bool inputs_disabled = (window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs);
  ------------------
  |  Branch (9380:46): [True: 0, False: 22]
  |  Branch (9380:102): [True: 0, False: 0]
  ------------------
 9381|       |                //const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >= window->ScrollMax[axis]);
 9382|     22|                if (has_scrolling && !inputs_disabled) // && !scrolling_past_limits)
  ------------------
  |  Branch (9382:21): [True: 0, False: 22]
  |  Branch (9382:38): [True: 0, False: 0]
  ------------------
 9383|      0|                    break; // select this window
 9384|     22|            }
 9385|     21|    if (windows[0] == NULL && windows[1] == NULL)
  ------------------
  |  Branch (9385:9): [True: 0, False: 21]
  |  Branch (9385:31): [True: 0, False: 0]
  ------------------
 9386|      0|        return NULL;
 9387|       |
 9388|       |    // If there's only one window or only one axis then there's no ambiguity
 9389|     21|    if (windows[0] == windows[1] || windows[0] == NULL || windows[1] == NULL)
  ------------------
  |  Branch (9389:9): [True: 20, False: 1]
  |  Branch (9389:37): [True: 0, False: 1]
  |  Branch (9389:59): [True: 1, False: 0]
  ------------------
 9390|     21|        return windows[1] ? windows[1] : windows[0];
  ------------------
  |  Branch (9390:16): [True: 20, False: 1]
  ------------------
 9391|       |
 9392|       |    // If candidate are different windows we need to decide which one to prioritize
 9393|       |    // - First frame: only find a winner if one axis is zero.
 9394|       |    // - Subsequent frames: only find a winner when one is more than the other.
 9395|      0|    if (g.WheelingWindowStartFrame == -1)
  ------------------
  |  Branch (9395:9): [True: 0, False: 0]
  ------------------
 9396|      0|        g.WheelingWindowStartFrame = g.FrameCount;
 9397|      0|    if ((g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0f && wheel.y != 0.0f) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y))
  ------------------
  |  Branch (9397:10): [True: 0, False: 0]
  |  Branch (9397:56): [True: 0, False: 0]
  |  Branch (9397:75): [True: 0, False: 0]
  |  Branch (9397:95): [True: 0, False: 0]
  ------------------
 9398|      0|    {
 9399|      0|        g.WheelingWindowWheelRemainder = wheel;
 9400|      0|        return NULL;
 9401|      0|    }
 9402|      0|    return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
  ------------------
  |  Branch (9402:12): [True: 0, False: 0]
  ------------------
 9403|      0|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckNewFrameSanityChecksEv:
 9848|  29.3k|{
 9849|  29.3k|    ImGuiContext& g = *GImGui;
 9850|       |
 9851|       |    // Check user IM_ASSERT macro
 9852|       |    // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
 9853|       |    //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
 9854|       |    //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
 9855|       |    // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
 9856|       |    // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
 9857|  29.3k|    if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9857:9): [Folded - Ignored]
  ------------------
 9858|       |
 9859|       |    // Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
 9860|       |    // Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
 9861|       |#ifdef __EMSCRIPTEN__
 9862|       |    if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
 9863|       |        g.IO.DeltaTime = 0.00001f;
 9864|       |#endif
 9865|       |
 9866|       |    // Check user data
 9867|       |    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
 9868|  29.3k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9869|  29.3k|    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9870|  29.3k|    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9871|  29.3k|    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9872|  29.3k|    IM_ASSERT(g.IO.Fonts->IsBuilt()                                     && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9873|  29.3k|    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9874|  29.3k|    IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f                 && "Invalid style setting!");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9875|  29.3k|    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9876|  29.3k|    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9877|  29.3k|    IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9878|  29.3k|    IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9879|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9880|       |    for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
 9881|       |        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");
 9882|       |
 9883|       |    // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
 9884|       |    if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
 9885|       |        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
 9886|       |#endif
 9887|       |
 9888|       |    // Check: the io.ConfigWindowsResizeFromEdges option requires backend to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
 9889|  29.3k|    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
  ------------------
  |  Branch (9889:9): [True: 1, False: 29.3k]
  |  Branch (9889:46): [True: 1, False: 0]
  ------------------
 9890|      1|        g.IO.ConfigWindowsResizeFromEdges = false;
 9891|       |
 9892|       |    // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
 9893|  29.3k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
  ------------------
  |  Branch (9893:9): [True: 2, False: 29.3k]
  |  Branch (9893:30): [True: 2, False: 0]
  |  Branch (9893:85): [True: 0, False: 2]
  ------------------
 9894|  29.3k|        IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9895|  29.3k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
  ------------------
  |  Branch (9895:9): [True: 2, False: 29.3k]
  |  Branch (9895:30): [True: 0, False: 2]
  |  Branch (9895:87): [True: 0, False: 0]
  ------------------
 9896|  29.3k|        IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9897|       |
 9898|       |    // Perform simple checks: multi-viewport and platform windows support
 9899|  29.3k|    if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (9899:9): [True: 1, False: 29.3k]
  ------------------
 9900|      1|    {
 9901|      1|        if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
  ------------------
  |  Branch (9901:13): [True: 0, False: 1]
  |  Branch (9901:77): [True: 0, False: 0]
  ------------------
 9902|      0|        {
 9903|      0|            IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9904|      0|            IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9905|      0|            IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9906|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9907|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9908|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9909|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9910|      0|            IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9911|      0|            IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9912|      0|            if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (9912:17): [True: 0, False: 0]
  |  Branch (9912:57): [True: 0, False: 0]
  ------------------
 9913|      0|                IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9914|      0|        }
 9915|      1|        else
 9916|      1|        {
 9917|       |            // Disable feature, our backends do not support it
 9918|      1|            g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
 9919|      1|        }
 9920|       |
 9921|       |        // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
 9922|      1|        for (ImGuiPlatformMonitor& mon : g.PlatformIO.Monitors)
  ------------------
  |  Branch (9922:40): [True: 0, False: 1]
  ------------------
 9923|      0|        {
 9924|      0|            IM_UNUSED(mon);
  ------------------
  |  |   89|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9925|      0|            IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9926|      0|            IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9927|      0|            IM_ASSERT(mon.DpiScale != 0.0f);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9928|      0|        }
 9929|      1|    }
 9930|  29.3k|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckEndFrameSanityChecksEv:
 9933|  29.3k|{
 9934|  29.3k|    ImGuiContext& g = *GImGui;
 9935|       |
 9936|       |    // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
 9937|       |    // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
 9938|       |    // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
 9939|       |    // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
 9940|       |    // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
 9941|       |    // while still correctly asserting on mid-frame key press events.
 9942|  29.3k|    const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
 9943|  29.3k|    IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9944|  29.3k|    IM_UNUSED(key_mods);
  ------------------
  |  |   89|  29.3k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9945|       |
 9946|       |    // [EXPERIMENTAL] Recover from errors: You may call this yourself before EndFrame().
 9947|       |    //ErrorCheckEndFrameRecover();
 9948|       |
 9949|       |    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
 9950|       |    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
 9951|  29.3k|    if (g.CurrentWindowStack.Size != 1)
  ------------------
  |  Branch (9951:9): [True: 0, False: 29.3k]
  ------------------
 9952|      0|    {
 9953|      0|        if (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (9953:13): [True: 0, False: 0]
  ------------------
 9954|      0|        {
 9955|      0|            ImGuiWindow* window = g.CurrentWindowStack.back().Window; // <-- This window was not Ended!
 9956|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
  ------------------
  |  |  268|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9957|      0|            IM_UNUSED(window);
  ------------------
  |  |   89|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9958|      0|            while (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (9958:20): [True: 0, False: 0]
  ------------------
 9959|      0|                End();
 9960|      0|        }
 9961|      0|        else
 9962|      0|        {
 9963|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
  ------------------
  |  |  268|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9964|      0|        }
 9965|      0|    }
 9966|       |
 9967|  29.3k|    IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
  ------------------
  |  |  268|  29.3k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9968|  29.3k|}
imgui.cpp:_ZL38CalcNextScrollFromScrollTargetAndClampP11ImGuiWindow:
10635|  84.7k|{
10636|  84.7k|    ImVec2 scroll = window->Scroll;
10637|  84.7k|    ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
10638|   254k|    for (int axis = 0; axis < 2; axis++)
  ------------------
  |  Branch (10638:24): [True: 169k, False: 84.7k]
  ------------------
10639|   169k|    {
10640|   169k|        if (window->ScrollTarget[axis] < FLT_MAX)
  ------------------
  |  Branch (10640:13): [True: 21.5k, False: 148k]
  ------------------
10641|  21.5k|        {
10642|  21.5k|            float center_ratio = window->ScrollTargetCenterRatio[axis];
10643|  21.5k|            float scroll_target = window->ScrollTarget[axis];
10644|  21.5k|            if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f)
  ------------------
  |  Branch (10644:17): [True: 0, False: 21.5k]
  ------------------
10645|      0|            {
10646|      0|                float snap_min = 0.0f;
10647|      0|                float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
10648|      0|                scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
10649|      0|            }
10650|  21.5k|            scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
10651|  21.5k|        }
10652|   169k|        scroll[axis] = IM_TRUNC(ImMax(scroll[axis], 0.0f));
  ------------------
  |  |  284|   169k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
10653|   169k|        if (!window->Collapsed && !window->SkipItems)
  ------------------
  |  Branch (10653:13): [True: 162k, False: 6.83k]
  |  Branch (10653:35): [True: 136k, False: 26.4k]
  ------------------
10654|   136k|            scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
10655|   169k|    }
10656|  84.7k|    return scroll;
10657|  84.7k|}
imgui.cpp:_ZN5ImGuiL20NavApplyItemToResultEP16ImGuiNavItemData:
11732|    110|{
11733|    110|    ImGuiContext& g = *GImGui;
11734|    110|    ImGuiWindow* window = g.CurrentWindow;
11735|    110|    result->Window = window;
11736|    110|    result->ID = g.LastItemData.ID;
11737|    110|    result->FocusScopeId = g.CurrentFocusScopeId;
11738|    110|    result->InFlags = g.LastItemData.InFlags;
11739|    110|    result->RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect);
11740|    110|    if (result->InFlags & ImGuiItemFlags_HasSelectionUserData)
  ------------------
  |  Branch (11740:9): [True: 0, False: 110]
  ------------------
11741|      0|    {
11742|      0|        IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11743|      0|        result->SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
11744|      0|    }
11745|    110|}
imgui.cpp:_ZN5ImGuiL14NavProcessItemEv:
11759|  2.47k|{
11760|  2.47k|    ImGuiContext& g = *GImGui;
11761|  2.47k|    ImGuiWindow* window = g.CurrentWindow;
11762|  2.47k|    const ImGuiID id = g.LastItemData.ID;
11763|  2.47k|    const ImGuiItemFlags item_flags = g.LastItemData.InFlags;
11764|       |
11765|       |    // When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
11766|  2.47k|    if (window->DC.NavIsScrollPushableX == false)
  ------------------
  |  Branch (11766:9): [True: 0, False: 2.47k]
  ------------------
11767|      0|    {
11768|      0|        g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
11769|      0|        g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
11770|      0|    }
11771|  2.47k|    const ImRect nav_bb = g.LastItemData.NavRect;
11772|       |
11773|       |    // Process Init Request
11774|  2.47k|    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
  ------------------
  |  Branch (11774:9): [True: 23, False: 2.44k]
  |  Branch (11774:29): [True: 11, False: 12]
  |  Branch (11774:73): [True: 11, False: 0]
  ------------------
11775|     11|    {
11776|       |        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
11777|     11|        const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
11778|     11|        if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0)
  ------------------
  |  Branch (11778:13): [True: 11, False: 0]
  |  Branch (11778:48): [True: 0, False: 0]
  ------------------
11779|     11|        {
11780|     11|            NavApplyItemToResult(&g.NavInitResult);
11781|     11|        }
11782|     11|        if (candidate_for_nav_default_focus)
  ------------------
  |  Branch (11782:13): [True: 11, False: 0]
  ------------------
11783|     11|        {
11784|     11|            g.NavInitRequest = false; // Found a match, clear request
11785|     11|            NavUpdateAnyRequestFlag();
11786|     11|        }
11787|     11|    }
11788|       |
11789|       |    // Process Move Request (scoring for navigation)
11790|       |    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
11791|  2.47k|    if (g.NavMoveScoringItems && (item_flags & ImGuiItemFlags_Disabled) == 0)
  ------------------
  |  Branch (11791:9): [True: 503, False: 1.96k]
  |  Branch (11791:34): [True: 503, False: 0]
  ------------------
11792|    503|    {
11793|    503|        const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
11794|    503|        if (is_tabbing)
  ------------------
  |  Branch (11794:13): [True: 157, False: 346]
  ------------------
11795|    157|        {
11796|    157|            NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
11797|    157|        }
11798|    346|        else if (g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_AllowCurrentNavId))
  ------------------
  |  Branch (11798:18): [True: 200, False: 146]
  |  Branch (11798:35): [True: 28, False: 118]
  ------------------
11799|    228|        {
11800|    228|            ImGuiNavItemData* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
  ------------------
  |  Branch (11800:40): [True: 228, False: 0]
  ------------------
11801|    228|            if (NavScoreItem(result))
  ------------------
  |  Branch (11801:17): [True: 34, False: 194]
  ------------------
11802|     34|                NavApplyItemToResult(result);
11803|       |
11804|       |            // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
11805|    228|            const float VISIBLE_RATIO = 0.70f;
11806|    228|            if ((g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
  ------------------
  |  Branch (11806:17): [True: 58, False: 170]
  |  Branch (11806:77): [True: 40, False: 18]
  ------------------
11807|     40|                if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
  ------------------
  |  Branch (11807:21): [True: 40, False: 0]
  ------------------
11808|     40|                    if (NavScoreItem(&g.NavMoveResultLocalVisible))
  ------------------
  |  Branch (11808:25): [True: 10, False: 30]
  ------------------
11809|     10|                        NavApplyItemToResult(&g.NavMoveResultLocalVisible);
11810|    228|        }
11811|    503|    }
11812|       |
11813|       |    // Update information for currently focused/navigated item
11814|  2.47k|    if (g.NavId == id)
  ------------------
  |  Branch (11814:9): [True: 2.15k, False: 317]
  ------------------
11815|  2.15k|    {
11816|  2.15k|        if (g.NavWindow != window)
  ------------------
  |  Branch (11816:13): [True: 0, False: 2.15k]
  ------------------
11817|      0|            SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
11818|  2.15k|        g.NavLayer = window->DC.NavLayerCurrent;
11819|  2.15k|        g.NavFocusScopeId = g.CurrentFocusScopeId;
11820|  2.15k|        g.NavIdIsAlive = true;
11821|  2.15k|        if (g.LastItemData.InFlags & ImGuiItemFlags_HasSelectionUserData)
  ------------------
  |  Branch (11821:13): [True: 0, False: 2.15k]
  ------------------
11822|      0|        {
11823|      0|            IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11824|      0|            g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
11825|      0|        }
11826|  2.15k|        window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
11827|  2.15k|    }
11828|  2.47k|}
imgui.cpp:_ZN5ImGuiL31NavProcessItemForTabbingRequestEjii:
11838|    157|{
11839|    157|    ImGuiContext& g = *GImGui;
11840|       |
11841|    157|    if ((move_flags & ImGuiNavMoveFlags_FocusApi) == 0)
  ------------------
  |  Branch (11841:9): [True: 157, False: 0]
  ------------------
11842|    157|        if (g.NavLayer != g.CurrentWindow->DC.NavLayerCurrent)
  ------------------
  |  Branch (11842:13): [True: 102, False: 55]
  ------------------
11843|    102|            return;
11844|       |
11845|       |    // - Can always land on an item when using API call.
11846|       |    // - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every item.
11847|       |    // - Tabbing without _NavEnableKeyboard: goes through inputable items only.
11848|     55|    bool can_stop;
11849|     55|    if (move_flags & ImGuiNavMoveFlags_FocusApi)
  ------------------
  |  Branch (11849:9): [True: 0, False: 55]
  ------------------
11850|      0|        can_stop = true;
11851|     55|    else
11852|     55|        can_stop = (item_flags & ImGuiItemFlags_NoTabStop) == 0 && ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) || (item_flags & ImGuiItemFlags_Inputable));
  ------------------
  |  Branch (11852:20): [True: 55, False: 0]
  |  Branch (11852:69): [True: 55, False: 0]
  |  Branch (11852:128): [True: 0, False: 0]
  ------------------
11853|       |
11854|       |    // Always store in NavMoveResultLocal (unlike directional request which uses NavMoveResultOther on sibling/flattened windows)
11855|     55|    ImGuiNavItemData* result = &g.NavMoveResultLocal;
11856|     55|    if (g.NavTabbingDir == +1)
  ------------------
  |  Branch (11856:9): [True: 55, False: 0]
  ------------------
11857|     55|    {
11858|       |        // Tab Forward or SetKeyboardFocusHere() with >= 0
11859|     55|        if (can_stop && g.NavTabbingResultFirst.ID == 0)
  ------------------
  |  Branch (11859:13): [True: 55, False: 0]
  |  Branch (11859:25): [True: 55, False: 0]
  ------------------
11860|     55|            NavApplyItemToResult(&g.NavTabbingResultFirst);
11861|     55|        if (can_stop && g.NavTabbingCounter > 0 && --g.NavTabbingCounter == 0)
  ------------------
  |  Branch (11861:13): [True: 55, False: 0]
  |  Branch (11861:25): [True: 0, False: 55]
  |  Branch (11861:52): [True: 0, False: 0]
  ------------------
11862|      0|            NavMoveRequestResolveWithLastItem(result);
11863|     55|        else if (g.NavId == id)
  ------------------
  |  Branch (11863:18): [True: 43, False: 12]
  ------------------
11864|     43|            g.NavTabbingCounter = 1;
11865|     55|    }
11866|      0|    else if (g.NavTabbingDir == -1)
  ------------------
  |  Branch (11866:14): [True: 0, False: 0]
  ------------------
11867|      0|    {
11868|       |        // Tab Backward
11869|      0|        if (g.NavId == id)
  ------------------
  |  Branch (11869:13): [True: 0, False: 0]
  ------------------
11870|      0|        {
11871|      0|            if (result->ID)
  ------------------
  |  Branch (11871:17): [True: 0, False: 0]
  ------------------
11872|      0|            {
11873|      0|                g.NavMoveScoringItems = false;
11874|      0|                NavUpdateAnyRequestFlag();
11875|      0|            }
11876|      0|        }
11877|      0|        else if (can_stop)
  ------------------
  |  Branch (11877:18): [True: 0, False: 0]
  ------------------
11878|      0|        {
11879|       |            // Keep applying until reaching NavId
11880|      0|            NavApplyItemToResult(result);
11881|      0|        }
11882|      0|    }
11883|      0|    else if (g.NavTabbingDir == 0)
  ------------------
  |  Branch (11883:14): [True: 0, False: 0]
  ------------------
11884|      0|    {
11885|      0|        if (can_stop && g.NavId == id)
  ------------------
  |  Branch (11885:13): [True: 0, False: 0]
  |  Branch (11885:25): [True: 0, False: 0]
  ------------------
11886|      0|            NavMoveRequestResolveWithLastItem(result);
11887|      0|        if (can_stop && g.NavTabbingResultFirst.ID == 0) // Tab init
  ------------------
  |  Branch (11887:13): [True: 0, False: 0]
  |  Branch (11887:25): [True: 0, False: 0]
  ------------------
11888|      0|            NavApplyItemToResult(&g.NavTabbingResultFirst);
11889|      0|    }
11890|     55|}
imgui.cpp:_ZN5ImGuiL12NavScoreItemEP16ImGuiNavItemData:
11594|    268|{
11595|    268|    ImGuiContext& g = *GImGui;
11596|    268|    ImGuiWindow* window = g.CurrentWindow;
11597|    268|    if (g.NavLayer != window->DC.NavLayerCurrent)
  ------------------
  |  Branch (11597:9): [True: 220, False: 48]
  ------------------
11598|    220|        return false;
11599|       |
11600|       |    // FIXME: Those are not good variables names
11601|     48|    ImRect cand = g.LastItemData.NavRect;   // Current item nav rectangle
11602|     48|    const ImRect curr = g.NavScoringRect;   // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
11603|     48|    g.NavScoringDebugCount++;
11604|       |
11605|       |    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
11606|     48|    if (window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (11606:9): [True: 0, False: 48]
  ------------------
11607|      0|    {
11608|      0|        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11609|      0|        if (!window->ClipRect.Overlaps(cand))
  ------------------
  |  Branch (11609:13): [True: 0, False: 0]
  ------------------
11610|      0|            return false;
11611|      0|        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
11612|      0|    }
11613|       |
11614|       |    // Compute distance between boxes
11615|       |    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
11616|     48|    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
11617|     48|    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
11618|     48|    if (dby != 0.0f && dbx != 0.0f)
  ------------------
  |  Branch (11618:9): [True: 38, False: 10]
  |  Branch (11618:24): [True: 0, False: 38]
  ------------------
11619|      0|        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
  ------------------
  |  Branch (11619:34): [True: 0, False: 0]
  ------------------
11620|     48|    float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  446|     48|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  446|     48|#define ImFabs(X)           fabsf(X)
  ------------------
11621|       |
11622|       |    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
11623|     48|    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
11624|     48|    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
11625|     48|    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  446|     48|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  446|     48|#define ImFabs(X)           fabsf(X)
  ------------------
11626|       |
11627|       |    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
11628|     48|    ImGuiDir quadrant;
11629|     48|    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
11630|     48|    if (dbx != 0.0f || dby != 0.0f)
  ------------------
  |  Branch (11630:9): [True: 0, False: 48]
  |  Branch (11630:24): [True: 38, False: 10]
  ------------------
11631|     38|    {
11632|       |        // For non-overlapping boxes, use distance between boxes
11633|     38|        dax = dbx;
11634|     38|        day = dby;
11635|     38|        dist_axial = dist_box;
11636|     38|        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
11637|     38|    }
11638|     10|    else if (dcx != 0.0f || dcy != 0.0f)
  ------------------
  |  Branch (11638:14): [True: 1, False: 9]
  |  Branch (11638:29): [True: 0, False: 9]
  ------------------
11639|      1|    {
11640|       |        // For overlapping boxes with different centers, use distance between centers
11641|      1|        dax = dcx;
11642|      1|        day = dcy;
11643|      1|        dist_axial = dist_center;
11644|      1|        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
11645|      1|    }
11646|      9|    else
11647|      9|    {
11648|       |        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
11649|      9|        quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
  ------------------
  |  Branch (11649:20): [True: 0, False: 9]
  ------------------
11650|      9|    }
11651|       |
11652|     48|    const ImGuiDir move_dir = g.NavMoveDir;
11653|       |#if IMGUI_DEBUG_NAV_SCORING
11654|       |    char buf[200];
11655|       |    if (g.IO.KeyCtrl) // Hold CTRL to preview score in matching quadrant. CTRL+Arrow to rotate.
11656|       |    {
11657|       |        if (quadrant == move_dir)
11658|       |        {
11659|       |            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
11660|       |            ImDrawList* draw_list = GetForegroundDrawList(window);
11661|       |            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 80));
11662|       |            draw_list->AddRectFilled(cand.Min, cand.Min + CalcTextSize(buf), IM_COL32(255, 0, 0, 200));
11663|       |            draw_list->AddText(cand.Min, IM_COL32(255, 255, 255, 255), buf);
11664|       |        }
11665|       |    }
11666|       |    const bool debug_hovering = IsMouseHoveringRect(cand.Min, cand.Max);
11667|       |    const bool debug_tty = (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_Space));
11668|       |    if (debug_hovering || debug_tty)
11669|       |    {
11670|       |        ImFormatString(buf, IM_ARRAYSIZE(buf),
11671|       |            "d-box    (%7.3f,%7.3f) -> %7.3f\nd-center (%7.3f,%7.3f) -> %7.3f\nd-axial  (%7.3f,%7.3f) -> %7.3f\nnav %c, quadrant %c",
11672|       |            dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "-WENS"[move_dir+1], "-WENS"[quadrant+1]);
11673|       |        if (debug_hovering)
11674|       |        {
11675|       |            ImDrawList* draw_list = GetForegroundDrawList(window);
11676|       |            draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
11677|       |            draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
11678|       |            draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40, 0, 0, 200));
11679|       |            draw_list->AddText(cand.Max, ~0U, buf);
11680|       |        }
11681|       |        if (debug_tty) { IMGUI_DEBUG_LOG_NAV("id 0x%08X\n%s\n", g.LastItemData.ID, buf); }
11682|       |    }
11683|       |#endif
11684|       |
11685|       |    // Is it in the quadrant we're interested in moving to?
11686|     48|    bool new_best = false;
11687|     48|    if (quadrant == move_dir)
  ------------------
  |  Branch (11687:9): [True: 44, False: 4]
  ------------------
11688|     44|    {
11689|       |        // Does it beat the current best candidate?
11690|     44|        if (dist_box < result->DistBox)
  ------------------
  |  Branch (11690:13): [True: 44, False: 0]
  ------------------
11691|     44|        {
11692|     44|            result->DistBox = dist_box;
11693|     44|            result->DistCenter = dist_center;
11694|     44|            return true;
11695|     44|        }
11696|      0|        if (dist_box == result->DistBox)
  ------------------
  |  Branch (11696:13): [True: 0, False: 0]
  ------------------
11697|      0|        {
11698|       |            // Try using distance between center points to break ties
11699|      0|            if (dist_center < result->DistCenter)
  ------------------
  |  Branch (11699:17): [True: 0, False: 0]
  ------------------
11700|      0|            {
11701|      0|                result->DistCenter = dist_center;
11702|      0|                new_best = true;
11703|      0|            }
11704|      0|            else if (dist_center == result->DistCenter)
  ------------------
  |  Branch (11704:22): [True: 0, False: 0]
  ------------------
11705|      0|            {
11706|       |                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
11707|       |                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
11708|       |                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
11709|      0|                if (((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
  ------------------
  |  Branch (11709:21): [True: 0, False: 0]
  |  Branch (11709:23): [True: 0, False: 0]
  |  Branch (11709:50): [True: 0, False: 0]
  ------------------
11710|      0|                    new_best = true;
11711|      0|            }
11712|      0|        }
11713|      0|    }
11714|       |
11715|       |    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
11716|       |    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
11717|       |    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
11718|       |    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
11719|       |    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
11720|      4|    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
  ------------------
  |  Branch (11720:9): [True: 4, False: 0]
  |  Branch (11720:39): [True: 4, False: 0]
  ------------------
11721|      4|        if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (11721:13): [True: 0, False: 4]
  |  Branch (11721:49): [True: 0, False: 0]
  ------------------
11722|      0|            if ((move_dir == ImGuiDir_Left && dax < 0.0f) || (move_dir == ImGuiDir_Right && dax > 0.0f) || (move_dir == ImGuiDir_Up && day < 0.0f) || (move_dir == ImGuiDir_Down && day > 0.0f))
  ------------------
  |  Branch (11722:18): [True: 0, False: 0]
  |  Branch (11722:47): [True: 0, False: 0]
  |  Branch (11722:63): [True: 0, False: 0]
  |  Branch (11722:93): [True: 0, False: 0]
  |  Branch (11722:109): [True: 0, False: 0]
  |  Branch (11722:136): [True: 0, False: 0]
  |  Branch (11722:152): [True: 0, False: 0]
  |  Branch (11722:181): [True: 0, False: 0]
  ------------------
11723|      0|            {
11724|      0|                result->DistAxial = dist_axial;
11725|      0|                new_best = true;
11726|      0|            }
11727|       |
11728|      4|    return new_best;
11729|     48|}
imgui.cpp:_ZL24NavScoreItemDistIntervalffff:
11584|     96|{
11585|     96|    if (cand_max < curr_min)
  ------------------
  |  Branch (11585:9): [True: 20, False: 76]
  ------------------
11586|     20|        return cand_max - curr_min;
11587|     76|    if (curr_max < cand_min)
  ------------------
  |  Branch (11587:9): [True: 18, False: 58]
  ------------------
11588|     18|        return cand_min - curr_max;
11589|     58|    return 0.0f;
11590|     76|}
imgui.cpp:_ZL25ImGetDirQuadrantFromDeltaff:
11577|     39|{
11578|     39|    if (ImFabs(dx) > ImFabs(dy))
  ------------------
  |  |  446|     39|#define ImFabs(X)           fabsf(X)
  ------------------
                  if (ImFabs(dx) > ImFabs(dy))
  ------------------
  |  |  446|     39|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (11578:9): [True: 1, False: 38]
  ------------------
11579|      1|        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
  ------------------
  |  Branch (11579:16): [True: 1, False: 0]
  ------------------
11580|     38|    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
  ------------------
  |  Branch (11580:12): [True: 18, False: 20]
  ------------------
11581|     39|}
imgui.cpp:_ZN5ImGuiL23NavUpdateAnyRequestFlagEv:
12031|  38.6k|{
12032|  38.6k|    ImGuiContext& g = *GImGui;
12033|  38.6k|    g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
  ------------------
  |  | 1034|  65.1k|#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
  |  |  ------------------
  |  |  |  Branch (1034:37): [Folded - Ignored]
  |  |  ------------------
  ------------------
  |  Branch (12033:23): [True: 6.01k, False: 32.6k]
  |  Branch (12033:48): [True: 21, False: 32.5k]
  |  Branch (12033:96): [True: 0, False: 0]
  ------------------
12034|  38.6k|    if (g.NavAnyRequest)
  ------------------
  |  Branch (12034:9): [True: 6.03k, False: 32.5k]
  ------------------
12035|  38.6k|        IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|  38.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12036|  38.6k|}
imgui.cpp:_ZN5ImGuiL22NavCalcPreferredRefPosEv:
12072|     17|{
12073|     17|    ImGuiContext& g = *GImGui;
12074|     17|    ImGuiWindow* window = g.NavWindow;
12075|     17|    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !window)
  ------------------
  |  Branch (12075:9): [True: 2, False: 15]
  |  Branch (12075:34): [True: 15, False: 0]
  |  Branch (12075:61): [True: 0, False: 0]
  ------------------
12076|     17|    {
12077|       |        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
12078|       |        // The +1.0f offset when stored by OpenPopupEx() allows reopening this or another popup (same or another mouse button) while not moving the mouse, it is pretty standard.
12079|       |        // In theory we could move that +1.0f offset in OpenPopupEx()
12080|     17|        ImVec2 p = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos;
  ------------------
  |  Branch (12080:20): [True: 17, False: 0]
  ------------------
12081|     17|        return ImVec2(p.x + 1.0f, p.y);
12082|     17|    }
12083|      0|    else
12084|      0|    {
12085|       |        // When navigation is active and mouse is disabled, pick a position around the bottom left of the currently navigated item
12086|       |        // Take account of upcoming scrolling (maybe set mouse pos should be done in EndFrame?)
12087|      0|        ImRect rect_rel = WindowRectRelToAbs(window, window->NavRectRel[g.NavLayer]);
12088|      0|        if (window->LastFrameActive != g.FrameCount && (window->ScrollTarget.x != FLT_MAX || window->ScrollTarget.y != FLT_MAX))
  ------------------
  |  Branch (12088:13): [True: 0, False: 0]
  |  Branch (12088:57): [True: 0, False: 0]
  |  Branch (12088:94): [True: 0, False: 0]
  ------------------
12089|      0|        {
12090|      0|            ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
12091|      0|            rect_rel.Translate(window->Scroll - next_scroll);
12092|      0|        }
12093|      0|        ImVec2 pos = ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
12094|      0|        ImGuiViewport* viewport = window->Viewport;
12095|      0|        return ImTrunc(ImClamp(pos, viewport->Pos, viewport->Pos + viewport->Size)); // ImTrunc() is important because non-integer mouse position application in backend might be lossy and result in undesirable non-zero delta.
12096|      0|    }
12097|     17|}
imgui.cpp:_ZN5ImGuiL9NavUpdateEv:
12123|  29.3k|{
12124|  29.3k|    ImGuiContext& g = *GImGui;
12125|  29.3k|    ImGuiIO& io = g.IO;
12126|       |
12127|  29.3k|    io.WantSetMousePos = false;
12128|       |    //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
12129|       |
12130|       |    // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
12131|       |    // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
12132|  29.3k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12132:37): [True: 29.3k, False: 0]
  |  Branch (12132:98): [True: 0, False: 29.3k]
  ------------------
12133|  29.3k|    const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
12134|  29.3k|    if (nav_gamepad_active)
  ------------------
  |  Branch (12134:9): [True: 0, False: 29.3k]
  ------------------
12135|      0|        for (ImGuiKey key : nav_gamepad_keys_to_change_source)
  ------------------
  |  Branch (12135:27): [True: 0, False: 0]
  ------------------
12136|      0|            if (IsKeyDown(key))
  ------------------
  |  Branch (12136:17): [True: 0, False: 0]
  ------------------
12137|      0|                g.NavInputSource = ImGuiInputSource_Gamepad;
12138|  29.3k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12139|  29.3k|    const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
12140|  29.3k|    if (nav_keyboard_active)
  ------------------
  |  Branch (12140:9): [True: 29.3k, False: 0]
  ------------------
12141|  29.3k|        for (ImGuiKey key : nav_keyboard_keys_to_change_source)
  ------------------
  |  Branch (12141:27): [True: 205k, False: 29.3k]
  ------------------
12142|   205k|            if (IsKeyDown(key))
  ------------------
  |  Branch (12142:17): [True: 16.6k, False: 188k]
  ------------------
12143|  16.6k|                g.NavInputSource = ImGuiInputSource_Keyboard;
12144|       |
12145|       |    // Process navigation init request (select first/default focus)
12146|  29.3k|    g.NavJustMovedToId = 0;
12147|  29.3k|    if (g.NavInitResult.ID != 0)
  ------------------
  |  Branch (12147:9): [True: 11, False: 29.3k]
  ------------------
12148|     11|        NavInitRequestApplyResult();
12149|  29.3k|    g.NavInitRequest = false;
12150|  29.3k|    g.NavInitRequestFromMove = false;
12151|  29.3k|    g.NavInitResult.ID = 0;
12152|       |
12153|       |    // Process navigation move request
12154|  29.3k|    if (g.NavMoveSubmitted)
  ------------------
  |  Branch (12154:9): [True: 2.76k, False: 26.6k]
  ------------------
12155|  2.76k|        NavMoveRequestApplyResult();
12156|  29.3k|    g.NavTabbingCounter = 0;
12157|  29.3k|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
12158|       |
12159|       |    // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
12160|  29.3k|    bool set_mouse_pos = false;
12161|  29.3k|    if (g.NavMousePosDirty && g.NavIdIsAlive)
  ------------------
  |  Branch (12161:9): [True: 1.47k, False: 27.8k]
  |  Branch (12161:31): [True: 382, False: 1.09k]
  ------------------
12162|    382|        if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
  ------------------
  |  Branch (12162:13): [True: 382, False: 0]
  |  Branch (12162:39): [True: 382, False: 0]
  |  Branch (12162:65): [True: 382, False: 0]
  ------------------
12163|    382|            set_mouse_pos = true;
12164|  29.3k|    g.NavMousePosDirty = false;
12165|  29.3k|    IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12166|       |
12167|       |    // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
12168|  29.3k|    if (g.NavWindow)
  ------------------
  |  Branch (12168:9): [True: 18.3k, False: 11.0k]
  ------------------
12169|  18.3k|        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
12170|  29.3k|    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (12170:9): [True: 18.3k, False: 11.0k]
  |  Branch (12170:24): [True: 254, False: 18.0k]
  |  Branch (12170:70): [True: 254, False: 0]
  ------------------
12171|    254|        g.NavWindow->NavLastChildNavWindow = NULL;
12172|       |
12173|       |    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
12174|  29.3k|    NavUpdateWindowing();
12175|       |
12176|       |    // Set output flags for user application
12177|  29.3k|    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
  ------------------
  |  Branch (12177:21): [True: 29.3k, False: 0]
  |  Branch (12177:44): [True: 0, False: 0]
  |  Branch (12177:67): [True: 18.3k, False: 11.0k]
  |  Branch (12177:82): [True: 18.3k, False: 0]
  ------------------
12178|  29.3k|    io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);
  ------------------
  |  Branch (12178:22): [True: 18.3k, False: 11.0k]
  |  Branch (12178:38): [True: 2.12k, False: 16.2k]
  |  Branch (12178:54): [True: 2.08k, False: 45]
  |  Branch (12178:81): [True: 0, False: 27.2k]
  ------------------
12179|       |
12180|       |    // Process NavCancel input (to close a popup, get back to parent, clear focus)
12181|  29.3k|    NavUpdateCancelRequest();
12182|       |
12183|       |    // Process manual activation request
12184|  29.3k|    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = 0;
12185|  29.3k|    g.NavActivateFlags = ImGuiActivateFlags_None;
12186|  29.3k|    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (12186:9): [True: 2.38k, False: 26.9k]
  |  Branch (12186:25): [True: 2.33k, False: 45]
  |  Branch (12186:51): [True: 2.33k, False: 0]
  |  Branch (12186:76): [True: 2.33k, False: 0]
  |  Branch (12186:91): [True: 2.33k, False: 0]
  ------------------
12187|  2.33k|    {
12188|  2.33k|        const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate));
  ------------------
  |  | 1325|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  |  Branch (12188:37): [True: 2.33k, False: 0]
  |  Branch (12188:60): [True: 60, False: 2.27k]
  |  Branch (12188:91): [True: 0, False: 2.27k]
  |  Branch (12188:113): [True: 0, False: 0]
  ------------------
12189|  2.33k|        const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, false)));
  ------------------
  |  | 1325|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  |  Branch (12189:39): [True: 60, False: 2.27k]
  |  Branch (12189:58): [True: 60, False: 0]
  |  Branch (12189:81): [True: 18, False: 42]
  |  Branch (12189:122): [True: 0, False: 42]
  |  Branch (12189:144): [True: 0, False: 0]
  ------------------
12190|  2.33k|        const bool input_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Enter)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput));
  ------------------
  |  | 1328|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
  |  Branch (12190:34): [True: 2.33k, False: 0]
  |  Branch (12190:57): [True: 19, False: 2.32k]
  |  Branch (12190:88): [True: 0, False: 2.32k]
  |  Branch (12190:110): [True: 0, False: 0]
  ------------------
12191|  2.33k|        const bool input_pressed = input_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Enter, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, false)));
  ------------------
  |  | 1328|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
  |  Branch (12191:36): [True: 19, False: 2.32k]
  |  Branch (12191:52): [True: 19, False: 0]
  |  Branch (12191:75): [True: 3, False: 16]
  |  Branch (12191:116): [True: 0, False: 16]
  |  Branch (12191:138): [True: 0, False: 0]
  ------------------
12192|  2.33k|        if (g.ActiveId == 0 && activate_pressed)
  ------------------
  |  Branch (12192:13): [True: 2.33k, False: 0]
  |  Branch (12192:32): [True: 18, False: 2.32k]
  ------------------
12193|     18|        {
12194|     18|            g.NavActivateId = g.NavId;
12195|     18|            g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
12196|     18|        }
12197|  2.33k|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed)
  ------------------
  |  Branch (12197:14): [True: 2.33k, False: 0]
  |  Branch (12197:33): [True: 0, False: 0]
  |  Branch (12197:59): [True: 3, False: 2.33k]
  ------------------
12198|      3|        {
12199|      3|            g.NavActivateId = g.NavId;
12200|      3|            g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
12201|      3|        }
12202|  2.33k|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down))
  ------------------
  |  Branch (12202:14): [True: 2.33k, False: 0]
  |  Branch (12202:33): [True: 0, False: 0]
  |  Branch (12202:60): [True: 60, False: 2.27k]
  |  Branch (12202:77): [True: 18, False: 2.26k]
  ------------------
12203|     78|            g.NavActivateDownId = g.NavId;
12204|  2.33k|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed))
  ------------------
  |  Branch (12204:14): [True: 2.33k, False: 0]
  |  Branch (12204:33): [True: 0, False: 0]
  |  Branch (12204:60): [True: 18, False: 2.32k]
  |  Branch (12204:80): [True: 2, False: 2.31k]
  ------------------
12205|     20|            g.NavActivatePressedId = g.NavId;
12206|  2.33k|    }
12207|  29.3k|    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (12207:9): [True: 18.3k, False: 11.0k]
  |  Branch (12207:24): [True: 0, False: 18.3k]
  ------------------
12208|      0|        g.NavDisableHighlight = true;
12209|  29.3k|    if (g.NavActivateId != 0)
  ------------------
  |  Branch (12209:9): [True: 20, False: 29.3k]
  ------------------
12210|  29.3k|        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12211|       |
12212|       |    // Process programmatic activation request
12213|       |    // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
12214|  29.3k|    if (g.NavNextActivateId != 0)
  ------------------
  |  Branch (12214:9): [True: 0, False: 29.3k]
  ------------------
12215|      0|    {
12216|      0|        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
12217|      0|        g.NavActivateFlags = g.NavNextActivateFlags;
12218|      0|    }
12219|  29.3k|    g.NavNextActivateId = 0;
12220|       |
12221|       |    // Process move requests
12222|  29.3k|    NavUpdateCreateMoveRequest();
12223|  29.3k|    if (g.NavMoveDir == ImGuiDir_None)
  ------------------
  |  Branch (12223:9): [True: 26.7k, False: 2.59k]
  ------------------
12224|  26.7k|        NavUpdateCreateTabbingRequest();
12225|  29.3k|    NavUpdateAnyRequestFlag();
12226|  29.3k|    g.NavIdIsAlive = false;
12227|       |
12228|       |    // Scrolling
12229|  29.3k|    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
  ------------------
  |  Branch (12229:9): [True: 18.3k, False: 11.0k]
  |  Branch (12229:24): [True: 18.3k, False: 0]
  |  Branch (12229:80): [True: 18.3k, False: 0]
  ------------------
12230|  18.3k|    {
12231|       |        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
12232|  18.3k|        ImGuiWindow* window = g.NavWindow;
12233|  18.3k|        const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
  ------------------
  |  |  285|  18.3k|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
12234|  18.3k|        const ImGuiDir move_dir = g.NavMoveDir;
12235|  18.3k|        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY && move_dir != ImGuiDir_None)
  ------------------
  |  Branch (12235:13): [True: 15.8k, False: 2.49k]
  |  Branch (12235:55): [True: 15.0k, False: 775]
  |  Branch (12235:89): [True: 2.38k, False: 12.6k]
  ------------------
12236|  2.38k|        {
12237|  2.38k|            if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
  ------------------
  |  Branch (12237:17): [True: 954, False: 1.42k]
  |  Branch (12237:46): [True: 267, False: 1.16k]
  ------------------
12238|  1.22k|                SetScrollX(window, ImTrunc(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (12238:64): [True: 954, False: 267]
  ------------------
12239|  2.38k|            if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
  ------------------
  |  Branch (12239:17): [True: 1.03k, False: 1.34k]
  |  Branch (12239:44): [True: 124, False: 1.22k]
  ------------------
12240|  1.16k|                SetScrollY(window, ImTrunc(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (12240:64): [True: 1.03k, False: 124]
  ------------------
12241|  2.38k|        }
12242|       |
12243|       |        // *Normal* Manual scroll with LStick
12244|       |        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
12245|  18.3k|        if (nav_gamepad_active)
  ------------------
  |  Branch (12245:13): [True: 0, False: 18.3k]
  ------------------
12246|      0|        {
12247|      0|            const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
12248|      0|            const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1323|      0|#define ImGuiKey_NavGamepadTweakSlow    ImGuiKey_GamepadL1
  ------------------
                          const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1324|      0|#define ImGuiKey_NavGamepadTweakFast    ImGuiKey_GamepadR1
  ------------------
  |  Branch (12248:40): [True: 0, False: 0]
  |  Branch (12248:97): [True: 0, False: 0]
  ------------------
12249|      0|            if (scroll_dir.x != 0.0f && window->ScrollbarX)
  ------------------
  |  Branch (12249:17): [True: 0, False: 0]
  |  Branch (12249:41): [True: 0, False: 0]
  ------------------
12250|      0|                SetScrollX(window, ImTrunc(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
12251|      0|            if (scroll_dir.y != 0.0f)
  ------------------
  |  Branch (12251:17): [True: 0, False: 0]
  ------------------
12252|      0|                SetScrollY(window, ImTrunc(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
12253|      0|        }
12254|  18.3k|    }
12255|       |
12256|       |    // Always prioritize mouse highlight if navigation is disabled
12257|  29.3k|    if (!nav_keyboard_active && !nav_gamepad_active)
  ------------------
  |  Branch (12257:9): [True: 0, False: 29.3k]
  |  Branch (12257:33): [True: 0, False: 0]
  ------------------
12258|      0|    {
12259|      0|        g.NavDisableHighlight = true;
12260|      0|        g.NavDisableMouseHover = set_mouse_pos = false;
12261|      0|    }
12262|       |
12263|       |    // Update mouse position if requested
12264|       |    // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
12265|  29.3k|    if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
  ------------------
  |  Branch (12265:9): [True: 382, False: 28.9k]
  |  Branch (12265:26): [True: 0, False: 382]
  |  Branch (12265:86): [True: 0, False: 0]
  ------------------
12266|      0|        TeleportMousePos(NavCalcPreferredRefPos());
12267|       |
12268|       |    // [DEBUG]
12269|  29.3k|    g.NavScoringDebugCount = 0;
12270|       |#if IMGUI_DEBUG_NAV_RECTS
12271|       |    if (ImGuiWindow* debug_window = g.NavWindow)
12272|       |    {
12273|       |        ImDrawList* draw_list = GetForegroundDrawList(debug_window);
12274|       |        int layer = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/ { ImRect r = WindowRectRelToAbs(debug_window, debug_window->NavRectRel[layer]); draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 200, 0, 255)); }
12275|       |        //if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
12276|       |    }
12277|       |#endif
12278|  29.3k|}
imgui.cpp:_ZN5ImGuiL35NavSaveLastChildNavWindowIntoParentEP11ImGuiWindow:
11980|  18.3k|{
11981|  18.3k|    ImGuiWindow* parent = nav_window;
11982|  34.4k|    while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (11982:12): [True: 34.4k, False: 0]
  |  Branch (11982:22): [True: 16.1k, False: 18.3k]
  |  Branch (11982:54): [True: 16.1k, False: 0]
  ------------------
11983|  16.1k|        parent = parent->ParentWindow;
11984|  18.3k|    if (parent && parent != nav_window)
  ------------------
  |  Branch (11984:9): [True: 18.3k, False: 0]
  |  Branch (11984:19): [True: 16.1k, False: 2.21k]
  ------------------
11985|  16.1k|        parent->NavLastChildNavWindow = nav_window;
11986|  18.3k|}
imgui.cpp:_ZN5ImGuiL18NavUpdateWindowingEv:
12822|  29.3k|{
12823|  29.3k|    ImGuiContext& g = *GImGui;
12824|  29.3k|    ImGuiIO& io = g.IO;
12825|       |
12826|  29.3k|    ImGuiWindow* apply_focus_window = NULL;
12827|  29.3k|    bool apply_toggle_layer = false;
12828|       |
12829|  29.3k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
12830|  29.3k|    bool allow_windowing = (modal_window == NULL); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
12831|  29.3k|    if (!allow_windowing)
  ------------------
  |  Branch (12831:9): [True: 0, False: 29.3k]
  ------------------
12832|      0|        g.NavWindowingTarget = NULL;
12833|       |
12834|       |    // Fade out
12835|  29.3k|    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
  ------------------
  |  Branch (12835:9): [True: 0, False: 29.3k]
  |  Branch (12835:37): [True: 0, False: 0]
  ------------------
12836|      0|    {
12837|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
12838|      0|        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (12838:13): [True: 0, False: 0]
  |  Branch (12838:37): [True: 0, False: 0]
  ------------------
12839|      0|            g.NavWindowingTargetAnim = NULL;
12840|      0|    }
12841|       |
12842|       |    // Start CTRL+Tab or Square+L/R window selection
12843|  29.3k|    const ImGuiID owner_id = ImHashStr("###NavUpdateWindowing");
12844|  29.3k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12844:37): [True: 29.3k, False: 0]
  |  Branch (12844:98): [True: 0, False: 29.3k]
  ------------------
12845|  29.3k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12846|  29.3k|    const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, owner_id, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
  ------------------
  |  Branch (12846:39): [True: 29.3k, False: 0]
  |  Branch (12846:58): [True: 29.3k, False: 0]
  |  Branch (12846:89): [True: 0, False: 29.3k]
  ------------------
12847|  29.3k|    const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, owner_id, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
  ------------------
  |  Branch (12847:39): [True: 29.3k, False: 0]
  |  Branch (12847:58): [True: 29.3k, False: 0]
  |  Branch (12847:89): [True: 0, False: 29.3k]
  ------------------
12848|  29.3k|    const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, 0, ImGuiInputFlags_None);
  ------------------
  |  | 1327|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (12848:47): [True: 29.3k, False: 0]
  |  Branch (12848:66): [True: 0, False: 29.3k]
  |  Branch (12848:88): [True: 0, False: 0]
  |  Branch (12848:113): [True: 0, False: 0]
  ------------------
12849|  29.3k|    const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
  ------------------
  |  Branch (12849:48): [True: 29.3k, False: 0]
  |  Branch (12849:67): [True: 29.3k, False: 0]
  |  Branch (12849:93): [True: 0, False: 29.3k]
  |  Branch (12849:117): [True: 0, False: 29.3k]
  ------------------
12850|  29.3k|    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
  ------------------
  |  Branch (12850:9): [True: 0, False: 29.3k]
  |  Branch (12850:41): [True: 0, False: 29.3k]
  ------------------
12851|      0|        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
  ------------------
  |  Branch (12851:26): [True: 0, False: 0]
  ------------------
12852|      0|        {
12853|      0|            g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
12854|      0|            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
12855|      0|            g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
12856|      0|            g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
  ------------------
  |  Branch (12856:41): [True: 0, False: 0]
  ------------------
12857|      0|            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
  ------------------
  |  Branch (12857:32): [True: 0, False: 0]
  ------------------
12858|       |
12859|       |            // Register ownership of our mods. Using ImGuiInputFlags_RouteGlobalHigh in the Shortcut() calls instead would probably be correct but may have more side-effects.
12860|      0|            if (keyboard_next_window || keyboard_prev_window)
  ------------------
  |  Branch (12860:17): [True: 0, False: 0]
  |  Branch (12860:41): [True: 0, False: 0]
  ------------------
12861|      0|                SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiMod_Mask_, owner_id);
12862|      0|        }
12863|       |
12864|       |    // Gamepad update
12865|  29.3k|    g.NavWindowingTimer += io.DeltaTime;
12866|  29.3k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (12866:9): [True: 0, False: 29.3k]
  |  Branch (12866:33): [True: 0, False: 0]
  ------------------
12867|      0|    {
12868|       |        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
12869|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
12870|       |
12871|       |        // Select window to focus
12872|      0|        const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
12873|      0|        if (focus_change_dir != 0)
  ------------------
  |  Branch (12873:13): [True: 0, False: 0]
  ------------------
12874|      0|        {
12875|      0|            NavUpdateWindowingHighlightWindow(focus_change_dir);
12876|      0|            g.NavWindowingHighlightAlpha = 1.0f;
12877|      0|        }
12878|       |
12879|       |        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
12880|      0|        if (!IsKeyDown(ImGuiKey_NavGamepadMenu))
  ------------------
  |  | 1327|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (12880:13): [True: 0, False: 0]
  ------------------
12881|      0|        {
12882|      0|            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
12883|      0|            if (g.NavWindowingToggleLayer && g.NavWindow)
  ------------------
  |  Branch (12883:17): [True: 0, False: 0]
  |  Branch (12883:46): [True: 0, False: 0]
  ------------------
12884|      0|                apply_toggle_layer = true;
12885|      0|            else if (!g.NavWindowingToggleLayer)
  ------------------
  |  Branch (12885:22): [True: 0, False: 0]
  ------------------
12886|      0|                apply_focus_window = g.NavWindowingTarget;
12887|      0|            g.NavWindowingTarget = NULL;
12888|      0|        }
12889|      0|    }
12890|       |
12891|       |    // Keyboard: Focus
12892|  29.3k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (12892:9): [True: 0, False: 29.3k]
  |  Branch (12892:33): [True: 0, False: 0]
  ------------------
12893|      0|    {
12894|       |        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
12895|      0|        ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
  ------------------
  |  Branch (12895:39): [True: 0, False: 0]
  |  Branch (12895:118): [True: 0, False: 0]
  ------------------
12896|      0|        IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12897|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
12898|      0|        if (keyboard_next_window || keyboard_prev_window)
  ------------------
  |  Branch (12898:13): [True: 0, False: 0]
  |  Branch (12898:37): [True: 0, False: 0]
  ------------------
12899|      0|            NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
  ------------------
  |  Branch (12899:47): [True: 0, False: 0]
  ------------------
12900|      0|        else if ((io.KeyMods & shared_mods) != shared_mods)
  ------------------
  |  Branch (12900:18): [True: 0, False: 0]
  ------------------
12901|      0|            apply_focus_window = g.NavWindowingTarget;
12902|      0|    }
12903|       |
12904|       |    // Keyboard: Press and Release ALT to toggle menu layer
12905|       |    // - Testing that only Alt is tested prevents Alt+Shift or AltGR from toggling menu layer.
12906|       |    // - AltGR is normally Alt+Ctrl but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl). But even on keyboards without AltGR we don't want Alt+Ctrl to open menu anyway.
12907|  29.3k|    if (nav_keyboard_active && IsKeyPressed(ImGuiMod_Alt, ImGuiKeyOwner_None))
  ------------------
  |  | 1385|  29.3k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12907:9): [True: 29.3k, False: 0]
  |  Branch (12907:32): [True: 0, False: 29.3k]
  ------------------
12908|      0|    {
12909|      0|        g.NavWindowingToggleLayer = true;
12910|      0|        g.NavInputSource = ImGuiInputSource_Keyboard;
12911|      0|    }
12912|  29.3k|    if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (12912:9): [True: 0, False: 29.3k]
  |  Branch (12912:38): [True: 0, False: 0]
  ------------------
12913|      0|    {
12914|       |        // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
12915|       |        // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
12916|       |        // We cancel toggling nav layer if an owner has claimed the key.
12917|      0|        if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_None) == false)
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12917:13): [True: 0, False: 0]
  |  Branch (12917:49): [True: 0, False: 0]
  |  Branch (12917:63): [True: 0, False: 0]
  |  Branch (12917:78): [True: 0, False: 0]
  |  Branch (12917:93): [True: 0, False: 0]
  ------------------
12918|      0|            g.NavWindowingToggleLayer = false;
12919|       |
12920|       |        // Apply layer toggle on release
12921|       |        // Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
12922|      0|        if (IsKeyReleased(ImGuiMod_Alt) && g.NavWindowingToggleLayer)
  ------------------
  |  Branch (12922:13): [True: 0, False: 0]
  |  Branch (12922:44): [True: 0, False: 0]
  ------------------
12923|      0|            if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (12923:17): [True: 0, False: 0]
  |  Branch (12923:36): [True: 0, False: 0]
  ------------------
12924|      0|                if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (12924:21): [True: 0, False: 0]
  ------------------
12925|      0|                    apply_toggle_layer = true;
12926|      0|        if (!IsKeyDown(ImGuiMod_Alt))
  ------------------
  |  Branch (12926:13): [True: 0, False: 0]
  ------------------
12927|      0|            g.NavWindowingToggleLayer = false;
12928|      0|    }
12929|       |
12930|       |    // Move window
12931|  29.3k|    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (12931:9): [True: 0, False: 29.3k]
  |  Branch (12931:33): [True: 0, False: 0]
  ------------------
12932|      0|    {
12933|      0|        ImVec2 nav_move_dir;
12934|      0|        if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
  ------------------
  |  Branch (12934:13): [True: 0, False: 0]
  |  Branch (12934:62): [True: 0, False: 0]
  ------------------
12935|      0|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
12936|      0|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (12936:13): [True: 0, False: 0]
  ------------------
12937|      0|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
12938|      0|        if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
  ------------------
  |  Branch (12938:13): [True: 0, False: 0]
  |  Branch (12938:39): [True: 0, False: 0]
  ------------------
12939|      0|        {
12940|      0|            const float NAV_MOVE_SPEED = 800.0f;
12941|      0|            const float move_step = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
12942|      0|            g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
12943|      0|            g.NavDisableMouseHover = true;
12944|      0|            ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaPos);
12945|      0|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (12945:17): [True: 0, False: 0]
  |  Branch (12945:44): [True: 0, False: 0]
  ------------------
12946|      0|            {
12947|      0|                ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
12948|      0|                SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
12949|      0|                g.NavWindowingAccumDeltaPos -= accum_floored;
12950|      0|            }
12951|      0|        }
12952|      0|    }
12953|       |
12954|       |    // Apply final focus
12955|  29.3k|    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
  ------------------
  |  Branch (12955:9): [True: 0, False: 29.3k]
  |  Branch (12955:32): [True: 0, False: 0]
  |  Branch (12955:55): [True: 0, False: 0]
  ------------------
12956|      0|    {
12957|       |        // FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
12958|       |        // Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
12959|      0|        ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
  ------------------
  |  Branch (12959:44): [True: 0, False: 0]
  ------------------
12960|      0|        ClearActiveID();
12961|      0|        NavRestoreHighlightAfterMove();
12962|      0|        ClosePopupsOverWindow(apply_focus_window, false);
12963|      0|        FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_RestoreFocusedChild);
12964|      0|        apply_focus_window = g.NavWindow;
12965|      0|        if (apply_focus_window->NavLastIds[0] == 0)
  ------------------
  |  Branch (12965:13): [True: 0, False: 0]
  ------------------
12966|      0|            NavInitWindow(apply_focus_window, false);
12967|       |
12968|       |        // If the window has ONLY a menu layer (no main layer), select it directly
12969|       |        // Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
12970|       |        // so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
12971|       |        // the target window as already been previewed once.
12972|       |        // FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
12973|       |        // we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
12974|       |        // won't be valid.
12975|      0|        if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
  ------------------
  |  Branch (12975:13): [True: 0, False: 0]
  ------------------
12976|      0|            g.NavLayer = ImGuiNavLayer_Menu;
12977|       |
12978|       |        // Request OS level focus
12979|      0|        if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
  ------------------
  |  Branch (12979:13): [True: 0, False: 0]
  |  Branch (12979:66): [True: 0, False: 0]
  ------------------
12980|      0|            g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
12981|      0|    }
12982|  29.3k|    if (apply_focus_window)
  ------------------
  |  Branch (12982:9): [True: 0, False: 29.3k]
  ------------------
12983|      0|        g.NavWindowingTarget = NULL;
12984|       |
12985|       |    // Apply menu/layer toggle
12986|  29.3k|    if (apply_toggle_layer && g.NavWindow)
  ------------------
  |  Branch (12986:9): [True: 0, False: 29.3k]
  |  Branch (12986:31): [True: 0, False: 0]
  ------------------
12987|      0|    {
12988|      0|        ClearActiveID();
12989|       |
12990|       |        // Move to parent menu if necessary
12991|      0|        ImGuiWindow* new_nav_window = g.NavWindow;
12992|      0|        while (new_nav_window->ParentWindow
  ------------------
  |  Branch (12992:16): [True: 0, False: 0]
  ------------------
12993|      0|            && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
  ------------------
  |  Branch (12993:16): [True: 0, False: 0]
  ------------------
12994|      0|            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
  ------------------
  |  Branch (12994:16): [True: 0, False: 0]
  ------------------
12995|      0|            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (12995:16): [True: 0, False: 0]
  ------------------
12996|      0|            new_nav_window = new_nav_window->ParentWindow;
12997|      0|        if (new_nav_window != g.NavWindow)
  ------------------
  |  Branch (12997:13): [True: 0, False: 0]
  ------------------
12998|      0|        {
12999|      0|            ImGuiWindow* old_nav_window = g.NavWindow;
13000|      0|            FocusWindow(new_nav_window);
13001|      0|            new_nav_window->NavLastChildNavWindow = old_nav_window;
13002|      0|        }
13003|       |
13004|       |        // Toggle layer
13005|      0|        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
  ------------------
  |  Branch (13005:45): [True: 0, False: 0]
  ------------------
13006|      0|        if (new_nav_layer != g.NavLayer)
  ------------------
  |  Branch (13006:13): [True: 0, False: 0]
  ------------------
13007|      0|        {
13008|       |            // Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
13009|      0|            const bool preserve_layer_1_nav_id = (new_nav_window->DockNodeAsHost != NULL);
13010|      0|            if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id)
  ------------------
  |  Branch (13010:17): [True: 0, False: 0]
  |  Branch (13010:56): [True: 0, False: 0]
  ------------------
13011|      0|                g.NavWindow->NavLastIds[new_nav_layer] = 0;
13012|      0|            NavRestoreLayer(new_nav_layer);
13013|      0|            NavRestoreHighlightAfterMove();
13014|      0|        }
13015|      0|    }
13016|  29.3k|}
imgui.cpp:_ZN5ImGuiL22NavUpdateCancelRequestEv:
12585|  29.3k|{
12586|  29.3k|    ImGuiContext& g = *GImGui;
12587|  29.3k|    const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12587:37): [True: 29.3k, False: 0]
  |  Branch (12587:100): [True: 0, False: 29.3k]
  ------------------
12588|  29.3k|    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12589|  29.3k|    if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1385|  29.3k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1326|      0|#define ImGuiKey_NavGamepadCancel       ImGuiKey_GamepadFaceRight
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12589:11): [True: 29.3k, False: 0]
  |  Branch (12589:34): [True: 483, False: 28.8k]
  |  Branch (12589:90): [True: 0, False: 28.8k]
  |  Branch (12589:112): [True: 0, False: 0]
  ------------------
12590|  28.8k|        return;
12591|       |
12592|    483|    IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
  ------------------
  |  |  246|    483|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 483]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12593|    483|    if (g.ActiveId != 0)
  ------------------
  |  Branch (12593:9): [True: 4, False: 479]
  ------------------
12594|      4|    {
12595|      4|        ClearActiveID();
12596|      4|    }
12597|    479|    else if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (12597:14): [True: 0, False: 479]
  ------------------
12598|      0|    {
12599|       |        // Leave the "menu" layer
12600|      0|        NavRestoreLayer(ImGuiNavLayer_Main);
12601|      0|        NavRestoreHighlightAfterMove();
12602|      0|    }
12603|    479|    else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
  ------------------
  |  Branch (12603:14): [True: 345, False: 134]
  |  Branch (12603:29): [True: 285, False: 60]
  |  Branch (12603:71): [True: 285, False: 0]
  |  Branch (12603:121): [True: 285, False: 0]
  ------------------
12604|    285|    {
12605|       |        // Exit child window
12606|    285|        ImGuiWindow* child_window = g.NavWindow;
12607|    285|        ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
12608|    285|        IM_ASSERT(child_window->ChildId != 0);
  ------------------
  |  |   23|    285|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12609|    285|        ImRect child_rect = child_window->Rect();
12610|    285|        FocusWindow(parent_window);
12611|    285|        SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_rect));
12612|    285|        NavRestoreHighlightAfterMove();
12613|    285|    }
12614|    194|    else if (g.OpenPopupStack.Size > 0 && g.OpenPopupStack.back().Window != NULL && !(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
  ------------------
  |  Branch (12614:14): [True: 0, False: 194]
  |  Branch (12614:43): [True: 0, False: 0]
  |  Branch (12614:85): [True: 0, False: 0]
  ------------------
12615|      0|    {
12616|       |        // Close open popup/menu
12617|      0|        ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
12618|      0|    }
12619|    194|    else
12620|    194|    {
12621|       |        // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
12622|    194|        if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
  ------------------
  |  Branch (12622:13): [True: 60, False: 134]
  |  Branch (12622:29): [True: 0, False: 60]
  |  Branch (12622:78): [True: 60, False: 0]
  ------------------
12623|     60|            g.NavWindow->NavLastIds[0] = 0;
12624|    194|        g.NavId = 0;
12625|    194|    }
12626|    483|}
imgui.cpp:_ZN5ImGuiL26NavUpdateCreateMoveRequestEv:
12332|  29.3k|{
12333|  29.3k|    ImGuiContext& g = *GImGui;
12334|  29.3k|    ImGuiIO& io = g.IO;
12335|  29.3k|    ImGuiWindow* window = g.NavWindow;
12336|  29.3k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12336:37): [True: 29.3k, False: 0]
  |  Branch (12336:98): [True: 0, False: 29.3k]
  ------------------
12337|  29.3k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12338|       |
12339|  29.3k|    if (g.NavMoveForwardToNextFrame && window != NULL)
  ------------------
  |  Branch (12339:9): [True: 0, False: 29.3k]
  |  Branch (12339:40): [True: 0, False: 0]
  ------------------
12340|      0|    {
12341|       |        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
12342|       |        // (preserve most state, which were already set by the NavMoveRequestForward() function)
12343|      0|        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12344|      0|        IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12345|      0|        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
  ------------------
  |  |  246|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 0]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12346|      0|    }
12347|  29.3k|    else
12348|  29.3k|    {
12349|       |        // Initiate directional inputs request
12350|  29.3k|        g.NavMoveDir = ImGuiDir_None;
12351|  29.3k|        g.NavMoveFlags = ImGuiNavMoveFlags_None;
12352|  29.3k|        g.NavMoveScrollFlags = ImGuiScrollFlags_None;
12353|  29.3k|        if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (12353:13): [True: 18.3k, False: 11.0k]
  |  Branch (12353:23): [True: 18.3k, False: 0]
  |  Branch (12353:48): [True: 18.3k, False: 0]
  ------------------
12354|  18.3k|        {
12355|  18.3k|            const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateNavMove;
12356|  18.3k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1385|  18.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12356:17): [True: 18.2k, False: 62]
  |  Branch (12356:61): [True: 0, False: 18.2k]
  |  Branch (12356:83): [True: 0, False: 0]
  |  Branch (12356:161): [True: 18.2k, False: 0]
  |  Branch (12356:184): [True: 1.23k, False: 17.0k]
  ------------------
12357|  18.3k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1385|  18.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12357:17): [True: 18.2k, False: 62]
  |  Branch (12357:61): [True: 0, False: 18.2k]
  |  Branch (12357:83): [True: 0, False: 0]
  |  Branch (12357:161): [True: 18.2k, False: 0]
  |  Branch (12357:184): [True: 299, False: 17.9k]
  ------------------
12358|  18.3k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1385|  18.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12358:17): [True: 18.2k, False: 62]
  |  Branch (12358:61): [True: 0, False: 18.2k]
  |  Branch (12358:83): [True: 0, False: 0]
  |  Branch (12358:161): [True: 18.2k, False: 0]
  |  Branch (12358:184): [True: 1.11k, False: 17.1k]
  ------------------
12359|  18.3k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1385|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1385|  18.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12359:17): [True: 18.2k, False: 62]
  |  Branch (12359:61): [True: 0, False: 18.2k]
  |  Branch (12359:83): [True: 0, False: 0]
  |  Branch (12359:161): [True: 18.2k, False: 0]
  |  Branch (12359:184): [True: 124, False: 18.1k]
  ------------------
12360|  18.3k|        }
12361|  29.3k|        g.NavMoveClipDir = g.NavMoveDir;
12362|  29.3k|        g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
12363|  29.3k|    }
12364|       |
12365|       |    // Update PageUp/PageDown/Home/End scroll
12366|       |    // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
12367|  29.3k|    float scoring_rect_offset_y = 0.0f;
12368|  29.3k|    if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
  ------------------
  |  Branch (12368:9): [True: 18.3k, False: 11.0k]
  |  Branch (12368:19): [True: 15.7k, False: 2.56k]
  |  Branch (12368:52): [True: 15.7k, False: 0]
  ------------------
12369|  15.7k|        scoring_rect_offset_y = NavUpdatePageUpPageDown();
12370|  29.3k|    if (scoring_rect_offset_y != 0.0f)
  ------------------
  |  Branch (12370:9): [True: 30, False: 29.3k]
  ------------------
12371|     30|    {
12372|     30|        g.NavScoringNoClipRect = window->InnerRect;
12373|     30|        g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
12374|     30|    }
12375|       |
12376|       |    // [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
12377|       |#if IMGUI_DEBUG_NAV_SCORING
12378|       |    //if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
12379|       |    //    g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
12380|       |    if (io.KeyCtrl)
12381|       |    {
12382|       |        if (g.NavMoveDir == ImGuiDir_None)
12383|       |            g.NavMoveDir = g.NavMoveDirForDebug;
12384|       |        g.NavMoveClipDir = g.NavMoveDir;
12385|       |        g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
12386|       |    }
12387|       |#endif
12388|       |
12389|       |    // Submit
12390|  29.3k|    g.NavMoveForwardToNextFrame = false;
12391|  29.3k|    if (g.NavMoveDir != ImGuiDir_None)
  ------------------
  |  Branch (12391:9): [True: 2.59k, False: 26.7k]
  ------------------
12392|  2.59k|        NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
12393|       |
12394|       |    // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
12395|  29.3k|    if (g.NavMoveSubmitted && g.NavId == 0)
  ------------------
  |  Branch (12395:9): [True: 2.59k, False: 26.7k]
  |  Branch (12395:31): [True: 2.41k, False: 180]
  ------------------
12396|  2.41k|    {
12397|  2.41k|        IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
  ------------------
  |  |  246|  2.41k|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 2.41k]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12398|  2.41k|        g.NavInitRequest = g.NavInitRequestFromMove = true;
12399|  2.41k|        g.NavInitResult.ID = 0;
12400|  2.41k|        g.NavDisableHighlight = false;
12401|  2.41k|    }
12402|       |
12403|       |    // When using gamepad, we project the reference nav bounding box into window visible area.
12404|       |    // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
12405|       |    // since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
12406|  29.3k|    if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != NULL)// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
  ------------------
  |  Branch (12406:9): [True: 2.59k, False: 26.7k]
  |  Branch (12406:31): [True: 0, False: 2.59k]
  |  Branch (12406:79): [True: 0, False: 0]
  |  Branch (12406:115): [True: 0, False: 0]
  ------------------
12407|      0|    {
12408|      0|        bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
12409|      0|        bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
12410|      0|        ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));
12411|       |
12412|       |        // Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
12413|       |        // Otherwise 'inner_rect_rel' would be off on the move result frame.
12414|      0|        inner_rect_rel.Translate(CalcNextScrollFromScrollTargetAndClamp(window) - window->Scroll);
12415|       |
12416|      0|        if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
  ------------------
  |  Branch (12416:14): [True: 0, False: 0]
  |  Branch (12416:25): [True: 0, False: 0]
  |  Branch (12416:37): [True: 0, False: 0]
  ------------------
12417|      0|        {
12418|      0|            IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
  ------------------
  |  |  246|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 0]
  |  |  |  Branch (246:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12419|      0|            float pad_x = ImMin(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
12420|      0|            float pad_y = ImMin(inner_rect_rel.GetHeight(), window->CalcFontSize() * 0.5f); // Terrible approximation for the intent of starting navigation from first fully visible item
12421|      0|            inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX;
  ------------------
  |  Branch (12421:36): [True: 0, False: 0]
  ------------------
12422|      0|            inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX;
  ------------------
  |  Branch (12422:36): [True: 0, False: 0]
  ------------------
12423|      0|            inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
  ------------------
  |  Branch (12423:36): [True: 0, False: 0]
  ------------------
12424|      0|            inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
  ------------------
  |  Branch (12424:36): [True: 0, False: 0]
  ------------------
12425|      0|            window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
12426|      0|            g.NavId = 0;
12427|      0|        }
12428|      0|    }
12429|       |
12430|       |    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
12431|  29.3k|    ImRect scoring_rect;
12432|  29.3k|    if (window != NULL)
  ------------------
  |  Branch (12432:9): [True: 18.3k, False: 11.0k]
  ------------------
12433|  18.3k|    {
12434|  18.3k|        ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
  ------------------
  |  Branch (12434:31): [True: 18.3k, False: 0]
  ------------------
12435|  18.3k|        scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
12436|  18.3k|        scoring_rect.TranslateY(scoring_rect_offset_y);
12437|  18.3k|        if (g.NavMoveSubmitted)
  ------------------
  |  Branch (12437:13): [True: 2.59k, False: 15.7k]
  ------------------
12438|  2.59k|            NavBiasScoringRect(scoring_rect, window->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags);
12439|  18.3k|        IM_ASSERT(!scoring_rect.IsInverted()); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
  ------------------
  |  |   23|  18.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12440|       |        //GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
12441|       |        //if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
12442|  18.3k|    }
12443|  29.3k|    g.NavScoringRect = scoring_rect;
12444|  29.3k|    g.NavScoringNoClipRect.Add(scoring_rect);
12445|  29.3k|}
imgui.cpp:_ZN5ImGuiL23NavUpdatePageUpPageDownEv:
12633|  15.7k|{
12634|  15.7k|    ImGuiContext& g = *GImGui;
12635|  15.7k|    ImGuiWindow* window = g.NavWindow;
12636|  15.7k|    if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (12636:9): [True: 0, False: 15.7k]
  |  Branch (12636:59): [True: 0, False: 15.7k]
  ------------------
12637|      0|        return 0.0f;
12638|       |
12639|  15.7k|    const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ImGuiKeyOwner_None);
  ------------------
  |  | 1385|  15.7k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12640|  15.7k|    const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ImGuiKeyOwner_None);
  ------------------
  |  | 1385|  15.7k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12641|  15.7k|    const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
  ------------------
  |  | 1385|  15.7k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12642|  15.7k|    const bool end_pressed = IsKeyPressed(ImGuiKey_End, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
  ------------------
  |  | 1385|  15.7k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12643|  15.7k|    if (page_up_held == page_down_held && home_pressed == end_pressed) // Proceed if either (not both) are pressed, otherwise early out
  ------------------
  |  Branch (12643:9): [True: 14.8k, False: 925]
  |  Branch (12643:43): [True: 14.8k, False: 2]
  ------------------
12644|  14.8k|        return 0.0f;
12645|       |
12646|    927|    if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (12646:9): [True: 0, False: 927]
  ------------------
12647|      0|        NavRestoreLayer(ImGuiNavLayer_Main);
12648|       |
12649|    927|    if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY)
  ------------------
  |  Branch (12649:9): [True: 573, False: 354]
  |  Branch (12649:51): [True: 521, False: 52]
  ------------------
12650|    521|    {
12651|       |        // Fallback manual-scroll when window has no navigable item
12652|    521|        if (IsKeyPressed(ImGuiKey_PageUp, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat))
  ------------------
  |  | 1385|    521|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12652:13): [True: 136, False: 385]
  ------------------
12653|    136|            SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
12654|    385|        else if (IsKeyPressed(ImGuiKey_PageDown, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat))
  ------------------
  |  | 1385|    385|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12654:18): [True: 1, False: 384]
  ------------------
12655|      1|            SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
12656|    384|        else if (home_pressed)
  ------------------
  |  Branch (12656:18): [True: 1, False: 383]
  ------------------
12657|      1|            SetScrollY(window, 0.0f);
12658|    383|        else if (end_pressed)
  ------------------
  |  Branch (12658:18): [True: 1, False: 382]
  ------------------
12659|      1|            SetScrollY(window, window->ScrollMax.y);
12660|    521|    }
12661|    406|    else
12662|    406|    {
12663|    406|        ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
12664|    406|        const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
12665|    406|        float nav_scoring_rect_offset_y = 0.0f;
12666|    406|        if (IsKeyPressed(ImGuiKey_PageUp, true))
  ------------------
  |  Branch (12666:13): [True: 20, False: 386]
  ------------------
12667|     20|        {
12668|     20|            nav_scoring_rect_offset_y = -page_offset_y;
12669|     20|            g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
12670|     20|            g.NavMoveClipDir = ImGuiDir_Up;
12671|     20|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
12672|     20|        }
12673|    386|        else if (IsKeyPressed(ImGuiKey_PageDown, true))
  ------------------
  |  Branch (12673:18): [True: 10, False: 376]
  ------------------
12674|     10|        {
12675|     10|            nav_scoring_rect_offset_y = +page_offset_y;
12676|     10|            g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
12677|     10|            g.NavMoveClipDir = ImGuiDir_Down;
12678|     10|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
12679|     10|        }
12680|    376|        else if (home_pressed)
  ------------------
  |  Branch (12680:18): [True: 0, False: 376]
  ------------------
12681|      0|        {
12682|       |            // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
12683|       |            // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
12684|       |            // Preserve current horizontal position if we have any.
12685|      0|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
12686|      0|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (12686:17): [True: 0, False: 0]
  ------------------
12687|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
12688|      0|            g.NavMoveDir = ImGuiDir_Down;
12689|      0|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
12690|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
12691|      0|        }
12692|    376|        else if (end_pressed)
  ------------------
  |  Branch (12692:18): [True: 0, False: 376]
  ------------------
12693|      0|        {
12694|      0|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
12695|      0|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (12695:17): [True: 0, False: 0]
  ------------------
12696|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
12697|      0|            g.NavMoveDir = ImGuiDir_Up;
12698|      0|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
12699|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
12700|      0|        }
12701|    406|        return nav_scoring_rect_offset_y;
12702|    406|    }
12703|    521|    return 0.0f;
12704|    927|}
imgui.cpp:_ZL18NavBiasScoringRectR6ImRectR6ImVec2ii:
12308|  2.59k|{
12309|       |    // Bias initial rect
12310|  2.59k|    ImGuiContext& g = *GImGui;
12311|  2.59k|    const ImVec2 rel_to_abs_offset = g.NavWindow->DC.CursorStartPos;
12312|       |
12313|       |    // Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
12314|       |    // - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
12315|       |    // - But each successful move sets new bias on one axis, only cleared when using mouse.
12316|  2.59k|    if ((move_flags & ImGuiNavMoveFlags_Forwarded) == 0)
  ------------------
  |  Branch (12316:9): [True: 2.59k, False: 0]
  ------------------
12317|  2.59k|    {
12318|  2.59k|        if (preferred_pos_rel.x == FLT_MAX)
  ------------------
  |  Branch (12318:13): [True: 1.35k, False: 1.23k]
  ------------------
12319|  1.35k|            preferred_pos_rel.x = ImMin(r.Min.x + 1.0f, r.Max.x) - rel_to_abs_offset.x;
12320|  2.59k|        if (preferred_pos_rel.y == FLT_MAX)
  ------------------
  |  Branch (12320:13): [True: 1.24k, False: 1.35k]
  ------------------
12321|  1.24k|            preferred_pos_rel.y = r.GetCenter().y - rel_to_abs_offset.y;
12322|  2.59k|    }
12323|       |
12324|       |    // Apply general bias on the other axis
12325|  2.59k|    if ((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX)
  ------------------
  |  Branch (12325:10): [True: 1.12k, False: 1.46k]
  |  Branch (12325:37): [True: 144, False: 1.32k]
  |  Branch (12325:67): [True: 1.27k, False: 0]
  ------------------
12326|  1.27k|        r.Min.x = r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
12327|  1.32k|    else if ((move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX)
  ------------------
  |  Branch (12327:15): [True: 1.02k, False: 299]
  |  Branch (12327:44): [True: 299, False: 0]
  |  Branch (12327:75): [True: 1.32k, False: 0]
  ------------------
12328|  1.32k|        r.Min.y = r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
12329|  2.59k|}
imgui.cpp:_ZN5ImGuiL29NavUpdateCreateTabbingRequestEv:
12448|  26.7k|{
12449|  26.7k|    ImGuiContext& g = *GImGui;
12450|  26.7k|    ImGuiWindow* window = g.NavWindow;
12451|  26.7k|    IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
  ------------------
  |  |   23|  26.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12452|  26.7k|    if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (12452:9): [True: 11.0k, False: 15.7k]
  |  Branch (12452:27): [True: 0, False: 15.7k]
  |  Branch (12452:59): [True: 0, False: 15.7k]
  ------------------
12453|  11.0k|        return;
12454|       |
12455|  15.7k|    const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
  ------------------
  |  | 1385|  15.7k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12455:30): [True: 409, False: 15.3k]
  |  Branch (12455:104): [True: 409, False: 0]
  |  Branch (12455:121): [True: 409, False: 0]
  ------------------
12456|  15.7k|    if (!tab_pressed)
  ------------------
  |  Branch (12456:9): [True: 15.3k, False: 409]
  ------------------
12457|  15.3k|        return;
12458|       |
12459|       |    // Initiate tabbing request
12460|       |    // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
12461|       |    // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
12462|    409|    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12463|    409|    if (nav_keyboard_active)
  ------------------
  |  Branch (12463:9): [True: 409, False: 0]
  ------------------
12464|    409|        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavDisableHighlight == true && g.ActiveId == 0) ? 0 : +1;
  ------------------
  |  Branch (12464:27): [True: 0, False: 409]
  |  Branch (12464:49): [True: 8, False: 401]
  |  Branch (12464:82): [True: 8, False: 0]
  ------------------
12465|      0|    else
12466|      0|        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
  ------------------
  |  Branch (12466:27): [True: 0, False: 0]
  |  Branch (12466:48): [True: 0, False: 0]
  ------------------
12467|    409|    ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate;
12468|    409|    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
  ------------------
  |  Branch (12468:37): [True: 0, False: 409]
  ------------------
12469|    409|    ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
  ------------------
  |  Branch (12469:25): [True: 0, False: 409]
  ------------------
12470|    409|    NavMoveRequestSubmit(ImGuiDir_None, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
12471|    409|    g.NavTabbingCounter = -1;
12472|    409|}
imgui.cpp:_ZN5ImGuiL11NavEndFrameEv:
12707|  29.3k|{
12708|  29.3k|    ImGuiContext& g = *GImGui;
12709|       |
12710|       |    // Show CTRL+TAB list window
12711|  29.3k|    if (g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (12711:9): [True: 0, False: 29.3k]
  ------------------
12712|      0|        NavUpdateWindowingOverlay();
12713|       |
12714|       |    // Perform wrap-around in menus
12715|       |    // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
12716|       |    // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
12717|  29.3k|    if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_WrapMask_) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
  ------------------
  |  Branch (12717:9): [True: 21.1k, False: 8.18k]
  |  Branch (12717:24): [True: 2.89k, False: 18.2k]
  |  Branch (12717:58): [True: 0, False: 2.89k]
  |  Branch (12717:108): [True: 0, False: 0]
  ------------------
12718|      0|        NavUpdateCreateWrappingRequest();
12719|  29.3k|}
imgui.cpp:_ZN5ImGuiL14UpdateSettingsEv:
13675|  29.3k|{
13676|       |    // Load settings on first frame (if not explicitly loaded manually before)
13677|  29.3k|    ImGuiContext& g = *GImGui;
13678|  29.3k|    if (!g.SettingsLoaded)
  ------------------
  |  Branch (13678:9): [True: 1, False: 29.3k]
  ------------------
13679|      1|    {
13680|      1|        IM_ASSERT(g.SettingsWindows.empty());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13681|      1|        if (g.IO.IniFilename)
  ------------------
  |  Branch (13681:13): [True: 0, False: 1]
  ------------------
13682|      0|            LoadIniSettingsFromDisk(g.IO.IniFilename);
13683|      1|        g.SettingsLoaded = true;
13684|      1|    }
13685|       |
13686|       |    // Save settings (with a delay after the last modification, so we don't spam disk too much)
13687|  29.3k|    if (g.SettingsDirtyTimer > 0.0f)
  ------------------
  |  Branch (13687:9): [True: 1.80k, False: 27.5k]
  ------------------
13688|  1.80k|    {
13689|  1.80k|        g.SettingsDirtyTimer -= g.IO.DeltaTime;
13690|  1.80k|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (13690:13): [True: 6, False: 1.79k]
  ------------------
13691|      6|        {
13692|      6|            if (g.IO.IniFilename != NULL)
  ------------------
  |  Branch (13692:17): [True: 0, False: 6]
  ------------------
13693|      0|                SaveIniSettingsToDisk(g.IO.IniFilename);
13694|      6|            else
13695|      6|                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
13696|      6|            g.SettingsDirtyTimer = 0.0f;
13697|      6|        }
13698|  1.80k|    }
13699|  29.3k|}
imgui.cpp:_ZL24InitOrLoadWindowSettingsP11ImGuiWindowP19ImGuiWindowSettings:
 5888|      4|{
 5889|       |    // Initial window state with e.g. default/arbitrary window position
 5890|       |    // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
 5891|      4|    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
 5892|      4|    window->Pos = main_viewport->Pos + ImVec2(60, 60);
 5893|      4|    window->Size = window->SizeFull = ImVec2(0, 0);
 5894|      4|    window->ViewportPos = main_viewport->Pos;
 5895|      4|    window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = window->SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
 5896|       |
 5897|      4|    if (settings != NULL)
  ------------------
  |  Branch (5897:9): [True: 0, False: 4]
  ------------------
 5898|      0|    {
 5899|      0|        SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
 5900|      0|        ApplyWindowSettings(window, settings);
 5901|      0|    }
 5902|      4|    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values
 5903|       |
 5904|      4|    if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
  ------------------
  |  Branch (5904:9): [True: 1, False: 3]
  ------------------
 5905|      1|    {
 5906|      1|        window->AutoFitFramesX = window->AutoFitFramesY = 2;
 5907|      1|        window->AutoFitOnlyGrows = false;
 5908|      1|    }
 5909|      3|    else
 5910|      3|    {
 5911|      3|        if (window->Size.x <= 0.0f)
  ------------------
  |  Branch (5911:13): [True: 3, False: 0]
  ------------------
 5912|      3|            window->AutoFitFramesX = 2;
 5913|      3|        if (window->Size.y <= 0.0f)
  ------------------
  |  Branch (5913:13): [True: 3, False: 0]
  ------------------
 5914|      3|            window->AutoFitFramesY = 2;
 5915|      3|        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
  ------------------
  |  Branch (5915:36): [True: 3, False: 0]
  |  Branch (5915:68): [True: 0, False: 0]
  ------------------
 5916|      3|    }
 5917|      4|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsNewFrameEv:
14239|  29.3k|{
14240|  29.3k|    ImGuiContext& g = *GImGui;
14241|  29.3k|    IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14242|       |
14243|       |    // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
14244|       |    // Update Focused status
14245|  29.3k|    const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
14246|  29.3k|    if (viewports_enabled)
  ------------------
  |  Branch (14246:9): [True: 0, False: 29.3k]
  ------------------
14247|      0|    {
14248|      0|        ImGuiViewportP* focused_viewport = NULL;
14249|      0|        for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (14249:39): [True: 0, False: 0]
  ------------------
14250|      0|        {
14251|      0|            const bool platform_funcs_available = viewport->PlatformWindowCreated;
14252|      0|            if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
  ------------------
  |  Branch (14252:17): [True: 0, False: 0]
  |  Branch (14252:61): [True: 0, False: 0]
  ------------------
14253|      0|            {
14254|      0|                bool is_minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
14255|      0|                if (is_minimized)
  ------------------
  |  Branch (14255:21): [True: 0, False: 0]
  ------------------
14256|      0|                    viewport->Flags |= ImGuiViewportFlags_IsMinimized;
14257|      0|                else
14258|      0|                    viewport->Flags &= ~ImGuiViewportFlags_IsMinimized;
14259|      0|            }
14260|       |
14261|       |            // Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
14262|       |            // When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
14263|      0|            if (g.PlatformIO.Platform_GetWindowFocus && platform_funcs_available)
  ------------------
  |  Branch (14263:17): [True: 0, False: 0]
  |  Branch (14263:57): [True: 0, False: 0]
  ------------------
14264|      0|            {
14265|      0|                bool is_focused = g.PlatformIO.Platform_GetWindowFocus(viewport);
14266|      0|                if (is_focused)
  ------------------
  |  Branch (14266:21): [True: 0, False: 0]
  ------------------
14267|      0|                    viewport->Flags |= ImGuiViewportFlags_IsFocused;
14268|      0|                else
14269|      0|                    viewport->Flags &= ~ImGuiViewportFlags_IsFocused;
14270|      0|                if (is_focused)
  ------------------
  |  Branch (14270:21): [True: 0, False: 0]
  ------------------
14271|      0|                    focused_viewport = viewport;
14272|      0|            }
14273|      0|        }
14274|       |
14275|       |        // Focused viewport has changed?
14276|      0|        if (focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport->ID)
  ------------------
  |  Branch (14276:13): [True: 0, False: 0]
  |  Branch (14276:33): [True: 0, False: 0]
  ------------------
14277|      0|        {
14278|      0|            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport->ID);
  ------------------
  |  |  251|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (251:50): [True: 0, False: 0]
  |  |  |  Branch (251:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
14279|      0|            const ImGuiViewport* prev_focused_viewport = FindViewportByID(g.PlatformLastFocusedViewportId);
14280|      0|            const bool prev_focused_has_been_destroyed = (prev_focused_viewport == NULL) || (prev_focused_viewport->PlatformWindowCreated == false);
  ------------------
  |  Branch (14280:58): [True: 0, False: 0]
  |  Branch (14280:93): [True: 0, False: 0]
  ------------------
14281|       |
14282|       |            // Store a tag so we can infer z-order easily from all our windows
14283|       |            // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
14284|       |            // will keep the front most stamp instead of losing it back to their parent viewport.
14285|      0|            if (focused_viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
  ------------------
  |  Branch (14285:17): [True: 0, False: 0]
  ------------------
14286|      0|                focused_viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
14287|      0|            g.PlatformLastFocusedViewportId = focused_viewport->ID;
14288|       |
14289|       |            // Focus associated dear imgui window
14290|       |            // - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
14291|       |            // - if focus didn't happen because we destroyed another window (#6462)
14292|       |            // FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window->Window != NULL' case as well.
14293|      0|            const bool apply_imgui_focus_on_focused_viewport = !IsAnyMouseDown() && !prev_focused_has_been_destroyed;
  ------------------
  |  Branch (14293:64): [True: 0, False: 0]
  |  Branch (14293:85): [True: 0, False: 0]
  ------------------
14294|      0|            if (apply_imgui_focus_on_focused_viewport)
  ------------------
  |  Branch (14294:17): [True: 0, False: 0]
  ------------------
14295|      0|            {
14296|      0|                focused_viewport->LastFocusedHadNavWindow |= (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
  ------------------
  |  Branch (14296:62): [True: 0, False: 0]
  |  Branch (14296:87): [True: 0, False: 0]
  ------------------
14297|      0|                ImGuiFocusRequestFlags focus_request_flags = ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild;
14298|      0|                if (focused_viewport->Window != NULL)
  ------------------
  |  Branch (14298:21): [True: 0, False: 0]
  ------------------
14299|      0|                    FocusWindow(focused_viewport->Window, focus_request_flags);
14300|      0|                else if (focused_viewport->LastFocusedHadNavWindow)
  ------------------
  |  Branch (14300:26): [True: 0, False: 0]
  ------------------
14301|      0|                    FocusTopMostWindowUnderOne(NULL, NULL, focused_viewport, focus_request_flags); // Focus top most in viewport
14302|      0|                else
14303|      0|                    FocusWindow(NULL, focus_request_flags); // No window had focus last time viewport was focused
14304|      0|            }
14305|      0|        }
14306|      0|        if (focused_viewport)
  ------------------
  |  Branch (14306:13): [True: 0, False: 0]
  ------------------
14307|      0|            focused_viewport->LastFocusedHadNavWindow = (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport);
  ------------------
  |  Branch (14307:57): [True: 0, False: 0]
  |  Branch (14307:82): [True: 0, False: 0]
  ------------------
14308|      0|    }
14309|       |
14310|       |    // Create/update main viewport with current platform position.
14311|       |    // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
14312|  29.3k|    ImGuiViewportP* main_viewport = g.Viewports[0];
14313|  29.3k|    IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14314|  29.3k|    IM_ASSERT(main_viewport->Window == NULL);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14315|  29.3k|    ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (14315:32): [True: 0, False: 29.3k]
  ------------------
14316|  29.3k|    ImVec2 main_viewport_size = g.IO.DisplaySize;
14317|  29.3k|    if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_IsMinimized))
  ------------------
  |  Branch (14317:9): [True: 0, False: 29.3k]
  |  Branch (14317:30): [True: 0, False: 0]
  ------------------
14318|      0|    {
14319|      0|        main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
14320|      0|        main_viewport_size = main_viewport->Size;
14321|      0|    }
14322|  29.3k|    AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);
14323|       |
14324|  29.3k|    g.CurrentDpiScale = 0.0f;
14325|  29.3k|    g.CurrentViewport = NULL;
14326|  29.3k|    g.MouseViewport = NULL;
14327|  58.7k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (14327:21): [True: 29.3k, False: 29.3k]
  ------------------
14328|  29.3k|    {
14329|  29.3k|        ImGuiViewportP* viewport = g.Viewports[n];
14330|  29.3k|        viewport->Idx = n;
14331|       |
14332|       |        // Erase unused viewports
14333|  29.3k|        if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
  ------------------
  |  Branch (14333:13): [True: 0, False: 29.3k]
  |  Branch (14333:22): [True: 0, False: 0]
  ------------------
14334|      0|        {
14335|      0|            DestroyViewport(viewport);
14336|      0|            n--;
14337|      0|            continue;
14338|      0|        }
14339|       |
14340|  29.3k|        const bool platform_funcs_available = viewport->PlatformWindowCreated;
14341|  29.3k|        if (viewports_enabled)
  ------------------
  |  Branch (14341:13): [True: 0, False: 29.3k]
  ------------------
14342|      0|        {
14343|       |            // Update Position and Size (from Platform Window to ImGui) if requested.
14344|       |            // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
14345|      0|            if (!(viewport->Flags & ImGuiViewportFlags_IsMinimized) && platform_funcs_available)
  ------------------
  |  Branch (14345:17): [True: 0, False: 0]
  |  Branch (14345:72): [True: 0, False: 0]
  ------------------
14346|      0|            {
14347|       |                // Viewport->WorkPos and WorkSize will be updated below
14348|      0|                if (viewport->PlatformRequestMove)
  ------------------
  |  Branch (14348:21): [True: 0, False: 0]
  ------------------
14349|      0|                    viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
14350|      0|                if (viewport->PlatformRequestResize)
  ------------------
  |  Branch (14350:21): [True: 0, False: 0]
  ------------------
14351|      0|                    viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
14352|      0|            }
14353|      0|        }
14354|       |
14355|       |        // Update/copy monitor info
14356|  29.3k|        UpdateViewportPlatformMonitor(viewport);
14357|       |
14358|       |        // Lock down space taken by menu bars and status bars, reset the offset for functions like BeginMainMenuBar() to alter them again.
14359|  29.3k|        viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
14360|  29.3k|        viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
14361|  29.3k|        viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
14362|  29.3k|        viewport->UpdateWorkRect();
14363|       |
14364|       |        // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
14365|  29.3k|        viewport->Alpha = 1.0f;
14366|       |
14367|       |        // Translate Dear ImGui windows when a Host Viewport has been moved
14368|       |        // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
14369|  29.3k|        const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
14370|  29.3k|        if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
  ------------------
  |  Branch (14370:13): [True: 29.3k, False: 0]
  |  Branch (14370:76): [True: 0, False: 29.3k]
  |  Branch (14370:108): [True: 0, False: 29.3k]
  ------------------
14371|      0|            TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos);
14372|       |
14373|       |        // Update DPI scale
14374|  29.3k|        float new_dpi_scale;
14375|  29.3k|        if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
  ------------------
  |  Branch (14375:13): [True: 0, False: 29.3k]
  |  Branch (14375:56): [True: 0, False: 0]
  ------------------
14376|      0|            new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
14377|  29.3k|        else if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (14377:18): [True: 0, False: 29.3k]
  ------------------
14378|      0|            new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
14379|  29.3k|        else
14380|  29.3k|            new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (14380:29): [True: 29.3k, False: 1]
  ------------------
14381|  29.3k|        if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
  ------------------
  |  Branch (14381:13): [True: 29.3k, False: 1]
  |  Branch (14381:43): [True: 0, False: 29.3k]
  ------------------
14382|      0|        {
14383|      0|            float scale_factor = new_dpi_scale / viewport->DpiScale;
14384|      0|            if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
  ------------------
  |  Branch (14384:17): [True: 0, False: 0]
  ------------------
14385|      0|                ScaleWindowsInViewport(viewport, scale_factor);
14386|       |            //if (viewport == GetMainViewport())
14387|       |            //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);
14388|       |
14389|       |            // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
14390|       |            // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
14391|       |            // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
14392|       |            //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
14393|       |            //    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
14394|      0|        }
14395|  29.3k|        viewport->DpiScale = new_dpi_scale;
14396|  29.3k|    }
14397|       |
14398|       |    // Update fallback monitor
14399|  29.3k|    if (g.PlatformIO.Monitors.Size == 0)
  ------------------
  |  Branch (14399:9): [True: 29.3k, False: 0]
  ------------------
14400|  29.3k|    {
14401|  29.3k|        ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
14402|  29.3k|        monitor->MainPos = main_viewport->Pos;
14403|  29.3k|        monitor->MainSize = main_viewport->Size;
14404|  29.3k|        monitor->WorkPos = main_viewport->WorkPos;
14405|  29.3k|        monitor->WorkSize = main_viewport->WorkSize;
14406|  29.3k|        monitor->DpiScale = main_viewport->DpiScale;
14407|  29.3k|    }
14408|       |
14409|  29.3k|    if (!viewports_enabled)
  ------------------
  |  Branch (14409:9): [True: 29.3k, False: 0]
  ------------------
14410|  29.3k|    {
14411|  29.3k|        g.MouseViewport = main_viewport;
14412|  29.3k|        return;
14413|  29.3k|    }
14414|       |
14415|       |    // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
14416|       |    // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
14417|      0|    ImGuiViewportP* viewport_hovered = NULL;
14418|      0|    if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
  ------------------
  |  Branch (14418:9): [True: 0, False: 0]
  ------------------
14419|      0|    {
14420|      0|        viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
  ------------------
  |  Branch (14420:28): [True: 0, False: 0]
  ------------------
14421|      0|        if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (14421:13): [True: 0, False: 0]
  |  Branch (14421:33): [True: 0, False: 0]
  ------------------
14422|      0|            viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
14423|      0|    }
14424|      0|    else
14425|      0|    {
14426|       |        // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
14427|       |        // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
14428|       |        // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
14429|       |        // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
14430|      0|        viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
14431|      0|    }
14432|      0|    if (viewport_hovered != NULL)
  ------------------
  |  Branch (14432:9): [True: 0, False: 0]
  ------------------
14433|      0|        g.MouseLastHoveredViewport = viewport_hovered;
14434|      0|    else if (g.MouseLastHoveredViewport == NULL)
  ------------------
  |  Branch (14434:14): [True: 0, False: 0]
  ------------------
14435|      0|        g.MouseLastHoveredViewport = g.Viewports[0];
14436|       |
14437|       |    // Update mouse reference viewport
14438|       |    // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
14439|       |    // (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
14440|      0|    if (g.MovingWindow && g.MovingWindow->Viewport)
  ------------------
  |  Branch (14440:9): [True: 0, False: 0]
  |  Branch (14440:27): [True: 0, False: 0]
  ------------------
14441|      0|        g.MouseViewport = g.MovingWindow->Viewport;
14442|      0|    else
14443|      0|        g.MouseViewport = g.MouseLastHoveredViewport;
14444|       |
14445|       |    // When dragging something, always refer to the last hovered viewport.
14446|       |    // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
14447|       |    // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
14448|       |    // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
14449|       |    // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
14450|      0|    const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
14451|      0|    if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
  ------------------
  |  Branch (14451:9): [True: 0, False: 0]
  |  Branch (14451:59): [True: 0, False: 0]
  ------------------
14452|      0|        viewport_hovered = g.MouseLastHoveredViewport;
14453|      0|    if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
  ------------------
  |  Branch (14453:9): [True: 0, False: 0]
  |  Branch (14453:59): [True: 0, False: 0]
  |  Branch (14453:78): [True: 0, False: 0]
  ------------------
14454|      0|        if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (14454:13): [True: 0, False: 0]
  |  Branch (14454:41): [True: 0, False: 0]
  |  Branch (14454:80): [True: 0, False: 0]
  ------------------
14455|      0|            g.MouseViewport = viewport_hovered;
14456|       |
14457|      0|    IM_ASSERT(g.MouseViewport != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14458|      0|}
imgui.cpp:_ZN5ImGuiL29UpdateViewportPlatformMonitorEP14ImGuiViewportP:
14980|  29.3k|{
14981|  29.3k|    viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
14982|  29.3k|}
imgui.cpp:_ZN5ImGuiL26FindPlatformMonitorForRectERK6ImRect:
14948|  29.3k|{
14949|  29.3k|    ImGuiContext& g = *GImGui;
14950|       |
14951|  29.3k|    const int monitor_count = g.PlatformIO.Monitors.Size;
14952|  29.3k|    if (monitor_count <= 1)
  ------------------
  |  Branch (14952:9): [True: 29.3k, False: 0]
  ------------------
14953|  29.3k|        return monitor_count - 1;
14954|       |
14955|       |    // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
14956|       |    // This is necessary for tooltips which always resize down to zero at first.
14957|      0|    const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
14958|      0|    int best_monitor_n = -1;
14959|      0|    float best_monitor_surface = 0.001f;
14960|       |
14961|      0|    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
  ------------------
  |  Branch (14961:29): [True: 0, False: 0]
  |  Branch (14961:71): [True: 0, False: 0]
  ------------------
14962|      0|    {
14963|      0|        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
14964|      0|        const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
14965|      0|        if (monitor_rect.Contains(rect))
  ------------------
  |  Branch (14965:13): [True: 0, False: 0]
  ------------------
14966|      0|            return monitor_n;
14967|      0|        ImRect overlapping_rect = rect;
14968|      0|        overlapping_rect.ClipWithFull(monitor_rect);
14969|      0|        float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
14970|      0|        if (overlapping_surface < best_monitor_surface)
  ------------------
  |  Branch (14970:13): [True: 0, False: 0]
  ------------------
14971|      0|            continue;
14972|      0|        best_monitor_surface = overlapping_surface;
14973|      0|        best_monitor_n = monitor_n;
14974|      0|    }
14975|      0|    return best_monitor_n;
14976|      0|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsEndFrameEv:
14462|  29.3k|{
14463|  29.3k|    ImGuiContext& g = *GImGui;
14464|  29.3k|    g.PlatformIO.Viewports.resize(0);
14465|  58.7k|    for (int i = 0; i < g.Viewports.Size; i++)
  ------------------
  |  Branch (14465:21): [True: 29.3k, False: 29.3k]
  ------------------
14466|  29.3k|    {
14467|  29.3k|        ImGuiViewportP* viewport = g.Viewports[i];
14468|  29.3k|        viewport->LastPos = viewport->Pos;
14469|  29.3k|        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
  ------------------
  |  Branch (14469:13): [True: 0, False: 29.3k]
  |  Branch (14469:57): [True: 0, False: 29.3k]
  |  Branch (14469:85): [True: 0, False: 29.3k]
  ------------------
14470|      0|            if (i > 0) // Always include main viewport in the list
  ------------------
  |  Branch (14470:17): [True: 0, False: 0]
  ------------------
14471|      0|                continue;
14472|  29.3k|        if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
  ------------------
  |  Branch (14472:13): [True: 0, False: 29.3k]
  |  Branch (14472:33): [True: 0, False: 0]
  ------------------
14473|      0|            continue;
14474|  29.3k|        if (i > 0)
  ------------------
  |  Branch (14474:13): [True: 0, False: 29.3k]
  ------------------
14475|  29.3k|            IM_ASSERT(viewport->Window != NULL);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14476|  29.3k|        g.PlatformIO.Viewports.push_back(viewport);
14477|  29.3k|    }
14478|  29.3k|    g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
14479|  29.3k|}
imgui.cpp:_ZN5ImGuiL17AddUpdateViewportEP11ImGuiWindowjRK6ImVec2S4_i:
14483|  29.3k|{
14484|  29.3k|    ImGuiContext& g = *GImGui;
14485|  29.3k|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14486|       |
14487|  29.3k|    flags |= ImGuiViewportFlags_IsPlatformWindow;
14488|  29.3k|    if (window != NULL)
  ------------------
  |  Branch (14488:9): [True: 0, False: 29.3k]
  ------------------
14489|      0|    {
14490|      0|        if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
  ------------------
  |  Branch (14490:13): [True: 0, False: 0]
  |  Branch (14490:31): [True: 0, False: 0]
  ------------------
14491|      0|            flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
14492|      0|        if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (14492:13): [True: 0, False: 0]
  |  Branch (14492:65): [True: 0, False: 0]
  ------------------
14493|      0|            flags |= ImGuiViewportFlags_NoInputs;
14494|      0|        if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
  ------------------
  |  Branch (14494:13): [True: 0, False: 0]
  ------------------
14495|      0|            flags |= ImGuiViewportFlags_NoFocusOnAppearing;
14496|      0|    }
14497|       |
14498|  29.3k|    ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
14499|  29.3k|    if (viewport)
  ------------------
  |  Branch (14499:9): [True: 29.3k, False: 0]
  ------------------
14500|  29.3k|    {
14501|       |        // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
14502|  29.3k|        if (!viewport->PlatformRequestMove || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (14502:13): [True: 29.3k, False: 0]
  |  Branch (14502:47): [True: 0, False: 0]
  ------------------
14503|  29.3k|            viewport->Pos = pos;
14504|  29.3k|        if (!viewport->PlatformRequestResize || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (14504:13): [True: 29.3k, False: 0]
  |  Branch (14504:49): [True: 0, False: 0]
  ------------------
14505|  29.3k|            viewport->Size = size;
14506|  29.3k|        viewport->Flags = flags | (viewport->Flags & (ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_IsFocused)); // Preserve existing flags
14507|  29.3k|    }
14508|      0|    else
14509|      0|    {
14510|       |        // New viewport
14511|      0|        viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 1883|      0|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
14512|      0|        viewport->ID = id;
14513|      0|        viewport->Idx = g.Viewports.Size;
14514|      0|        viewport->Pos = viewport->LastPos = pos;
14515|      0|        viewport->Size = size;
14516|      0|        viewport->Flags = flags;
14517|      0|        UpdateViewportPlatformMonitor(viewport);
14518|      0|        g.Viewports.push_back(viewport);
14519|      0|        g.ViewportCreatedCount++;
14520|      0|        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window->Name : "<NULL>");
  ------------------
  |  |  251|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (239:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (251:50): [True: 0, False: 0]
  |  |  |  Branch (251:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
14521|       |
14522|       |        // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
14523|       |        // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
14524|      0|        g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
14525|      0|        g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
14526|      0|        g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
14527|      0|        g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);
14528|       |
14529|       |        // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
14530|       |        // This is so we can select an appropriate font size on the first frame of our window lifetime
14531|      0|        if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (14531:13): [True: 0, False: 0]
  ------------------
14532|      0|            viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
14533|      0|    }
14534|       |
14535|  29.3k|    viewport->Window = window;
14536|  29.3k|    viewport->LastFrameActive = g.FrameCount;
14537|  29.3k|    viewport->UpdateWorkRect();
14538|  29.3k|    IM_ASSERT(window == NULL || viewport->ID == window->ID);
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14539|       |
14540|  29.3k|    if (window != NULL)
  ------------------
  |  Branch (14540:9): [True: 0, False: 29.3k]
  ------------------
14541|      0|        window->ViewportOwned = true;
14542|       |
14543|  29.3k|    return viewport;
14544|  29.3k|}
imgui.cpp:_ZN5ImGuiL20WindowSelectViewportEP11ImGuiWindow:
14571|  84.6k|{
14572|  84.6k|    ImGuiContext& g = *GImGui;
14573|  84.6k|    ImGuiWindowFlags flags = window->Flags;
14574|  84.6k|    window->ViewportAllowPlatformMonitorExtend = -1;
14575|       |
14576|       |    // Restore main viewport if multi-viewport is not supported by the backend
14577|  84.6k|    ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
14578|  84.6k|    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
  ------------------
  |  Branch (14578:9): [True: 84.6k, False: 0]
  ------------------
14579|  84.6k|    {
14580|  84.6k|        SetWindowViewport(window, main_viewport);
14581|  84.6k|        return;
14582|  84.6k|    }
14583|      0|    window->ViewportOwned = false;
14584|       |
14585|       |    // Appearing popups reset their viewport so they can inherit again
14586|      0|    if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
  ------------------
  |  Branch (14586:9): [True: 0, False: 0]
  |  Branch (14586:74): [True: 0, False: 0]
  ------------------
14587|      0|    {
14588|      0|        window->Viewport = NULL;
14589|      0|        window->ViewportId = 0;
14590|      0|    }
14591|       |
14592|      0|    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
  ------------------
  |  Branch (14592:9): [True: 0, False: 0]
  ------------------
14593|      0|    {
14594|       |        // By default inherit from parent window
14595|      0|        if (window->Viewport == NULL && window->ParentWindow && (!window->ParentWindow->IsFallbackWindow || window->ParentWindow->WasActive))
  ------------------
  |  Branch (14595:13): [True: 0, False: 0]
  |  Branch (14595:41): [True: 0, False: 0]
  |  Branch (14595:66): [True: 0, False: 0]
  |  Branch (14595:109): [True: 0, False: 0]
  ------------------
14596|      0|            window->Viewport = window->ParentWindow->Viewport;
14597|       |
14598|       |        // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
14599|      0|        if (window->Viewport == NULL && window->ViewportId != 0)
  ------------------
  |  Branch (14599:13): [True: 0, False: 0]
  |  Branch (14599:41): [True: 0, False: 0]
  ------------------
14600|      0|        {
14601|      0|            window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
14602|      0|            if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
  ------------------
  |  Branch (14602:17): [True: 0, False: 0]
  |  Branch (14602:45): [True: 0, False: 0]
  |  Branch (14602:81): [True: 0, False: 0]
  ------------------
14603|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
14604|      0|        }
14605|      0|    }
14606|       |
14607|      0|    bool lock_viewport = false;
14608|      0|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
  ------------------
  |  Branch (14608:9): [True: 0, False: 0]
  ------------------
14609|      0|    {
14610|       |        // Code explicitly request a viewport
14611|      0|        window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
14612|      0|        window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
14613|      0|        if (window->Viewport && (window->Flags & ImGuiWindowFlags_DockNodeHost) != 0 && window->Viewport->Window != NULL)
  ------------------
  |  Branch (14613:13): [True: 0, False: 0]
  |  Branch (14613:33): [True: 0, False: 0]
  |  Branch (14613:89): [True: 0, False: 0]
  ------------------
14614|      0|        {
14615|      0|            window->Viewport->Window = window;
14616|      0|            window->Viewport->ID = window->ViewportId = window->ID; // Overwrite ID (always owned by node)
14617|      0|        }
14618|      0|        lock_viewport = true;
14619|      0|    }
14620|      0|    else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (14620:14): [True: 0, False: 0]
  |  Branch (14620:56): [True: 0, False: 0]
  ------------------
14621|      0|    {
14622|       |        // Always inherit viewport from parent window
14623|      0|        if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (14623:13): [True: 0, False: 0]
  |  Branch (14623:33): [True: 0, False: 0]
  ------------------
14624|      0|            IM_ASSERT(window->DockNode->HostWindow->Viewport == window->ParentWindow->Viewport);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14625|      0|        window->Viewport = window->ParentWindow->Viewport;
14626|      0|    }
14627|      0|    else if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (14627:14): [True: 0, False: 0]
  |  Branch (14627:34): [True: 0, False: 0]
  ------------------
14628|      0|    {
14629|       |        // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
14630|      0|        window->Viewport = window->DockNode->HostWindow->Viewport;
14631|      0|    }
14632|      0|    else if (flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (14632:14): [True: 0, False: 0]
  ------------------
14633|      0|    {
14634|      0|        window->Viewport = g.MouseViewport;
14635|      0|    }
14636|      0|    else if (GetWindowAlwaysWantOwnViewport(window))
  ------------------
  |  Branch (14636:14): [True: 0, False: 0]
  ------------------
14637|      0|    {
14638|      0|        window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14639|      0|    }
14640|      0|    else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
  ------------------
  |  Branch (14640:14): [True: 0, False: 0]
  |  Branch (14640:32): [True: 0, False: 0]
  |  Branch (14640:80): [True: 0, False: 0]
  ------------------
14641|      0|    {
14642|      0|        if (window->Viewport != NULL && window->Viewport->Window == window)
  ------------------
  |  Branch (14642:13): [True: 0, False: 0]
  |  Branch (14642:41): [True: 0, False: 0]
  ------------------
14643|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14644|      0|    }
14645|      0|    else
14646|      0|    {
14647|       |        // Merge into host viewport?
14648|       |        // We cannot test window->ViewportOwned as it set lower in the function.
14649|       |        // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
14650|      0|        bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
  ------------------
  |  Branch (14650:49): [True: 0, False: 0]
  |  Branch (14650:69): [True: 0, False: 0]
  |  Branch (14650:108): [True: 0, False: 0]
  |  Branch (14650:127): [True: 0, False: 0]
  ------------------
14651|      0|        if (try_to_merge_into_host_viewport)
  ------------------
  |  Branch (14651:13): [True: 0, False: 0]
  ------------------
14652|      0|            UpdateTryMergeWindowIntoHostViewports(window);
14653|      0|    }
14654|       |
14655|       |    // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
14656|      0|    if (window->Viewport == NULL)
  ------------------
  |  Branch (14656:9): [True: 0, False: 0]
  ------------------
14657|      0|        if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
  ------------------
  |  Branch (14657:13): [True: 0, False: 0]
  ------------------
14658|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14659|       |
14660|       |    // Mark window as allowed to protrude outside of its viewport and into the current monitor
14661|      0|    if (!lock_viewport)
  ------------------
  |  Branch (14661:9): [True: 0, False: 0]
  ------------------
14662|      0|    {
14663|      0|        if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (14663:13): [True: 0, False: 0]
  ------------------
14664|      0|        {
14665|       |            // We need to take account of the possibility that mouse may become invalid.
14666|       |            // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
14667|      0|            ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
  ------------------
  |  Branch (14667:32): [True: 0, False: 0]
  ------------------
14668|      0|            bool use_mouse_ref = (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow);
  ------------------
  |  Branch (14668:35): [True: 0, False: 0]
  |  Branch (14668:60): [True: 0, False: 0]
  |  Branch (14668:87): [True: 0, False: 0]
  ------------------
14669|      0|            bool mouse_valid = IsMousePosValid(&mouse_ref);
14670|      0|            if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
  ------------------
  |  Branch (14670:18): [True: 0, False: 0]
  |  Branch (14670:39): [True: 0, False: 0]
  |  Branch (14670:110): [True: 0, False: 0]
  |  Branch (14670:128): [True: 0, False: 0]
  ------------------
14671|      0|                window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
  ------------------
  |  Branch (14671:89): [True: 0, False: 0]
  |  Branch (14671:106): [True: 0, False: 0]
  ------------------
14672|      0|            else
14673|      0|                window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
14674|      0|        }
14675|      0|        else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow) && window->DockNode == NULL)
  ------------------
  |  Branch (14675:18): [True: 0, False: 0]
  |  Branch (14675:38): [True: 0, False: 0]
  |  Branch (14675:76): [True: 0, False: 0]
  |  Branch (14675:104): [True: 0, False: 0]
  |  Branch (14675:147): [True: 0, False: 0]
  ------------------
14676|      0|        {
14677|       |            // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
14678|      0|            const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
  ------------------
  |  Branch (14678:43): [True: 0, False: 0]
  |  Branch (14678:67): [True: 0, False: 0]
  ------------------
14679|      0|            if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
  ------------------
  |  Branch (14679:17): [True: 0, False: 0]
  |  Branch (14679:68): [True: 0, False: 0]
  |  Branch (14679:120): [True: 0, False: 0]
  ------------------
14680|      0|            {
14681|       |                // Steal/transfer ownership
14682|      0|                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
  ------------------
  |  |  251|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  239|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (251:50): [True: 0, False: 0]
  |  |  |  Branch (251:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
14683|      0|                window->Viewport->Window = window;
14684|      0|                window->Viewport->ID = window->ID;
14685|      0|                window->Viewport->LastNameHash = 0;
14686|      0|            }
14687|      0|            else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
  ------------------
  |  Branch (14687:22): [True: 0, False: 0]
  ------------------
14688|      0|            {
14689|       |                // New viewport
14690|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
14691|      0|            }
14692|      0|        }
14693|      0|        else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
  ------------------
  |  Branch (14693:18): [True: 0, False: 0]
  |  Branch (14693:68): [True: 0, False: 0]
  ------------------
14694|      0|        {
14695|       |            // Regular (non-child, non-popup) windows by default are also allowed to protrude
14696|       |            // Child windows are kept contained within their parent.
14697|      0|            window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
14698|      0|        }
14699|      0|    }
14700|       |
14701|       |    // Update flags
14702|      0|    window->ViewportOwned = (window == window->Viewport->Window);
14703|      0|    window->ViewportId = window->Viewport->ID;
14704|       |
14705|       |    // If the OS window has a title bar, hide our imgui title bar
14706|       |    //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
14707|       |    //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
14708|      0|}
imgui.cpp:_ZN5ImGuiL25UpdateDebugToolItemPickerEv:
20649|  29.3k|{
20650|  29.3k|    ImGuiContext& g = *GImGui;
20651|  29.3k|    g.DebugItemPickerBreakId = 0;
20652|  29.3k|    if (!g.DebugItemPickerActive)
  ------------------
  |  Branch (20652:9): [True: 29.3k, False: 0]
  ------------------
20653|  29.3k|        return;
20654|       |
20655|      0|    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
20656|      0|    SetMouseCursor(ImGuiMouseCursor_Hand);
20657|      0|    if (IsKeyPressed(ImGuiKey_Escape))
  ------------------
  |  Branch (20657:9): [True: 0, False: 0]
  ------------------
20658|      0|        g.DebugItemPickerActive = false;
20659|      0|    const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
20660|      0|    if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
  ------------------
  |  Branch (20660:9): [True: 0, False: 0]
  |  Branch (20660:28): [True: 0, False: 0]
  |  Branch (20660:76): [True: 0, False: 0]
  ------------------
20661|      0|    {
20662|      0|        g.DebugItemPickerBreakId = hovered_id;
20663|      0|        g.DebugItemPickerActive = false;
20664|      0|    }
20665|      0|    for (int mouse_button = 0; mouse_button < 3; mouse_button++)
  ------------------
  |  Branch (20665:32): [True: 0, False: 0]
  ------------------
20666|      0|        if (change_mapping && IsMouseClicked(mouse_button))
  ------------------
  |  Branch (20666:13): [True: 0, False: 0]
  |  Branch (20666:31): [True: 0, False: 0]
  ------------------
20667|      0|            g.DebugItemPickerMouseButton = (ImU8)mouse_button;
20668|      0|    SetNextWindowBgAlpha(0.70f);
20669|      0|    if (!BeginTooltip())
  ------------------
  |  Branch (20669:9): [True: 0, False: 0]
  ------------------
20670|      0|        return;
20671|      0|    Text("HoveredId: 0x%08X", hovered_id);
20672|      0|    Text("Press ESC to abort picking.");
20673|      0|    const char* mouse_button_names[] = { "Left", "Right", "Middle" };
20674|      0|    if (change_mapping)
  ------------------
  |  Branch (20674:9): [True: 0, False: 0]
  ------------------
20675|      0|        Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
20676|      0|    else
20677|      0|        TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
  ------------------
  |  Branch (20677:39): [True: 0, False: 0]
  ------------------
20678|      0|    EndTooltip();
20679|      0|}
imgui.cpp:_ZN5ImGuiL27UpdateDebugToolStackQueriesEv:
20683|  29.3k|{
20684|  29.3k|    ImGuiContext& g = *GImGui;
20685|  29.3k|    ImGuiIDStackTool* tool = &g.DebugIDStackTool;
20686|       |
20687|       |    // Clear hook when id stack tool is not visible
20688|  29.3k|    g.DebugHookIdInfo = 0;
20689|  29.3k|    if (g.FrameCount != tool->LastActiveFrame + 1)
  ------------------
  |  Branch (20689:9): [True: 29.3k, False: 2]
  ------------------
20690|  29.3k|        return;
20691|       |
20692|       |    // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
20693|       |    // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
20694|      2|    const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
  ------------------
  |  Branch (20694:30): [True: 0, False: 2]
  ------------------
20695|      2|    if (tool->QueryId != query_id)
  ------------------
  |  Branch (20695:9): [True: 0, False: 2]
  ------------------
20696|      0|    {
20697|      0|        tool->QueryId = query_id;
20698|      0|        tool->StackLevel = -1;
20699|      0|        tool->Results.resize(0);
20700|      0|    }
20701|      2|    if (query_id == 0)
  ------------------
  |  Branch (20701:9): [True: 2, False: 0]
  ------------------
20702|      2|        return;
20703|       |
20704|       |    // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
20705|      0|    int stack_level = tool->StackLevel;
20706|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (20706:9): [True: 0, False: 0]
  |  Branch (20706:29): [True: 0, False: 0]
  ------------------
20707|      0|        if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
  ------------------
  |  Branch (20707:13): [True: 0, False: 0]
  |  Branch (20707:56): [True: 0, False: 0]
  ------------------
20708|      0|            tool->StackLevel++;
20709|       |
20710|       |    // Update hook
20711|      0|    stack_level = tool->StackLevel;
20712|      0|    if (stack_level == -1)
  ------------------
  |  Branch (20712:9): [True: 0, False: 0]
  ------------------
20713|      0|        g.DebugHookIdInfo = query_id;
20714|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (20714:9): [True: 0, False: 0]
  |  Branch (20714:29): [True: 0, False: 0]
  ------------------
20715|      0|    {
20716|      0|        g.DebugHookIdInfo = tool->Results[stack_level].ID;
20717|      0|        tool->Results[stack_level].QueryFrameCount++;
20718|      0|    }
20719|      0|}

_ZN6ImVec2C2Ev:
  267|   382k|    constexpr ImVec2()                      : x(0.0f), y(0.0f) { }
_ZN6ImVec4C2Ev:
  280|   225k|    constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
_ZN6ImVec2C2Eff:
  268|  17.4M|    constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }
imgui.cpp:_ZmlRK6ImVec2f:
 2550|   302k|static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui.cpp:_ZmiRK6ImVec2S1_:
 2553|   364k|static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui.cpp:_ZplRK6ImVec2S1_:
 2552|   889k|static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
_ZN6ImVec4C2Effff:
  281|   402k|    constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }
_ZN12ImGuiStorage16ImGuiStoragePairC2EjPv:
 2459|      4|        ImGuiStoragePair(ImGuiID _key, void* _val_p)    { key = _key; val_p = _val_p; }
_Znwm12ImNewWrapperPv:
 1878|     12|inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
_ZN15ImGuiPlatformIOC2Ev:
 3329|      1|    ImGuiPlatformIO()               { memset(this, 0, sizeof(*this)); }     // Zero clear
_ZN8ImVectorI20ImGuiPlatformMonitorEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP13ImGuiViewportEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiInputEventEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiWindowStackDataEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiColorModEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiStyleModEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP6ImFontEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIiEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiGroupDataEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiPopupDataEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiNavTreeNodeDataEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformMonitorC2Ev:
 3340|      1|    ImGuiPlatformMonitor()          { MainPos = MainSize = WorkPos = WorkSize = ImVec2(0, 0); DpiScale = 1.0f; PlatformHandle = NULL; }
_ZN12ImGuiPayloadC2Ev:
 2343|      1|    ImGuiPayload()  { Clear(); }
_ZN8ImVectorIhEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiListClipperDataEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImGuiTableTempDataEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImGuiTableEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIfEC2Ev:
 1911|     11|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImDrawChannelEC2Ev:
 1911|      5|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImGuiTabBarEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiPtrOrIndexEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiShrinkWidthItemEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIcEC2Ev:
 1911|     10|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformImeDataC2Ev:
 3350|      2|    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
_ZN8ImVectorI16ImGuiDockRequestEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI21ImGuiDockNodeSettingsEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN15ImGuiTextBufferC2Ev:
 2428|      3|    ImGuiTextBuffer()   { }
_ZN8ImVectorI20ImGuiSettingsHandlerEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16ImGuiContextHookEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiStackLevelInfoEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN13ImGuiViewportC2Ev:
 3213|      1|    ImGuiViewport()     { memset(this, 0, sizeof(*this)); }
_ZN10ImDrawDataC2Ev:
 2892|      1|    ImDrawData()    { Clear(); }
_ZN8ImVectorIP10ImDrawListEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorItE5clearEv:
 1916|      4|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 2, False: 2]
  ------------------
_ZN16ImGuiWindowClassC2Ev:
 2325|      9|    ImGuiWindowClass() { memset(this, 0, sizeof(*this)); ParentViewportId = (ImGuiID)-1; DockingAllowUnclassed = true; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEC2Ev:
 1911|      8|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN10ImDrawListC2EP20ImDrawListSharedData:
 2771|      4|    ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }
_ZN8ImVectorI9ImDrawCmdEC2Ev:
 1911|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImDrawVertEC2Ev:
 1911|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI6ImVec4EC2Ev:
 1911|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIPvEC2Ev:
 1911|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI6ImVec2EC2Ev:
 1911|      5|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN18ImDrawListSplitterC2Ev:
 2700|      4|    inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }
_ZN8ImVectorIP6ImFontEixEi:
 1925|  29.3k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK6ImFont8IsLoadedEv:
 3134|  58.7k|    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
_ZN8ImVectorIP10ImDrawListE6resizeEi:
 1939|  88.1k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 88.1k]
  ------------------
_ZN8ImVectorIP10ImDrawListE7reserveEi:
 1942|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 2]
  |  Branch (1942:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi:
 1938|      2|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 2]
  |  Branch (1938:131): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI9ImDrawCmdE8pop_backEv:
 1947|  71.3k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  71.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_:
 1946|   196k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 5, False: 196k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE7reserveEi:
 1942|      5|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      5|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 5]
  |  Branch (1942:167): [True: 0, False: 5]
  ------------------
_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi:
 1938|      5|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 5]
  |  Branch (1938:131): [True: 5, False: 0]
  ------------------
_ZNK8ImVectorIP10ImDrawListE5emptyEv:
 1920|  29.3k|    inline bool         empty() const                       { return Size == 0; }
_ZNK8ImVectorIP11ImGuiWindowE14_grow_capacityEi:
 1938|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 1, False: 3]
  |  Branch (1938:131): [True: 3, False: 1]
  ------------------
_ZNK8ImVectorIP11ImGuiWindowE8containsERKS1_:
 1953|      6|    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
  ------------------
  |  Branch (1953:126): [True: 3, False: 3]
  |  Branch (1953:147): [True: 0, False: 3]
  ------------------
imgui.cpp:_ZmlRK6ImVec2S1_:
 2554|  51.8k|static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
_ZN10ImDrawList10PathLineToERK6ImVec2:
 2821|   699k|    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
_ZN8ImVectorI6ImVec2E9push_backERKS0_:
 1946|   770k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 4, False: 770k]
  ------------------
_ZN8ImVectorI6ImVec2E7reserveEi:
 1942|  11.2k|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      7|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 11.2k, False: 7]
  |  Branch (1942:167): [True: 2, False: 5]
  ------------------
_ZNK8ImVectorI6ImVec2E14_grow_capacityEi:
 1938|      7|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 2, False: 5]
  |  Branch (1938:131): [True: 7, False: 0]
  ------------------
_ZN10ImDrawList14PathFillConvexEj:
 2823|   126k|    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
_ZN10ImDrawList10PathStrokeEjif:
 2824|   145k|    inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
imgui.cpp:_ZpLR6ImVec2RKS_:
 2559|    473|static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE6resizeEi:
 1939|  29.3k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 29.3k]
  ------------------
_ZN8ImVectorI19ImGuiKeyRoutingDataE4swapERS1_:
 1936|  29.3k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZNK6ImVec2ixEm:
  270|     42|    float  operator[] (size_t idx) const    { IM_ASSERT(idx == 0 || idx == 1); return ((const float*)(const void*)(const char*)this)[idx]; }
  ------------------
  |  |   23|     42|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK11ImFontAtlas7IsBuiltEv:
 3020|  29.3k|    bool                        IsBuilt() const             { return Fonts.Size > 0 && TexReady; } // Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
  ------------------
  |  Branch (3020:70): [True: 29.3k, False: 0]
  |  Branch (3020:88): [True: 29.3k, False: 0]
  ------------------
_ZN8ImVectorI20ImGuiPlatformMonitorE5beginEv:
 1928|      1|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI20ImGuiPlatformMonitorE3endEv:
 1930|      1|    inline T*           end()                               { return Data + Size; }
_ZN6ImVec2ixEm:
  269|  1.41M|    float& operator[] (size_t idx)          { IM_ASSERT(idx == 0 || idx == 1); return ((float*)(void*)(char*)this)[idx]; } // We very rarely use this [] operator, so the assert overhead is fine.
  ------------------
  |  |   23|  1.41M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN12ImGuiPayload5ClearEv:
 2344|      1|    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
_ZN8ImVectorIP13ImGuiViewportE6resizeEi:
 1939|  29.3k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 29.3k]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP13ImGuiViewportE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiEixEi:
 1925|    446|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIcE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorItEC2Ev:
 1911|      8|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjEC2Ev:
 1911|      6|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjED2Ev:
 1914|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1914:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIjE6resizeEi:
 1939|   114k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 2, False: 114k]
  ------------------
_ZN8ImVectorIjE7reserveEi:
 1942|      8|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      8|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 8]
  |  Branch (1942:167): [True: 0, False: 8]
  ------------------
_ZNK8ImVectorIjE14_grow_capacityEi:
 1938|      8|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 8]
  |  Branch (1938:131): [True: 6, False: 2]
  ------------------
_ZN8ImVectorIjE5clearEv:
 1916|      4|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      4|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 4, False: 0]
  ------------------
_ZN8ImVectorItEixEi:
 1925|  2.32k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  2.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowEC2Ev:
 1911|      7|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP14ImGuiViewportPEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiInputEventE9push_backERKS0_:
 1946|  18.6k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 14, False: 18.6k]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE7reserveEi:
 1942|     14|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|     14|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|     12|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 14]
  |  Branch (1942:167): [True: 12, False: 2]
  ------------------
_ZNK8ImVectorI15ImGuiInputEventE14_grow_capacityEi:
 1938|     14|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 12, False: 2]
  |  Branch (1938:131): [True: 14, False: 0]
  ------------------
_ZN8ImVectorItE6resizeEi:
 1939|   699k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 33, False: 699k]
  ------------------
_ZNK8ImVectorItE14_grow_capacityEi:
 1938|     41|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 35, False: 6]
  |  Branch (1938:131): [True: 23, False: 18]
  ------------------
_ZN8ImVectorI15ImGuiInputEventEixEi:
 1925|  25.2k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  25.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE3endEv:
 1931|  84.6k|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE3endEv:
 1930|      4|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE6insertEPKS1_RS3_:
 1952|      4|    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
  ------------------
  |  |   23|      4|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (1952:144): [True: 1, False: 3]
  |  Branch (1952:201): [True: 3, False: 1]
  ------------------
_ZNK8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorIcE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiE9push_backERKi:
 1946|  55.5k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 55.5k]
  ------------------
_ZN8ImVectorIiE7reserveEi:
 1942|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 2]
  |  Branch (1942:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorIiE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE9push_backERKS0_:
 1946|  29.4k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 29.4k]
  ------------------
_ZN8ImVectorI13ImGuiColorModE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiColorModE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE4backEv:
 1934|  29.4k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  29.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiColorModE8pop_backEv:
 1947|  29.4k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  29.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE9push_backERKS0_:
 1946|  29.3k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 29.3k]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiStyleModE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE4backEv:
 1934|  29.3k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE8pop_backEv:
 1947|  29.3k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  29.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE5beginEv:
 1928|   146k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP14ImGuiViewportPE3endEv:
 1930|   146k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorIiED2Ev:
 1914|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1914:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE9push_backERKS1_:
 1946|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP14ImGuiViewportPE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIcE6resizeEiRKc:
 1940|  3.07k|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1940:67): [True: 1, False: 0]
  |  Branch (1940:127): [True: 1, False: 0]
  |  Branch (1940:163): [True: 3.07k, False: 1]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE9push_backERKS1_:
 1946|  29.3k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 29.3k]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPEixEi:
 1925|   231k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   231k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI6ImVec2E5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorI13ImDrawChannelE5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorI16ImGuiContextHookE5beginEv:
 1928|   176k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI16ImGuiContextHookE3endEv:
 1930|   176k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI15ImGuiOldColumnsEC2Ev:
 1911|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjE9push_backERKj:
 1946|   110k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 6, False: 110k]
  ------------------
_ZN8ImVectorIjE4backEv:
 1934|   244k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   244k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIfE5clearEv:
 1916|      6|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 0, False: 6]
  ------------------
_ZN8ImVectorItE7reserveEi:
 1942|     42|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|     42|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|     35|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 42]
  |  Branch (1942:167): [True: 35, False: 7]
  ------------------
_ZN8ImVectorI10ImDrawVertE7reserveEi:
 1942|     32|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|     32|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|     27|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 32]
  |  Branch (1942:167): [True: 27, False: 5]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE6resizeEi:
 1939|  63.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 63.6k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE5beginEv:
 1928|   130k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP11ImGuiWindowE3endEv:
 1930|   130k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorIfEixEi:
 1925|    512|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    512|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImGuiTableTempDataE5beginEv:
 1928|  29.3k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI18ImGuiTableTempDataE3endEv:
 1930|  29.3k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI20ImGuiWindowStackDataE6resizeEi:
 1939|  29.3k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 29.3k]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiWindowStackDataE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI14ImGuiPopupDataE6resizeEi:
 1939|  29.3k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 29.3k]
  ------------------
_ZN8ImVectorIiE6resizeEi:
 1939|  29.3k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 29.3k]
  ------------------
_ZN8ImVectorI14ImGuiGroupDataE6resizeEi:
 1939|  29.3k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 29.3k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE9push_backERKS1_:
 1946|   141k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 4, False: 141k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowEixEi:
 1925|   152k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   152k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI6ImVec4E4backEv:
 1934|   254k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   254k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE4backEv:
 1934|  25.9k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE6resizeEi:
 1939|   114k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 114k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE7reserveEi:
 1942|  29.3k|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      5|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 29.3k, False: 5]
  |  Branch (1942:167): [True: 1, False: 4]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4swapERS2_:
 1936|  29.3k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZN8ImVectorIP10ImDrawListE5beginEv:
 1928|  29.3k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP10ImDrawListE3endEv:
 1930|  29.3k|    inline T*           end()                               { return Data + Size; }
_ZNK8ImVectorI20ImGuiWindowStackDataE5emptyEv:
 1920|  84.6k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI20ImGuiWindowStackDataE4backEv:
 1934|   280k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   280k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE9push_backERKS0_:
 1946|  84.6k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 84.6k]
  ------------------
_ZN8ImVectorI9ImDrawCmdEixEi:
 1925|   163k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   163k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIfE6resizeEi:
 1939|   169k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 169k]
  ------------------
_ZN8ImVectorIfE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIfE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE8pop_backEv:
 1947|  84.6k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4backEv:
 1934|  22.4k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  22.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP6ImFontE9push_backERKS1_:
 1946|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP6ImFontE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE4backEv:
 1934|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE4backEv:
 1934|  51.8k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  51.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE8pop_backEv:
 1947|  25.9k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  25.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIjE8pop_backEv:
 1947|   110k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   110k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorItE9push_backERKt:
 1946|  3.26k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 7, False: 3.26k]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE5eraseEPKS0_S3_:
 1950|  1.45k|    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
  ------------------
  |  |   23|  1.45k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE9push_backERKS0_:
 1946|      3|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 2]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiSettingsHandlerE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE5beginEv:
 1928|      2|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI20ImGuiSettingsHandlerE3endEv:
 1930|      2|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI16ImGuiDockRequestE5beginEv:
 1928|  58.7k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI16ImGuiDockRequestE3endEv:
 1930|  58.7k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI16ImGuiDockRequestE6resizeEi:
 1939|  29.3k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 29.3k]
  ------------------
_ZN8ImVectorIP6ImFontE5beginEv:
 1928|      1|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP6ImFontE3endEv:
 1930|      1|    inline T*           end()                               { return Data + Size; }
_ZN9ImDrawCmdC2Ev:
 2654|   196k|    ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed
_ZN18ImDrawListSplitter5ClearEv:
 2702|  84.6k|    inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame
_ZN21ImFontAtlasCustomRectC2Ev:
 2967|      2|    ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
_ZNK21ImFontAtlasCustomRect8IsPackedEv:
 2968|      2|    bool IsPacked() const           { return X != 0xFFFF; }
_ZN11ImFontAtlas20GetCustomRectByIndexEi:
 3054|      2|    ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectEixEi:
 1925|     16|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui_draw.cpp:_ZmlRK6ImVec4S1_:
 2565|      1|static inline ImVec4  operator*(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }
imgui_draw.cpp:_ZplRK6ImVec2S1_:
 2552|   469k|static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui_draw.cpp:_ZmlRK6ImVec2f:
 2550|   295k|static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui_draw.cpp:_ZmiRK6ImVec2S1_:
 2553|   175k|static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui_draw.cpp:_ZmlRK6ImVec2S1_:
 2554|    128|static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
_ZN8ImVectorI18ImFontBuildSrcDataEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildDstDataEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildSrcDataE6resizeEi:
 1939|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE6resizeEi:
 1939|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildDstDataE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE13size_in_bytesEv:
 1922|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZNK8ImVectorI18ImFontBuildDstDataE13size_in_bytesEv:
 1922|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI18ImFontBuildSrcDataEixEi:
 1925|      7|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI12ImFontConfigEixEi:
 1925|      4|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      4|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataEixEi:
 1925|      3|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIjE5emptyEv:
 1920|      1|    inline bool         empty() const                       { return Size == 0; }
_ZNK8ImVectorIjE5beginEv:
 1929|      1|    inline const T*     begin() const                       { return Data; }
_ZNK8ImVectorIjE3endEv:
 1931|      1|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorI18ImFontBuildDstDataE5clearEv:
 1916|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16stbtt_packedcharE6resizeEi:
 1939|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE13size_in_bytesEv:
 1922|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI16stbtt_packedcharEixEi:
 1925|      1|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI10stbrp_rectE5clearEv:
 1916|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE14clear_destructEv:
 1918|      2|    inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.
  ------------------
  |  Branch (1918:79): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE5clearEv:
 1916|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharED2Ev:
 1914|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1914:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataED2Ev:
 1914|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1914:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataED2Ev:
 1914|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1914:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI9ImDrawCmdE6resizeEi:
 1939|  84.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 84.6k]
  ------------------
_ZN8ImVectorI10ImDrawVertE6resizeEi:
 1939|   662k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 31, False: 662k]
  ------------------
_ZNK8ImVectorI10ImDrawVertE14_grow_capacityEi:
 1938|     31|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 27, False: 4]
  |  Branch (1938:131): [True: 18, False: 13]
  ------------------
_ZN8ImVectorI6ImVec4E6resizeEi:
 1939|  84.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 84.6k]
  ------------------
_ZN8ImVectorI6ImVec4E7reserveEi:
 1942|      5|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      5|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 5]
  |  Branch (1942:167): [True: 0, False: 5]
  ------------------
_ZNK8ImVectorI6ImVec4E14_grow_capacityEi:
 1938|      5|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 5]
  |  Branch (1938:131): [True: 5, False: 0]
  ------------------
_ZN8ImVectorIPvE6resizeEi:
 1939|  84.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 0, False: 84.6k]
  ------------------
_ZN8ImVectorIPvE7reserveEi:
 1942|      5|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      5|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 5]
  |  Branch (1942:167): [True: 0, False: 5]
  ------------------
_ZNK8ImVectorIPvE14_grow_capacityEi:
 1938|      5|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 5]
  |  Branch (1938:131): [True: 5, False: 0]
  ------------------
_ZN8ImVectorI6ImVec2E6resizeEi:
 1939|   256k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 3, False: 256k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI10ImDrawVertE5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorIPvE5clearEv:
 1916|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E9push_backERKS0_:
 1946|   170k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 5, False: 170k]
  ------------------
_ZN8ImVectorI6ImVec4E8pop_backEv:
 1947|  85.7k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  85.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIPvE9push_backERKS0_:
 1946|  84.6k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 5, False: 84.6k]
  ------------------
_ZN8ImVectorI6ImVec2E15reserve_discardEi:
 1943|   271k|    inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
                  inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 1880|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
  |  Branch (1943:67): [True: 271k, False: 2]
  |  Branch (1943:105): [True: 1, False: 1]
  ------------------
_ZN8ImVectorIP10ImDrawListE9push_backERKS1_:
 1946|  42.0k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 2, False: 42.0k]
  ------------------
_ZNK8ImVectorItE5emptyEv:
 1920|  15.4k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI21ImFontAtlasCustomRectEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigEC2Ev:
 1911|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigE5beginEv:
 1928|      2|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI12ImFontConfigE3endEv:
 1930|      2|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI12ImFontConfigE9push_backERKS0_:
 1946|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI12ImFontConfigE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE4backEv:
 1934|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_:
 1946|      2|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1946:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE7reserveEi:
 1942|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 1]
  |  Branch (1942:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI21ImFontAtlasCustomRectE14_grow_capacityEi:
 1938|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 1]
  |  Branch (1938:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10stbrp_rectED2Ev:
 1914|      2|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1914:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI10stbrp_rectE6resizeEi:
 1939|      2|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectE7reserveEi:
 1942|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 2]
  |  Branch (1942:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorI10stbrp_rectE14_grow_capacityEi:
 1938|      2|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 0, False: 2]
  |  Branch (1938:131): [True: 1, False: 1]
  ------------------
_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv:
 1922|      2|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI10stbrp_rectEixEi:
 1925|     20|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     20|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphEC2Ev:
 1911|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImFontGlyphE5clearEv:
 1916|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1916:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI11ImFontGlyphEixEi:
 1925|    669|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    669|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE4backEv:
 1934|    225|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE6resizeEi:
 1939|    224|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1939:67): [True: 10, False: 214]
  ------------------
_ZN8ImVectorI11ImFontGlyphE7reserveEi:
 1942|     10|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1880|     10|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1881|      9|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1942:67): [True: 0, False: 10]
  |  Branch (1942:167): [True: 9, False: 1]
  ------------------
_ZNK8ImVectorI11ImFontGlyphE14_grow_capacityEi:
 1938|     10|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1938:82): [True: 9, False: 1]
  |  Branch (1938:131): [True: 10, False: 0]
  ------------------
_ZN8ImVectorIfE6resizeEiRKf:
 1940|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1940:67): [True: 1, False: 0]
  |  Branch (1940:127): [True: 1, False: 0]
  |  Branch (1940:163): [True: 256, False: 1]
  ------------------
_ZN8ImVectorItE6resizeEiRKt:
 1940|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1940:67): [True: 1, False: 0]
  |  Branch (1940:127): [True: 1, False: 0]
  |  Branch (1940:163): [True: 256, False: 1]
  ------------------
imgui_widgets.cpp:_ZplRK6ImVec2S1_:
 2552|  71.6k|static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

_ZN5ImGui15StyleColorsDarkEP10ImGuiStyle:
  175|      1|{
  176|      1|    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
  ------------------
  |  Branch (176:25): [True: 1, False: 0]
  ------------------
  177|      1|    ImVec4* colors = style->Colors;
  178|       |
  179|      1|    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
  180|      1|    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
  181|      1|    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
  182|      1|    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  183|      1|    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
  184|      1|    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
  185|      1|    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  186|      1|    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
  187|      1|    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  188|      1|    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  189|      1|    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
  190|      1|    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
  191|      1|    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
  192|      1|    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
  193|      1|    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
  194|      1|    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
  195|      1|    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
  196|      1|    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
  197|      1|    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  198|      1|    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
  199|      1|    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  200|      1|    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  201|      1|    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  202|      1|    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
  203|      1|    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
  204|      1|    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
  205|      1|    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  206|      1|    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
  207|      1|    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
  208|      1|    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
  209|      1|    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
  210|      1|    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  211|      1|    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
  212|      1|    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
  213|      1|    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
  214|      1|    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
  215|      1|    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
  216|      1|    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
  217|      1|    colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
  218|      1|    colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
  219|      1|    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
  220|      1|    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
  221|      1|    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
  222|      1|    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
  223|      1|    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
  224|      1|    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
  225|      1|    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
  226|      1|    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  227|      1|    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
  228|      1|    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
  229|      1|    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
  230|      1|    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  231|      1|    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
  232|      1|    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
  233|      1|    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
  234|      1|}
_ZN20ImDrawListSharedDataC2Ev:
  366|      1|{
  367|      1|    memset(this, 0, sizeof(*this));
  368|     49|    for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
  ------------------
  |  |   88|     49|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (368:21): [True: 48, False: 1]
  ------------------
  369|     48|    {
  370|     48|        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |  272|     48|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |   88|     48|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  371|     48|        ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  449|     48|#define ImCos(X)            cosf(X)
  ------------------
                      ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  450|     48|#define ImSin(X)            sinf(X)
  ------------------
  372|     48|    }
  373|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  769|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  449|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  374|      1|}
_ZN20ImDrawListSharedData29SetCircleTessellationMaxErrorEf:
  377|  29.3k|{
  378|  29.3k|    if (CircleSegmentMaxError == max_error)
  ------------------
  |  Branch (378:9): [True: 29.3k, False: 1]
  ------------------
  379|  29.3k|        return;
  380|       |
  381|      1|    IM_ASSERT(max_error > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  382|      1|    CircleSegmentMaxError = max_error;
  383|     65|    for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
  ------------------
  |  |   88|     65|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (383:21): [True: 64, False: 1]
  ------------------
  384|     64|    {
  385|     64|        const float radius = (float)i;
  386|     64|        CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  766|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  763|     63|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  764|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  765|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
                      CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  776|      1|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      1|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (386:41): [True: 63, False: 1]
  ------------------
  387|     64|    }
  388|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  769|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  449|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  389|      1|}
_ZN10ImDrawList17_ResetForNewFrameEv:
  393|  84.6k|{
  394|       |    // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
  395|  84.6k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, ClipRect) == 0);
  ------------------
  |  |  254|  84.6k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  396|  84.6k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, TextureId) == sizeof(ImVec4));
  ------------------
  |  |  254|  84.6k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  397|  84.6k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
  ------------------
  |  |  254|  84.6k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  398|  84.6k|    if (_Splitter._Count > 1)
  ------------------
  |  Branch (398:9): [True: 0, False: 84.6k]
  ------------------
  399|      0|        _Splitter.Merge(this);
  400|       |
  401|  84.6k|    CmdBuffer.resize(0);
  402|  84.6k|    IdxBuffer.resize(0);
  403|  84.6k|    VtxBuffer.resize(0);
  404|  84.6k|    Flags = _Data->InitialFlags;
  405|  84.6k|    memset(&_CmdHeader, 0, sizeof(_CmdHeader));
  406|  84.6k|    _VtxCurrentIdx = 0;
  407|  84.6k|    _VtxWritePtr = NULL;
  408|  84.6k|    _IdxWritePtr = NULL;
  409|  84.6k|    _ClipRectStack.resize(0);
  410|  84.6k|    _TextureIdStack.resize(0);
  411|  84.6k|    _Path.resize(0);
  412|  84.6k|    _Splitter.Clear();
  413|  84.6k|    CmdBuffer.push_back(ImDrawCmd());
  414|  84.6k|    _FringeScale = 1.0f;
  415|  84.6k|}
_ZN10ImDrawList16_ClearFreeMemoryEv:
  418|      2|{
  419|      2|    CmdBuffer.clear();
  420|      2|    IdxBuffer.clear();
  421|      2|    VtxBuffer.clear();
  422|      2|    Flags = ImDrawListFlags_None;
  423|      2|    _VtxCurrentIdx = 0;
  424|      2|    _VtxWritePtr = NULL;
  425|      2|    _IdxWritePtr = NULL;
  426|      2|    _ClipRectStack.clear();
  427|      2|    _TextureIdStack.clear();
  428|      2|    _Path.clear();
  429|      2|    _Splitter.ClearFreeMemory();
  430|      2|}
_ZN10ImDrawList10AddDrawCmdEv:
  443|   111k|{
  444|   111k|    ImDrawCmd draw_cmd;
  445|   111k|    draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
  446|   111k|    draw_cmd.TextureId = _CmdHeader.TextureId;
  447|   111k|    draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
  448|   111k|    draw_cmd.IdxOffset = IdxBuffer.Size;
  449|       |
  450|   111k|    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
  ------------------
  |  |   23|   111k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  451|   111k|    CmdBuffer.push_back(draw_cmd);
  452|   111k|}
_ZN10ImDrawList17_PopUnusedDrawCmdEv:
  457|  42.0k|{
  458|  80.6k|    while (CmdBuffer.Size > 0)
  ------------------
  |  Branch (458:12): [True: 80.6k, False: 0]
  ------------------
  459|  80.6k|    {
  460|  80.6k|        ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  461|  80.6k|        if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
  ------------------
  |  Branch (461:13): [True: 42.0k, False: 38.6k]
  |  Branch (461:41): [True: 0, False: 38.6k]
  ------------------
  462|  42.0k|            return;// break;
  463|  38.6k|        CmdBuffer.pop_back();
  464|  38.6k|    }
  465|  42.0k|}
_ZN10ImDrawList18_OnChangedClipRectEv:
  505|   256k|{
  506|       |    // If current command is used with different settings we need to add a new command
  507|   256k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  260|   256k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   256k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  508|   256k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  509|   256k|    if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
  ------------------
  |  Branch (509:9): [True: 111k, False: 144k]
  |  Branch (509:37): [True: 111k, False: 0]
  ------------------
  510|   111k|    {
  511|   111k|        AddDrawCmd();
  512|   111k|        return;
  513|   111k|    }
  514|   144k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|   144k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  515|       |
  516|       |    // Try to merge with previous command if it matches, else use current command
  517|   144k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  518|   144k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  485|  33.8k|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  484|  33.8k|#define ImDrawCmd_HeaderSize                            (IM_OFFSETOF(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  |  |  ------------------
  |  |  |  |  |  |   90|  33.8k|#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  487|   177k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (487:57): [True: 32.7k, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (518:9): [True: 144k, False: 0]
  |  Branch (518:37): [True: 33.8k, False: 110k]
  |  Branch (518:59): [True: 32.7k, False: 1.01k]
  |  Branch (518:170): [True: 32.7k, False: 0]
  ------------------
  519|  32.7k|    {
  520|  32.7k|        CmdBuffer.pop_back();
  521|  32.7k|        return;
  522|  32.7k|    }
  523|       |
  524|   111k|    curr_cmd->ClipRect = _CmdHeader.ClipRect;
  525|   111k|}
_ZN10ImDrawList19_OnChangedTextureIDEv:
  528|  84.6k|{
  529|       |    // If current command is used with different settings we need to add a new command
  530|  84.6k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  260|  84.6k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  531|  84.6k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  532|  84.6k|    if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
  ------------------
  |  Branch (532:9): [True: 0, False: 84.6k]
  |  Branch (532:37): [True: 0, False: 0]
  ------------------
  533|      0|    {
  534|      0|        AddDrawCmd();
  535|      0|        return;
  536|      0|    }
  537|  84.6k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|  84.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  538|       |
  539|       |    // Try to merge with previous command if it matches, else use current command
  540|  84.6k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  541|  84.6k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  485|      0|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  484|      0|#define ImDrawCmd_HeaderSize                            (IM_OFFSETOF(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  |  |  ------------------
  |  |  |  |  |  |   90|      0|#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  487|  84.6k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (487:57): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (541:9): [True: 84.6k, False: 0]
  |  Branch (541:37): [True: 0, False: 84.6k]
  |  Branch (541:59): [True: 0, False: 0]
  |  Branch (541:170): [True: 0, False: 0]
  ------------------
  542|      0|    {
  543|      0|        CmdBuffer.pop_back();
  544|      0|        return;
  545|      0|    }
  546|       |
  547|  84.6k|    curr_cmd->TextureId = _CmdHeader.TextureId;
  548|  84.6k|}
_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf:
  567|   172k|{
  568|       |    // Automatic segment count
  569|   172k|    const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy
  570|   172k|    if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
  ------------------
  |  |   88|   172k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (570:9): [True: 172k, False: 0]
  |  Branch (570:28): [True: 172k, False: 0]
  ------------------
  571|   172k|        return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
  572|      0|    else
  573|      0|        return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
  ------------------
  |  |  766|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  763|      0|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  764|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  765|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
  574|   172k|}
_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b:
  578|   170k|{
  579|   170k|    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
  580|   170k|    if (intersect_with_current_clip_rect)
  ------------------
  |  Branch (580:9): [True: 84.6k, False: 85.7k]
  ------------------
  581|  84.6k|    {
  582|  84.6k|        ImVec4 current = _CmdHeader.ClipRect;
  583|  84.6k|        if (cr.x < current.x) cr.x = current.x;
  ------------------
  |  Branch (583:13): [True: 0, False: 84.6k]
  ------------------
  584|  84.6k|        if (cr.y < current.y) cr.y = current.y;
  ------------------
  |  Branch (584:13): [True: 0, False: 84.6k]
  ------------------
  585|  84.6k|        if (cr.z > current.z) cr.z = current.z;
  ------------------
  |  Branch (585:13): [True: 0, False: 84.6k]
  ------------------
  586|  84.6k|        if (cr.w > current.w) cr.w = current.w;
  ------------------
  |  Branch (586:13): [True: 0, False: 84.6k]
  ------------------
  587|  84.6k|    }
  588|   170k|    cr.z = ImMax(cr.x, cr.z);
  589|   170k|    cr.w = ImMax(cr.y, cr.w);
  590|       |
  591|   170k|    _ClipRectStack.push_back(cr);
  592|   170k|    _CmdHeader.ClipRect = cr;
  593|   170k|    _OnChangedClipRect();
  594|   170k|}
_ZN10ImDrawList11PopClipRectEv:
  602|  85.7k|{
  603|  85.7k|    _ClipRectStack.pop_back();
  604|  85.7k|    _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
  ------------------
  |  Branch (604:27): [True: 0, False: 85.7k]
  ------------------
  605|  85.7k|    _OnChangedClipRect();
  606|  85.7k|}
_ZN10ImDrawList13PushTextureIDEPv:
  609|  84.6k|{
  610|  84.6k|    _TextureIdStack.push_back(texture_id);
  611|  84.6k|    _CmdHeader.TextureId = texture_id;
  612|  84.6k|    _OnChangedTextureID();
  613|  84.6k|}
_ZN10ImDrawList11PrimReserveEii:
  626|   577k|{
  627|       |    // Large mesh support (when enabled)
  628|   577k|    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
  ------------------
  |  |  260|   577k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   577k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  629|   577k|    if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (629:9): [Folded - Ignored]
  |  Branch (629:35): [True: 0, False: 577k]
  |  Branch (629:80): [True: 0, False: 0]
  ------------------
  630|      0|    {
  631|       |        // FIXME: In theory we should be testing that vtx_count <64k here.
  632|       |        // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
  633|       |        // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
  634|      0|        _CmdHeader.VtxOffset = VtxBuffer.Size;
  635|      0|        _OnChangedVtxOffset();
  636|      0|    }
  637|       |
  638|   577k|    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  639|   577k|    draw_cmd->ElemCount += idx_count;
  640|       |
  641|   577k|    int vtx_buffer_old_size = VtxBuffer.Size;
  642|   577k|    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
  643|   577k|    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;
  644|       |
  645|   577k|    int idx_buffer_old_size = IdxBuffer.Size;
  646|   577k|    IdxBuffer.resize(idx_buffer_old_size + idx_count);
  647|   577k|    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
  648|   577k|}
_ZN10ImDrawList8PrimRectERK6ImVec2S2_j:
  663|   230k|{
  664|   230k|    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
  665|   230k|    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
  666|   230k|    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
  667|   230k|    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
  668|   230k|    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
  669|   230k|    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
  670|   230k|    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
  671|   230k|    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
  672|   230k|    _VtxWritePtr += 4;
  673|   230k|    _VtxCurrentIdx += 4;
  674|   230k|    _IdxWritePtr += 6;
  675|   230k|}
_ZN10ImDrawList11AddPolylineEPK6ImVec2ijif:
  716|   145k|{
  717|   145k|    if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|   145k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (717:9): [True: 0, False: 145k]
  |  Branch (717:29): [True: 0, False: 145k]
  ------------------
  718|      0|        return;
  719|       |
  720|   145k|    const bool closed = (flags & ImDrawFlags_Closed) != 0;
  721|   145k|    const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
  722|   145k|    const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
  ------------------
  |  Branch (722:23): [True: 115k, False: 29.7k]
  ------------------
  723|   145k|    const bool thick_line = (thickness > _FringeScale);
  724|       |
  725|   145k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (725:9): [True: 145k, False: 0]
  ------------------
  726|   145k|    {
  727|       |        // Anti-aliased stroke
  728|   145k|        const float AA_SIZE = _FringeScale;
  729|   145k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2583|   145k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  730|       |
  731|       |        // Thicknesses <1.0 should behave like thickness 1.0
  732|   145k|        thickness = ImMax(thickness, 1.0f);
  733|   145k|        const int integer_thickness = (int)thickness;
  734|   145k|        const float fractional_thickness = thickness - integer_thickness;
  735|       |
  736|       |        // Do we want to draw this line using a texture?
  737|       |        // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
  738|       |        // - If AA_SIZE is not 1.0f we cannot use the texture path.
  739|   145k|        const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);
  ------------------
  |  | 2619|   145k|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (739:34): [True: 145k, False: 0]
  |  Branch (739:86): [True: 145k, False: 0]
  |  Branch (739:143): [True: 145k, False: 0]
  |  Branch (739:181): [True: 145k, False: 0]
  ------------------
  740|       |
  741|       |        // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
  742|   145k|        IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
  ------------------
  |  |  260|   145k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   145k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  743|       |
  744|   145k|        const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
  ------------------
  |  Branch (744:31): [True: 145k, False: 0]
  |  Branch (744:60): [True: 0, False: 0]
  ------------------
  745|   145k|        const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
  ------------------
  |  Branch (745:31): [True: 145k, False: 0]
  |  Branch (745:67): [True: 0, False: 0]
  ------------------
  746|   145k|        PrimReserve(idx_count, vtx_count);
  747|       |
  748|       |        // Temporary buffer
  749|       |        // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
  750|   145k|        _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
  ------------------
  |  Branch (750:60): [True: 145k, False: 0]
  |  Branch (750:75): [True: 0, False: 0]
  ------------------
  751|   145k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
  752|   145k|        ImVec2* temp_points = temp_normals + points_count;
  753|       |
  754|       |        // Calculate normals (tangents) for each line segment
  755|   732k|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (755:26): [True: 587k, False: 145k]
  ------------------
  756|   587k|        {
  757|   587k|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (757:28): [True: 115k, False: 471k]
  ------------------
  758|   587k|            float dx = points[i2].x - points[i1].x;
  759|   587k|            float dy = points[i2].y - points[i1].y;
  760|   587k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|   587k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 587k, False: 50]
  |  |  ------------------
  ------------------
  761|   587k|            temp_normals[i1].x = dy;
  762|   587k|            temp_normals[i1].y = -dx;
  763|   587k|        }
  764|   145k|        if (!closed)
  ------------------
  |  Branch (764:13): [True: 29.7k, False: 115k]
  ------------------
  765|  29.7k|            temp_normals[points_count - 1] = temp_normals[points_count - 2];
  766|       |
  767|       |        // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
  768|   145k|        if (use_texture || !thick_line)
  ------------------
  |  Branch (768:13): [True: 145k, False: 0]
  |  Branch (768:28): [True: 0, False: 0]
  ------------------
  769|   145k|        {
  770|       |            // [PATH 1] Texture-based lines (thick or non-thick)
  771|       |            // [PATH 2] Non texture-based lines (non-thick)
  772|       |
  773|       |            // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
  774|       |            // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
  775|       |            //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
  776|       |            // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
  777|       |            //   allow scaling geometry while preserving one-screen-pixel AA fringe).
  778|   145k|            const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;
  ------------------
  |  Branch (778:42): [True: 145k, False: 0]
  ------------------
  779|       |
  780|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  781|   145k|            if (!closed)
  ------------------
  |  Branch (781:17): [True: 29.7k, False: 115k]
  ------------------
  782|  29.7k|            {
  783|  29.7k|                temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
  784|  29.7k|                temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
  785|  29.7k|                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
  786|  29.7k|                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
  787|  29.7k|            }
  788|       |
  789|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  790|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  791|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  792|   145k|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  793|   732k|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (793:30): [True: 587k, False: 145k]
  ------------------
  794|   587k|            {
  795|   587k|                const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
  ------------------
  |  Branch (795:32): [True: 115k, False: 471k]
  ------------------
  796|   587k|                const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment
  ------------------
  |  Branch (796:43): [True: 115k, False: 471k]
  |  Branch (796:98): [True: 471k, False: 0]
  ------------------
  797|       |
  798|       |                // Average normals
  799|   587k|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  800|   587k|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  801|   587k|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|   587k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|   587k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 587k, False: 40]
  |  |  |  Branch (711:127): [True: 0, False: 587k]
  |  |  ------------------
  ------------------
  802|   587k|                dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
  803|   587k|                dm_y *= half_draw_size;
  804|       |
  805|       |                // Add temporary vertexes for the outer edges
  806|   587k|                ImVec2* out_vtx = &temp_points[i2 * 2];
  807|   587k|                out_vtx[0].x = points[i2].x + dm_x;
  808|   587k|                out_vtx[0].y = points[i2].y + dm_y;
  809|   587k|                out_vtx[1].x = points[i2].x - dm_x;
  810|   587k|                out_vtx[1].y = points[i2].y - dm_y;
  811|       |
  812|   587k|                if (use_texture)
  ------------------
  |  Branch (812:21): [True: 587k, False: 0]
  ------------------
  813|   587k|                {
  814|       |                    // Add indices for two triangles
  815|   587k|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
  816|   587k|                    _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
  817|   587k|                    _IdxWritePtr += 6;
  818|   587k|                }
  819|      0|                else
  820|      0|                {
  821|       |                    // Add indexes for four triangles
  822|      0|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
  823|      0|                    _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
  824|      0|                    _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
  825|      0|                    _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
  826|      0|                    _IdxWritePtr += 12;
  827|      0|                }
  828|       |
  829|   587k|                idx1 = idx2;
  830|   587k|            }
  831|       |
  832|       |            // Add vertexes for each point on the line
  833|   145k|            if (use_texture)
  ------------------
  |  Branch (833:17): [True: 145k, False: 0]
  ------------------
  834|   145k|            {
  835|       |                // If we're using textures we only need to emit the left/right edge vertices
  836|   145k|                ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
  837|       |                /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
  838|       |                {
  839|       |                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
  840|       |                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
  841|       |                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
  842|       |                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
  843|       |                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
  844|       |                }*/
  845|   145k|                ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
  846|   145k|                ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
  847|   762k|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (847:33): [True: 617k, False: 145k]
  ------------------
  848|   617k|                {
  849|   617k|                    _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
  850|   617k|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
  851|   617k|                    _VtxWritePtr += 2;
  852|   617k|                }
  853|   145k|            }
  854|      0|            else
  855|      0|            {
  856|       |                // If we're not using a texture, we need the center vertex as well
  857|      0|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (857:33): [True: 0, False: 0]
  ------------------
  858|      0|                {
  859|      0|                    _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
  860|      0|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge
  861|      0|                    _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge
  862|      0|                    _VtxWritePtr += 3;
  863|      0|                }
  864|      0|            }
  865|   145k|        }
  866|      0|        else
  867|      0|        {
  868|       |            // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
  869|      0|            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
  870|       |
  871|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  872|      0|            if (!closed)
  ------------------
  |  Branch (872:17): [True: 0, False: 0]
  ------------------
  873|      0|            {
  874|      0|                const int points_last = points_count - 1;
  875|      0|                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
  876|      0|                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
  877|      0|                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
  878|      0|                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
  879|      0|                temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  880|      0|                temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
  881|      0|                temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
  882|      0|                temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  883|      0|            }
  884|       |
  885|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  886|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  887|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  888|      0|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  889|      0|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (889:30): [True: 0, False: 0]
  ------------------
  890|      0|            {
  891|      0|                const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
  ------------------
  |  Branch (891:32): [True: 0, False: 0]
  ------------------
  892|      0|                const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment
  ------------------
  |  Branch (892:43): [True: 0, False: 0]
  ------------------
  893|       |
  894|       |                // Average normals
  895|      0|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  896|      0|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  897|      0|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|      0|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 0, False: 0]
  |  |  |  Branch (711:127): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  898|      0|                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
  899|      0|                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
  900|      0|                float dm_in_x = dm_x * half_inner_thickness;
  901|      0|                float dm_in_y = dm_y * half_inner_thickness;
  902|       |
  903|       |                // Add temporary vertices
  904|      0|                ImVec2* out_vtx = &temp_points[i2 * 4];
  905|      0|                out_vtx[0].x = points[i2].x + dm_out_x;
  906|      0|                out_vtx[0].y = points[i2].y + dm_out_y;
  907|      0|                out_vtx[1].x = points[i2].x + dm_in_x;
  908|      0|                out_vtx[1].y = points[i2].y + dm_in_y;
  909|      0|                out_vtx[2].x = points[i2].x - dm_in_x;
  910|      0|                out_vtx[2].y = points[i2].y - dm_in_y;
  911|      0|                out_vtx[3].x = points[i2].x - dm_out_x;
  912|      0|                out_vtx[3].y = points[i2].y - dm_out_y;
  913|       |
  914|       |                // Add indexes
  915|      0|                _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);
  916|      0|                _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);
  917|      0|                _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);
  918|      0|                _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
  919|      0|                _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
  920|      0|                _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
  921|      0|                _IdxWritePtr += 18;
  922|       |
  923|      0|                idx1 = idx2;
  924|      0|            }
  925|       |
  926|       |            // Add vertices
  927|      0|            for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (927:29): [True: 0, False: 0]
  ------------------
  928|      0|            {
  929|      0|                _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
  930|      0|                _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  931|      0|                _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  932|      0|                _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
  933|      0|                _VtxWritePtr += 4;
  934|      0|            }
  935|      0|        }
  936|   145k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
  937|   145k|    }
  938|      0|    else
  939|      0|    {
  940|       |        // [PATH 4] Non texture-based, Non anti-aliased lines
  941|      0|        const int idx_count = count * 6;
  942|      0|        const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
  943|      0|        PrimReserve(idx_count, vtx_count);
  944|       |
  945|      0|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (945:26): [True: 0, False: 0]
  ------------------
  946|      0|        {
  947|      0|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (947:28): [True: 0, False: 0]
  ------------------
  948|      0|            const ImVec2& p1 = points[i1];
  949|      0|            const ImVec2& p2 = points[i2];
  950|       |
  951|      0|            float dx = p2.x - p1.x;
  952|      0|            float dy = p2.y - p1.y;
  953|      0|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|      0|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  954|      0|            dx *= (thickness * 0.5f);
  955|      0|            dy *= (thickness * 0.5f);
  956|       |
  957|      0|            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;
  958|      0|            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  959|      0|            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  960|      0|            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;
  961|      0|            _VtxWritePtr += 4;
  962|       |
  963|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
  964|      0|            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
  965|      0|            _IdxWritePtr += 6;
  966|      0|            _VtxCurrentIdx += 4;
  967|      0|        }
  968|      0|    }
  969|   145k|}
_ZN10ImDrawList19AddConvexPolyFilledEPK6ImVec2ij:
  974|   126k|{
  975|   126k|    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|   126k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (975:9): [True: 0, False: 126k]
  |  Branch (975:29): [True: 0, False: 126k]
  ------------------
  976|      0|        return;
  977|       |
  978|   126k|    const ImVec2 uv = _Data->TexUvWhitePixel;
  979|       |
  980|   126k|    if (Flags & ImDrawListFlags_AntiAliasedFill)
  ------------------
  |  Branch (980:9): [True: 126k, False: 0]
  ------------------
  981|   126k|    {
  982|       |        // Anti-aliased Fill
  983|   126k|        const float AA_SIZE = _FringeScale;
  984|   126k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2583|   126k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  985|   126k|        const int idx_count = (points_count - 2)*3 + points_count * 6;
  986|   126k|        const int vtx_count = (points_count * 2);
  987|   126k|        PrimReserve(idx_count, vtx_count);
  988|       |
  989|       |        // Add indexes for fill
  990|   126k|        unsigned int vtx_inner_idx = _VtxCurrentIdx;
  991|   126k|        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
  992|   403k|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (992:25): [True: 276k, False: 126k]
  ------------------
  993|   276k|        {
  994|   276k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
  995|   276k|            _IdxWritePtr += 3;
  996|   276k|        }
  997|       |
  998|       |        // Compute normals
  999|   126k|        _Data->TempBuffer.reserve_discard(points_count);
 1000|   126k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
 1001|   656k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1001:49): [True: 529k, False: 126k]
  ------------------
 1002|   529k|        {
 1003|   529k|            const ImVec2& p0 = points[i0];
 1004|   529k|            const ImVec2& p1 = points[i1];
 1005|   529k|            float dx = p1.x - p0.x;
 1006|   529k|            float dy = p1.y - p0.y;
 1007|   529k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|   529k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 529k, False: 0]
  |  |  ------------------
  ------------------
 1008|   529k|            temp_normals[i0].x = dy;
 1009|   529k|            temp_normals[i0].y = -dx;
 1010|   529k|        }
 1011|       |
 1012|   656k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1012:49): [True: 529k, False: 126k]
  ------------------
 1013|   529k|        {
 1014|       |            // Average normals
 1015|   529k|            const ImVec2& n0 = temp_normals[i0];
 1016|   529k|            const ImVec2& n1 = temp_normals[i1];
 1017|   529k|            float dm_x = (n0.x + n1.x) * 0.5f;
 1018|   529k|            float dm_y = (n0.y + n1.y) * 0.5f;
 1019|   529k|            IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|   529k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|   529k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 529k, False: 0]
  |  |  |  Branch (711:127): [True: 0, False: 529k]
  |  |  ------------------
  ------------------
 1020|   529k|            dm_x *= AA_SIZE * 0.5f;
 1021|   529k|            dm_y *= AA_SIZE * 0.5f;
 1022|       |
 1023|       |            // Add vertices
 1024|   529k|            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
 1025|   529k|            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
 1026|   529k|            _VtxWritePtr += 2;
 1027|       |
 1028|       |            // Add indexes for fringes
 1029|   529k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
 1030|   529k|            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
 1031|   529k|            _IdxWritePtr += 6;
 1032|   529k|        }
 1033|   126k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1034|   126k|    }
 1035|      0|    else
 1036|      0|    {
 1037|       |        // Non Anti-aliased Fill
 1038|      0|        const int idx_count = (points_count - 2)*3;
 1039|      0|        const int vtx_count = points_count;
 1040|      0|        PrimReserve(idx_count, vtx_count);
 1041|      0|        for (int i = 0; i < vtx_count; i++)
  ------------------
  |  Branch (1041:25): [True: 0, False: 0]
  ------------------
 1042|      0|        {
 1043|      0|            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
 1044|      0|            _VtxWritePtr++;
 1045|      0|        }
 1046|      0|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (1046:25): [True: 0, False: 0]
  ------------------
 1047|      0|        {
 1048|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
 1049|      0|            _IdxWritePtr += 3;
 1050|      0|        }
 1051|      0|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1052|      0|    }
 1053|   126k|}
_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii:
 1056|   172k|{
 1057|   172k|    if (radius < 0.5f)
  ------------------
  |  Branch (1057:9): [True: 0, False: 172k]
  ------------------
 1058|      0|    {
 1059|      0|        _Path.push_back(center);
 1060|      0|        return;
 1061|      0|    }
 1062|       |
 1063|       |    // Calculate arc auto segment step size
 1064|   172k|    if (a_step <= 0)
  ------------------
  |  Branch (1064:9): [True: 172k, False: 0]
  ------------------
 1065|   172k|        a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);
  ------------------
  |  |  776|   172k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|   172k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1066|       |
 1067|       |    // Make sure we never do steps larger than one quarter of the circle
 1068|   172k|    a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);
  ------------------
  |  |  774|   172k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  ------------------
 1069|       |
 1070|   172k|    const int sample_range = ImAbs(a_max_sample - a_min_sample);
 1071|   172k|    const int a_next_step = a_step;
 1072|       |
 1073|   172k|    int samples = sample_range + 1;
 1074|   172k|    bool extra_max_sample = false;
 1075|   172k|    if (a_step > 1)
  ------------------
  |  Branch (1075:9): [True: 172k, False: 0]
  ------------------
 1076|   172k|    {
 1077|   172k|        samples            = sample_range / a_step + 1;
 1078|   172k|        const int overstep = sample_range % a_step;
 1079|       |
 1080|   172k|        if (overstep > 0)
  ------------------
  |  Branch (1080:13): [True: 564, False: 171k]
  ------------------
 1081|    564|        {
 1082|    564|            extra_max_sample = true;
 1083|    564|            samples++;
 1084|       |
 1085|       |            // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
 1086|       |            // distribute first step range evenly between them by reducing first step size.
 1087|    564|            if (sample_range > 0)
  ------------------
  |  Branch (1087:17): [True: 564, False: 0]
  ------------------
 1088|    564|                a_step -= (a_step - overstep) / 2;
 1089|    564|        }
 1090|   172k|    }
 1091|       |
 1092|   172k|    _Path.resize(_Path.Size + samples);
 1093|   172k|    ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);
 1094|       |
 1095|   172k|    int sample_index = a_min_sample;
 1096|   172k|    if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  776|   172k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|   172k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1096:9): [True: 0, False: 172k]
  |  Branch (1096:29): [True: 0, False: 172k]
  ------------------
 1097|      0|    {
 1098|      0|        sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1099|      0|        if (sample_index < 0)
  ------------------
  |  Branch (1099:13): [True: 0, False: 0]
  ------------------
 1100|      0|            sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1101|      0|    }
 1102|       |
 1103|   172k|    if (a_max_sample >= a_min_sample)
  ------------------
  |  Branch (1103:9): [True: 172k, False: 0]
  ------------------
 1104|   172k|    {
 1105|   548k|        for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
  ------------------
  |  Branch (1105:36): [True: 375k, False: 172k]
  ------------------
 1106|   375k|        {
 1107|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1108|   375k|            if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  776|   375k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|   375k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1108:17): [True: 43.0k, False: 332k]
  ------------------
 1109|  43.0k|                sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|  43.0k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|  43.0k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1110|       |
 1111|   375k|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1112|   375k|            out_ptr->x = center.x + s.x * radius;
 1113|   375k|            out_ptr->y = center.y + s.y * radius;
 1114|   375k|            out_ptr++;
 1115|   375k|        }
 1116|   172k|    }
 1117|      0|    else
 1118|      0|    {
 1119|      0|        for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
  ------------------
  |  Branch (1119:36): [True: 0, False: 0]
  ------------------
 1120|      0|        {
 1121|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1122|      0|            if (sample_index < 0)
  ------------------
  |  Branch (1122:17): [True: 0, False: 0]
  ------------------
 1123|      0|                sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1124|       |
 1125|      0|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1126|      0|            out_ptr->x = center.x + s.x * radius;
 1127|      0|            out_ptr->y = center.y + s.y * radius;
 1128|      0|            out_ptr++;
 1129|      0|        }
 1130|      0|    }
 1131|       |
 1132|   172k|    if (extra_max_sample)
  ------------------
  |  Branch (1132:9): [True: 564, False: 171k]
  ------------------
 1133|    564|    {
 1134|    564|        int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|    564|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|    564|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1135|    564|        if (normalized_max_sample < 0)
  ------------------
  |  Branch (1135:13): [True: 0, False: 564]
  ------------------
 1136|      0|            normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1137|       |
 1138|    564|        const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];
 1139|    564|        out_ptr->x = center.x + s.x * radius;
 1140|    564|        out_ptr->y = center.y + s.y * radius;
 1141|    564|        out_ptr++;
 1142|    564|    }
 1143|       |
 1144|   172k|    IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
  ------------------
  |  |  260|   172k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   172k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 1145|   172k|}
_ZN10ImDrawList11_PathArcToNERK6ImVec2fffi:
 1148|  11.2k|{
 1149|  11.2k|    if (radius < 0.5f)
  ------------------
  |  Branch (1149:9): [True: 0, False: 11.2k]
  ------------------
 1150|      0|    {
 1151|      0|        _Path.push_back(center);
 1152|      0|        return;
 1153|      0|    }
 1154|       |
 1155|       |    // Note that we are adding a point at both a_min and a_max.
 1156|       |    // If you are trying to draw a full closed circle you don't want the overlapping points!
 1157|  11.2k|    _Path.reserve(_Path.Size + (num_segments + 1));
 1158|  56.1k|    for (int i = 0; i <= num_segments; i++)
  ------------------
  |  Branch (1158:21): [True: 44.9k, False: 11.2k]
  ------------------
 1159|  44.9k|    {
 1160|  44.9k|        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
 1161|  44.9k|        _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  449|  44.9k|#define ImCos(X)            cosf(X)
  ------------------
                      _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  450|  44.9k|#define ImSin(X)            sinf(X)
  ------------------
 1162|  44.9k|    }
 1163|  11.2k|}
_ZN10ImDrawList13PathArcToFastERK6ImVec2fii:
 1167|   198k|{
 1168|   198k|    if (radius < 0.5f)
  ------------------
  |  Branch (1168:9): [True: 25.9k, False: 172k]
  ------------------
 1169|  25.9k|    {
 1170|  25.9k|        _Path.push_back(center);
 1171|  25.9k|        return;
 1172|  25.9k|    }
 1173|   172k|    _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  776|   172k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|   172k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                  _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  776|   172k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|   172k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1174|   172k|}
_ZN10ImDrawList9PathArcToERK6ImVec2fffi:
 1177|  11.2k|{
 1178|  11.2k|    if (radius < 0.5f)
  ------------------
  |  Branch (1178:9): [True: 0, False: 11.2k]
  ------------------
 1179|      0|    {
 1180|      0|        _Path.push_back(center);
 1181|      0|        return;
 1182|      0|    }
 1183|       |
 1184|  11.2k|    if (num_segments > 0)
  ------------------
  |  Branch (1184:9): [True: 11.2k, False: 0]
  ------------------
 1185|  11.2k|    {
 1186|  11.2k|        _PathArcToN(center, radius, a_min, a_max, num_segments);
 1187|  11.2k|        return;
 1188|  11.2k|    }
 1189|       |
 1190|       |    // Automatic segment count
 1191|      0|    if (radius <= _Data->ArcFastRadiusCutoff)
  ------------------
  |  Branch (1191:9): [True: 0, False: 0]
  ------------------
 1192|      0|    {
 1193|      0|        const bool a_is_reverse = a_max < a_min;
 1194|       |
 1195|       |        // We are going to use precomputed values for mid samples.
 1196|       |        // Determine first and last sample in lookup table that belong to the arc.
 1197|      0|        const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  272|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1198|      0|        const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  272|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1199|       |
 1200|      0|        const int a_min_sample = a_is_reverse ? (int)ImFloor(a_min_sample_f) : (int)ImCeil(a_min_sample_f);
  ------------------
  |  |  454|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1200:34): [True: 0, False: 0]
  ------------------
 1201|      0|        const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloor(a_max_sample_f);
  ------------------
  |  |  454|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1201:34): [True: 0, False: 0]
  ------------------
 1202|      0|        const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);
  ------------------
  |  Branch (1202:35): [True: 0, False: 0]
  ------------------
 1203|       |
 1204|      0|        const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  272|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1205|      0|        const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  272|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  776|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1206|      0|        const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;
 1207|      0|        const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;
 1208|       |
 1209|      0|        _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));
  ------------------
  |  Branch (1209:58): [True: 0, False: 0]
  |  Branch (1209:83): [True: 0, False: 0]
  ------------------
 1210|      0|        if (a_emit_start)
  ------------------
  |  Branch (1210:13): [True: 0, False: 0]
  ------------------
 1211|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  449|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  450|      0|#define ImSin(X)            sinf(X)
  ------------------
 1212|      0|        if (a_mid_samples > 0)
  ------------------
  |  Branch (1212:13): [True: 0, False: 0]
  ------------------
 1213|      0|            _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
 1214|      0|        if (a_emit_end)
  ------------------
  |  Branch (1214:13): [True: 0, False: 0]
  ------------------
 1215|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  449|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  450|      0|#define ImSin(X)            sinf(X)
  ------------------
 1216|      0|    }
 1217|      0|    else
 1218|      0|    {
 1219|      0|        const float arc_length = ImAbs(a_max - a_min);
 1220|      0|        const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
 1221|      0|        const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  454|      0|#define ImCeil(X)           ceilf(X)
  ------------------
                      const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  272|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1222|      0|        _PathArcToN(center, radius, a_min, a_max, arc_segment_count);
 1223|      0|    }
 1224|      0|}
_ZN10ImDrawList8PathRectERK6ImVec2S2_fi:
 1367|   146k|{
 1368|   146k|    if (rounding >= 0.5f)
  ------------------
  |  Branch (1368:9): [True: 54.4k, False: 91.5k]
  ------------------
 1369|  54.4k|    {
 1370|  54.4k|        flags = FixRectCornerFlags(flags);
 1371|  54.4k|        rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);
  ------------------
  |  |  446|  54.4k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1371:57): [True: 54.4k, False: 0]
  |  Branch (1371:131): [True: 0, False: 0]
  ------------------
 1372|  54.4k|        rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);
  ------------------
  |  |  446|  54.4k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1372:57): [True: 54.4k, False: 0]
  |  Branch (1372:133): [True: 0, False: 0]
  ------------------
 1373|  54.4k|    }
 1374|   146k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1374:9): [True: 102k, False: 43.0k]
  |  Branch (1374:28): [True: 0, False: 43.0k]
  ------------------
 1375|   102k|    {
 1376|   102k|        PathLineTo(a);
 1377|   102k|        PathLineTo(ImVec2(b.x, a.y));
 1378|   102k|        PathLineTo(b);
 1379|   102k|        PathLineTo(ImVec2(a.x, b.y));
 1380|   102k|    }
 1381|  43.0k|    else
 1382|  43.0k|    {
 1383|  43.0k|        const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;
  ------------------
  |  Branch (1383:35): [True: 43.0k, False: 0]
  ------------------
 1384|  43.0k|        const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
  ------------------
  |  Branch (1384:35): [True: 43.0k, False: 0]
  ------------------
 1385|  43.0k|        const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
  ------------------
  |  Branch (1385:35): [True: 43.0k, False: 0]
  ------------------
 1386|  43.0k|        const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
  ------------------
  |  Branch (1386:35): [True: 43.0k, False: 0]
  ------------------
 1387|  43.0k|        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
 1388|  43.0k|        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
 1389|  43.0k|        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
 1390|  43.0k|        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
 1391|  43.0k|    }
 1392|   146k|}
_ZN10ImDrawList7AddLineERK6ImVec2S2_jf:
 1395|  29.7k|{
 1396|  29.7k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|  29.7k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1396:9): [True: 0, False: 29.7k]
  ------------------
 1397|      0|        return;
 1398|  29.7k|    PathLineTo(p1 + ImVec2(0.5f, 0.5f));
 1399|  29.7k|    PathLineTo(p2 + ImVec2(0.5f, 0.5f));
 1400|  29.7k|    PathStroke(col, 0, thickness);
 1401|  29.7k|}
_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif:
 1406|   118k|{
 1407|   118k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|   118k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1407:9): [True: 3.41k, False: 115k]
  ------------------
 1408|  3.41k|        return;
 1409|   115k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (1409:9): [True: 115k, False: 0]
  ------------------
 1410|   115k|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
 1411|      0|    else
 1412|      0|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
 1413|   115k|    PathStroke(col, ImDrawFlags_Closed, thickness);
 1414|   115k|}
_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi:
 1417|   260k|{
 1418|   260k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|   260k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1418:9): [True: 0, False: 260k]
  ------------------
 1419|      0|        return;
 1420|   260k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1420:9): [True: 230k, False: 30.5k]
  |  Branch (1420:28): [True: 0, False: 30.5k]
  ------------------
 1421|   230k|    {
 1422|   230k|        PrimReserve(6, 4);
 1423|   230k|        PrimRect(p_min, p_max, col);
 1424|   230k|    }
 1425|  30.5k|    else
 1426|  30.5k|    {
 1427|  30.5k|        PathRect(p_min, p_max, rounding, flags);
 1428|  30.5k|        PathFillConvex(col);
 1429|  30.5k|    }
 1430|   260k|}
_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j:
 1484|  58.7k|{
 1485|  58.7k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|  58.7k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1485:9): [True: 0, False: 58.7k]
  ------------------
 1486|      0|        return;
 1487|       |
 1488|  58.7k|    PathLineTo(p1);
 1489|  58.7k|    PathLineTo(p2);
 1490|  58.7k|    PathLineTo(p3);
 1491|  58.7k|    PathFillConvex(col);
 1492|  58.7k|}
_ZN10ImDrawList15AddCircleFilledERK6ImVec2fji:
 1519|  11.4k|{
 1520|  11.4k|    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
  ------------------
  |  | 2583|  11.4k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1520:9): [True: 0, False: 11.4k]
  |  Branch (1520:41): [True: 0, False: 11.4k]
  ------------------
 1521|      0|        return;
 1522|       |
 1523|  11.4k|    if (num_segments <= 0)
  ------------------
  |  Branch (1523:9): [True: 163, False: 11.2k]
  ------------------
 1524|    163|    {
 1525|       |        // Use arc with automatic segment count
 1526|    163|        _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
  ------------------
  |  |  776|    163|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  774|    163|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1527|    163|        _Path.Size--;
 1528|    163|    }
 1529|  11.2k|    else
 1530|  11.2k|    {
 1531|       |        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
 1532|  11.2k|        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
  ------------------
  |  |  765|  11.2k|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  ------------------
 1533|       |
 1534|       |        // Because we are filling a closed shape we remove 1 from the count of segments/points
 1535|  11.2k|        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
  ------------------
  |  |  272|  11.2k|#define IM_PI                           3.14159265358979323846f
  ------------------
 1536|  11.2k|        PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
 1537|  11.2k|    }
 1538|       |
 1539|  11.4k|    PathFillConvex(col);
 1540|  11.4k|}
_ZN10ImDrawList7AddTextEPK6ImFontfRK6ImVec2jPKcS7_fPK6ImVec4:
 1618|   362k|{
 1619|   362k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2583|   362k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1619:9): [True: 0, False: 362k]
  ------------------
 1620|      0|        return;
 1621|       |
 1622|   362k|    if (text_end == NULL)
  ------------------
  |  Branch (1622:9): [True: 303k, False: 58.7k]
  ------------------
 1623|   303k|        text_end = text_begin + strlen(text_begin);
 1624|   362k|    if (text_begin == text_end)
  ------------------
  |  Branch (1624:9): [True: 0, False: 362k]
  ------------------
 1625|      0|        return;
 1626|       |
 1627|       |    // Pull default font/size from the shared ImDrawListSharedData instance
 1628|   362k|    if (font == NULL)
  ------------------
  |  Branch (1628:9): [True: 362k, False: 24]
  ------------------
 1629|   362k|        font = _Data->Font;
 1630|   362k|    if (font_size == 0.0f)
  ------------------
  |  Branch (1630:9): [True: 362k, False: 24]
  ------------------
 1631|   362k|        font_size = _Data->FontSize;
 1632|       |
 1633|   362k|    IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
  ------------------
  |  |   23|   362k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1634|       |
 1635|   362k|    ImVec4 clip_rect = _CmdHeader.ClipRect;
 1636|   362k|    if (cpu_fine_clip_rect)
  ------------------
  |  Branch (1636:9): [True: 1, False: 362k]
  ------------------
 1637|      1|    {
 1638|      1|        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
 1639|      1|        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
 1640|      1|        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
 1641|      1|        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
 1642|      1|    }
 1643|   362k|    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
 1644|   362k|}
_ZN10ImDrawList7AddTextERK6ImVec2jPKcS4_:
 1647|   303k|{
 1648|   303k|    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
 1649|   303k|}
_ZN18ImDrawListSplitter15ClearFreeMemoryEv:
 1717|      2|{
 1718|      2|    for (int i = 0; i < _Channels.Size; i++)
  ------------------
  |  Branch (1718:21): [True: 0, False: 2]
  ------------------
 1719|      0|    {
 1720|      0|        if (i == _Current)
  ------------------
  |  Branch (1720:13): [True: 0, False: 0]
  ------------------
 1721|      0|            memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
 1722|      0|        _Channels[i]._CmdBuffer.clear();
 1723|      0|        _Channels[i]._IdxBuffer.clear();
 1724|      0|    }
 1725|      2|    _Current = 0;
 1726|      2|    _Count = 1;
 1727|      2|    _Channels.clear();
 1728|      2|}
_ZN10ImDrawData5ClearEv:
 1860|      1|{
 1861|      1|    Valid = false;
 1862|      1|    CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
 1863|      1|    CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
 1864|      1|    DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);
 1865|      1|    OwnerViewport = NULL;
 1866|      1|}
_ZN5ImGui23AddDrawListToDrawDataExEP10ImDrawDataP8ImVectorIP10ImDrawListES4_:
 1871|  42.0k|{
 1872|  42.0k|    if (draw_list->CmdBuffer.Size == 0)
  ------------------
  |  Branch (1872:9): [True: 0, False: 42.0k]
  ------------------
 1873|      0|        return;
 1874|  42.0k|    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
  ------------------
  |  Branch (1874:9): [True: 3.47k, False: 38.6k]
  |  Branch (1874:43): [True: 60, False: 3.41k]
  |  Branch (1874:85): [True: 60, False: 0]
  ------------------
 1875|     60|        return;
 1876|       |
 1877|       |    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
 1878|       |    // May trigger for you if you are using PrimXXX functions incorrectly.
 1879|  42.0k|    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  42.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1880|  42.0k|    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
  ------------------
  |  |   23|  42.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1881|  42.0k|    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (1881:9): [True: 42.0k, False: 0]
  ------------------
 1882|  42.0k|        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  42.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1883|       |
 1884|       |    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
 1885|       |    // If this assert triggers because you are drawing lots of stuff manually:
 1886|       |    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
 1887|       |    //   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
 1888|       |    // - If you want large meshes with more than 64K vertices, you can either:
 1889|       |    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
 1890|       |    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
 1891|       |    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
 1892|       |    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
 1893|       |    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
 1894|       |    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
 1895|       |    //       Your own engine or render API may use different parameters or function calls to specify index sizes.
 1896|       |    //       2 and 4 bytes indices are generally supported by most graphics API.
 1897|       |    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
 1898|       |    //   the 64K limit to split your draw commands in multiple draw lists.
 1899|  42.0k|    if (sizeof(ImDrawIdx) == 2)
  ------------------
  |  Branch (1899:9): [Folded - Ignored]
  ------------------
 1900|  42.0k|        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
  ------------------
  |  |   23|  42.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1901|       |
 1902|       |    // Add to output list + records state in ImDrawData
 1903|  42.0k|    out_list->push_back(draw_list);
 1904|  42.0k|    draw_data->CmdListsCount++;
 1905|  42.0k|    draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
 1906|  42.0k|    draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
 1907|  42.0k|}
_ZN12ImFontConfigC2Ev:
 2003|      1|{
 2004|      1|    memset(this, 0, sizeof(*this));
 2005|      1|    FontDataOwnedByAtlas = true;
 2006|      1|    OversampleH = 2;
 2007|      1|    OversampleV = 1;
 2008|      1|    GlyphMaxAdvanceX = FLT_MAX;
 2009|      1|    RasterizerMultiply = 1.0f;
 2010|      1|    EllipsisChar = (ImWchar)-1;
 2011|      1|}
_ZN11ImFontAtlasC2Ev:
 2068|      1|{
 2069|      1|    memset(this, 0, sizeof(*this));
 2070|      1|    TexGlyphPadding = 1;
 2071|      1|    PackIdMouseCursors = PackIdLines = -1;
 2072|      1|}
_ZN11ImFontAtlas12ClearTexDataEv:
 2104|      2|{
 2105|      2|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2106|      2|    if (TexPixelsAlpha8)
  ------------------
  |  Branch (2106:9): [True: 0, False: 2]
  ------------------
 2107|      0|        IM_FREE(TexPixelsAlpha8);
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2108|      2|    if (TexPixelsRGBA32)
  ------------------
  |  Branch (2108:9): [True: 0, False: 2]
  ------------------
 2109|      0|        IM_FREE(TexPixelsRGBA32);
  ------------------
  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2110|      2|    TexPixelsAlpha8 = NULL;
 2111|      2|    TexPixelsRGBA32 = NULL;
 2112|      2|    TexPixelsUseColors = false;
 2113|       |    // Important: we leave TexReady untouched
 2114|      2|}
_ZN11ImFontAtlas18GetTexDataAsAlpha8EPPhPiS2_S2_:
 2131|      1|{
 2132|       |    // Build atlas on demand
 2133|      1|    if (TexPixelsAlpha8 == NULL)
  ------------------
  |  Branch (2133:9): [True: 1, False: 0]
  ------------------
 2134|      1|        Build();
 2135|       |
 2136|      1|    *out_pixels = TexPixelsAlpha8;
 2137|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2137:9): [True: 0, False: 1]
  ------------------
 2138|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2138:9): [True: 0, False: 1]
  ------------------
 2139|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
  ------------------
  |  Branch (2139:9): [True: 0, False: 1]
  ------------------
 2140|      1|}
_ZN11ImFontAtlas18GetTexDataAsRGBA32EPPhPiS2_S2_:
 2143|      1|{
 2144|       |    // Convert to RGBA32 format on demand
 2145|       |    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
 2146|      1|    if (!TexPixelsRGBA32)
  ------------------
  |  Branch (2146:9): [True: 1, False: 0]
  ------------------
 2147|      1|    {
 2148|      1|        unsigned char* pixels = NULL;
 2149|      1|        GetTexDataAsAlpha8(&pixels, NULL, NULL);
 2150|      1|        if (pixels)
  ------------------
  |  Branch (2150:13): [True: 1, False: 0]
  ------------------
 2151|      1|        {
 2152|      1|            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2153|      1|            const unsigned char* src = pixels;
 2154|      1|            unsigned int* dst = TexPixelsRGBA32;
 2155|  32.7k|            for (int n = TexWidth * TexHeight; n > 0; n--)
  ------------------
  |  Branch (2155:48): [True: 32.7k, False: 1]
  ------------------
 2156|  32.7k|                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
  ------------------
  |  | 2586|  32.7k|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2582|  32.7k|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2581|  32.7k|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2580|  32.7k|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2579|  32.7k|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2157|      1|        }
 2158|      1|    }
 2159|       |
 2160|      1|    *out_pixels = (unsigned char*)TexPixelsRGBA32;
 2161|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2161:9): [True: 1, False: 0]
  ------------------
 2162|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2162:9): [True: 1, False: 0]
  ------------------
 2163|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
  ------------------
  |  Branch (2163:9): [True: 0, False: 1]
  ------------------
 2164|      1|}
_ZN11ImFontAtlas7AddFontEPK12ImFontConfig:
 2167|      1|{
 2168|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2169|      1|    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2170|      1|    IM_ASSERT(font_cfg->SizePixels > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2171|       |
 2172|       |    // Create new font
 2173|      1|    if (!font_cfg->MergeMode)
  ------------------
  |  Branch (2173:9): [True: 1, False: 0]
  ------------------
 2174|      1|        Fonts.push_back(IM_NEW(ImFont));
  ------------------
  |  | 1883|      1|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 2175|      0|    else
 2176|      1|        IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2177|       |
 2178|      1|    ConfigData.push_back(*font_cfg);
 2179|      1|    ImFontConfig& new_font_cfg = ConfigData.back();
 2180|      1|    if (new_font_cfg.DstFont == NULL)
  ------------------
  |  Branch (2180:9): [True: 1, False: 0]
  ------------------
 2181|      1|        new_font_cfg.DstFont = Fonts.back();
 2182|      1|    if (!new_font_cfg.FontDataOwnedByAtlas)
  ------------------
  |  Branch (2182:9): [True: 0, False: 1]
  ------------------
 2183|      0|    {
 2184|      0|        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
  ------------------
  |  | 1880|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2185|      0|        new_font_cfg.FontDataOwnedByAtlas = true;
 2186|      0|        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
 2187|      0|    }
 2188|       |
 2189|      1|    if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (2189:9): [True: 1, False: 0]
  ------------------
 2190|      1|        new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;
 2191|       |
 2192|      1|    ImFontAtlasUpdateConfigDataPointers(this);
 2193|       |
 2194|       |    // Invalidate texture
 2195|      1|    TexReady = false;
 2196|      1|    ClearTexData();
 2197|      1|    return new_font_cfg.DstFont;
 2198|      1|}
_ZN11ImFontAtlas14AddFontDefaultEPK12ImFontConfig:
 2218|      1|{
 2219|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2219:29): [True: 0, False: 1]
  ------------------
 2220|      1|    if (!font_cfg_template)
  ------------------
  |  Branch (2220:9): [True: 1, False: 0]
  ------------------
 2221|      1|    {
 2222|      1|        font_cfg.OversampleH = font_cfg.OversampleV = 1;
 2223|      1|        font_cfg.PixelSnapH = true;
 2224|      1|    }
 2225|      1|    if (font_cfg.SizePixels <= 0.0f)
  ------------------
  |  Branch (2225:9): [True: 1, False: 0]
  ------------------
 2226|      1|        font_cfg.SizePixels = 13.0f * 1.0f;
 2227|      1|    if (font_cfg.Name[0] == '\0')
  ------------------
  |  Branch (2227:9): [True: 1, False: 0]
  ------------------
 2228|      1|        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
  ------------------
  |  |   88|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 2229|      1|    font_cfg.EllipsisChar = (ImWchar)0x0085;
 2230|      1|    font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units
  ------------------
  |  |  284|      1|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 2231|       |
 2232|      1|    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
 2233|      1|    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
  ------------------
  |  Branch (2233:35): [True: 0, False: 1]
  ------------------
 2234|      1|    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
 2235|      1|    return font;
 2236|      1|}
_ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt:
 2261|      1|{
 2262|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2263|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2263:29): [True: 1, False: 0]
  ------------------
 2264|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2265|      1|    IM_ASSERT(font_data_size > 100 && "Incorrect value for font_data_size!"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2266|      1|    font_cfg.FontData = font_data;
 2267|      1|    font_cfg.FontDataSize = font_data_size;
 2268|      1|    font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
  ------------------
  |  Branch (2268:27): [True: 1, False: 0]
  ------------------
 2269|      1|    if (glyph_ranges)
  ------------------
  |  Branch (2269:9): [True: 1, False: 0]
  ------------------
 2270|      1|        font_cfg.GlyphRanges = glyph_ranges;
 2271|      1|    return AddFont(&font_cfg);
 2272|      1|}
_ZN11ImFontAtlas30AddFontFromMemoryCompressedTTFEPKvifPK12ImFontConfigPKt:
 2275|      1|{
 2276|      1|    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
 2277|      1|    unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2278|      1|    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
 2279|       |
 2280|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2280:29): [True: 1, False: 0]
  ------------------
 2281|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2282|      1|    font_cfg.FontDataOwnedByAtlas = true;
 2283|      1|    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
 2284|      1|}
_ZN11ImFontAtlas36AddFontFromMemoryCompressedBase85TTFEPKcfPK12ImFontConfigPKt:
 2287|      1|{
 2288|      1|    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
 2289|      1|    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2290|      1|    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
 2291|      1|    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
 2292|      1|    IM_FREE(compressed_ttf);
  ------------------
  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2293|      1|    return font;
 2294|      1|}
_ZN11ImFontAtlas20AddCustomRectRegularEii:
 2297|      2|{
 2298|      2|    IM_ASSERT(width > 0 && width <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2299|      2|    IM_ASSERT(height > 0 && height <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2300|      2|    ImFontAtlasCustomRect r;
 2301|      2|    r.Width = (unsigned short)width;
 2302|      2|    r.Height = (unsigned short)height;
 2303|      2|    CustomRects.push_back(r);
 2304|      2|    return CustomRects.Size - 1; // Return index
 2305|      2|}
_ZN11ImFontAtlas5BuildEv:
 2356|      1|{
 2357|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2358|       |
 2359|       |    // Default font is none are specified
 2360|      1|    if (ConfigData.Size == 0)
  ------------------
  |  Branch (2360:9): [True: 1, False: 0]
  ------------------
 2361|      1|        AddFontDefault();
 2362|       |
 2363|       |    // Select builder
 2364|       |    // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
 2365|       |    //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
 2366|       |    //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
 2367|       |    //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
 2368|      1|    const ImFontBuilderIO* builder_io = FontBuilderIO;
 2369|      1|    if (builder_io == NULL)
  ------------------
  |  Branch (2369:9): [True: 1, False: 0]
  ------------------
 2370|      1|    {
 2371|       |#ifdef IMGUI_ENABLE_FREETYPE
 2372|       |        builder_io = ImGuiFreeType::GetBuilderForFreeType();
 2373|       |#elif defined(IMGUI_ENABLE_STB_TRUETYPE)
 2374|      1|        builder_io = ImFontAtlasGetBuilderForStbTruetype();
 2375|       |#else
 2376|       |        IM_ASSERT(0); // Invalid Build function
 2377|       |#endif
 2378|      1|    }
 2379|       |
 2380|       |    // Build
 2381|      1|    return builder_io->FontBuilder_Build(this);
 2382|      1|}
_Z35ImFontAtlasGetBuilderForStbTruetypev:
 2698|      1|{
 2699|      1|    static ImFontBuilderIO io;
 2700|      1|    io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
 2701|      1|    return &io;
 2702|      1|}
_Z35ImFontAtlasUpdateConfigDataPointersP11ImFontAtlas:
 2707|      1|{
 2708|      1|    for (ImFontConfig& font_cfg : atlas->ConfigData)
  ------------------
  |  Branch (2708:33): [True: 1, False: 1]
  ------------------
 2709|      1|    {
 2710|      1|        ImFont* font = font_cfg.DstFont;
 2711|      1|        if (!font_cfg.MergeMode)
  ------------------
  |  Branch (2711:13): [True: 1, False: 0]
  ------------------
 2712|      1|        {
 2713|      1|            font->ConfigData = &font_cfg;
 2714|      1|            font->ConfigDataCount = 0;
 2715|      1|        }
 2716|      1|        font->ConfigDataCount++;
 2717|      1|    }
 2718|      1|}
_Z25ImFontAtlasBuildSetupFontP11ImFontAtlasP6ImFontP12ImFontConfigff:
 2721|      1|{
 2722|      1|    if (!font_config->MergeMode)
  ------------------
  |  Branch (2722:9): [True: 1, False: 0]
  ------------------
 2723|      1|    {
 2724|      1|        font->ClearOutputData();
 2725|      1|        font->FontSize = font_config->SizePixels;
 2726|      1|        IM_ASSERT(font->ConfigData == font_config);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2727|      1|        font->ContainerAtlas = atlas;
 2728|      1|        font->Ascent = ascent;
 2729|      1|        font->Descent = descent;
 2730|      1|    }
 2731|      1|}
_Z31ImFontAtlasBuildPackCustomRectsP11ImFontAtlasPv:
 2734|      1|{
 2735|      1|    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
 2736|      1|    IM_ASSERT(pack_context != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2737|       |
 2738|      1|    ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
 2739|      1|    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2740|      1|#ifdef __GNUC__
 2741|      1|    if (user_rects.Size < 1) { __builtin_unreachable(); } // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)
  ------------------
  |  Branch (2741:9): [True: 0, False: 1]
  ------------------
 2742|      1|#endif
 2743|       |
 2744|      1|    ImVector<stbrp_rect> pack_rects;
 2745|      1|    pack_rects.resize(user_rects.Size);
 2746|      1|    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
 2747|      3|    for (int i = 0; i < user_rects.Size; i++)
  ------------------
  |  Branch (2747:21): [True: 2, False: 1]
  ------------------
 2748|      2|    {
 2749|      2|        pack_rects[i].w = user_rects[i].Width;
 2750|      2|        pack_rects[i].h = user_rects[i].Height;
 2751|      2|    }
 2752|      1|    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
 2753|      3|    for (int i = 0; i < pack_rects.Size; i++)
  ------------------
  |  Branch (2753:21): [True: 2, False: 1]
  ------------------
 2754|      2|        if (pack_rects[i].was_packed)
  ------------------
  |  Branch (2754:13): [True: 2, False: 0]
  ------------------
 2755|      2|        {
 2756|      2|            user_rects[i].X = (unsigned short)pack_rects[i].x;
 2757|      2|            user_rects[i].Y = (unsigned short)pack_rects[i].y;
 2758|      2|            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2759|      2|            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
 2760|      2|        }
 2761|      1|}
_Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch:
 2764|      2|{
 2765|      2|    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2766|      2|    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2767|      2|    unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
 2768|     56|    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
  ------------------
  |  Branch (2768:25): [True: 54, False: 2]
  ------------------
 2769|  6.64k|        for (int off_x = 0; off_x < w; off_x++)
  ------------------
  |  Branch (2769:29): [True: 6.58k, False: 54]
  ------------------
 2770|  6.58k|            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
  ------------------
  |  Branch (2770:32): [True: 1.12k, False: 5.46k]
  ------------------
 2771|      2|}
_Z20ImFontAtlasBuildInitP11ImFontAtlas:
 2876|      1|{
 2877|       |    // Round font size
 2878|       |    // - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
 2879|       |    // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
 2880|       |    // - We may support it better later and remove this rounding.
 2881|      1|    for (ImFontConfig& cfg : atlas->ConfigData)
  ------------------
  |  Branch (2881:28): [True: 1, False: 1]
  ------------------
 2882|      1|       cfg.SizePixels = ImTrunc(cfg.SizePixels);
 2883|       |
 2884|       |    // Register texture region for mouse cursors or standard white pixels
 2885|      1|    if (atlas->PackIdMouseCursors < 0)
  ------------------
  |  Branch (2885:9): [True: 1, False: 0]
  ------------------
 2886|      1|    {
 2887|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (2887:13): [True: 1, False: 0]
  ------------------
 2888|      1|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
 2889|      0|        else
 2890|      0|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
 2891|      1|    }
 2892|       |
 2893|       |    // Register texture region for thick lines
 2894|       |    // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
 2895|      1|    if (atlas->PackIdLines < 0)
  ------------------
  |  Branch (2895:9): [True: 1, False: 0]
  ------------------
 2896|      1|    {
 2897|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (2897:13): [True: 1, False: 0]
  ------------------
 2898|      1|            atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2619|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
                          atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2619|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
 2899|      1|    }
 2900|      1|}
_Z22ImFontAtlasBuildFinishP11ImFontAtlas:
 2904|      1|{
 2905|       |    // Render into our custom data blocks
 2906|      1|    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2907|      1|    ImFontAtlasBuildRenderDefaultTexData(atlas);
 2908|      1|    ImFontAtlasBuildRenderLinesTexData(atlas);
 2909|       |
 2910|       |    // Register custom rectangle glyphs
 2911|      3|    for (int i = 0; i < atlas->CustomRects.Size; i++)
  ------------------
  |  Branch (2911:21): [True: 2, False: 1]
  ------------------
 2912|      2|    {
 2913|      2|        const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
 2914|      2|        if (r->Font == NULL || r->GlyphID == 0)
  ------------------
  |  Branch (2914:13): [True: 2, False: 0]
  |  Branch (2914:32): [True: 0, False: 0]
  ------------------
 2915|      2|            continue;
 2916|       |
 2917|       |        // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
 2918|      0|        IM_ASSERT(r->Font->ContainerAtlas == atlas);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2919|      0|        ImVec2 uv0, uv1;
 2920|      0|        atlas->CalcCustomRectUV(r, &uv0, &uv1);
 2921|      0|        r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
 2922|      0|    }
 2923|       |
 2924|       |    // Build all fonts lookup tables
 2925|      1|    for (ImFont* font : atlas->Fonts)
  ------------------
  |  Branch (2925:23): [True: 1, False: 1]
  ------------------
 2926|      1|        if (font->DirtyLookupTables)
  ------------------
  |  Branch (2926:13): [True: 1, False: 0]
  ------------------
 2927|      1|            font->BuildLookupTable();
 2928|       |
 2929|      1|    atlas->TexReady = true;
 2930|      1|}
_ZN11ImFontAtlas21GetGlyphRangesDefaultEv:
 2934|      1|{
 2935|      1|    static const ImWchar ranges[] =
 2936|      1|    {
 2937|      1|        0x0020, 0x00FF, // Basic Latin + Latin Supplement
 2938|      1|        0,
 2939|      1|    };
 2940|      1|    return &ranges[0];
 2941|      1|}
_ZN6ImFontC2Ev:
 3240|      2|{
 3241|      2|    FontSize = 0.0f;
 3242|      2|    FallbackAdvanceX = 0.0f;
 3243|      2|    FallbackChar = (ImWchar)-1;
 3244|      2|    EllipsisChar = (ImWchar)-1;
 3245|      2|    EllipsisWidth = EllipsisCharStep = 0.0f;
 3246|      2|    EllipsisCharCount = 0;
 3247|      2|    FallbackGlyph = NULL;
 3248|      2|    ContainerAtlas = NULL;
 3249|      2|    ConfigData = NULL;
 3250|      2|    ConfigDataCount = 0;
 3251|      2|    DirtyLookupTables = false;
 3252|      2|    Scale = 1.0f;
 3253|      2|    Ascent = Descent = 0.0f;
 3254|      2|    MetricsTotalSurface = 0;
 3255|      2|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3256|      2|}
_ZN6ImFont15ClearOutputDataEv:
 3264|      1|{
 3265|      1|    FontSize = 0.0f;
 3266|      1|    FallbackAdvanceX = 0.0f;
 3267|      1|    Glyphs.clear();
 3268|      1|    IndexAdvanceX.clear();
 3269|      1|    IndexLookup.clear();
 3270|      1|    FallbackGlyph = NULL;
 3271|      1|    ContainerAtlas = NULL;
 3272|      1|    DirtyLookupTables = true;
 3273|      1|    Ascent = Descent = 0.0f;
 3274|      1|    MetricsTotalSurface = 0;
 3275|      1|}
_ZN6ImFont16BuildLookupTableEv:
 3286|      1|{
 3287|      1|    int max_codepoint = 0;
 3288|    224|    for (int i = 0; i != Glyphs.Size; i++)
  ------------------
  |  Branch (3288:21): [True: 223, False: 1]
  ------------------
 3289|    223|        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);
 3290|       |
 3291|       |    // Build lookup table
 3292|      1|    IM_ASSERT(Glyphs.Size > 0 && "Font has not loaded glyph!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3293|      1|    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3294|      1|    IndexAdvanceX.clear();
 3295|      1|    IndexLookup.clear();
 3296|      1|    DirtyLookupTables = false;
 3297|      1|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3298|      1|    GrowIndex(max_codepoint + 1);
 3299|    224|    for (int i = 0; i < Glyphs.Size; i++)
  ------------------
  |  Branch (3299:21): [True: 223, False: 1]
  ------------------
 3300|    223|    {
 3301|    223|        int codepoint = (int)Glyphs[i].Codepoint;
 3302|    223|        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
 3303|    223|        IndexLookup[codepoint] = (ImWchar)i;
 3304|       |
 3305|       |        // Mark 4K page as used
 3306|    223|        const int page_n = codepoint / 4096;
 3307|    223|        Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
 3308|    223|    }
 3309|       |
 3310|       |    // Create a glyph to handle TAB
 3311|       |    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
 3312|      1|    if (FindGlyph((ImWchar)' '))
  ------------------
  |  Branch (3312:9): [True: 1, False: 0]
  ------------------
 3313|      1|    {
 3314|      1|        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
  ------------------
  |  Branch (3314:13): [True: 1, False: 0]
  ------------------
 3315|      1|            Glyphs.resize(Glyphs.Size + 1);
 3316|      1|        ImFontGlyph& tab_glyph = Glyphs.back();
 3317|      1|        tab_glyph = *FindGlyph((ImWchar)' ');
 3318|      1|        tab_glyph.Codepoint = '\t';
 3319|      1|        tab_glyph.AdvanceX *= IM_TABSIZE;
  ------------------
  |  |  279|      1|#define IM_TABSIZE                      (4)
  ------------------
 3320|      1|        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
 3321|      1|        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
 3322|      1|    }
 3323|       |
 3324|       |    // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
 3325|      1|    SetGlyphVisible((ImWchar)' ', false);
 3326|      1|    SetGlyphVisible((ImWchar)'\t', false);
 3327|       |
 3328|       |    // Setup Fallback character
 3329|      1|    const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
  ------------------
  |  | 2379|      1|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 3330|      1|    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3331|      1|    if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3331:9): [True: 1, False: 0]
  ------------------
 3332|      1|    {
 3333|      1|        FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
  ------------------
  |  |   88|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3334|      1|        FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3335|      1|        if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3335:13): [True: 0, False: 1]
  ------------------
 3336|      0|        {
 3337|      0|            FallbackGlyph = &Glyphs.back();
 3338|      0|            FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
 3339|      0|        }
 3340|      1|    }
 3341|      1|    FallbackAdvanceX = FallbackGlyph->AdvanceX;
 3342|    257|    for (int i = 0; i < max_codepoint + 1; i++)
  ------------------
  |  Branch (3342:21): [True: 256, False: 1]
  ------------------
 3343|    256|        if (IndexAdvanceX[i] < 0.0f)
  ------------------
  |  Branch (3343:13): [True: 32, False: 224]
  ------------------
 3344|     32|            IndexAdvanceX[i] = FallbackAdvanceX;
 3345|       |
 3346|       |    // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
 3347|       |    // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
 3348|       |    // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
 3349|      1|    const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
 3350|      1|    const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
 3351|      1|    if (EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (3351:9): [True: 0, False: 1]
  ------------------
 3352|      0|        EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
  ------------------
  |  |   88|      0|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3353|      1|    const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
  ------------------
  |  |   88|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3354|      1|    if (EllipsisChar != (ImWchar)-1)
  ------------------
  |  Branch (3354:9): [True: 1, False: 0]
  ------------------
 3355|      1|    {
 3356|      1|        EllipsisCharCount = 1;
 3357|      1|        EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
 3358|      1|    }
 3359|      0|    else if (dot_char != (ImWchar)-1)
  ------------------
  |  Branch (3359:14): [True: 0, False: 0]
  ------------------
 3360|      0|    {
 3361|      0|        const ImFontGlyph* glyph = FindGlyph(dot_char);
 3362|      0|        EllipsisChar = dot_char;
 3363|      0|        EllipsisCharCount = 3;
 3364|      0|        EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
 3365|      0|        EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
 3366|      0|    }
 3367|      1|}
_ZN6ImFont15SetGlyphVisibleEtb:
 3383|      2|{
 3384|      2|    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))
  ------------------
  |  Branch (3384:22): [True: 2, False: 0]
  ------------------
 3385|      2|        glyph->Visible = visible ? 1 : 0;
  ------------------
  |  Branch (3385:26): [True: 0, False: 2]
  ------------------
 3386|      2|}
_ZN6ImFont9GrowIndexEi:
 3389|      1|{
 3390|      1|    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3391|      1|    if (new_size <= IndexLookup.Size)
  ------------------
  |  Branch (3391:9): [True: 0, False: 1]
  ------------------
 3392|      0|        return;
 3393|      1|    IndexAdvanceX.resize(new_size, -1.0f);
 3394|      1|    IndexLookup.resize(new_size, (ImWchar)-1);
 3395|      1|}
_ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff:
 3401|    223|{
 3402|    223|    if (cfg != NULL)
  ------------------
  |  Branch (3402:9): [True: 223, False: 0]
  ------------------
 3403|    223|    {
 3404|       |        // Clamp & recenter if needed
 3405|    223|        const float advance_x_original = advance_x;
 3406|    223|        advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
 3407|    223|        if (advance_x != advance_x_original)
  ------------------
  |  Branch (3407:13): [True: 0, False: 223]
  ------------------
 3408|      0|        {
 3409|      0|            float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
  ------------------
  |  Branch (3409:32): [True: 0, False: 0]
  ------------------
 3410|      0|            x0 += char_off_x;
 3411|      0|            x1 += char_off_x;
 3412|      0|        }
 3413|       |
 3414|       |        // Snap to pixel
 3415|    223|        if (cfg->PixelSnapH)
  ------------------
  |  Branch (3415:13): [True: 223, False: 0]
  ------------------
 3416|    223|            advance_x = IM_ROUND(advance_x);
  ------------------
  |  |  285|    223|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 3417|       |
 3418|       |        // Bake spacing
 3419|    223|        advance_x += cfg->GlyphExtraSpacing.x;
 3420|    223|    }
 3421|       |
 3422|    223|    Glyphs.resize(Glyphs.Size + 1);
 3423|    223|    ImFontGlyph& glyph = Glyphs.back();
 3424|    223|    glyph.Codepoint = (unsigned int)codepoint;
 3425|    223|    glyph.Visible = (x0 != x1) && (y0 != y1);
  ------------------
  |  Branch (3425:21): [True: 214, False: 9]
  |  Branch (3425:35): [True: 214, False: 0]
  ------------------
 3426|    223|    glyph.Colored = false;
 3427|    223|    glyph.X0 = x0;
 3428|    223|    glyph.Y0 = y0;
 3429|    223|    glyph.X1 = x1;
 3430|    223|    glyph.Y1 = y1;
 3431|    223|    glyph.U0 = u0;
 3432|    223|    glyph.V0 = v0;
 3433|    223|    glyph.U1 = u1;
 3434|    223|    glyph.V1 = v1;
 3435|    223|    glyph.AdvanceX = advance_x;
 3436|       |
 3437|       |    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
 3438|       |    // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
 3439|    223|    float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
 3440|    223|    DirtyLookupTables = true;
 3441|    223|    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
 3442|    223|}
_ZNK6ImFont9FindGlyphEt:
 3460|   586k|{
 3461|   586k|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3461:9): [True: 22.7k, False: 563k]
  ------------------
 3462|  22.7k|        return FallbackGlyph;
 3463|   563k|    const ImWchar i = IndexLookup.Data[c];
 3464|   563k|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3464:9): [True: 728, False: 562k]
  ------------------
 3465|    728|        return FallbackGlyph;
 3466|   562k|    return &Glyphs.Data[i];
 3467|   563k|}
_ZNK6ImFont19FindGlyphNoFallbackEt:
 3470|      5|{
 3471|      5|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3471:9): [True: 2, False: 3]
  ------------------
 3472|      2|        return NULL;
 3473|      3|    const ImWchar i = IndexLookup.Data[c];
 3474|      3|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3474:9): [True: 0, False: 3]
  ------------------
 3475|      0|        return NULL;
 3476|      3|    return &Glyphs.Data[i];
 3477|      3|}
_ZNK6ImFont13CalcTextSizeAEfffPKcS1_PS1_:
 3591|  6.61M|{
 3592|  6.61M|    if (!text_end)
  ------------------
  |  Branch (3592:9): [True: 6.55M, False: 58.7k]
  ------------------
 3593|  6.55M|        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.
 3594|       |
 3595|  6.61M|    const float line_height = size;
 3596|  6.61M|    const float scale = size / FontSize;
 3597|       |
 3598|  6.61M|    ImVec2 text_size = ImVec2(0, 0);
 3599|  6.61M|    float line_width = 0.0f;
 3600|       |
 3601|  6.61M|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 3602|  6.61M|    const char* word_wrap_eol = NULL;
 3603|       |
 3604|  6.61M|    const char* s = text_begin;
 3605|  14.8M|    while (s < text_end)
  ------------------
  |  Branch (3605:12): [True: 8.20M, False: 6.61M]
  ------------------
 3606|  8.20M|    {
 3607|  8.20M|        if (word_wrap_enabled)
  ------------------
  |  Branch (3607:13): [True: 0, False: 8.20M]
  ------------------
 3608|      0|        {
 3609|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 3610|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (3610:17): [True: 0, False: 0]
  ------------------
 3611|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
 3612|       |
 3613|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (3613:17): [True: 0, False: 0]
  ------------------
 3614|      0|            {
 3615|      0|                if (text_size.x < line_width)
  ------------------
  |  Branch (3615:21): [True: 0, False: 0]
  ------------------
 3616|      0|                    text_size.x = line_width;
 3617|      0|                text_size.y += line_height;
 3618|      0|                line_width = 0.0f;
 3619|      0|                word_wrap_eol = NULL;
 3620|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 3621|      0|                continue;
 3622|      0|            }
 3623|      0|        }
 3624|       |
 3625|       |        // Decode and advance source
 3626|  8.20M|        const char* prev_s = s;
 3627|  8.20M|        unsigned int c = (unsigned int)*s;
 3628|  8.20M|        if (c < 0x80)
  ------------------
  |  Branch (3628:13): [True: 4.28M, False: 3.92M]
  ------------------
 3629|  4.28M|            s += 1;
 3630|  3.92M|        else
 3631|  3.92M|            s += ImTextCharFromUtf8(&c, s, text_end);
 3632|       |
 3633|  8.20M|        if (c < 32)
  ------------------
  |  Branch (3633:13): [True: 11.8k, False: 8.19M]
  ------------------
 3634|  11.8k|        {
 3635|  11.8k|            if (c == '\n')
  ------------------
  |  Branch (3635:17): [True: 0, False: 11.8k]
  ------------------
 3636|      0|            {
 3637|      0|                text_size.x = ImMax(text_size.x, line_width);
 3638|      0|                text_size.y += line_height;
 3639|      0|                line_width = 0.0f;
 3640|      0|                continue;
 3641|      0|            }
 3642|  11.8k|            if (c == '\r')
  ------------------
  |  Branch (3642:17): [True: 99, False: 11.7k]
  ------------------
 3643|     99|                continue;
 3644|  11.8k|        }
 3645|       |
 3646|  8.20M|        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
  ------------------
  |  Branch (3646:35): [True: 4.29M, False: 3.91M]
  ------------------
 3647|  8.20M|        if (line_width + char_width >= max_width)
  ------------------
  |  Branch (3647:13): [True: 0, False: 8.20M]
  ------------------
 3648|      0|        {
 3649|      0|            s = prev_s;
 3650|      0|            break;
 3651|      0|        }
 3652|       |
 3653|  8.20M|        line_width += char_width;
 3654|  8.20M|    }
 3655|       |
 3656|  6.61M|    if (text_size.x < line_width)
  ------------------
  |  Branch (3656:9): [True: 6.61M, False: 99]
  ------------------
 3657|  6.61M|        text_size.x = line_width;
 3658|       |
 3659|  6.61M|    if (line_width > 0 || text_size.y == 0.0f)
  ------------------
  |  Branch (3659:9): [True: 6.61M, False: 99]
  |  Branch (3659:27): [True: 99, False: 0]
  ------------------
 3660|  6.61M|        text_size.y += line_height;
 3661|       |
 3662|  6.61M|    if (remaining)
  ------------------
  |  Branch (3662:9): [True: 0, False: 6.61M]
  ------------------
 3663|      0|        *remaining = s;
 3664|       |
 3665|  6.61M|    return text_size;
 3666|  6.61M|}
_ZNK6ImFont10RenderTextEP10ImDrawListfRK6ImVec2jRK6ImVec4PKcS9_fb:
 3685|   362k|{
 3686|   362k|    if (!text_end)
  ------------------
  |  Branch (3686:9): [True: 0, False: 362k]
  ------------------
 3687|      0|        text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.
 3688|       |
 3689|       |    // Align to be pixel perfect
 3690|   362k|    float x = IM_TRUNC(pos.x);
  ------------------
  |  |  284|   362k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 3691|   362k|    float y = IM_TRUNC(pos.y);
  ------------------
  |  |  284|   362k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 3692|   362k|    if (y > clip_rect.w)
  ------------------
  |  Branch (3692:9): [True: 286k, False: 75.6k]
  ------------------
 3693|   286k|        return;
 3694|       |
 3695|  75.6k|    const float start_x = x;
 3696|  75.6k|    const float scale = size / FontSize;
 3697|  75.6k|    const float line_height = FontSize * scale;
 3698|  75.6k|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 3699|       |
 3700|       |    // Fast-forward to first visible line
 3701|  75.6k|    const char* s = text_begin;
 3702|  75.6k|    if (y + line_height < clip_rect.y)
  ------------------
  |  Branch (3702:9): [True: 0, False: 75.6k]
  ------------------
 3703|      0|        while (y + line_height < clip_rect.y && s < text_end)
  ------------------
  |  Branch (3703:16): [True: 0, False: 0]
  |  Branch (3703:49): [True: 0, False: 0]
  ------------------
 3704|      0|        {
 3705|      0|            const char* line_end = (const char*)memchr(s, '\n', text_end - s);
 3706|      0|            if (word_wrap_enabled)
  ------------------
  |  Branch (3706:17): [True: 0, False: 0]
  ------------------
 3707|      0|            {
 3708|       |                // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
 3709|       |                // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
 3710|       |                // However it is still better than nothing performing the fast-forward!
 3711|      0|                s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);
  ------------------
  |  Branch (3711:53): [True: 0, False: 0]
  ------------------
 3712|      0|                s = CalcWordWrapNextLineStartA(s, text_end);
 3713|      0|            }
 3714|      0|            else
 3715|      0|            {
 3716|      0|                s = line_end ? line_end + 1 : text_end;
  ------------------
  |  Branch (3716:21): [True: 0, False: 0]
  ------------------
 3717|      0|            }
 3718|      0|            y += line_height;
 3719|      0|        }
 3720|       |
 3721|       |    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
 3722|       |    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
 3723|  75.6k|    if (text_end - s > 10000 && !word_wrap_enabled)
  ------------------
  |  Branch (3723:9): [True: 2, False: 75.6k]
  |  Branch (3723:33): [True: 2, False: 0]
  ------------------
 3724|      2|    {
 3725|      2|        const char* s_end = s;
 3726|      2|        float y_end = y;
 3727|      2|        while (y_end < clip_rect.w && s_end < text_end)
  ------------------
  |  Branch (3727:16): [True: 0, False: 2]
  |  Branch (3727:39): [True: 0, False: 0]
  ------------------
 3728|      0|        {
 3729|      0|            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
 3730|      0|            s_end = s_end ? s_end + 1 : text_end;
  ------------------
  |  Branch (3730:21): [True: 0, False: 0]
  ------------------
 3731|      0|            y_end += line_height;
 3732|      0|        }
 3733|      2|        text_end = s_end;
 3734|      2|    }
 3735|  75.6k|    if (s == text_end)
  ------------------
  |  Branch (3735:9): [True: 2, False: 75.6k]
  ------------------
 3736|      2|        return;
 3737|       |
 3738|       |    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
 3739|  75.6k|    const int vtx_count_max = (int)(text_end - s) * 4;
 3740|  75.6k|    const int idx_count_max = (int)(text_end - s) * 6;
 3741|  75.6k|    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
 3742|  75.6k|    draw_list->PrimReserve(idx_count_max, vtx_count_max);
 3743|  75.6k|    ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;
 3744|  75.6k|    ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
 3745|  75.6k|    unsigned int vtx_index = draw_list->_VtxCurrentIdx;
 3746|       |
 3747|  75.6k|    const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
  ------------------
  |  | 2583|  75.6k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 3748|  75.6k|    const char* word_wrap_eol = NULL;
 3749|       |
 3750|   662k|    while (s < text_end)
  ------------------
  |  Branch (3750:12): [True: 586k, False: 75.6k]
  ------------------
 3751|   586k|    {
 3752|   586k|        if (word_wrap_enabled)
  ------------------
  |  Branch (3752:13): [True: 0, False: 586k]
  ------------------
 3753|      0|        {
 3754|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 3755|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (3755:17): [True: 0, False: 0]
  ------------------
 3756|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));
 3757|       |
 3758|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (3758:17): [True: 0, False: 0]
  ------------------
 3759|      0|            {
 3760|      0|                x = start_x;
 3761|      0|                y += line_height;
 3762|      0|                word_wrap_eol = NULL;
 3763|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 3764|      0|                continue;
 3765|      0|            }
 3766|      0|        }
 3767|       |
 3768|       |        // Decode and advance source
 3769|   586k|        unsigned int c = (unsigned int)*s;
 3770|   586k|        if (c < 0x80)
  ------------------
  |  Branch (3770:13): [True: 562k, False: 23.3k]
  ------------------
 3771|   562k|            s += 1;
 3772|  23.3k|        else
 3773|  23.3k|            s += ImTextCharFromUtf8(&c, s, text_end);
 3774|       |
 3775|   586k|        if (c < 32)
  ------------------
  |  Branch (3775:13): [True: 750, False: 585k]
  ------------------
 3776|    750|        {
 3777|    750|            if (c == '\n')
  ------------------
  |  Branch (3777:17): [True: 0, False: 750]
  ------------------
 3778|      0|            {
 3779|      0|                x = start_x;
 3780|      0|                y += line_height;
 3781|      0|                if (y > clip_rect.w)
  ------------------
  |  Branch (3781:21): [True: 0, False: 0]
  ------------------
 3782|      0|                    break; // break out of main loop
 3783|      0|                continue;
 3784|      0|            }
 3785|    750|            if (c == '\r')
  ------------------
  |  Branch (3785:17): [True: 22, False: 728]
  ------------------
 3786|     22|                continue;
 3787|    750|        }
 3788|       |
 3789|   586k|        const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
 3790|   586k|        if (glyph == NULL)
  ------------------
  |  Branch (3790:13): [True: 0, False: 586k]
  ------------------
 3791|      0|            continue;
 3792|       |
 3793|   586k|        float char_width = glyph->AdvanceX * scale;
 3794|   586k|        if (glyph->Visible)
  ------------------
  |  Branch (3794:13): [True: 543k, False: 43.0k]
  ------------------
 3795|   543k|        {
 3796|       |            // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
 3797|   543k|            float x1 = x + glyph->X0 * scale;
 3798|   543k|            float x2 = x + glyph->X1 * scale;
 3799|   543k|            float y1 = y + glyph->Y0 * scale;
 3800|   543k|            float y2 = y + glyph->Y1 * scale;
 3801|   543k|            if (x1 <= clip_rect.z && x2 >= clip_rect.x)
  ------------------
  |  Branch (3801:17): [True: 484k, False: 59.2k]
  |  Branch (3801:38): [True: 457k, False: 26.3k]
  ------------------
 3802|   457k|            {
 3803|       |                // Render a character
 3804|   457k|                float u1 = glyph->U0;
 3805|   457k|                float v1 = glyph->V0;
 3806|   457k|                float u2 = glyph->U1;
 3807|   457k|                float v2 = glyph->V1;
 3808|       |
 3809|       |                // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
 3810|   457k|                if (cpu_fine_clip)
  ------------------
  |  Branch (3810:21): [True: 1, False: 457k]
  ------------------
 3811|      1|                {
 3812|      1|                    if (x1 < clip_rect.x)
  ------------------
  |  Branch (3812:25): [True: 0, False: 1]
  ------------------
 3813|      0|                    {
 3814|      0|                        u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
 3815|      0|                        x1 = clip_rect.x;
 3816|      0|                    }
 3817|      1|                    if (y1 < clip_rect.y)
  ------------------
  |  Branch (3817:25): [True: 0, False: 1]
  ------------------
 3818|      0|                    {
 3819|      0|                        v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
 3820|      0|                        y1 = clip_rect.y;
 3821|      0|                    }
 3822|      1|                    if (x2 > clip_rect.z)
  ------------------
  |  Branch (3822:25): [True: 1, False: 0]
  ------------------
 3823|      1|                    {
 3824|      1|                        u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
 3825|      1|                        x2 = clip_rect.z;
 3826|      1|                    }
 3827|      1|                    if (y2 > clip_rect.w)
  ------------------
  |  Branch (3827:25): [True: 0, False: 1]
  ------------------
 3828|      0|                    {
 3829|      0|                        v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
 3830|      0|                        y2 = clip_rect.w;
 3831|      0|                    }
 3832|      1|                    if (y1 >= y2)
  ------------------
  |  Branch (3832:25): [True: 0, False: 1]
  ------------------
 3833|      0|                    {
 3834|      0|                        x += char_width;
 3835|      0|                        continue;
 3836|      0|                    }
 3837|      1|                }
 3838|       |
 3839|       |                // Support for untinted glyphs
 3840|   457k|                ImU32 glyph_col = glyph->Colored ? col_untinted : col;
  ------------------
  |  Branch (3840:35): [True: 0, False: 457k]
  ------------------
 3841|       |
 3842|       |                // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
 3843|   457k|                {
 3844|   457k|                    vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
 3845|   457k|                    vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
 3846|   457k|                    vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
 3847|   457k|                    vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
 3848|   457k|                    idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);
 3849|   457k|                    idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
 3850|   457k|                    vtx_write += 4;
 3851|   457k|                    vtx_index += 4;
 3852|   457k|                    idx_write += 6;
 3853|   457k|                }
 3854|   457k|            }
 3855|   543k|        }
 3856|   586k|        x += char_width;
 3857|   586k|    }
 3858|       |
 3859|       |    // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
 3860|  75.6k|    draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
 3861|  75.6k|    draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
 3862|  75.6k|    draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
 3863|  75.6k|    draw_list->_VtxWritePtr = vtx_write;
 3864|  75.6k|    draw_list->_IdxWritePtr = idx_write;
 3865|  75.6k|    draw_list->_VtxCurrentIdx = vtx_index;
 3866|  75.6k|}
_ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2jif:
 3886|  58.7k|{
 3887|  58.7k|    const float h = draw_list->_Data->FontSize * 1.00f;
 3888|  58.7k|    float r = h * 0.40f * scale;
 3889|  58.7k|    ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
 3890|       |
 3891|  58.7k|    ImVec2 a, b, c;
 3892|  58.7k|    switch (dir)
  ------------------
  |  Branch (3892:13): [True: 0, False: 58.7k]
  ------------------
 3893|  58.7k|    {
 3894|      0|    case ImGuiDir_Up:
  ------------------
  |  Branch (3894:5): [True: 0, False: 58.7k]
  ------------------
 3895|  55.3k|    case ImGuiDir_Down:
  ------------------
  |  Branch (3895:5): [True: 55.3k, False: 3.41k]
  ------------------
 3896|  55.3k|        if (dir == ImGuiDir_Up) r = -r;
  ------------------
  |  Branch (3896:13): [True: 0, False: 55.3k]
  ------------------
 3897|  55.3k|        a = ImVec2(+0.000f, +0.750f) * r;
 3898|  55.3k|        b = ImVec2(-0.866f, -0.750f) * r;
 3899|  55.3k|        c = ImVec2(+0.866f, -0.750f) * r;
 3900|  55.3k|        break;
 3901|      0|    case ImGuiDir_Left:
  ------------------
  |  Branch (3901:5): [True: 0, False: 58.7k]
  ------------------
 3902|  3.41k|    case ImGuiDir_Right:
  ------------------
  |  Branch (3902:5): [True: 3.41k, False: 55.3k]
  ------------------
 3903|  3.41k|        if (dir == ImGuiDir_Left) r = -r;
  ------------------
  |  Branch (3903:13): [True: 0, False: 3.41k]
  ------------------
 3904|  3.41k|        a = ImVec2(+0.750f, +0.000f) * r;
 3905|  3.41k|        b = ImVec2(-0.750f, +0.866f) * r;
 3906|  3.41k|        c = ImVec2(-0.750f, -0.866f) * r;
 3907|  3.41k|        break;
 3908|      0|    case ImGuiDir_None:
  ------------------
  |  Branch (3908:5): [True: 0, False: 58.7k]
  ------------------
 3909|      0|    case ImGuiDir_COUNT:
  ------------------
  |  Branch (3909:5): [True: 0, False: 58.7k]
  ------------------
 3910|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3911|      0|        break;
 3912|  58.7k|    }
 3913|  58.7k|    draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
 3914|  58.7k|}
imgui_draw.cpp:_ZL18FixRectCornerFlagsi:
 1343|  54.4k|{
 1344|       |    /*
 1345|       |    IM_STATIC_ASSERT(ImDrawFlags_RoundCornersTopLeft == (1 << 4));
 1346|       |#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
 1347|       |    // Obsoleted in 1.82 (from February 2021). This code was stripped/simplified and mostly commented in 1.90 (from September 2023)
 1348|       |    // - Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
 1349|       |    if (flags == ~0)                    { return ImDrawFlags_RoundCornersAll; }
 1350|       |    // - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations). Read details in older version of this code.
 1351|       |    if (flags >= 0x01 && flags <= 0x0F) { return (flags << 4); }
 1352|       |    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
 1353|       |#endif
 1354|       |    */
 1355|       |    // If this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
 1356|       |    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway.
 1357|       |    // See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in "API BREAKING CHANGES" section.
 1358|  54.4k|    IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");
  ------------------
  |  |   23|  54.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1359|       |
 1360|  54.4k|    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
  ------------------
  |  Branch (1360:9): [True: 54.4k, False: 0]
  ------------------
 1361|  54.4k|        flags |= ImDrawFlags_RoundCornersAll;
 1362|       |
 1363|  54.4k|    return flags;
 1364|  54.4k|}
imgui_draw.cpp:_ZL8Decode85PKhPh:
 2206|      1|{
 2207|  2.39k|    while (*src)
  ------------------
  |  Branch (2207:12): [True: 2.39k, False: 1]
  ------------------
 2208|  2.39k|    {
 2209|  2.39k|        unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
 2210|  2.39k|        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
 2211|  2.39k|        src += 5;
 2212|  2.39k|        dst += 4;
 2213|  2.39k|    }
 2214|      1|}
imgui_draw.cpp:_ZL12Decode85Bytec:
 2204|  11.9k|static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
  ------------------
  |  Branch (2204:86): [True: 3.28k, False: 8.70k]
  ------------------
imgui_draw.cpp:_ZL31ImFontAtlasBuildWithStbTruetypeP11ImFontAtlas:
 2441|      1|{
 2442|      1|    IM_ASSERT(atlas->ConfigData.Size > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2443|       |
 2444|      1|    ImFontAtlasBuildInit(atlas);
 2445|       |
 2446|       |    // Clear atlas
 2447|      1|    atlas->TexID = (ImTextureID)NULL;
 2448|      1|    atlas->TexWidth = atlas->TexHeight = 0;
 2449|      1|    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
 2450|      1|    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
 2451|      1|    atlas->ClearTexData();
 2452|       |
 2453|       |    // Temporary storage for building
 2454|      1|    ImVector<ImFontBuildSrcData> src_tmp_array;
 2455|      1|    ImVector<ImFontBuildDstData> dst_tmp_array;
 2456|      1|    src_tmp_array.resize(atlas->ConfigData.Size);
 2457|      1|    dst_tmp_array.resize(atlas->Fonts.Size);
 2458|      1|    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
 2459|      1|    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());
 2460|       |
 2461|       |    // 1. Initialize font loading structure, check font data validity
 2462|      2|    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
  ------------------
  |  Branch (2462:25): [True: 1, False: 1]
  ------------------
 2463|      1|    {
 2464|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2465|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2466|      1|        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2467|       |
 2468|       |        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
 2469|      1|        src_tmp.DstIndex = -1;
 2470|      2|        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
  ------------------
  |  Branch (2470:32): [True: 1, False: 1]
  |  Branch (2470:64): [True: 1, False: 0]
  ------------------
 2471|      1|            if (cfg.DstFont == atlas->Fonts[output_i])
  ------------------
  |  Branch (2471:17): [True: 1, False: 0]
  ------------------
 2472|      1|                src_tmp.DstIndex = output_i;
 2473|      1|        if (src_tmp.DstIndex == -1)
  ------------------
  |  Branch (2473:13): [True: 0, False: 1]
  ------------------
 2474|      0|        {
 2475|      0|            IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2476|      0|            return false;
 2477|      0|        }
 2478|       |        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
 2479|      1|        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
 2480|      1|        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2481|      1|        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
  ------------------
  |  Branch (2481:13): [True: 0, False: 1]
  ------------------
 2482|      0|        {
 2483|      0|            IM_ASSERT(0 && "stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2484|      0|            return false;
 2485|      0|        }
 2486|       |
 2487|       |        // Measure highest codepoints
 2488|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2489|      1|        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
  ------------------
  |  Branch (2489:29): [True: 1, False: 0]
  ------------------
 2490|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2490:60): [True: 1, False: 1]
  |  Branch (2490:76): [True: 1, False: 0]
  ------------------
 2491|      1|        {
 2492|       |            // Check for valid range. This may also help detect *some* dangling pointers, because a common
 2493|       |            // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent.
 2494|      1|            IM_ASSERT(src_range[0] <= src_range[1]);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2495|      1|            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
 2496|      1|        }
 2497|      1|        dst_tmp.SrcCount++;
 2498|      1|        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
 2499|      1|    }
 2500|       |
 2501|       |    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
 2502|      1|    int total_glyphs_count = 0;
 2503|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2503:25): [True: 1, False: 1]
  ------------------
 2504|      1|    {
 2505|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2506|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2507|      1|        src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
 2508|      1|        if (dst_tmp.GlyphsSet.Storage.empty())
  ------------------
  |  Branch (2508:13): [True: 1, False: 0]
  ------------------
 2509|      1|            dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);
 2510|       |
 2511|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2511:60): [True: 1, False: 1]
  |  Branch (2511:76): [True: 1, False: 0]
  ------------------
 2512|    225|            for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
  ------------------
  |  Branch (2512:57): [True: 224, False: 1]
  ------------------
 2513|    224|            {
 2514|    224|                if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
  ------------------
  |  Branch (2514:21): [True: 0, False: 224]
  ------------------
 2515|      0|                    continue;
 2516|    224|                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
  ------------------
  |  Branch (2516:21): [True: 1, False: 223]
  ------------------
 2517|      1|                    continue;
 2518|       |
 2519|       |                // Add to avail set/counters
 2520|    223|                src_tmp.GlyphsCount++;
 2521|    223|                dst_tmp.GlyphsCount++;
 2522|    223|                src_tmp.GlyphsSet.SetBit(codepoint);
 2523|    223|                dst_tmp.GlyphsSet.SetBit(codepoint);
 2524|    223|                total_glyphs_count++;
 2525|    223|            }
 2526|      1|    }
 2527|       |
 2528|       |    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
 2529|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2529:25): [True: 1, False: 1]
  ------------------
 2530|      1|    {
 2531|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2532|      1|        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
 2533|      1|        UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
 2534|      1|        src_tmp.GlyphsSet.Clear();
 2535|      1|        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2536|      1|    }
 2537|      2|    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
  ------------------
  |  Branch (2537:25): [True: 1, False: 1]
  ------------------
 2538|      1|        dst_tmp_array[dst_i].GlyphsSet.Clear();
 2539|      1|    dst_tmp_array.clear();
 2540|       |
 2541|       |    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
 2542|       |    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
 2543|      1|    ImVector<stbrp_rect> buf_rects;
 2544|      1|    ImVector<stbtt_packedchar> buf_packedchars;
 2545|      1|    buf_rects.resize(total_glyphs_count);
 2546|      1|    buf_packedchars.resize(total_glyphs_count);
 2547|      1|    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
 2548|      1|    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());
 2549|       |
 2550|       |    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
 2551|      1|    int total_surface = 0;
 2552|      1|    int buf_rects_out_n = 0;
 2553|      1|    int buf_packedchars_out_n = 0;
 2554|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2554:25): [True: 1, False: 1]
  ------------------
 2555|      1|    {
 2556|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2557|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2557:13): [True: 0, False: 1]
  ------------------
 2558|      0|            continue;
 2559|       |
 2560|      1|        src_tmp.Rects = &buf_rects[buf_rects_out_n];
 2561|      1|        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
 2562|      1|        buf_rects_out_n += src_tmp.GlyphsCount;
 2563|      1|        buf_packedchars_out_n += src_tmp.GlyphsCount;
 2564|       |
 2565|       |        // Convert our ranges in the format stb_truetype wants
 2566|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2567|      1|        src_tmp.PackRange.font_size = cfg.SizePixels;
 2568|      1|        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
 2569|      1|        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
 2570|      1|        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
 2571|      1|        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
 2572|      1|        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
 2573|      1|        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;
 2574|       |
 2575|       |        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
 2576|      1|        const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);
  ------------------
  |  Branch (2576:29): [True: 1, False: 0]
  ------------------
 2577|      1|        const int padding = atlas->TexGlyphPadding;
 2578|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
  ------------------
  |  Branch (2578:31): [True: 223, False: 1]
  ------------------
 2579|    223|        {
 2580|    223|            int x0, y0, x1, y1;
 2581|    223|            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
 2582|    223|            IM_ASSERT(glyph_index_in_font != 0);
  ------------------
  |  |   23|    223|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2583|    223|            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
 2584|    223|            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
 2585|    223|            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
 2586|    223|            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
 2587|    223|        }
 2588|      1|    }
 2589|       |
 2590|       |    // We need a width for the skyline algorithm, any width!
 2591|       |    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
 2592|       |    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
 2593|      1|    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
  ------------------
  |  |  447|      1|#define ImSqrt(X)           sqrtf(X)
  ------------------
 2594|      1|    atlas->TexHeight = 0;
 2595|      1|    if (atlas->TexDesiredWidth > 0)
  ------------------
  |  Branch (2595:9): [True: 0, False: 1]
  ------------------
 2596|      0|        atlas->TexWidth = atlas->TexDesiredWidth;
 2597|      1|    else
 2598|      1|        atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;
  ------------------
  |  Branch (2598:27): [True: 0, False: 1]
  |  Branch (2598:66): [True: 0, False: 1]
  |  Branch (2598:105): [True: 0, False: 1]
  ------------------
 2599|       |
 2600|       |    // 5. Start packing
 2601|       |    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
 2602|      1|    const int TEX_HEIGHT_MAX = 1024 * 32;
 2603|      1|    stbtt_pack_context spc = {};
 2604|      1|    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
 2605|      1|    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);
 2606|       |
 2607|       |    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
 2608|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2608:25): [True: 1, False: 1]
  ------------------
 2609|      1|    {
 2610|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2611|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2611:13): [True: 0, False: 1]
  ------------------
 2612|      0|            continue;
 2613|       |
 2614|      1|        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);
 2615|       |
 2616|       |        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
 2617|       |        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
 2618|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (2618:31): [True: 223, False: 1]
  ------------------
 2619|    223|            if (src_tmp.Rects[glyph_i].was_packed)
  ------------------
  |  Branch (2619:17): [True: 223, False: 0]
  ------------------
 2620|    223|                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
 2621|      1|    }
 2622|       |
 2623|       |    // 7. Allocate texture
 2624|      1|    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
  ------------------
  |  Branch (2624:24): [True: 0, False: 1]
  ------------------
 2625|      1|    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
 2626|      1|    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
  ------------------
  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2627|      1|    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
 2628|      1|    spc.pixels = atlas->TexPixelsAlpha8;
 2629|      1|    spc.height = atlas->TexHeight;
 2630|       |
 2631|       |    // 8. Render/rasterize font characters into the texture
 2632|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2632:25): [True: 1, False: 1]
  ------------------
 2633|      1|    {
 2634|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2635|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2636|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2636:13): [True: 0, False: 1]
  ------------------
 2637|      0|            continue;
 2638|       |
 2639|      1|        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);
 2640|       |
 2641|       |        // Apply multiply operator
 2642|      1|        if (cfg.RasterizerMultiply != 1.0f)
  ------------------
  |  Branch (2642:13): [True: 0, False: 1]
  ------------------
 2643|      0|        {
 2644|      0|            unsigned char multiply_table[256];
 2645|      0|            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
 2646|      0|            stbrp_rect* r = &src_tmp.Rects[0];
 2647|      0|            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
  ------------------
  |  Branch (2647:35): [True: 0, False: 0]
  ------------------
 2648|      0|                if (r->was_packed)
  ------------------
  |  Branch (2648:21): [True: 0, False: 0]
  ------------------
 2649|      0|                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
 2650|      0|        }
 2651|      1|        src_tmp.Rects = NULL;
 2652|      1|    }
 2653|       |
 2654|       |    // End packing
 2655|      1|    stbtt_PackEnd(&spc);
 2656|      1|    buf_rects.clear();
 2657|       |
 2658|       |    // 9. Setup ImFont and glyphs for runtime
 2659|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2659:25): [True: 1, False: 1]
  ------------------
 2660|      1|    {
 2661|       |        // When merging fonts with MergeMode=true:
 2662|       |        // - We can have multiple input fonts writing into a same destination font.
 2663|       |        // - dst_font->ConfigData is != from cfg which is our source configuration.
 2664|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2665|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2666|      1|        ImFont* dst_font = cfg.DstFont;
 2667|       |
 2668|      1|        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
 2669|      1|        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
 2670|      1|        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
 2671|       |
 2672|      1|        const float ascent = ImTrunc(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));
  ------------------
  |  Branch (2672:70): [True: 1, False: 0]
  ------------------
 2673|      1|        const float descent = ImTrunc(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));
  ------------------
  |  Branch (2673:72): [True: 0, False: 1]
  ------------------
 2674|      1|        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
 2675|      1|        const float font_off_x = cfg.GlyphOffset.x;
 2676|      1|        const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);
  ------------------
  |  |  285|      1|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 2677|       |
 2678|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (2678:31): [True: 223, False: 1]
  ------------------
 2679|    223|        {
 2680|       |            // Register glyph
 2681|    223|            const int codepoint = src_tmp.GlyphsList[glyph_i];
 2682|    223|            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
 2683|    223|            stbtt_aligned_quad q;
 2684|    223|            float unused_x = 0.0f, unused_y = 0.0f;
 2685|    223|            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
 2686|    223|            dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);
 2687|    223|        }
 2688|      1|    }
 2689|       |
 2690|       |    // Cleanup
 2691|      1|    src_tmp_array.clear_destruct();
 2692|       |
 2693|      1|    ImFontAtlasBuildFinish(atlas);
 2694|      1|    return true;
 2695|      1|}
imgui_draw.cpp:_ZL30UnpackBitVectorToFlatIndexListPK11ImBitVectorP8ImVectorIiE:
 2429|      1|{
 2430|      1|    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2431|      1|    const ImU32* it_begin = in->Storage.begin();
 2432|      1|    const ImU32* it_end = in->Storage.end();
 2433|      9|    for (const ImU32* it = it_begin; it < it_end; it++)
  ------------------
  |  Branch (2433:38): [True: 8, False: 1]
  ------------------
 2434|      8|        if (ImU32 entries_32 = *it)
  ------------------
  |  Branch (2434:19): [True: 7, False: 1]
  ------------------
 2435|    231|            for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
  ------------------
  |  Branch (2435:35): [True: 224, False: 7]
  ------------------
 2436|    224|                if (entries_32 & ((ImU32)1 << bit_n))
  ------------------
  |  Branch (2436:21): [True: 223, False: 1]
  ------------------
 2437|    223|                    out->push_back((int)(((it - it_begin) << 5) + bit_n));
 2438|      1|}
imgui_draw.cpp:_ZL36ImFontAtlasBuildRenderDefaultTexDataP11ImFontAtlas:
 2784|      1|{
 2785|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
 2786|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2787|       |
 2788|      1|    const int w = atlas->TexWidth;
 2789|      1|    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (2789:9): [True: 1, False: 0]
  ------------------
 2790|      1|    {
 2791|       |        // Render/copy pixels
 2792|      1|        IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2793|      1|        const int x_for_white = r->X;
 2794|      1|        const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
 2795|      1|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2795:13): [True: 1, False: 0]
  ------------------
 2796|      1|        {
 2797|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
 2798|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
 2799|      1|        }
 2800|      0|        else
 2801|      0|        {
 2802|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
  ------------------
  |  | 2587|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2803|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
  ------------------
  |  | 2587|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2804|      0|        }
 2805|      1|    }
 2806|      0|    else
 2807|      0|    {
 2808|       |        // Render 4 white pixels
 2809|      0|        IM_ASSERT(r->Width == 2 && r->Height == 2);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2810|      0|        const int offset = (int)r->X + (int)r->Y * w;
 2811|      0|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2811:13): [True: 0, False: 0]
  ------------------
 2812|      0|        {
 2813|      0|            atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
 2814|      0|        }
 2815|      0|        else
 2816|      0|        {
 2817|      0|            atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
  ------------------
  |  | 2587|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2818|      0|        }
 2819|      0|    }
 2820|      1|    atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
 2821|      1|}
imgui_draw.cpp:_ZL34ImFontAtlasBuildRenderLinesTexDataP11ImFontAtlas:
 2824|      1|{
 2825|      1|    if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
  ------------------
  |  Branch (2825:9): [True: 0, False: 1]
  ------------------
 2826|      0|        return;
 2827|       |
 2828|       |    // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
 2829|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
 2830|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2831|     65|    for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
  ------------------
  |  | 2619|     65|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (2831:30): [True: 64, False: 1]
  ------------------
 2832|     64|    {
 2833|       |        // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
 2834|     64|        unsigned int y = n;
 2835|     64|        unsigned int line_width = n;
 2836|     64|        unsigned int pad_left = (r->Width - line_width) / 2;
 2837|     64|        unsigned int pad_right = r->Width - (pad_left + line_width);
 2838|       |
 2839|       |        // Write each slice
 2840|     64|        IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
  ------------------
  |  |   23|     64|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2841|     64|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2841:13): [True: 64, False: 0]
  ------------------
 2842|     64|        {
 2843|     64|            unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
 2844|  1.12k|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (2844:38): [True: 1.05k, False: 64]
  ------------------
 2845|  1.05k|                *(write_ptr + i) = 0x00;
 2846|       |
 2847|  2.08k|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (2847:38): [True: 2.01k, False: 64]
  ------------------
 2848|  2.01k|                *(write_ptr + pad_left + i) = 0xFF;
 2849|       |
 2850|  1.15k|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (2850:38): [True: 1.08k, False: 64]
  ------------------
 2851|  1.08k|                *(write_ptr + pad_left + line_width + i) = 0x00;
 2852|     64|        }
 2853|      0|        else
 2854|      0|        {
 2855|      0|            unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
 2856|      0|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (2856:38): [True: 0, False: 0]
  ------------------
 2857|      0|                *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2858|       |
 2859|      0|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (2859:38): [True: 0, False: 0]
  ------------------
 2860|      0|                *(write_ptr + pad_left + i) = IM_COL32_WHITE;
  ------------------
  |  | 2587|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2861|       |
 2862|      0|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (2862:38): [True: 0, False: 0]
  ------------------
 2863|      0|                *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2586|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2582|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2581|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2580|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2579|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2864|      0|        }
 2865|       |
 2866|       |        // Calculate UVs for this line
 2867|     64|        ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
 2868|     64|        ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
 2869|     64|        float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
 2870|     64|        atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
 2871|     64|    }
 2872|      1|}
imgui_draw.cpp:_ZL22FindFirstExistingGlyphP6ImFontPKti:
 3278|      2|{
 3279|      3|    for (int n = 0; n < candidate_chars_count; n++)
  ------------------
  |  Branch (3279:21): [True: 3, False: 0]
  ------------------
 3280|      3|        if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
  ------------------
  |  Branch (3280:13): [True: 2, False: 1]
  ------------------
 3281|      2|            return candidate_chars[n];
 3282|      0|    return (ImWchar)-1;
 3283|      2|}
imgui_draw.cpp:_ZL21stb_decompress_lengthPKh:
 4105|      2|{
 4106|      2|    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
 4107|      2|}
imgui_draw.cpp:_ZL14stb_decompressPhPKhj:
 4183|      1|{
 4184|      1|    if (stb__in4(0) != 0x57bC0000) return 0;
  ------------------
  |  | 4132|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4131|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4130|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4184:9): [True: 0, False: 1]
  ------------------
 4185|      1|    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
  ------------------
  |  | 4132|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4131|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4130|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4185:9): [True: 0, False: 1]
  ------------------
 4186|      1|    const unsigned int olen = stb_decompress_length(i);
 4187|      1|    stb__barrier_in_b = i;
 4188|      1|    stb__barrier_out_e = output + olen;
 4189|      1|    stb__barrier_out_b = output;
 4190|      1|    i += 16;
 4191|       |
 4192|      1|    stb__dout = output;
 4193|  2.98k|    for (;;) {
 4194|  2.98k|        const unsigned char *old_i = i;
 4195|  2.98k|        i = stb_decompress_token(i);
 4196|  2.98k|        if (i == old_i) {
  ------------------
  |  Branch (4196:13): [True: 1, False: 2.98k]
  ------------------
 4197|      1|            if (*i == 0x05 && i[1] == 0xfa) {
  ------------------
  |  Branch (4197:17): [True: 1, False: 0]
  |  Branch (4197:31): [True: 1, False: 0]
  ------------------
 4198|      1|                IM_ASSERT(stb__dout == output + olen);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4199|      1|                if (stb__dout != output + olen) return 0;
  ------------------
  |  Branch (4199:21): [True: 0, False: 1]
  ------------------
 4200|      1|                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
  ------------------
  |  | 4132|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4131|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4130|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4200:21): [True: 0, False: 1]
  ------------------
 4201|      0|                    return 0;
 4202|      1|                return olen;
 4203|      1|            } else {
 4204|      0|                IM_ASSERT(0); /* NOTREACHED */
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4205|      0|                return 0;
 4206|      0|            }
 4207|      1|        }
 4208|  2.98k|        IM_ASSERT(stb__dout <= output + olen);
  ------------------
  |  |   23|  2.98k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4209|  2.98k|        if (stb__dout > output + olen)
  ------------------
  |  Branch (4209:13): [True: 0, False: 2.98k]
  ------------------
 4210|      0|            return 0;
 4211|  2.98k|    }
 4212|      1|}
imgui_draw.cpp:_ZL20stb_decompress_tokenPKh:
 4135|  2.98k|{
 4136|  2.98k|    if (*i >= 0x20) { // use fewer if's for cases that expand small
  ------------------
  |  Branch (4136:9): [True: 2.86k, False: 119]
  ------------------
 4137|  2.86k|        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
  ------------------
  |  Branch (4137:13): [True: 818, False: 2.04k]
  ------------------
 4138|  2.04k|        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
  ------------------
  |  | 4130|  1.39k|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4138:18): [True: 1.39k, False: 653]
  ------------------
 4139|    653|        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
 4140|  2.86k|    } else { // more ifs for cases that expand large, since overhead is amortized
 4141|    119|        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
  ------------------
  |  | 4131|    111|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4130|    111|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4141:13): [True: 111, False: 8]
  ------------------
 4142|      8|        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4131|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4130|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4130|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4142:18): [True: 0, False: 8]
  ------------------
 4143|      8|        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4130|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4130|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4143:18): [True: 7, False: 1]
  ------------------
 4144|      1|        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4130|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4130|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4144:18): [True: 0, False: 1]
  ------------------
 4145|      1|        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
  ------------------
  |  | 4131|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4130|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4145:18): [True: 0, False: 1]
  ------------------
 4146|      1|        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4131|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4130|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4130|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4146:18): [True: 0, False: 1]
  ------------------
 4147|    119|    }
 4148|  2.98k|    return i;
 4149|  2.98k|}
imgui_draw.cpp:_ZL10stb__matchPKhj:
 4113|  2.32k|{
 4114|       |    // INVERSE of memmove... write each byte before copying the next...
 4115|  2.32k|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|  2.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4116|  2.32k|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (4116:9): [True: 0, False: 2.32k]
  ------------------
 4117|  2.32k|    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (4117:9): [True: 0, False: 2.32k]
  ------------------
 4118|  40.8k|    while (length--) *stb__dout++ = *data++;
  ------------------
  |  Branch (4118:12): [True: 38.5k, False: 2.32k]
  ------------------
 4119|  2.32k|}
imgui_draw.cpp:_ZL8stb__litPKhj:
 4122|    660|{
 4123|    660|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|    660|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4124|    660|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (4124:9): [True: 0, False: 660]
  ------------------
 4125|    660|    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (4125:9): [True: 0, False: 660]
  ------------------
 4126|    660|    memcpy(stb__dout, data, length);
 4127|    660|    stb__dout += length;
 4128|    660|}
imgui_draw.cpp:_ZL11stb_adler32jPhj:
 4152|      1|{
 4153|      1|    const unsigned long ADLER_MOD = 65521;
 4154|      1|    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
 4155|      1|    unsigned long blocklen = buflen % 5552;
 4156|       |
 4157|      1|    unsigned long i;
 4158|      9|    while (buflen) {
  ------------------
  |  Branch (4158:12): [True: 8, False: 1]
  ------------------
 4159|  5.15k|        for (i=0; i + 7 < blocklen; i += 8) {
  ------------------
  |  Branch (4159:19): [True: 5.15k, False: 8]
  ------------------
 4160|  5.15k|            s1 += buffer[0], s2 += s1;
 4161|  5.15k|            s1 += buffer[1], s2 += s1;
 4162|  5.15k|            s1 += buffer[2], s2 += s1;
 4163|  5.15k|            s1 += buffer[3], s2 += s1;
 4164|  5.15k|            s1 += buffer[4], s2 += s1;
 4165|  5.15k|            s1 += buffer[5], s2 += s1;
 4166|  5.15k|            s1 += buffer[6], s2 += s1;
 4167|  5.15k|            s1 += buffer[7], s2 += s1;
 4168|       |
 4169|  5.15k|            buffer += 8;
 4170|  5.15k|        }
 4171|       |
 4172|      8|        for (; i < blocklen; ++i)
  ------------------
  |  Branch (4172:16): [True: 0, False: 8]
  ------------------
 4173|      0|            s1 += *buffer++, s2 += s1;
 4174|       |
 4175|      8|        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
 4176|      8|        buflen -= blocklen;
 4177|      8|        blocklen = 5552;
 4178|      8|    }
 4179|      1|    return (unsigned int)(s2 << 16) + (unsigned int)s1;
 4180|      1|}
imgui_draw.cpp:_ZL37GetDefaultCompressedFontDataTTFBase85v:
 4315|      1|{
 4316|      1|    return proggy_clean_ttf_compressed_data_base85;
 4317|      1|}

imgui.cpp:_ZL7ImTruncRK6ImVec2:
  492|   110k|static inline ImVec2 ImTrunc(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }
imgui.cpp:_ZL7ImTruncf:
  491|   425k|static inline float  ImTrunc(float f)                                           { return (float)(int)(f); }
_ZN15ImGuiInputEventC2Ev:
 1380|  10.1k|    ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }
_ZN5ImGui18IsNamedKeyOrModKeyE8ImGuiKey:
 3307|  84.7k|    inline bool             IsNamedKeyOrModKey(ImGuiKey key)                            { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super || key == ImGuiMod_Shortcut; }
  ------------------
  |  Branch (3307:99): [True: 84.7k, False: 0]
  |  Branch (3307:133): [True: 84.7k, False: 0]
  |  Branch (3307:165): [True: 0, False: 0]
  |  Branch (3307:189): [True: 0, False: 0]
  |  Branch (3307:214): [True: 0, False: 0]
  |  Branch (3307:237): [True: 0, False: 0]
  |  Branch (3307:262): [True: 0, False: 0]
  ------------------
_ZN5ImGui10IsAliasKeyE8ImGuiKey:
 3312|   210k|    inline bool             IsAliasKey(ImGuiKey key)                                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1317|   420k|#define ImGuiKey_Aliases_BEGIN          (ImGuiKey_Mouse_BEGIN)
  |  |  ------------------
  |  |  |  | 1315|   210k|#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)
  |  |  ------------------
  ------------------
                  inline bool             IsAliasKey(ImGuiKey key)                                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1318|   205k|#define ImGuiKey_Aliases_END            (ImGuiKey_Mouse_END)
  |  |  ------------------
  |  |  |  | 1316|   205k|#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)
  |  |  ------------------
  ------------------
  |  Branch (3312:98): [True: 205k, False: 4.73k]
  |  Branch (3312:131): [True: 205k, False: 2]
  ------------------
_ZN5ImGui12IsGamepadKeyE8ImGuiKey:
 3310|  4.29k|    inline bool             IsGamepadKey(ImGuiKey key)                                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1313|  8.59k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                  inline bool             IsGamepadKey(ImGuiKey key)                                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1314|    110|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (3310:98): [True: 110, False: 4.18k]
  |  Branch (3310:131): [True: 110, False: 0]
  ------------------
_ZN5ImGui10IsNamedKeyE8ImGuiKey:
 3306|  1.16M|    inline bool             IsNamedKey(ImGuiKey key)                                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }
  ------------------
  |  Branch (3306:98): [True: 1.16M, False: 4]
  |  Branch (3306:132): [True: 1.16M, False: 5]
  ------------------
imgui.cpp:_ZL7ImFloorf:
  493|   356k|static inline float  ImFloor(float f)                                           { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (493:99): [True: 353k, False: 2.20k]
  |  Branch (493:109): [True: 1.16k, False: 1.04k]
  ------------------
imgui.cpp:_ZL11ImLengthSqrRK6ImVec2:
  488|  37.3k|static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }
imgui.cpp:_ZL10ImSaturatef:
  487|  2.34M|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (487:90): [True: 0, False: 2.34M]
  |  Branch (487:110): [True: 0, False: 2.34M]
  ------------------
imgui.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  368|  55.3k|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (368:147): [True: 0, False: 55.3k]
  ------------------
_ZNK16ImGuiDataVarInfo9GetVarPtrEPv:
 1015|  58.7k|    void* GetVarPtr(void* parent) const { return (void*)((unsigned char*)parent + Offset); }
_ZN13ImGuiStyleModC2Ei6ImVec2:
 1054|  29.3k|    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
_ZN6ImRect8ClipWithERKS_:
  566|   204k|    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
imgui.cpp:_ZL5ImMinRK6ImVec2S1_:
  481|   204k|static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (481:97): [True: 199k, False: 4.95k]
  |  Branch (481:128): [True: 162k, False: 42.0k]
  ------------------
_ZN6ImRect6ExpandERK6ImVec2:
  562|  32.6k|    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
_ZNK6ImRect8ContainsERKS_:
  556|  2.13k|    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
  ------------------
  |  Branch (556:62): [True: 2.13k, False: 0]
  |  Branch (556:82): [True: 2.13k, False: 0]
  |  Branch (556:102): [True: 1.97k, False: 166]
  |  Branch (556:122): [True: 1.12k, False: 851]
  ------------------
_ZNK14ImGuiViewportP11GetMainRectEv:
 1875|   171k|    ImRect  GetMainRect() const         { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK6ImRect8OverlapsERKS_:
  558|   155k|    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
  ------------------
  |  Branch (558:62): [True: 155k, False: 74]
  |  Branch (558:82): [True: 100k, False: 55.0k]
  |  Branch (558:102): [True: 100k, False: 17]
  |  Branch (558:122): [True: 100k, False: 352]
  ------------------
_ZN6ImRectC2ERK6ImVec2S2_:
  542|   558k|    constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}
_ZN12ImGuiContextC2EP11ImFontAtlas:
 2371|      1|    {
 2372|      1|        IO.Ctx = this;
 2373|      1|        InputTextState.Ctx = this;
 2374|       |
 2375|      1|        Initialized = false;
 2376|      1|        ConfigFlagsCurrFrame = ConfigFlagsLastFrame = ImGuiConfigFlags_None;
 2377|      1|        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
  ------------------
  |  Branch (2377:35): [True: 0, False: 1]
  ------------------
 2378|      1|        Font = NULL;
 2379|      1|        FontSize = FontBaseSize = 0.0f;
 2380|      1|        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
  ------------------
  |  | 1883|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
  |  Branch (2380:20): [True: 0, False: 1]
  ------------------
 2381|      1|        Time = 0.0f;
 2382|      1|        FrameCount = 0;
 2383|      1|        FrameCountEnded = FrameCountPlatformEnded = FrameCountRendered = -1;
 2384|      1|        WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
 2385|      1|        GcCompactAll = false;
 2386|      1|        TestEngineHookItems = false;
 2387|      1|        TestEngine = NULL;
 2388|       |
 2389|      1|        InputEventsNextMouseSource = ImGuiMouseSource_Mouse;
 2390|      1|        InputEventsNextEventId = 1;
 2391|       |
 2392|      1|        WindowsActiveCount = 0;
 2393|      1|        CurrentWindow = NULL;
 2394|      1|        HoveredWindow = NULL;
 2395|      1|        HoveredWindowUnderMovingWindow = NULL;
 2396|      1|        MovingWindow = NULL;
 2397|      1|        WheelingWindow = NULL;
 2398|      1|        WheelingWindowStartFrame = -1;
 2399|      1|        WheelingWindowReleaseTimer = 0.0f;
 2400|       |
 2401|      1|        DebugHookIdInfo = 0;
 2402|      1|        HoveredId = HoveredIdPreviousFrame = 0;
 2403|      1|        HoveredIdAllowOverlap = false;
 2404|      1|        HoveredIdDisabled = false;
 2405|      1|        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
 2406|      1|        ActiveId = 0;
 2407|      1|        ActiveIdIsAlive = 0;
 2408|      1|        ActiveIdTimer = 0.0f;
 2409|      1|        ActiveIdIsJustActivated = false;
 2410|      1|        ActiveIdAllowOverlap = false;
 2411|      1|        ActiveIdNoClearOnFocusLoss = false;
 2412|      1|        ActiveIdHasBeenPressedBefore = false;
 2413|      1|        ActiveIdHasBeenEditedBefore = false;
 2414|      1|        ActiveIdHasBeenEditedThisFrame = false;
 2415|      1|        ActiveIdClickOffset = ImVec2(-1, -1);
 2416|      1|        ActiveIdWindow = NULL;
 2417|      1|        ActiveIdSource = ImGuiInputSource_None;
 2418|      1|        ActiveIdMouseButton = -1;
 2419|      1|        ActiveIdPreviousFrame = 0;
 2420|      1|        ActiveIdPreviousFrameIsAlive = false;
 2421|      1|        ActiveIdPreviousFrameHasBeenEditedBefore = false;
 2422|      1|        ActiveIdPreviousFrameWindow = NULL;
 2423|      1|        LastActiveId = 0;
 2424|      1|        LastActiveIdTimer = 0.0f;
 2425|       |
 2426|      1|        ActiveIdUsingNavDirMask = 0x00;
 2427|      1|        ActiveIdUsingAllKeyboardKeys = false;
 2428|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 2429|       |        ActiveIdUsingNavInputMask = 0x00;
 2430|       |#endif
 2431|       |
 2432|      1|        CurrentFocusScopeId = 0;
 2433|      1|        CurrentItemFlags = ImGuiItemFlags_None;
 2434|      1|        DebugShowGroupRects = false;
 2435|      1|        BeginMenuCount = 0;
 2436|       |
 2437|      1|        CurrentDpiScale = 0.0f;
 2438|      1|        CurrentViewport = NULL;
 2439|      1|        MouseViewport = MouseLastHoveredViewport = NULL;
 2440|      1|        PlatformLastFocusedViewportId = 0;
 2441|      1|        ViewportCreatedCount = PlatformWindowsCreatedCount = 0;
 2442|      1|        ViewportFocusedStampCount = 0;
 2443|       |
 2444|      1|        NavWindow = NULL;
 2445|      1|        NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = 0;
 2446|      1|        NavJustMovedToId = NavJustMovedToFocusScopeId = NavNextActivateId = 0;
 2447|      1|        NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
 2448|      1|        NavJustMovedToKeyMods = ImGuiMod_None;
 2449|      1|        NavInputSource = ImGuiInputSource_Keyboard;
 2450|      1|        NavLayer = ImGuiNavLayer_Main;
 2451|      1|        NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1681|      1|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
 2452|      1|        NavIdIsAlive = false;
 2453|      1|        NavMousePosDirty = false;
 2454|      1|        NavDisableHighlight = true;
 2455|      1|        NavDisableMouseHover = false;
 2456|      1|        NavAnyRequest = false;
 2457|      1|        NavInitRequest = false;
 2458|      1|        NavInitRequestFromMove = false;
 2459|      1|        NavMoveSubmitted = false;
 2460|      1|        NavMoveScoringItems = false;
 2461|      1|        NavMoveForwardToNextFrame = false;
 2462|      1|        NavMoveFlags = ImGuiNavMoveFlags_None;
 2463|      1|        NavMoveScrollFlags = ImGuiScrollFlags_None;
 2464|      1|        NavMoveKeyMods = ImGuiMod_None;
 2465|      1|        NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
 2466|      1|        NavScoringDebugCount = 0;
 2467|      1|        NavTabbingDir = 0;
 2468|      1|        NavTabbingCounter = 0;
 2469|       |
 2470|      1|        ConfigNavWindowingKeyNext = ImGuiMod_Ctrl | ImGuiKey_Tab;
 2471|      1|        ConfigNavWindowingKeyPrev = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab;
 2472|      1|        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
 2473|      1|        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
 2474|      1|        NavWindowingToggleLayer = false;
 2475|       |
 2476|      1|        DimBgRatio = 0.0f;
 2477|       |
 2478|      1|        DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
 2479|      1|        DragDropSourceFlags = ImGuiDragDropFlags_None;
 2480|      1|        DragDropSourceFrameCount = -1;
 2481|      1|        DragDropMouseButton = -1;
 2482|      1|        DragDropTargetId = 0;
 2483|      1|        DragDropAcceptFlags = ImGuiDragDropFlags_None;
 2484|      1|        DragDropAcceptIdCurrRectSurface = 0.0f;
 2485|      1|        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
 2486|      1|        DragDropAcceptFrameCount = -1;
 2487|      1|        DragDropHoldJustPressedId = 0;
 2488|      1|        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));
 2489|       |
 2490|      1|        ClipperTempDataStacked = 0;
 2491|       |
 2492|      1|        CurrentTable = NULL;
 2493|      1|        TablesTempDataStacked = 0;
 2494|      1|        CurrentTabBar = NULL;
 2495|       |
 2496|      1|        HoverItemDelayId = HoverItemDelayIdPreviousFrame = HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;
 2497|      1|        HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;
 2498|       |
 2499|      1|        MouseCursor = ImGuiMouseCursor_Arrow;
 2500|      1|        MouseStationaryTimer = 0.0f;
 2501|       |
 2502|      1|        TempInputId = 0;
 2503|      1|        ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
 2504|      1|        ColorEditCurrentID = ColorEditSavedID = 0;
 2505|      1|        ColorEditSavedHue = ColorEditSavedSat = 0.0f;
 2506|      1|        ColorEditSavedColor = 0;
 2507|      1|        SliderGrabClickOffset = 0.0f;
 2508|      1|        SliderCurrentAccum = 0.0f;
 2509|      1|        SliderCurrentAccumDirty = false;
 2510|      1|        DragCurrentAccumDirty = false;
 2511|      1|        DragCurrentAccum = 0.0f;
 2512|      1|        DragSpeedDefaultRatio = 1.0f / 100.0f;
 2513|      1|        ScrollbarClickDeltaToGrabCenter = 0.0f;
 2514|      1|        DisabledAlphaBackup = 0.0f;
 2515|      1|        DisabledStackSize = 0;
 2516|      1|        LockMarkEdited = 0;
 2517|      1|        TooltipOverrideCount = 0;
 2518|       |
 2519|      1|        PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
 2520|      1|        PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission
 2521|      1|        PlatformImeViewport = 0;
 2522|       |
 2523|      1|        DockNodeWindowMenuHandler = NULL;
 2524|       |
 2525|      1|        SettingsLoaded = false;
 2526|      1|        SettingsDirtyTimer = 0.0f;
 2527|      1|        HookIdNext = 0;
 2528|       |
 2529|      1|        memset(LocalizationTable, 0, sizeof(LocalizationTable));
 2530|       |
 2531|      1|        LogEnabled = false;
 2532|      1|        LogType = ImGuiLogType_None;
 2533|      1|        LogNextPrefix = LogNextSuffix = NULL;
 2534|      1|        LogFile = NULL;
 2535|      1|        LogLinePosY = FLT_MAX;
 2536|      1|        LogLineFirstItem = false;
 2537|      1|        LogDepthRef = 0;
 2538|      1|        LogDepthToExpand = LogDepthToExpandDefault = 2;
 2539|       |
 2540|      1|        DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
 2541|      1|        DebugLocateId = 0;
 2542|      1|        DebugLogClipperAutoDisableFrames = 0;
 2543|      1|        DebugLocateFrames = 0;
 2544|      1|        DebugBeginReturnValueCullDepth = -1;
 2545|      1|        DebugItemPickerActive = false;
 2546|      1|        DebugItemPickerMouseButton = ImGuiMouseButton_Left;
 2547|      1|        DebugItemPickerBreakId = 0;
 2548|      1|        DebugHoveredDockNode = NULL;
 2549|       |
 2550|      1|        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
 2551|      1|        FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
 2552|      1|        FramerateSecPerFrameAccum = 0.0f;
 2553|      1|        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
 2554|      1|    }
_ZN17ImGuiKeyOwnerDataC2Ev:
 1422|    140|    ImGuiKeyOwnerData()             { OwnerCurr = OwnerNext = ImGuiKeyOwner_None; LockThisFrame = LockUntilRelease = false; }
  ------------------
  |  | 1385|    140|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
_ZN20ImGuiKeyRoutingTableC2Ev:
 1409|      1|    ImGuiKeyRoutingTable()          { Clear(); }
_ZN17ImGuiNextItemDataC2Ev:
 1233|      1|    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); SelectionUserData = -1; }
_ZN17ImGuiLastItemDataC2Ev:
 1247|  84.7k|    ImGuiLastItemData()     { memset(this, 0, sizeof(*this)); }
_ZN19ImGuiNextWindowDataC2Ev:
 1208|      1|    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiNavItemDataC2Ev:
 1579|      5|    ImGuiNavItemData()  { Clear(); }
_ZN6ImPoolI10ImGuiTableEC2Ev:
  688|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN6ImPoolI11ImGuiTabBarEC2Ev:
  688|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN19ImGuiInputTextStateC2Ev:
 1135|      1|    ImGuiInputTextState()                   { memset(this, 0, sizeof(*this)); }
_ZN30ImGuiInputTextDeactivatedStateC2Ev:
 1112|      1|    ImGuiInputTextDeactivatedState()    { memset(this, 0, sizeof(*this)); }
_ZN21ImGuiComboPreviewDataC2Ev:
 1067|      1|    ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }
_ZN22ImGuiTypingSelectStateC2Ev:
 1616|      1|    ImGuiTypingSelectState() { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiDockContextC2Ev:
 1830|      1|    ImGuiDockContext()              { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiIDStackToolC2Ev:
 2022|      1|    ImGuiIDStackTool()      { memset(this, 0, sizeof(*this)); CopyToClipboardLastTime = -FLT_MAX; }
_ZN19ImGuiDebugAllocInfoC2Ev:
 1983|      1|    ImGuiDebugAllocInfo() { memset(this, 0, sizeof(*this)); }
_ZN20ImGuiSettingsHandlerC2Ev:
 1917|      3|    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
_ZN14ImGuiViewportPC2Ev:
 1865|      1|    ImGuiViewportP()                    { Window = NULL; Idx = -1; LastFrameActive = BgFgDrawListsLastFrame[0] = BgFgDrawListsLastFrame[1] = LastFocusedStampCount = -1; LastNameHash = 0; Alpha = LastAlpha = 1.0f; LastFocusedHadNavWindow = false; PlatformMonitor = -1; BgFgDrawLists[0] = BgFgDrawLists[1] = NULL; LastPlatformPos = LastPlatformSize = LastRendererSize = ImVec2(FLT_MAX, FLT_MAX); }
_ZN17ImDrawDataBuilderC2Ev:
  808|      1|    ImDrawDataBuilder()                     { memset(this, 0, sizeof(*this)); }
_ZN20ImGuiKeyRoutingTable5ClearEv:
 1410|    141|    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Index); n++) Index[n] = -1; Entries.clear(); EntriesNext.clear(); }
  ------------------
  |  |   88|    141|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1410:55): [True: 140, False: 1]
  ------------------
_ZN6ImVec1C2Ev:
  521|     12|    constexpr ImVec1()         : x(0.0f) { }
_ZN16ImGuiMenuColumnsC2Ev:
 1100|      4|    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }
_ZN6ImRectC2Ev:
  541|   314k|    constexpr ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}
_ZN8ImVec2ihC2Ev:
  529|      8|    constexpr ImVec2ih()                           : x(0), y(0) {}
_ZN5ImGui18WindowRectAbsToRelEP11ImGuiWindowRK6ImRect:
 3134|  2.55k|    inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }
_ZN14ImGuiViewportP14UpdateWorkRectEv:
 1872|  58.7k|    void    UpdateWorkRect()            { WorkPos = CalcWorkRectPos(WorkOffsetMin); WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax); } // Update public fields
_ZNK14ImGuiViewportP15CalcWorkRectPosERK6ImVec2:
 1870|  58.7k|    ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }
_ZNK14ImGuiViewportP16CalcWorkRectSizeERK6ImVec2S2_:
 1871|  58.7k|    ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }
_ZNK11ImGuiWindow12TitleBarRectEv:
 2752|   146k|    ImRect      TitleBarRect() const    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
_ZNK6ImRect8ContainsERK6ImVec2:
  555|     24|    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
  ------------------
  |  Branch (555:62): [True: 24, False: 0]
  |  Branch (555:82): [True: 24, False: 0]
  |  Branch (555:102): [True: 24, False: 0]
  |  Branch (555:122): [True: 21, False: 3]
  ------------------
imgui.cpp:_ZL5ImMaxRK6ImVec2S1_:
  482|   521k|static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (482:97): [True: 406k, False: 114k]
  |  Branch (482:129): [True: 406k, False: 114k]
  ------------------
_ZN5ImGui14GetDefaultFontEv:
 3150|  29.3k|    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }
  ------------------
  |  Branch (3150:82): [True: 0, False: 29.3k]
  ------------------
_ZN6ImRectC2Effff:
  544|   732k|    constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}
_ZN6ImRect3AddERKS_:
  560|  58.7k|    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
  ------------------
  |  Branch (560:59): [True: 58.7k, False: 30]
  |  Branch (560:97): [True: 58.7k, False: 30]
  |  Branch (560:135): [True: 58.7k, False: 30]
  |  Branch (560:173): [True: 58.7k, False: 21]
  ------------------
_ZNK6ImRect6ToVec4Ev:
  570|  29.3k|    ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }
_ZN5ImGui16GetCurrentWindowEv:
 3120|   469k|    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
_ZN6ImRectC2ERK6ImVec4:
  543|   338k|    constexpr ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}
_ZNK6ImRect7GetSizeEv:
  547|  84.6k|    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
imgui.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  475|     80|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (475:90): [True: 0, False: 80]
  |  Branch (475:106): [True: 0, False: 80]
  ------------------
_ZN15ImGuiStackSizesC2Ev:
 1272|  84.6k|    ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }
_ZNK11ImGuiWindow14TitleBarHeightEv:
 2751|   430k|    float       TitleBarHeight() const  { ImGuiContext& g = *Ctx; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }
  ------------------
  |  Branch (2751:74): [True: 77.8k, False: 352k]
  ------------------
_ZNK11ImGuiWindow13MenuBarHeightEv:
 2753|   202k|    float       MenuBarHeight() const   { ImGuiContext& g = *Ctx; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }
  ------------------
  |  Branch (2753:74): [True: 0, False: 202k]
  ------------------
_ZNK11ImGuiWindow4RectEv:
 2749|   137k|    ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK14ImGuiViewportP11GetWorkRectEv:
 1876|  84.6k|    ImRect  GetWorkRect() const         { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }
_ZNK6ImRect8GetWidthEv:
  548|   221k|    float       GetWidth() const                    { return Max.x - Min.x; }
_ZNK6ImRect9GetHeightEv:
  549|   201k|    float       GetHeight() const                   { return Max.y - Min.y; }
imgui.cpp:_ZL6ImLerpRK6ImVec2S1_S1_:
  485|  51.8k|static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
_ZN6ImRect12ClipWithFullERKS_:
  567|  84.6k|    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
_ZN19ImGuiNextWindowData10ClearFlagsEv:
 1209|  84.6k|    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }
_ZNK11ImGuiWindow12CalcFontSizeEv:
 2750|   511k|    float       CalcFontSize() const    { ImGuiContext& g = *Ctx; float scale = g.FontBaseSize * FontWindowScale * FontDpiScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }
  ------------------
  |  Branch (2750:134): [True: 41.8k, False: 469k]
  ------------------
imgui.cpp:_ZL14ImIsPowerOfTwoi:
  375|   114k|static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
  ------------------
  |  Branch (375:66): [True: 114k, False: 0]
  |  Branch (375:76): [True: 114k, False: 0]
  ------------------
_ZN5ImGui20GetCurrentWindowReadEv:
 3119|  32.3k|    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
_ZN5ImGui25ConvertSingleModFlagToKeyEP12ImGuiContext8ImGuiKey:
 3315|   264k|    {
 3316|   264k|        ImGuiContext& g = *ctx;
 3317|   264k|        if (key == ImGuiMod_Ctrl) return ImGuiKey_ReservedForModCtrl;
  ------------------
  |  Branch (3317:13): [True: 58.7k, False: 205k]
  ------------------
 3318|   205k|        if (key == ImGuiMod_Shift) return ImGuiKey_ReservedForModShift;
  ------------------
  |  Branch (3318:13): [True: 58.7k, False: 146k]
  ------------------
 3319|   146k|        if (key == ImGuiMod_Alt) return ImGuiKey_ReservedForModAlt;
  ------------------
  |  Branch (3319:13): [True: 88.1k, False: 58.7k]
  ------------------
 3320|  58.7k|        if (key == ImGuiMod_Super) return ImGuiKey_ReservedForModSuper;
  ------------------
  |  Branch (3320:13): [True: 58.7k, False: 0]
  ------------------
 3321|      0|        if (key == ImGuiMod_Shortcut) return (g.IO.ConfigMacOSXBehaviors ? ImGuiKey_ReservedForModSuper : ImGuiKey_ReservedForModCtrl);
  ------------------
  |  Branch (3321:13): [True: 0, False: 0]
  |  Branch (3321:47): [True: 0, False: 0]
  ------------------
 3322|      0|        return key;
 3323|      0|    }
_ZN5ImGui10GetKeyDataE8ImGuiKey:
 3326|  1.07M|    inline ImGuiKeyData*    GetKeyData(ImGuiKey key)                                    { ImGuiContext& g = *GImGui; return GetKeyData(&g, key); }
_ZN5ImGui16MouseButtonToKeyEi:
 3328|   146k|    inline ImGuiKey         MouseButtonToKey(ImGuiMouseButton button)                   { IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT); return (ImGuiKey)(ImGuiKey_MouseLeft + button); }
  ------------------
  |  |   23|   146k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK6ImRect15ContainsWithPadERK6ImVec2S2_:
  557|   227k|    bool        ContainsWithPad(const ImVec2& p, const ImVec2& pad) const { return p.x >= Min.x - pad.x && p.y >= Min.y - pad.y && p.x < Max.x + pad.x && p.y < Max.y + pad.y; }
  ------------------
  |  Branch (557:84): [True: 27.9k, False: 199k]
  |  Branch (557:108): [True: 25.9k, False: 1.96k]
  |  Branch (557:132): [True: 10.4k, False: 15.4k]
  |  Branch (557:155): [True: 2.41k, False: 8.02k]
  ------------------
imgui.cpp:_ZL7ImFloorRK6ImVec2:
  494|  6.71k|static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2(ImFloor(v.x), ImFloor(v.y)); }
imgui.cpp:_ZL26ImExponentialMovingAverageffi:
  501|    930|static inline float  ImExponentialMovingAverage(float avg, float sample, int n) { avg -= avg / n; avg += sample / n; return avg; }
imgui.cpp:_ZL5ImAbsf:
  460|    938|static inline float  ImAbs(float x)             { return fabsf(x); }
_ZN5ImGui15GetKeyOwnerDataEP12ImGuiContext8ImGuiKey:
 3354|  82.3k|    inline ImGuiKeyOwnerData*   GetKeyOwnerData(ImGuiContext* ctx, ImGuiKey key)                    { if (key & ImGuiMod_Mask_) key = ConvertSingleModFlagToKey(ctx, key); IM_ASSERT(IsNamedKey(key)); return &ctx->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN]; }
  ------------------
  |  |   23|  82.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (3354:107): [True: 0, False: 82.3k]
  ------------------
imgui.cpp:_ZL7ImClampRK6ImVec2S1_S_:
  483|   312k|static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
  ------------------
  |  Branch (483:97): [True: 29.4k, False: 283k]
  |  Branch (483:119): [True: 2.91k, False: 280k]
  |  Branch (483:146): [True: 47.9k, False: 264k]
  |  Branch (483:168): [True: 32.2k, False: 232k]
  ------------------
_ZN16ImGuiNavItemData5ClearEv:
 1580|  12.0k|    void Clear()        { Window = NULL; ID = FocusScopeId = 0; InFlags = 0; SelectionUserData = -1; DistBox = DistCenter = DistAxial = FLT_MAX; }
_ZN5ImGui21IsActiveIdUsingNavDirEi:
 3336|  73.3k|    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }
_ZN6ImRect10TranslateYEf:
  565|  18.3k|    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
_ZN5ImGui18WindowRectRelToAbsEP11ImGuiWindowRK6ImRect:
 3135|  18.4k|    inline ImRect           WindowRectRelToAbs(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y); }
_ZNK6ImRect9GetCenterEv:
  546|  1.43k|    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
_ZNK13ImChunkStreamI19ImGuiWindowSettingsE5emptyEv:
  723|      1|    bool    empty() const               { return Buf.Size == 0; }
_ZN14ImGuiViewportP17ClearRequestFlagsEv:
 1867|  29.3k|    void    ClearRequestFlags()         { PlatformRequestClose = PlatformRequestMove = PlatformRequestResize = false; }
_ZNK6ImRect10IsInvertedEv:
  569|  36.6k|    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
  ------------------
  |  Branch (569:62): [True: 0, False: 36.6k]
  |  Branch (569:79): [True: 0, False: 36.6k]
  ------------------
imgui.cpp:_ZL5ImMinIfET_S0_S0_:
  473|   196k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (473:90): [True: 20.3k, False: 176k]
  ------------------
imgui.cpp:_ZL5ImMaxIfET_S0_S0_:
  474|  2.00M|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (474:90): [True: 1.47M, False: 529k]
  ------------------
imgui.cpp:_ZL5ImMinIiET_S0_S0_:
  473|  35.0k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (473:90): [True: 59, False: 34.9k]
  ------------------
imgui.cpp:_ZL6ImSwapIfEvRT_S1_:
  477|  51.8k|template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
_ZN10ImBitArrayILi140ELi0EEC2Ev:
  602|  29.3k|    ImBitArray()                                { ClearAllBits(); }
_ZN10ImBitArrayILi140ELi0EE12ClearAllBitsEv:
  603|  29.3k|    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }
_ZNK10ImBitArrayILi140ELi0EE7TestBitEi:
  605|  1.84k|    bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
  ------------------
  |  |   23|  1.84k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
  ------------------
  |  |  574|  1.84k|#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
  ------------------
_ZN10ImBitArrayILi140ELi0EE6SetBitEi:
  606|  1.61k|    void            SetBit(int n)               { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(Storage, n); }
  ------------------
  |  |   23|  1.61k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_Z16ImBitArraySetBitPji:
  580|  2.06k|inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }
imgui.cpp:_ZL6ImLerpIfET_S0_S0_f:
  476|    192|template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }
_ZN13ImChunkStreamI19ImGuiWindowSettingsE5beginEv:
  726|      2|    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }
  ------------------
  |  Branch (726:66): [True: 2, False: 0]
  ------------------
_ZN11ImBitVector6CreateEi:
  617|      2|    void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
_ZN11ImBitVector5ClearEv:
  618|      2|    void            Clear()                     { Storage.clear(); }
_ZNK11ImBitVector7TestBitEi:
  619|    224|    bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }
  ------------------
  |  |   23|    224|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }
  ------------------
  |  |  574|    224|#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
  ------------------
_ZN11ImBitVector6SetBitEi:
  620|    446|    void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui_draw.cpp:_ZL6ImLerpRK6ImVec4S1_f:
  486|      4|static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
imgui_draw.cpp:_ZL7ImRsqrtf:
  465|  1.11M|static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }
imgui_draw.cpp:_ZL5ImAbsi:
  459|   172k|static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }
  ------------------
  |  Branch (459:58): [True: 0, False: 172k]
  ------------------
imgui_draw.cpp:_ZL7ImFloorf:
  493|  1.28k|static inline float  ImFloor(float f)                                           { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (493:99): [True: 648, False: 636]
  |  Branch (493:109): [True: 636, False: 0]
  ------------------
imgui_draw.cpp:_ZL17ImUpperPowerOfTwoi:
  377|      1|static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
imgui_draw.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  368|      4|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (368:147): [True: 4, False: 0]
  ------------------
imgui_draw.cpp:_ZL7ImTruncf:
  491|      3|static inline float  ImTrunc(float f)                                           { return (float)(int)(f); }
imgui_draw.cpp:_ZL5ImMinIfET_S0_S0_:
  473|   108k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (473:90): [True: 78.0k, False: 30.9k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIfET_S0_S0_:
  474|   486k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (474:90): [True: 200k, False: 285k]
  ------------------
imgui_draw.cpp:_ZL7ImClampIiET_S0_S0_S0_:
  475|   183k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (475:90): [True: 0, False: 183k]
  |  Branch (475:106): [True: 0, False: 183k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIiET_S0_S0_:
  474|    450|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (474:90): [True: 223, False: 227]
  ------------------
imgui_draw.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  475|    223|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (475:90): [True: 0, False: 223]
  |  Branch (475:106): [True: 0, False: 223]
  ------------------
imgui_widgets.cpp:_ZL10ImSaturatef:
  487|  30.9k|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (487:90): [True: 17, False: 30.9k]
  |  Branch (487:110): [True: 2.72k, False: 28.2k]
  ------------------
imgui_widgets.cpp:_ZL14ImIsPowerOfTwoi:
  375|     17|static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
  ------------------
  |  Branch (375:66): [True: 17, False: 0]
  |  Branch (375:76): [True: 17, False: 0]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIfET_S0_S0_:
  474|  52.3k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (474:90): [True: 23.2k, False: 29.1k]
  ------------------
imgui_widgets.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  475|  91.5k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (475:90): [True: 3.44k, False: 88.1k]
  |  Branch (475:106): [True: 38.0k, False: 50.0k]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIxET_S0_S0_:
  474|   122k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (474:90): [True: 66.1k, False: 55.9k]
  ------------------
imgui_widgets.cpp:_ZL6ImLerpIfET_S0_S0_f:
  476|  61.0k|template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

_ZN5ImGui31TableSettingsAddSettingsHandlerEv:
 3533|      1|{
 3534|      1|    ImGuiSettingsHandler ini_handler;
 3535|      1|    ini_handler.TypeName = "Table";
 3536|      1|    ini_handler.TypeHash = ImHashStr("Table");
 3537|      1|    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
 3538|      1|    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
 3539|      1|    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
 3540|      1|    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
 3541|      1|    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
 3542|      1|    AddSettingsHandler(&ini_handler);
 3543|      1|}

_ZN5ImGui6TextExEPKcS1_i:
  149|     34|{
  150|     34|    ImGuiWindow* window = GetCurrentWindow();
  151|     34|    if (window->SkipItems)
  ------------------
  |  Branch (151:9): [True: 0, False: 34]
  ------------------
  152|      0|        return;
  153|     34|    ImGuiContext& g = *GImGui;
  154|       |
  155|       |    // Accept null ranges
  156|     34|    if (text == text_end)
  ------------------
  |  Branch (156:9): [True: 0, False: 34]
  ------------------
  157|      0|        text = text_end = "";
  158|       |
  159|       |    // Calculate length
  160|     34|    const char* text_begin = text;
  161|     34|    if (text_end == NULL)
  ------------------
  |  Branch (161:9): [True: 0, False: 34]
  ------------------
  162|      0|        text_end = text + strlen(text); // FIXME-OPT
  163|       |
  164|     34|    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrLineTextBaseOffset);
  165|     34|    const float wrap_pos_x = window->DC.TextWrapPos;
  166|     34|    const bool wrap_enabled = (wrap_pos_x >= 0.0f);
  167|     34|    if (text_end - text <= 2000 || wrap_enabled)
  ------------------
  |  Branch (167:9): [True: 34, False: 0]
  |  Branch (167:36): [True: 0, False: 0]
  ------------------
  168|     34|    {
  169|       |        // Common case
  170|     34|        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
  ------------------
  |  Branch (170:34): [True: 0, False: 34]
  ------------------
  171|     34|        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);
  172|       |
  173|     34|        ImRect bb(text_pos, text_pos + text_size);
  174|     34|        ItemSize(text_size, 0.0f);
  175|     34|        if (!ItemAdd(bb, 0))
  ------------------
  |  Branch (175:13): [True: 10, False: 24]
  ------------------
  176|     10|            return;
  177|       |
  178|       |        // Render (we don't hide text after ## in this end-user function)
  179|     24|        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
  180|     24|    }
  181|      0|    else
  182|      0|    {
  183|       |        // Long text!
  184|       |        // Perform manual coarse clipping to optimize for long multi-line text
  185|       |        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
  186|       |        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
  187|       |        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
  188|      0|        const char* line = text;
  189|      0|        const float line_height = GetTextLineHeight();
  190|      0|        ImVec2 text_size(0, 0);
  191|       |
  192|       |        // Lines to skip (can't skip when logging text)
  193|      0|        ImVec2 pos = text_pos;
  194|      0|        if (!g.LogEnabled)
  ------------------
  |  Branch (194:13): [True: 0, False: 0]
  ------------------
  195|      0|        {
  196|      0|            int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);
  197|      0|            if (lines_skippable > 0)
  ------------------
  |  Branch (197:17): [True: 0, False: 0]
  ------------------
  198|      0|            {
  199|      0|                int lines_skipped = 0;
  200|      0|                while (line < text_end && lines_skipped < lines_skippable)
  ------------------
  |  Branch (200:24): [True: 0, False: 0]
  |  Branch (200:43): [True: 0, False: 0]
  ------------------
  201|      0|                {
  202|      0|                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
  203|      0|                    if (!line_end)
  ------------------
  |  Branch (203:25): [True: 0, False: 0]
  ------------------
  204|      0|                        line_end = text_end;
  205|      0|                    if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
  ------------------
  |  Branch (205:25): [True: 0, False: 0]
  ------------------
  206|      0|                        text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
  207|      0|                    line = line_end + 1;
  208|      0|                    lines_skipped++;
  209|      0|                }
  210|      0|                pos.y += lines_skipped * line_height;
  211|      0|            }
  212|      0|        }
  213|       |
  214|       |        // Lines to render
  215|      0|        if (line < text_end)
  ------------------
  |  Branch (215:13): [True: 0, False: 0]
  ------------------
  216|      0|        {
  217|      0|            ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
  218|      0|            while (line < text_end)
  ------------------
  |  Branch (218:20): [True: 0, False: 0]
  ------------------
  219|      0|            {
  220|      0|                if (IsClippedEx(line_rect, 0))
  ------------------
  |  Branch (220:21): [True: 0, False: 0]
  ------------------
  221|      0|                    break;
  222|       |
  223|      0|                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
  224|      0|                if (!line_end)
  ------------------
  |  Branch (224:21): [True: 0, False: 0]
  ------------------
  225|      0|                    line_end = text_end;
  226|      0|                text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
  227|      0|                RenderText(pos, line, line_end, false);
  228|      0|                line = line_end + 1;
  229|      0|                line_rect.Min.y += line_height;
  230|      0|                line_rect.Max.y += line_height;
  231|      0|                pos.y += line_height;
  232|      0|            }
  233|       |
  234|       |            // Count remaining lines
  235|      0|            int lines_skipped = 0;
  236|      0|            while (line < text_end)
  ------------------
  |  Branch (236:20): [True: 0, False: 0]
  ------------------
  237|      0|            {
  238|      0|                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
  239|      0|                if (!line_end)
  ------------------
  |  Branch (239:21): [True: 0, False: 0]
  ------------------
  240|      0|                    line_end = text_end;
  241|      0|                if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
  ------------------
  |  Branch (241:21): [True: 0, False: 0]
  ------------------
  242|      0|                    text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
  243|      0|                line = line_end + 1;
  244|      0|                lines_skipped++;
  245|      0|            }
  246|      0|            pos.y += lines_skipped * line_height;
  247|      0|        }
  248|      0|        text_size.y = (pos - text_pos).y;
  249|       |
  250|      0|        ImRect bb(text_pos, text_pos + text_size);
  251|      0|        ItemSize(text_size, 0.0f);
  252|      0|        ItemAdd(bb, 0);
  253|      0|    }
  254|     34|}
_ZN5ImGui4TextEPKcz:
  262|     34|{
  263|     34|    va_list args;
  264|     34|    va_start(args, fmt);
  265|     34|    TextV(fmt, args);
  266|     34|    va_end(args);
  267|     34|}
_ZN5ImGui5TextVEPKcP13__va_list_tag:
  270|     34|{
  271|     34|    ImGuiWindow* window = GetCurrentWindow();
  272|     34|    if (window->SkipItems)
  ------------------
  |  Branch (272:9): [True: 0, False: 34]
  ------------------
  273|      0|        return;
  274|       |
  275|     34|    const char* text, *text_end;
  276|     34|    ImFormatStringToTempBufferV(&text, &text_end, fmt, args);
  277|     34|    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
  278|     34|}
_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i:
  481|   115k|{
  482|   115k|    ImGuiContext& g = *GImGui;
  483|   115k|    ImGuiWindow* window = GetCurrentWindow();
  484|       |
  485|       |    // Default only reacts to left mouse button
  486|   115k|    if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)
  ------------------
  |  Branch (486:9): [True: 115k, False: 0]
  ------------------
  487|   115k|        flags |= ImGuiButtonFlags_MouseButtonDefault_;
  488|       |
  489|       |    // Default behavior requires click + release inside bounding box
  490|   115k|    if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)
  ------------------
  |  Branch (490:9): [True: 115k, False: 0]
  ------------------
  491|   115k|        flags |= ImGuiButtonFlags_PressedOnDefault_;
  492|       |
  493|       |    // Default behavior inherited from item flags
  494|       |    // Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check that.
  495|   115k|    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);
  ------------------
  |  Branch (495:34): [True: 115k, False: 0]
  ------------------
  496|   115k|    if (flags & ImGuiButtonFlags_AllowOverlap)
  ------------------
  |  Branch (496:9): [True: 0, False: 115k]
  ------------------
  497|      0|        item_flags |= ImGuiItemFlags_AllowOverlap;
  498|   115k|    if (flags & ImGuiButtonFlags_Repeat)
  ------------------
  |  Branch (498:9): [True: 0, False: 115k]
  ------------------
  499|      0|        item_flags |= ImGuiItemFlags_ButtonRepeat;
  500|       |
  501|   115k|    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
  502|   115k|    const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;
  ------------------
  |  Branch (502:43): [True: 25.9k, False: 89.2k]
  |  Branch (502:89): [True: 465, False: 25.4k]
  |  Branch (502:108): [True: 465, False: 0]
  ------------------
  503|   115k|    if (flatten_hovered_children)
  ------------------
  |  Branch (503:9): [True: 465, False: 114k]
  ------------------
  504|    465|        g.HoveredWindow = window;
  505|       |
  506|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
  507|       |    // Alternate registration spot, for when caller didn't use ItemAdd()
  508|       |    if (id != 0 && g.LastItemData.ID != id)
  509|       |        IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);
  510|       |#endif
  511|       |
  512|   115k|    bool pressed = false;
  513|   115k|    bool hovered = ItemHoverable(bb, id, item_flags);
  514|       |
  515|       |    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
  516|   115k|    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
  ------------------
  |  Branch (516:9): [True: 0, False: 115k]
  |  Branch (516:29): [True: 0, False: 0]
  |  Branch (516:81): [True: 0, False: 0]
  ------------------
  517|      0|        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (517:13): [True: 0, False: 0]
  ------------------
  518|      0|        {
  519|      0|            hovered = true;
  520|      0|            SetHoveredID(id);
  521|      0|            if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)
  ------------------
  |  Branch (521:17): [True: 0, False: 0]
  |  Branch (521:85): [True: 0, False: 0]
  ------------------
  522|      0|            {
  523|      0|                pressed = true;
  524|      0|                g.DragDropHoldJustPressedId = id;
  525|      0|                FocusWindow(window);
  526|      0|            }
  527|      0|        }
  528|       |
  529|   115k|    if (flatten_hovered_children)
  ------------------
  |  Branch (529:9): [True: 465, False: 114k]
  ------------------
  530|    465|        g.HoveredWindow = backup_hovered_window;
  531|       |
  532|       |    // Mouse handling
  533|   115k|    const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;
  ------------------
  |  | 1384|      0|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (533:35): [True: 0, False: 115k]
  ------------------
  534|   115k|    if (hovered)
  ------------------
  |  Branch (534:9): [True: 163, False: 115k]
  ------------------
  535|    163|    {
  536|       |        // Poll mouse buttons
  537|       |        // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
  538|       |        // - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
  539|    163|        int mouse_button_clicked = -1;
  540|    163|        int mouse_button_released = -1;
  541|    652|        for (int button = 0; button < 3; button++)
  ------------------
  |  Branch (541:30): [True: 489, False: 163]
  ------------------
  542|    489|            if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
  ------------------
  |  Branch (542:17): [True: 163, False: 326]
  ------------------
  543|    163|            {
  544|    163|                if (IsMouseClicked(button, test_owner_id) && mouse_button_clicked == -1) { mouse_button_clicked = button; }
  ------------------
  |  Branch (544:21): [True: 0, False: 163]
  |  Branch (544:62): [True: 0, False: 0]
  ------------------
  545|    163|                if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) { mouse_button_released = button; }
  ------------------
  |  Branch (545:21): [True: 0, False: 163]
  |  Branch (545:63): [True: 0, False: 0]
  ------------------
  546|    163|            }
  547|       |
  548|       |        // Process initial action
  549|    163|        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
  ------------------
  |  Branch (549:13): [True: 163, False: 0]
  |  Branch (549:60): [True: 0, False: 0]
  |  Branch (549:77): [True: 0, False: 0]
  |  Branch (549:95): [True: 0, False: 0]
  ------------------
  550|    163|        {
  551|    163|            if (mouse_button_clicked != -1 && g.ActiveId != id)
  ------------------
  |  Branch (551:17): [True: 0, False: 163]
  |  Branch (551:47): [True: 0, False: 0]
  ------------------
  552|      0|            {
  553|      0|                if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))
  ------------------
  |  Branch (553:21): [True: 0, False: 0]
  ------------------
  554|      0|                    SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);
  555|      0|                if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))
  ------------------
  |  Branch (555:21): [True: 0, False: 0]
  ------------------
  556|      0|                {
  557|      0|                    SetActiveID(id, window);
  558|      0|                    g.ActiveIdMouseButton = mouse_button_clicked;
  559|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (559:25): [True: 0, False: 0]
  ------------------
  560|      0|                        SetFocusID(id, window);
  561|      0|                    FocusWindow(window);
  562|      0|                }
  563|      0|                if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2))
  ------------------
  |  Branch (563:21): [True: 0, False: 0]
  |  Branch (563:67): [True: 0, False: 0]
  |  Branch (563:118): [True: 0, False: 0]
  ------------------
  564|      0|                {
  565|      0|                    pressed = true;
  566|      0|                    if (flags & ImGuiButtonFlags_NoHoldingActiveId)
  ------------------
  |  Branch (566:25): [True: 0, False: 0]
  ------------------
  567|      0|                        ClearActiveID();
  568|      0|                    else
  569|      0|                        SetActiveID(id, window); // Hold on ID
  570|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (570:25): [True: 0, False: 0]
  ------------------
  571|      0|                        SetFocusID(id, window);
  572|      0|                    g.ActiveIdMouseButton = mouse_button_clicked;
  573|      0|                    FocusWindow(window);
  574|      0|                }
  575|      0|            }
  576|    163|            if (flags & ImGuiButtonFlags_PressedOnRelease)
  ------------------
  |  Branch (576:17): [True: 0, False: 163]
  ------------------
  577|      0|            {
  578|      0|                if (mouse_button_released != -1)
  ------------------
  |  Branch (578:21): [True: 0, False: 0]
  ------------------
  579|      0|                {
  580|      0|                    const bool has_repeated_at_least_once = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
  ------------------
  |  Branch (580:61): [True: 0, False: 0]
  |  Branch (580:107): [True: 0, False: 0]
  ------------------
  581|      0|                    if (!has_repeated_at_least_once)
  ------------------
  |  Branch (581:25): [True: 0, False: 0]
  ------------------
  582|      0|                        pressed = true;
  583|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (583:25): [True: 0, False: 0]
  ------------------
  584|      0|                        SetFocusID(id, window);
  585|      0|                    ClearActiveID();
  586|      0|                }
  587|      0|            }
  588|       |
  589|       |            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
  590|       |            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
  591|    163|            if (g.ActiveId == id && (item_flags & ImGuiItemFlags_ButtonRepeat))
  ------------------
  |  Branch (591:17): [True: 0, False: 163]
  |  Branch (591:37): [True: 0, False: 0]
  ------------------
  592|      0|                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, test_owner_id, ImGuiInputFlags_Repeat))
  ------------------
  |  Branch (592:21): [True: 0, False: 0]
  |  Branch (592:77): [True: 0, False: 0]
  ------------------
  593|      0|                    pressed = true;
  594|    163|        }
  595|       |
  596|    163|        if (pressed)
  ------------------
  |  Branch (596:13): [True: 0, False: 163]
  ------------------
  597|      0|            g.NavDisableHighlight = true;
  598|    163|    }
  599|       |
  600|       |    // Gamepad/Keyboard navigation
  601|       |    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
  602|   115k|    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
  ------------------
  |  Branch (602:9): [True: 0, False: 115k]
  |  Branch (602:26): [True: 0, False: 0]
  |  Branch (602:52): [True: 0, False: 0]
  |  Branch (602:79): [True: 0, False: 0]
  |  Branch (602:98): [True: 0, False: 0]
  |  Branch (602:118): [True: 0, False: 0]
  ------------------
  603|      0|        if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))
  ------------------
  |  Branch (603:13): [True: 0, False: 0]
  ------------------
  604|      0|            hovered = true;
  605|   115k|    if (g.NavActivateDownId == id)
  ------------------
  |  Branch (605:9): [True: 0, False: 115k]
  ------------------
  606|      0|    {
  607|      0|        bool nav_activated_by_code = (g.NavActivateId == id);
  608|      0|        bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
  609|      0|        if (!nav_activated_by_inputs && (item_flags & ImGuiItemFlags_ButtonRepeat))
  ------------------
  |  Branch (609:13): [True: 0, False: 0]
  |  Branch (609:41): [True: 0, False: 0]
  ------------------
  610|      0|        {
  611|       |            // Avoid pressing multiple keys from triggering excessive amount of repeat events
  612|      0|            const ImGuiKeyData* key1 = GetKeyData(ImGuiKey_Space);
  613|      0|            const ImGuiKeyData* key2 = GetKeyData(ImGuiKey_Enter);
  614|      0|            const ImGuiKeyData* key3 = GetKeyData(ImGuiKey_NavGamepadActivate);
  ------------------
  |  | 1325|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  615|      0|            const float t1 = ImMax(ImMax(key1->DownDuration, key2->DownDuration), key3->DownDuration);
  616|      0|            nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
  617|      0|        }
  618|      0|        if (nav_activated_by_code || nav_activated_by_inputs)
  ------------------
  |  Branch (618:13): [True: 0, False: 0]
  |  Branch (618:38): [True: 0, False: 0]
  ------------------
  619|      0|        {
  620|       |            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
  621|      0|            pressed = true;
  622|      0|            SetActiveID(id, window);
  623|      0|            g.ActiveIdSource = g.NavInputSource;
  624|      0|            if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (624:17): [True: 0, False: 0]
  ------------------
  625|      0|                SetFocusID(id, window);
  626|      0|        }
  627|      0|    }
  628|       |
  629|       |    // Process while held
  630|   115k|    bool held = false;
  631|   115k|    if (g.ActiveId == id)
  ------------------
  |  Branch (631:9): [True: 0, False: 115k]
  ------------------
  632|      0|    {
  633|      0|        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
  ------------------
  |  Branch (633:13): [True: 0, False: 0]
  ------------------
  634|      0|        {
  635|      0|            if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (635:17): [True: 0, False: 0]
  ------------------
  636|      0|                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
  637|       |
  638|      0|            const int mouse_button = g.ActiveIdMouseButton;
  639|      0|            if (mouse_button == -1)
  ------------------
  |  Branch (639:17): [True: 0, False: 0]
  ------------------
  640|      0|            {
  641|       |                // Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g. #6304).
  642|      0|                ClearActiveID();
  643|      0|            }
  644|      0|            else if (IsMouseDown(mouse_button, test_owner_id))
  ------------------
  |  Branch (644:22): [True: 0, False: 0]
  ------------------
  645|      0|            {
  646|      0|                held = true;
  647|      0|            }
  648|      0|            else
  649|      0|            {
  650|      0|                bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;
  ------------------
  |  Branch (650:35): [True: 0, False: 0]
  |  Branch (650:46): [True: 0, False: 0]
  ------------------
  651|      0|                bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
  652|      0|                if ((release_in || release_anywhere) && !g.DragDropActive)
  ------------------
  |  Branch (652:22): [True: 0, False: 0]
  |  Branch (652:36): [True: 0, False: 0]
  |  Branch (652:57): [True: 0, False: 0]
  ------------------
  653|      0|                {
  654|       |                    // Report as pressed when releasing the mouse (this is the most common path)
  655|      0|                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;
  ------------------
  |  Branch (655:52): [True: 0, False: 0]
  |  Branch (655:103): [True: 0, False: 0]
  |  Branch (655:139): [True: 0, False: 0]
  ------------------
  656|      0|                    bool is_repeating_already = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
  ------------------
  |  Branch (656:49): [True: 0, False: 0]
  |  Branch (656:95): [True: 0, False: 0]
  ------------------
  657|      0|                    bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);
  658|      0|                    if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)
  ------------------
  |  Branch (658:25): [True: 0, False: 0]
  |  Branch (658:53): [True: 0, False: 0]
  |  Branch (658:78): [True: 0, False: 0]
  ------------------
  659|      0|                        pressed = true;
  660|      0|                }
  661|      0|                ClearActiveID();
  662|      0|            }
  663|      0|            if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (663:17): [True: 0, False: 0]
  ------------------
  664|      0|                g.NavDisableHighlight = true;
  665|      0|        }
  666|      0|        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (666:18): [True: 0, False: 0]
  |  Branch (666:67): [True: 0, False: 0]
  ------------------
  667|      0|        {
  668|       |            // When activated using Nav, we hold on the ActiveID until activation button is released
  669|      0|            if (g.NavActivateDownId != id)
  ------------------
  |  Branch (669:17): [True: 0, False: 0]
  ------------------
  670|      0|                ClearActiveID();
  671|      0|        }
  672|      0|        if (pressed)
  ------------------
  |  Branch (672:13): [True: 0, False: 0]
  ------------------
  673|      0|            g.ActiveIdHasBeenPressedBefore = true;
  674|      0|    }
  675|       |
  676|   115k|    if (out_hovered) *out_hovered = hovered;
  ------------------
  |  Branch (676:9): [True: 115k, False: 0]
  ------------------
  677|   115k|    if (out_held) *out_held = held;
  ------------------
  |  Branch (677:9): [True: 115k, False: 0]
  ------------------
  678|       |
  679|   115k|    return pressed;
  680|   115k|}
_ZN5ImGui14CollapseButtonEjRK6ImVec2P13ImGuiDockNode:
  840|  58.7k|{
  841|  58.7k|    ImGuiContext& g = *GImGui;
  842|  58.7k|    ImGuiWindow* window = g.CurrentWindow;
  843|       |
  844|  58.7k|    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));
  845|  58.7k|    bool is_clipped = !ItemAdd(bb, id);
  846|  58.7k|    bool hovered, held;
  847|  58.7k|    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);
  848|  58.7k|    if (is_clipped)
  ------------------
  |  Branch (848:9): [True: 0, False: 58.7k]
  ------------------
  849|      0|        return pressed;
  850|       |
  851|       |    // Render
  852|       |    //bool is_dock_menu = (window->DockNodeAsHost && !window->Collapsed);
  853|  58.7k|    ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (853:33): [True: 0, False: 58.7k]
  |  Branch (853:41): [True: 0, False: 0]
  |  Branch (853:76): [True: 163, False: 58.5k]
  ------------------
  854|  58.7k|    ImU32 text_col = GetColorU32(ImGuiCol_Text);
  855|  58.7k|    if (hovered || held)
  ------------------
  |  Branch (855:9): [True: 163, False: 58.5k]
  |  Branch (855:20): [True: 0, False: 58.5k]
  ------------------
  856|    163|        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, bg_col);
  857|       |
  858|  58.7k|    if (dock_node)
  ------------------
  |  Branch (858:9): [True: 0, False: 58.7k]
  ------------------
  859|      0|        RenderArrowDockMenu(window->DrawList, bb.Min, g.FontSize, text_col);
  860|  58.7k|    else
  861|  58.7k|        RenderArrow(window->DrawList, bb.Min, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);
  ------------------
  |  Branch (861:57): [True: 3.41k, False: 55.3k]
  ------------------
  862|       |
  863|       |    // Switch to moving the window after mouse is moved beyond the initial drag threshold
  864|  58.7k|    if (IsItemActive() && IsMouseDragging(0))
  ------------------
  |  Branch (864:9): [True: 0, False: 58.7k]
  |  Branch (864:27): [True: 0, False: 0]
  ------------------
  865|      0|        StartMouseMovingWindowOrNode(window, dock_node, true);
  866|       |
  867|  58.7k|    return pressed;
  868|  58.7k|}
_ZN5ImGui20GetWindowScrollbarIDEP11ImGuiWindow9ImGuiAxis:
  871|  52.3k|{
  872|  52.3k|    return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
  ------------------
  |  Branch (872:26): [True: 25.9k, False: 26.3k]
  ------------------
  873|  52.3k|}
_ZN5ImGui22GetWindowScrollbarRectEP11ImGuiWindow9ImGuiAxis:
  877|  52.3k|{
  878|  52.3k|    const ImRect outer_rect = window->Rect();
  879|  52.3k|    const ImRect inner_rect = window->InnerRect;
  880|  52.3k|    const float border_size = window->WindowBorderSize;
  881|  52.3k|    const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
  882|  52.3k|    IM_ASSERT(scrollbar_size > 0.0f);
  ------------------
  |  |   23|  52.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  883|  52.3k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (883:9): [True: 25.9k, False: 26.3k]
  ------------------
  884|  25.9k|        return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);
  885|  26.3k|    else
  886|  26.3k|        return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);
  887|  52.3k|}
_ZN5ImGui9ScrollbarE9ImGuiAxis:
  890|  52.3k|{
  891|  52.3k|    ImGuiContext& g = *GImGui;
  892|  52.3k|    ImGuiWindow* window = g.CurrentWindow;
  893|  52.3k|    const ImGuiID id = GetWindowScrollbarID(window, axis);
  894|       |
  895|       |    // Calculate scrollbar bounding box
  896|  52.3k|    ImRect bb = GetWindowScrollbarRect(window, axis);
  897|  52.3k|    ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;
  898|  52.3k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (898:9): [True: 25.9k, False: 26.3k]
  ------------------
  899|  25.9k|    {
  900|  25.9k|        rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;
  901|  25.9k|        if (!window->ScrollbarY)
  ------------------
  |  Branch (901:13): [True: 2.60k, False: 23.3k]
  ------------------
  902|  2.60k|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  903|  25.9k|    }
  904|  26.3k|    else
  905|  26.3k|    {
  906|  26.3k|        if ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar))
  ------------------
  |  Branch (906:13): [True: 23.3k, False: 3.05k]
  |  Branch (906:62): [True: 23.3k, False: 0]
  ------------------
  907|  23.3k|            rounding_corners |= ImDrawFlags_RoundCornersTopRight;
  908|  26.3k|        if (!window->ScrollbarX)
  ------------------
  |  Branch (908:13): [True: 3.05k, False: 23.3k]
  ------------------
  909|  3.05k|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  910|  26.3k|    }
  911|  52.3k|    float size_avail = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
  912|  52.3k|    float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;
  913|  52.3k|    ImS64 scroll = (ImS64)window->Scroll[axis];
  914|  52.3k|    ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_avail, (ImS64)size_contents, rounding_corners);
  915|  52.3k|    window->Scroll[axis] = (float)scroll;
  916|  52.3k|}
_ZN5ImGui11ScrollbarExERK6ImRectj9ImGuiAxisPxxxi:
  925|  52.3k|{
  926|  52.3k|    ImGuiContext& g = *GImGui;
  927|  52.3k|    ImGuiWindow* window = g.CurrentWindow;
  928|  52.3k|    if (window->SkipItems)
  ------------------
  |  Branch (928:9): [True: 0, False: 52.3k]
  ------------------
  929|      0|        return false;
  930|       |
  931|  52.3k|    const float bb_frame_width = bb_frame.GetWidth();
  932|  52.3k|    const float bb_frame_height = bb_frame.GetHeight();
  933|  52.3k|    if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)
  ------------------
  |  Branch (933:9): [True: 42, False: 52.3k]
  |  Branch (933:35): [True: 21.7k, False: 30.5k]
  ------------------
  934|  21.7k|        return false;
  935|       |
  936|       |    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
  937|  30.5k|    float alpha = 1.0f;
  938|  30.5k|    if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
  ------------------
  |  Branch (938:9): [True: 4.63k, False: 25.9k]
  |  Branch (938:34): [True: 438, False: 4.19k]
  ------------------
  939|    438|        alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
  940|  30.5k|    if (alpha <= 0.0f)
  ------------------
  |  Branch (940:9): [True: 17, False: 30.5k]
  ------------------
  941|     17|        return false;
  942|       |
  943|  30.5k|    const ImGuiStyle& style = g.Style;
  944|  30.5k|    const bool allow_interaction = (alpha >= 1.0f);
  945|       |
  946|  30.5k|    ImRect bb = bb_frame;
  947|  30.5k|    bb.Expand(ImVec2(-ImClamp(IM_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  284|  30.5k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
                  bb.Expand(ImVec2(-ImClamp(IM_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  284|  30.5k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  948|       |
  949|       |    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
  950|  30.5k|    const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();
  ------------------
  |  Branch (950:36): [True: 25.9k, False: 4.62k]
  ------------------
  951|       |
  952|       |    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
  953|       |    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
  954|  30.5k|    IM_ASSERT(ImMax(size_contents_v, size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
  ------------------
  |  |   23|  30.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  955|  30.5k|    const ImS64 win_size_v = ImMax(ImMax(size_contents_v, size_avail_v), (ImS64)1);
  956|  30.5k|    const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_avail_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);
  957|  30.5k|    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;
  958|       |
  959|       |    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
  960|  30.5k|    bool held = false;
  961|  30.5k|    bool hovered = false;
  962|  30.5k|    ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);
  963|  30.5k|    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);
  964|       |
  965|  30.5k|    const ImS64 scroll_max = ImMax((ImS64)1, size_contents_v - size_avail_v);
  966|  30.5k|    float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
  967|  30.5k|    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
  968|  30.5k|    if (held && allow_interaction && grab_h_norm < 1.0f)
  ------------------
  |  Branch (968:9): [True: 0, False: 30.5k]
  |  Branch (968:17): [True: 0, False: 0]
  |  Branch (968:38): [True: 0, False: 0]
  ------------------
  969|      0|    {
  970|      0|        const float scrollbar_pos_v = bb.Min[axis];
  971|      0|        const float mouse_pos_v = g.IO.MousePos[axis];
  972|       |
  973|       |        // Click position in scrollbar normalized space (0.0f->1.0f)
  974|      0|        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
  975|      0|        SetHoveredID(id);
  976|       |
  977|      0|        bool seek_absolute = false;
  978|      0|        if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (978:13): [True: 0, False: 0]
  ------------------
  979|      0|        {
  980|       |            // On initial click calculate the distance between mouse and the center of the grab
  981|      0|            seek_absolute = (clicked_v_norm < grab_v_norm || clicked_v_norm > grab_v_norm + grab_h_norm);
  ------------------
  |  Branch (981:30): [True: 0, False: 0]
  |  Branch (981:62): [True: 0, False: 0]
  ------------------
  982|      0|            if (seek_absolute)
  ------------------
  |  Branch (982:17): [True: 0, False: 0]
  ------------------
  983|      0|                g.ScrollbarClickDeltaToGrabCenter = 0.0f;
  984|      0|            else
  985|      0|                g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
  986|      0|        }
  987|       |
  988|       |        // Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
  989|       |        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
  990|      0|        const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
  991|      0|        *p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);
  992|       |
  993|       |        // Update values for rendering
  994|      0|        scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
  995|      0|        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
  996|       |
  997|       |        // Update distance to grab now that we have seeked and saturated
  998|      0|        if (seek_absolute)
  ------------------
  |  Branch (998:13): [True: 0, False: 0]
  ------------------
  999|      0|            g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
 1000|      0|    }
 1001|       |
 1002|       |    // Render
 1003|  30.5k|    const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);
 1004|  30.5k|    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
  ------------------
  |  Branch (1004:40): [True: 0, False: 30.5k]
  |  Branch (1004:78): [True: 0, False: 30.5k]
  ------------------
 1005|  30.5k|    window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);
 1006|  30.5k|    ImRect grab_rect;
 1007|  30.5k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (1007:9): [True: 25.9k, False: 4.62k]
  ------------------
 1008|  25.9k|        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);
 1009|  4.62k|    else
 1010|  4.62k|        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
 1011|  30.5k|    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
 1012|       |
 1013|  30.5k|    return held;
 1014|  30.5k|}
_ZN5ImGui5DummyERK6ImVec2:
 1354|  25.9k|{
 1355|  25.9k|    ImGuiWindow* window = GetCurrentWindow();
 1356|  25.9k|    if (window->SkipItems)
  ------------------
  |  Branch (1356:9): [True: 13.2k, False: 12.7k]
  ------------------
 1357|  13.2k|        return;
 1358|       |
 1359|  12.7k|    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
 1360|  12.7k|    ItemSize(size);
 1361|  12.7k|    ItemAdd(bb, 0);
 1362|  12.7k|}
_ZN5ImGui11SeparatorExEif:
 1396|     17|{
 1397|     17|    ImGuiWindow* window = GetCurrentWindow();
 1398|     17|    if (window->SkipItems)
  ------------------
  |  Branch (1398:9): [True: 0, False: 17]
  ------------------
 1399|      0|        return;
 1400|       |
 1401|     17|    ImGuiContext& g = *GImGui;
 1402|     17|    IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected
  ------------------
  |  |   23|     17|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1403|     17|    IM_ASSERT(thickness > 0.0f);
  ------------------
  |  |   23|     17|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1404|       |
 1405|     17|    if (flags & ImGuiSeparatorFlags_Vertical)
  ------------------
  |  Branch (1405:9): [True: 0, False: 17]
  ------------------
 1406|      0|    {
 1407|       |        // Vertical separator, for menu bars (use current line height).
 1408|      0|        float y1 = window->DC.CursorPos.y;
 1409|      0|        float y2 = window->DC.CursorPos.y + window->DC.CurrLineSize.y;
 1410|      0|        const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + thickness, y2));
 1411|      0|        ItemSize(ImVec2(thickness, 0.0f));
 1412|      0|        if (!ItemAdd(bb, 0))
  ------------------
  |  Branch (1412:13): [True: 0, False: 0]
  ------------------
 1413|      0|            return;
 1414|       |
 1415|       |        // Draw
 1416|      0|        window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));
 1417|      0|        if (g.LogEnabled)
  ------------------
  |  Branch (1417:13): [True: 0, False: 0]
  ------------------
 1418|      0|            LogText(" |");
 1419|      0|    }
 1420|     17|    else if (flags & ImGuiSeparatorFlags_Horizontal)
  ------------------
  |  Branch (1420:14): [True: 17, False: 0]
  ------------------
 1421|     17|    {
 1422|       |        // Horizontal Separator
 1423|     17|        float x1 = window->DC.CursorPos.x;
 1424|     17|        float x2 = window->WorkRect.Max.x;
 1425|       |
 1426|       |        // Preserve legacy behavior inside Columns()
 1427|       |        // Before Tables API happened, we relied on Separator() to span all columns of a Columns() set.
 1428|       |        // We currently don't need to provide the same feature for tables because tables naturally have border features.
 1429|     17|        ImGuiOldColumns* columns = (flags & ImGuiSeparatorFlags_SpanAllColumns) ? window->DC.CurrentColumns : NULL;
  ------------------
  |  Branch (1429:36): [True: 0, False: 17]
  ------------------
 1430|     17|        if (columns)
  ------------------
  |  Branch (1430:13): [True: 0, False: 17]
  ------------------
 1431|      0|        {
 1432|      0|            x1 = window->Pos.x + window->DC.Indent.x; // Used to be Pos.x before 2023/10/03
 1433|      0|            x2 = window->Pos.x + window->Size.x;
 1434|      0|            PushColumnsBackground();
 1435|      0|        }
 1436|       |
 1437|       |        // We don't provide our width to the layout so that it doesn't get feed back into AutoFit
 1438|       |        // FIXME: This prevents ->CursorMaxPos based bounding box evaluation from working (e.g. TableEndCell)
 1439|     17|        const float thickness_for_layout = (thickness == 1.0f) ? 0.0f : thickness; // FIXME: See 1.70/1.71 Separator() change: makes legacy 1-px separator not affect layout yet. Should change.
  ------------------
  |  Branch (1439:44): [True: 17, False: 0]
  ------------------
 1440|     17|        const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + thickness));
 1441|     17|        ItemSize(ImVec2(0.0f, thickness_for_layout));
 1442|       |
 1443|     17|        if (ItemAdd(bb, 0))
  ------------------
  |  Branch (1443:13): [True: 7, False: 10]
  ------------------
 1444|      7|        {
 1445|       |            // Draw
 1446|      7|            window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Separator));
 1447|      7|            if (g.LogEnabled)
  ------------------
  |  Branch (1447:17): [True: 0, False: 7]
  ------------------
 1448|      0|                LogRenderedText(&bb.Min, "--------------------------------\n");
 1449|       |
 1450|      7|        }
 1451|     17|        if (columns)
  ------------------
  |  Branch (1451:13): [True: 0, False: 17]
  ------------------
 1452|      0|        {
 1453|      0|            PopColumnsBackground();
 1454|      0|            columns->LineMinY = window->DC.CursorPos.y;
 1455|      0|        }
 1456|     17|    }
 1457|     17|}
_ZN5ImGui9SeparatorEv:
 1460|     17|{
 1461|     17|    ImGuiContext& g = *GImGui;
 1462|     17|    ImGuiWindow* window = g.CurrentWindow;
 1463|     17|    if (window->SkipItems)
  ------------------
  |  Branch (1463:9): [True: 0, False: 17]
  ------------------
 1464|      0|        return;
 1465|       |
 1466|       |    // Those flags should eventually be configurable by the user
 1467|       |    // FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
 1468|     17|    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
  ------------------
  |  Branch (1468:33): [True: 0, False: 17]
  ------------------
 1469|       |
 1470|       |    // Only applies to legacy Columns() api as they relied on Separator() a lot.
 1471|     17|    if (window->DC.CurrentColumns)
  ------------------
  |  Branch (1471:9): [True: 0, False: 17]
  ------------------
 1472|      0|        flags |= ImGuiSeparatorFlags_SpanAllColumns;
 1473|       |
 1474|     17|    SeparatorEx(flags, 1.0f);
 1475|     17|}
_ZN16ImGuiMenuColumns6UpdateEfb:
 7191|  84.6k|{
 7192|  84.6k|    if (window_reappearing)
  ------------------
  |  Branch (7192:9): [True: 15, False: 84.6k]
  ------------------
 7193|     15|        memset(Widths, 0, sizeof(Widths));
 7194|  84.6k|    Spacing = (ImU16)spacing;
 7195|  84.6k|    CalcNextTotalWidth(true);
 7196|  84.6k|    memset(Widths, 0, sizeof(Widths));
 7197|  84.6k|    TotalWidth = NextTotalWidth;
 7198|  84.6k|    NextTotalWidth = 0;
 7199|  84.6k|}
_ZN16ImGuiMenuColumns18CalcNextTotalWidthEb:
 7202|  84.6k|{
 7203|  84.6k|    ImU16 offset = 0;
 7204|  84.6k|    bool want_spacing = false;
 7205|   423k|    for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)
  ------------------
  |  |   88|   423k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (7205:21): [True: 338k, False: 84.6k]
  ------------------
 7206|   338k|    {
 7207|   338k|        ImU16 width = Widths[i];
 7208|   338k|        if (want_spacing && width > 0)
  ------------------
  |  Branch (7208:13): [True: 0, False: 338k]
  |  Branch (7208:29): [True: 0, False: 0]
  ------------------
 7209|      0|            offset += Spacing;
 7210|   338k|        want_spacing |= (width > 0);
 7211|   338k|        if (update_offsets)
  ------------------
  |  Branch (7211:13): [True: 338k, False: 0]
  ------------------
 7212|   338k|        {
 7213|   338k|            if (i == 1) { OffsetLabel = offset; }
  ------------------
  |  Branch (7213:17): [True: 84.6k, False: 254k]
  ------------------
 7214|   338k|            if (i == 2) { OffsetShortcut = offset; }
  ------------------
  |  Branch (7214:17): [True: 84.6k, False: 254k]
  ------------------
 7215|   338k|            if (i == 3) { OffsetMark = offset; }
  ------------------
  |  Branch (7215:17): [True: 84.6k, False: 254k]
  ------------------
 7216|   338k|        }
 7217|   338k|        offset += width;
 7218|   338k|    }
 7219|  84.6k|    NextTotalWidth = offset;
 7220|  84.6k|}

imgui_draw.cpp:_ZL17stbrp_init_targetP13stbrp_contextiiP10stbrp_nodei:
  266|      1|{
  267|      1|   int i;
  268|       |
  269|    511|   for (i=0; i < num_nodes-1; ++i)
  ------------------
  |  Branch (269:14): [True: 510, False: 1]
  ------------------
  270|    510|      nodes[i].next = &nodes[i+1];
  271|      1|   nodes[i].next = NULL;
  272|      1|   context->init_mode = STBRP__INIT_skyline;
  273|      1|   context->heuristic = STBRP_HEURISTIC_Skyline_default;
  274|      1|   context->free_head = &nodes[0];
  275|      1|   context->active_head = &context->extra[0];
  276|      1|   context->width = width;
  277|      1|   context->height = height;
  278|      1|   context->num_nodes = num_nodes;
  279|      1|   stbrp_setup_allow_out_of_mem(context, 0);
  280|       |
  281|       |   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
  282|      1|   context->extra[0].x = 0;
  283|      1|   context->extra[0].y = 0;
  284|      1|   context->extra[0].next = &context->extra[1];
  285|      1|   context->extra[1].x = (stbrp_coord) width;
  286|      1|   context->extra[1].y = (1<<30);
  287|      1|   context->extra[1].next = NULL;
  288|      1|}
imgui_draw.cpp:_ZL28stbrp_setup_allow_out_of_memP13stbrp_contexti:
  246|      1|{
  247|      1|   if (allow_out_of_mem)
  ------------------
  |  Branch (247:8): [True: 0, False: 1]
  ------------------
  248|       |      // if it's ok to run out of memory, then don't bother aligning them;
  249|       |      // this gives better packing, but may fail due to OOM (even though
  250|       |      // the rectangles easily fit). @TODO a smarter approach would be to only
  251|       |      // quantize once we've hit OOM, then we could get rid of this parameter.
  252|      0|      context->align = 1;
  253|      1|   else {
  254|       |      // if it's not ok to run out of memory, then quantize the widths
  255|       |      // so that num_nodes is always enough nodes.
  256|       |      //
  257|       |      // I.e. num_nodes * align >= width
  258|       |      //                  align >= width / num_nodes
  259|       |      //                  align = ceil(width/num_nodes)
  260|       |
  261|      1|      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
  262|      1|   }
  263|      1|}
imgui_draw.cpp:_ZL16stbrp_pack_rectsP13stbrp_contextP10stbrp_recti:
  547|      2|{
  548|      2|   int i, all_rects_packed = 1;
  549|       |
  550|       |   // we use the 'was_packed' field internally to allow sorting/unsorting
  551|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (551:14): [True: 225, False: 2]
  ------------------
  552|    225|      rects[i].was_packed = i;
  553|    225|   }
  554|       |
  555|       |   // sort according to heuristic
  556|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);
  ------------------
  |  |  118|      2|#define STBRP_SORT          ImQsort
  ------------------
  557|       |
  558|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (558:14): [True: 225, False: 2]
  ------------------
  559|    225|      if (rects[i].w == 0 || rects[i].h == 0) {
  ------------------
  |  Branch (559:11): [True: 0, False: 225]
  |  Branch (559:30): [True: 0, False: 225]
  ------------------
  560|      0|         rects[i].x = rects[i].y = 0;  // empty rect needs no space
  561|    225|      } else {
  562|    225|         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
  563|    225|         if (fr.prev_link) {
  ------------------
  |  Branch (563:14): [True: 225, False: 0]
  ------------------
  564|    225|            rects[i].x = (stbrp_coord) fr.x;
  565|    225|            rects[i].y = (stbrp_coord) fr.y;
  566|    225|         } else {
  567|      0|            rects[i].x = rects[i].y = STBRP__MAXVAL;
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  568|      0|         }
  569|    225|      }
  570|    225|   }
  571|       |
  572|       |   // unsort
  573|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);
  ------------------
  |  |  118|      2|#define STBRP_SORT          ImQsort
  ------------------
  574|       |
  575|       |   // set was_packed flags and all_rects_packed status
  576|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (576:14): [True: 225, False: 2]
  ------------------
  577|    225|      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|    450|#define STBRP__MAXVAL  0x7fffffff
  ------------------
                    rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  |  Branch (577:31): [True: 0, False: 225]
  |  Branch (577:62): [True: 0, False: 0]
  ------------------
  578|    225|      if (!rects[i].was_packed)
  ------------------
  |  Branch (578:11): [True: 0, False: 225]
  ------------------
  579|      0|         all_rects_packed = 0;
  580|    225|   }
  581|       |
  582|       |   // return the all_rects_packed status
  583|      2|   return all_rects_packed;
  584|      2|}
imgui_draw.cpp:_ZL19rect_height_comparePKvS0_:
  529|  1.40k|{
  530|  1.40k|   const stbrp_rect *p = (const stbrp_rect *) a;
  531|  1.40k|   const stbrp_rect *q = (const stbrp_rect *) b;
  532|  1.40k|   if (p->h > q->h)
  ------------------
  |  Branch (532:8): [True: 224, False: 1.17k]
  ------------------
  533|    224|      return -1;
  534|  1.17k|   if (p->h < q->h)
  ------------------
  |  Branch (534:8): [True: 383, False: 795]
  ------------------
  535|    383|      return  1;
  536|    795|   return (p->w > q->w) ? -1 : (p->w < q->w);
  ------------------
  |  Branch (536:11): [True: 97, False: 698]
  ------------------
  537|  1.17k|}
imgui_draw.cpp:_ZL29stbrp__skyline_pack_rectangleP13stbrp_contextii:
  450|    225|{
  451|       |   // find best position according to heuristic
  452|    225|   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
  453|    225|   stbrp_node *node, *cur;
  454|       |
  455|       |   // bail if:
  456|       |   //    1. it failed
  457|       |   //    2. the best node doesn't fit (we don't always check this)
  458|       |   //    3. we're out of memory
  459|    225|   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
  ------------------
  |  Branch (459:8): [True: 0, False: 225]
  |  Branch (459:33): [True: 0, False: 225]
  |  Branch (459:69): [True: 0, False: 225]
  ------------------
  460|      0|      res.prev_link = NULL;
  461|      0|      return res;
  462|      0|   }
  463|       |
  464|       |   // on success, create new node
  465|    225|   node = context->free_head;
  466|    225|   node->x = (stbrp_coord) res.x;
  467|    225|   node->y = (stbrp_coord) (res.y + height);
  468|       |
  469|    225|   context->free_head = node->next;
  470|       |
  471|       |   // insert the new node into the right starting point, and
  472|       |   // let 'cur' point to the remaining nodes needing to be
  473|       |   // stiched back in
  474|       |
  475|    225|   cur = *res.prev_link;
  476|    225|   if (cur->x < res.x) {
  ------------------
  |  Branch (476:8): [True: 0, False: 225]
  ------------------
  477|       |      // preserve the existing one, so start testing with the next one
  478|      0|      stbrp_node *next = cur->next;
  479|      0|      cur->next = node;
  480|      0|      cur = next;
  481|    225|   } else {
  482|    225|      *res.prev_link = node;
  483|    225|   }
  484|       |
  485|       |   // from here, traverse cur and free the nodes, until we get to one
  486|       |   // that shouldn't be freed
  487|    361|   while (cur->next && cur->next->x <= res.x + width) {
  ------------------
  |  Branch (487:11): [True: 358, False: 3]
  |  Branch (487:24): [True: 136, False: 222]
  ------------------
  488|    136|      stbrp_node *next = cur->next;
  489|       |      // move the current node to the free list
  490|    136|      cur->next = context->free_head;
  491|    136|      context->free_head = cur;
  492|    136|      cur = next;
  493|    136|   }
  494|       |
  495|       |   // stitch the list back in
  496|    225|   node->next = cur;
  497|       |
  498|    225|   if (cur->x < res.x + width)
  ------------------
  |  Branch (498:8): [True: 177, False: 48]
  ------------------
  499|    177|      cur->x = (stbrp_coord) (res.x + width);
  500|       |
  501|       |#ifdef _DEBUG
  502|       |   cur = context->active_head;
  503|       |   while (cur->x < context->width) {
  504|       |      STBRP_ASSERT(cur->x < cur->next->x);
  505|       |      cur = cur->next;
  506|       |   }
  507|       |   STBRP_ASSERT(cur->next == NULL);
  508|       |
  509|       |   {
  510|       |      int count=0;
  511|       |      cur = context->active_head;
  512|       |      while (cur) {
  513|       |         cur = cur->next;
  514|       |         ++count;
  515|       |      }
  516|       |      cur = context->free_head;
  517|       |      while (cur) {
  518|       |         cur = cur->next;
  519|       |         ++count;
  520|       |      }
  521|       |      STBRP_ASSERT(count == context->num_nodes+2);
  522|       |   }
  523|       |#endif
  524|       |
  525|    225|   return res;
  526|    225|}
imgui_draw.cpp:_ZL28stbrp__skyline_find_best_posP13stbrp_contextii:
  348|    225|{
  349|    225|   int best_waste = (1<<30), best_x, best_y = (1 << 30);
  350|    225|   stbrp__findresult fr;
  351|    225|   stbrp_node **prev, *node, *tail, **best = NULL;
  352|       |
  353|       |   // align to multiple of c->align
  354|    225|   width = (width + c->align - 1);
  355|    225|   width -= width % c->align;
  356|    225|   STBRP_ASSERT(width % c->align == 0);
  ------------------
  |  |  117|    225|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  357|       |
  358|       |   // if it can't possibly fit, bail immediately
  359|    225|   if (width > c->width || height > c->height) {
  ------------------
  |  Branch (359:8): [True: 0, False: 225]
  |  Branch (359:28): [True: 0, False: 225]
  ------------------
  360|      0|      fr.prev_link = NULL;
  361|      0|      fr.x = fr.y = 0;
  362|      0|      return fr;
  363|      0|   }
  364|       |
  365|    225|   node = c->active_head;
  366|    225|   prev = &c->active_head;
  367|  11.9k|   while (node->x + width <= c->width) {
  ------------------
  |  Branch (367:11): [True: 11.7k, False: 225]
  ------------------
  368|  11.7k|      int y,waste;
  369|  11.7k|      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
  370|  11.7k|      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
  ------------------
  |  Branch (370:11): [True: 11.7k, False: 0]
  ------------------
  371|       |         // bottom left
  372|  11.7k|         if (y < best_y) {
  ------------------
  |  Branch (372:14): [True: 1.03k, False: 10.7k]
  ------------------
  373|  1.03k|            best_y = y;
  374|  1.03k|            best = prev;
  375|  1.03k|         }
  376|  11.7k|      } else {
  377|       |         // best-fit
  378|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (378:14): [True: 0, False: 0]
  ------------------
  379|       |            // can only use it if it first vertically
  380|      0|            if (y < best_y || (y == best_y && waste < best_waste)) {
  ------------------
  |  Branch (380:17): [True: 0, False: 0]
  |  Branch (380:32): [True: 0, False: 0]
  |  Branch (380:47): [True: 0, False: 0]
  ------------------
  381|      0|               best_y = y;
  382|      0|               best_waste = waste;
  383|      0|               best = prev;
  384|      0|            }
  385|      0|         }
  386|      0|      }
  387|  11.7k|      prev = &node->next;
  388|  11.7k|      node = node->next;
  389|  11.7k|   }
  390|       |
  391|    225|   best_x = (best == NULL) ? 0 : (*best)->x;
  ------------------
  |  Branch (391:13): [True: 0, False: 225]
  ------------------
  392|       |
  393|       |   // if doing best-fit (BF), we also have to try aligning right edge to each node position
  394|       |   //
  395|       |   // e.g, if fitting
  396|       |   //
  397|       |   //     ____________________
  398|       |   //    |____________________|
  399|       |   //
  400|       |   //            into
  401|       |   //
  402|       |   //   |                         |
  403|       |   //   |             ____________|
  404|       |   //   |____________|
  405|       |   //
  406|       |   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
  407|       |   //
  408|       |   // This makes BF take about 2x the time
  409|       |
  410|    225|   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
  ------------------
  |  Branch (410:8): [True: 0, False: 225]
  ------------------
  411|      0|      tail = c->active_head;
  412|      0|      node = c->active_head;
  413|      0|      prev = &c->active_head;
  414|       |      // find first node that's admissible
  415|      0|      while (tail->x < width)
  ------------------
  |  Branch (415:14): [True: 0, False: 0]
  ------------------
  416|      0|         tail = tail->next;
  417|      0|      while (tail) {
  ------------------
  |  Branch (417:14): [True: 0, False: 0]
  ------------------
  418|      0|         int xpos = tail->x - width;
  419|      0|         int y,waste;
  420|      0|         STBRP_ASSERT(xpos >= 0);
  ------------------
  |  |  117|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  421|       |         // find the left position that matches this
  422|      0|         while (node->next->x <= xpos) {
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|            prev = &node->next;
  424|      0|            node = node->next;
  425|      0|         }
  426|      0|         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
  ------------------
  |  |  117|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  427|      0|         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
  428|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (428:14): [True: 0, False: 0]
  ------------------
  429|      0|            if (y <= best_y) {
  ------------------
  |  Branch (429:17): [True: 0, False: 0]
  ------------------
  430|      0|               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
  ------------------
  |  Branch (430:20): [True: 0, False: 0]
  |  Branch (430:34): [True: 0, False: 0]
  |  Branch (430:57): [True: 0, False: 0]
  |  Branch (430:78): [True: 0, False: 0]
  ------------------
  431|      0|                  best_x = xpos;
  432|       |                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
  433|      0|                  best_y = y;
  434|      0|                  best_waste = waste;
  435|      0|                  best = prev;
  436|      0|               }
  437|      0|            }
  438|      0|         }
  439|      0|         tail = tail->next;
  440|      0|      }
  441|      0|   }
  442|       |
  443|    225|   fr.prev_link = best;
  444|    225|   fr.x = best_x;
  445|    225|   fr.y = best_y;
  446|    225|   return fr;
  447|    225|}
imgui_draw.cpp:_ZL25stbrp__skyline_find_min_yP13stbrp_contextP10stbrp_nodeiiPi:
  292|  11.7k|{
  293|  11.7k|   stbrp_node *node = first;
  294|  11.7k|   int x1 = x0 + width;
  295|  11.7k|   int min_y, visited_width, waste_area;
  296|       |
  297|  11.7k|   STBRP__NOTUSED(c);
  ------------------
  |  |  224|  11.7k|#define STBRP__NOTUSED(v)  (void)sizeof(v)
  ------------------
  298|       |
  299|  11.7k|   STBRP_ASSERT(first->x <= x0);
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  300|       |
  301|       |   #if 0
  302|       |   // skip in case we're past the node
  303|       |   while (node->next->x <= x0)
  304|       |      ++node;
  305|       |   #else
  306|  11.7k|   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  307|  11.7k|   #endif
  308|       |
  309|  11.7k|   STBRP_ASSERT(node->x <= x0);
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  310|       |
  311|  11.7k|   min_y = 0;
  312|  11.7k|   waste_area = 0;
  313|  11.7k|   visited_width = 0;
  314|  26.9k|   while (node->x < x1) {
  ------------------
  |  Branch (314:11): [True: 15.1k, False: 11.7k]
  ------------------
  315|  15.1k|      if (node->y > min_y) {
  ------------------
  |  Branch (315:11): [True: 11.9k, False: 3.19k]
  ------------------
  316|       |         // raise min_y higher.
  317|       |         // we've accounted for all waste up to min_y,
  318|       |         // but we'll now add more waste for everything we've visted
  319|  11.9k|         waste_area += visited_width * (node->y - min_y);
  320|  11.9k|         min_y = node->y;
  321|       |         // the first time through, visited_width might be reduced
  322|  11.9k|         if (node->x < x0)
  ------------------
  |  Branch (322:14): [True: 0, False: 11.9k]
  ------------------
  323|      0|            visited_width += node->next->x - x0;
  324|  11.9k|         else
  325|  11.9k|            visited_width += node->next->x - node->x;
  326|  11.9k|      } else {
  327|       |         // add waste area
  328|  3.19k|         int under_width = node->next->x - node->x;
  329|  3.19k|         if (under_width + visited_width > width)
  ------------------
  |  Branch (329:14): [True: 2.55k, False: 636]
  ------------------
  330|  2.55k|            under_width = width - visited_width;
  331|  3.19k|         waste_area += under_width * (min_y - node->y);
  332|  3.19k|         visited_width += under_width;
  333|  3.19k|      }
  334|  15.1k|      node = node->next;
  335|  15.1k|   }
  336|       |
  337|  11.7k|   *pwaste = waste_area;
  338|  11.7k|   return min_y;
  339|  11.7k|}
imgui_draw.cpp:_ZL19rect_original_orderPKvS0_:
  540|  1.33k|{
  541|  1.33k|   const stbrp_rect *p = (const stbrp_rect *) a;
  542|  1.33k|   const stbrp_rect *q = (const stbrp_rect *) b;
  543|  1.33k|   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
  ------------------
  |  Branch (543:11): [True: 722, False: 616]
  ------------------
  544|  1.33k|}

imgui_draw.cpp:_ZL27stbtt_GetFontOffsetForIndexPKhi:
 4951|      1|{
 4952|      1|   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
 4953|      1|}
imgui_draw.cpp:_ZL36stbtt_GetFontOffsetForIndex_internalPhi:
 1325|      1|{
 1326|       |   // if it's just a font, there's only one valid index
 1327|      1|   if (stbtt__isfont(font_collection))
  ------------------
  |  Branch (1327:8): [True: 1, False: 0]
  ------------------
 1328|      1|      return index == 0 ? 0 : -1;
  ------------------
  |  Branch (1328:14): [True: 1, False: 0]
  ------------------
 1329|       |
 1330|       |   // check if it's a TTC
 1331|      0|   if (stbtt_tag(font_collection, "ttcf")) {
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1332|       |      // version 1?
 1333|      0|      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
  ------------------
  |  Branch (1333:11): [True: 0, False: 0]
  |  Branch (1333:55): [True: 0, False: 0]
  ------------------
 1334|      0|         stbtt_int32 n = ttLONG(font_collection+8);
 1335|      0|         if (index >= n)
  ------------------
  |  Branch (1335:14): [True: 0, False: 0]
  ------------------
 1336|      0|            return -1;
 1337|      0|         return ttULONG(font_collection+12+index*4);
 1338|      0|      }
 1339|      0|   }
 1340|      0|   return -1;
 1341|      0|}
imgui_draw.cpp:_ZL13stbtt__isfontPh:
 1300|      1|{
 1301|       |   // check the version number
 1302|      1|   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1303|      1|   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1304|      1|   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1305|      1|   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 1, False: 0]
  |  |  |  Branch (1296:54): [True: 1, False: 0]
  |  |  |  Branch (1296:72): [True: 1, False: 0]
  |  |  |  Branch (1296:90): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 1306|      0|   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1307|      0|   return 0;
 1308|      0|}
imgui_draw.cpp:_ZL7ttULONGPh:
 1293|      9|static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
imgui_draw.cpp:_ZL14stbtt_InitFontP14stbtt_fontinfoPKhi:
 4961|      1|{
 4962|      1|   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
 4963|      1|}
imgui_draw.cpp:_ZL23stbtt_InitFont_internalP14stbtt_fontinfoPhi:
 1389|      1|{
 1390|      1|   stbtt_uint32 cmap, t;
 1391|      1|   stbtt_int32 i,numTables;
 1392|       |
 1393|      1|   info->data = data;
 1394|      1|   info->fontstart = fontstart;
 1395|      1|   info->cff = stbtt__new_buf(NULL, 0);
 1396|       |
 1397|      1|   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
 1398|      1|   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
 1399|      1|   info->head = stbtt__find_table(data, fontstart, "head"); // required
 1400|      1|   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
 1401|      1|   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
 1402|      1|   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
 1403|      1|   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
 1404|      1|   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required
 1405|       |
 1406|      1|   if (!cmap || !info->head || !info->hhea || !info->hmtx)
  ------------------
  |  Branch (1406:8): [True: 0, False: 1]
  |  Branch (1406:17): [True: 0, False: 1]
  |  Branch (1406:32): [True: 0, False: 1]
  |  Branch (1406:47): [True: 0, False: 1]
  ------------------
 1407|      0|      return 0;
 1408|      1|   if (info->glyf) {
  ------------------
  |  Branch (1408:8): [True: 1, False: 0]
  ------------------
 1409|       |      // required for truetype
 1410|      1|      if (!info->loca) return 0;
  ------------------
  |  Branch (1410:11): [True: 0, False: 1]
  ------------------
 1411|      1|   } else {
 1412|       |      // initialization for CFF / Type2 fonts (OTF)
 1413|      0|      stbtt__buf b, topdict, topdictidx;
 1414|      0|      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
 1415|      0|      stbtt_uint32 cff;
 1416|       |
 1417|      0|      cff = stbtt__find_table(data, fontstart, "CFF ");
 1418|      0|      if (!cff) return 0;
  ------------------
  |  Branch (1418:11): [True: 0, False: 0]
  ------------------
 1419|       |
 1420|      0|      info->fontdicts = stbtt__new_buf(NULL, 0);
 1421|      0|      info->fdselect = stbtt__new_buf(NULL, 0);
 1422|       |
 1423|       |      // @TODO this should use size from table (not 512MB)
 1424|      0|      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
 1425|      0|      b = info->cff;
 1426|       |
 1427|       |      // read the header
 1428|      0|      stbtt__buf_skip(&b, 2);
 1429|      0|      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize
 1430|       |
 1431|       |      // @TODO the name INDEX could list multiple fonts,
 1432|       |      // but we just use the first one.
 1433|      0|      stbtt__cff_get_index(&b);  // name INDEX
 1434|      0|      topdictidx = stbtt__cff_get_index(&b);
 1435|      0|      topdict = stbtt__cff_index_get(topdictidx, 0);
 1436|      0|      stbtt__cff_get_index(&b);  // string INDEX
 1437|      0|      info->gsubrs = stbtt__cff_get_index(&b);
 1438|       |
 1439|      0|      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
 1440|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
 1441|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
 1442|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
 1443|      0|      info->subrs = stbtt__get_subrs(b, topdict);
 1444|       |
 1445|       |      // we only support Type 2 charstrings
 1446|      0|      if (cstype != 2) return 0;
  ------------------
  |  Branch (1446:11): [True: 0, False: 0]
  ------------------
 1447|      0|      if (charstrings == 0) return 0;
  ------------------
  |  Branch (1447:11): [True: 0, False: 0]
  ------------------
 1448|       |
 1449|      0|      if (fdarrayoff) {
  ------------------
  |  Branch (1449:11): [True: 0, False: 0]
  ------------------
 1450|       |         // looks like a CID font
 1451|      0|         if (!fdselectoff) return 0;
  ------------------
  |  Branch (1451:14): [True: 0, False: 0]
  ------------------
 1452|      0|         stbtt__buf_seek(&b, fdarrayoff);
 1453|      0|         info->fontdicts = stbtt__cff_get_index(&b);
 1454|      0|         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
 1455|      0|      }
 1456|       |
 1457|      0|      stbtt__buf_seek(&b, charstrings);
 1458|      0|      info->charstrings = stbtt__cff_get_index(&b);
 1459|      0|   }
 1460|       |
 1461|      1|   t = stbtt__find_table(data, fontstart, "maxp");
 1462|      1|   if (t)
  ------------------
  |  Branch (1462:8): [True: 1, False: 0]
  ------------------
 1463|      1|      info->numGlyphs = ttUSHORT(data+t+4);
 1464|      0|   else
 1465|      0|      info->numGlyphs = 0xffff;
 1466|       |
 1467|      1|   info->svg = -1;
 1468|       |
 1469|       |   // find a cmap encoding table we understand *now* to avoid searching
 1470|       |   // later. (todo: could make this installable)
 1471|       |   // the same regardless of glyph.
 1472|      1|   numTables = ttUSHORT(data + cmap + 2);
 1473|      1|   info->index_map = 0;
 1474|      4|   for (i=0; i < numTables; ++i) {
  ------------------
  |  Branch (1474:14): [True: 3, False: 1]
  ------------------
 1475|      3|      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
 1476|       |      // find an encoding we understand:
 1477|      3|      switch(ttUSHORT(data+encoding_record)) {
  ------------------
  |  Branch (1477:14): [True: 1, False: 2]
  ------------------
 1478|      1|         case STBTT_PLATFORM_ID_MICROSOFT:
  ------------------
  |  Branch (1478:10): [True: 1, False: 2]
  ------------------
 1479|      1|            switch (ttUSHORT(data+encoding_record+2)) {
  ------------------
  |  Branch (1479:21): [True: 0, False: 1]
  ------------------
 1480|      1|               case STBTT_MS_EID_UNICODE_BMP:
  ------------------
  |  Branch (1480:16): [True: 1, False: 0]
  ------------------
 1481|      1|               case STBTT_MS_EID_UNICODE_FULL:
  ------------------
  |  Branch (1481:16): [True: 0, False: 1]
  ------------------
 1482|       |                  // MS/Unicode
 1483|      1|                  info->index_map = cmap + ttULONG(data+encoding_record+4);
 1484|      1|                  break;
 1485|      1|            }
 1486|      1|            break;
 1487|      1|        case STBTT_PLATFORM_ID_UNICODE:
  ------------------
  |  Branch (1487:9): [True: 1, False: 2]
  ------------------
 1488|       |            // Mac/iOS has these
 1489|       |            // all the encodingIDs are unicode, so we don't bother to check it
 1490|      1|            info->index_map = cmap + ttULONG(data+encoding_record+4);
 1491|      1|            break;
 1492|      3|      }
 1493|      3|   }
 1494|      1|   if (info->index_map == 0)
  ------------------
  |  Branch (1494:8): [True: 0, False: 1]
  ------------------
 1495|      0|      return 0;
 1496|       |
 1497|      1|   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
 1498|      1|   return 1;
 1499|      1|}
imgui_draw.cpp:_ZL14stbtt__new_bufPKvm:
 1174|      1|{
 1175|      1|   stbtt__buf r;
 1176|      1|   STBTT_assert(size < 0x40000000);
  ------------------
  |  |  133|      1|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1177|      1|   r.data = (stbtt_uint8*) p;
 1178|      1|   r.size = (int) size;
 1179|      1|   r.cursor = 0;
 1180|      1|   return r;
 1181|      1|}
imgui_draw.cpp:_ZL17stbtt__find_tablePhjPKc:
 1312|      9|{
 1313|      9|   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
 1314|      9|   stbtt_uint32 tabledir = fontstart + 12;
 1315|      9|   stbtt_int32 i;
 1316|     67|   for (i=0; i < num_tables; ++i) {
  ------------------
  |  Branch (1316:14): [True: 65, False: 2]
  ------------------
 1317|     65|      stbtt_uint32 loc = tabledir + 16*i;
 1318|     65|      if (stbtt_tag(data+loc+0, tag))
  ------------------
  |  | 1297|     65|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|     65|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 10, False: 55]
  |  |  |  |  |  Branch (1296:54): [True: 7, False: 3]
  |  |  |  |  |  Branch (1296:72): [True: 7, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 7, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1319|      7|         return ttULONG(data+loc+8);
 1320|     65|   }
 1321|      2|   return 0;
 1322|      9|}
imgui_draw.cpp:_ZL8ttUSHORTPh:
 1291|  12.9k|static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi:
 1502|    670|{
 1503|    670|   stbtt_uint8 *data = info->data;
 1504|    670|   stbtt_uint32 index_map = info->index_map;
 1505|       |
 1506|    670|   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
 1507|    670|   if (format == 0) { // apple byte encoding
  ------------------
  |  Branch (1507:8): [True: 0, False: 670]
  ------------------
 1508|      0|      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
 1509|      0|      if (unicode_codepoint < bytes-6)
  ------------------
  |  Branch (1509:11): [True: 0, False: 0]
  ------------------
 1510|      0|         return ttBYTE(data + index_map + 6 + unicode_codepoint);
  ------------------
  |  | 1287|      0|#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
  ------------------
 1511|      0|      return 0;
 1512|    670|   } else if (format == 6) {
  ------------------
  |  Branch (1512:15): [True: 0, False: 670]
  ------------------
 1513|      0|      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
 1514|      0|      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
 1515|      0|      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
  ------------------
  |  Branch (1515:11): [True: 0, False: 0]
  |  Branch (1515:56): [True: 0, False: 0]
  ------------------
 1516|      0|         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
 1517|      0|      return 0;
 1518|    670|   } else if (format == 2) {
  ------------------
  |  Branch (1518:15): [True: 0, False: 670]
  ------------------
 1519|      0|      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1520|      0|      return 0;
 1521|    670|   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
  ------------------
  |  Branch (1521:15): [True: 670, False: 0]
  ------------------
 1522|    670|      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
 1523|    670|      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
 1524|    670|      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
 1525|    670|      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;
 1526|       |
 1527|       |      // do a binary search of the segments
 1528|    670|      stbtt_uint32 endCount = index_map + 14;
 1529|    670|      stbtt_uint32 search = endCount;
 1530|       |
 1531|    670|      if (unicode_codepoint > 0xffff)
  ------------------
  |  Branch (1531:11): [True: 0, False: 670]
  ------------------
 1532|      0|         return 0;
 1533|       |
 1534|       |      // they lie from endCount .. endCount + segCount
 1535|       |      // but searchRange is the nearest power of two, so...
 1536|    670|      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
  ------------------
  |  Branch (1536:11): [True: 385, False: 285]
  ------------------
 1537|    385|         search += rangeShift*2;
 1538|       |
 1539|       |      // now decrement to bias correctly to find smallest
 1540|    670|      search -= 2;
 1541|  2.01k|      while (entrySelector) {
  ------------------
  |  Branch (1541:14): [True: 1.34k, False: 670]
  ------------------
 1542|  1.34k|         stbtt_uint16 end;
 1543|  1.34k|         searchRange >>= 1;
 1544|  1.34k|         end = ttUSHORT(data + search + searchRange*2);
 1545|  1.34k|         if (unicode_codepoint > end)
  ------------------
  |  Branch (1545:14): [True: 382, False: 958]
  ------------------
 1546|    382|            search += searchRange*2;
 1547|  1.34k|         --entrySelector;
 1548|  1.34k|      }
 1549|    670|      search += 2;
 1550|       |
 1551|    670|      {
 1552|    670|         stbtt_uint16 offset, start, last;
 1553|    670|         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
 1554|       |
 1555|    670|         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
 1556|    670|         last = ttUSHORT(data + endCount + 2*item);
 1557|    670|         if (unicode_codepoint < start || unicode_codepoint > last)
  ------------------
  |  Branch (1557:14): [True: 1, False: 669]
  |  Branch (1557:43): [True: 0, False: 669]
  ------------------
 1558|      1|            return 0;
 1559|       |
 1560|    669|         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
 1561|    669|         if (offset == 0)
  ------------------
  |  Branch (1561:14): [True: 669, False: 0]
  ------------------
 1562|    669|            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));
 1563|       |
 1564|      0|         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
 1565|    669|      }
 1566|    669|   } else if (format == 12 || format == 13) {
  ------------------
  |  Branch (1566:15): [True: 0, False: 0]
  |  Branch (1566:31): [True: 0, False: 0]
  ------------------
 1567|      0|      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
 1568|      0|      stbtt_int32 low,high;
 1569|      0|      low = 0; high = (stbtt_int32)ngroups;
 1570|       |      // Binary search the right group.
 1571|      0|      while (low < high) {
  ------------------
  |  Branch (1571:14): [True: 0, False: 0]
  ------------------
 1572|      0|         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
 1573|      0|         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
 1574|      0|         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
 1575|      0|         if ((stbtt_uint32) unicode_codepoint < start_char)
  ------------------
  |  Branch (1575:14): [True: 0, False: 0]
  ------------------
 1576|      0|            high = mid;
 1577|      0|         else if ((stbtt_uint32) unicode_codepoint > end_char)
  ------------------
  |  Branch (1577:19): [True: 0, False: 0]
  ------------------
 1578|      0|            low = mid+1;
 1579|      0|         else {
 1580|      0|            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
 1581|      0|            if (format == 12)
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|               return start_glyph + unicode_codepoint-start_char;
 1583|      0|            else // format == 13
 1584|      0|               return start_glyph;
 1585|      0|         }
 1586|      0|      }
 1587|      0|      return 0; // not found
 1588|      0|   }
 1589|       |   // @TODO
 1590|      0|   STBTT_assert(0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1591|      0|   return 0;
 1592|    670|}
imgui_draw.cpp:_ZL7ttSHORTPh:
 1292|  3.90k|static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof:
 2666|      3|{
 2667|      3|   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
 2668|      3|   return (float) height / fheight;
 2669|      3|}
imgui_draw.cpp:_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_:
 2727|    669|{
 2728|    669|   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
 2729|    669|   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
  ------------------
  |  Branch (2729:8): [True: 27, False: 642]
  ------------------
 2730|       |      // e.g. space character
 2731|     27|      if (ix0) *ix0 = 0;
  ------------------
  |  Branch (2731:11): [True: 27, False: 0]
  ------------------
 2732|     27|      if (iy0) *iy0 = 0;
  ------------------
  |  Branch (2732:11): [True: 27, False: 0]
  ------------------
 2733|     27|      if (ix1) *ix1 = 0;
  ------------------
  |  Branch (2733:11): [True: 18, False: 9]
  ------------------
 2734|     27|      if (iy1) *iy1 = 0;
  ------------------
  |  Branch (2734:11): [True: 18, False: 9]
  ------------------
 2735|    642|   } else {
 2736|       |      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
 2737|    642|      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
  ------------------
  |  |  138|    642|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
  |  Branch (2737:11): [True: 642, False: 0]
  ------------------
 2738|    642|      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
  ------------------
  |  |  138|    642|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
  |  Branch (2738:11): [True: 642, False: 0]
  ------------------
 2739|    642|      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
  ------------------
  |  |  139|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  454|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2739:11): [True: 428, False: 214]
  ------------------
 2740|    642|      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
  ------------------
  |  |  139|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  454|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2740:11): [True: 428, False: 214]
  ------------------
 2741|    642|   }
 2742|    669|}
imgui_draw.cpp:_ZL17stbtt_GetGlyphBoxPK14stbtt_fontinfoiPiS2_S2_S2_:
 1631|    669|{
 1632|    669|   if (info->cff.size) {
  ------------------
  |  Branch (1632:8): [True: 0, False: 669]
  ------------------
 1633|      0|      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
 1634|    669|   } else {
 1635|    669|      int g = stbtt__GetGlyfOffset(info, glyph_index);
 1636|    669|      if (g < 0) return 0;
  ------------------
  |  Branch (1636:11): [True: 27, False: 642]
  ------------------
 1637|       |
 1638|    642|      if (x0) *x0 = ttSHORT(info->data + g + 2);
  ------------------
  |  Branch (1638:11): [True: 642, False: 0]
  ------------------
 1639|    642|      if (y0) *y0 = ttSHORT(info->data + g + 4);
  ------------------
  |  Branch (1639:11): [True: 642, False: 0]
  ------------------
 1640|    642|      if (x1) *x1 = ttSHORT(info->data + g + 6);
  ------------------
  |  Branch (1640:11): [True: 642, False: 0]
  ------------------
 1641|    642|      if (y1) *y1 = ttSHORT(info->data + g + 8);
  ------------------
  |  Branch (1641:11): [True: 642, False: 0]
  ------------------
 1642|    642|   }
 1643|    642|   return 1;
 1644|    669|}
imgui_draw.cpp:_ZL15stbtt_setvertexP12stbtt_vertexhiiii:
 1600|  15.8k|{
 1601|  15.8k|   v->type = type;
 1602|  15.8k|   v->x = (stbtt_int16) x;
 1603|  15.8k|   v->y = (stbtt_int16) y;
 1604|  15.8k|   v->cx = (stbtt_int16) cx;
 1605|  15.8k|   v->cy = (stbtt_int16) cy;
 1606|  15.8k|}
imgui_draw.cpp:_ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi:
 1609|    892|{
 1610|    892|   int g1,g2;
 1611|       |
 1612|    892|   STBTT_assert(!info->cff.size);
  ------------------
  |  |  133|    892|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|    892|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1613|       |
 1614|    892|   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
  ------------------
  |  Branch (1614:8): [True: 0, False: 892]
  ------------------
 1615|    892|   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format
  ------------------
  |  Branch (1615:8): [True: 0, False: 892]
  ------------------
 1616|       |
 1617|    892|   if (info->indexToLocFormat == 0) {
  ------------------
  |  Branch (1617:8): [True: 892, False: 0]
  ------------------
 1618|    892|      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
 1619|    892|      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
 1620|    892|   } else {
 1621|      0|      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
 1622|      0|      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
 1623|      0|   }
 1624|       |
 1625|    892|   return g1==g2 ? -1 : g1; // if length is 0, return -1
  ------------------
  |  Branch (1625:11): [True: 36, False: 856]
  ------------------
 1626|    892|}
imgui_draw.cpp:_ZL15stbtt_PackBeginP18stbtt_pack_contextPhiiiiPv:
 3966|      1|{
 3967|      1|   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
  ------------------
  |  |  131|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3968|      1|   int            num_nodes = pw - padding;
 3969|      1|   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);
  ------------------
  |  |  131|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3970|       |
 3971|      1|   if (context == NULL || nodes == NULL) {
  ------------------
  |  Branch (3971:8): [True: 0, False: 1]
  |  Branch (3971:27): [True: 0, False: 1]
  ------------------
 3972|      0|      if (context != NULL) STBTT_free(context, alloc_context);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3972:11): [True: 0, False: 0]
  ------------------
 3973|      0|      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3973:11): [True: 0, False: 0]
  ------------------
 3974|      0|      return 0;
 3975|      0|   }
 3976|       |
 3977|      1|   spc->user_allocator_context = alloc_context;
 3978|      1|   spc->width = pw;
 3979|      1|   spc->height = ph;
 3980|      1|   spc->pixels = pixels;
 3981|      1|   spc->pack_info = context;
 3982|      1|   spc->nodes = nodes;
 3983|      1|   spc->padding = padding;
 3984|      1|   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
  ------------------
  |  Branch (3984:27): [True: 0, False: 1]
  ------------------
 3985|      1|   spc->h_oversample = 1;
 3986|      1|   spc->v_oversample = 1;
 3987|      1|   spc->skip_missing = 0;
 3988|       |
 3989|      1|   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
 3990|       |
 3991|      1|   if (pixels)
  ------------------
  |  Branch (3991:8): [True: 0, False: 1]
  ------------------
 3992|      0|      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
  ------------------
  |  |  493|      0|   #define STBTT_memset       memset
  ------------------
 3993|       |
 3994|      1|   return 1;
 3995|      1|}
imgui_draw.cpp:_ZL35stbtt_PackFontRangesRenderIntoRectsP18stbtt_pack_contextPK14stbtt_fontinfoP16stbtt_pack_rangeiP10stbrp_rect:
 4217|      1|{
 4218|      1|   int i,j,k, missing_glyph = -1, return_value = 1;
 4219|       |
 4220|       |   // save current values
 4221|      1|   int old_h_over = spc->h_oversample;
 4222|      1|   int old_v_over = spc->v_oversample;
 4223|       |
 4224|      1|   k = 0;
 4225|      2|   for (i=0; i < num_ranges; ++i) {
  ------------------
  |  Branch (4225:14): [True: 1, False: 1]
  ------------------
 4226|      1|      float fh = ranges[i].font_size;
 4227|      1|      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
  ------------------
  |  Branch (4227:21): [True: 1, False: 0]
  ------------------
 4228|      1|      float recip_h,recip_v,sub_x,sub_y;
 4229|      1|      spc->h_oversample = ranges[i].h_oversample;
 4230|      1|      spc->v_oversample = ranges[i].v_oversample;
 4231|      1|      recip_h = 1.0f / spc->h_oversample;
 4232|      1|      recip_v = 1.0f / spc->v_oversample;
 4233|      1|      sub_x = stbtt__oversample_shift(spc->h_oversample);
 4234|      1|      sub_y = stbtt__oversample_shift(spc->v_oversample);
 4235|    224|      for (j=0; j < ranges[i].num_chars; ++j) {
  ------------------
  |  Branch (4235:17): [True: 223, False: 1]
  ------------------
 4236|    223|         stbrp_rect *r = &rects[k];
 4237|    223|         if (r->was_packed && r->w != 0 && r->h != 0) {
  ------------------
  |  Branch (4237:14): [True: 223, False: 0]
  |  Branch (4237:31): [True: 223, False: 0]
  |  Branch (4237:44): [True: 223, False: 0]
  ------------------
 4238|    223|            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
 4239|    223|            int advance, lsb, x0,y0,x1,y1;
 4240|    223|            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
  ------------------
  |  Branch (4240:29): [True: 0, False: 223]
  ------------------
 4241|    223|            int glyph = stbtt_FindGlyphIndex(info, codepoint);
 4242|    223|            stbrp_coord pad = (stbrp_coord) spc->padding;
 4243|       |
 4244|       |            // pad on left and top
 4245|    223|            r->x += pad;
 4246|    223|            r->y += pad;
 4247|    223|            r->w -= pad;
 4248|    223|            r->h -= pad;
 4249|    223|            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
 4250|    223|            stbtt_GetGlyphBitmapBox(info, glyph,
 4251|    223|                                    scale * spc->h_oversample,
 4252|    223|                                    scale * spc->v_oversample,
 4253|    223|                                    &x0,&y0,&x1,&y1);
 4254|    223|            stbtt_MakeGlyphBitmapSubpixel(info,
 4255|    223|                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4256|    223|                                          r->w - spc->h_oversample+1,
 4257|    223|                                          r->h - spc->v_oversample+1,
 4258|    223|                                          spc->stride_in_bytes,
 4259|    223|                                          scale * spc->h_oversample,
 4260|    223|                                          scale * spc->v_oversample,
 4261|    223|                                          0,0,
 4262|    223|                                          glyph);
 4263|       |
 4264|    223|            if (spc->h_oversample > 1)
  ------------------
  |  Branch (4264:17): [True: 0, False: 223]
  ------------------
 4265|      0|               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4266|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4267|      0|                                  spc->h_oversample);
 4268|       |
 4269|    223|            if (spc->v_oversample > 1)
  ------------------
  |  Branch (4269:17): [True: 0, False: 223]
  ------------------
 4270|      0|               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4271|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4272|      0|                                  spc->v_oversample);
 4273|       |
 4274|    223|            bc->x0       = (stbtt_int16)  r->x;
 4275|    223|            bc->y0       = (stbtt_int16)  r->y;
 4276|    223|            bc->x1       = (stbtt_int16) (r->x + r->w);
 4277|    223|            bc->y1       = (stbtt_int16) (r->y + r->h);
 4278|    223|            bc->xadvance =                scale * advance;
 4279|    223|            bc->xoff     =       (float)  x0 * recip_h + sub_x;
 4280|    223|            bc->yoff     =       (float)  y0 * recip_v + sub_y;
 4281|    223|            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
 4282|    223|            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
 4283|       |
 4284|    223|            if (glyph == 0)
  ------------------
  |  Branch (4284:17): [True: 0, False: 223]
  ------------------
 4285|      0|               missing_glyph = j;
 4286|    223|         } else if (spc->skip_missing) {
  ------------------
  |  Branch (4286:21): [True: 0, False: 0]
  ------------------
 4287|      0|            return_value = 0;
 4288|      0|         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
  ------------------
  |  Branch (4288:21): [True: 0, False: 0]
  |  Branch (4288:38): [True: 0, False: 0]
  |  Branch (4288:51): [True: 0, False: 0]
  |  Branch (4288:64): [True: 0, False: 0]
  ------------------
 4289|      0|            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
 4290|      0|         } else {
 4291|      0|            return_value = 0; // if any fail, report failure
 4292|      0|         }
 4293|       |
 4294|    223|         ++k;
 4295|    223|      }
 4296|      1|   }
 4297|       |
 4298|       |   // restore original values
 4299|      1|   spc->h_oversample = old_h_over;
 4300|      1|   spc->v_oversample = old_v_over;
 4301|       |
 4302|      1|   return return_value;
 4303|      1|}
imgui_draw.cpp:_ZL23stbtt__oversample_shifti:
 4145|      2|{
 4146|      2|   if (!oversample)
  ------------------
  |  Branch (4146:8): [True: 0, False: 2]
  ------------------
 4147|      0|      return 0.0f;
 4148|       |
 4149|       |   // The prefilter is a box filter of width "oversample",
 4150|       |   // which shifts phase by (oversample - 1)/2 pixels in
 4151|       |   // oversampled space. We want to shift in the opposite
 4152|       |   // direction to counter this.
 4153|      2|   return (float)-(oversample - 1) / (2.0f * (float)oversample);
 4154|      2|}
imgui_draw.cpp:_ZL22stbtt_GetGlyphHMetricsPK14stbtt_fontinfoiPiS2_:
 2311|    223|{
 2312|    223|   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
 2313|    223|   if (glyph_index < numOfLongHorMetrics) {
  ------------------
  |  Branch (2313:8): [True: 0, False: 223]
  ------------------
 2314|      0|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
  ------------------
  |  Branch (2314:11): [True: 0, False: 0]
  ------------------
 2315|      0|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
  ------------------
  |  Branch (2315:11): [True: 0, False: 0]
  ------------------
 2316|    223|   } else {
 2317|    223|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
  ------------------
  |  Branch (2317:11): [True: 223, False: 0]
  ------------------
 2318|    223|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
  ------------------
  |  Branch (2318:11): [True: 223, False: 0]
  ------------------
 2319|    223|   }
 2320|    223|}
imgui_draw.cpp:_ZL23stbtt_GetGlyphBitmapBoxPK14stbtt_fontinfoiffPiS2_S2_S2_:
 2745|    223|{
 2746|    223|   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
 2747|    223|}
imgui_draw.cpp:_ZL29stbtt_MakeGlyphBitmapSubpixelPK14stbtt_fontinfoPhiiiffffi:
 3767|    223|{
 3768|    223|   int ix0,iy0;
 3769|    223|   stbtt_vertex *vertices;
 3770|    223|   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
 3771|    223|   stbtt__bitmap gbm;
 3772|       |
 3773|    223|   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
 3774|    223|   gbm.pixels = output;
 3775|    223|   gbm.w = out_w;
 3776|    223|   gbm.h = out_h;
 3777|    223|   gbm.stride = out_stride;
 3778|       |
 3779|    223|   if (gbm.w && gbm.h)
  ------------------
  |  Branch (3779:8): [True: 214, False: 9]
  |  Branch (3779:17): [True: 214, False: 0]
  ------------------
 3780|    214|      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);
 3781|       |
 3782|    223|   STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|    223|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|    223|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3783|    223|}
imgui_draw.cpp:_ZL19stbtt_GetGlyphShapePK14stbtt_fontinfoiPP12stbtt_vertex:
 2303|    223|{
 2304|    223|   if (!info->cff.size)
  ------------------
  |  Branch (2304:8): [True: 223, False: 0]
  ------------------
 2305|    223|      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
 2306|      0|   else
 2307|      0|      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
 2308|    223|}
imgui_draw.cpp:_ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex:
 1680|    223|{
 1681|    223|   stbtt_int16 numberOfContours;
 1682|    223|   stbtt_uint8 *endPtsOfContours;
 1683|    223|   stbtt_uint8 *data = info->data;
 1684|    223|   stbtt_vertex *vertices=0;
 1685|    223|   int num_vertices=0;
 1686|    223|   int g = stbtt__GetGlyfOffset(info, glyph_index);
 1687|       |
 1688|    223|   *pvertices = NULL;
 1689|       |
 1690|    223|   if (g < 0) return 0;
  ------------------
  |  Branch (1690:8): [True: 9, False: 214]
  ------------------
 1691|       |
 1692|    214|   numberOfContours = ttSHORT(data + g);
 1693|       |
 1694|    214|   if (numberOfContours > 0) {
  ------------------
  |  Branch (1694:8): [True: 214, False: 0]
  ------------------
 1695|    214|      stbtt_uint8 flags=0,flagcount;
 1696|    214|      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
 1697|    214|      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
 1698|    214|      stbtt_uint8 *points;
 1699|    214|      endPtsOfContours = (data + g + 10);
 1700|    214|      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
 1701|    214|      points = data + g + 10 + numberOfContours * 2 + 2 + ins;
 1702|       |
 1703|    214|      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);
 1704|       |
 1705|    214|      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
 1706|    214|      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1707|    214|      if (vertices == 0)
  ------------------
  |  Branch (1707:11): [True: 0, False: 214]
  ------------------
 1708|      0|         return 0;
 1709|       |
 1710|    214|      next_move = 0;
 1711|    214|      flagcount=0;
 1712|       |
 1713|       |      // in first pass, we load uninterpreted data into the allocated array
 1714|       |      // above, shifted to the end of the array so we won't overwrite it when
 1715|       |      // we create our final data starting from the front
 1716|       |
 1717|    214|      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
 1718|       |
 1719|       |      // first load flags
 1720|       |
 1721|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1721:17): [True: 12.6k, False: 214]
  ------------------
 1722|  12.6k|         if (flagcount == 0) {
  ------------------
  |  Branch (1722:14): [True: 12.5k, False: 63]
  ------------------
 1723|  12.5k|            flags = *points++;
 1724|  12.5k|            if (flags & 8)
  ------------------
  |  Branch (1724:17): [True: 63, False: 12.5k]
  ------------------
 1725|     63|               flagcount = *points++;
 1726|  12.5k|         } else
 1727|     63|            --flagcount;
 1728|  12.6k|         vertices[off+i].type = flags;
 1729|  12.6k|      }
 1730|       |
 1731|       |      // now load x coordinates
 1732|    214|      x=0;
 1733|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1733:17): [True: 12.6k, False: 214]
  ------------------
 1734|  12.6k|         flags = vertices[off+i].type;
 1735|  12.6k|         if (flags & 2) {
  ------------------
  |  Branch (1735:14): [True: 3.76k, False: 8.87k]
  ------------------
 1736|  3.76k|            stbtt_int16 dx = *points++;
 1737|  3.76k|            x += (flags & 16) ? dx : -dx; // ???
  ------------------
  |  Branch (1737:18): [True: 3.41k, False: 350]
  ------------------
 1738|  8.87k|         } else {
 1739|  8.87k|            if (!(flags & 16)) {
  ------------------
  |  Branch (1739:17): [True: 1.56k, False: 7.30k]
  ------------------
 1740|  1.56k|               x = x + (stbtt_int16) (points[0]*256 + points[1]);
 1741|  1.56k|               points += 2;
 1742|  1.56k|            }
 1743|  8.87k|         }
 1744|  12.6k|         vertices[off+i].x = (stbtt_int16) x;
 1745|  12.6k|      }
 1746|       |
 1747|       |      // now load y coordinates
 1748|    214|      y=0;
 1749|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1749:17): [True: 12.6k, False: 214]
  ------------------
 1750|  12.6k|         flags = vertices[off+i].type;
 1751|  12.6k|         if (flags & 4) {
  ------------------
  |  Branch (1751:14): [True: 7.59k, False: 5.04k]
  ------------------
 1752|  7.59k|            stbtt_int16 dy = *points++;
 1753|  7.59k|            y += (flags & 32) ? dy : -dy; // ???
  ------------------
  |  Branch (1753:18): [True: 3.16k, False: 4.43k]
  ------------------
 1754|  7.59k|         } else {
 1755|  5.04k|            if (!(flags & 32)) {
  ------------------
  |  Branch (1755:17): [True: 273, False: 4.77k]
  ------------------
 1756|    273|               y = y + (stbtt_int16) (points[0]*256 + points[1]);
 1757|    273|               points += 2;
 1758|    273|            }
 1759|  5.04k|         }
 1760|  12.6k|         vertices[off+i].y = (stbtt_int16) y;
 1761|  12.6k|      }
 1762|       |
 1763|       |      // now convert them to our format
 1764|    214|      num_vertices=0;
 1765|    214|      sx = sy = cx = cy = scx = scy = 0;
 1766|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1766:17): [True: 12.6k, False: 214]
  ------------------
 1767|  12.6k|         flags = vertices[off+i].type;
 1768|  12.6k|         x     = (stbtt_int16) vertices[off+i].x;
 1769|  12.6k|         y     = (stbtt_int16) vertices[off+i].y;
 1770|       |
 1771|  12.6k|         if (next_move == i) {
  ------------------
  |  Branch (1771:14): [True: 3.16k, False: 9.48k]
  ------------------
 1772|  3.16k|            if (i != 0)
  ------------------
  |  Branch (1772:17): [True: 2.94k, False: 214]
  ------------------
 1773|  2.94k|               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1774|       |
 1775|       |            // now start the new one
 1776|  3.16k|            start_off = !(flags & 1);
 1777|  3.16k|            if (start_off) {
  ------------------
  |  Branch (1777:17): [True: 0, False: 3.16k]
  ------------------
 1778|       |               // if we start off with an off-curve point, then when we need to find a point on the curve
 1779|       |               // where we can start, and we need to save some state for when we wraparound.
 1780|      0|               scx = x;
 1781|      0|               scy = y;
 1782|      0|               if (!(vertices[off+i+1].type & 1)) {
  ------------------
  |  Branch (1782:20): [True: 0, False: 0]
  ------------------
 1783|       |                  // next point is also a curve point, so interpolate an on-point curve
 1784|      0|                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
 1785|      0|                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
 1786|      0|               } else {
 1787|       |                  // otherwise just use the next point as our start point
 1788|      0|                  sx = (stbtt_int32) vertices[off+i+1].x;
 1789|      0|                  sy = (stbtt_int32) vertices[off+i+1].y;
 1790|      0|                  ++i; // we're using point i+1 as the starting point, so skip it
 1791|      0|               }
 1792|  3.16k|            } else {
 1793|  3.16k|               sx = x;
 1794|  3.16k|               sy = y;
 1795|  3.16k|            }
 1796|  3.16k|            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
 1797|  3.16k|            was_off = 0;
 1798|  3.16k|            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
 1799|  3.16k|            ++j;
 1800|  9.48k|         } else {
 1801|  9.48k|            if (!(flags & 1)) { // if it's a curve
  ------------------
  |  Branch (1801:17): [True: 0, False: 9.48k]
  ------------------
 1802|      0|               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
  ------------------
  |  Branch (1802:20): [True: 0, False: 0]
  ------------------
 1803|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
 1804|      0|               cx = x;
 1805|      0|               cy = y;
 1806|      0|               was_off = 1;
 1807|  9.48k|            } else {
 1808|  9.48k|               if (was_off)
  ------------------
  |  Branch (1808:20): [True: 0, False: 9.48k]
  ------------------
 1809|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
 1810|  9.48k|               else
 1811|  9.48k|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
 1812|  9.48k|               was_off = 0;
 1813|  9.48k|            }
 1814|  9.48k|         }
 1815|  12.6k|      }
 1816|    214|      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1817|    214|   } else if (numberOfContours < 0) {
  ------------------
  |  Branch (1817:15): [True: 0, False: 0]
  ------------------
 1818|       |      // Compound shapes.
 1819|      0|      int more = 1;
 1820|      0|      stbtt_uint8 *comp = data + g + 10;
 1821|      0|      num_vertices = 0;
 1822|      0|      vertices = 0;
 1823|      0|      while (more) {
  ------------------
  |  Branch (1823:14): [True: 0, False: 0]
  ------------------
 1824|      0|         stbtt_uint16 flags, gidx;
 1825|      0|         int comp_num_verts = 0, i;
 1826|      0|         stbtt_vertex *comp_verts = 0, *tmp = 0;
 1827|      0|         float mtx[6] = {1,0,0,1,0,0}, m, n;
 1828|       |
 1829|      0|         flags = ttSHORT(comp); comp+=2;
 1830|      0|         gidx = ttSHORT(comp); comp+=2;
 1831|       |
 1832|      0|         if (flags & 2) { // XY values
  ------------------
  |  Branch (1832:14): [True: 0, False: 0]
  ------------------
 1833|      0|            if (flags & 1) { // shorts
  ------------------
  |  Branch (1833:17): [True: 0, False: 0]
  ------------------
 1834|      0|               mtx[4] = ttSHORT(comp); comp+=2;
 1835|      0|               mtx[5] = ttSHORT(comp); comp+=2;
 1836|      0|            } else {
 1837|      0|               mtx[4] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1838|      0|               mtx[5] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1839|      0|            }
 1840|      0|         }
 1841|      0|         else {
 1842|       |            // @TODO handle matching point
 1843|      0|            STBTT_assert(0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1844|      0|         }
 1845|      0|         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
  ------------------
  |  Branch (1845:14): [True: 0, False: 0]
  ------------------
 1846|      0|            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1847|      0|            mtx[1] = mtx[2] = 0;
 1848|      0|         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
  ------------------
  |  Branch (1848:21): [True: 0, False: 0]
  ------------------
 1849|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1850|      0|            mtx[1] = mtx[2] = 0;
 1851|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1852|      0|         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
  ------------------
  |  Branch (1852:21): [True: 0, False: 0]
  ------------------
 1853|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1854|      0|            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
 1855|      0|            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
 1856|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1857|      0|         }
 1858|       |
 1859|       |         // Find transformation scales.
 1860|      0|         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
  ------------------
  |  |  135|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  447|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1861|      0|         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);
  ------------------
  |  |  135|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  447|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1862|       |
 1863|       |         // Get indexed glyph.
 1864|      0|         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
 1865|      0|         if (comp_num_verts > 0) {
  ------------------
  |  Branch (1865:14): [True: 0, False: 0]
  ------------------
 1866|       |            // Transform vertices.
 1867|      0|            for (i = 0; i < comp_num_verts; ++i) {
  ------------------
  |  Branch (1867:25): [True: 0, False: 0]
  ------------------
 1868|      0|               stbtt_vertex* v = &comp_verts[i];
 1869|      0|               stbtt_vertex_type x,y;
  ------------------
  |  |  839|      0|   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
  ------------------
 1870|      0|               x=v->x; y=v->y;
 1871|      0|               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1872|      0|               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1873|      0|               x=v->cx; y=v->cy;
 1874|      0|               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1875|      0|               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1876|      0|            }
 1877|       |            // Append vertices.
 1878|      0|            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
  ------------------
  |  |  131|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1879|      0|            if (!tmp) {
  ------------------
  |  Branch (1879:17): [True: 0, False: 0]
  ------------------
 1880|      0|               if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1880:20): [True: 0, False: 0]
  ------------------
 1881|      0|               if (comp_verts) STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1881:20): [True: 0, False: 0]
  ------------------
 1882|      0|               return 0;
 1883|      0|            }
 1884|      0|            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
  |  Branch (1884:17): [True: 0, False: 0]
  |  Branch (1884:37): [True: 0, False: 0]
  ------------------
 1885|      0|            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
 1886|      0|            if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1886:17): [True: 0, False: 0]
  ------------------
 1887|      0|            vertices = tmp;
 1888|      0|            STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 1889|      0|            num_vertices += comp_num_verts;
 1890|      0|         }
 1891|       |         // More components ?
 1892|      0|         more = flags & (1<<5);
 1893|      0|      }
 1894|      0|   } else {
 1895|       |      // numberOfCounters == 0, do nothing
 1896|      0|   }
 1897|       |
 1898|    214|   *pvertices = vertices;
 1899|    214|   return num_vertices;
 1900|    214|}
imgui_draw.cpp:_ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii:
 1665|  3.16k|{
 1666|  3.16k|   if (start_off) {
  ------------------
  |  Branch (1666:8): [True: 0, False: 3.16k]
  ------------------
 1667|      0|      if (was_off)
  ------------------
  |  Branch (1667:11): [True: 0, False: 0]
  ------------------
 1668|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
 1669|      0|      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
 1670|  3.16k|   } else {
 1671|  3.16k|      if (was_off)
  ------------------
  |  Branch (1671:11): [True: 0, False: 3.16k]
  ------------------
 1672|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
 1673|  3.16k|      else
 1674|  3.16k|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
 1675|  3.16k|   }
 1676|  3.16k|   return num_vertices;
 1677|  3.16k|}
imgui_draw.cpp:_ZL15stbtt_RasterizeP13stbtt__bitmapfP12stbtt_vertexiffffiiiPv:
 3704|    214|{
 3705|    214|   float scale            = scale_x > scale_y ? scale_y : scale_x;
  ------------------
  |  Branch (3705:29): [True: 0, False: 214]
  ------------------
 3706|    214|   int winding_count      = 0;
 3707|    214|   int *winding_lengths   = NULL;
 3708|    214|   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
 3709|    214|   if (windings) {
  ------------------
  |  Branch (3709:8): [True: 214, False: 0]
  ------------------
 3710|    214|      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
 3711|    214|      STBTT_free(winding_lengths, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3712|    214|      STBTT_free(windings, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3713|    214|   }
 3714|    214|}
imgui_draw.cpp:_ZL19stbtt_FlattenCurvesP12stbtt_vertexifPPiS1_Pv:
 3627|    214|{
 3628|    214|   stbtt__point *points=0;
 3629|    214|   int num_points=0;
 3630|       |
 3631|    214|   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
 3632|    214|   int i,n=0,start=0, pass;
 3633|       |
 3634|       |   // count how many "moves" there are to get the contour count
 3635|  16.0k|   for (i=0; i < num_verts; ++i)
  ------------------
  |  Branch (3635:14): [True: 15.8k, False: 214]
  ------------------
 3636|  15.8k|      if (vertices[i].type == STBTT_vmove)
  ------------------
  |  Branch (3636:11): [True: 3.16k, False: 12.6k]
  ------------------
 3637|  3.16k|         ++n;
 3638|       |
 3639|    214|   *num_contours = n;
 3640|    214|   if (n == 0) return 0;
  ------------------
  |  Branch (3640:8): [True: 0, False: 214]
  ------------------
 3641|       |
 3642|    214|   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3643|       |
 3644|    214|   if (*contour_lengths == 0) {
  ------------------
  |  Branch (3644:8): [True: 0, False: 214]
  ------------------
 3645|      0|      *num_contours = 0;
 3646|      0|      return 0;
 3647|      0|   }
 3648|       |
 3649|       |   // make two passes through the points so we don't need to realloc
 3650|    642|   for (pass=0; pass < 2; ++pass) {
  ------------------
  |  Branch (3650:17): [True: 428, False: 214]
  ------------------
 3651|    428|      float x=0,y=0;
 3652|    428|      if (pass == 1) {
  ------------------
  |  Branch (3652:11): [True: 214, False: 214]
  ------------------
 3653|    214|         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3654|    214|         if (points == NULL) goto error;
  ------------------
  |  Branch (3654:14): [True: 0, False: 214]
  ------------------
 3655|    214|      }
 3656|    428|      num_points = 0;
 3657|    428|      n= -1;
 3658|  32.0k|      for (i=0; i < num_verts; ++i) {
  ------------------
  |  Branch (3658:17): [True: 31.6k, False: 428]
  ------------------
 3659|  31.6k|         switch (vertices[i].type) {
  ------------------
  |  Branch (3659:18): [True: 0, False: 31.6k]
  ------------------
 3660|  6.32k|            case STBTT_vmove:
  ------------------
  |  Branch (3660:13): [True: 6.32k, False: 25.2k]
  ------------------
 3661|       |               // start the next contour
 3662|  6.32k|               if (n >= 0)
  ------------------
  |  Branch (3662:20): [True: 5.89k, False: 428]
  ------------------
 3663|  5.89k|                  (*contour_lengths)[n] = num_points - start;
 3664|  6.32k|               ++n;
 3665|  6.32k|               start = num_points;
 3666|       |
 3667|  6.32k|               x = vertices[i].x, y = vertices[i].y;
 3668|  6.32k|               stbtt__add_point(points, num_points++, x,y);
 3669|  6.32k|               break;
 3670|  25.2k|            case STBTT_vline:
  ------------------
  |  Branch (3670:13): [True: 25.2k, False: 6.32k]
  ------------------
 3671|  25.2k|               x = vertices[i].x, y = vertices[i].y;
 3672|  25.2k|               stbtt__add_point(points, num_points++, x, y);
 3673|  25.2k|               break;
 3674|      0|            case STBTT_vcurve:
  ------------------
  |  Branch (3674:13): [True: 0, False: 31.6k]
  ------------------
 3675|      0|               stbtt__tesselate_curve(points, &num_points, x,y,
 3676|      0|                                        vertices[i].cx, vertices[i].cy,
 3677|      0|                                        vertices[i].x,  vertices[i].y,
 3678|      0|                                        objspace_flatness_squared, 0);
 3679|      0|               x = vertices[i].x, y = vertices[i].y;
 3680|      0|               break;
 3681|      0|            case STBTT_vcubic:
  ------------------
  |  Branch (3681:13): [True: 0, False: 31.6k]
  ------------------
 3682|      0|               stbtt__tesselate_cubic(points, &num_points, x,y,
 3683|      0|                                        vertices[i].cx, vertices[i].cy,
 3684|      0|                                        vertices[i].cx1, vertices[i].cy1,
 3685|      0|                                        vertices[i].x,  vertices[i].y,
 3686|      0|                                        objspace_flatness_squared, 0);
 3687|      0|               x = vertices[i].x, y = vertices[i].y;
 3688|      0|               break;
 3689|  31.6k|         }
 3690|  31.6k|      }
 3691|    428|      (*contour_lengths)[n] = num_points - start;
 3692|    428|   }
 3693|       |
 3694|    214|   return points;
 3695|      0|error:
 3696|      0|   STBTT_free(points, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3697|      0|   STBTT_free(*contour_lengths, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3698|      0|   *contour_lengths = 0;
 3699|      0|   *num_contours = 0;
 3700|      0|   return NULL;
 3701|    214|}
imgui_draw.cpp:_ZL16stbtt__add_pointP12stbtt__pointiff:
 3556|  31.6k|{
 3557|  31.6k|   if (!points) return; // during first pass, it's unallocated
  ------------------
  |  Branch (3557:8): [True: 15.8k, False: 15.8k]
  ------------------
 3558|  15.8k|   points[n].x = x;
 3559|  15.8k|   points[n].y = y;
 3560|  15.8k|}
imgui_draw.cpp:_ZL16stbtt__rasterizeP13stbtt__bitmapP12stbtt__pointPiiffffiiiPv:
 3499|    214|{
 3500|    214|   float y_scale_inv = invert ? -scale_y : scale_y;
  ------------------
  |  Branch (3500:24): [True: 214, False: 0]
  ------------------
 3501|    214|   stbtt__edge *e;
 3502|    214|   int n,i,j,k,m;
 3503|       |#if STBTT_RASTERIZER_VERSION == 1
 3504|       |   int vsubsample = result->h < 8 ? 15 : 5;
 3505|       |#elif STBTT_RASTERIZER_VERSION == 2
 3506|    214|   int vsubsample = 1;
 3507|       |#else
 3508|       |   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
 3509|       |#endif
 3510|       |   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
 3511|       |
 3512|       |   // now we have to blow out the windings into explicit edge lists
 3513|    214|   n = 0;
 3514|  3.37k|   for (i=0; i < windings; ++i)
  ------------------
  |  Branch (3514:14): [True: 3.16k, False: 214]
  ------------------
 3515|  3.16k|      n += wcount[i];
 3516|       |
 3517|    214|   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3518|    214|   if (e == 0) return;
  ------------------
  |  Branch (3518:8): [True: 0, False: 214]
  ------------------
 3519|    214|   n = 0;
 3520|       |
 3521|    214|   m=0;
 3522|  3.37k|   for (i=0; i < windings; ++i) {
  ------------------
  |  Branch (3522:14): [True: 3.16k, False: 214]
  ------------------
 3523|  3.16k|      stbtt__point *p = pts + m;
 3524|  3.16k|      m += wcount[i];
 3525|  3.16k|      j = wcount[i]-1;
 3526|  18.9k|      for (k=0; k < wcount[i]; j=k++) {
  ------------------
  |  Branch (3526:17): [True: 15.8k, False: 3.16k]
  ------------------
 3527|  15.8k|         int a=k,b=j;
 3528|       |         // skip the edge if horizontal
 3529|  15.8k|         if (p[j].y == p[k].y)
  ------------------
  |  Branch (3529:14): [True: 9.48k, False: 6.32k]
  ------------------
 3530|  9.48k|            continue;
 3531|       |         // add edge from j to k to the list
 3532|  6.32k|         e[n].invert = 0;
 3533|  6.32k|         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
  ------------------
  |  Branch (3533:14): [True: 6.32k, False: 0]
  |  Branch (3533:14): [True: 3.16k, False: 3.16k]
  ------------------
 3534|  3.16k|            e[n].invert = 1;
 3535|  3.16k|            a=j,b=k;
 3536|  3.16k|         }
 3537|  6.32k|         e[n].x0 = p[a].x * scale_x + shift_x;
 3538|  6.32k|         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
 3539|  6.32k|         e[n].x1 = p[b].x * scale_x + shift_x;
 3540|  6.32k|         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
 3541|  6.32k|         ++n;
 3542|  6.32k|      }
 3543|  3.16k|   }
 3544|       |
 3545|       |   // now sort the edges by their highest point (should snap to integer, and then by x)
 3546|       |   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
 3547|    214|   stbtt__sort_edges(e, n);
 3548|       |
 3549|       |   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
 3550|    214|   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);
 3551|       |
 3552|    214|   STBTT_free(e, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3553|    214|}
imgui_draw.cpp:_ZL17stbtt__sort_edgesP11stbtt__edgei:
 3488|    214|{
 3489|    214|   stbtt__sort_edges_quicksort(p, n);
 3490|    214|   stbtt__sort_edges_ins_sort(p, n);
 3491|    214|}
imgui_draw.cpp:_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei:
 3426|    862|{
 3427|       |   /* threshold for transitioning to insertion sort */
 3428|  1.51k|   while (n > 12) {
  ------------------
  |  Branch (3428:11): [True: 648, False: 862]
  ------------------
 3429|    648|      stbtt__edge t;
 3430|    648|      int c01,c12,c,m,i,j;
 3431|       |
 3432|       |      /* compute median of three */
 3433|    648|      m = n >> 1;
 3434|    648|      c01 = STBTT__COMPARE(&p[0],&p[m]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3435|    648|      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3436|       |      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
 3437|    648|      if (c01 != c12) {
  ------------------
  |  Branch (3437:11): [True: 249, False: 399]
  ------------------
 3438|       |         /* otherwise, we'll need to swap something else to middle */
 3439|    249|         int z;
 3440|    249|         c = STBTT__COMPARE(&p[0],&p[n-1]);
  ------------------
  |  | 3405|    249|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3441|       |         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
 3442|       |         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
 3443|    249|         z = (c == c12) ? 0 : n-1;
  ------------------
  |  Branch (3443:14): [True: 6, False: 243]
  ------------------
 3444|    249|         t = p[z];
 3445|    249|         p[z] = p[m];
 3446|    249|         p[m] = t;
 3447|    249|      }
 3448|       |      /* now p[m] is the median-of-three */
 3449|       |      /* swap it to the beginning so it won't move around */
 3450|    648|      t = p[0];
 3451|    648|      p[0] = p[m];
 3452|    648|      p[m] = t;
 3453|       |
 3454|       |      /* partition loop */
 3455|    648|      i=1;
 3456|    648|      j=n-1;
 3457|  1.98k|      for(;;) {
 3458|       |         /* handling of equality is crucial here */
 3459|       |         /* for sentinels & efficiency with duplicates */
 3460|  8.69k|         for (;;++i) {
 3461|  8.69k|            if (!STBTT__COMPARE(&p[i], &p[0])) break;
  ------------------
  |  | 3405|  8.69k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3461:17): [True: 1.98k, False: 6.71k]
  ------------------
 3462|  8.69k|         }
 3463|  5.67k|         for (;;--j) {
 3464|  5.67k|            if (!STBTT__COMPARE(&p[0], &p[j])) break;
  ------------------
  |  | 3405|  5.67k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3464:17): [True: 1.98k, False: 3.69k]
  ------------------
 3465|  5.67k|         }
 3466|       |         /* make sure we haven't crossed */
 3467|  1.98k|         if (i >= j) break;
  ------------------
  |  Branch (3467:14): [True: 648, False: 1.33k]
  ------------------
 3468|  1.33k|         t = p[i];
 3469|  1.33k|         p[i] = p[j];
 3470|  1.33k|         p[j] = t;
 3471|       |
 3472|  1.33k|         ++i;
 3473|  1.33k|         --j;
 3474|  1.33k|      }
 3475|       |      /* recurse on smaller side, iterate on larger */
 3476|    648|      if (j < (n-i)) {
  ------------------
  |  Branch (3476:11): [True: 199, False: 449]
  ------------------
 3477|    199|         stbtt__sort_edges_quicksort(p,j);
 3478|    199|         p = p+i;
 3479|    199|         n = n-i;
 3480|    449|      } else {
 3481|    449|         stbtt__sort_edges_quicksort(p+i, n-i);
 3482|    449|         n = j;
 3483|    449|      }
 3484|    648|   }
 3485|    862|}
imgui_draw.cpp:_ZL26stbtt__sort_edges_ins_sortP11stbtt__edgei:
 3408|    214|{
 3409|    214|   int i,j;
 3410|  6.32k|   for (i=1; i < n; ++i) {
  ------------------
  |  Branch (3410:14): [True: 6.10k, False: 214]
  ------------------
 3411|  6.10k|      stbtt__edge t = p[i], *a = &t;
 3412|  6.10k|      j = i;
 3413|  11.1k|      while (j > 0) {
  ------------------
  |  Branch (3413:14): [True: 10.9k, False: 177]
  ------------------
 3414|  10.9k|         stbtt__edge *b = &p[j-1];
 3415|  10.9k|         int c = STBTT__COMPARE(a,b);
  ------------------
  |  | 3405|  10.9k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3416|  10.9k|         if (!c) break;
  ------------------
  |  Branch (3416:14): [True: 5.93k, False: 5.04k]
  ------------------
 3417|  5.04k|         p[j] = p[j-1];
 3418|  5.04k|         --j;
 3419|  5.04k|      }
 3420|  6.10k|      if (i != j)
  ------------------
  |  Branch (3420:11): [True: 2.86k, False: 3.23k]
  ------------------
 3421|  2.86k|         p[j] = t;
 3422|  6.10k|   }
 3423|    214|}
imgui_draw.cpp:_ZL29stbtt__rasterize_sorted_edgesP13stbtt__bitmapP11stbtt__edgeiiiiPv:
 3306|    214|{
 3307|    214|   stbtt__hheap hh = { 0, 0, 0 };
 3308|    214|   stbtt__active_edge *active = NULL;
 3309|    214|   int y,j=0, i;
 3310|    214|   float scanline_data[129], *scanline, *scanline2;
 3311|       |
 3312|    214|   STBTT__NOTUSED(vsubsample);
  ------------------
  |  | 1130|    214|#define STBTT__NOTUSED(v)  (void)sizeof(v)
  ------------------
 3313|       |
 3314|    214|   if (result->w > 64)
  ------------------
  |  Branch (3314:8): [True: 0, False: 214]
  ------------------
 3315|      0|      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
  ------------------
  |  |  131|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3316|    214|   else
 3317|    214|      scanline = scanline_data;
 3318|       |
 3319|    214|   scanline2 = scanline + result->w;
 3320|       |
 3321|    214|   y = off_y;
 3322|    214|   e[n].y0 = (float) (off_y + result->h) + 1;
 3323|       |
 3324|  1.83k|   while (j < result->h) {
  ------------------
  |  Branch (3324:11): [True: 1.61k, False: 214]
  ------------------
 3325|       |      // find center of pixel for this scanline
 3326|  1.61k|      float scan_y_top    = y + 0.0f;
 3327|  1.61k|      float scan_y_bottom = y + 1.0f;
 3328|  1.61k|      stbtt__active_edge **step = &active;
 3329|       |
 3330|  1.61k|      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3331|  1.61k|      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3332|       |
 3333|       |      // update all active edges;
 3334|       |      // remove all active edges that terminate before the top of this scanline
 3335|  12.1k|      while (*step) {
  ------------------
  |  Branch (3335:14): [True: 10.5k, False: 1.61k]
  ------------------
 3336|  10.5k|         stbtt__active_edge * z = *step;
 3337|  10.5k|         if (z->ey <= scan_y_top) {
  ------------------
  |  Branch (3337:14): [True: 5.20k, False: 5.36k]
  ------------------
 3338|  5.20k|            *step = z->next; // delete from list
 3339|  5.20k|            STBTT_assert(z->direction);
  ------------------
  |  |  133|  5.20k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  5.20k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3340|  5.20k|            z->direction = 0;
 3341|  5.20k|            stbtt__hheap_free(&hh, z);
 3342|  5.36k|         } else {
 3343|  5.36k|            step = &((*step)->next); // advance through list
 3344|  5.36k|         }
 3345|  10.5k|      }
 3346|       |
 3347|       |      // insert all edges that start before the bottom of this scanline
 3348|  7.94k|      while (e->y0 <= scan_y_bottom) {
  ------------------
  |  Branch (3348:14): [True: 6.32k, False: 1.61k]
  ------------------
 3349|  6.32k|         if (e->y0 != e->y1) {
  ------------------
  |  Branch (3349:14): [True: 6.32k, False: 0]
  ------------------
 3350|  6.32k|            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
 3351|  6.32k|            if (z != NULL) {
  ------------------
  |  Branch (3351:17): [True: 6.32k, False: 0]
  ------------------
 3352|  6.32k|               if (j == 0 && off_y != 0) {
  ------------------
  |  Branch (3352:20): [True: 1.60k, False: 4.72k]
  |  Branch (3352:30): [True: 1.58k, False: 20]
  ------------------
 3353|  1.58k|                  if (z->ey < scan_y_top) {
  ------------------
  |  Branch (3353:23): [True: 0, False: 1.58k]
  ------------------
 3354|       |                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
 3355|      0|                     z->ey = scan_y_top;
 3356|      0|                  }
 3357|  1.58k|               }
 3358|  6.32k|               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
  ------------------
  |  |  133|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3359|       |               // insert at front
 3360|  6.32k|               z->next = active;
 3361|  6.32k|               active = z;
 3362|  6.32k|            }
 3363|  6.32k|         }
 3364|  6.32k|         ++e;
 3365|  6.32k|      }
 3366|       |
 3367|       |      // now process all active edges
 3368|  1.61k|      if (active)
  ------------------
  |  Branch (3368:11): [True: 1.61k, False: 5]
  ------------------
 3369|  1.61k|         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
 3370|       |
 3371|  1.61k|      {
 3372|  1.61k|         float sum = 0;
 3373|  9.77k|         for (i=0; i < result->w; ++i) {
  ------------------
  |  Branch (3373:20): [True: 8.15k, False: 1.61k]
  ------------------
 3374|  8.15k|            float k;
 3375|  8.15k|            int m;
 3376|  8.15k|            sum += scanline2[i];
 3377|  8.15k|            k = scanline[i] + sum;
 3378|  8.15k|            k = (float) STBTT_fabs(k)*255 + 0.5f;
  ------------------
  |  |  137|  8.15k|#define STBTT_fabs(x)       ImFabs(x)
  |  |  ------------------
  |  |  |  |  446|  8.15k|#define ImFabs(X)           fabsf(X)
  |  |  ------------------
  ------------------
 3379|  8.15k|            m = (int) k;
 3380|  8.15k|            if (m > 255) m = 255;
  ------------------
  |  Branch (3380:17): [True: 0, False: 8.15k]
  ------------------
 3381|  8.15k|            result->pixels[j*result->stride + i] = (unsigned char) m;
 3382|  8.15k|         }
 3383|  1.61k|      }
 3384|       |      // advance all the edges
 3385|  1.61k|      step = &active;
 3386|  13.3k|      while (*step) {
  ------------------
  |  Branch (3386:14): [True: 11.6k, False: 1.61k]
  ------------------
 3387|  11.6k|         stbtt__active_edge *z = *step;
 3388|  11.6k|         z->fx += z->fdx; // advance to position for current scanline
 3389|  11.6k|         step = &((*step)->next); // advance through list
 3390|  11.6k|      }
 3391|       |
 3392|  1.61k|      ++y;
 3393|  1.61k|      ++j;
 3394|  1.61k|   }
 3395|       |
 3396|    214|   stbtt__hheap_cleanup(&hh, userdata);
 3397|       |
 3398|    214|   if (scanline != scanline_data)
  ------------------
  |  Branch (3398:8): [True: 0, False: 214]
  ------------------
 3399|      0|      STBTT_free(scanline, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3400|    214|}
imgui_draw.cpp:_ZL17stbtt__hheap_freeP12stbtt__hheapPv:
 2797|  5.20k|{
 2798|  5.20k|   *(void **) p = hh->first_free;
 2799|  5.20k|   hh->first_free = p;
 2800|  5.20k|}
imgui_draw.cpp:_ZL17stbtt__new_activeP12stbtt__hheapP11stbtt__edgeifPv:
 2863|  6.32k|{
 2864|  6.32k|   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
 2865|  6.32k|   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
 2866|  6.32k|   STBTT_assert(z != NULL);
  ------------------
  |  |  133|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2867|       |   //STBTT_assert(e->y0 <= start_point);
 2868|  6.32k|   if (!z) return z;
  ------------------
  |  Branch (2868:8): [True: 0, False: 6.32k]
  ------------------
 2869|  6.32k|   z->fdx = dxdy;
 2870|  6.32k|   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
  ------------------
  |  Branch (2870:13): [True: 0, False: 6.32k]
  ------------------
 2871|  6.32k|   z->fx = e->x0 + dxdy * (start_point - e->y0);
 2872|  6.32k|   z->fx -= off_x;
 2873|  6.32k|   z->direction = e->invert ? 1.0f : -1.0f;
  ------------------
  |  Branch (2873:19): [True: 3.16k, False: 3.16k]
  ------------------
 2874|  6.32k|   z->sy = e->y0;
 2875|  6.32k|   z->ey = e->y1;
 2876|  6.32k|   z->next = 0;
 2877|  6.32k|   return z;
 2878|  6.32k|}
imgui_draw.cpp:_ZL18stbtt__hheap_allocP12stbtt__hheapmPv:
 2776|  6.32k|{
 2777|  6.32k|   if (hh->first_free) {
  ------------------
  |  Branch (2777:8): [True: 4.07k, False: 2.24k]
  ------------------
 2778|  4.07k|      void *p = hh->first_free;
 2779|  4.07k|      hh->first_free = * (void **) p;
 2780|  4.07k|      return p;
 2781|  4.07k|   } else {
 2782|  2.24k|      if (hh->num_remaining_in_head_chunk == 0) {
  ------------------
  |  Branch (2782:11): [True: 214, False: 2.03k]
  ------------------
 2783|    214|         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
  ------------------
  |  Branch (2783:23): [True: 0, False: 214]
  |  Branch (2783:42): [True: 214, False: 0]
  ------------------
 2784|    214|         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1880|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 2785|    214|         if (c == NULL)
  ------------------
  |  Branch (2785:14): [True: 0, False: 214]
  ------------------
 2786|      0|            return NULL;
 2787|    214|         c->next = hh->head;
 2788|    214|         hh->head = c;
 2789|    214|         hh->num_remaining_in_head_chunk = count;
 2790|    214|      }
 2791|  2.24k|      --hh->num_remaining_in_head_chunk;
 2792|  2.24k|      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
 2793|  2.24k|   }
 2794|  6.32k|}
imgui_draw.cpp:_ZL28stbtt__fill_active_edges_newPfS_iP18stbtt__active_edgef:
 3088|  1.61k|{
 3089|  1.61k|   float y_bottom = y_top+1;
 3090|       |
 3091|  13.2k|   while (e) {
  ------------------
  |  Branch (3091:11): [True: 11.6k, False: 1.61k]
  ------------------
 3092|       |      // brute force every pixel
 3093|       |
 3094|       |      // compute intersection points with top & bottom
 3095|  11.6k|      STBTT_assert(e->ey >= y_top);
  ------------------
  |  |  133|  11.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  11.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3096|       |
 3097|  11.6k|      if (e->fdx == 0) {
  ------------------
  |  Branch (3097:11): [True: 11.6k, False: 0]
  ------------------
 3098|  11.6k|         float x0 = e->fx;
 3099|  11.6k|         if (x0 < len) {
  ------------------
  |  Branch (3099:14): [True: 10.3k, False: 1.36k]
  ------------------
 3100|  10.3k|            if (x0 >= 0) {
  ------------------
  |  Branch (3100:17): [True: 10.3k, False: 0]
  ------------------
 3101|  10.3k|               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
 3102|  10.3k|               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
 3103|  10.3k|            } else {
 3104|      0|               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
 3105|      0|            }
 3106|  10.3k|         }
 3107|  11.6k|      } else {
 3108|      0|         float x0 = e->fx;
 3109|      0|         float dx = e->fdx;
 3110|      0|         float xb = x0 + dx;
 3111|      0|         float x_top, x_bottom;
 3112|      0|         float sy0,sy1;
 3113|      0|         float dy = e->fdy;
 3114|      0|         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3115|       |
 3116|       |         // compute endpoints of line segment clipped to this scanline (if the
 3117|       |         // line segment starts on this scanline. x0 is the intersection of the
 3118|       |         // line with y_top, but that may be off the line segment.
 3119|      0|         if (e->sy > y_top) {
  ------------------
  |  Branch (3119:14): [True: 0, False: 0]
  ------------------
 3120|      0|            x_top = x0 + dx * (e->sy - y_top);
 3121|      0|            sy0 = e->sy;
 3122|      0|         } else {
 3123|      0|            x_top = x0;
 3124|      0|            sy0 = y_top;
 3125|      0|         }
 3126|      0|         if (e->ey < y_bottom) {
  ------------------
  |  Branch (3126:14): [True: 0, False: 0]
  ------------------
 3127|      0|            x_bottom = x0 + dx * (e->ey - y_top);
 3128|      0|            sy1 = e->ey;
 3129|      0|         } else {
 3130|      0|            x_bottom = xb;
 3131|      0|            sy1 = y_bottom;
 3132|      0|         }
 3133|       |
 3134|      0|         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
  ------------------
  |  Branch (3134:14): [True: 0, False: 0]
  |  Branch (3134:28): [True: 0, False: 0]
  |  Branch (3134:45): [True: 0, False: 0]
  |  Branch (3134:60): [True: 0, False: 0]
  ------------------
 3135|       |            // from here on, we don't have to range check x values
 3136|       |
 3137|      0|            if ((int) x_top == (int) x_bottom) {
  ------------------
  |  Branch (3137:17): [True: 0, False: 0]
  ------------------
 3138|      0|               float height;
 3139|       |               // simple case, only spans one pixel
 3140|      0|               int x = (int) x_top;
 3141|      0|               height = (sy1 - sy0) * e->direction;
 3142|      0|               STBTT_assert(x >= 0 && x < len);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3143|      0|               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
 3144|      0|               scanline_fill[x] += height; // everything right of this pixel is filled
 3145|      0|            } else {
 3146|      0|               int x,x1,x2;
 3147|      0|               float y_crossing, y_final, step, sign, area;
 3148|       |               // covers 2+ pixels
 3149|      0|               if (x_top > x_bottom) {
  ------------------
  |  Branch (3149:20): [True: 0, False: 0]
  ------------------
 3150|       |                  // flip scanline vertically; signed area is the same
 3151|      0|                  float t;
 3152|      0|                  sy0 = y_bottom - (sy0 - y_top);
 3153|      0|                  sy1 = y_bottom - (sy1 - y_top);
 3154|      0|                  t = sy0, sy0 = sy1, sy1 = t;
 3155|      0|                  t = x_bottom, x_bottom = x_top, x_top = t;
 3156|      0|                  dx = -dx;
 3157|      0|                  dy = -dy;
 3158|      0|                  t = x0, x0 = xb, xb = t;
 3159|      0|               }
 3160|      0|               STBTT_assert(dy >= 0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3161|      0|               STBTT_assert(dx >= 0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3162|       |
 3163|      0|               x1 = (int) x_top;
 3164|      0|               x2 = (int) x_bottom;
 3165|       |               // compute intersection with y axis at x1+1
 3166|      0|               y_crossing = y_top + dy * (x1+1 - x0);
 3167|       |
 3168|       |               // compute intersection with y axis at x2
 3169|      0|               y_final = y_top + dy * (x2 - x0);
 3170|       |
 3171|       |               //           x1    x_top                            x2    x_bottom
 3172|       |               //     y_top  +------|-----+------------+------------+--------|---+------------+
 3173|       |               //            |            |            |            |            |            |
 3174|       |               //            |            |            |            |            |            |
 3175|       |               //       sy0  |      Txxxxx|............|............|............|............|
 3176|       |               // y_crossing |            *xxxxx.......|............|............|............|
 3177|       |               //            |            |     xxxxx..|............|............|............|
 3178|       |               //            |            |     /-   xx*xxxx........|............|............|
 3179|       |               //            |            | dy <       |    xxxxxx..|............|............|
 3180|       |               //   y_final  |            |     \-     |          xx*xxx.........|............|
 3181|       |               //       sy1  |            |            |            |   xxxxxB...|............|
 3182|       |               //            |            |            |            |            |            |
 3183|       |               //            |            |            |            |            |            |
 3184|       |               //  y_bottom  +------------+------------+------------+------------+------------+
 3185|       |               //
 3186|       |               // goal is to measure the area covered by '.' in each pixel
 3187|       |
 3188|       |               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
 3189|       |               // @TODO: maybe test against sy1 rather than y_bottom?
 3190|      0|               if (y_crossing > y_bottom)
  ------------------
  |  Branch (3190:20): [True: 0, False: 0]
  ------------------
 3191|      0|                  y_crossing = y_bottom;
 3192|       |
 3193|      0|               sign = e->direction;
 3194|       |
 3195|       |               // area of the rectangle covered from sy0..y_crossing
 3196|      0|               area = sign * (y_crossing-sy0);
 3197|       |
 3198|       |               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
 3199|      0|               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);
 3200|       |
 3201|       |               // check if final y_crossing is blown up; no test case for this
 3202|      0|               if (y_final > y_bottom) {
  ------------------
  |  Branch (3202:20): [True: 0, False: 0]
  ------------------
 3203|      0|                  int denom = (x2 - (x1+1));
 3204|      0|                  y_final = y_bottom;
 3205|      0|                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
  ------------------
  |  Branch (3205:23): [True: 0, False: 0]
  ------------------
 3206|      0|                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
 3207|      0|                  }
 3208|      0|               }
 3209|       |
 3210|       |               // in second pixel, area covered by line segment found in first pixel
 3211|       |               // is always a rectangle 1 wide * the height of that line segment; this
 3212|       |               // is exactly what the variable 'area' stores. it also gets a contribution
 3213|       |               // from the line segment within it. the THIRD pixel will get the first
 3214|       |               // pixel's rectangle contribution, the second pixel's rectangle contribution,
 3215|       |               // and its own contribution. the 'own contribution' is the same in every pixel except
 3216|       |               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
 3217|       |               // the second pixel's contribution to the third pixel will be the
 3218|       |               // rectangle 1 wide times the height change in the second pixel, which is dy.
 3219|       |
 3220|      0|               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
 3221|       |               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
 3222|       |               // so the area advances by 'step' every time
 3223|       |
 3224|      0|               for (x = x1+1; x < x2; ++x) {
  ------------------
  |  Branch (3224:31): [True: 0, False: 0]
  ------------------
 3225|      0|                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
 3226|      0|                  area += step;
 3227|      0|               }
 3228|      0|               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3229|      0|               STBTT_assert(sy1 > y_final-0.01f);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3230|       |
 3231|       |               // area covered in the last pixel is the rectangle from all the pixels to the left,
 3232|       |               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
 3233|      0|               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);
 3234|       |
 3235|       |               // the rest of the line is filled based on the total height of the line segment in this pixel
 3236|      0|               scanline_fill[x2] += sign * (sy1-sy0);
 3237|      0|            }
 3238|      0|         } else {
 3239|       |            // if edge goes outside of box we're drawing, we require
 3240|       |            // clipping logic. since this does not match the intended use
 3241|       |            // of this library, we use a different, very slow brute
 3242|       |            // force implementation
 3243|       |            // note though that this does happen some of the time because
 3244|       |            // x_top and x_bottom can be extrapolated at the top & bottom of
 3245|       |            // the shape and actually lie outside the bounding box
 3246|      0|            int x;
 3247|      0|            for (x=0; x < len; ++x) {
  ------------------
  |  Branch (3247:23): [True: 0, False: 0]
  ------------------
 3248|       |               // cases:
 3249|       |               //
 3250|       |               // there can be up to two intersections with the pixel. any intersection
 3251|       |               // with left or right edges can be handled by splitting into two (or three)
 3252|       |               // regions. intersections with top & bottom do not necessitate case-wise logic.
 3253|       |               //
 3254|       |               // the old way of doing this found the intersections with the left & right edges,
 3255|       |               // then used some simple logic to produce up to three segments in sorted order
 3256|       |               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
 3257|       |               // across the x border, then the corresponding y position might not be distinct
 3258|       |               // from the other y segment, and it might ignored as an empty segment. to avoid
 3259|       |               // that, we need to explicitly produce segments based on x positions.
 3260|       |
 3261|       |               // rename variables to clearly-defined pairs
 3262|      0|               float y0 = y_top;
 3263|      0|               float x1 = (float) (x);
 3264|      0|               float x2 = (float) (x+1);
 3265|      0|               float x3 = xb;
 3266|      0|               float y3 = y_bottom;
 3267|       |
 3268|       |               // x = e->x + e->dx * (y-y_top)
 3269|       |               // (y-y_top) = (x - e->x) / e->dx
 3270|       |               // y = (x - e->x) / e->dx + y_top
 3271|      0|               float y1 = (x - x0) / dx + y_top;
 3272|      0|               float y2 = (x+1 - x0) / dx + y_top;
 3273|       |
 3274|      0|               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
  ------------------
  |  Branch (3274:20): [True: 0, False: 0]
  |  Branch (3274:31): [True: 0, False: 0]
  ------------------
 3275|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3276|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
 3277|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3278|      0|               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
  ------------------
  |  Branch (3278:27): [True: 0, False: 0]
  |  Branch (3278:38): [True: 0, False: 0]
  ------------------
 3279|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3280|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
 3281|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3282|      0|               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
  ------------------
  |  Branch (3282:27): [True: 0, False: 0]
  |  Branch (3282:38): [True: 0, False: 0]
  ------------------
 3283|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3284|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3285|      0|               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
  ------------------
  |  Branch (3285:27): [True: 0, False: 0]
  |  Branch (3285:38): [True: 0, False: 0]
  ------------------
 3286|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3287|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3288|      0|               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
  ------------------
  |  Branch (3288:27): [True: 0, False: 0]
  |  Branch (3288:38): [True: 0, False: 0]
  ------------------
 3289|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3290|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3291|      0|               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
  ------------------
  |  Branch (3291:27): [True: 0, False: 0]
  |  Branch (3291:38): [True: 0, False: 0]
  ------------------
 3292|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3293|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3294|      0|               } else {  // one segment
 3295|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
 3296|      0|               }
 3297|      0|            }
 3298|      0|         }
 3299|      0|      }
 3300|  11.6k|      e = e->next;
 3301|  11.6k|   }
 3302|  1.61k|}
imgui_draw.cpp:_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff:
 3034|  20.6k|{
 3035|  20.6k|   if (y0 == y1) return;
  ------------------
  |  Branch (3035:8): [True: 0, False: 20.6k]
  ------------------
 3036|  20.6k|   STBTT_assert(y0 < y1);
  ------------------
  |  |  133|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3037|  20.6k|   STBTT_assert(e->sy <= e->ey);
  ------------------
  |  |  133|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3038|  20.6k|   if (y0 > e->ey) return;
  ------------------
  |  Branch (3038:8): [True: 0, False: 20.6k]
  ------------------
 3039|  20.6k|   if (y1 < e->sy) return;
  ------------------
  |  Branch (3039:8): [True: 0, False: 20.6k]
  ------------------
 3040|  20.6k|   if (y0 < e->sy) {
  ------------------
  |  Branch (3040:8): [True: 9.44k, False: 11.1k]
  ------------------
 3041|  9.44k|      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
 3042|  9.44k|      y0 = e->sy;
 3043|  9.44k|   }
 3044|  20.6k|   if (y1 > e->ey) {
  ------------------
  |  Branch (3044:8): [True: 0, False: 20.6k]
  ------------------
 3045|      0|      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
 3046|      0|      y1 = e->ey;
 3047|      0|   }
 3048|       |
 3049|  20.6k|   if (x0 == x)
  ------------------
  |  Branch (3049:8): [True: 10.3k, False: 10.3k]
  ------------------
 3050|  10.3k|      STBTT_assert(x1 <= x+1);
  ------------------
  |  |  133|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3051|  10.3k|   else if (x0 == x+1)
  ------------------
  |  Branch (3051:13): [True: 0, False: 10.3k]
  ------------------
 3052|      0|      STBTT_assert(x1 >= x);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3053|  10.3k|   else if (x0 <= x)
  ------------------
  |  Branch (3053:13): [True: 10.3k, False: 0]
  ------------------
 3054|  10.3k|      STBTT_assert(x1 <= x);
  ------------------
  |  |  133|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3055|      0|   else if (x0 >= x+1)
  ------------------
  |  Branch (3055:13): [True: 0, False: 0]
  ------------------
 3056|      0|      STBTT_assert(x1 >= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3057|      0|   else
 3058|      0|      STBTT_assert(x1 >= x && x1 <= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3059|       |
 3060|  20.6k|   if (x0 <= x && x1 <= x)
  ------------------
  |  Branch (3060:8): [True: 20.6k, False: 0]
  |  Branch (3060:19): [True: 20.6k, False: 0]
  ------------------
 3061|  20.6k|      scanline[x] += e->direction * (y1-y0);
 3062|      0|   else if (x0 >= x+1 && x1 >= x+1)
  ------------------
  |  Branch (3062:13): [True: 0, False: 0]
  |  Branch (3062:26): [True: 0, False: 0]
  ------------------
 3063|      0|      ;
 3064|      0|   else {
 3065|      0|      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3066|      0|      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
 3067|      0|   }
 3068|  20.6k|}
imgui_draw.cpp:_ZL20stbtt__hheap_cleanupP12stbtt__hheapPv:
 2803|    214|{
 2804|    214|   stbtt__hheap_chunk *c = hh->head;
 2805|    428|   while (c) {
  ------------------
  |  Branch (2805:11): [True: 214, False: 214]
  ------------------
 2806|    214|      stbtt__hheap_chunk *n = c->next;
 2807|    214|      STBTT_free(c, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 2808|    214|      c = n;
 2809|    214|   }
 2810|    214|}
imgui_draw.cpp:_ZL13stbtt_PackEndP18stbtt_pack_context:
 3998|      1|{
 3999|      1|   STBTT_free(spc->nodes    , spc->user_allocator_context);
  ------------------
  |  |  132|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4000|      1|   STBTT_free(spc->pack_info, spc->user_allocator_context);
  ------------------
  |  |  132|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1881|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4001|      1|}
imgui_draw.cpp:_ZL21stbtt_GetFontVMetricsPK14stbtt_fontinfoPiS2_S2_:
 2640|      1|{
 2641|      1|   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
  ------------------
  |  Branch (2641:8): [True: 1, False: 0]
  ------------------
 2642|      1|   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
  ------------------
  |  Branch (2642:8): [True: 1, False: 0]
  ------------------
 2643|      1|   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
  ------------------
  |  Branch (2643:8): [True: 1, False: 0]
  ------------------
 2644|      1|}
imgui_draw.cpp:_ZL19stbtt_GetPackedQuadPK16stbtt_packedchariiiPfS2_P18stbtt_aligned_quadi:
 4372|    223|{
 4373|    223|   float ipw = 1.0f / pw, iph = 1.0f / ph;
 4374|    223|   const stbtt_packedchar *b = chardata + char_index;
 4375|       |
 4376|    223|   if (align_to_integer) {
  ------------------
  |  Branch (4376:8): [True: 0, False: 223]
  ------------------
 4377|      0|      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
  ------------------
  |  |  138|      0|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
 4378|      0|      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
  ------------------
  |  |  138|      0|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
 4379|      0|      q->x0 = x;
 4380|      0|      q->y0 = y;
 4381|      0|      q->x1 = x + b->xoff2 - b->xoff;
 4382|      0|      q->y1 = y + b->yoff2 - b->yoff;
 4383|    223|   } else {
 4384|    223|      q->x0 = *xpos + b->xoff;
 4385|    223|      q->y0 = *ypos + b->yoff;
 4386|    223|      q->x1 = *xpos + b->xoff2;
 4387|    223|      q->y1 = *ypos + b->yoff2;
 4388|    223|   }
 4389|       |
 4390|    223|   q->s0 = b->x0 * ipw;
 4391|    223|   q->t0 = b->y0 * iph;
 4392|    223|   q->s1 = b->x1 * ipw;
 4393|    223|   q->t1 = b->y1 * iph;
 4394|       |
 4395|    223|   *xpos += b->xadvance;
 4396|    223|}

_Z9consume_tIN6dlxemu10CodeEditor11CoordinatesEEN3phi8optionalIT_EEPKhmRm:
  137|  2.37k|{
  138|  2.37k|    GET_T(phi::uint32_t, column);
  ------------------
  |  |   37|  2.37k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.37k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 24, False: 2.35k]
  |  |  ------------------
  |  |   39|  2.37k|    {                                                                                              \
  |  |   40|     24|        return {};                                                                                 \
  |  |   41|     24|    }                                                                                              \
  |  |   42|  2.37k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  139|  2.35k|    GET_T(phi::uint32_t, line);
  ------------------
  |  |   37|  2.35k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.35k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 7, False: 2.34k]
  |  |  ------------------
  |  |   39|  2.35k|    {                                                                                              \
  |  |   40|      7|        return {};                                                                                 \
  |  |   41|      7|    }                                                                                              \
  |  |   42|  2.35k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  140|       |
  141|  2.34k|    return dlxemu::CodeEditor::Coordinates{column, line};
  142|  2.35k|}
_Z14consume_stringPKhmRm:
  146|  20.6k|{
  147|       |    // Ensure we're not already past the available data
  148|  20.6k|    if (index >= size)
  ------------------
  |  Branch (148:9): [True: 126, False: 20.5k]
  ------------------
  149|    126|    {
  150|    126|        return false;
  151|    126|    }
  152|       |
  153|  20.5k|    const char* str_begin = reinterpret_cast<const char*>(data + index);
  154|  20.5k|    phi::size_t str_len   = 0u;
  155|       |
  156|  26.4k|    while (index < size && data[index] != '\0')
  ------------------
  |  Branch (156:12): [True: 26.3k, False: 62]
  |  Branch (156:28): [True: 5.93k, False: 20.4k]
  ------------------
  157|  5.93k|    {
  158|  5.93k|        ++index;
  159|  5.93k|        ++str_len;
  160|  5.93k|    }
  161|       |
  162|       |    // Reject too long strings
  163|  20.5k|    if (str_len > MaxStringLength)
  ------------------
  |  Branch (163:9): [True: 111, False: 20.3k]
  ------------------
  164|    111|    {
  165|    111|        return false;
  166|    111|    }
  167|       |
  168|  20.3k|    PHI_ASSERT(index <= size);
  169|       |    // Reject strings that are not null terminated
  170|  20.3k|    if (data[index - 1u] != '\0')
  ------------------
  |  Branch (170:9): [True: 851, False: 19.5k]
  ------------------
  171|    851|    {
  172|    851|        return false;
  173|    851|    }
  174|       |
  175|       |    // Move back to proper alignment
  176|  19.5k|    index += (sizeof(void*) - (index % sizeof(void*)));
  177|       |
  178|       |    // Assign string value to cache
  179|  19.5k|    cache.string = str_begin;
  180|       |
  181|  19.5k|    return true;
  182|  20.3k|}
_Z21consume_vector_stringPKhmRm:
  188|    848|{
  189|    848|    GET_T(phi::size_t, number_of_lines);
  ------------------
  |  |   37|    848|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    848|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 5, False: 843]
  |  |  ------------------
  |  |   39|    848|    {                                                                                              \
  |  |   40|      5|        return {};                                                                                 \
  |  |   41|      5|    }                                                                                              \
  |  |   42|    848|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  190|       |
  191|    843|    if (number_of_lines >= MaxVectorSize)
  ------------------
  |  Branch (191:9): [True: 9, False: 834]
  ------------------
  192|      9|    {
  193|      9|        return {};
  194|      9|    }
  195|       |
  196|    834|    std::vector<std::string>& res = cache.vector_string[number_of_lines];
  197|  4.83k|    for (phi::size_t i{0u}; i < number_of_lines; ++i)
  ------------------
  |  Branch (197:29): [True: 4.00k, False: 825]
  ------------------
  198|  4.00k|    {
  199|  4.00k|        if (!consume_string(data, size, index))
  ------------------
  |  Branch (199:13): [True: 9, False: 3.99k]
  ------------------
  200|      9|        {
  201|      9|            return {};
  202|      9|        }
  203|       |
  204|  3.99k|        res[i] = cache.string;
  205|  3.99k|    }
  206|       |
  207|    825|    return number_of_lines;
  208|    834|}
_Z13IsReservedKey8ImGuiKey:
  321|  2.37k|{
  322|  2.37k|    switch (key)
  323|  2.37k|    {
  324|      2|        case ImGuiKey_ReservedForModCtrl:
  ------------------
  |  Branch (324:9): [True: 2, False: 2.37k]
  ------------------
  325|      2|        case ImGuiKey_ReservedForModShift:
  ------------------
  |  Branch (325:9): [True: 0, False: 2.37k]
  ------------------
  326|      2|        case ImGuiKey_ReservedForModAlt:
  ------------------
  |  Branch (326:9): [True: 0, False: 2.37k]
  ------------------
  327|      2|        case ImGuiKey_ReservedForModSuper:
  ------------------
  |  Branch (327:9): [True: 0, False: 2.37k]
  ------------------
  328|      2|            return true;
  329|       |
  330|  2.37k|        default:
  ------------------
  |  Branch (330:9): [True: 2.37k, False: 2]
  ------------------
  331|  2.37k|            return false;
  332|  2.37k|    }
  333|  2.37k|}
_Z10SetupImGuiv:
  336|      1|{
  337|      1|    IMGUI_CHECKVERSION();
  338|      1|    if (GImGui != nullptr)
  ------------------
  |  Branch (338:9): [True: 0, False: 1]
  ------------------
  339|      0|    {
  340|      0|        return true;
  341|      0|    }
  342|       |
  343|      1|    if (ImGui::CreateContext() == nullptr)
  ------------------
  |  Branch (343:9): [True: 0, False: 1]
  ------------------
  344|      0|    {
  345|      0|        FUZZ_LOG("Failed to create ImGuiContext");
  ------------------
  |  |   33|      0|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  346|      0|        return false;
  347|      0|    }
  348|       |
  349|       |    // Set config
  350|      1|    ImGuiIO& io = ImGui::GetIO();
  351|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
  352|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;  // Enable Gamepad Controls
  353|      1|    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;     // Enable Docking
  354|      1|    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; // Enable Multi-Viewport / Platform Windows
  355|       |
  356|       |    // Enforce valid display size
  357|      1|    io.DisplaySize.x = 1024.0f;
  358|      1|    io.DisplaySize.y = 768.0f;
  359|       |
  360|       |    // Enfore valid DeltaTime
  361|      1|    io.DeltaTime = 1.0f / 60.0f;
  362|       |
  363|       |    // Don't save any config
  364|      1|    io.IniFilename = nullptr;
  365|       |
  366|       |    // SetStyle
  367|      1|    ImGuiStyle& style = ImGui::GetStyle();
  368|      1|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (368:9): [True: 1, False: 0]
  ------------------
  369|      1|    {
  370|      1|        style.WindowRounding              = 0.0f;
  371|      1|        style.Colors[ImGuiCol_WindowBg].w = 1.0f;
  372|      1|    }
  373|       |
  374|       |    // Build atlas
  375|      1|    unsigned char* tex_pixels{nullptr};
  376|      1|    int            tex_w;
  377|      1|    int            tex_h;
  378|      1|    io.Fonts->GetTexDataAsRGBA32(&tex_pixels, &tex_w, &tex_h);
  379|       |
  380|      1|    return true;
  381|      1|}
_Z8EndImGuiv:
  384|  29.3k|{
  385|  29.3k|    ImGui::Render();
  386|       |
  387|  29.3k|    volatile ImDrawData* draw_data = ImGui::GetDrawData();
  388|  29.3k|    PHI_UNUSED_VARIABLE(draw_data);
  389|       |
  390|  29.3k|    ImGuiIO& io = ImGui::GetIO();
  391|       |    // Update and Render additional Platform Windows
  392|       |    // (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.
  393|  29.3k|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (393:9): [True: 0, False: 29.3k]
  ------------------
  394|      0|    {
  395|      0|        ImGui::UpdatePlatformWindows();
  396|      0|        ImGui::RenderPlatformWindowsDefault();
  397|      0|    }
  398|       |
  399|  29.3k|    ImGui::EndFrame();
  400|       |
  401|       |    // Ensure frame count doesn't overflow
  402|  29.3k|    GImGui->FrameCount %= 16384;
  403|  29.3k|}
LLVMFuzzerTestOneInput:
  407|  6.34k|{
  408|  6.34k|    static bool imgui_init = SetupImGui();
  409|  6.34k|    (void)imgui_init;
  410|       |
  411|       |    // Reset some ImGui states
  412|  6.34k|    ImGui::GetIO().ClearInputKeys();
  413|  6.34k|    ImGui::GetIO().InputQueueSurrogate = 0;
  414|  6.34k|    GImGui->InputEventsQueue.resize(0u);
  415|  6.34k|    ImGui::FocusWindow(nullptr);
  416|       |
  417|  6.34k|    dlxemu::Emulator   emulator;
  418|  6.34k|    dlxemu::CodeEditor editor{&emulator};
  419|       |
  420|  6.34k|    editor.UpdatePalette();
  421|       |
  422|  6.34k|    FUZZ_LOG("Beginning execution");
  ------------------
  |  |   33|  6.34k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  423|       |
  424|   437k|    for (phi::size_t index{0u}; index < size;)
  ------------------
  |  Branch (424:33): [True: 434k, False: 3.29k]
  ------------------
  425|   434k|    {
  426|   434k|        GET_T(phi::uint32_t, function_index);
  ------------------
  |  |   37|   434k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|   434k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1.36k, False: 433k]
  |  |  ------------------
  |  |   39|   434k|    {                                                                                              \
  |  |   40|  1.36k|        return {};                                                                                 \
  |  |   41|  1.36k|    }                                                                                              \
  |  |   42|   434k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  427|       |
  428|   433k|        switch (function_index)
  ------------------
  |  Branch (428:17): [True: 307k, False: 125k]
  ------------------
  429|   433k|        {
  430|       |            // AddErrorMarker
  431|  15.4k|            case 0: {
  ------------------
  |  Branch (431:13): [True: 15.4k, False: 417k]
  ------------------
  432|  15.4k|                GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   37|  15.4k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  15.4k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 204, False: 15.2k]
  |  |  ------------------
  |  |   39|  15.4k|    {                                                                                              \
  |  |   40|    204|        return {};                                                                                 \
  |  |   41|    204|    }                                                                                              \
  |  |   42|  15.4k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  433|       |
  434|  15.2k|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (434:21): [True: 1.02k, False: 14.1k]
  ------------------
  435|  1.02k|                {
  436|  1.02k|                    return 0;
  437|  1.02k|                }
  438|  14.1k|                std::string& message = cache.string;
  439|       |
  440|  14.1k|                FUZZ_LOG("AddErrorMarker({:s}, {:s})", print_int(line_number),
  ------------------
  |  |   33|  14.1k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  441|  14.1k|                         print_string(message));
  442|       |
  443|  14.1k|                editor.AddErrorMarker(line_number, message);
  444|  14.1k|                break;
  445|  15.2k|            }
  446|       |
  447|       |            // ClearErrorMarkers
  448|    611|            case 1: {
  ------------------
  |  Branch (448:13): [True: 611, False: 432k]
  ------------------
  449|    611|                FUZZ_LOG("ClearErrorMarkers");
  ------------------
  |  |   33|    611|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  450|       |
  451|    611|                editor.ClearErrorMarkers();
  452|    611|                break;
  453|  15.2k|            }
  454|       |
  455|       |            // SetText
  456|    152|            case 2: {
  ------------------
  |  Branch (456:13): [True: 152, False: 432k]
  ------------------
  457|    152|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (457:21): [True: 17, False: 135]
  ------------------
  458|     17|                {
  459|     17|                    return 0;
  460|     17|                }
  461|    135|                std::string& text = cache.string;
  462|       |
  463|    135|                FUZZ_LOG("SetText({:s})", print_string(text));
  ------------------
  |  |   33|    135|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  464|       |
  465|    135|                editor.SetText(text);
  466|    135|                break;
  467|    152|            }
  468|       |
  469|       |            // GetText
  470|  2.29k|            case 3: {
  ------------------
  |  Branch (470:13): [True: 2.29k, False: 430k]
  ------------------
  471|  2.29k|                FUZZ_LOG("GetText()");
  ------------------
  |  |   33|  2.29k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  472|       |
  473|  2.29k|                volatile std::string str = editor.GetText();
  474|  2.29k|                PHI_UNUSED_VARIABLE(str);
  475|  2.29k|                break;
  476|    152|            }
  477|       |
  478|       |            // SetTextLines
  479|    848|            case 4: {
  ------------------
  |  Branch (479:13): [True: 848, False: 432k]
  ------------------
  480|    848|                auto lines_opt = consume_vector_string(data, size, index);
  481|    848|                if (!lines_opt)
  ------------------
  |  Branch (481:21): [True: 23, False: 825]
  ------------------
  482|     23|                {
  483|     23|                    return 0;
  484|     23|                }
  485|       |
  486|    825|                const std::vector<std::string>& lines = cache.vector_string[lines_opt.value()];
  487|       |
  488|    825|                FUZZ_LOG("SetTextLines({:s})", print_vector_string(lines));
  ------------------
  |  |   33|    825|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  489|    825|                editor.SetTextLines(lines);
  490|    825|                break;
  491|    848|            }
  492|       |
  493|       |            // GetTextLines
  494|    287|            case 5: {
  ------------------
  |  Branch (494:13): [True: 287, False: 432k]
  ------------------
  495|    287|                FUZZ_LOG("GetTextLines()");
  ------------------
  |  |   33|    287|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  496|       |
  497|    287|                volatile std::vector<std::string> lines = editor.GetTextLines();
  498|    287|                PHI_UNUSED_VARIABLE(lines);
  499|    287|                break;
  500|    848|            }
  501|       |
  502|       |            // GetSelectedText
  503|    262|            case 6: {
  ------------------
  |  Branch (503:13): [True: 262, False: 432k]
  ------------------
  504|    262|                FUZZ_LOG("GetSelectedText()");
  ------------------
  |  |   33|    262|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  505|       |
  506|    262|                volatile std::string line = editor.GetSelectedText();
  507|    262|                PHI_UNUSED_VARIABLE(line);
  508|    262|                break;
  509|    848|            }
  510|       |
  511|       |            // GetCurrentLineText
  512|    483|            case 7: {
  ------------------
  |  Branch (512:13): [True: 483, False: 432k]
  ------------------
  513|    483|                FUZZ_LOG("GetCurrentLineText()");
  ------------------
  |  |   33|    483|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  514|       |
  515|    483|                volatile std::string line = editor.GetCurrentLineText();
  516|    483|                PHI_UNUSED_VARIABLE(line);
  517|    483|                break;
  518|    848|            }
  519|       |
  520|       |            // SetReadOnly
  521|    306|            case 8: {
  ------------------
  |  Branch (521:13): [True: 306, False: 432k]
  ------------------
  522|    306|                GET_T(bool, read_only);
  ------------------
  |  |   37|    306|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    306|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 305]
  |  |  ------------------
  |  |   39|    306|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    306|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  523|       |
  524|    305|                FUZZ_LOG("SetReadOnly({:s})", print_bool(read_only));
  ------------------
  |  |   33|    305|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  525|    305|                editor.SetReadOnly(read_only);
  526|    305|                break;
  527|    306|            }
  528|       |
  529|       |            // GetCursorPosition
  530|    306|            case 9: {
  ------------------
  |  Branch (530:13): [True: 306, False: 432k]
  ------------------
  531|    306|                FUZZ_LOG("GetCursorPosition()");
  ------------------
  |  |   33|    306|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  532|       |
  533|    306|                volatile dlxemu::CodeEditor::Coordinates coords = editor.GetCursorPosition();
  534|    306|                PHI_UNUSED_VARIABLE(coords);
  535|    306|                break;
  536|    306|            }
  537|       |
  538|       |            // SetCursorPosition
  539|  1.13k|            case 10: {
  ------------------
  |  Branch (539:13): [True: 1.13k, False: 431k]
  ------------------
  540|  1.13k|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   37|  1.13k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  1.13k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 21, False: 1.11k]
  |  |  ------------------
  |  |   39|  1.13k|    {                                                                                              \
  |  |   40|     21|        return {};                                                                                 \
  |  |   41|     21|    }                                                                                              \
  |  |   42|  1.13k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  541|       |
  542|  1.11k|                FUZZ_LOG("SetCursorPosition(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   33|  1.11k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  543|  1.11k|                         print_int(coords.m_Column));
  544|  1.11k|                editor.SetCursorPosition(coords);
  545|  1.11k|                break;
  546|  1.13k|            }
  547|       |
  548|       |            // SetShowWhitespaces
  549|     79|            case 11: {
  ------------------
  |  Branch (549:13): [True: 79, False: 432k]
  ------------------
  550|     79|                GET_T(bool, show_whitespaces);
  ------------------
  |  |   37|     79|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|     79|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 78]
  |  |  ------------------
  |  |   39|     79|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|     79|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  551|       |
  552|     78|                FUZZ_LOG("SetShowShitespaces({:s})", print_bool(show_whitespaces));
  ------------------
  |  |   33|     78|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  553|     78|                editor.SetShowWhitespaces(show_whitespaces);
  554|     78|                break;
  555|     79|            }
  556|       |
  557|       |            // SetTabSize
  558|    329|            case 12: {
  ------------------
  |  Branch (558:13): [True: 329, False: 432k]
  ------------------
  559|    329|                GET_T(phi::uint_fast8_t, tab_size);
  ------------------
  |  |   37|    329|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    329|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 328]
  |  |  ------------------
  |  |   39|    329|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    329|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  560|       |
  561|    328|                FUZZ_LOG("SetTabSize({:s})", print_int(tab_size));
  ------------------
  |  |   33|    328|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  562|    328|                editor.SetTabSize(tab_size);
  563|    328|                break;
  564|    329|            }
  565|       |
  566|       |            // InsertText
  567|    256|            case 13: {
  ------------------
  |  Branch (567:13): [True: 256, False: 432k]
  ------------------
  568|    256|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (568:21): [True: 10, False: 246]
  ------------------
  569|     10|                {
  570|     10|                    return 0;
  571|     10|                }
  572|       |
  573|    246|                std::string& message = cache.string;
  574|       |
  575|    246|                FUZZ_LOG("InsertText({:s})", print_string(message));
  ------------------
  |  |   33|    246|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  576|    246|                editor.InsertText(message);
  577|    246|                break;
  578|    256|            }
  579|       |
  580|       |            // MoveUp
  581|    132|            case 14: {
  ------------------
  |  Branch (581:13): [True: 132, False: 432k]
  ------------------
  582|    132|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|    132|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    132|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 131]
  |  |  ------------------
  |  |   39|    132|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    132|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  583|    131|                GET_T(bool, select);
  ------------------
  |  |   37|    131|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    131|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 130]
  |  |  ------------------
  |  |   39|    131|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    131|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  584|       |
  585|    130|                FUZZ_LOG("MoveUp({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   33|    130|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  586|    130|                editor.MoveUp(amount, select);
  587|    130|                break;
  588|    131|            }
  589|       |
  590|       |            // MoveDown
  591|    332|            case 15: {
  ------------------
  |  Branch (591:13): [True: 332, False: 432k]
  ------------------
  592|    332|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|    332|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    332|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 331]
  |  |  ------------------
  |  |   39|    332|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    332|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  593|    331|                GET_T(bool, select);
  ------------------
  |  |   37|    331|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    331|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 330]
  |  |  ------------------
  |  |   39|    331|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    331|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  594|       |
  595|    330|                FUZZ_LOG("MoveDown({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   33|    330|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  596|    330|                editor.MoveDown(amount, select);
  597|    330|                break;
  598|    331|            }
  599|       |
  600|       |            // MoveLeft
  601|  2.10k|            case 16: {
  ------------------
  |  Branch (601:13): [True: 2.10k, False: 430k]
  ------------------
  602|  2.10k|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|  2.10k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.10k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 4, False: 2.09k]
  |  |  ------------------
  |  |   39|  2.10k|    {                                                                                              \
  |  |   40|      4|        return {};                                                                                 \
  |  |   41|      4|    }                                                                                              \
  |  |   42|  2.10k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  603|  2.09k|                GET_T(bool, select);
  ------------------
  |  |   37|  2.09k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.09k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 2.09k]
  |  |  ------------------
  |  |   39|  2.09k|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|  2.09k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  604|  2.09k|                GET_T(bool, word_mode);
  ------------------
  |  |   37|  2.09k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.09k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 2.09k]
  |  |  ------------------
  |  |   39|  2.09k|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|  2.09k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  605|       |
  606|  2.09k|                FUZZ_LOG("MoveLeft({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   33|  2.09k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  607|  2.09k|                         print_bool(word_mode));
  608|  2.09k|                editor.MoveLeft(amount, select, word_mode);
  609|  2.09k|                break;
  610|  2.09k|            }
  611|       |
  612|       |            // MoveRight
  613|    308|            case 17: {
  ------------------
  |  Branch (613:13): [True: 308, False: 432k]
  ------------------
  614|    308|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|    308|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    308|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 307]
  |  |  ------------------
  |  |   39|    308|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    308|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  615|    307|                GET_T(bool, select);
  ------------------
  |  |   37|    307|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    307|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 306]
  |  |  ------------------
  |  |   39|    307|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    307|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  616|    306|                GET_T(bool, word_mode);
  ------------------
  |  |   37|    306|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    306|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 305]
  |  |  ------------------
  |  |   39|    306|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    306|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  617|       |
  618|    305|                FUZZ_LOG("MoveRight({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   33|    305|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  619|    305|                         print_bool(word_mode));
  620|       |
  621|    305|                editor.MoveRight(amount, select, word_mode);
  622|    305|                break;
  623|    306|            }
  624|       |
  625|       |            // MoveTop
  626|  2.62k|            case 18: {
  ------------------
  |  Branch (626:13): [True: 2.62k, False: 430k]
  ------------------
  627|  2.62k|                GET_T(bool, select);
  ------------------
  |  |   37|  2.62k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.62k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 2.61k]
  |  |  ------------------
  |  |   39|  2.62k|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|  2.62k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  628|       |
  629|  2.61k|                FUZZ_LOG("MoveTop({:s})", print_bool(select));
  ------------------
  |  |   33|  2.61k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  630|  2.61k|                editor.MoveTop(select);
  631|  2.61k|                break;
  632|  2.62k|            }
  633|       |
  634|       |            // MoveBottom
  635|    289|            case 19: {
  ------------------
  |  Branch (635:13): [True: 289, False: 432k]
  ------------------
  636|    289|                GET_T(bool, select);
  ------------------
  |  |   37|    289|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    289|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 288]
  |  |  ------------------
  |  |   39|    289|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    289|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  637|       |
  638|    288|                FUZZ_LOG("MoveBottom({:s})", print_bool(select));
  ------------------
  |  |   33|    288|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  639|    288|                editor.MoveBottom(select);
  640|    288|                break;
  641|    289|            }
  642|       |
  643|       |            // MoveHome
  644|    102|            case 20: {
  ------------------
  |  Branch (644:13): [True: 102, False: 432k]
  ------------------
  645|    102|                GET_T(bool, select);
  ------------------
  |  |   37|    102|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    102|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 3, False: 99]
  |  |  ------------------
  |  |   39|    102|    {                                                                                              \
  |  |   40|      3|        return {};                                                                                 \
  |  |   41|      3|    }                                                                                              \
  |  |   42|    102|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  646|       |
  647|     99|                FUZZ_LOG("MoveHome({:s})", print_bool(select));
  ------------------
  |  |   33|     99|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  648|     99|                editor.MoveHome(select);
  649|     99|                break;
  650|    102|            }
  651|       |
  652|       |            // MoveEnd
  653|  1.53k|            case 21: {
  ------------------
  |  Branch (653:13): [True: 1.53k, False: 431k]
  ------------------
  654|  1.53k|                GET_T(bool, select);
  ------------------
  |  |   37|  1.53k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  1.53k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 1.53k]
  |  |  ------------------
  |  |   39|  1.53k|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|  1.53k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  655|       |
  656|  1.53k|                FUZZ_LOG("MoveEnd({:s})", print_bool(select));
  ------------------
  |  |   33|  1.53k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  657|  1.53k|                editor.MoveEnd(select);
  658|  1.53k|                break;
  659|  1.53k|            }
  660|       |
  661|       |            // SetSelectionStart
  662|    158|            case 22: {
  ------------------
  |  Branch (662:13): [True: 158, False: 432k]
  ------------------
  663|    158|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   37|    158|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    158|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 156]
  |  |  ------------------
  |  |   39|    158|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|    158|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  664|       |
  665|    156|                FUZZ_LOG("SetSelectionStart(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   33|    156|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  666|    156|                         print_int(coords.m_Column));
  667|    156|                editor.SetSelectionStart(coords);
  668|    156|                break;
  669|    158|            }
  670|       |
  671|       |            // SetSelectionEnd
  672|    327|            case 23: {
  ------------------
  |  Branch (672:13): [True: 327, False: 432k]
  ------------------
  673|    327|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   37|    327|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    327|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 3, False: 324]
  |  |  ------------------
  |  |   39|    327|    {                                                                                              \
  |  |   40|      3|        return {};                                                                                 \
  |  |   41|      3|    }                                                                                              \
  |  |   42|    327|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  674|       |
  675|    324|                FUZZ_LOG("SetSelectionEnd(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   33|    324|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  676|    324|                         print_int(coords.m_Column));
  677|    324|                editor.SetSelectionEnd(coords);
  678|    324|                break;
  679|    327|            }
  680|       |
  681|       |            // SetSelection
  682|    381|            case 24: {
  ------------------
  |  Branch (682:13): [True: 381, False: 432k]
  ------------------
  683|    381|                GET_T(dlxemu::CodeEditor::Coordinates, coords_start);
  ------------------
  |  |   37|    381|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    381|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 3, False: 378]
  |  |  ------------------
  |  |   39|    381|    {                                                                                              \
  |  |   40|      3|        return {};                                                                                 \
  |  |   41|      3|    }                                                                                              \
  |  |   42|    381|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  684|    378|                GET_T(dlxemu::CodeEditor::Coordinates, coords_end);
  ------------------
  |  |   37|    378|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    378|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 376]
  |  |  ------------------
  |  |   39|    378|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|    378|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  685|    376|                GET_T_COND(dlxemu::CodeEditor::SelectionMode, selection_mode,
  ------------------
  |  |   45|    376|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    376|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    376|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 1, False: 375]
  |  |  |  |  ------------------
  |  |  |  |   39|    376|    {                                                                                              \
  |  |  |  |   40|      1|        return {};                                                                                 \
  |  |  |  |   41|      1|    }                                                                                              \
  |  |  |  |   42|    376|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|    750|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 375, False: 0]
  |  |  |  Branch (46:11): [True: 373, False: 2]
  |  |  ------------------
  |  |   47|    375|    {                                                                                              \
  |  |   48|      2|        return {};                                                                                 \
  |  |   49|      2|    }                                                                                              \
  |  |   50|    375|    (void)(0)
  ------------------
  686|    373|                           selection_mode >= dlxemu::CodeEditor::SelectionMode::Normal &&
  687|    373|                                   selection_mode <= dlxemu::CodeEditor::SelectionMode::Line);
  688|       |
  689|    373|                FUZZ_LOG("SetSelection(Coordinates({:s}, {:s}), Coordinates({:s}, "
  ------------------
  |  |   33|    373|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  690|    373|                         "{:s}), {:s})",
  691|    373|                         print_int(coords_start.m_Line), print_int(coords_start.m_Column),
  692|    373|                         print_int(coords_end.m_Line), print_int(coords_start.m_Column),
  693|    373|                         dlx::enum_name(selection_mode).data());
  694|    373|                editor.SetSelection(coords_start, coords_end, selection_mode);
  695|    373|                break;
  696|    375|            }
  697|       |
  698|       |            // SelectWordUnderCursor
  699|    663|            case 25: {
  ------------------
  |  Branch (699:13): [True: 663, False: 432k]
  ------------------
  700|    663|                FUZZ_LOG("SelectWordUnderCursor");
  ------------------
  |  |   33|    663|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  701|       |
  702|    663|                editor.SelectWordUnderCursor();
  703|    663|                break;
  704|    375|            }
  705|       |
  706|       |            // SelectAll
  707|    134|            case 26: {
  ------------------
  |  Branch (707:13): [True: 134, False: 432k]
  ------------------
  708|    134|                FUZZ_LOG("SelectAll");
  ------------------
  |  |   33|    134|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  709|       |
  710|    134|                editor.SelectAll();
  711|    134|                break;
  712|    375|            }
  713|       |
  714|       |            // Delete
  715|    869|            case 27: {
  ------------------
  |  Branch (715:13): [True: 869, False: 432k]
  ------------------
  716|    869|                FUZZ_LOG("Delete");
  ------------------
  |  |   33|    869|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  717|       |
  718|    869|                editor.Delete();
  719|    869|                break;
  720|    375|            }
  721|       |
  722|       |            // Undo
  723|  2.05k|            case 28: {
  ------------------
  |  Branch (723:13): [True: 2.05k, False: 430k]
  ------------------
  724|  2.05k|                FUZZ_LOG("Undo()");
  ------------------
  |  |   33|  2.05k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  725|       |
  726|  2.05k|                editor.Undo();
  727|  2.05k|                break;
  728|    375|            }
  729|       |
  730|       |            // Redo
  731|  1.74k|            case 29: {
  ------------------
  |  Branch (731:13): [True: 1.74k, False: 431k]
  ------------------
  732|  1.74k|                FUZZ_LOG("Redo()");
  ------------------
  |  |   33|  1.74k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  733|       |
  734|  1.74k|                editor.Redo();
  735|  1.74k|                break;
  736|    375|            }
  737|       |
  738|       |            // SetErrorMarkers
  739|    574|            case 30: {
  ------------------
  |  Branch (739:13): [True: 574, False: 432k]
  ------------------
  740|  1.13k|                GET_T_COND(phi::size_t, count, count <= MaxVectorSize);
  ------------------
  |  |   45|    574|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    574|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    574|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 3, False: 571]
  |  |  |  |  ------------------
  |  |  |  |   39|    574|    {                                                                                              \
  |  |  |  |   40|      3|        return {};                                                                                 \
  |  |  |  |   41|      3|    }                                                                                              \
  |  |  |  |   42|    574|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|    571|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 6, False: 565]
  |  |  ------------------
  |  |   47|    571|    {                                                                                              \
  |  |   48|      6|        return {};                                                                                 \
  |  |   49|      6|    }                                                                                              \
  |  |   50|    571|    (void)(0)
  ------------------
  741|       |
  742|  1.13k|                dlxemu::CodeEditor::ErrorMarkers markers;
  743|  1.49k|                for (phi::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (743:41): [True: 960, False: 538]
  ------------------
  744|    960|                {
  745|    960|                    GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   37|    960|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    960|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 11, False: 949]
  |  |  ------------------
  |  |   39|    960|    {                                                                                              \
  |  |   40|     11|        return {};                                                                                 \
  |  |   41|     11|    }                                                                                              \
  |  |   42|    960|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  746|       |
  747|    949|                    if (!consume_string(data, size, index))
  ------------------
  |  Branch (747:25): [True: 16, False: 933]
  ------------------
  748|     16|                    {
  749|     16|                        return 0;
  750|     16|                    }
  751|    933|                    std::string& message = cache.string;
  752|       |
  753|       |                    // Add to error markers
  754|    933|                    markers[line_number] = message;
  755|    933|                }
  756|       |
  757|    538|                FUZZ_LOG("SetErrorMarkers({:s})", print_error_markers(markers));
  ------------------
  |  |   33|    538|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  758|       |
  759|    538|                editor.SetErrorMarkers(markers);
  760|    538|                break;
  761|  1.13k|            }
  762|       |
  763|       |            // SetBreakpoints
  764|    769|            case 31: {
  ------------------
  |  Branch (764:13): [True: 769, False: 432k]
  ------------------
  765|  1.53k|                GET_T_COND(phi::size_t, count, count <= MaxVectorSize);
  ------------------
  |  |   45|    769|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    769|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    769|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 1, False: 768]
  |  |  |  |  ------------------
  |  |  |  |   39|    769|    {                                                                                              \
  |  |  |  |   40|      1|        return {};                                                                                 \
  |  |  |  |   41|      1|    }                                                                                              \
  |  |  |  |   42|    769|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|    768|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 4, False: 764]
  |  |  ------------------
  |  |   47|    768|    {                                                                                              \
  |  |   48|      4|        return {};                                                                                 \
  |  |   49|      4|    }                                                                                              \
  |  |   50|    768|    (void)(0)
  ------------------
  766|       |
  767|  1.53k|                dlxemu::CodeEditor::Breakpoints breakpoints;
  768|  3.73k|                for (phi::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (768:41): [True: 3.02k, False: 713]
  ------------------
  769|  3.02k|                {
  770|  3.02k|                    GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   37|  3.02k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  3.02k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 51, False: 2.97k]
  |  |  ------------------
  |  |   39|  3.02k|    {                                                                                              \
  |  |   40|     51|        return {};                                                                                 \
  |  |   41|     51|    }                                                                                              \
  |  |   42|  3.02k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  771|       |
  772|  2.97k|                    breakpoints.insert(line_number);
  773|  2.97k|                }
  774|       |
  775|    713|                FUZZ_LOG("SetBreakpoints({:s})", print_breakpoints(breakpoints));
  ------------------
  |  |   33|    713|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  776|       |
  777|    713|                editor.SetBreakpoints(breakpoints);
  778|    713|                break;
  779|  1.53k|            }
  780|       |
  781|       |            // Render
  782|  29.4k|            case 32: {
  ------------------
  |  Branch (782:13): [True: 29.4k, False: 403k]
  ------------------
  783|  58.9k|                GET_T_COND(float, x, x <= MaxSaneFloatValue && x >= 0.0f && !phi::is_nan(x));
  ------------------
  |  |   45|  29.4k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  29.4k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  29.4k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 17, False: 29.4k]
  |  |  |  |  ------------------
  |  |  |  |   39|  29.4k|    {                                                                                              \
  |  |  |  |   40|     17|        return {};                                                                                 \
  |  |  |  |   41|     17|    }                                                                                              \
  |  |  |  |   42|  29.4k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|   117k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 29.4k, False: 42]
  |  |  |  Branch (46:11): [True: 29.4k, False: 15]
  |  |  |  Branch (46:11): [True: 29.4k, False: 0]
  |  |  ------------------
  |  |   47|  29.4k|    {                                                                                              \
  |  |   48|     57|        return {};                                                                                 \
  |  |   49|     57|    }                                                                                              \
  |  |   50|  29.4k|    (void)(0)
  ------------------
  784|  58.9k|                GET_T_COND(float, y, y <= MaxSaneFloatValue && y >= 0.0f && !phi::is_nan(y));
  ------------------
  |  |   45|  29.4k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  29.4k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  29.4k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 8, False: 29.4k]
  |  |  |  |  ------------------
  |  |  |  |   39|  29.4k|    {                                                                                              \
  |  |  |  |   40|      8|        return {};                                                                                 \
  |  |  |  |   41|      8|    }                                                                                              \
  |  |  |  |   42|  29.4k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|   117k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 29.3k, False: 22]
  |  |  |  Branch (46:11): [True: 29.3k, False: 21]
  |  |  |  Branch (46:11): [True: 29.3k, False: 0]
  |  |  ------------------
  |  |   47|  29.4k|    {                                                                                              \
  |  |   48|     43|        return {};                                                                                 \
  |  |   49|     43|    }                                                                                              \
  |  |   50|  29.4k|    (void)(0)
  ------------------
  785|       |
  786|  58.7k|                ImVec2 size_vec(x, y);
  787|       |
  788|  58.7k|                GET_T(bool, border);
  ------------------
  |  |   37|  29.3k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  29.3k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 4, False: 29.3k]
  |  |  ------------------
  |  |   39|  29.3k|    {                                                                                              \
  |  |   40|      4|        return {};                                                                                 \
  |  |   41|      4|    }                                                                                              \
  |  |   42|  29.3k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  789|       |
  790|  29.3k|                FUZZ_LOG("Render(ImVec2({:f}, {:f}), {:s})", x, y, border ? "true" : "false");
  ------------------
  |  |   33|  29.3k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  791|       |
  792|  29.3k|                ImGui::NewFrame();
  793|  29.3k|                editor.Render(size_vec, border);
  794|  29.3k|                EndImGui();
  795|       |
  796|  29.3k|                break;
  797|  58.7k|            }
  798|       |
  799|       |            // EnterCharacter
  800|  25.2k|            case 33: {
  ------------------
  |  Branch (800:13): [True: 25.2k, False: 407k]
  ------------------
  801|  25.2k|                GET_T(ImWchar, character);
  ------------------
  |  |   37|  25.2k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  25.2k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 25.2k]
  |  |  ------------------
  |  |   39|  25.2k|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|  25.2k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  802|  25.2k|                GET_T(bool, shift);
  ------------------
  |  |   37|  25.2k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  25.2k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 13, False: 25.2k]
  |  |  ------------------
  |  |   39|  25.2k|    {                                                                                              \
  |  |   40|     13|        return {};                                                                                 \
  |  |   41|     13|    }                                                                                              \
  |  |   42|  25.2k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  803|       |
  804|  25.2k|                FUZZ_LOG("EnterCharacter({:s}, {:s})", print_char(character), print_bool(shift));
  ------------------
  |  |   33|  25.2k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  805|  25.2k|                editor.EnterCharacter(character, shift);
  806|  25.2k|                break;
  807|  25.2k|            }
  808|       |
  809|       |            // ClearText
  810|    521|            case 34: {
  ------------------
  |  Branch (810:13): [True: 521, False: 432k]
  ------------------
  811|    521|                FUZZ_LOG("ClearText()");
  ------------------
  |  |   33|    521|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  812|       |
  813|    521|                editor.ClearText();
  814|    521|                break;
  815|  25.2k|            }
  816|       |
  817|       |            // ClearSelection
  818|     91|            case 35: {
  ------------------
  |  Branch (818:13): [True: 91, False: 432k]
  ------------------
  819|     91|                FUZZ_LOG("ClearSelection");
  ------------------
  |  |   33|     91|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  820|       |
  821|     91|                editor.ClearSelection();
  822|     91|                break;
  823|  25.2k|            }
  824|       |
  825|       |            // Backspace
  826|  1.20k|            case 36: {
  ------------------
  |  Branch (826:13): [True: 1.20k, False: 431k]
  ------------------
  827|  1.20k|                FUZZ_LOG("Backspace");
  ------------------
  |  |   33|  1.20k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  828|       |
  829|  1.20k|                editor.Backspace();
  830|  1.20k|                break;
  831|  25.2k|            }
  832|       |
  833|       |            // ImGui::AddKeyEvent
  834|  2.01k|            case 37: {
  ------------------
  |  Branch (834:13): [True: 2.01k, False: 431k]
  ------------------
  835|  4.01k|                GET_T_COND(ImGuiKey, key,
  ------------------
  |  |   45|  2.01k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  2.01k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  2.01k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 1, False: 2.01k]
  |  |  |  |  ------------------
  |  |  |  |   39|  2.01k|    {                                                                                              \
  |  |  |  |   40|      1|        return {};                                                                                 \
  |  |  |  |   41|      1|    }                                                                                              \
  |  |  |  |   42|  2.01k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  8.03k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 9, False: 2.00k]
  |  |  |  Branch (46:11): [True: 2.00k, False: 7]
  |  |  |  Branch (46:11): [True: 2.00k, False: 1]
  |  |  |  Branch (46:11): [True: 2.00k, False: 1]
  |  |  ------------------
  |  |   47|  2.01k|    {                                                                                              \
  |  |   48|      9|        return {};                                                                                 \
  |  |   49|      9|    }                                                                                              \
  |  |   50|  2.01k|    (void)(0)
  ------------------
  836|  4.01k|                           ImGui::IsNamedKey(key) && !ImGui::IsAliasKey(key) &&
  837|  4.01k|                                   !IsReservedKey(key));
  838|  4.01k|                GET_T(bool, down);
  ------------------
  |  |   37|  2.00k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.00k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 2.00k]
  |  |  ------------------
  |  |   39|  2.00k|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|  2.00k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  839|       |
  840|  2.00k|                FUZZ_LOG("ImGui::GetIO().AddKeyEvent({:s}, {:s})", magic_enum::enum_name(key),
  ------------------
  |  |   33|  2.00k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  841|  2.00k|                         print_bool(down));
  842|  2.00k|                ImGui::GetIO().AddKeyEvent(key, down);
  843|       |
  844|  2.00k|                break;
  845|  4.01k|            }
  846|       |
  847|       |            // ImGui::AddKeyAnalogEvent
  848|    373|            case 38: {
  ------------------
  |  Branch (848:13): [True: 373, False: 432k]
  ------------------
  849|    740|                GET_T_COND(ImGuiKey, key,
  ------------------
  |  |   45|    373|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    373|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    373|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 1, False: 372]
  |  |  |  |  ------------------
  |  |  |  |   39|    373|    {                                                                                              \
  |  |  |  |   40|      1|        return {};                                                                                 \
  |  |  |  |   41|      1|    }                                                                                              \
  |  |  |  |   42|    373|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  1.48k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 4, False: 368]
  |  |  |  Branch (46:11): [True: 370, False: 2]
  |  |  |  Branch (46:11): [True: 369, False: 1]
  |  |  |  Branch (46:11): [True: 368, False: 1]
  |  |  ------------------
  |  |   47|    372|    {                                                                                              \
  |  |   48|      4|        return {};                                                                                 \
  |  |   49|      4|    }                                                                                              \
  |  |   50|    372|    (void)(0)
  ------------------
  850|    740|                           ImGui::IsNamedKey(key) && !ImGui::IsAliasKey(key) &&
  851|    740|                                   !IsReservedKey(key));
  852|    740|                GET_T(bool, down);
  ------------------
  |  |   37|    368|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    368|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 367]
  |  |  ------------------
  |  |   39|    368|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    368|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  853|    367|                GET_T_COND(float, value, phi::abs(value) <= MaxSaneFloatValue);
  ------------------
  |  |   45|    367|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    367|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    367|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 1, False: 366]
  |  |  |  |  ------------------
  |  |  |  |   39|    367|    {                                                                                              \
  |  |  |  |   40|      1|        return {};                                                                                 \
  |  |  |  |   41|      1|    }                                                                                              \
  |  |  |  |   42|    367|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|    366|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 2, False: 364]
  |  |  ------------------
  |  |   47|    366|    {                                                                                              \
  |  |   48|      2|        return {};                                                                                 \
  |  |   49|      2|    }                                                                                              \
  |  |   50|    366|    (void)(0)
  ------------------
  854|       |
  855|    364|                FUZZ_LOG("ImGui::GetIO().AddKeyAnalogEvent({:s}, {:s}, {:f})",
  ------------------
  |  |   33|    364|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  856|    364|                         magic_enum::enum_name(key), print_bool(down), value);
  857|    364|                ImGui::GetIO().AddKeyAnalogEvent(key, down, value);
  858|       |
  859|    364|                break;
  860|    366|            }
  861|       |
  862|       |            // ImGui::AddMousePosEvent
  863|  1.91k|            case 39: {
  ------------------
  |  Branch (863:13): [True: 1.91k, False: 431k]
  ------------------
  864|  3.81k|                GET_T_COND(float, x, phi::abs(x) <= MaxSaneFloatValue);
  ------------------
  |  |   45|  1.91k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  1.91k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  1.91k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 3, False: 1.91k]
  |  |  |  |  ------------------
  |  |  |  |   39|  1.91k|    {                                                                                              \
  |  |  |  |   40|      3|        return {};                                                                                 \
  |  |  |  |   41|      3|    }                                                                                              \
  |  |  |  |   42|  1.91k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  1.91k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 1, False: 1.90k]
  |  |  ------------------
  |  |   47|  1.91k|    {                                                                                              \
  |  |   48|      1|        return {};                                                                                 \
  |  |   49|      1|    }                                                                                              \
  |  |   50|  1.91k|    (void)(0)
  ------------------
  865|  3.81k|                GET_T_COND(float, y, phi::abs(y) <= MaxSaneFloatValue);
  ------------------
  |  |   45|  1.90k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  1.90k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  1.90k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 1, False: 1.90k]
  |  |  |  |  ------------------
  |  |  |  |   39|  1.90k|    {                                                                                              \
  |  |  |  |   40|      1|        return {};                                                                                 \
  |  |  |  |   41|      1|    }                                                                                              \
  |  |  |  |   42|  1.90k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  1.90k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 1, False: 1.90k]
  |  |  ------------------
  |  |   47|  1.90k|    {                                                                                              \
  |  |   48|      1|        return {};                                                                                 \
  |  |   49|      1|    }                                                                                              \
  |  |   50|  1.90k|    (void)(0)
  ------------------
  866|       |
  867|  1.90k|                FUZZ_LOG("ImGui::GetIO().AddMousePosEvent({:f}, {:f})", x, y);
  ------------------
  |  |   33|  1.90k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  868|  1.90k|                ImGui::GetIO().AddMousePosEvent(x, y);
  869|       |
  870|  1.90k|                break;
  871|  1.90k|            }
  872|       |
  873|       |            // ImGui::AddMouseButtonEvent
  874|  3.14k|            case 40: {
  ------------------
  |  Branch (874:13): [True: 3.14k, False: 429k]
  ------------------
  875|  6.23k|                GET_T_COND(int, button, button >= 0 && button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   45|  3.14k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  3.14k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  3.14k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 7, False: 3.13k]
  |  |  |  |  ------------------
  |  |  |  |   39|  3.14k|    {                                                                                              \
  |  |  |  |   40|      7|        return {};                                                                                 \
  |  |  |  |   41|      7|    }                                                                                              \
  |  |  |  |   42|  3.14k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  6.27k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 3.13k, False: 3]
  |  |  |  Branch (46:11): [True: 3.09k, False: 45]
  |  |  ------------------
  |  |   47|  3.13k|    {                                                                                              \
  |  |   48|     48|        return {};                                                                                 \
  |  |   49|     48|    }                                                                                              \
  |  |   50|  3.13k|    (void)(0)
  ------------------
  876|  6.23k|                GET_T(bool, down);
  ------------------
  |  |   37|  3.09k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  3.09k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 3, False: 3.08k]
  |  |  ------------------
  |  |   39|  3.09k|    {                                                                                              \
  |  |   40|      3|        return {};                                                                                 \
  |  |   41|      3|    }                                                                                              \
  |  |   42|  3.09k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  877|       |
  878|  3.08k|                FUZZ_LOG("ImGui::GetIO().AddMouseButtonEvent({}, {:s})", button, print_bool(down));
  ------------------
  |  |   33|  3.08k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  879|  3.08k|                ImGui::GetIO().AddMouseButtonEvent(button, down);
  880|       |
  881|  3.08k|                break;
  882|  6.23k|            }
  883|       |
  884|       |            // ImGui::AddMouseWheelEvent
  885|    777|            case 41: {
  ------------------
  |  Branch (885:13): [True: 777, False: 432k]
  ------------------
  886|  1.54k|                GET_T_COND(float, wh_x, phi::abs(wh_x) <= MaxSaneFloatValue);
  ------------------
  |  |   45|    777|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    777|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    777|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 2, False: 775]
  |  |  |  |  ------------------
  |  |  |  |   39|    777|    {                                                                                              \
  |  |  |  |   40|      2|        return {};                                                                                 \
  |  |  |  |   41|      2|    }                                                                                              \
  |  |  |  |   42|    777|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|    775|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 1, False: 774]
  |  |  ------------------
  |  |   47|    775|    {                                                                                              \
  |  |   48|      1|        return {};                                                                                 \
  |  |   49|      1|    }                                                                                              \
  |  |   50|    775|    (void)(0)
  ------------------
  887|  1.54k|                GET_T_COND(float, wh_y, phi::abs(wh_y) <= MaxSaneFloatValue);
  ------------------
  |  |   45|    774|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    774|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    774|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 1, False: 773]
  |  |  |  |  ------------------
  |  |  |  |   39|    774|    {                                                                                              \
  |  |  |  |   40|      1|        return {};                                                                                 \
  |  |  |  |   41|      1|    }                                                                                              \
  |  |  |  |   42|    774|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|    773|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 1, False: 772]
  |  |  ------------------
  |  |   47|    773|    {                                                                                              \
  |  |   48|      1|        return {};                                                                                 \
  |  |   49|      1|    }                                                                                              \
  |  |   50|    773|    (void)(0)
  ------------------
  888|       |
  889|    772|                FUZZ_LOG("ImGui::GetIO().AddMouseWheelEvent({:f}, {:f})", wh_x, wh_y);
  ------------------
  |  |   33|    772|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  890|    772|                ImGui::GetIO().AddMouseWheelEvent(wh_x, wh_y);
  891|       |
  892|    772|                break;
  893|    773|            }
  894|       |
  895|       |            // ImGui::AddFocusEvent
  896|    606|            case 42: {
  ------------------
  |  Branch (896:13): [True: 606, False: 432k]
  ------------------
  897|    606|                GET_T(bool, focused);
  ------------------
  |  |   37|    606|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    606|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 604]
  |  |  ------------------
  |  |   39|    606|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|    606|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  898|       |
  899|    604|                FUZZ_LOG("ImGui::GetIO().AddFocusEvent({:s})", print_bool(focused));
  ------------------
  |  |   33|    604|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  900|    604|                ImGui::GetIO().AddFocusEvent(focused);
  901|       |
  902|    604|                break;
  903|    606|            }
  904|       |
  905|       |            // ImGui::AddInputCharacter
  906|    445|            case 43: {
  ------------------
  |  Branch (906:13): [True: 445, False: 432k]
  ------------------
  907|    445|                GET_T(unsigned int, character);
  ------------------
  |  |   37|    445|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    445|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 444]
  |  |  ------------------
  |  |   39|    445|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    445|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  908|       |
  909|    444|                FUZZ_LOG("ImGui::GetIO().AddInputCharacter({})", character);
  ------------------
  |  |   33|    444|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  910|    444|                ImGui::GetIO().AddInputCharacter(character);
  911|       |
  912|    444|                break;
  913|    445|            }
  914|       |
  915|       |            // ImGui::AddInputCharacterUTF16
  916|  3.99k|            case 44: {
  ------------------
  |  Branch (916:13): [True: 3.99k, False: 429k]
  ------------------
  917|  3.99k|                GET_T(ImWchar16, character);
  ------------------
  |  |   37|  3.99k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  3.99k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 3.99k]
  |  |  ------------------
  |  |   39|  3.99k|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|  3.99k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  918|       |
  919|  3.99k|                FUZZ_LOG("ImGui::GetIO().AddInputCharacterUTF16({})", character);
  ------------------
  |  |   33|  3.99k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  920|  3.99k|                ImGui::GetIO().AddInputCharacterUTF16(character);
  921|       |
  922|  3.99k|                break;
  923|  3.99k|            }
  924|       |
  925|       |            // ImGui::AddInputCharactersUTF8
  926|     59|            case 45: {
  ------------------
  |  Branch (926:13): [True: 59, False: 432k]
  ------------------
  927|     59|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (927:21): [True: 11, False: 48]
  ------------------
  928|     11|                {
  929|     11|                    return 0;
  930|     11|                }
  931|     48|                std::string& str = cache.string;
  932|       |
  933|     48|                FUZZ_LOG("ImGui::GetIO().AddInputCharactersUTF8({:s})", print_string(str));
  ------------------
  |  |   33|     48|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  934|     48|                ImGui::GetIO().AddInputCharactersUTF8(str.c_str());
  935|       |
  936|     48|                break;
  937|     59|            }
  938|       |
  939|       |            // Copy
  940|  7.00k|            case 46: {
  ------------------
  |  Branch (940:13): [True: 7.00k, False: 426k]
  ------------------
  941|  7.00k|                FUZZ_LOG("Copy()");
  ------------------
  |  |   33|  7.00k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  942|  7.00k|                editor.Copy();
  943|       |
  944|  7.00k|                break;
  945|     59|            }
  946|       |
  947|       |            // Cut
  948|    101|            case 47: {
  ------------------
  |  Branch (948:13): [True: 101, False: 432k]
  ------------------
  949|    101|                FUZZ_LOG("Cut()");
  ------------------
  |  |   33|    101|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  950|    101|                editor.Cut();
  951|       |
  952|    101|                break;
  953|     59|            }
  954|       |
  955|       |            // Paste
  956|  8.74k|            case 48: {
  ------------------
  |  Branch (956:13): [True: 8.74k, False: 424k]
  ------------------
  957|  8.74k|                FUZZ_LOG("Paste()");
  ------------------
  |  |   33|  8.74k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  958|  8.74k|                editor.Paste();
  959|       |
  960|  8.74k|                break;
  961|     59|            }
  962|       |
  963|       |            // SetOverwrite
  964|    260|            case 49: {
  ------------------
  |  Branch (964:13): [True: 260, False: 432k]
  ------------------
  965|    260|                GET_T(bool, overwrite);
  ------------------
  |  |   37|    260|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    260|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 258]
  |  |  ------------------
  |  |   39|    260|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|    260|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  966|       |
  967|    258|                FUZZ_LOG("SetOverwrite({:s})", print_bool(overwrite));
  ------------------
  |  |   33|    258|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  968|    258|                editor.SetOverwrite(overwrite);
  969|       |
  970|    258|                break;
  971|    260|            }
  972|       |
  973|       |            // SetColorizerEnable
  974|    107|            case 50: {
  ------------------
  |  Branch (974:13): [True: 107, False: 432k]
  ------------------
  975|    107|                GET_T(bool, colorizer);
  ------------------
  |  |   37|    107|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    107|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 106]
  |  |  ------------------
  |  |   39|    107|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    107|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  976|       |
  977|    106|                FUZZ_LOG("SetColorizerEnable({:s})", print_bool(colorizer));
  ------------------
  |  |   33|    106|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  978|    106|                editor.SetColorizerEnable(colorizer);
  979|       |
  980|    106|                break;
  981|    107|            }
  982|       |
  983|       |            // RemoveBreakpoint
  984|    315|            case 51: {
  ------------------
  |  Branch (984:13): [True: 315, False: 432k]
  ------------------
  985|    315|                GET_T(phi::u32, line_number);
  ------------------
  |  |   37|    315|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    315|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 314]
  |  |  ------------------
  |  |   39|    315|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|    315|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  986|       |
  987|    314|                FUZZ_LOG("RemoveBreakpoint({:s})", print_int(line_number));
  ------------------
  |  |   33|    314|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  988|    314|                editor.RemoveBreakpoint(line_number);
  989|       |
  990|    314|                break;
  991|    315|            }
  992|       |
  993|       |            // ToggleBreakpoint
  994|  1.48k|            case 52: {
  ------------------
  |  Branch (994:13): [True: 1.48k, False: 431k]
  ------------------
  995|  1.48k|                GET_T(phi::u32, line_number);
  ------------------
  |  |   37|  1.48k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  1.48k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 1.48k]
  |  |  ------------------
  |  |   39|  1.48k|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|  1.48k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  996|       |
  997|  1.48k|                FUZZ_LOG("ToggleBreakpoint({:s})", print_int(line_number));
  ------------------
  |  |   33|  1.48k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  998|  1.48k|                editor.ToggleBreakpoint(line_number);
  999|       |
 1000|  1.48k|                break;
 1001|  1.48k|            }
 1002|   433k|        }
 1003|   433k|    }
 1004|       |
 1005|  3.29k|    FUZZ_LOG("VerifyInternalState()");
  ------------------
  |  |   33|  3.29k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
 1006|  3.29k|    editor.VerifyInternalState();
 1007|       |
 1008|  3.29k|    FUZZ_LOG("Finished execution");
  ------------------
  |  |   33|  3.29k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
 1009|       |
 1010|  3.29k|    return 0;
 1011|  6.34k|}
_ZN5Cache10InitializeEv:
   72|      2|    {
   73|      2|        Cache c;
   74|       |
   75|       |        // Resize vector args
   76|     18|        for (phi::usize i{0u}; i < MaxVectorSize; ++i)
  ------------------
  |  Branch (76:32): [True: 16, False: 2]
  ------------------
   77|     16|        {
   78|     16|            svec& vector = c.vector_string[i.unsafe()];
   79|     16|            vector.resize(i.unsafe());
   80|       |
   81|       |            // Reserve max size
   82|     16|            for (std::string& str : vector)
  ------------------
  |  Branch (82:35): [True: 56, False: 16]
  ------------------
   83|     56|            {
   84|     56|                str.reserve(MaxStringLength);
   85|     56|            }
   86|     16|        }
   87|       |
   88|      2|        c.string.reserve(MaxStringLength);
   89|       |
   90|      2|        return c;
   91|      2|    }
_Z9consume_tIjEN3phi8optionalIT_EEPKhmRm:
  111|   461k|{
  112|   461k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 1.66k, False: 460k]
  ------------------
  113|  1.66k|    {
  114|  1.66k|        return {};
  115|  1.66k|    }
  116|       |
  117|   460k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|   460k|    const phi::size_t old_index = index;
  120|   460k|    index += aligned_size<T>();
  121|       |
  122|   460k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|   460k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|   460k|        return static_cast<bool>(value);
  126|   460k|    }
  127|   460k|    else
  128|   460k|    {
  129|   460k|        return *reinterpret_cast<const T*>(data + old_index);
  130|   460k|    }
  131|   460k|}
_Z10has_x_moremmm:
   98|   637k|{
   99|   637k|    return index + x < size;
  100|   637k|}
_Z12aligned_sizeIjEmv:
  104|   460k|{
  105|   460k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|   460k|}
_Z9consume_tImEN3phi8optionalIT_EEPKhmRm:
  111|  2.19k|{
  112|  2.19k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 9, False: 2.18k]
  ------------------
  113|      9|    {
  114|      9|        return {};
  115|      9|    }
  116|       |
  117|  2.18k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  2.18k|    const phi::size_t old_index = index;
  120|  2.18k|    index += aligned_size<T>();
  121|       |
  122|  2.18k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  2.18k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  2.18k|        return static_cast<bool>(value);
  126|  2.18k|    }
  127|  2.18k|    else
  128|  2.18k|    {
  129|  2.18k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  2.18k|    }
  131|  2.18k|}
_Z12aligned_sizeImEmv:
  104|  2.18k|{
  105|  2.18k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  2.18k|}
_Z9consume_tIbEN3phi8optionalIT_EEPKhmRm:
  111|  71.2k|{
  112|  71.2k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 43, False: 71.2k]
  ------------------
  113|     43|    {
  114|     43|        return {};
  115|     43|    }
  116|       |
  117|  71.2k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  71.2k|    const phi::size_t old_index = index;
  120|  71.2k|    index += aligned_size<T>();
  121|       |
  122|  71.2k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|  71.2k|    {
  124|  71.2k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  71.2k|        return static_cast<bool>(value);
  126|  71.2k|    }
  127|  71.2k|    else
  128|  71.2k|    {
  129|  71.2k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  71.2k|    }
  131|  71.2k|}
_Z12aligned_sizeIbEmv:
  104|  71.2k|{
  105|  71.2k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  71.2k|}
_Z9consume_tIhEN3phi8optionalIT_EEPKhmRm:
  111|    329|{
  112|    329|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 1, False: 328]
  ------------------
  113|      1|    {
  114|      1|        return {};
  115|      1|    }
  116|       |
  117|    328|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|    328|    const phi::size_t old_index = index;
  120|    328|    index += aligned_size<T>();
  121|       |
  122|    328|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|    328|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|    328|        return static_cast<bool>(value);
  126|    328|    }
  127|    328|    else
  128|    328|    {
  129|    328|        return *reinterpret_cast<const T*>(data + old_index);
  130|    328|    }
  131|    328|}
_Z12aligned_sizeIhEmv:
  104|    328|{
  105|    328|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|    328|}
_Z9consume_tIN6dlxemu10CodeEditor13SelectionModeEEN3phi8optionalIT_EEPKhmRm:
  111|    376|{
  112|    376|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 1, False: 375]
  ------------------
  113|      1|    {
  114|      1|        return {};
  115|      1|    }
  116|       |
  117|    375|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|    375|    const phi::size_t old_index = index;
  120|    375|    index += aligned_size<T>();
  121|       |
  122|    375|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|    375|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|    375|        return static_cast<bool>(value);
  126|    375|    }
  127|    375|    else
  128|    375|    {
  129|    375|        return *reinterpret_cast<const T*>(data + old_index);
  130|    375|    }
  131|    375|}
_Z12aligned_sizeIN6dlxemu10CodeEditor13SelectionModeEEmv:
  104|    375|{
  105|    375|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|    375|}
_Z9consume_tIfEN3phi8optionalIT_EEPKhmRm:
  111|  64.6k|{
  112|  64.6k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 33, False: 64.6k]
  ------------------
  113|     33|    {
  114|     33|        return {};
  115|     33|    }
  116|       |
  117|  64.6k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  64.6k|    const phi::size_t old_index = index;
  120|  64.6k|    index += aligned_size<T>();
  121|       |
  122|  64.6k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  64.6k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  64.6k|        return static_cast<bool>(value);
  126|  64.6k|    }
  127|  64.6k|    else
  128|  64.6k|    {
  129|  64.6k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  64.6k|    }
  131|  64.6k|}
_Z12aligned_sizeIfEmv:
  104|  64.6k|{
  105|  64.6k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  64.6k|}
_Z9consume_tItEN3phi8optionalIT_EEPKhmRm:
  111|  29.2k|{
  112|  29.2k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 4, False: 29.2k]
  ------------------
  113|      4|    {
  114|      4|        return {};
  115|      4|    }
  116|       |
  117|  29.2k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  29.2k|    const phi::size_t old_index = index;
  120|  29.2k|    index += aligned_size<T>();
  121|       |
  122|  29.2k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  29.2k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  29.2k|        return static_cast<bool>(value);
  126|  29.2k|    }
  127|  29.2k|    else
  128|  29.2k|    {
  129|  29.2k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  29.2k|    }
  131|  29.2k|}
_Z12aligned_sizeItEmv:
  104|  29.2k|{
  105|  29.2k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  29.2k|}
_Z9consume_tI8ImGuiKeyEN3phi8optionalIT_EEPKhmRm:
  111|  2.38k|{
  112|  2.38k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 2, False: 2.38k]
  ------------------
  113|      2|    {
  114|      2|        return {};
  115|      2|    }
  116|       |
  117|  2.38k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  2.38k|    const phi::size_t old_index = index;
  120|  2.38k|    index += aligned_size<T>();
  121|       |
  122|  2.38k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  2.38k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  2.38k|        return static_cast<bool>(value);
  126|  2.38k|    }
  127|  2.38k|    else
  128|  2.38k|    {
  129|  2.38k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  2.38k|    }
  131|  2.38k|}
_Z12aligned_sizeI8ImGuiKeyEmv:
  104|  2.38k|{
  105|  2.38k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  2.38k|}
_Z9consume_tIiEN3phi8optionalIT_EEPKhmRm:
  111|  3.14k|{
  112|  3.14k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 7, False: 3.13k]
  ------------------
  113|      7|    {
  114|      7|        return {};
  115|      7|    }
  116|       |
  117|  3.13k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  3.13k|    const phi::size_t old_index = index;
  120|  3.13k|    index += aligned_size<T>();
  121|       |
  122|  3.13k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  3.13k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  3.13k|        return static_cast<bool>(value);
  126|  3.13k|    }
  127|  3.13k|    else
  128|  3.13k|    {
  129|  3.13k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  3.13k|    }
  131|  3.13k|}
_Z12aligned_sizeIiEmv:
  104|  3.13k|{
  105|  3.13k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  3.13k|}
_Z9consume_tIN3phi7integerIjEEENS0_8optionalIT_EEPKhmRm:
  111|  1.80k|{
  112|  1.80k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 2, False: 1.79k]
  ------------------
  113|      2|    {
  114|      2|        return {};
  115|      2|    }
  116|       |
  117|  1.79k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  1.79k|    const phi::size_t old_index = index;
  120|  1.79k|    index += aligned_size<T>();
  121|       |
  122|  1.79k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  1.79k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  1.79k|        return static_cast<bool>(value);
  126|  1.79k|    }
  127|  1.79k|    else
  128|  1.79k|    {
  129|  1.79k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  1.79k|    }
  131|  1.79k|}
_Z12aligned_sizeIN3phi7integerIjEEEmv:
  104|  1.79k|{
  105|  1.79k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  1.79k|}

