_ZN6dlxemu10CodeEditor10UndoRecordC2Ev:
  265|   107k|            UndoRecord() = default;

_ZN6dlxemu6WindowC2Ev:
   13|  9.34k|        Window() = default;

_ZN6dlxemu10CodeEditor11CoordinatesC2Ev:
  197|  1.16M|    {}
_ZN6dlxemu10CodeEditor11CoordinatesC2EN3phi7integerIjEES4_:
  202|  1.39M|    {}
_ZNK6dlxemu10CodeEditor11CoordinateseqERKS1_:
  206|   169k|    {
  207|   169k|        return (m_Line == other.m_Line) && (m_Column == other.m_Column);
  ------------------
  |  Branch (207:16): [True: 161k, False: 8.14k]
  |  Branch (207:44): [True: 159k, False: 1.55k]
  ------------------
  208|   169k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesneERKS1_:
  212|   183k|    {
  213|   183k|        return (m_Line != other.m_Line) || (m_Column != other.m_Column);
  ------------------
  |  Branch (213:16): [True: 35.7k, False: 147k]
  |  Branch (213:44): [True: 40.4k, False: 107k]
  ------------------
  214|   183k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesltERKS1_:
  218|    465|    {
  219|    465|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (219:13): [True: 353, False: 112]
  ------------------
  220|    353|        {
  221|    353|            return m_Line < other.m_Line;
  222|    353|        }
  223|       |
  224|    112|        return m_Column < other.m_Column;
  225|    465|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgtERKS1_:
  229|   231k|    {
  230|   231k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (230:13): [True: 38.0k, False: 193k]
  ------------------
  231|  38.0k|        {
  232|  38.0k|            return m_Line > other.m_Line;
  233|  38.0k|        }
  234|       |
  235|   193k|        return m_Column > other.m_Column;
  236|   231k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesleERKS1_:
  240|   273k|    {
  241|   273k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (241:13): [True: 123k, False: 150k]
  ------------------
  242|   123k|        {
  243|   123k|            return m_Line < other.m_Line;
  244|   123k|        }
  245|       |
  246|   150k|        return m_Column <= other.m_Column;
  247|   273k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgeERKS1_:
  251|   230k|    {
  252|   230k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (252:13): [True: 3.74k, False: 226k]
  ------------------
  253|  3.74k|        {
  254|  3.74k|            return m_Line > other.m_Line;
  255|  3.74k|        }
  256|       |
  257|   226k|        return m_Column >= other.m_Column;
  258|   230k|    }
_ZN6dlxemu10CodeEditor5GlyphC2EhNS0_12PaletteIndexE:
  265|  88.4M|    {}
_ZN6dlxemu10CodeEditorC2EPNS_8EmulatorE:
  293|  18.6k|    {
  294|  18.6k|        Colorize();
  295|  18.6k|        m_Lines.push_back(Line());
  296|  18.6k|    }
_ZN6dlxemu10CodeEditorD2Ev:
  299|  18.6k|    {
  300|  18.6k|        VerifyInternalState();
  301|  18.6k|    }
_ZN6dlxemu10CodeEditor15SetErrorMarkersERKNSt3__13mapIjNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS1_4lessIjEENS6_INS1_4pairIKjS8_EEEEEE:
  316|  2.29k|    {
  317|       |        // Reject if any marker are invalid
  318|  2.29k|        for (auto&& marker : markers)
  ------------------
  |  Branch (318:28): [True: 2.07k, False: 1.98k]
  ------------------
  319|  2.07k|        {
  320|  2.07k|            const phi::u32 line_number = marker.first;
  321|       |
  322|  2.07k|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (322:17): [True: 177, False: 1.89k]
  |  Branch (322:17): [True: 315, False: 1.75k]
  |  Branch (322:38): [True: 138, False: 1.75k]
  ------------------
  323|    315|            {
  324|    315|                return;
  325|    315|            }
  326|  2.07k|        }
  327|       |
  328|  1.98k|        m_ErrorMarkers = markers;
  329|  1.98k|    }
_ZN6dlxemu10CodeEditor14AddErrorMarkerEN3phi7integerIjEERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE:
  332|   124k|    {
  333|   124k|        if (line_number > m_Lines.size() || line_number == 0u)
  ------------------
  |  Branch (333:13): [True: 58.7k, False: 66.0k]
  |  Branch (333:13): [True: 121k, False: 3.23k]
  |  Branch (333:45): [True: 62.7k, False: 3.23k]
  ------------------
  334|   121k|        {
  335|   121k|            return;
  336|   121k|        }
  337|       |
  338|  3.23k|        if (m_ErrorMarkers.contains(line_number.unsafe()))
  ------------------
  |  Branch (338:13): [True: 782, False: 2.45k]
  ------------------
  339|    782|        {
  340|    782|            m_ErrorMarkers[line_number.unsafe()] += '\n' + message;
  341|    782|        }
  342|  2.45k|        else
  343|  2.45k|        {
  344|  2.45k|            m_ErrorMarkers[line_number.unsafe()] = message;
  345|  2.45k|        }
  346|  3.23k|    }
_ZN6dlxemu10CodeEditor17ClearErrorMarkersEv:
  349|  5.25k|    {
  350|  5.25k|        m_ErrorMarkers.clear();
  351|  5.25k|    }
_ZN6dlxemu10CodeEditor14SetBreakpointsERKNSt3__113unordered_setIjNS1_4hashIjEENS1_8equal_toIjEENS1_9allocatorIjEEEE:
  364|  1.60k|    {
  365|       |        // Reject aif any lines are invalid
  366|  1.60k|        for (phi::u32 line_number : markers)
  ------------------
  |  Branch (366:35): [True: 1.99k, False: 298]
  ------------------
  367|  1.99k|        {
  368|  1.99k|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (368:17): [True: 67, False: 1.92k]
  |  Branch (368:17): [True: 1.30k, False: 692]
  |  Branch (368:38): [True: 1.23k, False: 692]
  ------------------
  369|  1.30k|            {
  370|  1.30k|                return;
  371|  1.30k|            }
  372|  1.99k|        }
  373|       |
  374|    298|        m_Breakpoints = markers;
  375|    298|    }
_ZN6dlxemu10CodeEditor13AddBreakpointEN3phi7integerIjEE:
  378|  4.39k|    {
  379|  4.39k|        if (line_number > m_Lines.size() || line_number == 0u)
  ------------------
  |  Branch (379:13): [True: 2.28k, False: 2.10k]
  |  Branch (379:13): [True: 2.28k, False: 2.10k]
  |  Branch (379:45): [True: 3, False: 2.10k]
  ------------------
  380|  2.28k|        {
  381|  2.28k|            return false;
  382|  2.28k|        }
  383|       |
  384|  2.10k|        return m_Breakpoints.insert(line_number.unsafe()).second;
  385|  4.39k|    }
_ZN6dlxemu10CodeEditor16RemoveBreakpointEN3phi7integerIjEE:
  388|    842|    {
  389|    842|        auto iterator = m_Breakpoints.find(line_number.unsafe());
  390|       |
  391|    842|        if (iterator != m_Breakpoints.end())
  ------------------
  |  Branch (391:13): [True: 29, False: 813]
  ------------------
  392|     29|        {
  393|     29|            m_Breakpoints.erase(iterator);
  394|     29|            return true;
  395|     29|        }
  396|       |
  397|    813|        return false;
  398|    842|    }
_ZN6dlxemu10CodeEditor16ToggleBreakpointEN3phi7integerIjEE:
  401|  4.66k|    {
  402|  4.66k|        if (auto iterator = m_Breakpoints.find(line_number.unsafe());
  403|  4.66k|            iterator != m_Breakpoints.end())
  ------------------
  |  Branch (403:13): [True: 276, False: 4.39k]
  ------------------
  404|    276|        {
  405|    276|            m_Breakpoints.erase(iterator);
  406|    276|            return false;
  407|    276|        }
  408|       |
  409|  4.39k|        AddBreakpoint(line_number);
  410|  4.39k|        return true;
  411|  4.66k|    }
_ZN6dlxemu10CodeEditor16ClearBreakPointsEv:
  414|  1.52k|    {
  415|  1.52k|        m_Breakpoints.clear();
  416|  1.52k|    }
_ZN6dlxemu10CodeEditor6RenderERK6ImVec2N3phi7booleanE:
  429|  90.2k|    {
  430|       |        // Verify that ImGui is correctly initialzied
  431|  90.2k|        PHI_ASSERT(GImGui && GImGui->Initialized, "ImGui was not initialized!");
  432|       |
  433|  90.2k|        m_CursorPositionChanged = false;
  434|       |
  435|  90.2k|        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::ColorConvertU32ToFloat4(GetPaletteForIndex(
  436|  90.2k|                                                        PaletteIndex::Background)));
  437|  90.2k|        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
  438|       |
  439|       |        // Assert size is properly sanitzed
  440|  90.2k|        PHI_ASSERT(size.x >= 0.0f);
  441|  90.2k|        PHI_ASSERT(!(phi::is_nan(size.x) || phi::is_infinity(size.x)));
  442|       |
  443|  90.2k|        PHI_ASSERT(size.y >= 0.0f);
  444|  90.2k|        PHI_ASSERT(!(phi::is_nan(size.y) || phi::is_infinity(size.y)));
  445|       |
  446|  90.2k|        if (ImGui::Begin("Code Editor"))
  ------------------
  |  Branch (446:13): [True: 323, False: 89.9k]
  ------------------
  447|    323|        {
  448|    323|            ImGui::BeginChild("Code Editor", size, border.unsafe(),
  449|    323|                              ImGuiWindowFlags_HorizontalScrollbar |
  450|    323|                                      ImGuiWindowFlags_AlwaysHorizontalScrollbar |
  451|    323|                                      ImGuiWindowFlags_NoMove);
  452|       |
  453|       |            // Need to calculate char advance before any inputs which use the values
  454|    323|            ComputeCharAdvance();
  455|       |
  456|    323|            HandleKeyboardInputs();
  457|    323|            ImGui::PushAllowKeyboardFocus(true);
  458|       |
  459|    323|            HandleMouseInputs();
  460|       |
  461|    323|            if (m_TextChanged)
  ------------------
  |  Branch (461:17): [True: 83, False: 240]
  ------------------
  462|     83|            {
  463|     83|                m_FullText = GetText();
  464|       |
  465|     83|                m_Emulator->ParseProgram(m_FullText);
  466|       |
  467|     83|                ColorizeInternal();
  468|       |
  469|     83|                ClearErrorMarkers();
  470|       |
  471|       |                // Add error markers
  472|     83|                for (const dlx::ParseError& err : m_Emulator->m_DLXProgram.m_ParseErrors)
  ------------------
  |  Branch (472:49): [True: 163, False: 83]
  ------------------
  473|    163|                {
  474|    163|                    AddErrorMarker(static_cast<phi::uint32_t>(err.GetLineNumber()),
  475|    163|                                   err.ConstructMessage());
  476|    163|                }
  477|       |
  478|     83|                m_TextChanged = false;
  479|     83|            }
  480|       |
  481|    323|            InternalRender();
  482|       |
  483|    323|            ImGui::PopAllowKeyboardFocus();
  484|       |
  485|    323|            ImGui::EndChild();
  486|    323|        }
  487|  90.2k|        ImGui::End();
  488|       |
  489|  90.2k|        ImGui::PopStyleVar();
  490|  90.2k|        ImGui::PopStyleColor();
  491|  90.2k|    }
_ZN6dlxemu10CodeEditor7SetTextERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  494|  1.10k|    {
  495|  1.10k|        m_Lines.clear();
  496|  1.10k|        ResetState();
  497|  1.10k|        m_Lines.emplace_back(Line());
  498|       |
  499|  1.10k|        for (const char character : text)
  ------------------
  |  Branch (499:35): [True: 0, False: 1.10k]
  ------------------
  500|      0|        {
  501|      0|            if (character == '\r' ||
  ------------------
  |  Branch (501:17): [True: 0, False: 0]
  |  Branch (501:17): [True: 0, False: 0]
  ------------------
  502|      0|                (phi::is_control(character) && character != '\n' && character != '\t'))
  ------------------
  |  Branch (502:18): [True: 0, False: 0]
  |  Branch (502:48): [True: 0, False: 0]
  |  Branch (502:69): [True: 0, False: 0]
  ------------------
  503|      0|            {
  504|       |                // ignore the carriage return character and control characters
  505|      0|            }
  506|      0|            else if (character == '\n')
  ------------------
  |  Branch (506:22): [True: 0, False: 0]
  ------------------
  507|      0|            {
  508|      0|                m_Lines.emplace_back(Line());
  509|      0|            }
  510|      0|            else
  511|      0|            {
  512|      0|                m_Lines.back().emplace_back(
  513|      0|                        Glyph(static_cast<Char>(character), PaletteIndex::Default));
  514|      0|            }
  515|      0|        }
  516|       |
  517|  1.10k|        m_TextChanged = true;
  518|  1.10k|        m_ScrollToTop = true;
  519|       |
  520|  1.10k|        m_UndoBuffer.clear();
  521|  1.10k|        m_UndoIndex = 0u;
  522|       |
  523|  1.10k|        Colorize();
  524|  1.10k|    }
_ZNK6dlxemu10CodeEditor7GetTextEv:
  527|   159k|    {
  528|   159k|        const phi::u32 max_line = GetMaxLineNumber();
  529|       |
  530|   159k|        return GetText(Coordinates(0u, 0u), Coordinates(max_line, GetLineMaxColumn(max_line)));
  531|   159k|    }
_ZN6dlxemu10CodeEditor9ClearTextEv:
  534|    359|    {
  535|    359|        PHI_ASSERT(!m_Lines.empty());
  536|       |
  537|    359|        if (IsReadOnly())
  ------------------
  |  Branch (537:13): [True: 128, False: 231]
  ------------------
  538|    128|        {
  539|    128|            return;
  540|    128|        }
  541|       |
  542|       |        // No text to clear
  543|    231|        if (m_Lines.size() == 1u && m_Lines[0u].empty())
  ------------------
  |  Branch (543:13): [True: 171, False: 60]
  |  Branch (543:37): [True: 34, False: 137]
  ------------------
  544|     34|        {
  545|     34|            return;
  546|     34|        }
  547|       |
  548|    197|        UndoRecord undo;
  549|    197|        undo.StoreBeforeState(this);
  550|       |
  551|    197|        undo.m_Removed      = GetText();
  552|    197|        undo.m_RemovedStart = Coordinates(0u, 0u);
  553|    197|        phi::u32 max_line   = GetMaxLineNumber();
  554|    197|        undo.m_RemovedEnd   = Coordinates(max_line, GetLineMaxColumn(max_line));
  555|       |
  556|    197|        m_Lines.clear();
  557|    197|        m_Lines.emplace_back(Line{});
  558|    197|        ResetState();
  559|       |
  560|    197|        undo.StoreAfterState(this);
  561|    197|        AddUndo(undo);
  562|    197|    }
_ZN6dlxemu10CodeEditor12SetTextLinesERKNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE:
  565|    221|    {
  566|    221|        m_Lines.clear();
  567|    221|        ResetState();
  568|       |
  569|    221|        if (lines.empty())
  ------------------
  |  Branch (569:13): [True: 9, False: 212]
  ------------------
  570|      9|        {
  571|      9|            m_Lines.emplace_back(Line());
  572|      9|        }
  573|    212|        else
  574|    212|        {
  575|    212|            m_Lines.resize(lines.size());
  576|       |
  577|    212|            phi::usize line_number{0u};
  578|    908|            for (phi::usize index = 0u; index < lines.size(); ++index, ++line_number)
  ------------------
  |  Branch (578:41): [True: 696, False: 212]
  ------------------
  579|    696|            {
  580|    696|                const std::string& line = lines[index.unsafe()];
  581|       |
  582|    696|                m_Lines[line_number.unsafe()].reserve(line.size());
  583|    696|                for (char character : line)
  ------------------
  |  Branch (583:37): [True: 0, False: 696]
  ------------------
  584|      0|                {
  585|      0|                    if (character == '\n')
  ------------------
  |  Branch (585:25): [True: 0, False: 0]
  ------------------
  586|      0|                    {
  587|       |                        // Hang on an extra line at the end
  588|      0|                        m_Lines.emplace_back(Line{});
  589|       |
  590|       |                        // Increase line number
  591|      0|                        line_number += 1u;
  592|      0|                    }
  593|      0|                    else
  594|      0|                    {
  595|      0|                        m_Lines[line_number.unsafe()].emplace_back(
  596|      0|                                Glyph(static_cast<Char>(character), PaletteIndex::Default));
  597|      0|                    }
  598|      0|                }
  599|    696|            }
  600|    212|        }
  601|       |
  602|    221|        m_TextChanged = true;
  603|    221|        m_ScrollToTop = true;
  604|       |
  605|    221|        m_UndoBuffer.clear();
  606|    221|        m_UndoIndex = 0u;
  607|       |
  608|    221|        Colorize();
  609|    221|    }
_ZNK6dlxemu10CodeEditor12GetTextLinesEv:
  612|    323|    {
  613|    323|        std::vector<std::string> result;
  614|       |
  615|    323|        result.reserve(m_Lines.size());
  616|       |
  617|    323|        for (const Line& line : m_Lines)
  ------------------
  |  Branch (617:31): [True: 2.04k, False: 323]
  ------------------
  618|  2.04k|        {
  619|  2.04k|            std::string text;
  620|       |
  621|  2.04k|            text.resize(line.size());
  622|       |
  623|   219k|            for (size_t i = 0; i < line.size(); ++i)
  ------------------
  |  Branch (623:32): [True: 217k, False: 2.04k]
  ------------------
  624|   217k|            {
  625|   217k|                text[i] = static_cast<char>(line[i].m_Char);
  626|   217k|            }
  627|       |
  628|  2.04k|            result.emplace_back(phi::move(text));
  629|  2.04k|        }
  630|       |
  631|    323|        return result;
  632|    323|    }
_ZNK6dlxemu10CodeEditor15GetSelectedTextEv:
  635|  5.68k|    {
  636|  5.68k|        return GetText(m_State.m_SelectionStart, m_State.m_SelectionEnd);
  637|  5.68k|    }
_ZNK6dlxemu10CodeEditor18GetCurrentLineTextEv:
  640|    298|    {
  641|    298|        const phi::u32 line_length = GetLineMaxColumn(m_State.m_CursorPosition.m_Line);
  642|       |
  643|    298|        return GetText(Coordinates(m_State.m_CursorPosition.m_Line, 0u),
  644|    298|                       Coordinates(m_State.m_CursorPosition.m_Line, line_length));
  645|    298|    }
_ZN6dlxemu10CodeEditor12SetOverwriteEN3phi7booleanE:
  653|    453|    {
  654|    453|        m_Overwrite = overwrite;
  655|    453|    }
_ZN6dlxemu10CodeEditor11SetReadOnlyEN3phi7booleanE:
  668|  1.97k|    {
  669|  1.97k|        m_ReadOnly = value;
  670|  1.97k|    }
_ZNK6dlxemu10CodeEditor10IsReadOnlyEv:
  678|  56.4k|    {
  679|  56.4k|        return m_ReadOnly;
  680|  56.4k|    }
_ZN6dlxemu10CodeEditor18SetColorizerEnableEN3phi7booleanE:
  693|    304|    {
  694|    304|        m_ColorizerEnabled = value;
  695|    304|    }
_ZNK6dlxemu10CodeEditor17GetCursorPositionEv:
  708|   109k|    {
  709|   109k|        return GetActualCursorCoordinates();
  710|   109k|    }
_ZN6dlxemu10CodeEditor17SetCursorPositionERKNS0_11CoordinatesE:
  713|  78.4k|    {
  714|       |        // Sanitize
  715|  78.4k|        const Coordinates new_pos = SanitizeCoordinates(position);
  716|       |
  717|  78.4k|        if (m_State.m_CursorPosition != new_pos)
  ------------------
  |  Branch (717:13): [True: 52.1k, False: 26.3k]
  ------------------
  718|  52.1k|        {
  719|  52.1k|            m_State.m_CursorPosition = new_pos;
  720|  52.1k|            m_CursorPositionChanged  = true;
  721|  52.1k|            EnsureCursorVisible();
  722|  52.1k|        }
  723|  78.4k|    }
_ZN6dlxemu10CodeEditor18SetShowWhitespacesEN3phi7booleanE:
  726|      9|    {
  727|      9|        m_ShowWhitespaces = value;
  728|      9|    }
_ZN6dlxemu10CodeEditor10SetTabSizeEN3phi7integerIhEE:
  741|  1.95k|    {
  742|  1.95k|        new_tab_size = phi::clamp(new_tab_size, MinTabSize, MaxTabSize);
  743|       |
  744|  1.95k|        if (new_tab_size != m_TabSize)
  ------------------
  |  Branch (744:13): [True: 1.26k, False: 687]
  ------------------
  745|  1.26k|        {
  746|       |            // Save old character indexes
  747|  1.26k|            const phi::u32 cursor_char_index          = GetCharacterIndex(m_State.m_CursorPosition);
  748|  1.26k|            const phi::u32 selection_start_char_index = GetCharacterIndex(m_State.m_SelectionStart);
  749|  1.26k|            const phi::u32 selection_end_char_index   = GetCharacterIndex(m_State.m_SelectionEnd);
  750|       |
  751|       |            // Update tab size
  752|  1.26k|            m_TabSize = new_tab_size;
  753|       |
  754|       |            // Set new character indexes
  755|  1.26k|            m_State.m_CursorPosition.m_Column =
  756|  1.26k|                    GetCharacterColumn(m_State.m_CursorPosition.m_Line, cursor_char_index);
  757|  1.26k|            m_State.m_SelectionStart.m_Column =
  758|  1.26k|                    GetCharacterColumn(m_State.m_SelectionStart.m_Line, selection_start_char_index);
  759|  1.26k|            m_State.m_SelectionEnd.m_Column =
  760|  1.26k|                    GetCharacterColumn(m_State.m_SelectionEnd.m_Line, selection_end_char_index);
  761|  1.26k|        }
  762|  1.95k|    }
_ZN6dlxemu10CodeEditor14EnterCharacterEtN3phi7booleanE:
  770|  32.0k|    {
  771|  32.0k|        if (!IsReadOnly() && character != '\0' && IsValidUTF8Sequence(character))
  ------------------
  |  Branch (771:13): [True: 31.8k, False: 237]
  |  Branch (771:13): [True: 30.9k, False: 1.15k]
  |  Branch (771:30): [True: 30.9k, False: 921]
  |  Branch (771:51): [True: 30.9k, False: 0]
  ------------------
  772|  30.9k|        {
  773|  30.9k|            EnterCharacterImpl(character, shift);
  774|  30.9k|        }
  775|  32.0k|    }
_ZN6dlxemu10CodeEditor9BackspaceEv:
  778|  7.43k|    {
  779|  7.43k|        if (!IsReadOnly())
  ------------------
  |  Branch (779:13): [True: 7.43k, False: 1]
  ------------------
  780|  7.43k|        {
  781|  7.43k|            BackspaceImpl();
  782|  7.43k|        }
  783|  7.43k|    }
_ZN6dlxemu10CodeEditor10InsertTextERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  786|    473|    {
  787|    473|        InsertText(value.c_str());
  788|    473|    }
_ZN6dlxemu10CodeEditor10InsertTextEPKc:
  791|  14.3k|    {
  792|  14.3k|        if (value == nullptr || m_ReadOnly)
  ------------------
  |  Branch (792:13): [True: 0, False: 14.3k]
  |  Branch (792:33): [True: 6, False: 14.3k]
  ------------------
  793|      6|        {
  794|      6|            return;
  795|      6|        }
  796|       |
  797|  14.3k|        Coordinates       pos         = GetActualCursorCoordinates();
  798|  14.3k|        const Coordinates start       = HasSelection() ? m_State.m_SelectionStart : pos;
  ------------------
  |  Branch (798:41): [True: 21, False: 14.2k]
  ------------------
  799|  14.3k|        phi::u32          total_lines = pos.m_Line - start.m_Line;
  800|       |
  801|  14.3k|        total_lines += InsertTextAt(pos, value);
  802|       |
  803|  14.3k|        SetSelection(pos, pos);
  804|  14.3k|        SetCursorPosition(pos);
  805|       |
  806|  14.3k|        Colorize(start.m_Line, total_lines);
  807|  14.3k|    }
_ZN6dlxemu10CodeEditor6MoveUpEN3phi7integerIjEENS1_7booleanE:
  810|    301|    {
  811|    301|        if (amount == 0u)
  ------------------
  |  Branch (811:13): [True: 0, False: 301]
  ------------------
  812|      0|        {
  813|      0|            return;
  814|      0|        }
  815|       |
  816|    301|        const Coordinates old_pos = m_State.m_CursorPosition;
  817|       |
  818|       |        // Move cursor to the beginning of the first line
  819|    301|        if (amount > old_pos.m_Line)
  ------------------
  |  Branch (819:13): [True: 141, False: 160]
  ------------------
  820|    141|        {
  821|    141|            m_State.m_CursorPosition.m_Line   = 0u;
  822|    141|            m_State.m_CursorPosition.m_Column = 0u;
  823|    141|        }
  824|    160|        else
  825|    160|        {
  826|    160|            PHI_ASSERT(amount <= m_State.m_CursorPosition.m_Line);
  827|    160|            m_State.m_CursorPosition.m_Line -= amount;
  828|    160|        }
  829|       |
  830|    301|        FixSelectionAfterMove(select, old_pos);
  831|    301|    }
_ZN6dlxemu10CodeEditor8MoveDownEN3phi7integerIjEENS1_7booleanE:
  834|  2.12k|    {
  835|  2.12k|        if (amount == 0u)
  ------------------
  |  Branch (835:13): [True: 4, False: 2.11k]
  ------------------
  836|      4|        {
  837|      4|            return;
  838|      4|        }
  839|       |
  840|  2.11k|        const Coordinates old_pos  = m_State.m_CursorPosition;
  841|  2.11k|        const phi::u32    max_line = GetMaxLineNumber();
  842|       |
  843|  2.11k|        PHI_ASSERT(old_pos.m_Line <= max_line);
  844|       |
  845|       |        // Move cursor to the end of the line after we reached the bottom
  846|  2.11k|        if (amount > max_line - old_pos.m_Line)
  ------------------
  |  Branch (846:13): [True: 2.06k, False: 52]
  ------------------
  847|  2.06k|        {
  848|  2.06k|            m_State.m_CursorPosition.m_Line   = max_line;
  849|  2.06k|            m_State.m_CursorPosition.m_Column = GetLineMaxColumn(max_line);
  850|  2.06k|        }
  851|     52|        else
  852|     52|        {
  853|     52|            m_State.m_CursorPosition.m_Line += amount;
  854|     52|        }
  855|       |
  856|  2.11k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line <= max_line);
  857|       |
  858|  2.11k|        FixSelectionAfterMove(select, old_pos);
  859|  2.11k|    }
_ZN6dlxemu10CodeEditor8MoveLeftEN3phi7integerIjEENS1_7booleanES4_:
  862|  5.22k|    {
  863|  5.22k|        PHI_ASSERT(!m_Lines.empty());
  864|       |
  865|  5.22k|        if (amount == 0u)
  ------------------
  |  Branch (865:13): [True: 389, False: 4.83k]
  ------------------
  866|    389|        {
  867|    389|            return;
  868|    389|        }
  869|       |
  870|  4.83k|        const Coordinates old_pos = m_State.m_CursorPosition;
  871|  4.83k|        m_State.m_CursorPosition  = GetActualCursorCoordinates();
  872|  4.83k|        phi::u32 line             = m_State.m_CursorPosition.m_Line;
  873|  4.83k|        phi::u32 cindex           = GetCharacterIndex(m_State.m_CursorPosition);
  874|       |
  875|   135k|        while (amount > 0u)
  ------------------
  |  Branch (875:16): [True: 130k, False: 4.83k]
  ------------------
  876|   130k|        {
  877|   130k|            amount -= 1u;
  878|       |
  879|   130k|            if (cindex == 0u)
  ------------------
  |  Branch (879:17): [True: 72.5k, False: 57.7k]
  ------------------
  880|  72.5k|            {
  881|  72.5k|                if (line == 0u)
  ------------------
  |  Branch (881:21): [True: 4.60k, False: 67.8k]
  ------------------
  882|  4.60k|                {
  883|       |                    // We're already on the last line so we can't move further left
  884|  4.60k|                    amount = 0u;
  885|  4.60k|                }
  886|  67.8k|                else
  887|  67.8k|                {
  888|  67.8k|                    line -= 1u;
  889|  67.8k|                    cindex = static_cast<phi::uint32_t>(m_Lines[line.unsafe()].size());
  890|  67.8k|                }
  891|  72.5k|            }
  892|  57.7k|            else
  893|  57.7k|            {
  894|  57.7k|                --cindex;
  895|  57.7k|                if (cindex > 0u && m_Lines.size() > line)
  ------------------
  |  Branch (895:21): [True: 43.3k, False: 14.4k]
  |  Branch (895:21): [True: 43.3k, False: 14.4k]
  |  Branch (895:36): [True: 43.3k, False: 0]
  ------------------
  896|  43.3k|                {
  897|  81.3k|                    while (cindex > 0u &&
  ------------------
  |  Branch (897:28): [True: 73.3k, False: 7.95k]
  |  Branch (897:28): [True: 38.0k, False: 43.3k]
  ------------------
  898|  81.3k|                           IsUTFSequence(m_Lines[line.unsafe()][cindex.unsafe()].m_Char))
  ------------------
  |  Branch (898:28): [True: 38.0k, False: 35.3k]
  ------------------
  899|  38.0k|                    {
  900|  38.0k|                        --cindex;
  901|  38.0k|                    }
  902|  43.3k|                }
  903|  57.7k|            }
  904|       |
  905|   130k|            m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  906|   130k|            if (word_mode)
  ------------------
  |  Branch (906:17): [True: 84.7k, False: 45.4k]
  ------------------
  907|  84.7k|            {
  908|  84.7k|                m_State.m_CursorPosition = FindWordStart(m_State.m_CursorPosition);
  909|  84.7k|                cindex                   = GetCharacterIndex(m_State.m_CursorPosition);
  910|  84.7k|            }
  911|   130k|        }
  912|       |
  913|  4.83k|        m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  914|  4.83k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
  915|       |
  916|  4.83k|        FixSelectionAfterMove(select, old_pos);
  917|  4.83k|    }
_ZN6dlxemu10CodeEditor9MoveRightEN3phi7integerIjEENS1_7booleanES4_:
  921|    299|    {
  922|    299|        const Coordinates old_pos = m_State.m_CursorPosition;
  923|       |
  924|    299|        if (old_pos.m_Line >= m_Lines.size() || amount == 0u)
  ------------------
  |  Branch (924:13): [True: 0, False: 299]
  |  Branch (924:13): [True: 10, False: 289]
  |  Branch (924:49): [True: 10, False: 289]
  ------------------
  925|     10|        {
  926|     10|            return;
  927|     10|        }
  928|       |
  929|    289|        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
  930|  6.46k|        while (amount > 0u)
  ------------------
  |  Branch (930:16): [True: 6.27k, False: 188]
  ------------------
  931|  6.27k|        {
  932|  6.27k|            amount -= 1u;
  933|       |
  934|  6.27k|            const phi::u32 lindex = m_State.m_CursorPosition.m_Line;
  935|  6.27k|            PHI_ASSERT(lindex < m_Lines.size());
  936|  6.27k|            const Line& line = m_Lines[lindex.unsafe()];
  937|       |
  938|  6.27k|            if (cindex >= line.size())
  ------------------
  |  Branch (938:17): [True: 4.47k, False: 1.80k]
  ------------------
  939|  4.47k|            {
  940|  4.47k|                if (m_State.m_CursorPosition.m_Line < GetMaxLineNumber())
  ------------------
  |  Branch (940:21): [True: 4.37k, False: 101]
  ------------------
  941|  4.37k|                {
  942|  4.37k|                    m_State.m_CursorPosition.m_Line =
  943|  4.37k|                            phi::clamp(m_State.m_CursorPosition.m_Line.unsafe() + 1u, 0u,
  944|  4.37k|                                       GetMaxLineNumber().unsafe());
  945|  4.37k|                    m_State.m_CursorPosition.m_Column = 0u;
  946|  4.37k|                }
  947|    101|                else
  948|    101|                {
  949|    101|                    return;
  950|    101|                }
  951|  4.47k|            }
  952|  1.80k|            else
  953|  1.80k|            {
  954|  1.80k|                PHI_ASSERT(cindex < line.size());
  955|  1.80k|                cindex += UTF8CharLength(line[cindex.unsafe()].m_Char);
  956|  1.80k|                m_State.m_CursorPosition = Coordinates(lindex, GetCharacterColumn(lindex, cindex));
  957|       |
  958|  1.80k|                if (word_mode)
  ------------------
  |  Branch (958:21): [True: 1.62k, False: 179]
  ------------------
  959|  1.62k|                {
  960|  1.62k|                    m_State.m_CursorPosition = FindNextWord(m_State.m_CursorPosition);
  961|  1.62k|                }
  962|  1.80k|            }
  963|  6.27k|        }
  964|       |
  965|    188|        FixSelectionAfterMove(select, old_pos);
  966|    188|    }
_ZN6dlxemu10CodeEditor7MoveTopEN3phi7booleanE:
  969|    595|    {
  970|    595|        const Coordinates old_pos = m_State.m_CursorPosition;
  971|    595|        SetCursorPosition(Coordinates(0u, 0u));
  972|       |
  973|    595|        if (select)
  ------------------
  |  Branch (973:13): [True: 297, False: 298]
  ------------------
  974|    297|        {
  975|    297|            m_InteractiveEnd   = old_pos;
  976|    297|            m_InteractiveStart = m_State.m_CursorPosition;
  977|    297|        }
  978|    298|        else
  979|    298|        {
  980|    298|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
  981|    298|        }
  982|       |
  983|    595|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
  984|    595|        EnsureCursorVisible();
  985|    595|    }
_ZN6dlxemu10CodeEditor10MoveBottomEN3phi7booleanE:
  988|    150|    {
  989|    150|        const Coordinates old_pos = GetCursorPosition();
  990|       |
  991|    150|        const phi::u32 end_line = GetMaxLineNumber();
  992|    150|        Coordinates    new_pos  = Coordinates(end_line, GetLineMaxColumn(end_line));
  993|       |
  994|    150|        SetCursorPosition(new_pos);
  995|    150|        if (select)
  ------------------
  |  Branch (995:13): [True: 150, False: 0]
  ------------------
  996|    150|        {
  997|    150|            m_InteractiveStart = old_pos;
  998|    150|            m_InteractiveEnd   = new_pos;
  999|    150|        }
 1000|      0|        else
 1001|      0|        {
 1002|      0|            m_InteractiveStart = m_InteractiveEnd = new_pos;
 1003|      0|        }
 1004|       |
 1005|    150|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
 1006|    150|        EnsureCursorVisible();
 1007|    150|    }
_ZN6dlxemu10CodeEditor8MoveHomeEN3phi7booleanE:
 1010|  3.39k|    {
 1011|  3.39k|        const Coordinates old_pos = m_State.m_CursorPosition;
 1012|  3.39k|        SetCursorPosition(Coordinates(m_State.m_CursorPosition.m_Line, 0u));
 1013|       |
 1014|  3.39k|        FixSelectionAfterMove(select, old_pos);
 1015|  3.39k|    }
_ZN6dlxemu10CodeEditor7MoveEndEN3phi7booleanE:
 1018|    424|    {
 1019|    424|        Coordinates old_pos = m_State.m_CursorPosition;
 1020|    424|        SetCursorPosition(
 1021|    424|                Coordinates(m_State.m_CursorPosition.m_Line, GetLineMaxColumn(old_pos.m_Line)));
 1022|       |
 1023|    424|        FixSelectionAfterMove(select, old_pos);
 1024|    424|    }
_ZN6dlxemu10CodeEditor17SetSelectionStartERKNS0_11CoordinatesE:
 1027|    209|    {
 1028|    209|        m_State.m_SelectionStart = SanitizeCoordinates(position);
 1029|    209|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1029:13): [True: 204, False: 5]
  ------------------
 1030|    204|        {
 1031|    204|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1032|    204|        }
 1033|    209|    }
_ZN6dlxemu10CodeEditor15SetSelectionEndERKNS0_11CoordinatesE:
 1036|     48|    {
 1037|     48|        m_State.m_SelectionEnd = SanitizeCoordinates(position);
 1038|     48|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1038:13): [True: 0, False: 48]
  ------------------
 1039|      0|        {
 1040|      0|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1041|      0|        }
 1042|     48|    }
_ZN6dlxemu10CodeEditor12SetSelectionERKNS0_11CoordinatesES3_NS0_13SelectionModeE:
 1048|  62.8k|    {
 1049|  62.8k|        const Coordinates old_sel_start = m_State.m_SelectionStart;
 1050|  62.8k|        const Coordinates old_sel_end   = m_State.m_SelectionEnd;
 1051|       |
 1052|  62.8k|        m_State.m_SelectionStart = SanitizeCoordinates(start);
 1053|  62.8k|        m_State.m_SelectionEnd   = SanitizeCoordinates(end);
 1054|  62.8k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1054:13): [True: 744, False: 62.0k]
  ------------------
 1055|    744|        {
 1056|    744|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1057|    744|        }
 1058|       |
 1059|  62.8k|        switch (mode)
 1060|  62.8k|        {
 1061|  62.5k|            case CodeEditor::SelectionMode::Normal:
  ------------------
  |  Branch (1061:13): [True: 62.5k, False: 269]
  ------------------
 1062|  62.5k|                break;
 1063|    269|            case CodeEditor::SelectionMode::Word: {
  ------------------
  |  Branch (1063:13): [True: 269, False: 62.5k]
  ------------------
 1064|    269|                m_State.m_SelectionStart = FindWordStart(m_State.m_SelectionStart);
 1065|    269|                if (!IsOnWordBoundary(m_State.m_SelectionEnd))
  ------------------
  |  Branch (1065:21): [True: 0, False: 269]
  ------------------
 1066|      0|                {
 1067|      0|                    m_State.m_SelectionEnd = FindWordEnd(FindWordStart(m_State.m_SelectionEnd));
 1068|      0|                }
 1069|    269|                break;
 1070|      0|            }
 1071|      0|            case CodeEditor::SelectionMode::Line: {
  ------------------
  |  Branch (1071:13): [True: 0, False: 62.8k]
  ------------------
 1072|      0|                const phi::u32 line_no   = m_State.m_SelectionEnd.m_Line;
 1073|      0|                m_State.m_SelectionStart = Coordinates(m_State.m_SelectionStart.m_Line, 0u);
 1074|      0|                m_State.m_SelectionEnd   = Coordinates(line_no, GetLineMaxColumn(line_no));
 1075|      0|                break;
 1076|      0|            }
 1077|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
 1078|      0|            default:
  ------------------
  |  Branch (1078:13): [True: 0, False: 62.8k]
  ------------------
 1079|      0|                PHI_ASSERT_NOT_REACHED();
 1080|  62.8k|#endif
 1081|  62.8k|        }
 1082|       |
 1083|  62.8k|        if (m_State.m_SelectionStart != old_sel_start || m_State.m_SelectionEnd != old_sel_end)
  ------------------
  |  Branch (1083:13): [True: 20.3k, False: 42.4k]
  |  Branch (1083:13): [True: 24.1k, False: 38.6k]
  |  Branch (1083:58): [True: 3.84k, False: 38.6k]
  ------------------
 1084|  24.1k|        {
 1085|  24.1k|            m_CursorPositionChanged = true;
 1086|  24.1k|        }
 1087|  62.8k|    }
_ZN6dlxemu10CodeEditor21SelectWordUnderCursorEv:
 1092|    827|    {
 1093|    827|        const Coordinates coords = GetCursorPosition();
 1094|    827|        SetSelection(FindWordStart(coords), FindWordEnd(coords));
 1095|    827|    }
_ZN6dlxemu10CodeEditor9SelectAllEv:
 1098|    413|    {
 1099|    413|        SetSelection(Coordinates(0u, 0u),
 1100|    413|                     Coordinates(static_cast<phi::uint32_t>(m_Lines.size()), 0u));
 1101|    413|    }
_ZN6dlxemu10CodeEditor14ClearSelectionEv:
 1104|  31.7k|    {
 1105|  31.7k|        SetSelection(Coordinates(0u, 0u), Coordinates(0u, 0u));
 1106|  31.7k|    }
_ZNK6dlxemu10CodeEditor12HasSelectionEv:
 1109|  77.1k|    {
 1110|  77.1k|        return m_State.m_SelectionEnd > m_State.m_SelectionStart;
 1111|  77.1k|    }
_ZNK6dlxemu10CodeEditor17GetSelectionStartEv:
 1114|   107k|    {
 1115|   107k|        return m_State.m_SelectionStart;
 1116|   107k|    }
_ZNK6dlxemu10CodeEditor15GetSelectionEndEv:
 1119|   107k|    {
 1120|   107k|        return m_State.m_SelectionEnd;
 1121|   107k|    }
_ZNK6dlxemu10CodeEditor4CopyEv:
 1124|  7.66k|    {
 1125|  7.66k|        if (HasSelection())
  ------------------
  |  Branch (1125:13): [True: 2.40k, False: 5.25k]
  ------------------
 1126|  2.40k|        {
 1127|  2.40k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1128|  2.40k|            m_FuzzingClipboardText = GetSelectedText();
 1129|       |#else
 1130|       |            ImGui::SetClipboardText(GetSelectedText().c_str());
 1131|       |#endif
 1132|  2.40k|        }
 1133|  5.25k|        else
 1134|  5.25k|        {
 1135|  5.25k|            PHI_ASSERT(!m_Lines.empty());
 1136|       |
 1137|  5.25k|            std::string str;
 1138|  5.25k|            const Line& line = m_Lines[GetActualCursorCoordinates().m_Line.unsafe()];
 1139|       |
 1140|  5.25k|            for (const Glyph& glyph : line)
  ------------------
  |  Branch (1140:37): [True: 34.3M, False: 5.25k]
  ------------------
 1141|  34.3M|            {
 1142|  34.3M|                str.push_back(static_cast<char>(glyph.m_Char));
 1143|  34.3M|            }
 1144|       |
 1145|  5.25k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1146|  5.25k|            m_FuzzingClipboardText = str;
 1147|       |#else
 1148|       |            ImGui::SetClipboardText(str.c_str());
 1149|       |#endif
 1150|  5.25k|        }
 1151|  7.66k|    }
_ZN6dlxemu10CodeEditor3CutEv:
 1154|     38|    {
 1155|     38|        if (IsReadOnly())
  ------------------
  |  Branch (1155:13): [True: 0, False: 38]
  ------------------
 1156|      0|        {
 1157|      0|            Copy();
 1158|      0|        }
 1159|     38|        else
 1160|     38|        {
 1161|     38|            if (HasSelection())
  ------------------
  |  Branch (1161:17): [True: 37, False: 1]
  ------------------
 1162|     37|            {
 1163|     37|                UndoRecord undo;
 1164|     37|                undo.StoreBeforeState(this);
 1165|     37|                undo.m_Removed      = GetSelectedText();
 1166|     37|                undo.m_RemovedStart = m_State.m_SelectionStart;
 1167|     37|                undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1168|       |
 1169|     37|                Copy();
 1170|     37|                DeleteSelection();
 1171|       |
 1172|     37|                undo.StoreAfterState(this);
 1173|     37|                AddUndo(undo);
 1174|     37|            }
 1175|     38|        }
 1176|     38|    }
_ZN6dlxemu10CodeEditor5PasteEv:
 1179|  14.7k|    {
 1180|  14.7k|        if (IsReadOnly())
  ------------------
  |  Branch (1180:13): [True: 71, False: 14.6k]
  ------------------
 1181|     71|        {
 1182|     71|            return;
 1183|     71|        }
 1184|       |
 1185|  14.6k|        const char* clip_text =
 1186|  14.6k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1187|  14.6k|                m_FuzzingClipboardText.c_str();
 1188|       |#else
 1189|       |                ImGui::GetClipboardText();
 1190|       |#endif
 1191|  14.6k|        if (phi::string_length(clip_text) == 0u)
  ------------------
  |  Branch (1191:13): [True: 817, False: 13.8k]
  ------------------
 1192|    817|        {
 1193|    817|            return;
 1194|    817|        }
 1195|       |
 1196|  13.8k|        UndoRecord undo;
 1197|  13.8k|        undo.StoreBeforeState(this);
 1198|       |
 1199|  13.8k|        if (HasSelection())
  ------------------
  |  Branch (1199:13): [True: 1.81k, False: 12.0k]
  ------------------
 1200|  1.81k|        {
 1201|  1.81k|            undo.m_Removed      = GetSelectedText();
 1202|  1.81k|            undo.m_RemovedStart = m_State.m_SelectionStart;
 1203|  1.81k|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1204|  1.81k|            DeleteSelection();
 1205|  1.81k|        }
 1206|       |
 1207|  13.8k|        undo.m_Added      = clip_text;
 1208|  13.8k|        undo.m_AddedStart = GetActualCursorCoordinates();
 1209|       |
 1210|  13.8k|        InsertText(clip_text);
 1211|       |
 1212|  13.8k|        undo.m_AddedEnd = GetActualCursorCoordinates();
 1213|  13.8k|        undo.StoreAfterState(this);
 1214|       |
 1215|  13.8k|        AddUndo(undo);
 1216|  13.8k|    }
_ZN6dlxemu10CodeEditor6DeleteEv:
 1219|  2.63k|    {
 1220|  2.63k|        PHI_ASSERT(!m_Lines.empty());
 1221|       |
 1222|  2.63k|        if (m_ReadOnly)
  ------------------
  |  Branch (1222:13): [True: 7, False: 2.62k]
  ------------------
 1223|      7|        {
 1224|      7|            return;
 1225|      7|        }
 1226|       |
 1227|  2.62k|        UndoRecord undo;
 1228|  2.62k|        undo.StoreBeforeState(this);
 1229|       |
 1230|  2.62k|        if (HasSelection())
  ------------------
  |  Branch (1230:13): [True: 101, False: 2.52k]
  ------------------
 1231|    101|        {
 1232|    101|            undo.m_Removed      = GetSelectedText();
 1233|    101|            undo.m_RemovedStart = m_State.m_SelectionStart;
 1234|    101|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1235|       |
 1236|    101|            DeleteSelection();
 1237|    101|        }
 1238|  2.52k|        else
 1239|  2.52k|        {
 1240|  2.52k|            const Coordinates pos = GetActualCursorCoordinates();
 1241|  2.52k|            PHI_ASSERT(pos.m_Line < m_Lines.size());
 1242|  2.52k|            PHI_ASSERT(pos.m_Column <= GetLineMaxColumn(pos.m_Line));
 1243|       |
 1244|  2.52k|            SetCursorPosition(pos);
 1245|  2.52k|            Line& line = m_Lines[pos.m_Line.unsafe()];
 1246|       |
 1247|  2.52k|            if (pos.m_Column == GetLineMaxColumn(pos.m_Line))
  ------------------
  |  Branch (1247:17): [True: 2.00k, False: 514]
  ------------------
 1248|  2.00k|            {
 1249|  2.00k|                if (pos.m_Line == GetMaxLineNumber())
  ------------------
  |  Branch (1249:21): [True: 1.41k, False: 594]
  ------------------
 1250|  1.41k|                {
 1251|  1.41k|                    return;
 1252|  1.41k|                }
 1253|       |
 1254|    594|                undo.m_Removed      = '\n';
 1255|    594|                undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 1256|    594|                Advance(undo.m_RemovedEnd);
 1257|       |
 1258|    594|                PHI_ASSERT(pos.m_Line + 1u < m_Lines.size());
 1259|    594|                const Line& next_line = m_Lines[pos.m_Line.unsafe() + 1];
 1260|    594|                line.insert(line.end(), next_line.begin(), next_line.end());
 1261|       |
 1262|    594|                PHI_ASSERT(pos.m_Line <= m_Lines.size());
 1263|    594|                RemoveLine(pos.m_Line + 1u);
 1264|    594|            }
 1265|    514|            else
 1266|    514|            {
 1267|       |                // Nothing todo when line is empty
 1268|    514|                if (line.empty())
  ------------------
  |  Branch (1268:21): [True: 0, False: 514]
  ------------------
 1269|      0|                {
 1270|      0|                    return;
 1271|      0|                }
 1272|       |
 1273|    514|                const phi::u32 cindex = GetCharacterIndex(pos);
 1274|    514|                PHI_ASSERT(cindex < line.size());
 1275|       |
 1276|    514|                const Coordinates current_cursor_pos = GetActualCursorCoordinates();
 1277|    514|                undo.m_RemovedStart                  = current_cursor_pos;
 1278|    514|                undo.m_RemovedEnd                    = current_cursor_pos;
 1279|    514|                undo.m_RemovedEnd.m_Column++;
 1280|    514|                undo.m_Removed = GetText(undo.m_RemovedStart, undo.m_RemovedEnd);
 1281|       |
 1282|    514|                phi::u8_fast length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1283|  1.99k|                while (length > 0u && cindex < line.size())
  ------------------
  |  Branch (1283:24): [True: 1.48k, False: 514]
  |  Branch (1283:24): [True: 1.48k, False: 514]
  |  Branch (1283:39): [True: 1.48k, False: 0]
  ------------------
 1284|  1.48k|                {
 1285|  1.48k|                    line.erase(line.begin() + cindex.unsafe());
 1286|  1.48k|                    length--;
 1287|  1.48k|                }
 1288|       |
 1289|       |                // Remove any kind of selection if we had any
 1290|    514|                ClearSelection();
 1291|    514|            }
 1292|       |
 1293|  1.10k|            m_TextChanged = true;
 1294|       |
 1295|  1.10k|            Colorize(pos.m_Line, 1);
 1296|  1.10k|        }
 1297|       |
 1298|  1.20k|        undo.StoreAfterState(this);
 1299|  1.20k|        AddUndo(undo);
 1300|  1.20k|    }
_ZNK6dlxemu10CodeEditor7CanUndoEv:
 1303|   161k|    {
 1304|   161k|        return !m_ReadOnly && m_UndoIndex != 0u;
  ------------------
  |  Branch (1304:16): [True: 161k, False: 0]
  |  Branch (1304:31): [True: 156k, False: 5.78k]
  ------------------
 1305|   161k|    }
_ZN6dlxemu10CodeEditor4UndoEN3phi7integerIjEE:
 1308|  54.6k|    {
 1309|   109k|        while (CanUndo() && steps > 0u)
  ------------------
  |  Branch (1309:16): [True: 103k, False: 5.78k]
  |  Branch (1309:16): [True: 54.6k, False: 54.6k]
  |  Branch (1309:29): [True: 54.6k, False: 48.8k]
  ------------------
 1310|  54.6k|        {
 1311|  54.6k|            m_UndoIndex -= 1u;
 1312|  54.6k|            m_UndoBuffer[m_UndoIndex.unsafe()].Undo(this);
 1313|  54.6k|            steps -= 1u;
 1314|  54.6k|        }
 1315|  54.6k|    }
_ZNK6dlxemu10CodeEditor7CanRedoEv:
 1318|   158k|    {
 1319|   158k|        return !m_ReadOnly && m_UndoIndex < m_UndoBuffer.size();
  ------------------
  |  Branch (1319:16): [True: 158k, False: 24]
  |  Branch (1319:31): [True: 105k, False: 52.8k]
  ------------------
 1320|   158k|    }
_ZN6dlxemu10CodeEditor4RedoEN3phi7integerIjEE:
 1323|  52.8k|    {
 1324|   105k|        while (CanRedo() && steps > 0u)
  ------------------
  |  Branch (1324:16): [True: 52.8k, False: 52.8k]
  |  Branch (1324:16): [True: 52.7k, False: 52.8k]
  |  Branch (1324:29): [True: 52.7k, False: 32]
  ------------------
 1325|  52.7k|        {
 1326|  52.7k|            m_UndoBuffer[m_UndoIndex.unsafe()].Redo(this);
 1327|  52.7k|            m_UndoIndex += 1u;
 1328|  52.7k|            steps -= 1u;
 1329|  52.7k|        }
 1330|  52.8k|    }
_ZN6dlxemu10CodeEditor13UpdatePaletteEv:
 1481|  9.34k|    {
 1482|  9.34k|        PHI_ASSERT(GImGui && GImGui->Initialized);
 1483|       |
 1484|       |        // Update palette with the current alpha from style
 1485|   140k|        for (phi::usize i = 0u; i < phi::to_underlying(PaletteIndex::Max); ++i)
  ------------------
  |  Branch (1485:33): [True: 130k, False: 9.34k]
  ------------------
 1486|   130k|        {
 1487|   130k|            ImVec4 color = ImGui::ColorConvertU32ToFloat4(m_PaletteBase[i]);
 1488|   130k|            color.w *= ImGui::GetStyle().Alpha;
 1489|   130k|            m_Palette[i] = ImGui::ColorConvertFloat4ToU32(color);
 1490|   130k|        }
 1491|  9.34k|    }
_ZNK6dlxemu10CodeEditor19VerifyInternalStateEv:
 1494|   230k|    {
 1495|       |        // Lines should never be empty
 1496|   230k|        PHI_ASSERT(!m_Lines.empty());
 1497|       |
 1498|       |        // Verify Selection is still in a valid state
 1499|   230k|        PHI_ASSERT(m_State.m_SelectionEnd >= m_State.m_SelectionStart);
 1500|   230k|        PHI_ASSERT(m_State.m_SelectionStart.m_Line < m_Lines.size());
 1501|   230k|        PHI_ASSERT(m_State.m_SelectionStart.m_Column >= 0u);
 1502|   230k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Line < m_Lines.size());
 1503|   230k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Column >= 0u);
 1504|       |
 1505|       |        // Verify cursor position
 1506|   230k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line >= 0u);
 1507|   230k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 1508|   230k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
 1509|       |
 1510|       |        // This should also always be true. But its implementation is way to slow when fuzzing
 1511|       |#if defined(DLXEMU_VERIFY_COLUMN)
 1512|       |        PHI_ASSERT(m_State.m_SelectionStart.m_Column <=
 1513|       |                   GetLineMaxColumn(m_State.m_SelectionStart.m_Line));
 1514|       |        PHI_ASSERT(m_State.m_SelectionEnd.m_Column <=
 1515|       |                   GetLineMaxColumn(m_State.m_SelectionEnd.m_Line));
 1516|       |#endif
 1517|       |
 1518|       |        // Verify that all breakpoints are on existing lines
 1519|   230k|        for (phi::u32 break_point : m_Breakpoints)
  ------------------
  |  Branch (1519:35): [True: 72.1k, False: 230k]
  ------------------
 1520|  72.1k|        {
 1521|  72.1k|            PHI_ASSERT(break_point != 0u);
 1522|  72.1k|            PHI_ASSERT(break_point <= m_Lines.size());
 1523|  72.1k|        }
 1524|       |
 1525|       |        // Verify that all error markers are on existing lines
 1526|   230k|        for (auto&& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (1526:34): [True: 41.4k, False: 230k]
  ------------------
 1527|  41.4k|        {
 1528|  41.4k|            const phi::u32 line_number = error_marker.first;
 1529|       |
 1530|  41.4k|            PHI_ASSERT(line_number != 0u);
 1531|  41.4k|            PHI_ASSERT(line_number <= m_Lines.size());
 1532|  41.4k|        }
 1533|   230k|    }
_ZN6dlxemu10CodeEditor14GetDarkPaletteEv:
 1536|  18.6k|    {
 1537|  18.6k|        constexpr const static Palette palette = {{
 1538|  18.6k|                0xff7f7f7f, // Default
 1539|  18.6k|                0xffd69c56, // OpCode
 1540|  18.6k|                0xff00ff00, // Register
 1541|  18.6k|                0xff7070e0, // IntegerLiteral
 1542|  18.6k|                0xff206020, // Comment
 1543|  18.6k|                0xff101010, // Background
 1544|  18.6k|                0xffe0e0e0, // Cursor
 1545|  18.6k|                0x80a06020, // Selection
 1546|  18.6k|                0x800020ff, // ErrorMarker
 1547|  18.6k|                0x40f08000, // Breakpoint
 1548|  18.6k|                0xff707000, // Line number
 1549|  18.6k|                0x40000000, // Current line fill
 1550|  18.6k|                0x40808080, // Current line fill (inactive)
 1551|  18.6k|                0x40a0a0a0, // Current line edge
 1552|  18.6k|        }};
 1553|       |
 1554|  18.6k|        return palette;
 1555|  18.6k|    }
_ZNK6dlxemu10CodeEditor11EditorStateeqERKS1_:
 1604|  52.7k|    {
 1605|  52.7k|        return other.m_CursorPosition == m_CursorPosition &&
  ------------------
  |  Branch (1605:16): [True: 52.7k, False: 0]
  ------------------
 1606|  52.7k|               other.m_SelectionStart == m_SelectionStart && other.m_SelectionEnd == m_SelectionEnd;
  ------------------
  |  Branch (1606:16): [True: 52.7k, False: 0]
  |  Branch (1606:62): [True: 52.7k, False: 0]
  ------------------
 1607|  52.7k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4UndoEPS0_:
 1618|  54.6k|    {
 1619|  54.6k|        PHI_ASSERT(editor != nullptr);
 1620|       |
 1621|  54.6k|        if (!m_Added.empty())
  ------------------
  |  Branch (1621:13): [True: 46.4k, False: 8.13k]
  ------------------
 1622|  46.4k|        {
 1623|  46.4k|            editor->DeleteRange(m_AddedStart, m_AddedEnd);
 1624|  46.4k|            editor->Colorize(m_AddedStart.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1625|  46.4k|        }
 1626|       |
 1627|  54.6k|        if (!m_Removed.empty())
  ------------------
  |  Branch (1627:13): [True: 11.6k, False: 42.9k]
  ------------------
 1628|  11.6k|        {
 1629|  11.6k|            Coordinates start = m_RemovedStart;
 1630|  11.6k|            editor->InsertTextAt(start, m_Removed.c_str());
 1631|  11.6k|            editor->Colorize(start.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1632|  11.6k|        }
 1633|       |
 1634|  54.6k|        ApplyBeforeState(editor);
 1635|  54.6k|        editor->EnsureCursorVisible();
 1636|  54.6k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4RedoEPS0_:
 1639|  52.7k|    {
 1640|  52.7k|        PHI_ASSERT(editor != nullptr);
 1641|       |
 1642|  52.7k|        if (!m_Removed.empty())
  ------------------
  |  Branch (1642:13): [True: 11.4k, False: 41.3k]
  ------------------
 1643|  11.4k|        {
 1644|  11.4k|            editor->DeleteRange(m_RemovedStart, m_RemovedEnd);
 1645|  11.4k|            editor->Colorize(m_RemovedStart.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1646|  11.4k|        }
 1647|       |
 1648|  52.7k|        if (!m_Added.empty())
  ------------------
  |  Branch (1648:13): [True: 44.7k, False: 8.02k]
  ------------------
 1649|  44.7k|        {
 1650|  44.7k|            Coordinates start = m_AddedStart;
 1651|  44.7k|            editor->InsertTextAt(start, m_Added.c_str());
 1652|  44.7k|            editor->Colorize(start.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1653|  44.7k|        }
 1654|       |
 1655|  52.7k|        ApplyAfterState(editor);
 1656|  52.7k|        editor->EnsureCursorVisible();
 1657|  52.7k|    }
_ZN6dlxemu10CodeEditor10UndoRecord16StoreBeforeStateEPS0_:
 1660|  55.0k|    {
 1661|  55.0k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1662|  55.0k|        const Coordinates selection_start = editor->GetSelectionStart();
 1663|  55.0k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1664|       |
 1665|  55.0k|        m_Before.m_CursorPosition = {cursor_position.m_Line,
 1666|  55.0k|                                     editor->GetCharacterIndex(cursor_position)};
 1667|  55.0k|        m_Before.m_SelectionStart = {selection_start.m_Line,
 1668|  55.0k|                                     editor->GetCharacterIndex(selection_start)};
 1669|  55.0k|        m_Before.m_SelectionEnd = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1670|  55.0k|    }
_ZN6dlxemu10CodeEditor10UndoRecord15StoreAfterStateEPS0_:
 1673|  52.7k|    {
 1674|  52.7k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1675|  52.7k|        const Coordinates selection_start = editor->GetSelectionStart();
 1676|  52.7k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1677|       |
 1678|  52.7k|        m_After.m_CursorPosition = {cursor_position.m_Line,
 1679|  52.7k|                                    editor->GetCharacterIndex(cursor_position)};
 1680|  52.7k|        m_After.m_SelectionStart = {selection_start.m_Line,
 1681|  52.7k|                                    editor->GetCharacterIndex(selection_start)};
 1682|  52.7k|        m_After.m_SelectionEnd   = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1683|  52.7k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord16ApplyBeforeStateEPS0_:
 1686|  54.6k|    {
 1687|  54.6k|        Coordinates cursor_position = m_Before.m_CursorPosition;
 1688|  54.6k|        cursor_position.m_Column =
 1689|  54.6k|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1690|  54.6k|        Coordinates selection_start = m_Before.m_SelectionStart;
 1691|  54.6k|        selection_start.m_Column =
 1692|  54.6k|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1693|  54.6k|        Coordinates selection_end = m_Before.m_SelectionEnd;
 1694|  54.6k|        selection_end.m_Column =
 1695|  54.6k|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1696|       |
 1697|  54.6k|        editor->m_State.m_CursorPosition = cursor_position;
 1698|  54.6k|        editor->m_State.m_SelectionStart = selection_start;
 1699|  54.6k|        editor->m_State.m_SelectionEnd   = selection_end;
 1700|  54.6k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord15ApplyAfterStateEPS0_:
 1703|  52.7k|    {
 1704|  52.7k|        Coordinates cursor_position = m_After.m_CursorPosition;
 1705|  52.7k|        cursor_position.m_Column =
 1706|  52.7k|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1707|  52.7k|        Coordinates selection_start = m_After.m_SelectionStart;
 1708|  52.7k|        selection_start.m_Column =
 1709|  52.7k|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1710|  52.7k|        Coordinates selection_end = m_After.m_SelectionEnd;
 1711|  52.7k|        selection_end.m_Column =
 1712|  52.7k|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1713|       |
 1714|  52.7k|        editor->m_State.m_CursorPosition = cursor_position;
 1715|  52.7k|        editor->m_State.m_SelectionStart = selection_start;
 1716|  52.7k|        editor->m_State.m_SelectionEnd   = selection_end;
 1717|  52.7k|    }
_ZN6dlxemu10CodeEditor8ColorizeEN3phi7integerIjEENS2_IlEE:
 1722|   189k|    {
 1723|       |        // TODO: This is quite unreadable
 1724|   189k|        const phi::u32 to_line =
 1725|   189k|                count == -1 ? static_cast<phi::uint32_t>(m_Lines.size()) :
  ------------------
  |  Branch (1725:17): [True: 20.0k, False: 169k]
  ------------------
 1726|   189k|                              phi::min(static_cast<phi::uint32_t>(m_Lines.size()),
 1727|   169k|                                       from_line + static_cast<phi::uint32_t>(count.unsafe()));
 1728|       |
 1729|   189k|        m_ColorRangeMin = phi::min(m_ColorRangeMin, from_line);
 1730|   189k|        m_ColorRangeMax = phi::max(m_ColorRangeMax, to_line);
 1731|   189k|        m_ColorRangeMin = phi::max(0u, m_ColorRangeMin);
 1732|   189k|        m_ColorRangeMax = phi::max(m_ColorRangeMin, m_ColorRangeMax);
 1733|   189k|    }
_ZNK6dlxemu10CodeEditor23TextDistanceToLineStartERKNS0_11CoordinatesE:
 1736|  1.00k|    {
 1737|  1.00k|        PHI_ASSERT(from.m_Line < m_Lines.size());
 1738|       |
 1739|  1.00k|        const Line& line     = m_Lines[from.m_Line.unsafe()];
 1740|  1.00k|        float       distance = 0.0f;
 1741|  1.00k|        float       space_size =
 1742|  1.00k|                ImGui::GetFont()
 1743|  1.00k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 1744|  1.00k|                        .x;
 1745|  1.00k|        const phi::u32 col_index = GetCharacterIndex(from);
 1746|  2.50k|        for (phi::usize it{0u}; it < line.size() && it < col_index;)
  ------------------
  |  Branch (1746:33): [True: 1.50k, False: 1.00k]
  |  Branch (1746:33): [True: 1.50k, False: 1.00k]
  |  Branch (1746:53): [True: 1.50k, False: 4]
  ------------------
 1747|  1.50k|        {
 1748|  1.50k|            if (line[it.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (1748:17): [True: 168, False: 1.33k]
  ------------------
 1749|    168|            {
 1750|    168|                distance = (1.0f + std::floor((1.0f + distance) /
 1751|    168|                                              (float(m_TabSize.unsafe()) * space_size))) *
 1752|    168|                           (float(m_TabSize.unsafe()) * space_size);
 1753|    168|                ++it;
 1754|    168|            }
 1755|  1.33k|            else
 1756|  1.33k|            {
 1757|  1.33k|                phi::u8_fast        length = UTF8CharLength(line[it.unsafe()].m_Char);
 1758|  1.33k|                phi::array<char, 7> temp_c_string;
 1759|  1.33k|                phi::usize          index = 0u;
 1760|  4.18k|                for (; index < 6u && length > 0u && it < line.size(); ++index, ++it, --length)
  ------------------
  |  Branch (1760:24): [True: 4.18k, False: 0]
  |  Branch (1760:24): [True: 2.84k, False: 1.33k]
  |  Branch (1760:38): [True: 2.84k, False: 1.33k]
  |  Branch (1760:53): [True: 2.84k, False: 0]
  ------------------
 1761|  2.84k|                {
 1762|  2.84k|                    temp_c_string[index] = static_cast<char>(line[it.unsafe()].m_Char);
 1763|  2.84k|                }
 1764|       |
 1765|  1.33k|                temp_c_string[index] = '\0';
 1766|  1.33k|                distance += ImGui::GetFont()
 1767|  1.33k|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 1768|  1.33k|                                                    temp_c_string.data(), nullptr, nullptr)
 1769|  1.33k|                                    .x;
 1770|  1.33k|            }
 1771|  1.50k|        }
 1772|       |
 1773|  1.00k|        return distance;
 1774|  1.00k|    }
_ZN6dlxemu10CodeEditor19EnsureCursorVisibleEv:
 1777|   178k|    {
 1778|   178k|        m_ScrollToCursor = true;
 1779|   178k|    }
_ZN6dlxemu10CodeEditor14ScrollToCursorEv:
 1782|     91|    {
 1783|     91|        PHI_ASSERT(m_ScrollToCursor);
 1784|       |
 1785|     91|        float scroll_x = ImGui::GetScrollX();
 1786|     91|        float scroll_y = ImGui::GetScrollY();
 1787|       |
 1788|     91|        float height = ImGui::GetWindowHeight();
 1789|     91|        float width  = ImGui::GetWindowWidth();
 1790|       |
 1791|     91|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 1792|     91|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 1793|     91|        phi::u32 top = 1u + static_cast<phi::uint32_t>(std::ceil(scroll_y / m_CharAdvance.y));
 1794|     91|        phi::u32 bottom =
 1795|     91|                static_cast<phi::uint32_t>(std::ceil((scroll_y + height) / m_CharAdvance.y));
 1796|       |
 1797|     91|        phi::u32 left = static_cast<phi::uint32_t>(std::ceil(scroll_x / m_CharAdvance.x));
 1798|     91|        phi::u32 right =
 1799|     91|                static_cast<phi::uint32_t>(std::ceil((scroll_x + width) / m_CharAdvance.x));
 1800|       |
 1801|     91|        Coordinates pos = GetActualCursorCoordinates();
 1802|     91|        float       len = TextDistanceToLineStart(pos);
 1803|       |
 1804|       |        // TODO: The 4 here seems like it could very well be a constant
 1805|       |
 1806|     91|        if (pos.m_Line < top)
  ------------------
  |  Branch (1806:13): [True: 38, False: 53]
  ------------------
 1807|     38|        {
 1808|     38|            ImGui::SetScrollY(phi::max(0.0f, static_cast<float>(pos.m_Line.unsafe()) - 1.0f) *
 1809|     38|                              m_CharAdvance.y);
 1810|     38|        }
 1811|     91|        if (pos.m_Line > bottom.unsafe() - 4u)
  ------------------
  |  Branch (1811:13): [True: 1, False: 90]
  ------------------
 1812|      1|        {
 1813|      1|            ImGui::SetScrollY(phi::max(
 1814|      1|                    0.0f,
 1815|      1|                    static_cast<float>((pos.m_Line + 4u).unsafe()) * m_CharAdvance.y - height));
 1816|      1|        }
 1817|     91|        if (len + m_TextStart < static_cast<float>((left + 4u).unsafe()))
  ------------------
  |  Branch (1817:13): [True: 2, False: 89]
  ------------------
 1818|      2|        {
 1819|      2|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart - 4.0f));
 1820|      2|        }
 1821|     91|        if (len + m_TextStart > static_cast<float>(right.unsafe()) - 4.0f)
  ------------------
  |  Branch (1821:13): [True: 89, False: 2]
  ------------------
 1822|     89|        {
 1823|     89|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart + 4.0f - width));
 1824|     89|        }
 1825|     91|    }
_ZNK6dlxemu10CodeEditor7GetTextERKNS0_11CoordinatesES3_:
 1839|   166k|    {
 1840|   166k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1841|   166k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1842|   166k|        PHI_ASSERT(start <= end);
 1843|       |
 1844|   166k|        std::string result;
 1845|       |
 1846|   166k|        phi::u32   lstart = start.m_Line;
 1847|   166k|        phi::u32   lend   = end.m_Line;
 1848|   166k|        phi::u32   istart = GetCharacterIndex(start);
 1849|   166k|        phi::u32   iend   = phi::min(GetCharacterIndex(end),
 1850|   166k|                                     static_cast<phi::uint32_t>(m_Lines[end.m_Line.unsafe()].size()));
 1851|   166k|        phi::usize size   = 0u;
 1852|       |
 1853|  2.54M|        for (phi::u32 i = lstart; i <= lend; ++i)
  ------------------
  |  Branch (1853:35): [True: 2.37M, False: 166k]
  ------------------
 1854|  2.37M|        {
 1855|  2.37M|            PHI_ASSERT(i < m_Lines.size());
 1856|  2.37M|            size += m_Lines[i.unsafe()].size();
 1857|  2.37M|        }
 1858|       |
 1859|   166k|        result.reserve((size + size / 8u).unsafe());
 1860|       |
 1861|   317M|        while (istart < iend || lstart < lend)
  ------------------
  |  Branch (1861:16): [True: 276M, False: 41.4M]
  |  Branch (1861:16): [True: 317M, False: 166k]
  |  Branch (1861:33): [True: 41.2M, False: 166k]
  ------------------
 1862|   317M|        {
 1863|   317M|            PHI_ASSERT(lstart < m_Lines.size());
 1864|       |
 1865|   317M|            const Line& line = m_Lines[lstart.unsafe()];
 1866|   317M|            if (istart < line.size())
  ------------------
  |  Branch (1866:17): [True: 315M, False: 2.20M]
  ------------------
 1867|   315M|            {
 1868|   315M|                result += static_cast<char>(line[istart.unsafe()].m_Char);
 1869|   315M|                istart++;
 1870|   315M|            }
 1871|  2.20M|            else
 1872|  2.20M|            {
 1873|  2.20M|                istart = 0u;
 1874|  2.20M|                ++lstart;
 1875|       |
 1876|  2.20M|                if (lstart != m_Lines.size())
  ------------------
  |  Branch (1876:21): [True: 2.20M, False: 0]
  ------------------
 1877|  2.20M|                {
 1878|  2.20M|                    result += '\n';
 1879|  2.20M|                }
 1880|  2.20M|            }
 1881|   317M|        }
 1882|       |
 1883|   166k|        return result;
 1884|   166k|    }
_ZNK6dlxemu10CodeEditor26GetActualCursorCoordinatesEv:
 1888|   236k|    {
 1889|   236k|        return SanitizeCoordinates(m_State.m_CursorPosition);
 1890|   236k|    }
_ZNK6dlxemu10CodeEditor19SanitizeCoordinatesERKNS0_11CoordinatesE:
 1894|   454k|    {
 1895|   454k|        PHI_ASSERT(!m_Lines.empty());
 1896|       |
 1897|   454k|        phi::u32 line   = value.m_Line;
 1898|   454k|        phi::u32 column = value.m_Column;
 1899|       |
 1900|   454k|        if (line >= m_Lines.size())
  ------------------
  |  Branch (1900:13): [True: 11.9k, False: 442k]
  ------------------
 1901|  11.9k|        {
 1902|  11.9k|            line   = GetMaxLineNumber();
 1903|  11.9k|            column = GetLineMaxColumn(line);
 1904|       |
 1905|  11.9k|            PHI_ASSERT(line < m_Lines.size());
 1906|  11.9k|            PHI_ASSERT(column <= GetLineMaxColumn(line));
 1907|       |
 1908|  11.9k|            return {line, column};
 1909|  11.9k|        }
 1910|       |
 1911|       |        // Sanitize column
 1912|   442k|        const Line& current_line = m_Lines[line.unsafe()];
 1913|   442k|        phi::u32    new_column   = 0u;
 1914|   437M|        for (phi::u32 char_index{0u}; char_index < current_line.size();)
  ------------------
  |  Branch (1914:39): [True: 437M, False: 324k]
  ------------------
 1915|   437M|        {
 1916|   437M|            if (new_column >= column)
  ------------------
  |  Branch (1916:17): [True: 117k, False: 437M]
  ------------------
 1917|   117k|            {
 1918|   117k|                break;
 1919|   117k|            }
 1920|       |
 1921|   437M|            const char current_char = static_cast<char>(current_line[char_index.unsafe()].m_Char);
 1922|   437M|            if (current_char == '\t')
  ------------------
  |  Branch (1922:17): [True: 4.22M, False: 433M]
  ------------------
 1923|  4.22M|            {
 1924|  4.22M|                new_column += GetTabSizeAt(new_column);
 1925|  4.22M|            }
 1926|   433M|            else
 1927|   433M|            {
 1928|   433M|                ++new_column;
 1929|   433M|            }
 1930|       |
 1931|   437M|            char_index += UTF8CharLength(current_char);
 1932|   437M|        }
 1933|       |
 1934|   442k|        column = new_column;
 1935|       |
 1936|   442k|        PHI_ASSERT(line < m_Lines.size());
 1937|   442k|        PHI_ASSERT(column <= GetLineMaxColumn(line));
 1938|       |
 1939|   442k|        return {line, column};
 1940|   454k|    }
_ZNK6dlxemu10CodeEditor7AdvanceERNS0_11CoordinatesE:
 1943|  3.59k|    {
 1944|  3.59k|        if (coordinates.m_Line >= m_Lines.size())
  ------------------
  |  Branch (1944:13): [True: 0, False: 3.59k]
  ------------------
 1945|      0|        {
 1946|      0|            return;
 1947|      0|        }
 1948|       |
 1949|  3.59k|        const Line& line   = m_Lines[coordinates.m_Line.unsafe()];
 1950|  3.59k|        phi::u32    cindex = GetCharacterIndex(coordinates);
 1951|       |
 1952|  3.59k|        if (cindex + 1u < line.size())
  ------------------
  |  Branch (1952:13): [True: 0, False: 3.59k]
  ------------------
 1953|      0|        {
 1954|      0|            PHI_ASSERT(cindex < line.size());
 1955|      0|            phi::u8_fast delta = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1956|      0|            cindex = phi::min(cindex + delta, static_cast<phi::uint32_t>(line.size() - 1u));
 1957|      0|        }
 1958|  3.59k|        else
 1959|  3.59k|        {
 1960|  3.59k|            ++coordinates.m_Line;
 1961|  3.59k|            cindex = 0u;
 1962|  3.59k|        }
 1963|  3.59k|        coordinates.m_Column = GetCharacterColumn(coordinates.m_Line, cindex);
 1964|  3.59k|    }
_ZN6dlxemu10CodeEditor11DeleteRangeERKNS0_11CoordinatesES3_:
 1967|  60.9k|    {
 1968|  60.9k|        PHI_ASSERT(end > start);
 1969|  60.9k|        PHI_ASSERT(!m_ReadOnly);
 1970|  60.9k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1971|  60.9k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1972|       |
 1973|  60.9k|        const phi::u32 start_index = GetCharacterIndex(start);
 1974|  60.9k|        const phi::u32 end_index   = GetCharacterIndex(end);
 1975|       |
 1976|  60.9k|        if (start.m_Line == end.m_Line)
  ------------------
  |  Branch (1976:13): [True: 32.3k, False: 28.6k]
  ------------------
 1977|  32.3k|        {
 1978|  32.3k|            Line&          line       = m_Lines[start.m_Line.unsafe()];
 1979|  32.3k|            const phi::u32 max_column = GetLineMaxColumn(start.m_Line);
 1980|       |
 1981|  32.3k|            if (end.m_Column >= max_column)
  ------------------
  |  Branch (1981:17): [True: 24.3k, False: 7.97k]
  ------------------
 1982|  24.3k|            {
 1983|  24.3k|                line.erase(line.begin() + start_index.unsafe(), line.end());
 1984|       |
 1985|       |                // Fix selection
 1986|  24.3k|                if (m_State.m_SelectionStart.m_Column > start_index)
  ------------------
  |  Branch (1986:21): [True: 4.90k, False: 19.4k]
  ------------------
 1987|  4.90k|                {
 1988|  4.90k|                    m_State.m_SelectionStart.m_Column = start_index;
 1989|  4.90k|                }
 1990|  24.3k|                if (m_State.m_SelectionEnd.m_Column > start_index)
  ------------------
  |  Branch (1990:21): [True: 5.83k, False: 18.5k]
  ------------------
 1991|  5.83k|                {
 1992|  5.83k|                    m_State.m_SelectionEnd.m_Column = start_index;
 1993|  5.83k|                }
 1994|  24.3k|            }
 1995|  7.97k|            else
 1996|  7.97k|            {
 1997|  7.97k|                const phi::u32 start_column = GetCharacterColumn(start.m_Line, start_index);
 1998|  7.97k|                const phi::u32 end_column   = GetCharacterColumn(end.m_Line, end_index);
 1999|       |
 2000|  7.97k|                line.erase(line.begin() + start_index.unsafe(), line.begin() + end_index.unsafe());
 2001|       |
 2002|       |                // Fix selection
 2003|  7.97k|                if (m_State.m_SelectionStart.m_Column > start_column)
  ------------------
  |  Branch (2003:21): [True: 4.81k, False: 3.16k]
  ------------------
 2004|  4.81k|                {
 2005|  4.81k|                    if (m_State.m_SelectionStart.m_Column <= end_column)
  ------------------
  |  Branch (2005:25): [True: 4.37k, False: 440]
  ------------------
 2006|  4.37k|                    {
 2007|  4.37k|                        m_State.m_SelectionStart.m_Column = start_column;
 2008|  4.37k|                    }
 2009|    440|                    else
 2010|    440|                    {
 2011|    440|                        m_State.m_SelectionStart.m_Column -= (end_column - start_column);
 2012|    440|                    }
 2013|  4.81k|                }
 2014|  7.97k|                if (m_State.m_SelectionEnd.m_Column > start_column)
  ------------------
  |  Branch (2014:21): [True: 4.94k, False: 3.03k]
  ------------------
 2015|  4.94k|                {
 2016|  4.94k|                    if (m_State.m_SelectionEnd.m_Column <= end_column)
  ------------------
  |  Branch (2016:25): [True: 4.44k, False: 496]
  ------------------
 2017|  4.44k|                    {
 2018|  4.44k|                        m_State.m_SelectionEnd.m_Column = start_column;
 2019|  4.44k|                    }
 2020|    496|                    else
 2021|    496|                    {
 2022|    496|                        m_State.m_SelectionEnd.m_Column -= (end_column - start_column);
 2023|    496|                    }
 2024|  4.94k|                }
 2025|  7.97k|            }
 2026|  32.3k|        }
 2027|  28.6k|        else
 2028|  28.6k|        {
 2029|  28.6k|            Line& first_line = m_Lines[start.m_Line.unsafe()];
 2030|  28.6k|            Line& last_line  = m_Lines[end.m_Line.unsafe()];
 2031|       |
 2032|  28.6k|            first_line.erase(first_line.begin() + start_index.unsafe(), first_line.end());
 2033|  28.6k|            last_line.erase(last_line.begin(), last_line.begin() + end_index.unsafe());
 2034|       |
 2035|  28.6k|            if (start.m_Line < end.m_Line)
  ------------------
  |  Branch (2035:17): [True: 28.6k, False: 0]
  ------------------
 2036|  28.6k|            {
 2037|  28.6k|                first_line.insert(first_line.end(), last_line.begin(), last_line.end());
 2038|  28.6k|                RemoveLine(start.m_Line + 1u, end.m_Line + 1u);
 2039|  28.6k|            }
 2040|  28.6k|        }
 2041|       |
 2042|  60.9k|        m_TextChanged = true;
 2043|  60.9k|    }
_ZN6dlxemu10CodeEditor12InsertTextAtERNS0_11CoordinatesEPKc:
 2046|  70.7k|    {
 2047|  70.7k|        PHI_ASSERT(!m_ReadOnly);
 2048|  70.7k|        PHI_ASSERT(where.m_Line < m_Lines.size());
 2049|       |
 2050|  70.7k|        phi::u32 cindex      = GetCharacterIndex(where);
 2051|  70.7k|        phi::u32 total_lines = 0u;
 2052|  51.1M|        while (*value != '\0')
  ------------------
  |  Branch (2052:16): [True: 51.1M, False: 70.7k]
  ------------------
 2053|  51.1M|        {
 2054|  51.1M|            PHI_ASSERT(!m_Lines.empty());
 2055|       |
 2056|  51.1M|            if (*value == '\n')
  ------------------
  |  Branch (2056:17): [True: 288k, False: 50.8M]
  ------------------
 2057|   288k|            {
 2058|   288k|                if (cindex < m_Lines[where.m_Line.unsafe()].size())
  ------------------
  |  Branch (2058:21): [True: 28.4k, False: 260k]
  ------------------
 2059|  28.4k|                {
 2060|  28.4k|                    Line& new_line = InsertLine(where.m_Line + 1u);
 2061|  28.4k|                    Line& line     = m_Lines[where.m_Line.unsafe()];
 2062|  28.4k|                    new_line.insert(new_line.begin(), line.begin() + cindex.unsafe(), line.end());
 2063|  28.4k|                    line.erase(line.begin() + cindex.unsafe(), line.end());
 2064|  28.4k|                }
 2065|   260k|                else
 2066|   260k|                {
 2067|   260k|                    InsertLine(where.m_Line + 1u);
 2068|   260k|                }
 2069|       |
 2070|   288k|                ++where.m_Line;
 2071|   288k|                where.m_Column = 0u;
 2072|   288k|                cindex         = 0u;
 2073|   288k|                ++total_lines;
 2074|   288k|                ++value;
 2075|   288k|            }
 2076|  50.8M|            else if (*value == '\t')
  ------------------
  |  Branch (2076:22): [True: 897k, False: 49.9M]
  ------------------
 2077|   897k|            {
 2078|   897k|                Line& line = m_Lines[where.m_Line.unsafe()];
 2079|       |
 2080|   897k|                line.insert(line.begin() + cindex.unsafe(),
 2081|   897k|                            Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2082|   897k|                cindex += 1u;
 2083|       |
 2084|   897k|                where.m_Column += GetTabSizeAt(where.m_Column);
 2085|   897k|            }
 2086|  49.9M|            else
 2087|  49.9M|            {
 2088|  49.9M|                Line& line = m_Lines[where.m_Line.unsafe()];
 2089|       |
 2090|   137M|                for (phi::u8_fast length = UTF8CharLength(*value); length > 0u && *value != '\0';
  ------------------
  |  Branch (2090:68): [True: 87.5M, False: 49.9M]
  |  Branch (2090:68): [True: 87.5M, False: 49.9M]
  |  Branch (2090:83): [True: 87.5M, False: 0]
  ------------------
 2091|  87.5M|                     ++cindex, --length)
 2092|  87.5M|                {
 2093|  87.5M|                    line.insert(line.begin() + cindex.unsafe(),
 2094|  87.5M|                                Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2095|  87.5M|                }
 2096|       |
 2097|  49.9M|                ++where.m_Column;
 2098|  49.9M|            }
 2099|       |
 2100|  51.1M|            m_TextChanged = true;
 2101|  51.1M|        }
 2102|       |
 2103|  70.7k|        return total_lines;
 2104|  70.7k|    }
_ZN6dlxemu10CodeEditor7AddUndoERNS0_10UndoRecordE:
 2107|  52.7k|    {
 2108|  52.7k|        PHI_ASSERT(!m_ReadOnly);
 2109|       |
 2110|  52.7k|#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2111|  52.7k|        VerifyInternalState();
 2112|       |        // Reject empty undos
 2113|  52.7k|        PHI_ASSERT(!(value.m_Added.empty() && value.m_Removed.empty()));
 2114|       |        // Start and end are valid
 2115|  52.7k|        PHI_ASSERT(value.m_AddedStart <= value.m_AddedEnd);
 2116|  52.7k|        PHI_ASSERT(value.m_RemovedStart <= value.m_RemovedEnd);
 2117|  52.7k|#endif
 2118|       |
 2119|  52.7k|        m_UndoBuffer.resize((m_UndoIndex + 1u).unsafe());
 2120|  52.7k|        m_UndoBuffer.back() = value;
 2121|  52.7k|        ++m_UndoIndex;
 2122|       |
 2123|  52.7k|#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2124|  52.7k|        VerifyInternalState();
 2125|       |
 2126|  52.7k|        PHI_ASSERT(CanUndo());
 2127|       |
 2128|  52.7k|        const std::string text_before          = GetText();
 2129|  52.7k|        EditorState       state_before         = m_State;
 2130|  52.7k|        state_before.m_CursorPosition.m_Column = GetCharacterIndex(state_before.m_CursorPosition);
 2131|  52.7k|        state_before.m_SelectionStart.m_Column = GetCharacterIndex(state_before.m_SelectionStart);
 2132|  52.7k|        state_before.m_SelectionEnd.m_Column   = GetCharacterIndex(state_before.m_SelectionEnd);
 2133|       |
 2134|       |        // Test the undo
 2135|  52.7k|        Undo();
 2136|  52.7k|        VerifyInternalState();
 2137|       |
 2138|  52.7k|        const std::string text_after_undo  = GetText();
 2139|  52.7k|        EditorState       state_after_undo = m_State;
 2140|  52.7k|        state_after_undo.m_CursorPosition.m_Column =
 2141|  52.7k|                GetCharacterIndex(state_after_undo.m_CursorPosition);
 2142|  52.7k|        state_after_undo.m_SelectionStart.m_Column =
 2143|  52.7k|                GetCharacterIndex(state_after_undo.m_SelectionStart);
 2144|  52.7k|        state_after_undo.m_SelectionEnd.m_Column =
 2145|  52.7k|                GetCharacterIndex(state_after_undo.m_SelectionEnd);
 2146|       |
 2147|  52.7k|        PHI_ASSERT(CanRedo());
 2148|       |
 2149|       |        // Test the redo
 2150|  52.7k|        Redo();
 2151|  52.7k|        VerifyInternalState();
 2152|       |
 2153|  52.7k|        const std::string text_after          = GetText();
 2154|  52.7k|        EditorState       state_after         = m_State;
 2155|  52.7k|        state_after.m_CursorPosition.m_Column = GetCharacterIndex(state_after.m_CursorPosition);
 2156|  52.7k|        state_after.m_SelectionStart.m_Column = GetCharacterIndex(state_after.m_SelectionStart);
 2157|  52.7k|        state_after.m_SelectionEnd.m_Column   = GetCharacterIndex(state_after.m_SelectionEnd);
 2158|       |
 2159|  52.7k|        PHI_ASSERT(text_before == text_after);
 2160|  52.7k|        PHI_ASSERT(state_before == state_after);
 2161|  52.7k|#endif
 2162|  52.7k|    }
_ZNK6dlxemu10CodeEditor22ScreenPosToCoordinatesERK6ImVec2:
 2166|     87|    {
 2167|     87|        const ImVec2 origin = ImGui::GetCursorScreenPos();
 2168|     87|        const ImVec2 local(position.x - origin.x, position.y - origin.y);
 2169|       |
 2170|     87|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 2171|     87|        const phi::u32 line_no =
 2172|     87|                phi::max(0u, static_cast<phi::int32_t>(std::floor(local.y / m_CharAdvance.y)));
 2173|       |
 2174|     87|        phi::u32 column_coord = 0u;
 2175|       |
 2176|     87|        if (line_no >= 0u && line_no < m_Lines.size())
  ------------------
  |  Branch (2176:13): [True: 87, False: 0]
  |  Branch (2176:13): [True: 0, False: 87]
  |  Branch (2176:30): [True: 0, False: 87]
  ------------------
 2177|      0|        {
 2178|      0|            const Line& line = m_Lines[line_no.unsafe()];
 2179|       |
 2180|      0|            phi::u32 column_index = 0u;
 2181|      0|            float    column_x     = 0.0f;
 2182|       |
 2183|      0|            while (column_index < line.size())
  ------------------
  |  Branch (2183:20): [True: 0, False: 0]
  ------------------
 2184|      0|            {
 2185|      0|                float column_width = 0.0f;
 2186|       |
 2187|      0|                if (line[column_index.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2187:21): [True: 0, False: 0]
  ------------------
 2188|      0|                {
 2189|      0|                    float space_size =
 2190|      0|                            ImGui::GetFont()
 2191|      0|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ")
 2192|      0|                                    .x;
 2193|      0|                    float old_x = column_x;
 2194|      0|                    float new_column_x =
 2195|      0|                            (1.0f + std::floor((1.0f + column_x) /
 2196|      0|                                               (float(m_TabSize.unsafe()) * space_size))) *
 2197|      0|                            (float(m_TabSize.unsafe()) * space_size);
 2198|      0|                    column_width = new_column_x - old_x;
 2199|       |
 2200|      0|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2200:25): [True: 0, False: 0]
  ------------------
 2201|      0|                    {
 2202|      0|                        break;
 2203|      0|                    }
 2204|       |
 2205|      0|                    column_x = new_column_x;
 2206|      0|                    column_coord =
 2207|      0|                            (column_coord.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2208|      0|                            m_TabSize.unsafe();
 2209|      0|                    column_index += 1u;
 2210|      0|                }
 2211|      0|                else
 2212|      0|                {
 2213|      0|                    phi::array<char, 7u> buffer;
 2214|      0|                    phi::usize           index = 0u;
 2215|       |
 2216|      0|                    for (phi::u8_fast length = UTF8CharLength(line[column_index.unsafe()].m_Char);
 2217|      0|                         index < 6u && length > 0u; ++index, ++column_index, --length)
  ------------------
  |  Branch (2217:26): [True: 0, False: 0]
  |  Branch (2217:26): [True: 0, False: 0]
  |  Branch (2217:40): [True: 0, False: 0]
  ------------------
 2218|      0|                    {
 2219|      0|                        buffer[index] = static_cast<char>(line[column_index.unsafe()].m_Char);
 2220|      0|                    }
 2221|       |
 2222|      0|                    buffer[index] = '\0';
 2223|      0|                    column_width  = ImGui::GetFont()
 2224|      0|                                           ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 2225|      0|                                                           buffer.data())
 2226|      0|                                           .x;
 2227|      0|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2227:25): [True: 0, False: 0]
  ------------------
 2228|      0|                    {
 2229|      0|                        break;
 2230|      0|                    }
 2231|      0|                    column_x += column_width;
 2232|      0|                    column_coord++;
 2233|      0|                }
 2234|      0|            }
 2235|      0|        }
 2236|       |
 2237|     87|        return SanitizeCoordinates(Coordinates(line_no, column_coord));
 2238|     87|    }
_ZNK6dlxemu10CodeEditor13FindWordStartERKNS0_11CoordinatesE:
 2242|  85.9k|    {
 2243|  85.9k|        if (from.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2243:13): [True: 0, False: 85.9k]
  ------------------
 2244|      0|        {
 2245|      0|            return from;
 2246|      0|        }
 2247|       |
 2248|  85.9k|        const Line& line   = m_Lines[from.m_Line.unsafe()];
 2249|  85.9k|        phi::u32    cindex = GetCharacterIndex(from);
 2250|       |
 2251|  85.9k|        if (cindex >= line.size())
  ------------------
  |  Branch (2251:13): [True: 53.1k, False: 32.7k]
  ------------------
 2252|  53.1k|        {
 2253|  53.1k|            return from;
 2254|  53.1k|        }
 2255|       |
 2256|  52.8k|        while (cindex > 0u && phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2256:16): [True: 31.3k, False: 21.5k]
  |  Branch (2256:16): [True: 20.1k, False: 32.7k]
  |  Branch (2256:31): [True: 20.1k, False: 11.2k]
  ------------------
 2257|  20.1k|        {
 2258|  20.1k|            --cindex;
 2259|  20.1k|        }
 2260|       |
 2261|  32.7k|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2262|   170k|        while (cindex > 0u)
  ------------------
  |  Branch (2262:16): [True: 142k, False: 28.3k]
  ------------------
 2263|   142k|        {
 2264|   142k|            Glyph glyph = line[cindex.unsafe()];
 2265|   142k|            if (!IsUTFSequence(glyph.m_Char))
  ------------------
  |  Branch (2265:17): [True: 57.8k, False: 84.3k]
  ------------------
 2266|  57.8k|            {
 2267|  57.8k|                if (glyph.m_Char <= 32 && phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2267:21): [True: 18.1k, False: 39.6k]
  |  Branch (2267:21): [True: 4.45k, False: 53.4k]
  |  Branch (2267:43): [True: 4.45k, False: 13.7k]
  ------------------
 2268|  4.45k|                {
 2269|  4.45k|                    cindex += 1u;
 2270|  4.45k|                    break;
 2271|  4.45k|                }
 2272|       |
 2273|  53.4k|                if (cstart != line[phi::size_t(cindex.unsafe() - 1u)].m_ColorIndex)
  ------------------
  |  Branch (2273:21): [True: 2, False: 53.4k]
  ------------------
 2274|      2|                {
 2275|      2|                    break;
 2276|      2|                }
 2277|  53.4k|            }
 2278|       |
 2279|   137k|            cindex -= 1u;
 2280|   137k|        }
 2281|       |
 2282|  32.7k|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2283|  85.9k|    }
_ZNK6dlxemu10CodeEditor11FindWordEndERKNS0_11CoordinatesE:
 2287|    914|    {
 2288|    914|        Coordinates at = from;
 2289|    914|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2289:13): [True: 0, False: 914]
  ------------------
 2290|      0|        {
 2291|      0|            return at;
 2292|      0|        }
 2293|       |
 2294|    914|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2295|    914|        phi::u32    cindex = GetCharacterIndex(at);
 2296|       |
 2297|    914|        if (cindex >= line.size())
  ------------------
  |  Branch (2297:13): [True: 524, False: 390]
  ------------------
 2298|    524|        {
 2299|    524|            return at;
 2300|    524|        }
 2301|       |
 2302|    390|        const phi::boolean prevspace =
 2303|    390|                phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char));
 2304|    390|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2305|  1.50k|        while (cindex < line.size())
  ------------------
  |  Branch (2305:16): [True: 1.41k, False: 89]
  ------------------
 2306|  1.41k|        {
 2307|  1.41k|            const Glyph glyph = line[cindex.unsafe()];
 2308|       |
 2309|  1.41k|            if (cstart != line[cindex.unsafe()].m_ColorIndex)
  ------------------
  |  Branch (2309:17): [True: 0, False: 1.41k]
  ------------------
 2310|      0|            {
 2311|      0|                break;
 2312|      0|            }
 2313|       |
 2314|  1.41k|            if (prevspace != phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2314:17): [True: 301, False: 1.11k]
  ------------------
 2315|    301|            {
 2316|    301|                if (phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2316:21): [True: 267, False: 34]
  ------------------
 2317|    267|                {
 2318|    616|                    while (cindex < line.size() &&
  ------------------
  |  Branch (2318:28): [True: 431, False: 185]
  |  Branch (2318:28): [True: 349, False: 267]
  ------------------
 2319|    616|                           phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2319:28): [True: 349, False: 82]
  ------------------
 2320|    349|                    {
 2321|    349|                        cindex += 1u;
 2322|    349|                    }
 2323|    267|                }
 2324|    301|                break;
 2325|    301|            }
 2326|       |
 2327|  1.11k|            cindex += UTF8CharLength(glyph.m_Char);
 2328|  1.11k|        }
 2329|       |
 2330|    390|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2331|    914|    }
_ZNK6dlxemu10CodeEditor12FindNextWordERKNS0_11CoordinatesE:
 2335|  1.62k|    {
 2336|  1.62k|        Coordinates at = from;
 2337|  1.62k|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2337:13): [True: 0, False: 1.62k]
  ------------------
 2338|      0|        {
 2339|      0|            return at;
 2340|      0|        }
 2341|       |
 2342|       |        // skip to the next non-word character
 2343|  1.62k|        phi::u32     cindex  = GetCharacterIndex(from);
 2344|  1.62k|        phi::boolean is_word = false;
 2345|  1.62k|        phi::boolean skip    = false;
 2346|  1.62k|        if (cindex < m_Lines[at.m_Line.unsafe()].size())
  ------------------
  |  Branch (2346:13): [True: 1.60k, False: 21]
  ------------------
 2347|  1.60k|        {
 2348|  1.60k|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2349|  1.60k|            is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2350|  1.60k|            skip    = is_word;
 2351|  1.60k|        }
 2352|       |
 2353|  1.18M|        while (!is_word || skip)
  ------------------
  |  Branch (2353:16): [True: 1.18M, False: 4]
  |  Branch (2353:16): [True: 1.18M, False: 0]
  |  Branch (2353:28): [True: 4, False: 0]
  ------------------
 2354|  1.18M|        {
 2355|  1.18M|            if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2355:17): [True: 1.62k, False: 1.18M]
  ------------------
 2356|  1.62k|            {
 2357|  1.62k|                const phi::u32 line_number = GetMaxLineNumber();
 2358|       |
 2359|  1.62k|                return {line_number, GetLineMaxColumn(line_number)};
 2360|  1.62k|            }
 2361|       |
 2362|  1.18M|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2363|  1.18M|            if (cindex < line.size())
  ------------------
  |  Branch (2363:17): [True: 1.18M, False: 1.79k]
  ------------------
 2364|  1.18M|            {
 2365|  1.18M|                is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2366|       |
 2367|  1.18M|                if (is_word && !skip)
  ------------------
  |  Branch (2367:21): [True: 2, False: 1.18M]
  |  Branch (2367:21): [True: 0, False: 1.18M]
  |  Branch (2367:32): [True: 0, False: 2]
  ------------------
 2368|      0|                {
 2369|      0|                    return {at.m_Line, GetCharacterColumn(at.m_Line, cindex)};
 2370|      0|                }
 2371|       |
 2372|  1.18M|                if (!is_word)
  ------------------
  |  Branch (2372:21): [True: 1.18M, False: 2]
  ------------------
 2373|  1.18M|                {
 2374|  1.18M|                    skip = false;
 2375|  1.18M|                }
 2376|       |
 2377|  1.18M|                cindex++;
 2378|  1.18M|            }
 2379|  1.79k|            else
 2380|  1.79k|            {
 2381|  1.79k|                cindex = 0u;
 2382|  1.79k|                at.m_Line += 1u;
 2383|  1.79k|                skip    = false;
 2384|  1.79k|                is_word = false;
 2385|  1.79k|            }
 2386|  1.18M|        }
 2387|       |
 2388|      0|        return at;
 2389|  1.62k|    }
_ZNK6dlxemu10CodeEditor9GetWordAtERKNS0_11CoordinatesE:
 2398|     87|    {
 2399|     87|        PHI_ASSERT(coords.m_Line < m_Lines.size());
 2400|       |
 2401|     87|        Coordinates start = FindWordStart(coords);
 2402|     87|        Coordinates end   = FindWordEnd(coords);
 2403|       |
 2404|     87|        phi::u32 istart = GetCharacterIndex(start);
 2405|     87|        phi::u32 iend   = GetCharacterIndex(end);
 2406|       |
 2407|     87|        std::string result;
 2408|       |
 2409|     87|        for (phi::u32 iterator = istart; iterator < iend; ++iterator)
  ------------------
  |  Branch (2409:42): [True: 0, False: 87]
  ------------------
 2410|      0|        {
 2411|      0|            const Line& line = m_Lines[coords.m_Line.unsafe()];
 2412|       |
 2413|      0|            PHI_ASSERT(iterator < line.size());
 2414|      0|            result.push_back(static_cast<char>(line[iterator.unsafe()].m_Char));
 2415|      0|        }
 2416|       |
 2417|     87|        return result;
 2418|     87|    }
_ZNK6dlxemu10CodeEditor17GetCharacterIndexERKNS0_11CoordinatesE:
 2422|  1.54M|    {
 2423|  1.54M|        PHI_ASSERT(coordinates.m_Line < m_Lines.size());
 2424|       |
 2425|  1.54M|        const Line& line  = m_Lines[coordinates.m_Line.unsafe()];
 2426|  1.54M|        phi::u32    index = 0u;
 2427|  1.11G|        for (phi::u32 column{0u}; index < line.size() && column < coordinates.m_Column;)
  ------------------
  |  Branch (2427:35): [True: 1.11G, False: 1.02M]
  |  Branch (2427:35): [True: 1.10G, False: 1.54M]
  |  Branch (2427:58): [True: 1.10G, False: 517k]
  ------------------
 2428|  1.10G|        {
 2429|  1.10G|            PHI_ASSERT(index < line.size());
 2430|  1.10G|            const Char character = line[index.unsafe()].m_Char;
 2431|       |
 2432|  1.10G|            if (character == '\t')
  ------------------
  |  Branch (2432:17): [True: 11.2M, False: 1.09G]
  ------------------
 2433|  11.2M|            {
 2434|  11.2M|                column = (column / m_TabSize) * m_TabSize + m_TabSize;
 2435|  11.2M|            }
 2436|  1.09G|            else
 2437|  1.09G|            {
 2438|  1.09G|                ++column;
 2439|  1.09G|            }
 2440|       |
 2441|  1.10G|            index += UTF8CharLength(character);
 2442|  1.10G|        }
 2443|       |
 2444|  1.54M|        return index;
 2445|  1.54M|    }
_ZNK6dlxemu10CodeEditor18GetCharacterColumnEN3phi7integerIjEES3_:
 2449|   546k|    {
 2450|   546k|        PHI_ASSERT(line_number < m_Lines.size());
 2451|       |
 2452|   546k|        const Line& line   = m_Lines[line_number.unsafe()];
 2453|   546k|        phi::u32    column = 0u;
 2454|   546k|        phi::u32    i      = 0u;
 2455|       |
 2456|   371M|        while (i < index && i < line.size())
  ------------------
  |  Branch (2456:16): [True: 371M, False: 546k]
  |  Branch (2456:16): [True: 371M, False: 546k]
  |  Branch (2456:29): [True: 371M, False: 0]
  ------------------
 2457|   371M|        {
 2458|   371M|            char character = static_cast<char>(line[static_cast<phi::size_t>(i.unsafe())].m_Char);
 2459|   371M|            i += UTF8CharLength(character);
 2460|   371M|            if (character == '\t')
  ------------------
  |  Branch (2460:17): [True: 2.78M, False: 368M]
  ------------------
 2461|  2.78M|            {
 2462|  2.78M|                column = (column.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2463|  2.78M|                         m_TabSize.unsafe();
 2464|  2.78M|            }
 2465|   368M|            else
 2466|   368M|            {
 2467|   368M|                column++;
 2468|   368M|            }
 2469|   371M|        }
 2470|       |
 2471|   546k|        return column;
 2472|   546k|    }
_ZNK6dlxemu10CodeEditor16GetLineMaxColumnEN3phi7integerIjEE:
 2494|   676k|    {
 2495|   676k|        if (line_number >= m_Lines.size())
  ------------------
  |  Branch (2495:13): [True: 0, False: 676k]
  ------------------
 2496|      0|        {
 2497|      0|            return 0u;
 2498|      0|        }
 2499|       |
 2500|   676k|        const Line& line = m_Lines[line_number.unsafe()];
 2501|   676k|        phi::u32    col  = 0u;
 2502|       |
 2503|   691M|        for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (2503:32): [True: 690M, False: 676k]
  ------------------
 2504|   690M|        {
 2505|   690M|            char character = static_cast<char>(line[i.unsafe()].m_Char);
 2506|   690M|            if (character == '\t')
  ------------------
  |  Branch (2506:17): [True: 10.2M, False: 680M]
  ------------------
 2507|  10.2M|            {
 2508|  10.2M|                col = (col / m_TabSize) * m_TabSize + m_TabSize;
 2509|  10.2M|            }
 2510|   680M|            else
 2511|   680M|            {
 2512|   680M|                col++;
 2513|   680M|            }
 2514|       |
 2515|   690M|            i += UTF8CharLength(character);
 2516|   690M|        }
 2517|       |
 2518|   676k|        return col;
 2519|   676k|    }
_ZNK6dlxemu10CodeEditor16GetMaxLineNumberEv:
 2522|   186k|    {
 2523|   186k|        PHI_ASSERT(!m_Lines.empty());
 2524|       |
 2525|   186k|        return static_cast<phi::uint32_t>(m_Lines.size() - 1u);
 2526|   186k|    }
_ZNK6dlxemu10CodeEditor16IsOnWordBoundaryERKNS0_11CoordinatesE:
 2530|    269|    {
 2531|    269|        if (at.m_Line >= m_Lines.size() || at.m_Column == 0u)
  ------------------
  |  Branch (2531:13): [True: 0, False: 269]
  |  Branch (2531:13): [True: 205, False: 64]
  |  Branch (2531:44): [True: 205, False: 64]
  ------------------
 2532|    205|        {
 2533|    205|            return true;
 2534|    205|        }
 2535|       |
 2536|     64|        PHI_ASSERT(at.m_Line < m_Lines.size());
 2537|     64|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2538|     64|        phi::u32    cindex = GetCharacterIndex(at);
 2539|     64|        if (cindex >= line.size())
  ------------------
  |  Branch (2539:13): [True: 64, False: 0]
  ------------------
 2540|     64|        {
 2541|     64|            return true;
 2542|     64|        }
 2543|       |
 2544|      0|        if (m_ColorizerEnabled)
  ------------------
  |  Branch (2544:13): [True: 0, False: 0]
  ------------------
 2545|      0|        {
 2546|      0|            return line[cindex.unsafe()].m_ColorIndex != line[cindex.unsafe() - 1u].m_ColorIndex;
 2547|      0|        }
 2548|       |
 2549|      0|        PHI_ASSERT(cindex < line.size());
 2550|      0|        return phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)) !=
 2551|      0|               phi::is_space(static_cast<char>(line[(cindex - 1u).unsafe()].m_Char));
 2552|      0|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEES3_:
 2555|  28.6k|    {
 2556|  28.6k|        PHI_ASSERT(!m_ReadOnly);
 2557|  28.6k|        PHI_ASSERT(end >= start);
 2558|  28.6k|        PHI_ASSERT(m_Lines.size() > (end - start));
 2559|       |
 2560|       |        // Remove error markers
 2561|  28.6k|        ErrorMarkers etmp;
 2562|  28.6k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2562:33): [True: 9.69k, False: 28.6k]
  ------------------
 2563|  9.69k|        {
 2564|  9.69k|            if (marker.first >= start && marker.first <= end)
  ------------------
  |  Branch (2564:17): [True: 5.83k, False: 3.86k]
  |  Branch (2564:17): [True: 742, False: 8.95k]
  |  Branch (2564:42): [True: 742, False: 5.09k]
  ------------------
 2565|    742|            {
 2566|    742|                continue;
 2567|    742|            }
 2568|       |
 2569|  8.95k|            ErrorMarkers::value_type error_marker(
 2570|  8.95k|                    marker.first >= start ? phi::max(marker.first - (end - start + 1u), 1u) :
  ------------------
  |  Branch (2570:21): [True: 5.09k, False: 3.86k]
  ------------------
 2571|  8.95k|                                            marker.first,
 2572|  8.95k|                    marker.second);
 2573|       |
 2574|  8.95k|            etmp.insert(error_marker);
 2575|  8.95k|        }
 2576|  28.6k|        m_ErrorMarkers = phi::move(etmp);
 2577|       |
 2578|       |        // Remove breakpoints
 2579|  28.6k|        Breakpoints btmp;
 2580|  28.6k|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2580:37): [True: 14.5k, False: 28.6k]
  ------------------
 2581|  14.5k|        {
 2582|  14.5k|            if (line_number >= start && line_number <= end)
  ------------------
  |  Branch (2582:17): [True: 835, False: 13.7k]
  |  Branch (2582:17): [True: 205, False: 14.3k]
  |  Branch (2582:41): [True: 205, False: 630]
  ------------------
 2583|    205|            {
 2584|    205|                continue;
 2585|    205|            }
 2586|  14.3k|            btmp.insert(line_number >= start ?
  ------------------
  |  Branch (2586:25): [True: 630, False: 13.7k]
  ------------------
 2587|    630|                                phi::max(line_number - (end - start + 1u).unsafe(), 1u) :
 2588|  14.3k|                                line_number);
 2589|  14.3k|        }
 2590|  28.6k|        m_Breakpoints = phi::move(btmp);
 2591|       |
 2592|  28.6k|        m_Lines.erase(m_Lines.begin() + start.unsafe(), m_Lines.begin() + end.unsafe());
 2593|  28.6k|        PHI_ASSERT(!m_Lines.empty());
 2594|       |
 2595|       |        // Fix selection state
 2596|  28.6k|        if (m_State.m_SelectionStart.m_Line >= start)
  ------------------
  |  Branch (2596:13): [True: 7.31k, False: 21.3k]
  ------------------
 2597|  7.31k|        {
 2598|  7.31k|            if (m_State.m_SelectionStart.m_Line < end - start)
  ------------------
  |  Branch (2598:17): [True: 1, False: 7.31k]
  ------------------
 2599|      1|            {
 2600|      1|                m_State.m_SelectionStart.m_Line = 0u;
 2601|      1|            }
 2602|  7.31k|            else
 2603|  7.31k|            {
 2604|  7.31k|                m_State.m_SelectionStart.m_Line -= end - start;
 2605|  7.31k|            }
 2606|  7.31k|        }
 2607|  28.6k|        if (m_State.m_SelectionEnd.m_Line >= start)
  ------------------
  |  Branch (2607:13): [True: 12.4k, False: 16.2k]
  ------------------
 2608|  12.4k|        {
 2609|  12.4k|            if (m_State.m_SelectionEnd.m_Line < end - start)
  ------------------
  |  Branch (2609:17): [True: 0, False: 12.4k]
  ------------------
 2610|      0|            {
 2611|      0|                m_State.m_SelectionEnd.m_Line = 0u;
 2612|      0|            }
 2613|  12.4k|            else
 2614|  12.4k|            {
 2615|  12.4k|                m_State.m_SelectionEnd.m_Line -= end - start;
 2616|  12.4k|            }
 2617|  12.4k|        }
 2618|  28.6k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (2618:13): [True: 100, False: 28.5k]
  ------------------
 2619|    100|        {
 2620|    100|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 2621|    100|        }
 2622|       |
 2623|  28.6k|        m_TextChanged = true;
 2624|  28.6k|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEE:
 2627|  3.59k|    {
 2628|  3.59k|        PHI_ASSERT(!m_ReadOnly);
 2629|  3.59k|        PHI_ASSERT(m_Lines.size() > 1u);
 2630|       |
 2631|       |        // Clear error markers on that line
 2632|  3.59k|        ErrorMarkers etmp;
 2633|  3.59k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2633:33): [True: 3.81k, False: 3.59k]
  ------------------
 2634|  3.81k|        {
 2635|  3.81k|            ErrorMarkers::value_type error_marker(
 2636|  3.81k|                    marker.first > index ? phi::max(marker.first - 1u, 1u) : marker.first,
  ------------------
  |  Branch (2636:21): [True: 1.37k, False: 2.43k]
  ------------------
 2637|  3.81k|                    marker.second);
 2638|  3.81k|            if ((error_marker.first - 1u) == index)
  ------------------
  |  Branch (2638:17): [True: 65, False: 3.74k]
  ------------------
 2639|     65|            {
 2640|     65|                continue;
 2641|     65|            }
 2642|  3.74k|            etmp.insert(error_marker);
 2643|  3.74k|        }
 2644|  3.59k|        m_ErrorMarkers = phi::move(etmp);
 2645|       |
 2646|       |        // Remove breakpoints on that line
 2647|  3.59k|        Breakpoints btmp;
 2648|  3.59k|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2648:37): [True: 3.14k, False: 3.59k]
  ------------------
 2649|  3.14k|        {
 2650|  3.14k|            if (line_number == index)
  ------------------
  |  Branch (2650:17): [True: 111, False: 3.03k]
  ------------------
 2651|    111|            {
 2652|    111|                continue;
 2653|    111|            }
 2654|       |
 2655|  3.03k|            btmp.insert(line_number >= index ? phi::max(line_number - 1u, 1u) : line_number);
  ------------------
  |  Branch (2655:25): [True: 126, False: 2.90k]
  ------------------
 2656|  3.03k|        }
 2657|  3.59k|        m_Breakpoints = phi::move(btmp);
 2658|       |
 2659|       |        // Fix selection
 2660|  3.59k|        if (m_State.m_SelectionStart.m_Line >= index)
  ------------------
  |  Branch (2660:13): [True: 2.61k, False: 976]
  ------------------
 2661|  2.61k|        {
 2662|  2.61k|            m_State.m_SelectionStart.m_Line--;
 2663|  2.61k|        }
 2664|  3.59k|        if (m_State.m_SelectionEnd.m_Line >= index)
  ------------------
  |  Branch (2664:13): [True: 2.61k, False: 976]
  ------------------
 2665|  2.61k|        {
 2666|  2.61k|            m_State.m_SelectionEnd.m_Line--;
 2667|  2.61k|        }
 2668|       |
 2669|  3.59k|        m_Lines.erase(m_Lines.begin() + index.unsafe());
 2670|  3.59k|        PHI_ASSERT(!m_Lines.empty());
 2671|       |
 2672|  3.59k|        m_TextChanged = true;
 2673|  3.59k|    }
_ZN6dlxemu10CodeEditor10InsertLineEN3phi7integerIjEE:
 2676|   303k|    {
 2677|   303k|        PHI_ASSERT(!m_ReadOnly);
 2678|       |
 2679|   303k|        Line& result = *m_Lines.insert(m_Lines.begin() + index.unsafe(), Line());
 2680|       |
 2681|   303k|        ErrorMarkers etmp;
 2682|   303k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2682:33): [True: 84.2k, False: 303k]
  ------------------
 2683|  84.2k|        {
 2684|  84.2k|            etmp.insert(ErrorMarkers::value_type(
 2685|  84.2k|                    marker.first >= index ? marker.first + 1u : marker.first, marker.second));
  ------------------
  |  Branch (2685:21): [True: 32.8k, False: 51.4k]
  ------------------
 2686|  84.2k|        }
 2687|   303k|        m_ErrorMarkers = phi::move(etmp);
 2688|       |
 2689|   303k|        Breakpoints btmp;
 2690|   303k|        for (const phi::u32 line_number : m_Breakpoints)
  ------------------
  |  Branch (2690:41): [True: 32.4k, False: 303k]
  ------------------
 2691|  32.4k|        {
 2692|  32.4k|            btmp.insert(line_number >= index ? line_number.unsafe() + 1u : line_number.unsafe());
  ------------------
  |  Branch (2692:25): [True: 7.50k, False: 24.9k]
  ------------------
 2693|  32.4k|        }
 2694|   303k|        m_Breakpoints = phi::move(btmp);
 2695|       |
 2696|   303k|        return result;
 2697|   303k|    }
_ZN6dlxemu10CodeEditor18EnterCharacterImplEtN3phi7booleanE:
 2700|  30.9k|    {
 2701|  30.9k|        PHI_ASSERT(!m_ReadOnly);
 2702|  30.9k|        PHI_ASSERT(IsValidUTF8Sequence(character));
 2703|  30.9k|        PHI_ASSERT(character != '\0');
 2704|       |
 2705|  30.9k|        UndoRecord undo;
 2706|  30.9k|        undo.StoreBeforeState(this);
 2707|       |
 2708|  30.9k|        phi::boolean removed_selection{false};
 2709|       |
 2710|  30.9k|        if (HasSelection())
  ------------------
  |  Branch (2710:13): [True: 1.45k, False: 29.4k]
  ------------------
 2711|  1.45k|        {
 2712|       |            // Do indenting
 2713|  1.45k|            if (character == '\t' &&
  ------------------
  |  Branch (2713:17): [True: 453, False: 1.00k]
  |  Branch (2713:17): [True: 445, False: 1.01k]
  ------------------
 2714|  1.45k|                (m_State.m_SelectionStart.m_Column == 0u ||
  ------------------
  |  Branch (2714:18): [True: 419, False: 34]
  ------------------
 2715|    453|                 m_State.m_SelectionStart.m_Line != m_State.m_SelectionEnd.m_Line))
  ------------------
  |  Branch (2715:18): [True: 26, False: 8]
  ------------------
 2716|    445|            {
 2717|    445|                Coordinates       start        = m_State.m_SelectionStart;
 2718|    445|                Coordinates       end          = m_State.m_SelectionEnd;
 2719|    445|                const Coordinates original_end = end;
 2720|       |
 2721|    445|                PHI_ASSERT(start < end);
 2722|    445|                start.m_Column = 0u;
 2723|       |                //          end.mColumn = end.mLine < mLines.size() ? mLines[end.mLine].size() : 0;
 2724|    445|                if (end.m_Column == 0u && end.m_Line > 0u)
  ------------------
  |  Branch (2724:21): [True: 21, False: 424]
  |  Branch (2724:21): [True: 21, False: 424]
  |  Branch (2724:43): [True: 21, False: 0]
  ------------------
 2725|     21|                {
 2726|     21|                    --end.m_Line;
 2727|     21|                }
 2728|    445|                if (end.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2728:21): [True: 0, False: 445]
  ------------------
 2729|      0|                {
 2730|      0|                    PHI_ASSERT(!m_Lines.empty());
 2731|      0|                    end.m_Line = GetMaxLineNumber();
 2732|      0|                }
 2733|    445|                end.m_Column = GetLineMaxColumn(end.m_Line);
 2734|       |
 2735|       |                //if (end.mColumn >= GetLineMaxColumn(end.mLine))
 2736|       |                //  end.mColumn = GetLineMaxColumn(end.mLine) - 1;
 2737|       |
 2738|    445|                undo.m_RemovedStart = start;
 2739|    445|                undo.m_RemovedEnd   = end;
 2740|    445|                undo.m_Removed      = GetText(start, end);
 2741|       |
 2742|    445|                phi::boolean modified = false;
 2743|       |
 2744|  12.6k|                for (phi::u32 line_index = start.m_Line; line_index <= end.m_Line; ++line_index)
  ------------------
  |  Branch (2744:58): [True: 12.1k, False: 445]
  ------------------
 2745|  12.1k|                {
 2746|  12.1k|                    PHI_ASSERT(line_index < m_Lines.size());
 2747|  12.1k|                    Line& line = m_Lines[line_index.unsafe()];
 2748|  12.1k|                    if (shift)
  ------------------
  |  Branch (2748:25): [True: 9.91k, False: 2.25k]
  ------------------
 2749|  9.91k|                    {
 2750|       |                        // Remove idention
 2751|  9.91k|                        if (line.empty())
  ------------------
  |  Branch (2751:29): [True: 4.09k, False: 5.81k]
  ------------------
 2752|  4.09k|                        {
 2753|       |                            // Skip already empty lines
 2754|  4.09k|                            continue;
 2755|  4.09k|                        }
 2756|       |
 2757|  5.81k|                        if (line.front().m_Char == '\t')
  ------------------
  |  Branch (2757:29): [True: 2.82k, False: 2.99k]
  ------------------
 2758|  2.82k|                        {
 2759|  2.82k|                            line.erase(line.begin());
 2760|  2.82k|                            modified = true;
 2761|  2.82k|                        }
 2762|  2.99k|                        else
 2763|  2.99k|                        {
 2764|  2.99k|                            for (phi::u32 j = 0u;
 2765|  4.87k|                                 j < m_TabSize && !line.empty() && line.front().m_Char == ' '; ++j)
  ------------------
  |  Branch (2765:34): [True: 4.23k, False: 647]
  |  Branch (2765:34): [True: 1.88k, False: 2.99k]
  |  Branch (2765:51): [True: 3.81k, False: 414]
  |  Branch (2765:68): [True: 1.88k, False: 1.93k]
  ------------------
 2766|  1.88k|                            {
 2767|  1.88k|                                line.erase(line.begin());
 2768|  1.88k|                                modified = true;
 2769|  1.88k|                            }
 2770|  2.99k|                        }
 2771|  5.81k|                    }
 2772|  2.25k|                    else
 2773|  2.25k|                    {
 2774|  2.25k|                        PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
 2775|       |
 2776|       |                        // Add indention
 2777|  2.25k|                        line.insert(line.begin(), Glyph('\t', PaletteIndex::Background));
 2778|  2.25k|                        modified = true;
 2779|       |
 2780|  2.25k|                        PHI_GCC_SUPPRESS_WARNING_POP()
 2781|  2.25k|                    }
 2782|  12.1k|                }
 2783|       |
 2784|    445|                if (modified)
  ------------------
  |  Branch (2784:21): [True: 386, False: 59]
  ------------------
 2785|    386|                {
 2786|    386|                    start = Coordinates(start.m_Line, GetCharacterColumn(start.m_Line, 0u));
 2787|    386|                    Coordinates range_end;
 2788|       |
 2789|    386|                    if (original_end.m_Column != 0u)
  ------------------
  |  Branch (2789:25): [True: 382, False: 4]
  ------------------
 2790|    382|                    {
 2791|    382|                        end          = Coordinates(end.m_Line, GetLineMaxColumn(end.m_Line));
 2792|    382|                        range_end    = end;
 2793|    382|                        undo.m_Added = GetText(start, end);
 2794|    382|                    }
 2795|      4|                    else
 2796|      4|                    {
 2797|      4|                        end       = Coordinates(original_end.m_Line, 0u);
 2798|      4|                        range_end = Coordinates(end.m_Line - 1u, GetLineMaxColumn(end.m_Line - 1u));
 2799|      4|                        undo.m_Added = GetText(start, range_end);
 2800|      4|                    }
 2801|       |
 2802|    386|                    undo.m_AddedStart        = start;
 2803|    386|                    undo.m_AddedEnd          = range_end;
 2804|    386|                    m_State.m_SelectionStart = start;
 2805|    386|                    m_State.m_SelectionEnd   = end;
 2806|       |
 2807|    386|                    undo.StoreAfterState(this);
 2808|    386|                    AddUndo(undo);
 2809|       |
 2810|    386|                    m_TextChanged = true;
 2811|       |
 2812|    386|                    EnsureCursorVisible();
 2813|    386|                }
 2814|       |
 2815|    445|                return;
 2816|    445|            } // c == '\t'
 2817|  1.01k|            else
 2818|  1.01k|            {
 2819|  1.01k|                undo.m_Removed      = GetSelectedText();
 2820|  1.01k|                undo.m_RemovedStart = m_State.m_SelectionStart;
 2821|  1.01k|                undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2822|  1.01k|                DeleteSelection();
 2823|       |
 2824|  1.01k|                removed_selection = true;
 2825|  1.01k|            }
 2826|  1.45k|        } // HasSelection
 2827|  30.4k|        {
 2828|       |            // Reset selection
 2829|  30.4k|            ClearSelection();
 2830|  30.4k|        }
 2831|       |
 2832|  30.4k|        const Coordinates coord = GetActualCursorCoordinates();
 2833|  30.4k|        undo.m_AddedStart       = coord;
 2834|       |
 2835|  30.4k|        PHI_ASSERT(!m_Lines.empty());
 2836|       |
 2837|  30.4k|        if (character == '\n')
  ------------------
  |  Branch (2837:13): [True: 14.9k, False: 15.4k]
  ------------------
 2838|  14.9k|        {
 2839|  14.9k|            InsertLine(coord.m_Line + 1u);
 2840|  14.9k|            undo.m_Added = static_cast<char>(character);
 2841|       |
 2842|  14.9k|            PHI_ASSERT(coord.m_Line < m_Lines.size() - 1u);
 2843|  14.9k|            Line& line     = m_Lines[coord.m_Line.unsafe()];
 2844|  14.9k|            Line& new_line = m_Lines[coord.m_Line.unsafe() + 1u];
 2845|       |
 2846|   745k|            for (phi::u32 it{0u}; it < line.size() && it < coord.m_Column &&
  ------------------
  |  Branch (2846:35): [True: 735k, False: 10.7k]
  |  Branch (2846:35): [True: 730k, False: 14.9k]
  |  Branch (2846:55): [True: 733k, False: 1.45k]
  ------------------
 2847|   745k|                                  phi::is_blank(static_cast<char>(line[it.unsafe()].m_Char));
  ------------------
  |  Branch (2847:35): [True: 730k, False: 2.77k]
  ------------------
 2848|   730k|                 ++it)
 2849|   730k|            {
 2850|   730k|                new_line.push_back(line[it.unsafe()]);
 2851|   730k|                undo.m_Added += static_cast<char>(line[it.unsafe()].m_Char);
 2852|   730k|            }
 2853|       |
 2854|  14.9k|            const phi::usize whitespace_size = new_line.size();
 2855|  14.9k|            const phi::u32   cindex          = GetCharacterIndex(coord);
 2856|  14.9k|            new_line.insert(new_line.end(), line.begin() + cindex.unsafe(), line.end());
 2857|  14.9k|            line.erase(line.begin() + cindex.unsafe(),
 2858|  14.9k|                       line.begin() + static_cast<phi::int32_t>(line.size()));
 2859|       |
 2860|  14.9k|            SetCursorPosition(Coordinates(
 2861|  14.9k|                    coord.m_Line + 1u,
 2862|  14.9k|                    GetCharacterColumn(coord.m_Line.unsafe() + 1u,
 2863|  14.9k|                                       static_cast<phi::uint32_t>(whitespace_size.unsafe()))));
 2864|  14.9k|        }
 2865|  15.4k|        else
 2866|  15.4k|        {
 2867|  15.4k|            phi::array<char, 5u> buffer{};
 2868|  15.4k|            const phi::u8_fast   length = ImTextCharToUtf8(buffer, character);
 2869|       |
 2870|       |            // We require a valid ut8 sequence
 2871|  15.4k|            PHI_ASSERT(length > 0u);
 2872|       |
 2873|  15.4k|            Line&    line   = m_Lines[phi::narrow_cast<phi::size_t>(coord.m_Line)];
 2874|  15.4k|            phi::u32 cindex = GetCharacterIndex(coord);
 2875|       |
 2876|  15.4k|            if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (2876:17): [True: 744, False: 14.7k]
  |  Branch (2876:17): [True: 216, False: 15.2k]
  |  Branch (2876:32): [True: 216, False: 528]
  ------------------
 2877|    216|            {
 2878|    216|                phi::u8_fast char_length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 2879|       |
 2880|       |                // Only set the start if haven't removed something from deleting the selection beforehand
 2881|    216|                if (removed_selection)
  ------------------
  |  Branch (2881:21): [True: 24, False: 192]
  ------------------
 2882|     24|                {
 2883|     24|                    undo.m_RemovedEnd.m_Column += 1u;
 2884|     24|                }
 2885|    192|                else
 2886|    192|                {
 2887|    192|                    undo.m_RemovedStart = m_State.m_CursorPosition;
 2888|    192|                    undo.m_RemovedEnd   = Coordinates(
 2889|    192|                            coord.m_Line, GetCharacterColumn(coord.m_Line, cindex + char_length));
 2890|    192|                }
 2891|       |
 2892|    721|                for (; char_length > 0u && cindex < line.size(); --char_length)
  ------------------
  |  Branch (2892:24): [True: 505, False: 216]
  |  Branch (2892:24): [True: 505, False: 216]
  |  Branch (2892:44): [True: 505, False: 0]
  ------------------
 2893|    505|                {
 2894|    505|                    undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 2895|    505|                    line.erase(line.begin() + cindex.unsafe());
 2896|    505|                }
 2897|    216|            }
 2898|       |
 2899|  43.5k|            for (char* pointer = buffer.data(); *pointer != '\0'; ++pointer, ++cindex)
  ------------------
  |  Branch (2899:49): [True: 28.0k, False: 15.4k]
  ------------------
 2900|  28.0k|            {
 2901|  28.0k|                line.insert(line.begin() + cindex.unsafe(),
 2902|  28.0k|                            Glyph(static_cast<phi::uint8_t>(*pointer), PaletteIndex::Default));
 2903|  28.0k|            }
 2904|  15.4k|            undo.m_Added = phi::string_view{buffer.data(), length.unsafe()};
 2905|       |
 2906|  15.4k|            SetCursorPosition(Coordinates(coord.m_Line, GetCharacterColumn(coord.m_Line, cindex)));
 2907|  15.4k|        }
 2908|       |
 2909|  30.4k|        m_TextChanged = true;
 2910|       |
 2911|  30.4k|        undo.m_AddedEnd = GetActualCursorCoordinates();
 2912|  30.4k|        undo.StoreAfterState(this);
 2913|       |
 2914|  30.4k|        AddUndo(undo);
 2915|       |
 2916|  30.4k|        Colorize(coord.m_Line, 1u);
 2917|  30.4k|    }
_ZN6dlxemu10CodeEditor13BackspaceImplEv:
 2920|  7.43k|    {
 2921|  7.43k|        PHI_ASSERT(!m_ReadOnly);
 2922|  7.43k|        PHI_ASSERT(!m_Lines.empty());
 2923|       |
 2924|  7.43k|        UndoRecord undo;
 2925|  7.43k|        undo.StoreBeforeState(this);
 2926|       |
 2927|  7.43k|        if (HasSelection())
  ------------------
  |  Branch (2927:13): [True: 85, False: 7.35k]
  ------------------
 2928|     85|        {
 2929|     85|            undo.m_Removed      = GetSelectedText();
 2930|     85|            undo.m_RemovedStart = m_State.m_SelectionStart;
 2931|     85|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2932|       |
 2933|     85|            DeleteSelection();
 2934|     85|        }
 2935|  7.35k|        else
 2936|  7.35k|        {
 2937|  7.35k|            Coordinates pos = GetActualCursorCoordinates();
 2938|  7.35k|            SetCursorPosition(pos);
 2939|       |
 2940|  7.35k|            if (m_State.m_CursorPosition.m_Column == 0u)
  ------------------
  |  Branch (2940:17): [True: 3.84k, False: 3.50k]
  ------------------
 2941|  3.84k|            {
 2942|  3.84k|                if (m_State.m_CursorPosition.m_Line == 0u)
  ------------------
  |  Branch (2942:21): [True: 851, False: 2.99k]
  ------------------
 2943|    851|                {
 2944|    851|                    return;
 2945|    851|                }
 2946|       |
 2947|  2.99k|                undo.m_Removed      = '\n';
 2948|  2.99k|                undo.m_RemovedStart = undo.m_RemovedEnd =
 2949|  2.99k|                        Coordinates(pos.m_Line - 1u, GetLineMaxColumn(pos.m_Line - 1u));
 2950|  2.99k|                Advance(undo.m_RemovedEnd);
 2951|       |
 2952|  2.99k|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2953|  2.99k|                Line& line      = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2954|  2.99k|                Line& prev_line = m_Lines[m_State.m_CursorPosition.m_Line.unsafe() - 1u];
 2955|       |
 2956|  2.99k|                const phi::u32 prev_size = GetLineMaxColumn(m_State.m_CursorPosition.m_Line - 1u);
 2957|  2.99k|                prev_line.insert(prev_line.end(), line.begin(), line.end());
 2958|       |
 2959|  2.99k|                ErrorMarkers etmp;
 2960|  2.99k|                for (auto& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (2960:41): [True: 2.76k, False: 2.99k]
  ------------------
 2961|  2.76k|                {
 2962|  2.76k|                    const phi::u32 error_marker_line = error_marker.first;
 2963|       |
 2964|  2.76k|                    etmp.insert(ErrorMarkers::value_type(
 2965|  2.76k|                            (error_marker_line - 1u) == m_State.m_CursorPosition.m_Line ?
  ------------------
  |  Branch (2965:29): [True: 4, False: 2.75k]
  ------------------
 2966|      4|                                    error_marker_line - 1u :
 2967|  2.76k|                                    error_marker_line,
 2968|  2.76k|                            error_marker.second));
 2969|  2.76k|                }
 2970|  2.99k|                m_ErrorMarkers = phi::move(etmp);
 2971|       |
 2972|  2.99k|                RemoveLine(m_State.m_CursorPosition.m_Line);
 2973|  2.99k|                --m_State.m_CursorPosition.m_Line;
 2974|  2.99k|                m_State.m_CursorPosition.m_Column = prev_size;
 2975|  2.99k|            }
 2976|  3.50k|            else
 2977|  3.50k|            {
 2978|  3.50k|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2979|  3.50k|                Line&    line   = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2980|  3.50k|                phi::u32 cindex = GetCharacterIndex(pos) - 1u;
 2981|       |
 2982|  3.50k|                if (line[cindex.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2982:21): [True: 2, False: 3.50k]
  ------------------
 2983|      2|                {
 2984|      2|                    undo.m_RemovedStart.m_Line = GetActualCursorCoordinates().m_Line;
 2985|      2|                    undo.m_RemovedEnd          = GetActualCursorCoordinates();
 2986|      2|                    undo.m_Removed             = '\t';
 2987|       |
 2988|      2|                    line.erase(line.begin() + cindex.unsafe());
 2989|       |
 2990|       |                    // Move cursor back
 2991|      2|                    m_State.m_CursorPosition.m_Column = GetCharacterColumn(pos.m_Line, cindex);
 2992|      2|                    undo.m_RemovedStart.m_Column      = GetCharacterColumn(pos.m_Line, cindex);
 2993|      2|                }
 2994|  3.50k|                else
 2995|  3.50k|                {
 2996|  3.50k|                    phi::u32 cend = cindex + 1u;
 2997|  6.84k|                    while (cindex > 0u && IsUTFSequence(line[cindex.unsafe()].m_Char))
  ------------------
  |  Branch (2997:28): [True: 5.71k, False: 1.12k]
  |  Branch (2997:28): [True: 3.34k, False: 3.50k]
  |  Branch (2997:43): [True: 3.34k, False: 2.37k]
  ------------------
 2998|  3.34k|                    {
 2999|  3.34k|                        --cindex;
 3000|  3.34k|                    }
 3001|       |
 3002|  3.50k|                    undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 3003|  3.50k|                    --undo.m_RemovedStart.m_Column;
 3004|  3.50k|                    --m_State.m_CursorPosition.m_Column;
 3005|       |
 3006|  10.3k|                    for (; cindex < line.size() && cend > cindex; --cend)
  ------------------
  |  Branch (3006:28): [True: 7.41k, False: 2.92k]
  |  Branch (3006:28): [True: 6.84k, False: 3.50k]
  |  Branch (3006:52): [True: 6.84k, False: 572]
  ------------------
 3007|  6.84k|                    {
 3008|  6.84k|                        undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 3009|  6.84k|                        line.erase(line.begin() + cindex.unsafe());
 3010|  6.84k|                    }
 3011|  3.50k|                }
 3012|  3.50k|            }
 3013|       |
 3014|  6.50k|            m_TextChanged = true;
 3015|       |
 3016|  6.50k|            EnsureCursorVisible();
 3017|  6.50k|            Colorize(m_State.m_CursorPosition.m_Line, 1);
 3018|  6.50k|        }
 3019|       |
 3020|       |        // Correct selection
 3021|  6.58k|        m_State.m_SelectionStart = SanitizeCoordinates(m_State.m_SelectionStart);
 3022|  6.58k|        m_State.m_SelectionEnd   = SanitizeCoordinates(m_State.m_SelectionEnd);
 3023|       |
 3024|  6.58k|        undo.StoreAfterState(this);
 3025|  6.58k|        AddUndo(undo);
 3026|  6.58k|    }
_ZN6dlxemu10CodeEditor15DeleteSelectionEv:
 3029|  3.04k|    {
 3030|  3.04k|        if (m_State.m_SelectionEnd == m_State.m_SelectionStart)
  ------------------
  |  Branch (3030:13): [True: 0, False: 3.04k]
  ------------------
 3031|      0|        {
 3032|      0|            return;
 3033|      0|        }
 3034|       |
 3035|  3.04k|        DeleteRange(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 3036|       |
 3037|  3.04k|        SetSelection(m_State.m_SelectionStart, m_State.m_SelectionStart);
 3038|  3.04k|        SetCursorPosition(m_State.m_SelectionStart);
 3039|  3.04k|        Colorize(m_State.m_SelectionStart.m_Line, 1);
 3040|  3.04k|        m_TextChanged = true;
 3041|  3.04k|    }
_ZNK6dlxemu10CodeEditor13GetGlyphColorERKNS0_5GlyphE:
 3044|    987|    {
 3045|    987|        if (!m_ColorizerEnabled)
  ------------------
  |  Branch (3045:13): [True: 0, False: 987]
  ------------------
 3046|      0|        {
 3047|      0|            return GetPaletteForIndex(PaletteIndex::Default);
 3048|      0|        }
 3049|       |
 3050|    987|        return GetPaletteForIndex(glyph.m_ColorIndex);
 3051|    987|    }
_ZN6dlxemu10CodeEditor20HandleKeyboardInputsEv:
 3054|    323|    {
 3055|    323|        if (!ImGui::IsWindowFocused())
  ------------------
  |  Branch (3055:13): [True: 132, False: 191]
  ------------------
 3056|    132|        {
 3057|    132|            return;
 3058|    132|        }
 3059|       |
 3060|    191|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3061|    191|        const phi::boolean shift    = imgui_io.KeyShift;
 3062|    191|        const phi::boolean ctrl =
 3063|    191|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3063:17): [True: 0, False: 191]
  ------------------
 3064|    191|        const phi::boolean alt =
 3065|    191|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3065:17): [True: 0, False: 191]
  ------------------
 3066|       |
 3067|    191|        if (ImGui::IsWindowHovered())
  ------------------
  |  Branch (3067:13): [True: 0, False: 191]
  ------------------
 3068|      0|        {
 3069|      0|            ImGui::SetMouseCursor(ImGuiMouseCursor_TextInput);
 3070|      0|        }
 3071|       |        //ImGui::CaptureKeyboardFromApp(true);
 3072|       |
 3073|    191|        imgui_io.WantCaptureKeyboard = true;
 3074|    191|        imgui_io.WantTextInput       = true;
 3075|       |
 3076|    191|        if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Z))
  ------------------
  |  Branch (3076:13): [True: 176, False: 15]
  |  Branch (3076:13): [True: 0, False: 191]
  |  Branch (3076:30): [True: 0, False: 176]
  |  Branch (3076:38): [True: 0, False: 0]
  |  Branch (3076:48): [True: 0, False: 0]
  |  Branch (3076:56): [True: 0, False: 0]
  ------------------
 3077|      0|        {
 3078|      0|            Undo();
 3079|      0|        }
 3080|    191|        else if (!IsReadOnly() && !ctrl && !shift && alt && ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3080:18): [True: 176, False: 15]
  |  Branch (3080:18): [True: 0, False: 191]
  |  Branch (3080:35): [True: 176, False: 0]
  |  Branch (3080:44): [True: 176, False: 0]
  |  Branch (3080:54): [True: 0, False: 176]
  |  Branch (3080:61): [True: 0, False: 0]
  ------------------
 3081|      0|        {
 3082|      0|            Undo();
 3083|      0|        }
 3084|    191|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Y))
  ------------------
  |  Branch (3084:18): [True: 176, False: 15]
  |  Branch (3084:18): [True: 0, False: 191]
  |  Branch (3084:35): [True: 0, False: 176]
  |  Branch (3084:43): [True: 0, False: 0]
  |  Branch (3084:53): [True: 0, False: 0]
  |  Branch (3084:61): [True: 0, False: 0]
  ------------------
 3085|      0|        {
 3086|      0|            Redo();
 3087|      0|        }
 3088|    191|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_UpArrow))
  ------------------
  |  Branch (3088:18): [True: 191, False: 0]
  |  Branch (3088:18): [True: 1, False: 190]
  |  Branch (3088:27): [True: 191, False: 0]
  |  Branch (3088:35): [True: 1, False: 190]
  ------------------
 3089|      1|        {
 3090|      1|            MoveUp(1u, shift);
 3091|      1|        }
 3092|    190|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_DownArrow))
  ------------------
  |  Branch (3092:18): [True: 190, False: 0]
  |  Branch (3092:18): [True: 0, False: 190]
  |  Branch (3092:27): [True: 190, False: 0]
  |  Branch (3092:35): [True: 0, False: 190]
  ------------------
 3093|      0|        {
 3094|      0|            MoveDown(1u, shift);
 3095|      0|        }
 3096|    190|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_LeftArrow))
  ------------------
  |  Branch (3096:18): [True: 190, False: 0]
  |  Branch (3096:18): [True: 0, False: 190]
  |  Branch (3096:26): [True: 0, False: 190]
  ------------------
 3097|      0|        {
 3098|      0|            MoveLeft(1u, shift, ctrl);
 3099|      0|        }
 3100|    190|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_RightArrow))
  ------------------
  |  Branch (3100:18): [True: 190, False: 0]
  |  Branch (3100:18): [True: 6, False: 184]
  |  Branch (3100:26): [True: 6, False: 184]
  ------------------
 3101|      6|        {
 3102|      6|            MoveRight(1u, shift, ctrl);
 3103|      6|        }
 3104|    184|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageUp))
  ------------------
  |  Branch (3104:18): [True: 184, False: 0]
  |  Branch (3104:18): [True: 0, False: 184]
  |  Branch (3104:26): [True: 0, False: 184]
  ------------------
 3105|      0|        {
 3106|      0|            const phi::u32 page_size = GetPageSize();
 3107|      0|            MoveUp(page_size - 4u, shift);
 3108|      0|        }
 3109|    184|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageDown))
  ------------------
  |  Branch (3109:18): [True: 184, False: 0]
  |  Branch (3109:18): [True: 0, False: 184]
  |  Branch (3109:26): [True: 0, False: 184]
  ------------------
 3110|      0|        {
 3111|      0|            const phi::u32 page_size = GetPageSize();
 3112|      0|            MoveDown(page_size - 4u, shift);
 3113|      0|        }
 3114|    184|        else if (!alt && ctrl && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3114:18): [True: 184, False: 0]
  |  Branch (3114:18): [True: 0, False: 184]
  |  Branch (3114:26): [True: 0, False: 184]
  |  Branch (3114:34): [True: 0, False: 0]
  ------------------
 3115|      0|        {
 3116|      0|            MoveTop(shift);
 3117|      0|        }
 3118|    184|        else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3118:18): [True: 0, False: 184]
  |  Branch (3118:18): [True: 0, False: 184]
  |  Branch (3118:26): [True: 0, False: 0]
  |  Branch (3118:34): [True: 0, False: 0]
  ------------------
 3119|      0|        {
 3120|      0|            MoveBottom(shift);
 3121|      0|        }
 3122|    184|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3122:18): [True: 184, False: 0]
  |  Branch (3122:18): [True: 0, False: 184]
  |  Branch (3122:27): [True: 184, False: 0]
  |  Branch (3122:35): [True: 0, False: 184]
  ------------------
 3123|      0|        {
 3124|      0|            MoveHome(shift);
 3125|      0|        }
 3126|    184|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3126:18): [True: 184, False: 0]
  |  Branch (3126:18): [True: 0, False: 184]
  |  Branch (3126:27): [True: 184, False: 0]
  |  Branch (3126:35): [True: 0, False: 184]
  ------------------
 3127|      0|        {
 3128|      0|            MoveEnd(shift);
 3129|      0|        }
 3130|    184|        else if (!IsReadOnly() && !ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3130:18): [True: 171, False: 13]
  |  Branch (3130:18): [True: 0, False: 184]
  |  Branch (3130:35): [True: 171, False: 0]
  |  Branch (3130:44): [True: 171, False: 0]
  |  Branch (3130:54): [True: 171, False: 0]
  |  Branch (3130:62): [True: 0, False: 171]
  ------------------
 3131|      0|        {
 3132|      0|            Delete();
 3133|      0|        }
 3134|    184|        else if (!IsReadOnly() && !ctrl && !shift && !alt &&
  ------------------
  |  Branch (3134:18): [True: 171, False: 13]
  |  Branch (3134:18): [True: 0, False: 184]
  |  Branch (3134:35): [True: 171, False: 0]
  |  Branch (3134:44): [True: 171, False: 0]
  |  Branch (3134:54): [True: 171, False: 0]
  ------------------
 3135|    184|                 ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3135:18): [True: 0, False: 171]
  ------------------
 3136|      0|        {
 3137|      0|            BackspaceImpl();
 3138|      0|        }
 3139|    184|        else if (!ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3139:18): [True: 184, False: 0]
  |  Branch (3139:18): [True: 0, False: 184]
  |  Branch (3139:27): [True: 184, False: 0]
  |  Branch (3139:37): [True: 184, False: 0]
  |  Branch (3139:45): [True: 0, False: 184]
  ------------------
 3140|      0|        {
 3141|      0|            m_Overwrite = !m_Overwrite;
 3142|      0|        }
 3143|    184|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3143:18): [True: 0, False: 184]
  |  Branch (3143:18): [True: 0, False: 184]
  |  Branch (3143:26): [True: 0, False: 0]
  |  Branch (3143:36): [True: 0, False: 0]
  |  Branch (3143:44): [True: 0, False: 0]
  ------------------
 3144|      0|        {
 3145|      0|            Copy();
 3146|      0|        }
 3147|    184|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_C))
  ------------------
  |  Branch (3147:18): [True: 0, False: 184]
  |  Branch (3147:18): [True: 0, False: 184]
  |  Branch (3147:26): [True: 0, False: 0]
  |  Branch (3147:36): [True: 0, False: 0]
  |  Branch (3147:44): [True: 0, False: 0]
  ------------------
 3148|      0|        {
 3149|      0|            Copy();
 3150|      0|        }
 3151|    184|        else if (!IsReadOnly() && !ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3151:18): [True: 171, False: 13]
  |  Branch (3151:18): [True: 0, False: 184]
  |  Branch (3151:35): [True: 171, False: 0]
  |  Branch (3151:44): [True: 0, False: 171]
  |  Branch (3151:53): [True: 0, False: 0]
  |  Branch (3151:61): [True: 0, False: 0]
  ------------------
 3152|      0|        {
 3153|      0|            Paste();
 3154|      0|        }
 3155|    184|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_V))
  ------------------
  |  Branch (3155:18): [True: 171, False: 13]
  |  Branch (3155:18): [True: 0, False: 184]
  |  Branch (3155:35): [True: 0, False: 171]
  |  Branch (3155:43): [True: 0, False: 0]
  |  Branch (3155:53): [True: 0, False: 0]
  |  Branch (3155:61): [True: 0, False: 0]
  ------------------
 3156|      0|        {
 3157|      0|            Paste();
 3158|      0|        }
 3159|    184|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_X))
  ------------------
  |  Branch (3159:18): [True: 0, False: 184]
  |  Branch (3159:18): [True: 0, False: 184]
  |  Branch (3159:26): [True: 0, False: 0]
  |  Branch (3159:36): [True: 0, False: 0]
  |  Branch (3159:44): [True: 0, False: 0]
  ------------------
 3160|      0|        {
 3161|      0|            Cut();
 3162|      0|        }
 3163|    184|        else if (!ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3163:18): [True: 184, False: 0]
  |  Branch (3163:18): [True: 0, False: 184]
  |  Branch (3163:27): [True: 0, False: 184]
  |  Branch (3163:36): [True: 0, False: 0]
  |  Branch (3163:44): [True: 0, False: 0]
  ------------------
 3164|      0|        {
 3165|      0|            Cut();
 3166|      0|        }
 3167|    184|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_A))
  ------------------
  |  Branch (3167:18): [True: 0, False: 184]
  |  Branch (3167:18): [True: 0, False: 184]
  |  Branch (3167:26): [True: 0, False: 0]
  |  Branch (3167:36): [True: 0, False: 0]
  |  Branch (3167:44): [True: 0, False: 0]
  ------------------
 3168|      0|        {
 3169|      0|            SelectAll();
 3170|      0|        }
 3171|    184|        else if (!IsReadOnly() && !ctrl && !alt &&
  ------------------
  |  Branch (3171:18): [True: 171, False: 13]
  |  Branch (3171:18): [True: 0, False: 184]
  |  Branch (3171:35): [True: 171, False: 0]
  |  Branch (3171:44): [True: 171, False: 0]
  ------------------
 3172|    184|                 (ImGui::IsKeyPressed(ImGuiKey_Enter) || ImGui::IsKeyPressed(ImGuiKey_KeypadEnter)))
  ------------------
  |  Branch (3172:19): [True: 0, False: 171]
  |  Branch (3172:58): [True: 0, False: 171]
  ------------------
 3173|      0|        {
 3174|      0|            EnterCharacterImpl('\n', shift);
 3175|      0|        }
 3176|    184|        else if (!IsReadOnly() && !ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Tab))
  ------------------
  |  Branch (3176:18): [True: 171, False: 13]
  |  Branch (3176:18): [True: 0, False: 184]
  |  Branch (3176:35): [True: 171, False: 0]
  |  Branch (3176:44): [True: 171, False: 0]
  |  Branch (3176:52): [True: 0, False: 171]
  ------------------
 3177|      0|        {
 3178|      0|            EnterCharacterImpl('\t', shift);
 3179|      0|        }
 3180|       |
 3181|    191|        if (!IsReadOnly() && !imgui_io.InputQueueCharacters.empty())
  ------------------
  |  Branch (3181:13): [True: 176, False: 15]
  |  Branch (3181:13): [True: 6, False: 185]
  |  Branch (3181:30): [True: 6, False: 170]
  ------------------
 3182|      6|        {
 3183|     12|            for (phi::i32 i{0}; i < imgui_io.InputQueueCharacters.Size; ++i)
  ------------------
  |  Branch (3183:33): [True: 6, False: 6]
  ------------------
 3184|      6|            {
 3185|      6|                ImWchar input_char = imgui_io.InputQueueCharacters[i.unsafe()];
 3186|      6|                if (input_char != '\0' && IsValidUTF8Sequence(input_char))
  ------------------
  |  Branch (3186:21): [True: 6, False: 0]
  |  Branch (3186:21): [True: 6, False: 0]
  |  Branch (3186:43): [True: 6, False: 0]
  ------------------
 3187|      6|                {
 3188|      6|                    EnterCharacterImpl(input_char, shift);
 3189|      6|                }
 3190|      6|            }
 3191|       |
 3192|      6|            imgui_io.InputQueueCharacters.resize(0);
 3193|      6|        }
 3194|    191|    }
_ZN6dlxemu10CodeEditor17HandleMouseInputsEv:
 3197|    323|    {
 3198|       |        // Do nothing if our window is not hovered
 3199|    323|        if (!ImGui::IsWindowHovered())
  ------------------
  |  Branch (3199:13): [True: 323, False: 0]
  ------------------
 3200|    323|        {
 3201|    323|            return;
 3202|    323|        }
 3203|       |
 3204|      0|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3205|      0|        const phi::boolean shift    = imgui_io.KeyShift;
 3206|      0|        const phi::boolean ctrl =
 3207|      0|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3207:17): [True: 0, False: 0]
  ------------------
 3208|      0|        const phi::boolean alt =
 3209|      0|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3209:17): [True: 0, False: 0]
  ------------------
 3210|       |
 3211|      0|        if (shift || alt)
  ------------------
  |  Branch (3211:13): [True: 0, False: 0]
  |  Branch (3211:22): [True: 0, False: 0]
  ------------------
 3212|      0|        {
 3213|      0|            return;
 3214|      0|        }
 3215|       |
 3216|       |        // TODO: Maybe theres a smarter way here than suppressing the warning and comparing m_LastClick != -1.0f?
 3217|      0|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3218|       |
 3219|      0|        const phi::boolean click        = ImGui::IsMouseClicked(ImGuiMouseButton_Left);
 3220|      0|        const phi::boolean double_click = ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left);
 3221|      0|        const double       time         = ImGui::GetTime();
 3222|      0|        const phi::boolean triple_click =
 3223|      0|                click && !double_click &&
  ------------------
  |  Branch (3223:17): [True: 0, False: 0]
  |  Branch (3223:26): [True: 0, False: 0]
  ------------------
 3224|      0|                (m_LastClick != -1.0f &&
  ------------------
  |  Branch (3224:18): [True: 0, False: 0]
  ------------------
 3225|      0|                 (static_cast<float>(time) - m_LastClick) < imgui_io.MouseDoubleClickTime);
  ------------------
  |  Branch (3225:18): [True: 0, False: 0]
  ------------------
 3226|       |
 3227|      0|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_POP()
 3228|       |
 3229|       |        /*
 3230|       |            Left mouse button triple click
 3231|       |        */
 3232|       |
 3233|      0|        if (triple_click)
  ------------------
  |  Branch (3233:13): [True: 0, False: 0]
  ------------------
 3234|      0|        {
 3235|      0|            if (!ctrl)
  ------------------
  |  Branch (3235:17): [True: 0, False: 0]
  ------------------
 3236|      0|            {
 3237|      0|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3238|      0|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3239|      0|                m_SelectionMode = SelectionMode::Line;
 3240|      0|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3241|      0|            }
 3242|       |
 3243|      0|            m_LastClick = -1.0f;
 3244|      0|        }
 3245|       |
 3246|       |        /*
 3247|       |            Left mouse button double click
 3248|       |        */
 3249|       |
 3250|      0|        else if (double_click)
  ------------------
  |  Branch (3250:18): [True: 0, False: 0]
  ------------------
 3251|      0|        {
 3252|      0|            if (!ctrl)
  ------------------
  |  Branch (3252:17): [True: 0, False: 0]
  ------------------
 3253|      0|            {
 3254|      0|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3255|      0|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3256|      0|                if (m_SelectionMode == SelectionMode::Line)
  ------------------
  |  Branch (3256:21): [True: 0, False: 0]
  ------------------
 3257|      0|                {
 3258|      0|                    m_SelectionMode = SelectionMode::Normal;
 3259|      0|                }
 3260|      0|                else
 3261|      0|                {
 3262|      0|                    m_SelectionMode = SelectionMode::Word;
 3263|      0|                }
 3264|      0|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3265|      0|            }
 3266|       |
 3267|      0|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3268|      0|        }
 3269|       |
 3270|       |        /*
 3271|       |            Left mouse button click
 3272|       |        */
 3273|       |
 3274|      0|        else if (click)
  ------------------
  |  Branch (3274:18): [True: 0, False: 0]
  ------------------
 3275|      0|        {
 3276|      0|            m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3277|      0|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3278|      0|            if (ctrl)
  ------------------
  |  Branch (3278:17): [True: 0, False: 0]
  ------------------
 3279|      0|            {
 3280|      0|                m_SelectionMode = SelectionMode::Word;
 3281|      0|            }
 3282|      0|            else
 3283|      0|            {
 3284|      0|                m_SelectionMode = SelectionMode::Normal;
 3285|      0|            }
 3286|      0|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3287|       |
 3288|      0|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3289|      0|        }
 3290|       |        // Mouse left button dragging (=> update selection)
 3291|      0|        else if (ImGui::IsMouseDragging(ImGuiMouseButton_Left) &&
  ------------------
  |  Branch (3291:18): [True: 0, False: 0]
  ------------------
 3292|      0|                 ImGui::IsMouseDown(ImGuiMouseButton_Left))
  ------------------
  |  Branch (3292:18): [True: 0, False: 0]
  ------------------
 3293|      0|        {
 3294|      0|            imgui_io.WantCaptureMouse = true;
 3295|      0|            m_State.m_CursorPosition  = m_InteractiveEnd =
 3296|      0|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3297|      0|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3298|      0|        }
 3299|      0|    }
_ZN6dlxemu10CodeEditor14InternalRenderEv:
 3303|    323|    {
 3304|    323|        PHI_ASSERT(m_LineBuffer.empty());
 3305|       |
 3306|    323|        const ImVec2 content_size = ImGui::GetWindowContentRegionMax();
 3307|    323|        ImDrawList*  draw_list    = ImGui::GetWindowDrawList();
 3308|    323|        float        longest      = m_TextStart;
 3309|       |
 3310|    323|        if (m_ScrollToTop)
  ------------------
  |  Branch (3310:13): [True: 10, False: 313]
  ------------------
 3311|     10|        {
 3312|     10|            m_ScrollToTop = false;
 3313|     10|            ImGui::SetScrollY(0.f);
 3314|     10|        }
 3315|       |
 3316|    323|        const ImVec2 cursor_screen_pos = ImGui::GetCursorScreenPos();
 3317|    323|        const float  scroll_x          = ImGui::GetScrollX();
 3318|    323|        const float  scroll_y          = ImGui::GetScrollY();
 3319|       |
 3320|    323|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3321|    323|        phi::u32       line_no = static_cast<phi::uint32_t>(std::floor(scroll_y / m_CharAdvance.y));
 3322|    323|        const phi::u32 global_line_max = static_cast<phi::uint32_t>(m_Lines.size());
 3323|       |
 3324|       |        // TODO: This is very unreadable
 3325|    323|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3326|    323|        const phi::u32 line_max = static_cast<phi::uint32_t>(phi::clamp(
 3327|    323|                GetMaxLineNumber().unsafe(), 0u,
 3328|    323|                line_no.unsafe() + static_cast<phi::int32_t>(std::floor(
 3329|    323|                                           (scroll_y + content_size.y) / m_CharAdvance.y))));
 3330|       |
 3331|       |        // Deduce m_TextStart by evaluating mLines size (global lineMax) plus two spaces as text width
 3332|    323|        phi::array<char, 16u> buffer;
 3333|    323|        snprintf(buffer.data(), buffer.size().unsafe(), " %u ", global_line_max.unsafe());
 3334|    323|        m_TextStart = ImGui::GetFont()
 3335|    323|                              ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3336|    323|                                              nullptr, nullptr)
 3337|    323|                              .x +
 3338|    323|                      LeftMargin;
 3339|       |
 3340|    323|        PHI_ASSERT(!m_Lines.empty());
 3341|    323|        float space_size =
 3342|    323|                ImGui::GetFont()
 3343|    323|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 3344|    323|                        .x;
 3345|       |
 3346|  1.20k|        while (line_no <= line_max)
  ------------------
  |  Branch (3346:16): [True: 878, False: 323]
  ------------------
 3347|    878|        {
 3348|    878|            const ImVec2 line_start_screen_pos = ImVec2(
 3349|    878|                    cursor_screen_pos.x,
 3350|    878|                    cursor_screen_pos.y + static_cast<float>(line_no.unsafe()) * m_CharAdvance.y);
 3351|    878|            const ImVec2 text_screen_pos =
 3352|    878|                    ImVec2(line_start_screen_pos.x + m_TextStart, line_start_screen_pos.y);
 3353|       |
 3354|    878|            PHI_ASSERT(line_no < m_Lines.size());
 3355|    878|            const Line& line = m_Lines[line_no.unsafe()];
 3356|       |
 3357|    878|            longest               = phi::max(m_TextStart + TextDistanceToLineStart(Coordinates(
 3358|    878|                                                     line_no, GetLineMaxColumn(line_no))),
 3359|    878|                                             longest);
 3360|    878|            phi::u32    column_no = 0u;
 3361|    878|            Coordinates line_start_coord(line_no, 0u);
 3362|    878|            Coordinates line_end_coord(line_no, GetLineMaxColumn(line_no));
 3363|       |
 3364|       |            // Draw selection for the current line
 3365|    878|            float sstart = -1.0f;
 3366|    878|            float ssend  = -1.0f;
 3367|       |
 3368|    878|            PHI_ASSERT(m_State.m_SelectionStart <= m_State.m_SelectionEnd);
 3369|    878|            if (m_State.m_SelectionStart <= line_end_coord)
  ------------------
  |  Branch (3369:17): [True: 878, False: 0]
  ------------------
 3370|    878|            {
 3371|    878|                sstart = m_State.m_SelectionStart > line_start_coord ?
  ------------------
  |  Branch (3371:26): [True: 18, False: 860]
  ------------------
 3372|     18|                                 TextDistanceToLineStart(m_State.m_SelectionStart) :
 3373|    878|                                 0.0f;
 3374|    878|            }
 3375|       |
 3376|    878|            if (m_State.m_SelectionEnd > line_start_coord)
  ------------------
  |  Branch (3376:17): [True: 20, False: 858]
  ------------------
 3377|     20|            {
 3378|     20|                ssend = TextDistanceToLineStart(m_State.m_SelectionEnd < line_end_coord ?
  ------------------
  |  Branch (3378:49): [True: 0, False: 20]
  ------------------
 3379|      0|                                                        m_State.m_SelectionEnd :
 3380|     20|                                                        line_end_coord);
 3381|     20|            }
 3382|       |
 3383|    878|            if (m_State.m_SelectionEnd.m_Line > line_no)
  ------------------
  |  Branch (3383:17): [True: 0, False: 878]
  ------------------
 3384|      0|            {
 3385|      0|                ssend += m_CharAdvance.x;
 3386|      0|            }
 3387|       |
 3388|    878|            PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3389|       |
 3390|    878|            if (sstart != -1.0f && ssend != -1.0f && sstart < ssend)
  ------------------
  |  Branch (3390:17): [True: 878, False: 0]
  |  Branch (3390:36): [True: 20, False: 858]
  |  Branch (3390:54): [True: 2, False: 18]
  ------------------
 3391|      2|            {
 3392|      2|                const ImVec2 vstart(line_start_screen_pos.x + m_TextStart + sstart,
 3393|      2|                                    line_start_screen_pos.y);
 3394|      2|                const ImVec2 vend(line_start_screen_pos.x + m_TextStart + ssend,
 3395|      2|                                  line_start_screen_pos.y + m_CharAdvance.y);
 3396|       |
 3397|      2|                draw_list->AddRectFilled(vstart, vend, GetPaletteForIndex(PaletteIndex::Selection));
 3398|      2|            }
 3399|       |
 3400|    878|            PHI_GCC_SUPPRESS_WARNING_POP()
 3401|       |
 3402|       |            // Draw breakpoints
 3403|    878|            const ImVec2 start =
 3404|    878|                    ImVec2(line_start_screen_pos.x + scroll_x, line_start_screen_pos.y);
 3405|       |
 3406|    878|            if (m_Breakpoints.contains(line_no.unsafe() + 1u))
  ------------------
  |  Branch (3406:17): [True: 133, False: 745]
  ------------------
 3407|    133|            {
 3408|    133|                const ImVec2 end =
 3409|    133|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3410|    133|                               line_start_screen_pos.y + m_CharAdvance.y);
 3411|       |
 3412|    133|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::Breakpoint));
 3413|    133|            }
 3414|       |
 3415|       |            // Draw error markers
 3416|    878|            auto error_it = m_ErrorMarkers.find(line_no.unsafe() + 1u);
 3417|    878|            if (error_it != m_ErrorMarkers.end())
  ------------------
  |  Branch (3417:17): [True: 164, False: 714]
  ------------------
 3418|    164|            {
 3419|    164|                const ImVec2 end =
 3420|    164|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3421|    164|                               line_start_screen_pos.y + m_CharAdvance.y);
 3422|    164|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::ErrorMarker));
 3423|       |
 3424|    164|                if (GImGui->HoveredWindow == ImGui::GetCurrentWindow() &&
  ------------------
  |  Branch (3424:21): [True: 0, False: 164]
  ------------------
 3425|    164|                    ImGui::IsMouseHoveringRect(line_start_screen_pos, end))
  ------------------
  |  Branch (3425:21): [True: 0, False: 0]
  ------------------
 3426|      0|                {
 3427|      0|                    ImGui::BeginTooltip();
 3428|      0|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.2f, 0.2f, 1.0f));
 3429|      0|                    ImGui::Text("Error at line %u:", error_it->first);
 3430|      0|                    ImGui::PopStyleColor();
 3431|      0|                    ImGui::Separator();
 3432|      0|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.2f, 1.0f));
 3433|      0|                    ImGui::Text("%s", error_it->second.c_str());
 3434|      0|                    ImGui::PopStyleColor();
 3435|      0|                    ImGui::EndTooltip();
 3436|      0|                }
 3437|    164|            }
 3438|       |
 3439|       |            // Highlight PC line
 3440|    878|            const phi::u64 current_execution_line_number = m_Emulator->GetExecutingLineNumber();
 3441|    878|            if (line_no + 1u == current_execution_line_number)
  ------------------
  |  Branch (3441:17): [True: 0, False: 878]
  ------------------
 3442|      0|            {
 3443|      0|                const ImVec2 end =
 3444|      0|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3445|      0|                               line_start_screen_pos.y + m_CharAdvance.y);
 3446|       |                // TODO: Don't hardcode color
 3447|      0|                draw_list->AddRectFilled(start, end, 0x40ffff00);
 3448|      0|            }
 3449|       |
 3450|       |            // Draw line number (right aligned)
 3451|    878|            snprintf(buffer.data(), buffer.size().unsafe(), "%u  ", line_no.unsafe() + 1u);
 3452|       |
 3453|    878|            const float line_no_width =
 3454|    878|                    ImGui::GetFont()
 3455|    878|                            ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3456|    878|                                            nullptr, nullptr)
 3457|    878|                            .x;
 3458|    878|            draw_list->AddText(ImVec2(line_start_screen_pos.x + m_TextStart - line_no_width,
 3459|    878|                                      line_start_screen_pos.y),
 3460|    878|                               GetPaletteForIndex(PaletteIndex::LineNumber), buffer.data());
 3461|       |
 3462|    878|            if (m_State.m_CursorPosition.m_Line == line_no)
  ------------------
  |  Branch (3462:17): [True: 320, False: 558]
  ------------------
 3463|    320|            {
 3464|    320|                const phi::boolean focused = ImGui::IsWindowFocused();
 3465|       |
 3466|       |                // Highlight the current line (where the cursor is)
 3467|    320|                if (!HasSelection())
  ------------------
  |  Branch (3467:21): [True: 318, False: 2]
  ------------------
 3468|    318|                {
 3469|    318|                    const ImVec2 end =
 3470|    318|                            ImVec2(start.x + content_size.x + scroll_x, start.y + m_CharAdvance.y);
 3471|    318|                    draw_list->AddRectFilled(
 3472|    318|                            start, end,
 3473|    318|                            GetPaletteForIndex(focused ? PaletteIndex::CurrentLineFill :
  ------------------
  |  Branch (3473:48): [True: 188, False: 130]
  ------------------
 3474|    318|                                                         PaletteIndex::CurrentLineFillInactive));
 3475|    318|                    draw_list->AddRect(start, end,
 3476|    318|                                       GetPaletteForIndex(PaletteIndex::CurrentLineEdge), 1.0f);
 3477|    318|                }
 3478|       |
 3479|       |                // Render the cursor
 3480|    320|                if (focused)
  ------------------
  |  Branch (3480:21): [True: 190, False: 130]
  ------------------
 3481|    190|                {
 3482|    190|                    phi::uint64_t time_end = static_cast<phi::uint64_t>(
 3483|    190|                            std::chrono::duration_cast<std::chrono::milliseconds>(
 3484|    190|                                    std::chrono::system_clock::now().time_since_epoch())
 3485|    190|                                    .count());
 3486|    190|                    phi::uint64_t elapsed = time_end - m_StartTime;
 3487|    190|                    if (elapsed > 400)
  ------------------
  |  Branch (3487:25): [True: 0, False: 190]
  ------------------
 3488|      0|                    {
 3489|      0|                        float    width  = 1.0f;
 3490|      0|                        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
 3491|      0|                        float    cx     = TextDistanceToLineStart(m_State.m_CursorPosition);
 3492|       |
 3493|      0|                        if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (3493:29): [True: 0, False: 0]
  |  Branch (3493:29): [True: 0, False: 0]
  |  Branch (3493:44): [True: 0, False: 0]
  ------------------
 3494|      0|                        {
 3495|      0|                            char character = static_cast<char>(line[cindex.unsafe()].m_Char);
 3496|      0|                            if (character == '\t')
  ------------------
  |  Branch (3496:33): [True: 0, False: 0]
  ------------------
 3497|      0|                            {
 3498|      0|                                float x = (1.0f +
 3499|      0|                                           std::floor((1.0f + cx) /
 3500|      0|                                                      (float(m_TabSize.unsafe()) * space_size))) *
 3501|      0|                                          (float(m_TabSize.unsafe()) * space_size);
 3502|      0|                                width = x - cx;
 3503|      0|                            }
 3504|      0|                            else
 3505|      0|                            {
 3506|      0|                                phi::array<char, 2u> buffer2;
 3507|      0|                                buffer2[0u] = static_cast<char>(line[cindex.unsafe()].m_Char);
 3508|      0|                                buffer2[1u] = '\0';
 3509|      0|                                width       = ImGui::GetFont()
 3510|      0|                                                ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX,
 3511|      0|                                                                -1.0f, buffer2.data())
 3512|      0|                                                .x;
 3513|      0|                            }
 3514|      0|                        }
 3515|      0|                        const ImVec2 cstart(text_screen_pos.x + cx, line_start_screen_pos.y);
 3516|      0|                        const ImVec2 cend(text_screen_pos.x + cx + width,
 3517|      0|                                          line_start_screen_pos.y + m_CharAdvance.y);
 3518|      0|                        draw_list->AddRectFilled(cstart, cend,
 3519|      0|                                                 GetPaletteForIndex(PaletteIndex::Cursor));
 3520|      0|                        if (elapsed > 800)
  ------------------
  |  Branch (3520:29): [True: 0, False: 0]
  ------------------
 3521|      0|                        {
 3522|      0|                            m_StartTime = time_end;
 3523|      0|                        }
 3524|      0|                    }
 3525|    190|                }
 3526|    320|            }
 3527|       |
 3528|       |            // Render colorized text
 3529|    878|            ImU32  prev_color = line.empty() ? GetPaletteForIndex(PaletteIndex::Default) :
  ------------------
  |  Branch (3529:33): [True: 584, False: 294]
  ------------------
 3530|    878|                                               GetGlyphColor(line[0]);
 3531|    878|            ImVec2 buffer_offset;
 3532|       |
 3533|  1.57k|            for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (3533:36): [True: 693, False: 878]
  ------------------
 3534|    693|            {
 3535|    693|                const CodeEditor::Glyph& glyph = line[i.unsafe()];
 3536|    693|                const ImU32              color = GetGlyphColor(glyph);
 3537|       |
 3538|    693|                if ((color != prev_color || glyph.m_Char == '\t' || glyph.m_Char == ' ') &&
  ------------------
  |  Branch (3538:22): [True: 18, False: 675]
  |  Branch (3538:45): [True: 166, False: 509]
  |  Branch (3538:69): [True: 0, False: 509]
  ------------------
 3539|    693|                    !m_LineBuffer.empty())
  ------------------
  |  Branch (3539:21): [True: 16, False: 168]
  ------------------
 3540|     16|                {
 3541|     16|                    const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3542|     16|                                            text_screen_pos.y + buffer_offset.y);
 3543|     16|                    draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3544|     16|                    const ImVec2 text_size =
 3545|     16|                            ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 3546|     16|                                                            m_LineBuffer.c_str(), nullptr, nullptr);
 3547|     16|                    buffer_offset.x += text_size.x;
 3548|     16|                    m_LineBuffer.clear();
 3549|     16|                }
 3550|    693|                prev_color = color;
 3551|       |
 3552|    693|                if (glyph.m_Char == '\t')
  ------------------
  |  Branch (3552:21): [True: 166, False: 527]
  ------------------
 3553|    166|                {
 3554|    166|                    const float old_x = buffer_offset.x;
 3555|    166|                    buffer_offset.x =
 3556|    166|                            (1.0f + std::floor((1.0f + buffer_offset.x) /
 3557|    166|                                               (float(m_TabSize.unsafe()) * space_size))) *
 3558|    166|                            (float(m_TabSize.unsafe()) * space_size);
 3559|    166|                    ++i;
 3560|       |
 3561|    166|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3561:25): [True: 0, False: 166]
  ------------------
 3562|      0|                    {
 3563|      0|                        const float font_size =
 3564|      0|                                ImGui::GetFont()
 3565|      0|                                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#",
 3566|      0|                                                        nullptr, nullptr)
 3567|      0|                                        .x;
 3568|       |
 3569|      0|                        const float  s  = ImGui::GetFontSize();
 3570|      0|                        const float  x1 = text_screen_pos.x + old_x + 1.0f;
 3571|      0|                        const float  x2 = text_screen_pos.x + buffer_offset.x - 1.0f;
 3572|      0|                        const float  y  = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3573|      0|                        const ImVec2 p1(x1, y);
 3574|      0|                        const ImVec2 p2(x2, y);
 3575|      0|                        const ImVec2 p3(x2 - font_size * 0.2f, y - font_size * 0.2f);
 3576|      0|                        const ImVec2 p4(x2 - font_size * 0.2f, y + font_size * 0.2f);
 3577|       |
 3578|      0|                        PHI_MSVC_SUPPRESS_WARNING_WITH_PUSH(5264) // Unused const variable
 3579|       |
 3580|      0|                        static constexpr const ImU32 whitespace_color{0x90909090};
 3581|       |
 3582|      0|                        PHI_MSVC_SUPPRESS_WARNING_POP()
 3583|       |
 3584|      0|                        draw_list->AddLine(p1, p2, whitespace_color);
 3585|      0|                        draw_list->AddLine(p2, p3, whitespace_color);
 3586|      0|                        draw_list->AddLine(p2, p4, whitespace_color);
 3587|      0|                    }
 3588|    166|                }
 3589|    527|                else if (glyph.m_Char == ' ')
  ------------------
  |  Branch (3589:26): [True: 0, False: 527]
  ------------------
 3590|      0|                {
 3591|      0|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3591:25): [True: 0, False: 0]
  ------------------
 3592|      0|                    {
 3593|      0|                        const float s = ImGui::GetFontSize();
 3594|      0|                        const float x = text_screen_pos.x + buffer_offset.x + space_size * 0.5f;
 3595|      0|                        const float y = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3596|      0|                        draw_list->AddCircleFilled(ImVec2(x, y), 1.5f, 0x80808080, 4);
 3597|      0|                    }
 3598|      0|                    buffer_offset.x += space_size;
 3599|      0|                    i++;
 3600|      0|                }
 3601|    527|                else
 3602|    527|                {
 3603|  1.67k|                    for (phi::u8_fast length = UTF8CharLength(glyph.m_Char); length > 0u;
  ------------------
  |  Branch (3603:78): [True: 1.14k, False: 527]
  ------------------
 3604|  1.14k|                         ++i, --length)
 3605|  1.14k|                    {
 3606|  1.14k|                        m_LineBuffer.push_back(static_cast<char>(line[i.unsafe()].m_Char));
 3607|  1.14k|                    }
 3608|    527|                }
 3609|    693|                ++column_no;
 3610|    693|            }
 3611|    878|            if (!m_LineBuffer.empty())
  ------------------
  |  Branch (3611:17): [True: 166, False: 712]
  ------------------
 3612|    166|            {
 3613|    166|                const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3614|    166|                                        text_screen_pos.y + buffer_offset.y);
 3615|    166|                draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3616|    166|                m_LineBuffer.clear();
 3617|    166|            }
 3618|       |
 3619|    878|            ++line_no;
 3620|    878|        }
 3621|       |
 3622|       |        // Draw a tooltip on known identifiers/preprocessor symbols
 3623|    323|        if (ImGui::IsMousePosValid())
  ------------------
  |  Branch (3623:13): [True: 87, False: 236]
  ------------------
 3624|     87|        {
 3625|     87|            std::string id = GetWordAt(ScreenPosToCoordinates(ImGui::GetMousePos()));
 3626|     87|            if (!id.empty())
  ------------------
  |  Branch (3626:17): [True: 0, False: 87]
  ------------------
 3627|      0|            {
 3628|       |                /*
 3629|       |                    auto it = m_LanguageDefinition.mIdentifiers.find(id);
 3630|       |                    if (it != m_LanguageDefinition.mIdentifiers.end())
 3631|       |                    {
 3632|       |                        ImGui::BeginTooltip();
 3633|       |                        ImGui::TextUnformatted(it->second.m_Declaration.c_str());
 3634|       |                        ImGui::EndTooltip();
 3635|       |                    }
 3636|       |                    else
 3637|       |                    {
 3638|       |                        auto pi = m_LanguageDefinition.mPreprocIdentifiers.find(id);
 3639|       |                        if (pi != m_LanguageDefinition.mPreprocIdentifiers.end())
 3640|       |                        {
 3641|       |                            ImGui::BeginTooltip();
 3642|       |                            ImGui::TextUnformatted(pi->second.m_Declaration.c_str());
 3643|       |                            ImGui::EndTooltip();
 3644|       |                        }
 3645|       |                    }
 3646|       |                    */
 3647|      0|            }
 3648|     87|        }
 3649|       |
 3650|    323|        ImGui::Dummy(ImVec2((longest + 2), static_cast<float>(m_Lines.size()) * m_CharAdvance.y));
 3651|       |
 3652|    323|        if (m_ScrollToCursor)
  ------------------
  |  Branch (3652:13): [True: 91, False: 232]
  ------------------
 3653|     91|        {
 3654|     91|            ScrollToCursor();
 3655|     91|            ImGui::SetWindowFocus();
 3656|     91|            m_ScrollToCursor = false;
 3657|     91|        }
 3658|    323|    }
_ZN6dlxemu10CodeEditor13ColorizeTokenERKN3dlx5TokenE:
 3661|    673|    {
 3662|    673|        PaletteIndex palette_index{PaletteIndex::Default};
 3663|       |
 3664|       |        // Determine palette color
 3665|    673|        switch (token.GetType())
 3666|    673|        {
 3667|      4|            case dlx::Token::Type::Comment:
  ------------------
  |  Branch (3667:13): [True: 4, False: 669]
  ------------------
 3668|      4|                palette_index = PaletteIndex::Comment;
 3669|      4|                break;
 3670|      0|            case dlx::Token::Type::ImmediateInteger:
  ------------------
  |  Branch (3670:13): [True: 0, False: 673]
  ------------------
 3671|      8|            case dlx::Token::Type::IntegerLiteral:
  ------------------
  |  Branch (3671:13): [True: 8, False: 665]
  ------------------
 3672|      8|                palette_index = PaletteIndex::IntegerLiteral;
 3673|      8|                break;
 3674|      0|            case dlx::Token::Type::OpCode:
  ------------------
  |  Branch (3674:13): [True: 0, False: 673]
  ------------------
 3675|      0|                palette_index = PaletteIndex::OpCode;
 3676|      0|                break;
 3677|      0|            case dlx::Token::Type::RegisterFloat:
  ------------------
  |  Branch (3677:13): [True: 0, False: 673]
  ------------------
 3678|      0|            case dlx::Token::Type::RegisterInt:
  ------------------
  |  Branch (3678:13): [True: 0, False: 673]
  ------------------
 3679|      0|            case dlx::Token::Type::RegisterStatus:
  ------------------
  |  Branch (3679:13): [True: 0, False: 673]
  ------------------
 3680|      0|                palette_index = PaletteIndex::Register;
 3681|      0|                break;
 3682|    506|            case dlx::Token::Type::NewLine:
  ------------------
  |  Branch (3682:13): [True: 506, False: 167]
  ------------------
 3683|    506|                return;
 3684|    155|            default:
  ------------------
  |  Branch (3684:13): [True: 155, False: 518]
  ------------------
 3685|    155|                break;
 3686|    673|        }
 3687|       |
 3688|    167|        PHI_ASSERT(token.GetLineNumber() - 1u < m_Lines.size());
 3689|    167|        Line& line = m_Lines[(token.GetLineNumber() - 1u).unsafe()];
 3690|       |
 3691|    167|        for (phi::u64 index{token.GetColumn() - 1u};
 3692|    830|             index < token.GetColumn() + token.GetLength() - 1u; ++index)
  ------------------
  |  Branch (3692:14): [True: 663, False: 167]
  ------------------
 3693|    663|        {
 3694|    663|            PHI_ASSERT(index < line.size());
 3695|    663|            line[index.unsafe()].m_ColorIndex = palette_index;
 3696|    663|        }
 3697|    167|    }
_ZN6dlxemu10CodeEditor16ColorizeInternalEv:
 3700|     83|    {
 3701|     83|        const dlx::ParsedProgram& program = m_Emulator->GetProgram();
 3702|       |
 3703|     83|        for (const dlx::Token& token : program.m_Tokens)
  ------------------
  |  Branch (3703:38): [True: 673, False: 83]
  ------------------
 3704|    673|        {
 3705|    673|            ColorizeToken(token);
 3706|    673|        }
 3707|     83|    }
_ZN6dlxemu10CodeEditor10ResetStateEv:
 3710|  1.52k|    {
 3711|  1.52k|        m_State.m_CursorPosition = Coordinates(0u, 0u);
 3712|  1.52k|        m_State.m_SelectionStart = Coordinates(0u, 0u);
 3713|  1.52k|        m_State.m_SelectionEnd   = Coordinates(0u, 0u);
 3714|       |
 3715|       |        // Clear breakpoints and markers
 3716|  1.52k|        ClearBreakPoints();
 3717|  1.52k|        ClearErrorMarkers();
 3718|  1.52k|    }
_ZN6dlxemu10CodeEditor21FixSelectionAfterMoveEN3phi7booleanENS0_11CoordinatesE:
 3721|  11.2k|    {
 3722|  11.2k|        if (select)
  ------------------
  |  Branch (3722:13): [True: 4.57k, False: 6.69k]
  ------------------
 3723|  4.57k|        {
 3724|  4.57k|            if (old_pos == m_InteractiveStart)
  ------------------
  |  Branch (3724:17): [True: 1.15k, False: 3.42k]
  ------------------
 3725|  1.15k|            {
 3726|  1.15k|                m_InteractiveStart = m_State.m_CursorPosition;
 3727|  1.15k|            }
 3728|  3.42k|            else if (old_pos == m_InteractiveEnd)
  ------------------
  |  Branch (3728:22): [True: 183, False: 3.23k]
  ------------------
 3729|    183|            {
 3730|    183|                m_InteractiveEnd = m_State.m_CursorPosition;
 3731|    183|            }
 3732|  3.23k|            else
 3733|  3.23k|            {
 3734|  3.23k|                m_InteractiveStart = m_State.m_CursorPosition;
 3735|  3.23k|                m_InteractiveEnd   = old_pos;
 3736|  3.23k|            }
 3737|  4.57k|        }
 3738|  6.69k|        else
 3739|  6.69k|        {
 3740|  6.69k|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
 3741|  6.69k|        }
 3742|       |
 3743|  11.2k|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
 3744|  11.2k|        EnsureCursorVisible();
 3745|  11.2k|    }
_ZNK6dlxemu10CodeEditor12GetTabSizeAtEN3phi7integerIjEE:
 3748|  5.11M|    {
 3749|  5.11M|        return static_cast<phi::uint_fast8_t>(m_TabSize.unsafe() -
 3750|  5.11M|                                              (column.unsafe() % m_TabSize.unsafe()));
 3751|  5.11M|    }
_ZNK6dlxemu10CodeEditor18GetPaletteForIndexENS0_12PaletteIndexE:
 3754|  93.6k|    {
 3755|  93.6k|        PHI_ASSERT(index != PaletteIndex::Max);
 3756|       |
 3757|  93.6k|        const phi::size_t int_value = static_cast<phi::size_t>(index);
 3758|  93.6k|        PHI_ASSERT(int_value < m_Palette.size());
 3759|       |
 3760|  93.6k|        return m_Palette[int_value];
 3761|  93.6k|    }
_ZN6dlxemu10CodeEditor18ComputeCharAdvanceEv:
 3764|    323|    {
 3765|       |        // Compute m_CharAdvance regarding to scaled font size (Ctrl + mouse wheel)
 3766|    323|        const float font_size =
 3767|    323|                ImGui::GetFont()
 3768|    323|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#", nullptr, nullptr)
 3769|    323|                        .x;
 3770|    323|        m_CharAdvance = ImVec2(font_size, ImGui::GetTextLineHeightWithSpacing() * m_LineSpacing);
 3771|       |
 3772|    323|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 3773|    323|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3774|    323|    }
CodeEditor.cpp:_ZL19IsValidUTF8SequenceN3phi7integerIjEE:
  187|  61.8k|{
  188|  61.8k|    return !(character >= 0xdc00u && character < 0xe000u);
  ------------------
  |  Branch (188:14): [True: 5.34k, False: 56.4k]
  |  Branch (188:38): [True: 0, False: 5.34k]
  ------------------
  189|  61.8k|}
CodeEditor.cpp:_ZL13IsUTFSequenceh:
   96|   221k|{
   97|   221k|    return IsUTFSequence(static_cast<char>(character));
   98|   221k|}
CodeEditor.cpp:_ZL13IsUTFSequencec:
   91|   221k|{
   92|   221k|    return (character & 0xC0) == 0x80;
   93|   221k|}
CodeEditor.cpp:_ZL14UTF8CharLengthh:
  135|  1.10G|{
  136|  1.10G|    return UTF8CharLength(static_cast<char>(characater));
  137|  1.10G|}
CodeEditor.cpp:_ZL14UTF8CharLengthc:
  105|  2.65G|{
  106|  2.65G|    if ((characater & 0xFE) == 0xFC)
  ------------------
  |  Branch (106:9): [True: 0, False: 2.65G]
  ------------------
  107|      0|    {
  108|      0|        return 6_u8;
  109|      0|    }
  110|       |
  111|  2.65G|    if ((characater & 0xFC) == 0xF8)
  ------------------
  |  Branch (111:9): [True: 0, False: 2.65G]
  ------------------
  112|      0|    {
  113|      0|        return 5_u8;
  114|      0|    }
  115|       |
  116|  2.65G|    if ((characater & 0xF8) == 0xF0)
  ------------------
  |  Branch (116:9): [True: 14.8M, False: 2.64G]
  ------------------
  117|  14.8M|    {
  118|  14.8M|        return 4_u8;
  119|  14.8M|    }
  120|       |
  121|  2.64G|    if ((characater & 0xF0) == 0xE0)
  ------------------
  |  Branch (121:9): [True: 884M, False: 1.75G]
  ------------------
  122|   884M|    {
  123|   884M|        return 3_u8;
  124|   884M|    }
  125|       |
  126|  1.75G|    if ((characater & 0xE0) == 0xC0)
  ------------------
  |  Branch (126:9): [True: 85.1M, False: 1.67G]
  ------------------
  127|  85.1M|    {
  128|  85.1M|        return 2_u8;
  129|  85.1M|    }
  130|       |
  131|  1.67G|    return 1_u8;
  132|  1.75G|}
CodeEditor.cpp:_ZL16ImTextCharToUtf8RN3phi5arrayIcLm5EEENS_7integerIjEE:
  142|  15.4k|{
  143|  15.4k|    if (character < 0x80u)
  ------------------
  |  Branch (143:9): [True: 9.06k, False: 6.41k]
  ------------------
  144|  9.06k|    {
  145|  9.06k|        buffer[0u] = static_cast<char>(character.unsafe());
  146|  9.06k|        buffer[1u] = '\0';
  147|  9.06k|        return 1_u8;
  148|  9.06k|    }
  149|  6.41k|    if (character < 0x800u)
  ------------------
  |  Branch (149:9): [True: 595, False: 5.82k]
  ------------------
  150|    595|    {
  151|    595|        buffer[0u] = static_cast<char>(0xc0 + (character.unsafe() >> 6));
  152|    595|        buffer[1u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  153|    595|        buffer[2u] = '\0';
  154|       |
  155|    595|        return 2_u8;
  156|    595|    }
  157|  5.82k|    if (character >= 0xdc00u && character < 0xe000u)
  ------------------
  |  Branch (157:9): [True: 2.67k, False: 3.14k]
  |  Branch (157:9): [True: 0, False: 5.82k]
  |  Branch (157:33): [True: 0, False: 2.67k]
  ------------------
  158|      0|    {
  159|      0|        buffer[0u] = '\0';
  160|      0|        return 0_u8;
  161|      0|    }
  162|       |
  163|  5.82k|    if (character >= 0xd800u && character < 0xdc00u)
  ------------------
  |  Branch (163:9): [True: 2.99k, False: 2.82k]
  |  Branch (163:9): [True: 322, False: 5.49k]
  |  Branch (163:33): [True: 322, False: 2.67k]
  ------------------
  164|    322|    {
  165|    322|        buffer[0u] = static_cast<char>(0xf0 + (character.unsafe() >> 18));
  166|    322|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 12) & 0x3f));
  167|    322|        buffer[2u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  168|    322|        buffer[3u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  169|    322|        buffer[4u] = '\0';
  170|       |
  171|    322|        return 4_u8;
  172|    322|    }
  173|       |    //else if (character < 0x10000)
  174|  5.49k|    {
  175|  5.49k|        PHI_ASSERT(character.unsafe() < 0x10000);
  176|       |
  177|  5.49k|        buffer[0u] = static_cast<char>(0xe0 + (character.unsafe() >> 12));
  178|  5.49k|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  179|  5.49k|        buffer[2u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  180|  5.49k|        buffer[3u] = '\0';
  181|       |
  182|  5.49k|        return 3_u8;
  183|  5.82k|    }
  184|  5.82k|}

_ZN6dlxemu8EmulatorC2Ev:
   42|  9.34k|    {}
_ZNK6dlxemu8Emulator10GetProgramEv:
  178|     83|    {
  179|     83|        return m_DLXProgram;
  180|     83|    }
_ZN6dlxemu8Emulator12ParseProgramEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  183|     83|    {
  184|     83|        m_DLXProgram = dlx::Parser::Parse(source);
  185|       |
  186|     83|        if (m_DLXProgram.m_ParseErrors.empty())
  ------------------
  |  Branch (186:13): [True: 21, False: 62]
  ------------------
  187|     21|        {
  188|     21|            m_Processor.LoadProgram(m_DLXProgram);
  189|     21|        }
  190|     83|    }
_ZNK6dlxemu8Emulator22GetExecutingLineNumberEv:
  222|    878|    {
  223|    878|        if (m_DLXProgram.IsValid() && !m_Processor.IsHalted() &&
  ------------------
  |  Branch (223:13): [True: 0, False: 878]
  |  Branch (223:13): [True: 0, False: 878]
  |  Branch (223:39): [True: 0, False: 0]
  ------------------
  224|    878|            m_CurrentExecutionMode != ExecutionMode::None)
  ------------------
  |  Branch (224:13): [True: 0, False: 0]
  ------------------
  225|      0|        {
  226|      0|            PHI_ASSERT(m_Processor.GetProgramCounter() < m_DLXProgram.m_Instructions.size());
  227|       |
  228|      0|            const auto& current_instruction =
  229|      0|                    m_DLXProgram.m_Instructions.at(m_Processor.GetProgramCounter().unsafe());
  230|       |
  231|      0|            return current_instruction.GetSourceLine();
  232|      0|        }
  233|       |
  234|       |        // Not valid
  235|    878|        return 0u;
  236|    878|    }

_ZN6dlxemu12MemoryViewerC2EPNS_8EmulatorE:
   13|  9.34k|    {}

_ZN6dlxemu14RegisterViewerC2EPNS_8EmulatorE:
   19|  9.34k|    {}

_ZN6dlxemu6WindowD2Ev:
   38|  9.34k|    {
   39|  9.34k|        Shutdown();
   40|  9.34k|    }
_ZN6dlxemu6Window8ShutdownEv:
  108|  9.34k|    {
  109|  9.34k|        if (imgui_initialized)
  ------------------
  |  Branch (109:13): [True: 0, False: 9.34k]
  ------------------
  110|      0|        {
  111|      0|            ShutdownImGui();
  112|      0|        }
  113|       |
  114|  9.34k|        if (m_Window != nullptr)
  ------------------
  |  Branch (114:13): [True: 0, False: 9.34k]
  ------------------
  115|      0|        {
  116|      0|            glfwDestroyWindow(m_Window);
  117|      0|        }
  118|       |
  119|  9.34k|        if (glfw_initialized)
  ------------------
  |  Branch (119:13): [True: 0, False: 9.34k]
  ------------------
  120|      0|        {
  121|      0|            glfwTerminate();
  122|      0|        }
  123|  9.34k|    }

_ZN3dlx11MemoryBlock10MemoryByteC2Ev:
   17|  9.34M|            {}

_ZN3dlx20IsReservedIdentifierEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   30|     41|    {
   31|     41|        if (StringToIntRegister(token) != IntRegisterID::None)
  ------------------
  |  Branch (31:13): [True: 0, False: 41]
  ------------------
   32|      0|        {
   33|      0|            return true;
   34|      0|        }
   35|       |
   36|     41|        if (StringToFloatRegister(token) != FloatRegisterID::None)
  ------------------
  |  Branch (36:13): [True: 0, False: 41]
  ------------------
   37|      0|        {
   38|      0|            return true;
   39|      0|        }
   40|       |
   41|     41|        if (StringToOpCode(token) != OpCode::NONE)
  ------------------
  |  Branch (41:13): [True: 0, False: 41]
  ------------------
   42|      0|        {
   43|      0|            return true;
   44|      0|        }
   45|       |
   46|     41|        if (IsFPSR(token))
  ------------------
  |  Branch (46:13): [True: 0, False: 41]
  ------------------
   47|      0|        {
   48|      0|            return true;
   49|      0|        }
   50|       |
   51|     41|        return false;
   52|     41|    }
_ZN3dlx17IsValidIdentifierEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   55|     41|    {
   56|     41|        if (token.is_empty())
  ------------------
  |  Branch (56:13): [True: 0, False: 41]
  ------------------
   57|      0|        {
   58|      0|            return false;
   59|      0|        }
   60|       |
   61|     41|        const char first_char = token.at(0u);
   62|       |
   63|     41|        if (token.length() == 1u)
  ------------------
  |  Branch (63:13): [True: 1, False: 40]
  ------------------
   64|      1|        {
   65|      1|            return phi::is_alpha(first_char);
   66|      1|        }
   67|       |
   68|     40|        phi::boolean just_under_scores = (first_char == '_');
   69|     40|        if (!phi::is_alpha(first_char) && (first_char != '_'))
  ------------------
  |  Branch (69:13): [True: 34, False: 6]
  |  Branch (69:13): [True: 34, False: 6]
  |  Branch (69:43): [True: 34, False: 0]
  ------------------
   70|     34|        {
   71|     34|            return false;
   72|     34|        }
   73|       |
   74|     20|        for (std::size_t index{1u}; index < token.length(); ++index)
  ------------------
  |  Branch (74:37): [True: 14, False: 6]
  ------------------
   75|     14|        {
   76|     14|            const char c{token.at(index)};
   77|       |
   78|     14|            if (phi::is_alpha_numeric(c))
  ------------------
  |  Branch (78:17): [True: 14, False: 0]
  ------------------
   79|     14|            {
   80|     14|                just_under_scores = false;
   81|     14|            }
   82|      0|            else if (c == '_')
  ------------------
  |  Branch (82:22): [True: 0, False: 0]
  ------------------
   83|      0|            {
   84|      0|                continue;
   85|      0|            }
   86|      0|            else
   87|      0|            {
   88|      0|                return false;
   89|      0|            }
   90|     14|        }
   91|       |
   92|      6|        return !just_under_scores;
   93|      6|    }
_ZN3dlx11ParseNumberEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   99|    147|    {
  100|    147|        if (token.is_empty())
  ------------------
  |  Branch (100:13): [True: 0, False: 147]
  ------------------
  101|      0|        {
  102|      0|            return {};
  103|      0|        }
  104|       |
  105|    147|        if (token.length() == 1u)
  ------------------
  |  Branch (105:13): [True: 15, False: 132]
  ------------------
  106|     15|        {
  107|     15|            if (phi::is_digit(token.at(0u)))
  ------------------
  |  Branch (107:17): [True: 8, False: 7]
  ------------------
  108|      8|            {
  109|      8|                return static_cast<std::int16_t>(token.at(0u) - '0');
  110|      8|            }
  111|       |
  112|      7|            return {};
  113|     15|        }
  114|       |
  115|       |        // Disallow trailing seperators
  116|    132|        if (token.at(token.length() - 1u) == '\'')
  ------------------
  |  Branch (116:13): [True: 0, False: 132]
  ------------------
  117|      0|        {
  118|      0|            return {};
  119|      0|        }
  120|       |
  121|    132|        std::int32_t number{0};
  122|    132|        phi::boolean is_negative{false};
  123|    132|        phi::boolean starts_with_zero{false};
  124|    132|        phi::boolean parsing_binary{false};
  125|    132|        phi::boolean parsing_octal{false};
  126|    132|        phi::boolean parsing_hexadecimal{false};
  127|    132|        phi::boolean parsed_something{false};
  128|    132|        phi::boolean parsed_separator{false};
  129|       |
  130|       |        // TODO: Move x'th character checks out of the for loop
  131|       |
  132|    133|        for (std::size_t index{0u}; index < token.length(); ++index)
  ------------------
  |  Branch (132:37): [True: 133, False: 0]
  ------------------
  133|    133|        {
  134|    133|            const char c{token.at(index)};
  135|       |
  136|       |            // First character
  137|    133|            if (index == 0u)
  ------------------
  |  Branch (137:17): [True: 132, False: 1]
  ------------------
  138|    132|            {
  139|    132|                if (c == '+')
  ------------------
  |  Branch (139:21): [True: 0, False: 132]
  ------------------
  140|      0|                {
  141|      0|                    continue;
  142|      0|                }
  143|       |
  144|    132|                if (c == '-')
  ------------------
  |  Branch (144:21): [True: 1, False: 131]
  ------------------
  145|      1|                {
  146|      1|                    is_negative = true;
  147|      1|                    continue;
  148|      1|                }
  149|       |
  150|    131|                if (c == '0')
  ------------------
  |  Branch (150:21): [True: 0, False: 131]
  ------------------
  151|      0|                {
  152|      0|                    starts_with_zero = true;
  153|      0|                    continue;
  154|      0|                }
  155|       |
  156|    131|                if (c == '\'')
  ------------------
  |  Branch (156:21): [True: 0, False: 131]
  ------------------
  157|      0|                {
  158|      0|                    return {};
  159|      0|                }
  160|    131|            }
  161|       |
  162|       |            // Second character
  163|    132|            if (index == 1u)
  ------------------
  |  Branch (163:17): [True: 1, False: 131]
  ------------------
  164|      1|            {
  165|      1|                if (starts_with_zero)
  ------------------
  |  Branch (165:21): [True: 0, False: 1]
  ------------------
  166|      0|                {
  167|       |                    // Binary
  168|      0|                    if (c == 'b' || c == 'B')
  ------------------
  |  Branch (168:25): [True: 0, False: 0]
  |  Branch (168:37): [True: 0, False: 0]
  ------------------
  169|      0|                    {
  170|      0|                        parsing_binary = true;
  171|      0|                        continue;
  172|      0|                    }
  173|       |
  174|       |                    // Hexadecimal
  175|      0|                    if (c == 'x' || c == 'X')
  ------------------
  |  Branch (175:25): [True: 0, False: 0]
  |  Branch (175:37): [True: 0, False: 0]
  ------------------
  176|      0|                    {
  177|      0|                        parsing_hexadecimal = true;
  178|      0|                        continue;
  179|      0|                    }
  180|       |
  181|       |                    // Octal
  182|      0|                    parsing_octal = true;
  183|      0|                }
  184|      1|            }
  185|       |
  186|       |            // Handle seperators
  187|    132|            if (c == '\'')
  ------------------
  |  Branch (187:17): [True: 0, False: 132]
  ------------------
  188|      0|            {
  189|      0|                if (parsed_separator)
  ------------------
  |  Branch (189:21): [True: 0, False: 0]
  ------------------
  190|      0|                {
  191|      0|                    return {};
  192|      0|                }
  193|       |
  194|      0|                parsed_separator = true;
  195|      0|                continue;
  196|      0|            }
  197|       |
  198|       |            // Check for over/underflow
  199|    132|            if (is_negative && (-number < std::numeric_limits<std::int16_t>::min()))
  ------------------
  |  Branch (199:17): [True: 1, False: 131]
  |  Branch (199:32): [True: 0, False: 1]
  ------------------
  200|      0|            {
  201|       |                // Would underflow
  202|      0|                return {};
  203|      0|            }
  204|    132|            if (!is_negative && (number > std::numeric_limits<std::int16_t>::max()))
  ------------------
  |  Branch (204:17): [True: 131, False: 1]
  |  Branch (204:17): [True: 0, False: 132]
  |  Branch (204:33): [True: 0, False: 131]
  ------------------
  205|      0|            {
  206|       |                // Would overflow
  207|      0|                return {};
  208|      0|            }
  209|       |
  210|    132|            parsed_separator = false;
  211|    132|            parsed_something = true;
  212|       |
  213|    132|            if (parsing_binary)
  ------------------
  |  Branch (213:17): [True: 0, False: 132]
  ------------------
  214|      0|            {
  215|      0|                if (!phi::is_binary_digit(c))
  ------------------
  |  Branch (215:21): [True: 0, False: 0]
  ------------------
  216|      0|                {
  217|      0|                    return {};
  218|      0|                }
  219|       |
  220|      0|                number <<= 1;
  221|      0|                number |= (c - '0');
  222|      0|            }
  223|    132|            else if (parsing_octal)
  ------------------
  |  Branch (223:22): [True: 0, False: 132]
  ------------------
  224|      0|            {
  225|      0|                if (!phi::is_octal_digit(c))
  ------------------
  |  Branch (225:21): [True: 0, False: 0]
  ------------------
  226|      0|                {
  227|      0|                    return {};
  228|      0|                }
  229|       |
  230|      0|                number <<= 3;
  231|      0|                number |= (c - '0');
  232|      0|            }
  233|    132|            else if (parsing_hexadecimal)
  ------------------
  |  Branch (233:22): [True: 0, False: 132]
  ------------------
  234|      0|            {
  235|      0|                if (!phi::is_hex_digit(c))
  ------------------
  |  Branch (235:21): [True: 0, False: 0]
  ------------------
  236|      0|                {
  237|      0|                    return {};
  238|      0|                }
  239|       |
  240|      0|                number <<= 4;
  241|      0|                number |= phi::hex_digit_value(c).unsafe();
  242|      0|            }
  243|    132|            else
  244|    132|            {
  245|    132|                if (!phi::is_digit(c))
  ------------------
  |  Branch (245:21): [True: 132, False: 0]
  ------------------
  246|    132|                {
  247|    132|                    return {};
  248|    132|                }
  249|       |
  250|       |                // Disallow leading zeros
  251|      0|                if (number == 0 && c == '0')
  ------------------
  |  Branch (251:21): [True: 0, False: 0]
  |  Branch (251:36): [True: 0, False: 0]
  ------------------
  252|      0|                {
  253|      0|                    return {};
  254|      0|                }
  255|       |
  256|      0|                number *= 10;
  257|      0|                number += (c - '0');
  258|      0|            }
  259|    132|        }
  260|       |
  261|      0|        if (parsed_something)
  ------------------
  |  Branch (261:13): [True: 0, False: 0]
  ------------------
  262|      0|        {
  263|       |            // Check for over/underflow
  264|      0|            if (is_negative && (-number < std::numeric_limits<std::int16_t>::min()))
  ------------------
  |  Branch (264:17): [True: 0, False: 0]
  |  Branch (264:32): [True: 0, False: 0]
  ------------------
  265|      0|            {
  266|       |                // Would underflow
  267|      0|                return {};
  268|      0|            }
  269|      0|            if (!is_negative && (number > std::numeric_limits<std::int16_t>::max()))
  ------------------
  |  Branch (269:17): [True: 0, False: 0]
  |  Branch (269:17): [True: 0, False: 0]
  |  Branch (269:33): [True: 0, False: 0]
  ------------------
  270|      0|            {
  271|       |                // Would overflow
  272|      0|                return {};
  273|      0|            }
  274|       |
  275|      0|            if (is_negative)
  ------------------
  |  Branch (275:17): [True: 0, False: 0]
  ------------------
  276|      0|            {
  277|      0|                return static_cast<std::int16_t>(-number);
  278|      0|            }
  279|       |
  280|      0|            return static_cast<std::int16_t>(number);
  281|      0|        }
  282|       |
  283|      0|        return {};
  284|      0|    }

_ZN3dlx9enum_nameINS_5Token4TypeEEEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEET_:
   85|     48|    {
   86|     48|        switch (value)
   87|     48|        {
   88|      0|#define DLX_ENUM_TOKEN_TYPE_IMPL(name)                                                             \
   89|      0|    case Token::Type::name:                                                                        \
   90|      0|        return #name;
   91|       |
   92|      0|            DLX_ENUM_TOKEN_TYPE
  ------------------
  |  |   13|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(Comment)                                                              \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   14|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(OpCode)                                                               \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   15|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(LabelIdentifier)                                                      \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   16|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterInt)                                                          \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   17|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterFloat)                                                        \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   18|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterStatus)                                                       \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   19|      8|    DLX_ENUM_TOKEN_TYPE_IMPL(Comma)                                                                \
  |  |  ------------------
  |  |  |  |   89|      8|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 8, False: 40]
  |  |  |  |  ------------------
  |  |  |  |   90|      8|        return #name;
  |  |  ------------------
  |  |   20|      8|    DLX_ENUM_TOKEN_TYPE_IMPL(Colon)                                                                \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   21|      8|    DLX_ENUM_TOKEN_TYPE_IMPL(OpenBracket)                                                          \
  |  |  ------------------
  |  |  |  |   89|      8|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 8, False: 40]
  |  |  |  |  ------------------
  |  |  |  |   90|      8|        return #name;
  |  |  ------------------
  |  |   22|      8|    DLX_ENUM_TOKEN_TYPE_IMPL(ClosingBracket)                                                       \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   23|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(NewLine)                                                              \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   24|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(ImmediateInteger)                                                     \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   25|      8|    DLX_ENUM_TOKEN_TYPE_IMPL(IntegerLiteral)                                                       \
  |  |  ------------------
  |  |  |  |   89|      8|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 8, False: 40]
  |  |  |  |  ------------------
  |  |  |  |   90|      8|        return #name;
  |  |  ------------------
  |  |   26|     24|    DLX_ENUM_TOKEN_TYPE_IMPL(Unknown)
  |  |  ------------------
  |  |  |  |   89|     24|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 24, False: 24]
  |  |  |  |  ------------------
  |  |  |  |   90|     24|        return #name;
  |  |  ------------------
  ------------------
   93|       |
   94|      0|#undef DLX_ENUM_TOKEN_TYPE_IMPL
   95|       |
   96|      0|            default:
  ------------------
  |  Branch (96:13): [True: 0, False: 48]
  ------------------
   97|      0|                PHI_ASSERT_NOT_REACHED();
   98|     48|        }
   99|     48|    }

Parser.cpp:_ZNK3dlx11TokenStream19find_first_token_ifIZNS_6Parser5ParseERS0_E3$_0EEPKNS_5TokenET_:
   58|      2|        {
   59|       |#if defined(PHI_DEBUG)
   60|       |            PHI_ASSERT(m_Finialized);
   61|       |#endif
   62|       |
   63|      2|            for (const Token& token : m_Tokens)
  ------------------
  |  Branch (63:37): [True: 6, False: 0]
  ------------------
   64|      6|            {
   65|      6|                if (pred(token))
  ------------------
  |  Branch (65:21): [True: 2, False: 4]
  ------------------
   66|      2|                {
   67|      2|                    return &token;
   68|      2|                }
   69|      6|            }
   70|       |
   71|      0|            return nullptr;
   72|      2|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5Token4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEERNS4_7integerImEESC_EEEvDpOT_:
   24|    506|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finialized);
   27|       |#endif
   28|       |
   29|    506|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|    506|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5TokenEEEEvDpOT_:
   24|    151|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finialized);
   27|       |#endif
   28|       |
   29|    151|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|    151|        }
_ZN3dlx11TokenStream12emplace_backIJRNS_5Token4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEERNS5_7integerImEESD_EEEvDpOT_:
   24|     16|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finialized);
   27|       |#endif
   28|       |
   29|     16|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|     16|        }

_ZN3dlx11IntRegisterC2Ev:
   13|   298k|    {}
_ZN3dlx11IntRegister11SetReadOnlyEN3phi7booleanE:
   41|  9.34k|    {
   42|  9.34k|        m_IsReadOnly = read_only;
   43|  9.34k|    }

_ZN3dlx11MemoryBlockC2EN3phi7integerImEES3_:
   16|  9.34k|    {
   17|  9.34k|        m_Values.resize(starting_size.unsafe());
   18|  9.34k|    }

_ZN3dlx14StringToOpCodeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   23|    180|    {
   24|    180|        switch (token.length().unsafe())
   25|    180|        {
   26|       |            // 1 character OpCodes
   27|      8|            case 1: {
  ------------------
  |  Branch (27:13): [True: 8, False: 172]
  ------------------
   28|      8|                const char c1 = token[0u];
   29|       |
   30|      8|                if (ice(c1, 'J'))
  ------------------
  |  Branch (30:21): [True: 0, False: 8]
  ------------------
   31|      0|                {
   32|      0|                    return OpCode::J;
   33|      0|                }
   34|      8|                break;
   35|      8|            }
   36|       |
   37|       |            // 2 character OpCodes
   38|      8|            case 2: {
  ------------------
  |  Branch (38:13): [True: 4, False: 176]
  ------------------
   39|      4|                const char c1 = token[0u];
   40|      4|                const char c2 = token[1u];
   41|       |
   42|      4|                switch (c1)
  ------------------
  |  Branch (42:25): [True: 4, False: 0]
  ------------------
   43|      4|                {
   44|      0|                    case 'J':
  ------------------
  |  Branch (44:21): [True: 0, False: 4]
  ------------------
   45|      0|                    case 'j':
  ------------------
  |  Branch (45:21): [True: 0, False: 4]
  ------------------
   46|      0|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (46:29): [True: 0, False: 0]
  ------------------
   47|      0|                        {
   48|      0|                            return OpCode::JR;
   49|      0|                        }
   50|      0|                        break;
   51|       |
   52|      0|                    case 'L':
  ------------------
  |  Branch (52:21): [True: 0, False: 4]
  ------------------
   53|      0|                    case 'l':
  ------------------
  |  Branch (53:21): [True: 0, False: 4]
  ------------------
   54|      0|                        switch (c2)
  ------------------
  |  Branch (54:33): [True: 0, False: 0]
  ------------------
   55|      0|                        {
   56|      0|                            case 'B':
  ------------------
  |  Branch (56:29): [True: 0, False: 0]
  ------------------
   57|      0|                            case 'b':
  ------------------
  |  Branch (57:29): [True: 0, False: 0]
  ------------------
   58|      0|                                return OpCode::LB;
   59|      0|                            case 'D':
  ------------------
  |  Branch (59:29): [True: 0, False: 0]
  ------------------
   60|      0|                            case 'd':
  ------------------
  |  Branch (60:29): [True: 0, False: 0]
  ------------------
   61|      0|                                return OpCode::LD;
   62|      0|                            case 'F':
  ------------------
  |  Branch (62:29): [True: 0, False: 0]
  ------------------
   63|      0|                            case 'f':
  ------------------
  |  Branch (63:29): [True: 0, False: 0]
  ------------------
   64|      0|                                return OpCode::LF;
   65|      0|                            case 'H':
  ------------------
  |  Branch (65:29): [True: 0, False: 0]
  ------------------
   66|      0|                            case 'h':
  ------------------
  |  Branch (66:29): [True: 0, False: 0]
  ------------------
   67|      0|                                return OpCode::LH;
   68|      0|                            case 'W':
  ------------------
  |  Branch (68:29): [True: 0, False: 0]
  ------------------
   69|      0|                            case 'w':
  ------------------
  |  Branch (69:29): [True: 0, False: 0]
  ------------------
   70|      0|                                return OpCode::LW;
   71|      0|                        }
   72|      0|                        break;
   73|      0|                    case 'O':
  ------------------
  |  Branch (73:21): [True: 0, False: 4]
  ------------------
   74|      0|                    case 'o':
  ------------------
  |  Branch (74:21): [True: 0, False: 4]
  ------------------
   75|      0|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (75:29): [True: 0, False: 0]
  ------------------
   76|      0|                        {
   77|      0|                            return OpCode::OR;
   78|      0|                        }
   79|      0|                        break;
   80|      0|                    case 'S':
  ------------------
  |  Branch (80:21): [True: 0, False: 4]
  ------------------
   81|      0|                    case 's':
  ------------------
  |  Branch (81:21): [True: 0, False: 4]
  ------------------
   82|      0|                        switch (c2)
  ------------------
  |  Branch (82:33): [True: 0, False: 0]
  ------------------
   83|      0|                        {
   84|      0|                            case 'B':
  ------------------
  |  Branch (84:29): [True: 0, False: 0]
  ------------------
   85|      0|                            case 'b':
  ------------------
  |  Branch (85:29): [True: 0, False: 0]
  ------------------
   86|      0|                                return OpCode::SB;
   87|      0|                            case 'D':
  ------------------
  |  Branch (87:29): [True: 0, False: 0]
  ------------------
   88|      0|                            case 'd':
  ------------------
  |  Branch (88:29): [True: 0, False: 0]
  ------------------
   89|      0|                                return OpCode::SD;
   90|      0|                            case 'F':
  ------------------
  |  Branch (90:29): [True: 0, False: 0]
  ------------------
   91|      0|                            case 'f':
  ------------------
  |  Branch (91:29): [True: 0, False: 0]
  ------------------
   92|      0|                                return OpCode::SF;
   93|      0|                            case 'H':
  ------------------
  |  Branch (93:29): [True: 0, False: 0]
  ------------------
   94|      0|                            case 'h':
  ------------------
  |  Branch (94:29): [True: 0, False: 0]
  ------------------
   95|      0|                                return OpCode::SH;
   96|      0|                            case 'w':
  ------------------
  |  Branch (96:29): [True: 0, False: 0]
  ------------------
   97|      0|                            case 'W':
  ------------------
  |  Branch (97:29): [True: 0, False: 0]
  ------------------
   98|      0|                                return OpCode::SW;
   99|      0|                        }
  100|      0|                        break;
  101|      4|                }
  102|      4|                break;
  103|      4|            }
  104|       |
  105|       |            // 3 character OpCodes
  106|     89|            case 3: {
  ------------------
  |  Branch (106:13): [True: 89, False: 91]
  ------------------
  107|     89|                const char c1 = token[0u];
  108|     89|                const char c2 = token[1u];
  109|     89|                const char c3 = token[2u];
  110|       |
  111|     89|                switch (c1)
  ------------------
  |  Branch (111:25): [True: 89, False: 0]
  ------------------
  112|     89|                {
  113|      0|                    case 'A':
  ------------------
  |  Branch (113:21): [True: 0, False: 89]
  ------------------
  114|      0|                    case 'a':
  ------------------
  |  Branch (114:21): [True: 0, False: 89]
  ------------------
  115|      0|                        if (ice(c2, 'D') && ice(c3, 'D'))
  ------------------
  |  Branch (115:29): [True: 0, False: 0]
  |  Branch (115:29): [True: 0, False: 0]
  |  Branch (115:45): [True: 0, False: 0]
  ------------------
  116|      0|                        {
  117|      0|                            return OpCode::ADD;
  118|      0|                        }
  119|      0|                        else if (ice(c2, 'N') && ice(c3, 'D'))
  ------------------
  |  Branch (119:34): [True: 0, False: 0]
  |  Branch (119:34): [True: 0, False: 0]
  |  Branch (119:50): [True: 0, False: 0]
  ------------------
  120|      0|                        {
  121|      0|                            return OpCode::AND;
  122|      0|                        }
  123|      0|                        break;
  124|       |
  125|      0|                    case 'D':
  ------------------
  |  Branch (125:21): [True: 0, False: 89]
  ------------------
  126|      0|                    case 'd':
  ------------------
  |  Branch (126:21): [True: 0, False: 89]
  ------------------
  127|      0|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (127:29): [True: 0, False: 0]
  |  Branch (127:29): [True: 0, False: 0]
  |  Branch (127:45): [True: 0, False: 0]
  ------------------
  128|      0|                        {
  129|      0|                            return OpCode::DIV;
  130|      0|                        }
  131|      0|                        break;
  132|       |
  133|      0|                    case 'E':
  ------------------
  |  Branch (133:21): [True: 0, False: 89]
  ------------------
  134|      0|                    case 'e':
  ------------------
  |  Branch (134:21): [True: 0, False: 89]
  ------------------
  135|      0|                        if (ice(c2, 'Q'))
  ------------------
  |  Branch (135:29): [True: 0, False: 0]
  ------------------
  136|      0|                        {
  137|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (137:33): [True: 0, False: 0]
  ------------------
  138|      0|                            {
  139|      0|                                return OpCode::EQD;
  140|      0|                            }
  141|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (141:38): [True: 0, False: 0]
  ------------------
  142|      0|                            {
  143|      0|                                return OpCode::EQF;
  144|      0|                            }
  145|      0|                        }
  146|      0|                        break;
  147|       |
  148|      0|                    case 'G':
  ------------------
  |  Branch (148:21): [True: 0, False: 89]
  ------------------
  149|      0|                    case 'g':
  ------------------
  |  Branch (149:21): [True: 0, False: 89]
  ------------------
  150|      0|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (150:29): [True: 0, False: 0]
  ------------------
  151|      0|                        {
  152|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (152:33): [True: 0, False: 0]
  ------------------
  153|      0|                            {
  154|      0|                                return OpCode::GED;
  155|      0|                            }
  156|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (156:38): [True: 0, False: 0]
  ------------------
  157|      0|                            {
  158|      0|                                return OpCode::GEF;
  159|      0|                            }
  160|      0|                        }
  161|      0|                        else if (ice(c2, 'T'))
  ------------------
  |  Branch (161:34): [True: 0, False: 0]
  ------------------
  162|      0|                        {
  163|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (163:33): [True: 0, False: 0]
  ------------------
  164|      0|                            {
  165|      0|                                return OpCode::GTD;
  166|      0|                            }
  167|      0|                            if (ice(c3, 'F'))
  ------------------
  |  Branch (167:33): [True: 0, False: 0]
  ------------------
  168|      0|                            {
  169|      0|                                return OpCode::GTF;
  170|      0|                            }
  171|      0|                        }
  172|      0|                        break;
  173|       |
  174|      0|                    case 'J':
  ------------------
  |  Branch (174:21): [True: 0, False: 89]
  ------------------
  175|      0|                    case 'j':
  ------------------
  |  Branch (175:21): [True: 0, False: 89]
  ------------------
  176|      0|                        if (ice(c2, 'A') && ice(c3, 'L'))
  ------------------
  |  Branch (176:29): [True: 0, False: 0]
  |  Branch (176:29): [True: 0, False: 0]
  |  Branch (176:45): [True: 0, False: 0]
  ------------------
  177|      0|                        {
  178|      0|                            return OpCode::JAL;
  179|      0|                        }
  180|      0|                        break;
  181|       |
  182|      0|                    case 'L':
  ------------------
  |  Branch (182:21): [True: 0, False: 89]
  ------------------
  183|      0|                    case 'l':
  ------------------
  |  Branch (183:21): [True: 0, False: 89]
  ------------------
  184|      0|                        switch (c2)
  ------------------
  |  Branch (184:33): [True: 0, False: 0]
  ------------------
  185|      0|                        {
  186|      0|                            case 'B':
  ------------------
  |  Branch (186:29): [True: 0, False: 0]
  ------------------
  187|      0|                            case 'b':
  ------------------
  |  Branch (187:29): [True: 0, False: 0]
  ------------------
  188|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (188:37): [True: 0, False: 0]
  ------------------
  189|      0|                                {
  190|      0|                                    return OpCode::LBU;
  191|      0|                                }
  192|      0|                                break;
  193|       |
  194|      0|                            case 'E':
  ------------------
  |  Branch (194:29): [True: 0, False: 0]
  ------------------
  195|      0|                            case 'e':
  ------------------
  |  Branch (195:29): [True: 0, False: 0]
  ------------------
  196|      0|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (196:37): [True: 0, False: 0]
  ------------------
  197|      0|                                {
  198|      0|                                    return OpCode::LED;
  199|      0|                                }
  200|      0|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (200:42): [True: 0, False: 0]
  ------------------
  201|      0|                                {
  202|      0|                                    return OpCode::LEF;
  203|      0|                                }
  204|      0|                                break;
  205|       |
  206|      0|                            case 'H':
  ------------------
  |  Branch (206:29): [True: 0, False: 0]
  ------------------
  207|      0|                            case 'h':
  ------------------
  |  Branch (207:29): [True: 0, False: 0]
  ------------------
  208|      0|                                if (ice(c3, 'I'))
  ------------------
  |  Branch (208:37): [True: 0, False: 0]
  ------------------
  209|      0|                                {
  210|      0|                                    return OpCode::LHI;
  211|      0|                                }
  212|      0|                                else if (ice(c3, 'U'))
  ------------------
  |  Branch (212:42): [True: 0, False: 0]
  ------------------
  213|      0|                                {
  214|      0|                                    return OpCode::LHU;
  215|      0|                                }
  216|      0|                                break;
  217|       |
  218|      0|                            case 'T':
  ------------------
  |  Branch (218:29): [True: 0, False: 0]
  ------------------
  219|      0|                            case 't':
  ------------------
  |  Branch (219:29): [True: 0, False: 0]
  ------------------
  220|      0|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (220:37): [True: 0, False: 0]
  ------------------
  221|      0|                                {
  222|      0|                                    return OpCode::LTD;
  223|      0|                                }
  224|      0|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (224:42): [True: 0, False: 0]
  ------------------
  225|      0|                                {
  226|      0|                                    return OpCode::LTF;
  227|      0|                                }
  228|      0|                                break;
  229|       |
  230|      0|                            case 'W':
  ------------------
  |  Branch (230:29): [True: 0, False: 0]
  ------------------
  231|      0|                            case 'w':
  ------------------
  |  Branch (231:29): [True: 0, False: 0]
  ------------------
  232|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (232:37): [True: 0, False: 0]
  ------------------
  233|      0|                                {
  234|      0|                                    return OpCode::LWU;
  235|      0|                                }
  236|      0|                                break;
  237|      0|                        }
  238|      0|                        break;
  239|       |
  240|      0|                    case 'N':
  ------------------
  |  Branch (240:21): [True: 0, False: 89]
  ------------------
  241|      0|                    case 'n':
  ------------------
  |  Branch (241:21): [True: 0, False: 89]
  ------------------
  242|      0|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (242:29): [True: 0, False: 0]
  ------------------
  243|      0|                        {
  244|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (244:33): [True: 0, False: 0]
  ------------------
  245|      0|                            {
  246|      0|                                return OpCode::NED;
  247|      0|                            }
  248|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (248:38): [True: 0, False: 0]
  ------------------
  249|      0|                            {
  250|      0|                                return OpCode::NEF;
  251|      0|                            }
  252|      0|                        }
  253|      0|                        else if (ice(c2, 'O') && ice(c3, 'P'))
  ------------------
  |  Branch (253:34): [True: 0, False: 0]
  |  Branch (253:34): [True: 0, False: 0]
  |  Branch (253:50): [True: 0, False: 0]
  ------------------
  254|      0|                        {
  255|      0|                            return OpCode::NOP;
  256|      0|                        }
  257|       |
  258|      0|                        break;
  259|       |
  260|      0|                    case 'O':
  ------------------
  |  Branch (260:21): [True: 0, False: 89]
  ------------------
  261|      0|                    case 'o':
  ------------------
  |  Branch (261:21): [True: 0, False: 89]
  ------------------
  262|      0|                        if (ice(c2, 'R') && ice(c3, 'I'))
  ------------------
  |  Branch (262:29): [True: 0, False: 0]
  |  Branch (262:29): [True: 0, False: 0]
  |  Branch (262:45): [True: 0, False: 0]
  ------------------
  263|      0|                        {
  264|      0|                            return OpCode::ORI;
  265|      0|                        }
  266|      0|                        break;
  267|       |
  268|      0|                    case 'S':
  ------------------
  |  Branch (268:21): [True: 0, False: 89]
  ------------------
  269|      0|                    case 's':
  ------------------
  |  Branch (269:21): [True: 0, False: 89]
  ------------------
  270|      0|                        switch (c2)
  ------------------
  |  Branch (270:33): [True: 0, False: 0]
  ------------------
  271|      0|                        {
  272|      0|                            case 'B':
  ------------------
  |  Branch (272:29): [True: 0, False: 0]
  ------------------
  273|      0|                            case 'b':
  ------------------
  |  Branch (273:29): [True: 0, False: 0]
  ------------------
  274|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (274:37): [True: 0, False: 0]
  ------------------
  275|      0|                                {
  276|      0|                                    return OpCode::SBU;
  277|      0|                                }
  278|      0|                                break;
  279|       |
  280|      0|                            case 'E':
  ------------------
  |  Branch (280:29): [True: 0, False: 0]
  ------------------
  281|      0|                            case 'e':
  ------------------
  |  Branch (281:29): [True: 0, False: 0]
  ------------------
  282|      0|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (282:37): [True: 0, False: 0]
  ------------------
  283|      0|                                {
  284|      0|                                    return OpCode::SEQ;
  285|      0|                                }
  286|      0|                                break;
  287|       |
  288|      0|                            case 'G':
  ------------------
  |  Branch (288:29): [True: 0, False: 0]
  ------------------
  289|      0|                            case 'g':
  ------------------
  |  Branch (289:29): [True: 0, False: 0]
  ------------------
  290|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (290:37): [True: 0, False: 0]
  ------------------
  291|      0|                                {
  292|      0|                                    return OpCode::SGE;
  293|      0|                                }
  294|      0|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (294:42): [True: 0, False: 0]
  ------------------
  295|      0|                                {
  296|      0|                                    return OpCode::SGT;
  297|      0|                                }
  298|      0|                                break;
  299|       |
  300|      0|                            case 'H':
  ------------------
  |  Branch (300:29): [True: 0, False: 0]
  ------------------
  301|      0|                            case 'h':
  ------------------
  |  Branch (301:29): [True: 0, False: 0]
  ------------------
  302|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (302:37): [True: 0, False: 0]
  ------------------
  303|      0|                                {
  304|      0|                                    return OpCode::SHU;
  305|      0|                                }
  306|      0|                                break;
  307|       |
  308|      0|                            case 'L':
  ------------------
  |  Branch (308:29): [True: 0, False: 0]
  ------------------
  309|      0|                            case 'l':
  ------------------
  |  Branch (309:29): [True: 0, False: 0]
  ------------------
  310|      0|                                switch (c3)
  ------------------
  |  Branch (310:41): [True: 0, False: 0]
  ------------------
  311|      0|                                {
  312|      0|                                    case 'A':
  ------------------
  |  Branch (312:37): [True: 0, False: 0]
  ------------------
  313|      0|                                    case 'a':
  ------------------
  |  Branch (313:37): [True: 0, False: 0]
  ------------------
  314|      0|                                        return OpCode::SLA;
  315|       |
  316|      0|                                    case 'E':
  ------------------
  |  Branch (316:37): [True: 0, False: 0]
  ------------------
  317|      0|                                    case 'e':
  ------------------
  |  Branch (317:37): [True: 0, False: 0]
  ------------------
  318|      0|                                        return OpCode::SLE;
  319|       |
  320|      0|                                    case 'L':
  ------------------
  |  Branch (320:37): [True: 0, False: 0]
  ------------------
  321|      0|                                    case 'l':
  ------------------
  |  Branch (321:37): [True: 0, False: 0]
  ------------------
  322|      0|                                        return OpCode::SLL;
  323|       |
  324|      0|                                    case 'T':
  ------------------
  |  Branch (324:37): [True: 0, False: 0]
  ------------------
  325|      0|                                    case 't':
  ------------------
  |  Branch (325:37): [True: 0, False: 0]
  ------------------
  326|      0|                                        return OpCode::SLT;
  327|      0|                                }
  328|      0|                                break;
  329|       |
  330|      0|                            case 'N':
  ------------------
  |  Branch (330:29): [True: 0, False: 0]
  ------------------
  331|      0|                            case 'n':
  ------------------
  |  Branch (331:29): [True: 0, False: 0]
  ------------------
  332|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (332:37): [True: 0, False: 0]
  ------------------
  333|      0|                                {
  334|      0|                                    return OpCode::SNE;
  335|      0|                                }
  336|      0|                                break;
  337|       |
  338|      0|                            case 'R':
  ------------------
  |  Branch (338:29): [True: 0, False: 0]
  ------------------
  339|      0|                            case 'r':
  ------------------
  |  Branch (339:29): [True: 0, False: 0]
  ------------------
  340|      0|                                if (ice(c3, 'A'))
  ------------------
  |  Branch (340:37): [True: 0, False: 0]
  ------------------
  341|      0|                                {
  342|      0|                                    return OpCode::SRA;
  343|      0|                                }
  344|      0|                                else if (ice(c3, 'L'))
  ------------------
  |  Branch (344:42): [True: 0, False: 0]
  ------------------
  345|      0|                                {
  346|      0|                                    return OpCode::SRL;
  347|      0|                                }
  348|      0|                                break;
  349|       |
  350|      0|                            case 'U':
  ------------------
  |  Branch (350:29): [True: 0, False: 0]
  ------------------
  351|      0|                            case 'u':
  ------------------
  |  Branch (351:29): [True: 0, False: 0]
  ------------------
  352|      0|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (352:37): [True: 0, False: 0]
  ------------------
  353|      0|                                {
  354|      0|                                    return OpCode::SUB;
  355|      0|                                }
  356|      0|                                break;
  357|       |
  358|      0|                            case 'W':
  ------------------
  |  Branch (358:29): [True: 0, False: 0]
  ------------------
  359|      0|                            case 'w':
  ------------------
  |  Branch (359:29): [True: 0, False: 0]
  ------------------
  360|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (360:37): [True: 0, False: 0]
  ------------------
  361|      0|                                {
  362|      0|                                    return OpCode::SWU;
  363|      0|                                }
  364|      0|                                break;
  365|      0|                        }
  366|       |
  367|      0|                    case 'X':
  ------------------
  |  Branch (367:21): [True: 0, False: 89]
  ------------------
  368|      0|                    case 'x':
  ------------------
  |  Branch (368:21): [True: 0, False: 89]
  ------------------
  369|      0|                        if (ice(c2, 'O') && ice(c3, 'R'))
  ------------------
  |  Branch (369:29): [True: 0, False: 0]
  |  Branch (369:29): [True: 0, False: 0]
  |  Branch (369:45): [True: 0, False: 0]
  ------------------
  370|      0|                        {
  371|      0|                            return OpCode::XOR;
  372|      0|                        }
  373|      0|                        break;
  374|     89|                }
  375|     89|                break;
  376|     89|            }
  377|       |
  378|       |            // 4 character OpCodes
  379|     89|            case 4: {
  ------------------
  |  Branch (379:13): [True: 6, False: 174]
  ------------------
  380|      6|                const char c1 = token[0u];
  381|      6|                const char c2 = token[1u];
  382|      6|                const char c3 = token[2u];
  383|      6|                const char c4 = token[3u];
  384|       |
  385|      6|                switch (c1)
  ------------------
  |  Branch (385:25): [True: 2, False: 4]
  ------------------
  386|      6|                {
  387|      0|                    case 'A':
  ------------------
  |  Branch (387:21): [True: 0, False: 6]
  ------------------
  388|      0|                    case 'a':
  ------------------
  |  Branch (388:21): [True: 0, False: 6]
  ------------------
  389|      0|                        switch (c2)
  ------------------
  |  Branch (389:33): [True: 0, False: 0]
  ------------------
  390|      0|                        {
  391|      0|                            case 'D':
  ------------------
  |  Branch (391:29): [True: 0, False: 0]
  ------------------
  392|      0|                            case 'd':
  ------------------
  |  Branch (392:29): [True: 0, False: 0]
  ------------------
  393|      0|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (393:37): [True: 0, False: 0]
  ------------------
  394|      0|                                {
  395|      0|                                    switch (c4)
  ------------------
  |  Branch (395:45): [True: 0, False: 0]
  ------------------
  396|      0|                                    {
  397|      0|                                        case 'D':
  ------------------
  |  Branch (397:41): [True: 0, False: 0]
  ------------------
  398|      0|                                        case 'd':
  ------------------
  |  Branch (398:41): [True: 0, False: 0]
  ------------------
  399|      0|                                            return OpCode::ADDD;
  400|       |
  401|      0|                                        case 'F':
  ------------------
  |  Branch (401:41): [True: 0, False: 0]
  ------------------
  402|      0|                                        case 'f':
  ------------------
  |  Branch (402:41): [True: 0, False: 0]
  ------------------
  403|      0|                                            return OpCode::ADDF;
  404|       |
  405|      0|                                        case 'I':
  ------------------
  |  Branch (405:41): [True: 0, False: 0]
  ------------------
  406|      0|                                        case 'i':
  ------------------
  |  Branch (406:41): [True: 0, False: 0]
  ------------------
  407|      0|                                            return OpCode::ADDI;
  408|       |
  409|      0|                                        case 'U':
  ------------------
  |  Branch (409:41): [True: 0, False: 0]
  ------------------
  410|      0|                                        case 'u':
  ------------------
  |  Branch (410:41): [True: 0, False: 0]
  ------------------
  411|      0|                                            return OpCode::ADDU;
  412|      0|                                    }
  413|      0|                                }
  414|      0|                                break;
  415|       |
  416|      0|                            case 'N':
  ------------------
  |  Branch (416:29): [True: 0, False: 0]
  ------------------
  417|      0|                            case 'n':
  ------------------
  |  Branch (417:29): [True: 0, False: 0]
  ------------------
  418|      0|                                if (ice(c3, 'D') && ice(c4, 'I'))
  ------------------
  |  Branch (418:37): [True: 0, False: 0]
  |  Branch (418:37): [True: 0, False: 0]
  |  Branch (418:53): [True: 0, False: 0]
  ------------------
  419|      0|                                {
  420|      0|                                    return OpCode::ANDI;
  421|      0|                                }
  422|       |
  423|      0|                                break;
  424|      0|                        }
  425|      0|                        break;
  426|       |
  427|      4|                    case 'B':
  ------------------
  |  Branch (427:21): [True: 4, False: 2]
  ------------------
  428|      4|                    case 'b':
  ------------------
  |  Branch (428:21): [True: 0, False: 6]
  ------------------
  429|      4|                        switch (c2)
  ------------------
  |  Branch (429:33): [True: 4, False: 0]
  ------------------
  430|      4|                        {
  431|      0|                            case 'E':
  ------------------
  |  Branch (431:29): [True: 0, False: 4]
  ------------------
  432|      0|                            case 'e':
  ------------------
  |  Branch (432:29): [True: 0, False: 4]
  ------------------
  433|      0|                                if (ice(c3, 'Q') && ice(c4, 'Z'))
  ------------------
  |  Branch (433:37): [True: 0, False: 0]
  |  Branch (433:37): [True: 0, False: 0]
  |  Branch (433:53): [True: 0, False: 0]
  ------------------
  434|      0|                                {
  435|      0|                                    return OpCode::BEQZ;
  436|      0|                                }
  437|      0|                                break;
  438|       |
  439|      0|                            case 'F':
  ------------------
  |  Branch (439:29): [True: 0, False: 4]
  ------------------
  440|      0|                            case 'f':
  ------------------
  |  Branch (440:29): [True: 0, False: 4]
  ------------------
  441|      0|                                if (ice(c3, 'P'))
  ------------------
  |  Branch (441:37): [True: 0, False: 0]
  ------------------
  442|      0|                                {
  443|      0|                                    if (ice(c4, 'F'))
  ------------------
  |  Branch (443:41): [True: 0, False: 0]
  ------------------
  444|      0|                                    {
  445|      0|                                        return OpCode::BFPF;
  446|      0|                                    }
  447|      0|                                    else if (ice(c4, 'T'))
  ------------------
  |  Branch (447:46): [True: 0, False: 0]
  ------------------
  448|      0|                                    {
  449|      0|                                        return OpCode::BFPT;
  450|      0|                                    }
  451|      0|                                }
  452|      0|                                break;
  453|       |
  454|      0|                            case 'N':
  ------------------
  |  Branch (454:29): [True: 0, False: 4]
  ------------------
  455|      0|                            case 'n':
  ------------------
  |  Branch (455:29): [True: 0, False: 4]
  ------------------
  456|      0|                                if (ice(c3, 'E') && ice(c4, 'Z'))
  ------------------
  |  Branch (456:37): [True: 0, False: 0]
  |  Branch (456:37): [True: 0, False: 0]
  |  Branch (456:53): [True: 0, False: 0]
  ------------------
  457|      0|                                {
  458|      0|                                    return OpCode::BNEZ;
  459|      0|                                }
  460|      4|                        }
  461|      4|                        break;
  462|       |
  463|      4|                    case 'D':
  ------------------
  |  Branch (463:21): [True: 0, False: 6]
  ------------------
  464|      0|                    case 'd':
  ------------------
  |  Branch (464:21): [True: 0, False: 6]
  ------------------
  465|      0|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (465:29): [True: 0, False: 0]
  |  Branch (465:29): [True: 0, False: 0]
  |  Branch (465:45): [True: 0, False: 0]
  ------------------
  466|      0|                        {
  467|      0|                            switch (c4)
  ------------------
  |  Branch (467:37): [True: 0, False: 0]
  ------------------
  468|      0|                            {
  469|      0|                                case 'D':
  ------------------
  |  Branch (469:33): [True: 0, False: 0]
  ------------------
  470|      0|                                case 'd':
  ------------------
  |  Branch (470:33): [True: 0, False: 0]
  ------------------
  471|      0|                                    return OpCode::DIVD;
  472|       |
  473|      0|                                case 'F':
  ------------------
  |  Branch (473:33): [True: 0, False: 0]
  ------------------
  474|      0|                                case 'f':
  ------------------
  |  Branch (474:33): [True: 0, False: 0]
  ------------------
  475|      0|                                    return OpCode::DIVF;
  476|       |
  477|      0|                                case 'I':
  ------------------
  |  Branch (477:33): [True: 0, False: 0]
  ------------------
  478|      0|                                case 'i':
  ------------------
  |  Branch (478:33): [True: 0, False: 0]
  ------------------
  479|      0|                                    return OpCode::DIVI;
  480|       |
  481|      0|                                case 'U':
  ------------------
  |  Branch (481:33): [True: 0, False: 0]
  ------------------
  482|      0|                                case 'u':
  ------------------
  |  Branch (482:33): [True: 0, False: 0]
  ------------------
  483|      0|                                    return OpCode::DIVU;
  484|      0|                            }
  485|      0|                        }
  486|      0|                        break;
  487|       |
  488|      0|                    case 'H':
  ------------------
  |  Branch (488:21): [True: 0, False: 6]
  ------------------
  489|      0|                    case 'h':
  ------------------
  |  Branch (489:21): [True: 0, False: 6]
  ------------------
  490|      0|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (490:29): [True: 0, False: 0]
  |  Branch (490:29): [True: 0, False: 0]
  |  Branch (490:45): [True: 0, False: 0]
  |  Branch (490:61): [True: 0, False: 0]
  ------------------
  491|      0|                        {
  492|      0|                            return OpCode::HALT;
  493|      0|                        }
  494|      0|                        break;
  495|       |
  496|      0|                    case 'J':
  ------------------
  |  Branch (496:21): [True: 0, False: 6]
  ------------------
  497|      0|                    case 'j':
  ------------------
  |  Branch (497:21): [True: 0, False: 6]
  ------------------
  498|      0|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'R'))
  ------------------
  |  Branch (498:29): [True: 0, False: 0]
  |  Branch (498:29): [True: 0, False: 0]
  |  Branch (498:45): [True: 0, False: 0]
  |  Branch (498:61): [True: 0, False: 0]
  ------------------
  499|      0|                        {
  500|      0|                            return OpCode::JALR;
  501|      0|                        }
  502|      0|                        break;
  503|       |
  504|      0|                    case 'M':
  ------------------
  |  Branch (504:21): [True: 0, False: 6]
  ------------------
  505|      0|                    case 'm':
  ------------------
  |  Branch (505:21): [True: 0, False: 6]
  ------------------
  506|      0|                        if (ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (506:29): [True: 0, False: 0]
  |  Branch (506:29): [True: 0, False: 0]
  |  Branch (506:45): [True: 0, False: 0]
  ------------------
  507|      0|                        {
  508|      0|                            if (ice(c4, 'D'))
  ------------------
  |  Branch (508:33): [True: 0, False: 0]
  ------------------
  509|      0|                            {
  510|      0|                                return OpCode::MOVD;
  511|      0|                            }
  512|      0|                            else if (ice(c4, 'F'))
  ------------------
  |  Branch (512:38): [True: 0, False: 0]
  ------------------
  513|      0|                            {
  514|      0|                                return OpCode::MOVF;
  515|      0|                            }
  516|      0|                        }
  517|      0|                        else if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (517:34): [True: 0, False: 0]
  |  Branch (517:34): [True: 0, False: 0]
  |  Branch (517:50): [True: 0, False: 0]
  |  Branch (517:66): [True: 0, False: 0]
  ------------------
  518|      0|                        {
  519|      0|                            return OpCode::MULT;
  520|      0|                        }
  521|      0|                        break;
  522|       |
  523|      0|                    case 'S':
  ------------------
  |  Branch (523:21): [True: 0, False: 6]
  ------------------
  524|      0|                    case 's':
  ------------------
  |  Branch (524:21): [True: 0, False: 6]
  ------------------
  525|      0|                        switch (c2)
  ------------------
  |  Branch (525:33): [True: 0, False: 0]
  ------------------
  526|      0|                        {
  527|      0|                            case 'E':
  ------------------
  |  Branch (527:29): [True: 0, False: 0]
  ------------------
  528|      0|                            case 'e':
  ------------------
  |  Branch (528:29): [True: 0, False: 0]
  ------------------
  529|      0|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (529:37): [True: 0, False: 0]
  ------------------
  530|      0|                                {
  531|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (531:41): [True: 0, False: 0]
  ------------------
  532|      0|                                    {
  533|      0|                                        return OpCode::SEQI;
  534|      0|                                    }
  535|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (535:46): [True: 0, False: 0]
  ------------------
  536|      0|                                    {
  537|      0|                                        return OpCode::SEQU;
  538|      0|                                    }
  539|      0|                                }
  540|      0|                                break;
  541|       |
  542|      0|                            case 'G':
  ------------------
  |  Branch (542:29): [True: 0, False: 0]
  ------------------
  543|      0|                            case 'g':
  ------------------
  |  Branch (543:29): [True: 0, False: 0]
  ------------------
  544|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (544:37): [True: 0, False: 0]
  ------------------
  545|      0|                                {
  546|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (546:41): [True: 0, False: 0]
  ------------------
  547|      0|                                    {
  548|      0|                                        return OpCode::SGEI;
  549|      0|                                    }
  550|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (550:46): [True: 0, False: 0]
  ------------------
  551|      0|                                    {
  552|      0|                                        return OpCode::SGEU;
  553|      0|                                    }
  554|      0|                                }
  555|      0|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (555:42): [True: 0, False: 0]
  ------------------
  556|      0|                                {
  557|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (557:41): [True: 0, False: 0]
  ------------------
  558|      0|                                    {
  559|      0|                                        return OpCode::SGTI;
  560|      0|                                    }
  561|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (561:46): [True: 0, False: 0]
  ------------------
  562|      0|                                    {
  563|      0|                                        return OpCode::SGTU;
  564|      0|                                    }
  565|      0|                                }
  566|      0|                                break;
  567|       |
  568|      0|                            case 'L':
  ------------------
  |  Branch (568:29): [True: 0, False: 0]
  ------------------
  569|      0|                            case 'l':
  ------------------
  |  Branch (569:29): [True: 0, False: 0]
  ------------------
  570|      0|                                switch (c3)
  ------------------
  |  Branch (570:41): [True: 0, False: 0]
  ------------------
  571|      0|                                {
  572|      0|                                    case 'A':
  ------------------
  |  Branch (572:37): [True: 0, False: 0]
  ------------------
  573|      0|                                    case 'a':
  ------------------
  |  Branch (573:37): [True: 0, False: 0]
  ------------------
  574|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (574:45): [True: 0, False: 0]
  ------------------
  575|      0|                                        {
  576|      0|                                            return OpCode::SLAI;
  577|      0|                                        }
  578|      0|                                        break;
  579|       |
  580|      0|                                    case 'E':
  ------------------
  |  Branch (580:37): [True: 0, False: 0]
  ------------------
  581|      0|                                    case 'e':
  ------------------
  |  Branch (581:37): [True: 0, False: 0]
  ------------------
  582|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (582:45): [True: 0, False: 0]
  ------------------
  583|      0|                                        {
  584|      0|                                            return OpCode::SLEI;
  585|      0|                                        }
  586|      0|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (586:50): [True: 0, False: 0]
  ------------------
  587|      0|                                        {
  588|      0|                                            return OpCode::SLEU;
  589|      0|                                        }
  590|      0|                                        break;
  591|       |
  592|      0|                                    case 'L':
  ------------------
  |  Branch (592:37): [True: 0, False: 0]
  ------------------
  593|      0|                                    case 'l':
  ------------------
  |  Branch (593:37): [True: 0, False: 0]
  ------------------
  594|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (594:45): [True: 0, False: 0]
  ------------------
  595|      0|                                        {
  596|      0|                                            return OpCode::SLLI;
  597|      0|                                        }
  598|      0|                                        break;
  599|       |
  600|      0|                                    case 'T':
  ------------------
  |  Branch (600:37): [True: 0, False: 0]
  ------------------
  601|      0|                                    case 't':
  ------------------
  |  Branch (601:37): [True: 0, False: 0]
  ------------------
  602|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (602:45): [True: 0, False: 0]
  ------------------
  603|      0|                                        {
  604|      0|                                            return OpCode::SLTI;
  605|      0|                                        }
  606|      0|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (606:50): [True: 0, False: 0]
  ------------------
  607|      0|                                        {
  608|      0|                                            return OpCode::SLTU;
  609|      0|                                        }
  610|      0|                                        break;
  611|      0|                                }
  612|       |
  613|      0|                            case 'N':
  ------------------
  |  Branch (613:29): [True: 0, False: 0]
  ------------------
  614|      0|                            case 'n':
  ------------------
  |  Branch (614:29): [True: 0, False: 0]
  ------------------
  615|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (615:37): [True: 0, False: 0]
  ------------------
  616|      0|                                {
  617|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (617:41): [True: 0, False: 0]
  ------------------
  618|      0|                                    {
  619|      0|                                        return OpCode::SNEI;
  620|      0|                                    }
  621|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (621:46): [True: 0, False: 0]
  ------------------
  622|      0|                                    {
  623|      0|                                        return OpCode::SNEU;
  624|      0|                                    }
  625|      0|                                }
  626|      0|                                break;
  627|       |
  628|      0|                            case 'R':
  ------------------
  |  Branch (628:29): [True: 0, False: 0]
  ------------------
  629|      0|                            case 'r':
  ------------------
  |  Branch (629:29): [True: 0, False: 0]
  ------------------
  630|      0|                                if (ice(c3, 'A') && ice(c4, 'I'))
  ------------------
  |  Branch (630:37): [True: 0, False: 0]
  |  Branch (630:37): [True: 0, False: 0]
  |  Branch (630:53): [True: 0, False: 0]
  ------------------
  631|      0|                                {
  632|      0|                                    return OpCode::SRAI;
  633|      0|                                }
  634|      0|                                else if (ice(c3, 'L') && ice(c4, 'I'))
  ------------------
  |  Branch (634:42): [True: 0, False: 0]
  |  Branch (634:42): [True: 0, False: 0]
  |  Branch (634:58): [True: 0, False: 0]
  ------------------
  635|      0|                                {
  636|      0|                                    return OpCode::SRLI;
  637|      0|                                }
  638|      0|                                break;
  639|       |
  640|      0|                            case 'U':
  ------------------
  |  Branch (640:29): [True: 0, False: 0]
  ------------------
  641|      0|                            case 'u':
  ------------------
  |  Branch (641:29): [True: 0, False: 0]
  ------------------
  642|      0|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (642:37): [True: 0, False: 0]
  ------------------
  643|      0|                                {
  644|      0|                                    switch (c4)
  ------------------
  |  Branch (644:45): [True: 0, False: 0]
  ------------------
  645|      0|                                    {
  646|      0|                                        case 'D':
  ------------------
  |  Branch (646:41): [True: 0, False: 0]
  ------------------
  647|      0|                                        case 'd':
  ------------------
  |  Branch (647:41): [True: 0, False: 0]
  ------------------
  648|      0|                                            return OpCode::SUBD;
  649|       |
  650|      0|                                        case 'F':
  ------------------
  |  Branch (650:41): [True: 0, False: 0]
  ------------------
  651|      0|                                        case 'f':
  ------------------
  |  Branch (651:41): [True: 0, False: 0]
  ------------------
  652|      0|                                            return OpCode::SUBF;
  653|       |
  654|      0|                                        case 'I':
  ------------------
  |  Branch (654:41): [True: 0, False: 0]
  ------------------
  655|      0|                                        case 'i':
  ------------------
  |  Branch (655:41): [True: 0, False: 0]
  ------------------
  656|      0|                                            return OpCode::SUBI;
  657|       |
  658|      0|                                        case 'U':
  ------------------
  |  Branch (658:41): [True: 0, False: 0]
  ------------------
  659|      0|                                        case 'u':
  ------------------
  |  Branch (659:41): [True: 0, False: 0]
  ------------------
  660|      0|                                            return OpCode::SUBU;
  661|      0|                                    }
  662|      0|                                }
  663|      0|                                break;
  664|      0|                        }
  665|      0|                        break;
  666|       |
  667|      0|                    case 'T':
  ------------------
  |  Branch (667:21): [True: 0, False: 6]
  ------------------
  668|      0|                    case 't':
  ------------------
  |  Branch (668:21): [True: 0, False: 6]
  ------------------
  669|      0|                        if (ice(c2, 'R') && ice(c3, 'A') && ice(c4, 'P'))
  ------------------
  |  Branch (669:29): [True: 0, False: 0]
  |  Branch (669:29): [True: 0, False: 0]
  |  Branch (669:45): [True: 0, False: 0]
  |  Branch (669:61): [True: 0, False: 0]
  ------------------
  670|      0|                        {
  671|      0|                            return OpCode::TRAP;
  672|      0|                        }
  673|      0|                        break;
  674|      0|                    case 'X':
  ------------------
  |  Branch (674:21): [True: 0, False: 6]
  ------------------
  675|      0|                    case 'x':
  ------------------
  |  Branch (675:21): [True: 0, False: 6]
  ------------------
  676|      0|                        if (ice(c2, 'O') && ice(c3, 'R') && ice(c4, 'I'))
  ------------------
  |  Branch (676:29): [True: 0, False: 0]
  |  Branch (676:29): [True: 0, False: 0]
  |  Branch (676:45): [True: 0, False: 0]
  |  Branch (676:61): [True: 0, False: 0]
  ------------------
  677|      0|                        {
  678|      0|                            return OpCode::XORI;
  679|      0|                        }
  680|      0|                        break;
  681|      6|                }
  682|      6|                break;
  683|      6|            }
  684|       |
  685|       |            // 5 character OpCodes
  686|      6|            case 5: {
  ------------------
  |  Branch (686:13): [True: 5, False: 175]
  ------------------
  687|      5|                const char c1 = token[0u];
  688|      5|                const char c2 = token[1u];
  689|      5|                const char c3 = token[2u];
  690|      5|                const char c4 = token[3u];
  691|      5|                const char c5 = token[4u];
  692|       |
  693|      5|                switch (c1)
  ------------------
  |  Branch (693:25): [True: 5, False: 0]
  ------------------
  694|      5|                {
  695|      0|                    case 'A':
  ------------------
  |  Branch (695:21): [True: 0, False: 5]
  ------------------
  696|      0|                    case 'a':
  ------------------
  |  Branch (696:21): [True: 0, False: 5]
  ------------------
  697|      0|                        if (ice(c2, 'D') && ice(c3, 'D') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (697:29): [True: 0, False: 0]
  |  Branch (697:29): [True: 0, False: 0]
  |  Branch (697:45): [True: 0, False: 0]
  |  Branch (697:61): [True: 0, False: 0]
  |  Branch (697:77): [True: 0, False: 0]
  ------------------
  698|      0|                        {
  699|      0|                            return OpCode::ADDUI;
  700|      0|                        }
  701|      0|                        break;
  702|       |
  703|      0|                    case 'D':
  ------------------
  |  Branch (703:21): [True: 0, False: 5]
  ------------------
  704|      0|                    case 'd':
  ------------------
  |  Branch (704:21): [True: 0, False: 5]
  ------------------
  705|      0|                        if (ice(c2, 'I') && ice(c3, 'V') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (705:29): [True: 0, False: 0]
  |  Branch (705:29): [True: 0, False: 0]
  |  Branch (705:45): [True: 0, False: 0]
  |  Branch (705:61): [True: 0, False: 0]
  |  Branch (705:77): [True: 0, False: 0]
  ------------------
  706|      0|                        {
  707|      0|                            return OpCode::DIVUI;
  708|      0|                        }
  709|      0|                        break;
  710|       |
  711|      0|                    case 'M':
  ------------------
  |  Branch (711:21): [True: 0, False: 5]
  ------------------
  712|      0|                    case 'm':
  ------------------
  |  Branch (712:21): [True: 0, False: 5]
  ------------------
  713|      0|                        if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (713:29): [True: 0, False: 0]
  |  Branch (713:29): [True: 0, False: 0]
  |  Branch (713:45): [True: 0, False: 0]
  |  Branch (713:61): [True: 0, False: 0]
  ------------------
  714|      0|                        {
  715|      0|                            switch (c5)
  ------------------
  |  Branch (715:37): [True: 0, False: 0]
  ------------------
  716|      0|                            {
  717|      0|                                case 'D':
  ------------------
  |  Branch (717:33): [True: 0, False: 0]
  ------------------
  718|      0|                                case 'd':
  ------------------
  |  Branch (718:33): [True: 0, False: 0]
  ------------------
  719|      0|                                    return OpCode::MULTD;
  720|       |
  721|      0|                                case 'F':
  ------------------
  |  Branch (721:33): [True: 0, False: 0]
  ------------------
  722|      0|                                case 'f':
  ------------------
  |  Branch (722:33): [True: 0, False: 0]
  ------------------
  723|      0|                                    return OpCode::MULTF;
  724|       |
  725|      0|                                case 'I':
  ------------------
  |  Branch (725:33): [True: 0, False: 0]
  ------------------
  726|      0|                                case 'i':
  ------------------
  |  Branch (726:33): [True: 0, False: 0]
  ------------------
  727|      0|                                    return OpCode::MULTI;
  728|       |
  729|      0|                                case 'U':
  ------------------
  |  Branch (729:33): [True: 0, False: 0]
  ------------------
  730|      0|                                case 'u':
  ------------------
  |  Branch (730:33): [True: 0, False: 0]
  ------------------
  731|      0|                                    return OpCode::MULTU;
  732|      0|                            }
  733|      0|                        }
  734|      0|                        break;
  735|       |
  736|      0|                    case 'S':
  ------------------
  |  Branch (736:21): [True: 0, False: 5]
  ------------------
  737|      0|                    case 's':
  ------------------
  |  Branch (737:21): [True: 0, False: 5]
  ------------------
  738|      0|                        switch (c2)
  ------------------
  |  Branch (738:33): [True: 0, False: 0]
  ------------------
  739|      0|                        {
  740|      0|                            case 'E':
  ------------------
  |  Branch (740:29): [True: 0, False: 0]
  ------------------
  741|      0|                            case 'e':
  ------------------
  |  Branch (741:29): [True: 0, False: 0]
  ------------------
  742|      0|                                if (ice(c3, 'Q') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (742:37): [True: 0, False: 0]
  |  Branch (742:37): [True: 0, False: 0]
  |  Branch (742:53): [True: 0, False: 0]
  |  Branch (742:69): [True: 0, False: 0]
  ------------------
  743|      0|                                {
  744|      0|                                    return OpCode::SEQUI;
  745|      0|                                }
  746|      0|                                break;
  747|       |
  748|      0|                            case 'G':
  ------------------
  |  Branch (748:29): [True: 0, False: 0]
  ------------------
  749|      0|                            case 'g':
  ------------------
  |  Branch (749:29): [True: 0, False: 0]
  ------------------
  750|      0|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (750:37): [True: 0, False: 0]
  |  Branch (750:37): [True: 0, False: 0]
  |  Branch (750:53): [True: 0, False: 0]
  |  Branch (750:69): [True: 0, False: 0]
  ------------------
  751|      0|                                {
  752|      0|                                    return OpCode::SGEUI;
  753|      0|                                }
  754|      0|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (754:42): [True: 0, False: 0]
  |  Branch (754:42): [True: 0, False: 0]
  |  Branch (754:58): [True: 0, False: 0]
  |  Branch (754:74): [True: 0, False: 0]
  ------------------
  755|      0|                                {
  756|      0|                                    return OpCode::SGTUI;
  757|      0|                                }
  758|      0|                                break;
  759|       |
  760|      0|                            case 'L':
  ------------------
  |  Branch (760:29): [True: 0, False: 0]
  ------------------
  761|      0|                            case 'l':
  ------------------
  |  Branch (761:29): [True: 0, False: 0]
  ------------------
  762|      0|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (762:37): [True: 0, False: 0]
  |  Branch (762:37): [True: 0, False: 0]
  |  Branch (762:53): [True: 0, False: 0]
  |  Branch (762:69): [True: 0, False: 0]
  ------------------
  763|      0|                                {
  764|      0|                                    return OpCode::SLEUI;
  765|      0|                                }
  766|      0|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (766:42): [True: 0, False: 0]
  |  Branch (766:42): [True: 0, False: 0]
  |  Branch (766:58): [True: 0, False: 0]
  |  Branch (766:74): [True: 0, False: 0]
  ------------------
  767|      0|                                {
  768|      0|                                    return OpCode::SLTUI;
  769|      0|                                }
  770|      0|                                break;
  771|       |
  772|      0|                            case 'N':
  ------------------
  |  Branch (772:29): [True: 0, False: 0]
  ------------------
  773|      0|                            case 'n':
  ------------------
  |  Branch (773:29): [True: 0, False: 0]
  ------------------
  774|      0|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (774:37): [True: 0, False: 0]
  |  Branch (774:37): [True: 0, False: 0]
  |  Branch (774:53): [True: 0, False: 0]
  |  Branch (774:69): [True: 0, False: 0]
  ------------------
  775|      0|                                {
  776|      0|                                    return OpCode::SNEUI;
  777|      0|                                }
  778|      0|                                break;
  779|       |
  780|      0|                            case 'U':
  ------------------
  |  Branch (780:29): [True: 0, False: 0]
  ------------------
  781|      0|                            case 'u':
  ------------------
  |  Branch (781:29): [True: 0, False: 0]
  ------------------
  782|      0|                                if (ice(c3, 'B') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (782:37): [True: 0, False: 0]
  |  Branch (782:37): [True: 0, False: 0]
  |  Branch (782:53): [True: 0, False: 0]
  |  Branch (782:69): [True: 0, False: 0]
  ------------------
  783|      0|                                {
  784|      0|                                    return OpCode::SUBUI;
  785|      0|                                }
  786|      0|                                break;
  787|      0|                        }
  788|       |
  789|      0|                        break;
  790|      5|                }
  791|       |
  792|      5|                break;
  793|      5|            }
  794|       |
  795|       |            // 6 character OpCodes
  796|      5|            case 6: {
  ------------------
  |  Branch (796:13): [True: 0, False: 180]
  ------------------
  797|      0|                const char c1 = token[0u];
  798|      0|                const char c2 = token[1u];
  799|      0|                const char c3 = token[2u];
  800|      0|                const char c4 = token[3u];
  801|      0|                const char c5 = token[4u];
  802|      0|                const char c6 = token[5u];
  803|       |
  804|      0|                if (ice(c1, 'C') && ice(c2, 'V') && ice(c3, 'T'))
  ------------------
  |  Branch (804:21): [True: 0, False: 0]
  |  Branch (804:21): [True: 0, False: 0]
  |  Branch (804:37): [True: 0, False: 0]
  |  Branch (804:53): [True: 0, False: 0]
  ------------------
  805|      0|                {
  806|      0|                    switch (c4)
  ------------------
  |  Branch (806:29): [True: 0, False: 0]
  ------------------
  807|      0|                    {
  808|      0|                        case 'D':
  ------------------
  |  Branch (808:25): [True: 0, False: 0]
  ------------------
  809|      0|                        case 'd':
  ------------------
  |  Branch (809:25): [True: 0, False: 0]
  ------------------
  810|      0|                            if (c5 == '2')
  ------------------
  |  Branch (810:33): [True: 0, False: 0]
  ------------------
  811|      0|                            {
  812|      0|                                if (ice(c6, 'F'))
  ------------------
  |  Branch (812:37): [True: 0, False: 0]
  ------------------
  813|      0|                                {
  814|      0|                                    return OpCode::CVTD2F;
  815|      0|                                }
  816|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (816:42): [True: 0, False: 0]
  ------------------
  817|      0|                                {
  818|      0|                                    return OpCode::CVTD2I;
  819|      0|                                }
  820|      0|                            }
  821|      0|                            break;
  822|       |
  823|      0|                        case 'F':
  ------------------
  |  Branch (823:25): [True: 0, False: 0]
  ------------------
  824|      0|                        case 'f':
  ------------------
  |  Branch (824:25): [True: 0, False: 0]
  ------------------
  825|      0|                            if (c5 == '2')
  ------------------
  |  Branch (825:33): [True: 0, False: 0]
  ------------------
  826|      0|                            {
  827|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (827:37): [True: 0, False: 0]
  ------------------
  828|      0|                                {
  829|      0|                                    return OpCode::CVTF2D;
  830|      0|                                }
  831|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (831:42): [True: 0, False: 0]
  ------------------
  832|      0|                                {
  833|      0|                                    return OpCode::CVTF2I;
  834|      0|                                }
  835|      0|                            }
  836|      0|                            break;
  837|       |
  838|      0|                        case 'I':
  ------------------
  |  Branch (838:25): [True: 0, False: 0]
  ------------------
  839|      0|                        case 'i':
  ------------------
  |  Branch (839:25): [True: 0, False: 0]
  ------------------
  840|      0|                            if (c5 == '2')
  ------------------
  |  Branch (840:33): [True: 0, False: 0]
  ------------------
  841|      0|                            {
  842|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (842:37): [True: 0, False: 0]
  ------------------
  843|      0|                                {
  844|      0|                                    return OpCode::CVTI2D;
  845|      0|                                }
  846|      0|                                else if (ice(c6, 'F'))
  ------------------
  |  Branch (846:42): [True: 0, False: 0]
  ------------------
  847|      0|                                {
  848|      0|                                    return OpCode::CVTI2F;
  849|      0|                                }
  850|      0|                            }
  851|      0|                    }
  852|      0|                }
  853|      0|                else if (ice(c1, 'M') && ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T') &&
  ------------------
  |  Branch (853:26): [True: 0, False: 0]
  |  Branch (853:26): [True: 0, False: 0]
  |  Branch (853:42): [True: 0, False: 0]
  |  Branch (853:58): [True: 0, False: 0]
  |  Branch (853:74): [True: 0, False: 0]
  ------------------
  854|      0|                         ice(c5, 'U') && ice(c6, 'I'))
  ------------------
  |  Branch (854:26): [True: 0, False: 0]
  |  Branch (854:42): [True: 0, False: 0]
  ------------------
  855|      0|                {
  856|      0|                    return OpCode::MULTUI;
  857|      0|                }
  858|      0|                break;
  859|      0|            }
  860|       |
  861|       |            // 7 character OpCodes
  862|      0|            case 7: {
  ------------------
  |  Branch (862:13): [True: 0, False: 180]
  ------------------
  863|      0|                const char c1 = token[0u];
  864|      0|                const char c2 = token[1u];
  865|      0|                const char c3 = token[2u];
  866|      0|                const char c4 = token[3u];
  867|      0|                const char c5 = token[4u];
  868|      0|                const char c6 = token[5u];
  869|      0|                const char c7 = token[6u];
  870|       |
  871|      0|                if (ice(c1, 'M') && ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (871:21): [True: 0, False: 0]
  |  Branch (871:21): [True: 0, False: 0]
  |  Branch (871:37): [True: 0, False: 0]
  |  Branch (871:53): [True: 0, False: 0]
  ------------------
  872|      0|                {
  873|      0|                    if (ice(c4, 'I') && c5 == '2' && ice(c6, 'F') && ice(c7, 'P'))
  ------------------
  |  Branch (873:25): [True: 0, False: 0]
  |  Branch (873:25): [True: 0, False: 0]
  |  Branch (873:41): [True: 0, False: 0]
  |  Branch (873:54): [True: 0, False: 0]
  |  Branch (873:70): [True: 0, False: 0]
  ------------------
  874|      0|                    {
  875|      0|                        return OpCode::MOVI2FP;
  876|      0|                    }
  877|      0|                    if (ice(c4, 'F') && ice(c5, 'P') && c6 == '2' && ice(c7, 'I'))
  ------------------
  |  Branch (877:25): [True: 0, False: 0]
  |  Branch (877:25): [True: 0, False: 0]
  |  Branch (877:41): [True: 0, False: 0]
  |  Branch (877:57): [True: 0, False: 0]
  |  Branch (877:70): [True: 0, False: 0]
  ------------------
  878|      0|                    {
  879|      0|                        return OpCode::MOVFP2I;
  880|      0|                    }
  881|      0|                }
  882|      0|                break;
  883|      0|            }
  884|       |
  885|     68|            default: {
  ------------------
  |  Branch (885:13): [True: 68, False: 112]
  ------------------
  886|     68|                break;
  887|      0|            }
  888|    180|        }
  889|       |
  890|       |        // None found
  891|    180|        return OpCode::NONE;
  892|    180|    }
_ZN3dlx3iceEcc:
   17|      8|    {
   18|      8|        constexpr const char diff = 'a' - 'A';
   19|      8|        return (c == t) || (c == t + diff);
  ------------------
  |  Branch (19:16): [True: 0, False: 8]
  |  Branch (19:28): [True: 0, False: 8]
  ------------------
   20|      8|    }

_ZN3dlx10ParseErrorC2Ev:
   20|    163|    {}
_ZNK3dlx10ParseError13GetLineNumberEv:
   28|    163|    {
   29|    163|        return m_LineNumber;
   30|    163|    }
_ZNK3dlx10ParseError16ConstructMessageEv:
   44|    163|    {
   45|    163|        switch (m_Type)
   46|    163|        {
   47|      0|            case Type::UnexpectedArgumentType: {
  ------------------
  |  Branch (47:13): [True: 0, False: 163]
  ------------------
   48|      0|                const UnexpectedArgumentType& detail = GetUnexpectedArgumentType();
   49|       |
   50|      0|                return fmt::format("Expected {:s} but got {:s}",
   51|      0|                                   dlx::enum_name(detail.expected_type).data(),
   52|      0|                                   dlx::enum_name(detail.actual_type).data());
   53|      0|            }
   54|       |
   55|      0|            case Type::InvalidNumber: {
  ------------------
  |  Branch (55:13): [True: 0, False: 163]
  ------------------
   56|      0|                const InvalidNumber& detail = GetInvalidNumber();
   57|       |
   58|      0|                return fmt::format("'{:s}' is not a valid number", detail.text.data());
   59|      0|            }
   60|       |
   61|      0|            case Type::TooFewArgumentsAddressDisplacement: {
  ------------------
  |  Branch (61:13): [True: 0, False: 163]
  ------------------
   62|      0|                return fmt::format("Not enough arguments left to parse address displacement");
   63|      0|            }
   64|       |
   65|     24|            case Type::UnexpectedToken: {
  ------------------
  |  Branch (65:13): [True: 24, False: 139]
  ------------------
   66|     24|                const UnexpectedToken& detail = GetUnexpectedToken();
   67|       |
   68|     24|                return fmt::format("Expected token of type {:s} but got {:s}",
   69|     24|                                   dlx::enum_name(detail.expected_type).data(),
   70|     24|                                   dlx::enum_name(detail.actual_type).data());
   71|      0|            }
   72|       |
   73|      0|            case Type::ReserverdIdentifier: {
  ------------------
  |  Branch (73:13): [True: 0, False: 163]
  ------------------
   74|      0|                const ReservedIdentifier& detail = GetReserverIdentifier();
   75|       |
   76|      0|                return fmt::format("'{:s}' is a reserved identifier", detail.identifier.data());
   77|      0|            }
   78|       |
   79|    132|            case Type::InvalidLabelIdentifier: {
  ------------------
  |  Branch (79:13): [True: 132, False: 31]
  ------------------
   80|    132|                const InvalidLabelIdentifier& detail = GetInvalidLabelIdentifier();
   81|       |
   82|    132|                return fmt::format("'{:s}' is not a valid label identifier",
   83|    132|                                   detail.identifer.data());
   84|      0|            }
   85|       |
   86|      2|            case Type::LabelAlreadyDefined: {
  ------------------
  |  Branch (86:13): [True: 2, False: 161]
  ------------------
   87|      2|                const LabelAlreadyDefined& detail = GetLabelAlreadyDefined();
   88|       |
   89|      2|                return fmt::format("Label '{:s}' was already defined at {:d}:{:d}",
   90|      2|                                   detail.label_name.data(), detail.at_line, detail.at_column);
   91|      0|            }
   92|       |
   93|      0|            case Type::OneInstructionPerLine: {
  ------------------
  |  Branch (93:13): [True: 0, False: 163]
  ------------------
   94|      0|                return fmt::format("You may only place one instruction per line");
   95|      0|            }
   96|       |
   97|      0|            case Type::TooFewArgument: {
  ------------------
  |  Branch (97:13): [True: 0, False: 163]
  ------------------
   98|      0|                const TooFewArguments& detail = GetTooFewArguments();
   99|       |
  100|      0|                return fmt::format(
  101|      0|                        "Not enough arguments provided. Required {:d}, provided only {:d}",
  102|      0|                        detail.required, detail.provided);
  103|      0|            }
  104|       |
  105|      5|            case Type::EmptyLabel: {
  ------------------
  |  Branch (105:13): [True: 5, False: 158]
  ------------------
  106|      5|                const EmptyLabel& detail = GetEmptyLabel();
  107|       |
  108|      5|                return fmt::format("Label '{:s}' does not have any instruction",
  109|      5|                                   detail.label_name.data());
  110|      0|            }
  111|       |
  112|      0|            case Type::TooManyComma: {
  ------------------
  |  Branch (112:13): [True: 0, False: 163]
  ------------------
  113|      0|                return fmt::format("Only one comma is allowed");
  114|      0|            }
  115|       |
  116|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  117|      0|            default:
  ------------------
  |  Branch (117:13): [True: 0, False: 163]
  ------------------
  118|      0|                PHI_ASSERT_NOT_REACHED();
  119|    163|#endif
  120|    163|        }
  121|    163|    }
_ZNK3dlx10ParseError18GetUnexpectedTokenEv:
  144|     24|    {
  145|     24|        PHI_ASSERT(m_Type == Type::UnexpectedToken);
  146|       |
  147|     24|        return unexpected_token;
  148|     24|    }
_ZNK3dlx10ParseError25GetInvalidLabelIdentifierEv:
  160|    132|    {
  161|    132|        PHI_ASSERT(m_Type == Type::InvalidLabelIdentifier);
  162|       |
  163|    132|        return invalid_label_identifier;
  164|    132|    }
_ZNK3dlx10ParseError22GetLabelAlreadyDefinedEv:
  168|      2|    {
  169|      2|        PHI_ASSERT(m_Type == Type::LabelAlreadyDefined);
  170|       |
  171|      2|        return label_already_defined;
  172|      2|    }
_ZNK3dlx10ParseError13GetEmptyLabelEv:
  183|      5|    {
  184|      5|        PHI_ASSERT(m_Type == Type::EmptyLabel);
  185|       |
  186|      5|        return empty_label;
  187|      5|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorEmmNS_5Token4TypeES1_:
  256|     24|    {
  257|     24|        ParseError err;
  258|       |
  259|     24|        err.m_Type                         = ParseError::Type::UnexpectedToken;
  260|     24|        err.m_LineNumber                   = line_number;
  261|     24|        err.m_Column                       = column;
  262|     24|        err.unexpected_token.expected_type = expected_type;
  263|     24|        err.unexpected_token.actual_type   = actual_type;
  264|       |
  265|     24|        return err;
  266|     24|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorERKNS_5TokenENS0_4TypeE:
  270|     24|    {
  271|     24|        return ConstructUnexpectedTokenParseError(token.GetLineNumber().unsafe(),
  272|     24|                                                  token.GetColumn().unsafe(), expected_type,
  273|     24|                                                  token.GetType());
  274|     24|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  297|    132|    {
  298|    132|        ParseError err;
  299|       |
  300|    132|        err.m_Type                             = ParseError::Type::InvalidLabelIdentifier;
  301|    132|        err.m_LineNumber                       = line_number;
  302|    132|        err.m_Column                           = column;
  303|    132|        err.invalid_label_identifier.identifer = identifier;
  304|       |
  305|    132|        return err;
  306|    132|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorERKNS_5TokenE:
  310|    132|    {
  311|    132|        return ConstructInvalidLabelIdentifierParseError(
  312|    132|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText());
  313|    132|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEEmm:
  318|      2|    {
  319|      2|        ParseError err;
  320|       |
  321|      2|        err.m_Type                           = ParseError::Type::LabelAlreadyDefined;
  322|      2|        err.m_LineNumber                     = line_number;
  323|      2|        err.m_Column                         = column;
  324|      2|        err.label_already_defined.label_name = label_name;
  325|      2|        err.label_already_defined.at_line    = at_line;
  326|      2|        err.label_already_defined.at_column  = at_column;
  327|       |
  328|      2|        return err;
  329|      2|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorERKNS_5TokenES2_:
  333|      2|    {
  334|      2|        return ConstructLabelAlreadyDefinedParseError(
  335|      2|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText(),
  336|      2|                first_definition.GetLineNumber().unsafe(), first_definition.GetColumn().unsafe());
  337|      2|    }
_ZN3dlx29ConstructEmptyLabelParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  382|      5|    {
  383|      5|        ParseError err;
  384|       |
  385|      5|        err.m_Type                 = ParseError::Type::EmptyLabel;
  386|      5|        err.m_LineNumber           = line_number;
  387|      5|        err.m_Column               = column;
  388|      5|        err.empty_label.label_name = label_name;
  389|       |
  390|      5|        return err;
  391|      5|    }
_ZN3dlx29ConstructEmptyLabelParseErrorERKNS_5TokenE:
  394|      5|    {
  395|      5|        return ConstructEmptyLabelParseError(
  396|      5|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(),
  397|      5|                (token.GetText().back() == ':') ?
  ------------------
  |  Branch (397:17): [True: 4, False: 1]
  ------------------
  398|      4|                        token.GetText().substring_view(0u, token.GetText().length() - 1u) :
  399|      5|                        token.GetText());
  400|      5|    }

_ZN3dlx13ParsedProgram13AddParseErrorEONS_10ParseErrorE:
   18|    163|    {
   19|    163|        m_ParseErrors.emplace_back(phi::move(error));
   20|    163|    }
_ZNK3dlx13ParsedProgram7IsValidEv:
   23|    878|    {
   24|    878|        return m_ParseErrors.empty() && !m_Instructions.empty();
  ------------------
  |  Branch (24:16): [True: 289, False: 589]
  |  Branch (24:41): [True: 0, False: 289]
  ------------------
   25|    878|    }

_ZN3dlx6Parser5ParseERNS_11TokenStreamE:
  180|     83|    {
  181|     83|        ParsedProgram program;
  182|       |
  183|     83|        program.m_Tokens = tokens;
  184|       |
  185|     83|        phi::boolean line_has_instruction{false};
  186|     83|        phi::usize   label_count{0u};
  187|       |
  188|    756|        while (tokens.has_more())
  ------------------
  |  Branch (188:16): [True: 673, False: 83]
  ------------------
  189|    673|        {
  190|    673|            const Token& current_token = tokens.consume();
  191|       |
  192|       |            //DLX_INFO("Parsing '{}'", current_token.DebugInfo());
  193|       |
  194|    673|            switch (current_token.GetType())
  195|    673|            {
  196|       |                // Ignore comments
  197|      4|                case Token::Type::Comment:
  ------------------
  |  Branch (197:17): [True: 4, False: 669]
  ------------------
  198|       |                    //DLX_DEBUG("Ignoring comment");
  199|      4|                    break;
  200|       |
  201|    506|                case Token::Type::NewLine:
  ------------------
  |  Branch (201:17): [True: 506, False: 167]
  ------------------
  202|       |                    //DLX_DEBUG("Ignoring newline");
  203|    506|                    line_has_instruction = false;
  204|    506|                    break;
  205|       |
  206|    139|                case Token::Type::LabelIdentifier: {
  ------------------
  |  Branch (206:17): [True: 139, False: 534]
  ------------------
  207|    139|                    if (line_has_instruction)
  ------------------
  |  Branch (207:25): [True: 0, False: 139]
  ------------------
  208|      0|                    {
  209|      0|                        program.AddParseError(ConstructUnexpectedTokenParseError(
  210|      0|                                current_token, Token::Type::NewLine));
  211|      0|                        break;
  212|      0|                    }
  213|       |
  214|       |                    // Handle jump labels
  215|       |                    // Check if the last character of the identifier is a colon
  216|    139|                    if (current_token.GetText().back() != ':')
  ------------------
  |  Branch (216:25): [True: 98, False: 41]
  ------------------
  217|     98|                    {
  218|     98|                        program.AddParseError(
  219|     98|                                ConstructInvalidLabelIdentifierParseError(current_token));
  220|     98|                        break;
  221|     98|                    }
  222|       |
  223|     41|                    phi::string_view label_name = current_token.GetText();
  224|     41|                    label_name.remove_suffix(1u);
  225|       |
  226|     41|                    if (IsReservedIdentifier(label_name))
  ------------------
  |  Branch (226:25): [True: 0, False: 41]
  ------------------
  227|      0|                    {
  228|      0|                        program.AddParseError(ConstructReservedIdentiferParseError(
  229|      0|                                current_token.GetLineNumber().unsafe(),
  230|      0|                                current_token.GetColumn().unsafe(), label_name));
  231|      0|                        break;
  232|      0|                    }
  233|       |
  234|     41|                    if (!IsValidIdentifier(label_name))
  ------------------
  |  Branch (234:25): [True: 34, False: 7]
  ------------------
  235|     34|                    {
  236|     34|                        program.AddParseError(
  237|     34|                                ConstructInvalidLabelIdentifierParseError(current_token));
  238|     34|                        break;
  239|     34|                    }
  240|       |
  241|       |                    // Check if label was already defined
  242|      7|                    if (program.m_JumpData.find(label_name) != program.m_JumpData.end())
  ------------------
  |  Branch (242:25): [True: 2, False: 5]
  ------------------
  243|      2|                    {
  244|       |                        // Find first defintions of label
  245|      2|                        const Token* first_label_definition =
  246|      2|                                tokens.find_first_token_if([&](const Token& t) {
  247|      2|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  248|      2|                                    {
  249|      2|                                        phi::string_view token_label_name = t.GetText();
  250|      2|                                        token_label_name.remove_suffix(1u);
  251|       |
  252|      2|                                        if (token_label_name == label_name)
  253|      2|                                        {
  254|      2|                                            return true;
  255|      2|                                        }
  256|      2|                                    }
  257|       |
  258|      2|                                    return false;
  259|      2|                                });
  260|       |
  261|      2|                        PHI_ASSERT(first_label_definition);
  262|       |
  263|      2|                        program.AddParseError(ConstructLabelAlreadyDefinedParseError(
  264|      2|                                current_token, *first_label_definition));
  265|      2|                        break;
  266|      2|                    }
  267|       |
  268|      5|                    program.m_JumpData[label_name] =
  269|      5|                            static_cast<std::uint32_t>(program.m_Instructions.size());
  270|      5|                    label_count += 1u;
  271|       |
  272|       |                    //DLX_INFO("Added jump label {} -> {}", label_name,
  273|       |                    //             program.m_Instructions.size());
  274|       |
  275|      5|                    break;
  276|      7|                }
  277|       |
  278|      0|                case Token::Type::OpCode: {
  ------------------
  |  Branch (278:17): [True: 0, False: 673]
  ------------------
  279|      0|                    if (line_has_instruction)
  ------------------
  |  Branch (279:25): [True: 0, False: 0]
  ------------------
  280|      0|                    {
  281|      0|                        program.AddParseError(
  282|      0|                                ConstructOneInstructionPerLineParseError(current_token));
  283|      0|                        break;
  284|      0|                    }
  285|       |
  286|      0|                    label_count = 0u;
  287|       |
  288|       |                    // Handle normal instructions
  289|      0|                    PHI_ASSERT(current_token.HasHint());
  290|      0|                    OpCode opcode = static_cast<OpCode>(current_token.GetHint());
  291|       |
  292|       |                    //DLX_INFO("Instruction opcode: {}", dlx::enum_name(opcode));
  293|       |
  294|      0|                    const InstructionInfo& info = LookUpIntructionInfo(opcode);
  295|       |
  296|       |                    // Make sure we got no problems here
  297|      0|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  298|      0|                    PHI_ASSERT(info.GetArgumentType(1_u8) != ArgumentType::Unknown);
  299|      0|                    PHI_ASSERT(info.GetArgumentType(2_u8) != ArgumentType::Unknown);
  300|      0|                    PHI_ASSERT(info.GetExecutor());
  301|       |
  302|      0|                    const phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  303|       |                    //DLX_INFO("Instruction requires {} arguments",
  304|       |                    //             number_of_argument_required.unsafe());
  305|       |
  306|       |                    // Create instruction
  307|      0|                    Instruction  instruction(info, current_token.GetLineNumber());
  308|      0|                    phi::boolean consumed_comma{false};
  309|       |
  310|       |                    // Parse arguments
  311|      0|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  ------------------
  |  Branch (311:54): [True: 0, False: 0]
  ------------------
  312|      0|                    {
  313|       |                        // Get next token
  314|      0|                        if (!tokens.has_more())
  ------------------
  |  Branch (314:29): [True: 0, False: 0]
  ------------------
  315|      0|                        {
  316|      0|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  317|      0|                                    current_token, number_of_argument_required.unsafe(),
  318|      0|                                    argument_num.unsafe()));
  319|      0|                            break;
  320|      0|                        }
  321|       |
  322|      0|                        const Token& token = tokens.consume();
  323|       |
  324|       |                        // Skip commas
  325|      0|                        if (token.GetType() == Token::Type::Comma)
  ------------------
  |  Branch (325:29): [True: 0, False: 0]
  ------------------
  326|      0|                        {
  327|      0|                            if (consumed_comma)
  ------------------
  |  Branch (327:33): [True: 0, False: 0]
  ------------------
  328|      0|                            {
  329|      0|                                program.AddParseError(ConstructTooManyCommaParseError(token));
  330|      0|                            }
  331|       |
  332|      0|                            consumed_comma = true;
  333|       |                            //DLX_DEBUG("Skipping comma");
  334|      0|                            continue;
  335|      0|                        }
  336|       |
  337|      0|                        if (token.GetType() == Token::Type::NewLine)
  ------------------
  |  Branch (337:29): [True: 0, False: 0]
  ------------------
  338|      0|                        {
  339|      0|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  340|      0|                                    token, number_of_argument_required.unsafe(),
  341|      0|                                    argument_num.unsafe()));
  342|      0|                            break;
  343|      0|                        }
  344|       |
  345|      0|                        phi::optional<InstructionArgument> optional_parsed_argument =
  346|      0|                                parse_instruction_argument(
  347|      0|                                        token, info.GetArgumentType(argument_num), tokens, program);
  348|      0|                        if (!optional_parsed_argument.has_value())
  ------------------
  |  Branch (348:29): [True: 0, False: 0]
  ------------------
  349|      0|                        {
  350|       |                            // The parse_instruction_argument function should already have added a parse error with more detail
  351|      0|                            break;
  352|      0|                        }
  353|       |
  354|       |                        // Successfully parsed one argument
  355|      0|                        InstructionArgument parsed_argument = optional_parsed_argument.value();
  356|       |
  357|      0|                        instruction.SetArgument(argument_num, parsed_argument);
  358|      0|                        argument_num++;
  359|      0|                        consumed_comma = false;
  360|       |
  361|       |                        //DLX_INFO("Successfully parsed argument {}", argument_num.unsafe());
  362|      0|                    }
  363|       |
  364|       |                    //DLX_INFO("Successfully parsed instruction '{}'",
  365|       |                    //            instruction.DebugInfo());
  366|      0|                    program.m_Instructions.emplace_back(instruction);
  367|      0|                    line_has_instruction = true;
  368|      0|                    break;
  369|      0|                }
  370|       |
  371|     24|                default:
  ------------------
  |  Branch (371:17): [True: 24, False: 649]
  ------------------
  372|     24|                    Token::Type expected_token_type = Token::Type::Unknown;
  373|     24|                    if (line_has_instruction)
  ------------------
  |  Branch (373:25): [True: 0, False: 24]
  ------------------
  374|      0|                    {
  375|      0|                        expected_token_type = Token::Type::NewLine;
  376|      0|                    }
  377|       |
  378|     24|                    program.AddParseError(
  379|     24|                            ConstructUnexpectedTokenParseError(current_token, expected_token_type));
  380|     24|                    break;
  381|    673|            }
  382|    673|        }
  383|       |
  384|       |        // Check for empty labels
  385|     83|        if (label_count > 0u)
  ------------------
  |  Branch (385:13): [True: 1, False: 82]
  ------------------
  386|      1|        {
  387|      7|            for (auto it = tokens.rbegin(); label_count > 0u; ++it)
  ------------------
  |  Branch (387:45): [True: 6, False: 1]
  ------------------
  388|      6|            {
  389|      6|                PHI_ASSERT(it != tokens.rend(), "Iterator should never reach the end");
  390|       |
  391|      6|                const Token& token = *it;
  392|      6|                if (token.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (392:21): [True: 5, False: 1]
  ------------------
  393|      5|                {
  394|      5|                    program.AddParseError(ConstructEmptyLabelParseError(token));
  395|      5|                    --label_count;
  396|      5|                }
  397|      6|            }
  398|      1|        }
  399|       |
  400|     83|        return program;
  401|     83|    }
_ZN3dlx6Parser5ParseEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  404|     83|    {
  405|     83|        TokenStream tokens = Tokenize(source);
  406|     83|        return Parse(tokens);
  407|     83|    }
Parser.cpp:_ZZN3dlx6Parser5ParseERNS_11TokenStreamEENK3$_0clERKNS_5TokenE:
  246|      6|                                tokens.find_first_token_if([&](const Token& t) {
  247|      6|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (247:41): [True: 6, False: 0]
  ------------------
  248|      6|                                    {
  249|      6|                                        phi::string_view token_label_name = t.GetText();
  250|      6|                                        token_label_name.remove_suffix(1u);
  251|       |
  252|      6|                                        if (token_label_name == label_name)
  ------------------
  |  Branch (252:45): [True: 2, False: 4]
  ------------------
  253|      2|                                        {
  254|      2|                                            return true;
  255|      2|                                        }
  256|      6|                                    }
  257|       |
  258|      4|                                    return false;
  259|      6|                                });

_ZN3dlx9ProcessorC2Ev:
   64|  9.34k|    {
   65|       |        // Mark R0 as ready only
   66|  9.34k|        m_IntRegisters[0].SetReadOnly(true);
   67|  9.34k|    }
_ZN3dlx9Processor11LoadProgramERNS_13ParsedProgramE:
  353|     21|    {
  354|     21|        if (!program.m_ParseErrors.empty())
  ------------------
  |  Branch (354:13): [True: 0, False: 21]
  ------------------
  355|      0|        {
  356|      0|            DLX_WARN("Trying to load program with parsing errors");
  ------------------
  |  |    8|      0|#define DLX_WARN(...)     PHI_EMPTY_MACRO()
  ------------------
  357|      0|            return false;
  358|      0|        }
  359|       |
  360|     21|        m_CurrentProgram = &program;
  361|       |
  362|     21|        m_ProgramCounter               = 0u;
  363|     21|        m_Halted                       = false;
  364|     21|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  365|     21|        m_LastRaisedException          = Exception::None;
  366|     21|        m_CurrentStepCount             = 0u;
  367|       |
  368|     21|        return true;
  369|     21|    }

_ZN3dlx19StringToIntRegisterEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   12|    180|    {
   13|    180|        if (token.length() == 2u)
  ------------------
  |  Branch (13:13): [True: 4, False: 176]
  ------------------
   14|      4|        {
   15|      4|            const char first_char = token[0u];
   16|      4|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (16:17): [True: 0, False: 4]
  |  Branch (16:38): [True: 0, False: 4]
  ------------------
   17|      0|            {
   18|      0|                const char second_char = token[1u];
   19|      0|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (19:21): [True: 0, False: 0]
  |  Branch (19:43): [True: 0, False: 0]
  ------------------
   20|      0|                {
   21|      0|                    return static_cast<IntRegisterID>(second_char - '0');
   22|      0|                }
   23|      0|            }
   24|      4|        }
   25|    176|        else if (token.length() == 3u)
  ------------------
  |  Branch (25:18): [True: 89, False: 87]
  ------------------
   26|     89|        {
   27|     89|            const char first_char = token[0u];
   28|     89|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (28:17): [True: 0, False: 89]
  |  Branch (28:38): [True: 0, False: 89]
  ------------------
   29|      0|            {
   30|      0|                const char second_char = token[1u];
   31|      0|                const char third_char  = token[2u];
   32|       |
   33|      0|                switch (second_char)
   34|      0|                {
   35|      0|                    case '1': {
  ------------------
  |  Branch (35:21): [True: 0, False: 0]
  ------------------
   36|      0|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (36:29): [True: 0, False: 0]
  |  Branch (36:50): [True: 0, False: 0]
  ------------------
   37|      0|                        {
   38|      0|                            return static_cast<IntRegisterID>(third_char - '0' + 10);
   39|      0|                        }
   40|      0|                        break;
   41|      0|                    }
   42|      0|                    case '2': {
  ------------------
  |  Branch (42:21): [True: 0, False: 0]
  ------------------
   43|      0|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (43:29): [True: 0, False: 0]
  |  Branch (43:50): [True: 0, False: 0]
  ------------------
   44|      0|                        {
   45|      0|                            return static_cast<IntRegisterID>(third_char - '0' + 20);
   46|      0|                        }
   47|      0|                        break;
   48|      0|                    }
   49|      0|                    case '3': {
  ------------------
  |  Branch (49:21): [True: 0, False: 0]
  ------------------
   50|      0|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (50:29): [True: 0, False: 0]
  |  Branch (50:50): [True: 0, False: 0]
  ------------------
   51|      0|                        {
   52|      0|                            return static_cast<IntRegisterID>(third_char - '0' + 30);
   53|      0|                        }
   54|      0|                        break;
   55|      0|                    }
   56|      0|                    default: {
  ------------------
  |  Branch (56:21): [True: 0, False: 0]
  ------------------
   57|      0|                        break;
   58|      0|                    }
   59|      0|                }
   60|      0|            }
   61|     89|        }
   62|       |
   63|    180|        return IntRegisterID::None;
   64|    180|    }
_ZN3dlx21StringToFloatRegisterEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   67|    180|    {
   68|    180|        if (token.length() == 2u)
  ------------------
  |  Branch (68:13): [True: 4, False: 176]
  ------------------
   69|      4|        {
   70|      4|            const char first_char = token[0u];
   71|      4|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (71:17): [True: 0, False: 4]
  |  Branch (71:38): [True: 0, False: 4]
  ------------------
   72|      0|            {
   73|      0|                const char second_char = token[1u];
   74|      0|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (74:21): [True: 0, False: 0]
  |  Branch (74:43): [True: 0, False: 0]
  ------------------
   75|      0|                {
   76|      0|                    return static_cast<FloatRegisterID>(second_char - '0');
   77|      0|                }
   78|      0|            }
   79|      4|        }
   80|    176|        else if (token.length() == 3u)
  ------------------
  |  Branch (80:18): [True: 89, False: 87]
  ------------------
   81|     89|        {
   82|     89|            const char first_char = token[0u];
   83|     89|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (83:17): [True: 0, False: 89]
  |  Branch (83:38): [True: 0, False: 89]
  ------------------
   84|      0|            {
   85|      0|                const char second_char = token[1u];
   86|      0|                const char third_char  = token[2u];
   87|       |
   88|      0|                switch (second_char)
   89|      0|                {
   90|      0|                    case '1': {
  ------------------
  |  Branch (90:21): [True: 0, False: 0]
  ------------------
   91|      0|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (91:29): [True: 0, False: 0]
  |  Branch (91:50): [True: 0, False: 0]
  ------------------
   92|      0|                        {
   93|      0|                            return static_cast<FloatRegisterID>(third_char - '0' + 10);
   94|      0|                        }
   95|      0|                        break;
   96|      0|                    }
   97|      0|                    case '2': {
  ------------------
  |  Branch (97:21): [True: 0, False: 0]
  ------------------
   98|      0|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (98:29): [True: 0, False: 0]
  |  Branch (98:50): [True: 0, False: 0]
  ------------------
   99|      0|                        {
  100|      0|                            return static_cast<FloatRegisterID>(third_char - '0' + 20);
  101|      0|                        }
  102|      0|                        break;
  103|      0|                    }
  104|      0|                    case '3': {
  ------------------
  |  Branch (104:21): [True: 0, False: 0]
  ------------------
  105|      0|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (105:29): [True: 0, False: 0]
  |  Branch (105:50): [True: 0, False: 0]
  ------------------
  106|      0|                        {
  107|      0|                            return static_cast<FloatRegisterID>(third_char - '0' + 30);
  108|      0|                        }
  109|      0|                        break;
  110|      0|                    }
  111|      0|                    default: {
  ------------------
  |  Branch (111:21): [True: 0, False: 0]
  ------------------
  112|      0|                        break;
  113|      0|                    }
  114|      0|                }
  115|      0|            }
  116|     89|        }
  117|       |
  118|    180|        return FloatRegisterID::None;
  119|    180|    }
_ZN3dlx6IsFPSREN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  122|    180|    {
  123|    180|        if (token.length() == 4u)
  ------------------
  |  Branch (123:13): [True: 6, False: 174]
  ------------------
  124|      6|        {
  125|      6|            const char c1 = token[0u];
  126|      6|            const char c2 = token[1u];
  127|      6|            const char c3 = token[2u];
  128|      6|            const char c4 = token[3u];
  129|       |
  130|      6|            return (c1 == 'F' || c1 == 'f') && (c2 == 'P' || c2 == 'p') &&
  ------------------
  |  Branch (130:21): [True: 0, False: 6]
  |  Branch (130:34): [True: 0, False: 6]
  |  Branch (130:49): [True: 0, False: 0]
  |  Branch (130:62): [True: 0, False: 0]
  ------------------
  131|      6|                   (c3 == 'S' || c3 == 's') && (c4 == 'R' || c4 == 'r');
  ------------------
  |  Branch (131:21): [True: 0, False: 0]
  |  Branch (131:34): [True: 0, False: 0]
  |  Branch (131:49): [True: 0, False: 0]
  |  Branch (131:62): [True: 0, False: 0]
  ------------------
  132|      6|        }
  133|       |
  134|    174|        return false;
  135|    180|    }

_ZN3dlx5TokenC2ENS0_4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS2_7integerImEES9_:
   27|    665|    {}
_ZN3dlx5TokenC2ENS0_4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS2_7integerImEES9_j:
   37|      8|    {}
_ZNK3dlx5Token7GetTypeEv:
   40|  1.38k|    {
   41|  1.38k|        return m_Type;
   42|  1.38k|    }
_ZNK3dlx5Token13GetLineNumberEv:
   50|    499|    {
   51|    499|        return m_LineNumber;
   52|    499|    }
_ZNK3dlx5Token9GetColumnEv:
   55|  1.16k|    {
   56|  1.16k|        return m_Column;
   57|  1.16k|    }
_ZNK3dlx5Token9GetLengthEv:
   60|    830|    {
   61|    830|        return m_Text.length();
   62|    830|    }
_ZNK3dlx5Token7GetTextEv:
   65|    334|    {
   66|    334|        return m_Text;
   67|    334|    }

_ZN3dlx11TokenStream8finalizeEv:
   29|     83|    {
   30|       |#if defined(PHI_DEBUG)
   31|       |        PHI_ASSERT(!m_Finialized);
   32|       |#endif
   33|       |
   34|     83|        m_Iterator = m_Tokens.begin();
   35|       |#if defined(PHI_DEBUG)
   36|       |        m_Finialized = true;
   37|       |#endif
   38|     83|    }
_ZNK3dlx11TokenStream8has_moreEv:
   64|    756|    {
   65|    756|        return m_Iterator != m_Tokens.end();
   66|    756|    }
_ZNK3dlx11TokenStream11reached_endEv:
   69|    673|    {
   70|    673|        return m_Iterator == m_Tokens.end();
   71|    673|    }
_ZN3dlx11TokenStream7consumeEv:
   84|    673|    {
   85|    673|        PHI_ASSERT(!reached_end());
   86|       |#if defined(PHI_DEBUG)
   87|       |        PHI_ASSERT(m_Finialized);
   88|       |#endif
   89|       |
   90|    673|        return *m_Iterator++;
   91|    673|    }
_ZNK3dlx11TokenStream5beginEv:
  182|     83|    {
  183|       |#if defined(PHI_DEBUG)
  184|       |        //PHI_ASSERT(m_Finialized);
  185|       |#endif
  186|       |
  187|     83|        return m_Tokens.begin();
  188|     83|    }
_ZNK3dlx11TokenStream3endEv:
  200|     83|    {
  201|       |#if defined(PHI_DEBUG)
  202|       |        //PHI_ASSERT(m_Finialized);
  203|       |#endif
  204|       |
  205|     83|        return m_Tokens.end();
  206|     83|    }
_ZNK3dlx11TokenStream6rbeginEv:
  218|      1|    {
  219|       |#if defined(PHI_DEBUG)
  220|       |        //PHI_ASSERT(m_Finialized);
  221|       |#endif
  222|       |
  223|      1|        return m_Tokens.rbegin();
  224|      1|    }
_ZNK3dlx11TokenStream4rendEv:
  227|      6|    {
  228|       |#if defined(PHI_DEBUG)
  229|       |        //PHI_ASSERT(m_Finialized);
  230|       |#endif
  231|       |
  232|      6|        return m_Tokens.rend();
  233|      6|    }

_ZN3dlx8TokenizeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   65|     83|    {
   66|     83|        TokenStream tokens;
   67|       |
   68|     83|        phi::string_view current_token;
   69|       |
   70|     83|        phi::u64 current_line_number{1u};
   71|     83|        phi::u64 current_column{1u};
   72|     83|        phi::u64 token_begin{0u};
   73|       |
   74|     83|        phi::boolean parsing_comment{false};
   75|       |
   76|  1.41k|        for (phi::usize i{0u}; i < source.length(); ++i)
  ------------------
  |  Branch (76:32): [True: 1.33k, False: 83]
  ------------------
   77|  1.33k|        {
   78|  1.33k|            const char c{source.at(i)};
   79|       |
   80|  1.33k|            if (c == '\n')
  ------------------
  |  Branch (80:17): [True: 506, False: 829]
  ------------------
   81|    506|            {
   82|    506|                if (current_token.is_empty())
  ------------------
  |  Branch (82:21): [True: 422, False: 84]
  ------------------
   83|    422|                {
   84|       |                    // Skip empty lines
   85|    422|                    tokens.emplace_back(Token::Type::NewLine, source.substring_view(i, 1u),
   86|    422|                                        current_line_number, current_column);
   87|       |
   88|    422|                    parsing_comment = false;
   89|    422|                    current_line_number += 1u;
   90|    422|                    current_column = 1u;
   91|    422|                    continue;
   92|    422|                }
   93|       |
   94|       |                // Otherwise a new line separates tokens
   95|     84|                tokens.emplace_back(ParseToken(
   96|     84|                        source.substring_view(
   97|     84|                                phi::narrow_cast<phi::string_view::size_type>(token_begin),
   98|     84|                                current_token.length()),
   99|     84|                        current_line_number, current_column - current_token.length()));
  100|       |
  101|     84|                tokens.emplace_back(Token::Type::NewLine, source.substring_view(i, 1u),
  102|     84|                                    current_line_number, current_column);
  103|       |
  104|     84|                current_token   = phi::string_view{};
  105|     84|                parsing_comment = false;
  106|     84|                current_line_number += 1u;
  107|     84|                current_column = 0u;
  108|     84|            }
  109|       |            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  110|    829|            else if (c == '/' || c == ';')
  ------------------
  |  Branch (110:22): [True: 0, False: 829]
  |  Branch (110:34): [True: 4, False: 825]
  ------------------
  111|      4|            {
  112|      4|                if (current_token.is_empty())
  ------------------
  |  Branch (112:21): [True: 2, False: 2]
  ------------------
  113|      2|                {
  114|      2|                    token_begin = i;
  115|      2|                }
  116|      2|                else if (!parsing_comment)
  ------------------
  |  Branch (116:26): [True: 2, False: 0]
  ------------------
  117|      2|                {
  118|      2|                    tokens.emplace_back(ParseToken(
  119|      2|                            source.substring_view(
  120|      2|                                    phi::narrow_cast<phi::string_view::size_type>(token_begin),
  121|      2|                                    current_token.length()),
  122|      2|                            current_line_number, current_column - current_token.length()));
  123|      2|                    token_begin   = i;
  124|      2|                    current_token = phi::string_view{};
  125|      2|                }
  126|       |
  127|      4|                parsing_comment = true;
  128|      4|                current_token   = source.substring_view(
  129|      4|                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  130|      4|                        current_token.length() + 1u);
  131|      4|            }
  132|    825|            else if (parsing_comment)
  ------------------
  |  Branch (132:22): [True: 0, False: 825]
  ------------------
  133|      0|            {
  134|       |                // simply append the character
  135|      0|                current_token = source.substring_view(
  136|      0|                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  137|      0|                        current_token.length() + 1u);
  138|      0|            }
  139|    825|            else
  140|    825|            {
  141|       |                // Not parsing a comment
  142|    825|                switch (c)
  143|    825|                {
  144|      0|                    case ' ':
  ------------------
  |  Branch (144:21): [True: 0, False: 825]
  ------------------
  145|    166|                    case '\t':
  ------------------
  |  Branch (145:21): [True: 166, False: 659]
  ------------------
  146|    166|                    case '\v':
  ------------------
  |  Branch (146:21): [True: 0, False: 825]
  ------------------
  147|    166|                        if (current_token.is_empty())
  ------------------
  |  Branch (147:29): [True: 166, False: 0]
  ------------------
  148|    166|                        {
  149|    166|                            current_column += 1u;
  150|       |                            // We haven't found any usable character for the current token so just skip the whitespace.
  151|    166|                            continue;
  152|    166|                        }
  153|       |
  154|       |                        // Otherwise a whitespace separates tokens
  155|      0|                        tokens.emplace_back(ParseToken(
  156|      0|                                source.substring_view(
  157|      0|                                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  158|      0|                                        current_token.length()),
  159|      0|                                current_line_number, current_column - current_token.length()));
  160|      0|                        current_token = phi::string_view{};
  161|      0|                        break;
  162|     41|                    case ':':
  ------------------
  |  Branch (162:21): [True: 41, False: 784]
  ------------------
  163|       |                        // Need to parse label names together with their colon
  164|     41|                        if (!current_token.is_empty())
  ------------------
  |  Branch (164:29): [True: 41, False: 0]
  ------------------
  165|     41|                        {
  166|     41|                            current_token = source.substring_view(
  167|     41|                                    phi::narrow_cast<phi::string_view::size_type>(token_begin),
  168|     41|                                    current_token.length() + 1u);
  169|     41|                            tokens.emplace_back(ParseToken(
  170|     41|                                    source.substring_view(
  171|     41|                                            phi::narrow_cast<phi::string_view::size_type>(
  172|     41|                                                    token_begin),
  173|     41|                                            current_token.length()),
  174|     41|                                    current_line_number,
  175|     41|                                    current_column + 1u - current_token.length()));
  176|       |
  177|     41|                            current_token = phi::string_view{};
  178|     41|                        }
  179|      0|                        else
  180|      0|                        {
  181|       |                            // Orphan colon
  182|      0|                            token_begin = i;
  183|       |
  184|      0|                            tokens.emplace_back(
  185|      0|                                    Token::Type::Colon,
  186|      0|                                    source.substring_view(
  187|      0|                                            phi::narrow_cast<phi::string_view::size_type>(
  188|      0|                                                    token_begin),
  189|      0|                                            1u),
  190|      0|                                    current_line_number, current_column);
  191|      0|                        }
  192|     41|                        break;
  193|      8|                    case ',':
  ------------------
  |  Branch (193:21): [True: 8, False: 817]
  ------------------
  194|     16|                    case '(':
  ------------------
  |  Branch (194:21): [True: 8, False: 817]
  ------------------
  195|     16|                    case ')':
  ------------------
  |  Branch (195:21): [True: 0, False: 825]
  ------------------
  196|     16|                        if (!current_token.is_empty())
  ------------------
  |  Branch (196:29): [True: 6, False: 10]
  ------------------
  197|      6|                        {
  198|      6|                            tokens.emplace_back(ParseToken(
  199|      6|                                    source.substring_view(
  200|      6|                                            phi::narrow_cast<phi::string_view::size_type>(
  201|      6|                                                    token_begin),
  202|      6|                                            current_token.length()),
  203|      6|                                    current_line_number, current_column - current_token.length()));
  204|       |
  205|      6|                            current_token = phi::string_view{};
  206|      6|                        }
  207|       |
  208|     16|                        Token::Type type;
  209|     16|                        switch (c)
  210|     16|                        {
  211|      8|                            case ',':
  ------------------
  |  Branch (211:29): [True: 8, False: 8]
  ------------------
  212|      8|                                type = Token::Type::Comma;
  213|      8|                                break;
  214|      8|                            case '(':
  ------------------
  |  Branch (214:29): [True: 8, False: 8]
  ------------------
  215|      8|                                type = Token::Type::OpenBracket;
  216|      8|                                break;
  217|      0|                            case ')':
  ------------------
  |  Branch (217:29): [True: 0, False: 16]
  ------------------
  218|      0|                                type = Token::Type::ClosingBracket;
  219|      0|                                break;
  220|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  221|      0|                            default:
  ------------------
  |  Branch (221:29): [True: 0, False: 16]
  ------------------
  222|      0|                                PHI_ASSERT_NOT_REACHED();
  223|      0|                                break;
  224|     16|#endif
  225|     16|                        }
  226|       |
  227|     16|                        token_begin = i;
  228|       |
  229|     16|                        tokens.emplace_back(
  230|     16|                                type,
  231|     16|                                source.substring_view(
  232|     16|                                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  233|     16|                                        1u),
  234|     16|                                current_line_number, current_column);
  235|     16|                        break;
  236|       |
  237|    602|                    default:
  ------------------
  |  Branch (237:21): [True: 602, False: 223]
  ------------------
  238|    602|                        if (current_token.is_empty())
  ------------------
  |  Branch (238:29): [True: 147, False: 455]
  ------------------
  239|    147|                        {
  240|    147|                            token_begin = i;
  241|    147|                        }
  242|       |
  243|       |                        // simply append the character
  244|    602|                        current_token = source.substring_view(
  245|    602|                                phi::narrow_cast<phi::string_view::size_type>(token_begin),
  246|    602|                                current_token.length() + 1u);
  247|    825|                }
  248|    825|            }
  249|       |
  250|    747|            current_column += 1u;
  251|    747|        }
  252|       |
  253|       |        // Checked the entire string. Parse whats left if anything
  254|     83|        if (!current_token.is_empty())
  ------------------
  |  Branch (254:13): [True: 18, False: 65]
  ------------------
  255|     18|        {
  256|     18|            tokens.emplace_back(
  257|     18|                    ParseToken(source.substring_view(
  258|     18|                                       phi::narrow_cast<phi::string_view::size_type>(token_begin),
  259|     18|                                       current_token.length()),
  260|     18|                               current_line_number, current_column - current_token.length()));
  261|     18|        }
  262|       |
  263|       |        // Finialize token stream
  264|     83|        tokens.finalize();
  265|       |
  266|     83|        return tokens;
  267|     83|    }
Tokenize.cpp:_ZN3dlxL10ParseTokenEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS0_7integerImEES7_:
   13|    151|    {
   14|    151|        if (token.at(0u) == '#' && token.length() > 1u)
  ------------------
  |  Branch (14:13): [True: 0, False: 151]
  |  Branch (14:13): [True: 0, False: 151]
  |  Branch (14:36): [True: 0, False: 0]
  ------------------
   15|      0|        {
   16|      0|            auto number = ParseNumber(token.substring_view(1u));
   17|       |
   18|      0|            if (number)
  ------------------
  |  Branch (18:17): [True: 0, False: 0]
  ------------------
   19|      0|            {
   20|      0|                return {Token::Type::ImmediateInteger, token, line_number, column,
   21|      0|                        static_cast<phi::uint32_t>(number.value().unsafe())};
   22|      0|            }
   23|       |
   24|      0|            return {Token::Type::ImmediateInteger, token, line_number, column};
   25|      0|        }
   26|       |
   27|    151|        if (token.at(0u) == '/' || token.at(0u) == ';')
  ------------------
  |  Branch (27:13): [True: 0, False: 151]
  |  Branch (27:13): [True: 4, False: 147]
  |  Branch (27:36): [True: 4, False: 147]
  ------------------
   28|      4|        {
   29|      4|            return {Token::Type::Comment, token, line_number, column};
   30|      4|        }
   31|       |
   32|    147|        if (phi::optional<phi::i16> number = ParseNumber(token); number.has_value())
  ------------------
  |  Branch (32:66): [True: 8, False: 139]
  ------------------
   33|      8|        {
   34|      8|            return {Token::Type::IntegerLiteral, token, line_number, column,
   35|      8|                    static_cast<phi::uint32_t>(number->unsafe())};
   36|      8|        }
   37|       |
   38|    139|        if (IsFPSR(token))
  ------------------
  |  Branch (38:13): [True: 0, False: 139]
  ------------------
   39|      0|        {
   40|      0|            return {Token::Type::RegisterStatus, token, line_number, column};
   41|      0|        }
   42|       |
   43|    139|        if (IntRegisterID id = StringToIntRegister(token); id != IntRegisterID::None)
  ------------------
  |  Branch (43:60): [True: 0, False: 139]
  ------------------
   44|      0|        {
   45|      0|            return {Token::Type::RegisterInt, token, line_number, column,
   46|      0|                    static_cast<phi::uint32_t>(id)};
   47|      0|        }
   48|       |
   49|    139|        if (FloatRegisterID id = StringToFloatRegister(token); id != FloatRegisterID::None)
  ------------------
  |  Branch (49:64): [True: 0, False: 139]
  ------------------
   50|      0|        {
   51|      0|            return {Token::Type::RegisterFloat, token, line_number, column,
   52|      0|                    static_cast<phi::uint32_t>(id)};
   53|      0|        }
   54|       |
   55|    139|        if (OpCode opcode = StringToOpCode(token); opcode != OpCode::NONE)
  ------------------
  |  Branch (55:52): [True: 0, False: 139]
  ------------------
   56|      0|        {
   57|      0|            return {Token::Type::OpCode, token, line_number, column,
   58|      0|                    static_cast<phi::uint32_t>(opcode)};
   59|      0|        }
   60|       |
   61|    139|        return {Token::Type::LabelIdentifier, token, line_number, column};
   62|    139|    }

_ZN3fmt2v96detail11to_unsignedIiEENSt3__113make_unsignedIT_E4typeES5_:
  409|    191|    typename std::make_unsigned<Int>::type {
  410|    191|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  368|    382|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (368:37): [Folded - Ignored]
  |  |  |  Branch (368:37): [True: 191, False: 0]
  |  |  ------------------
  ------------------
  411|    191|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  412|    191|}
_ZN3fmt2v96detail13ignore_unusedIJbA15_cEEEvDpRKT_:
  336|  1.69k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt2v917basic_string_viewIcE4sizeEv:
  476|    841|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail13ignore_unusedIJbA1_cEEEvDpRKT_:
  336|    191|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt2v96detail6bufferIcE4sizeEv:
  930|    163|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt2v96detail6bufferIcEC2EPcmm:
  902|    163|      : ptr_(p), size_(sz), capacity_(cap) {}
_ZN3fmt2v96detail6bufferIcE3setEPcm:
  908|    163|  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  909|    163|    ptr_ = buf_data;
  910|    163|    capacity_ = buf_capacity;
  911|    163|  }
_ZN3fmt2v96detail6bufferIcE4dataEv:
  936|    163|  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
_ZNK3fmt2v917basic_string_viewIcE5beginEv:
  478|    328|  constexpr auto begin() const noexcept -> iterator { return data_; }
_ZNK3fmt2v917basic_string_viewIcE3endEv:
  479|    328|  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
_ZN3fmt2v917basic_string_viewIcEC2EPKc:
  459|    187|                  : std::char_traits<Char>::length(s)) {}
_ZN3fmt2v96detail10locale_refC2Ev:
 1730|    350|  constexpr FMT_INLINE locale_ref() : locale_(nullptr) {}
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1297|    191|  constexpr FMT_INLINE value() : no_value() {}
_ZN3fmt2v99monostateC2Ev:
  319|    191|  constexpr monostate() {}
_ZN3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEC2EyPKNS0_6detail5valueIS4_EE:
 1991|    163|      : desc_(desc), values_(values) {}
_ZNK3fmt2v917basic_string_viewIcE4dataEv:
  473|    350|  constexpr auto data() const noexcept -> const Char* { return data_; }
_ZN3fmt2v917basic_string_viewIcEC2EPKcm:
  444|    328|      : data_(s), size_(count) {}
_ZN3fmt2v96detail11to_unsignedIlEENSt3__113make_unsignedIT_E4typeES5_:
  409|  1.50k|    typename std::make_unsigned<Int>::type {
  410|  1.50k|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  368|  3.00k|      ::fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (368:37): [Folded - Ignored]
  |  |  |  Branch (368:37): [True: 1.50k, False: 0]
  |  |  ------------------
  ------------------
  411|  1.50k|  return static_cast<typename std::make_unsigned<Int>::type>(value);
  412|  1.50k|}
_ZN3fmt2v96detail6bufferIcE11try_reserveEm:
  955|    519|  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
  956|    519|    if (new_capacity > capacity_) grow(new_capacity);
  ------------------
  |  Branch (956:9): [True: 0, False: 519]
  ------------------
  957|    519|  }
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE3getEi:
 2029|    191|  FMT_CONSTEXPR auto get(int id) const -> format_arg {
 2030|    191|    format_arg arg;
 2031|    191|    if (!is_packed()) {
  ------------------
  |  Branch (2031:9): [True: 0, False: 191]
  ------------------
 2032|      0|      if (id < max_size()) arg = args_[id];
  ------------------
  |  Branch (2032:11): [True: 0, False: 0]
  ------------------
 2033|      0|      return arg;
 2034|      0|    }
 2035|    191|    if (id >= detail::max_packed_args) return arg;
  ------------------
  |  Branch (2035:9): [True: 0, False: 191]
  ------------------
 2036|    191|    arg.type_ = type(id);
 2037|    191|    if (arg.type_ == detail::type::none_type) return arg;
  ------------------
  |  Branch (2037:9): [True: 0, False: 191]
  ------------------
 2038|    191|    arg.value_ = values_[id];
 2039|    191|    return arg;
 2040|    191|  }
_ZN3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEC2Ev:
 1618|    191|  constexpr basic_format_arg() : type_(detail::type::none_type) {}
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE9is_packedEv:
 1976|    191|  constexpr auto is_packed() const -> bool {
 1977|    191|    return (desc_ & detail::is_unpacked_bit) == 0;
 1978|    191|  }
_ZNK3fmt2v917basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEE4typeEi:
 1983|    191|  FMT_CONSTEXPR auto type(int index) const -> detail::type {
 1984|    191|    int shift = index * detail::packed_arg_bits;
 1985|    191|    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
 1986|    191|    return static_cast<detail::type>((desc_ >> shift) & mask);
 1987|    191|  }
_ZNK3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEEcvbEv:
 1620|    191|  constexpr explicit operator bool() const noexcept {
 1621|    191|    return type_ != detail::type::none_type;
 1622|    191|  }
_ZN3fmt2v96detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EE:
  858|    519|    -> Container& {
  859|    519|  using base = std::back_insert_iterator<Container>;
  860|    519|  struct accessor : base {
  861|    519|    accessor(base b) : base(b) {}
  862|    519|    using base::container;
  863|    519|  };
  864|    519|  return *accessor(it).container;
  865|    519|}
_ZZN3fmt2v96detail13get_containerINS1_6bufferIcEEEERT_NSt3__120back_insert_iteratorIS5_EEEN8accessorC2ENS8_IS4_EE:
  861|    519|    accessor(base b) : base(b) {}
_ZN3fmt2v96detail13ignore_unusedIJbA20_cEEEvDpRKT_:
  336|      4|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt2v96detail8copy_strIcPcEENS0_8appenderET0_S5_S4_:
 1683|      4|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1684|      4|  get_container(out).append(begin, end);
 1685|      4|  return out;
 1686|      4|}
_ZNK3fmt2v96detail6fill_tIcE4sizeEv:
 2107|    187|  constexpr auto size() const -> size_t { return size_; }
_ZN3fmt2v96detail8copy_strIcPKcEENS0_8appenderET0_S6_S5_:
 1683|    515|auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
 1684|    515|  get_container(out).append(begin, end);
 1685|    515|  return out;
 1686|    515|}
_ZN3fmt2v912format_specsIcEC2Ev:
 2158|    191|        localized(false) {}
_ZN3fmt2v926basic_format_parse_contextIcEC2ENS0_17basic_string_viewIcEEi:
  697|    163|      : format_str_(format_str), next_arg_id_(next_arg_id) {}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcEC2ES2_NS0_17basic_format_argsIS3_EENS0_6detail10locale_refE:
 1827|    163|      : out_(out), args_(ctx_args), loc_(loc) {}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE3outEv:
 1842|    519|  FMT_CONSTEXPR auto out() -> iterator { return out_; }
_ZN3fmt2v96detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_:
 2586|    163|    basic_string_view<Char> format_str, Handler&& handler) {
 2587|       |  // Workaround a name-lookup bug in MSVC's modules implementation.
 2588|    163|  using detail::find;
 2589|       |
 2590|    163|  auto begin = format_str.data();
 2591|    163|  auto end = begin + format_str.size();
 2592|    163|  if (end - begin < 32) {
  ------------------
  |  Branch (2592:7): [True: 0, False: 163]
  ------------------
 2593|       |    // Use a simple loop instead of memchr for small strings.
 2594|      0|    const Char* p = begin;
 2595|      0|    while (p != end) {
  ------------------
  |  Branch (2595:12): [True: 0, False: 0]
  ------------------
 2596|      0|      auto c = *p++;
 2597|      0|      if (c == '{') {
  ------------------
  |  Branch (2597:11): [True: 0, False: 0]
  ------------------
 2598|      0|        handler.on_text(begin, p - 1);
 2599|      0|        begin = p = parse_replacement_field(p - 1, end, handler);
 2600|      0|      } else if (c == '}') {
  ------------------
  |  Branch (2600:18): [True: 0, False: 0]
  ------------------
 2601|      0|        if (p == end || *p != '}')
  ------------------
  |  Branch (2601:13): [True: 0, False: 0]
  |  Branch (2601:25): [True: 0, False: 0]
  ------------------
 2602|      0|          return handler.on_error("unmatched '}' in format string");
 2603|      0|        handler.on_text(begin, p);
 2604|      0|        begin = ++p;
 2605|      0|      }
 2606|      0|    }
 2607|      0|    handler.on_text(begin, end);
 2608|      0|    return;
 2609|      0|  }
 2610|    163|  struct writer {
 2611|    163|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2612|    163|      if (from == to) return;
 2613|    163|      for (;;) {
 2614|    163|        const Char* p = nullptr;
 2615|    163|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
 2616|    163|          return handler_.on_text(from, to);
 2617|    163|        ++p;
 2618|    163|        if (p == to || *p != '}')
 2619|    163|          return handler_.on_error("unmatched '}' in format string");
 2620|    163|        handler_.on_text(from, p);
 2621|    163|        from = p + 1;
 2622|    163|      }
 2623|    163|    }
 2624|    163|    Handler& handler_;
 2625|    163|  } write = {handler};
 2626|    354|  while (begin != end) {
  ------------------
  |  Branch (2626:10): [True: 328, False: 26]
  ------------------
 2627|       |    // Doing two passes with memchr (one for '{' and another for '}') is up to
 2628|       |    // 2.5x faster than the naive one-pass implementation on big format strings.
 2629|    328|    const Char* p = begin;
 2630|    328|    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
  ------------------
  |  Branch (2630:9): [True: 328, False: 0]
  |  Branch (2630:26): [True: 137, False: 191]
  ------------------
 2631|    137|      return write(begin, end);
 2632|    191|    write(begin, p);
 2633|    191|    begin = parse_replacement_field(p, end, handler);
 2634|    191|  }
 2635|    163|}
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE10advance_toES2_:
 1845|    519|  void advance_to(iterator it) {
 1846|    519|    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
  ------------------
  |  Branch (1846:9): [Folded - Ignored]
  ------------------
 1847|    519|  }
_ZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_:
 2549|    191|                                           Handler&& handler) -> const Char* {
 2550|    191|  struct id_adapter {
 2551|    191|    Handler& handler;
 2552|    191|    int arg_id;
 2553|       |
 2554|    191|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
 2555|    191|    FMT_CONSTEXPR void on_index(int id) { arg_id = handler.on_arg_id(id); }
 2556|    191|    FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
 2557|    191|      arg_id = handler.on_arg_id(id);
 2558|    191|    }
 2559|    191|  };
 2560|       |
 2561|    191|  ++begin;
 2562|    191|  if (begin == end) return handler.on_error("invalid format string"), end;
  ------------------
  |  Branch (2562:7): [True: 0, False: 191]
  ------------------
 2563|    191|  if (*begin == '}') {
  ------------------
  |  Branch (2563:7): [True: 0, False: 191]
  ------------------
 2564|      0|    handler.on_replacement_field(handler.on_arg_id(), begin);
 2565|    191|  } else if (*begin == '{') {
  ------------------
  |  Branch (2565:14): [True: 0, False: 191]
  ------------------
 2566|      0|    handler.on_text(begin, begin + 1);
 2567|    191|  } else {
 2568|    191|    auto adapter = id_adapter{handler, 0};
 2569|    191|    begin = parse_arg_id(begin, end, adapter);
 2570|    191|    Char c = begin != end ? *begin : Char();
  ------------------
  |  Branch (2570:14): [True: 191, False: 0]
  ------------------
 2571|    191|    if (c == '}') {
  ------------------
  |  Branch (2571:9): [True: 0, False: 191]
  ------------------
 2572|      0|      handler.on_replacement_field(adapter.arg_id, begin);
 2573|    191|    } else if (c == ':') {
  ------------------
  |  Branch (2573:16): [True: 191, False: 0]
  ------------------
 2574|    191|      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
 2575|    191|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (2575:11): [True: 0, False: 191]
  |  Branch (2575:27): [True: 0, False: 191]
  ------------------
 2576|      0|        return handler.on_error("unknown format specifier"), end;
 2577|    191|    } else {
 2578|      0|      return handler.on_error("missing '}' in format string"), end;
 2579|      0|    }
 2580|    191|  }
 2581|    191|  return begin + 1;
 2582|    191|}
_ZNK3fmt2v920basic_format_contextINS0_8appenderEcE3argEi:
 1829|    191|  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
_ZN3fmt2v920basic_format_contextINS0_8appenderEcE6localeEv:
 1849|    191|  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
_ZN3fmt2v926basic_format_parse_contextIcE11next_arg_idEv:
  721|    191|  FMT_CONSTEXPR auto next_arg_id() -> int {
  722|    191|    if (next_arg_id_ < 0) {
  ------------------
  |  Branch (722:9): [True: 0, False: 191]
  ------------------
  723|      0|      detail::throw_format_error(
  724|      0|          "cannot switch from manual to automatic argument indexing");
  725|      0|      return 0;
  726|      0|    }
  727|    191|    int id = next_arg_id_++;
  728|    191|    do_check_arg_id(id);
  729|    191|    return id;
  730|    191|  }
_ZN3fmt2v926basic_format_parse_contextIcE15do_check_arg_idEi:
  792|    191|FMT_CONSTEXPR void basic_format_parse_context<Char>::do_check_arg_id(int id) {
  793|       |  // Argument id is only checked at compile-time during parsing because
  794|       |  // formatting has its own validation.
  795|    191|  if (detail::is_constant_evaluated() &&
  ------------------
  |  Branch (795:7): [Folded - Ignored]
  ------------------
  796|    191|      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   32|      0|#  define FMT_GCC_VERSION 0
  ------------------
                    (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   32|      0|#  define FMT_GCC_VERSION 0
  ------------------
  |  Branch (796:8): [Folded - Ignored]
  |  Branch (796:28): [Folded - Ignored]
  ------------------
  797|      0|    using context = detail::compile_parse_context<Char>;
  798|      0|    if (id >= static_cast<context*>(this)->num_args())
  ------------------
  |  Branch (798:9): [True: 0, False: 0]
  ------------------
  799|      0|      detail::throw_format_error("argument not found");
  800|      0|  }
  801|    191|}
_ZN3fmt2v96detail12parse_arg_idIcRZNS1_23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS6_EENS1_12vformat_argsIS6_E4typeENS1_10locale_refEE14format_handlerEEPKS6_SI_SI_OT0_E10id_adapterEESI_SI_SI_SK_:
 2314|    191|                                           Handler&& handler) -> const Char* {
 2315|    191|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  368|    191|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 2316|    191|  Char c = *begin;
 2317|    191|  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
  ------------------
  |  Branch (2317:7): [True: 191, False: 0]
  |  Branch (2317:19): [True: 0, False: 191]
  ------------------
 2318|    191|  handler.on_auto();
 2319|    191|  return begin;
 2320|    191|}
_ZZN3fmt2v96detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_EN10id_adapter7on_autoEv:
 2554|    191|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
_ZNK3fmt2v916basic_format_argINS0_20basic_format_contextINS0_8appenderEcEEE4typeEv:
 1624|    382|  auto type() const -> detail::type { return type_; }
_ZN3fmt2v96detail7arg_refIcEC2Ev:
 2167|    382|  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
_ZN3fmt2v96detail7arg_refIcE5valueC2Ei:
 2182|    382|    FMT_CONSTEXPR value(int idx = 0) : index(idx) {}
_ZN3fmt2v96detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeE:
 2384|    191|    basic_format_parse_context<Char>& ctx, type arg_type) -> const Char* {
 2385|    191|  auto c = '\0';
 2386|    191|  if (end - begin > 1) {
  ------------------
  |  Branch (2386:7): [True: 191, False: 0]
  ------------------
 2387|    191|    auto next = to_ascii(begin[1]);
 2388|    191|    c = parse_align(next) == align::none ? to_ascii(*begin) : '\0';
  ------------------
  |  Branch (2388:9): [True: 191, False: 0]
  ------------------
 2389|    191|  } else {
 2390|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2390:9): [True: 0, False: 0]
  ------------------
 2391|      0|    c = to_ascii(*begin);
 2392|      0|  }
 2393|       |
 2394|    191|  struct {
 2395|    191|    state current_state = state::start;
 2396|    191|    FMT_CONSTEXPR void operator()(state s, bool valid = true) {
 2397|    191|      if (current_state >= s || !valid)
 2398|    191|        throw_format_error("invalid format specifier");
 2399|    191|      current_state = s;
 2400|    191|    }
 2401|    191|  } enter_state;
 2402|       |
 2403|    191|  using pres = presentation_type;
 2404|    191|  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
 2405|    191|  struct {
 2406|    191|    const Char*& begin;
 2407|    191|    dynamic_format_specs<Char>& specs;
 2408|    191|    type arg_type;
 2409|       |
 2410|    191|    FMT_CONSTEXPR auto operator()(pres type, int set) -> const Char* {
 2411|    191|      if (!in(arg_type, set)) throw_format_error("invalid format specifier");
 2412|    191|      specs.type = type;
 2413|    191|      return begin + 1;
 2414|    191|    }
 2415|    191|  } parse_presentation_type{begin, specs, arg_type};
 2416|       |
 2417|    191|  for (;;) {
 2418|    191|    switch (c) {
 2419|      0|    case '<':
  ------------------
  |  Branch (2419:5): [True: 0, False: 191]
  ------------------
 2420|      0|    case '>':
  ------------------
  |  Branch (2420:5): [True: 0, False: 191]
  ------------------
 2421|      0|    case '^':
  ------------------
  |  Branch (2421:5): [True: 0, False: 191]
  ------------------
 2422|      0|      enter_state(state::align);
 2423|      0|      specs.align = parse_align(c);
 2424|      0|      ++begin;
 2425|      0|      break;
 2426|      0|    case '+':
  ------------------
  |  Branch (2426:5): [True: 0, False: 191]
  ------------------
 2427|      0|    case '-':
  ------------------
  |  Branch (2427:5): [True: 0, False: 191]
  ------------------
 2428|      0|    case ' ':
  ------------------
  |  Branch (2428:5): [True: 0, False: 191]
  ------------------
 2429|      0|      enter_state(state::sign, in(arg_type, sint_set | float_set));
 2430|      0|      switch (c) {
  ------------------
  |  Branch (2430:15): [True: 0, False: 0]
  ------------------
 2431|      0|      case '+':
  ------------------
  |  Branch (2431:7): [True: 0, False: 0]
  ------------------
 2432|      0|        specs.sign = sign::plus;
 2433|      0|        break;
 2434|      0|      case '-':
  ------------------
  |  Branch (2434:7): [True: 0, False: 0]
  ------------------
 2435|      0|        specs.sign = sign::minus;
 2436|      0|        break;
 2437|      0|      case ' ':
  ------------------
  |  Branch (2437:7): [True: 0, False: 0]
  ------------------
 2438|      0|        specs.sign = sign::space;
 2439|      0|        break;
 2440|      0|      }
 2441|      0|      ++begin;
 2442|      0|      break;
 2443|      0|    case '#':
  ------------------
  |  Branch (2443:5): [True: 0, False: 191]
  ------------------
 2444|      0|      enter_state(state::hash, is_arithmetic_type(arg_type));
 2445|      0|      specs.alt = true;
 2446|      0|      ++begin;
 2447|      0|      break;
 2448|      0|    case '0':
  ------------------
  |  Branch (2448:5): [True: 0, False: 191]
  ------------------
 2449|      0|      enter_state(state::zero);
 2450|      0|      if (!is_arithmetic_type(arg_type))
  ------------------
  |  Branch (2450:11): [True: 0, False: 0]
  ------------------
 2451|      0|        throw_format_error("format specifier requires numeric argument");
 2452|      0|      if (specs.align == align::none) {
  ------------------
  |  Branch (2452:11): [True: 0, False: 0]
  ------------------
 2453|       |        // Ignore 0 if align is specified for compatibility with std::format.
 2454|      0|        specs.align = align::numeric;
 2455|      0|        specs.fill[0] = Char('0');
 2456|      0|      }
 2457|      0|      ++begin;
 2458|      0|      break;
 2459|      0|    case '1':
  ------------------
  |  Branch (2459:5): [True: 0, False: 191]
  ------------------
 2460|      0|    case '2':
  ------------------
  |  Branch (2460:5): [True: 0, False: 191]
  ------------------
 2461|      0|    case '3':
  ------------------
  |  Branch (2461:5): [True: 0, False: 191]
  ------------------
 2462|      0|    case '4':
  ------------------
  |  Branch (2462:5): [True: 0, False: 191]
  ------------------
 2463|      0|    case '5':
  ------------------
  |  Branch (2463:5): [True: 0, False: 191]
  ------------------
 2464|      0|    case '6':
  ------------------
  |  Branch (2464:5): [True: 0, False: 191]
  ------------------
 2465|      0|    case '7':
  ------------------
  |  Branch (2465:5): [True: 0, False: 191]
  ------------------
 2466|      0|    case '8':
  ------------------
  |  Branch (2466:5): [True: 0, False: 191]
  ------------------
 2467|      0|    case '9':
  ------------------
  |  Branch (2467:5): [True: 0, False: 191]
  ------------------
 2468|      0|    case '{':
  ------------------
  |  Branch (2468:5): [True: 0, False: 191]
  ------------------
 2469|      0|      enter_state(state::width);
 2470|      0|      begin = parse_dynamic_spec(begin, end, specs.width, specs.width_ref, ctx);
 2471|      0|      break;
 2472|      0|    case '.':
  ------------------
  |  Branch (2472:5): [True: 0, False: 191]
  ------------------
 2473|      0|      enter_state(state::precision,
 2474|      0|                  in(arg_type, float_set | string_set | cstring_set));
 2475|      0|      begin = parse_precision(begin, end, specs.precision, specs.precision_ref,
 2476|      0|                              ctx);
 2477|      0|      break;
 2478|      0|    case 'L':
  ------------------
  |  Branch (2478:5): [True: 0, False: 191]
  ------------------
 2479|      0|      enter_state(state::locale, is_arithmetic_type(arg_type));
 2480|      0|      specs.localized = true;
 2481|      0|      ++begin;
 2482|      0|      break;
 2483|      4|    case 'd':
  ------------------
  |  Branch (2483:5): [True: 4, False: 187]
  ------------------
 2484|      4|      return parse_presentation_type(pres::dec, integral_set);
 2485|      0|    case 'o':
  ------------------
  |  Branch (2485:5): [True: 0, False: 191]
  ------------------
 2486|      0|      return parse_presentation_type(pres::oct, integral_set);
 2487|      0|    case 'x':
  ------------------
  |  Branch (2487:5): [True: 0, False: 191]
  ------------------
 2488|      0|      return parse_presentation_type(pres::hex_lower, integral_set);
 2489|      0|    case 'X':
  ------------------
  |  Branch (2489:5): [True: 0, False: 191]
  ------------------
 2490|      0|      return parse_presentation_type(pres::hex_upper, integral_set);
 2491|      0|    case 'b':
  ------------------
  |  Branch (2491:5): [True: 0, False: 191]
  ------------------
 2492|      0|      return parse_presentation_type(pres::bin_lower, integral_set);
 2493|      0|    case 'B':
  ------------------
  |  Branch (2493:5): [True: 0, False: 191]
  ------------------
 2494|      0|      return parse_presentation_type(pres::bin_upper, integral_set);
 2495|      0|    case 'a':
  ------------------
  |  Branch (2495:5): [True: 0, False: 191]
  ------------------
 2496|      0|      return parse_presentation_type(pres::hexfloat_lower, float_set);
 2497|      0|    case 'A':
  ------------------
  |  Branch (2497:5): [True: 0, False: 191]
  ------------------
 2498|      0|      return parse_presentation_type(pres::hexfloat_upper, float_set);
 2499|      0|    case 'e':
  ------------------
  |  Branch (2499:5): [True: 0, False: 191]
  ------------------
 2500|      0|      return parse_presentation_type(pres::exp_lower, float_set);
 2501|      0|    case 'E':
  ------------------
  |  Branch (2501:5): [True: 0, False: 191]
  ------------------
 2502|      0|      return parse_presentation_type(pres::exp_upper, float_set);
 2503|      0|    case 'f':
  ------------------
  |  Branch (2503:5): [True: 0, False: 191]
  ------------------
 2504|      0|      return parse_presentation_type(pres::fixed_lower, float_set);
 2505|      0|    case 'F':
  ------------------
  |  Branch (2505:5): [True: 0, False: 191]
  ------------------
 2506|      0|      return parse_presentation_type(pres::fixed_upper, float_set);
 2507|      0|    case 'g':
  ------------------
  |  Branch (2507:5): [True: 0, False: 191]
  ------------------
 2508|      0|      return parse_presentation_type(pres::general_lower, float_set);
 2509|      0|    case 'G':
  ------------------
  |  Branch (2509:5): [True: 0, False: 191]
  ------------------
 2510|      0|      return parse_presentation_type(pres::general_upper, float_set);
 2511|      0|    case 'c':
  ------------------
  |  Branch (2511:5): [True: 0, False: 191]
  ------------------
 2512|      0|      return parse_presentation_type(pres::chr, integral_set);
 2513|    187|    case 's':
  ------------------
  |  Branch (2513:5): [True: 187, False: 4]
  ------------------
 2514|    187|      return parse_presentation_type(pres::string,
 2515|    187|                                     bool_set | string_set | cstring_set);
 2516|      0|    case 'p':
  ------------------
  |  Branch (2516:5): [True: 0, False: 191]
  ------------------
 2517|      0|      return parse_presentation_type(pres::pointer, pointer_set | cstring_set);
 2518|      0|    case '?':
  ------------------
  |  Branch (2518:5): [True: 0, False: 191]
  ------------------
 2519|      0|      return parse_presentation_type(pres::debug,
 2520|      0|                                     char_set | string_set | cstring_set);
 2521|      0|    case '}':
  ------------------
  |  Branch (2521:5): [True: 0, False: 191]
  ------------------
 2522|      0|      return begin;
 2523|      0|    default: {
  ------------------
  |  Branch (2523:5): [True: 0, False: 191]
  ------------------
 2524|      0|      if (*begin == '}') return begin;
  ------------------
  |  Branch (2524:11): [True: 0, False: 0]
  ------------------
 2525|       |      // Parse fill and alignment.
 2526|      0|      auto fill_end = begin + code_point_length(begin);
 2527|      0|      if (end - fill_end <= 0) {
  ------------------
  |  Branch (2527:11): [True: 0, False: 0]
  ------------------
 2528|      0|        throw_format_error("invalid format specifier");
 2529|      0|        return begin;
 2530|      0|      }
 2531|      0|      if (*begin == '{') {
  ------------------
  |  Branch (2531:11): [True: 0, False: 0]
  ------------------
 2532|      0|        throw_format_error("invalid fill character '{'");
 2533|      0|        return begin;
 2534|      0|      }
 2535|      0|      auto align = parse_align(to_ascii(*fill_end));
 2536|      0|      enter_state(state::align, align != align::none);
 2537|      0|      specs.fill = {begin, to_unsigned(fill_end - begin)};
 2538|      0|      specs.align = align;
 2539|      0|      begin = fill_end + 1;
 2540|      0|    }
 2541|    191|    }
 2542|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2542:9): [True: 0, False: 0]
  ------------------
 2543|      0|    c = to_ascii(*begin);
 2544|      0|  }
 2545|    191|}
_ZN3fmt2v96detail8to_asciiIcLi0EEEcT_:
 2201|    382|constexpr auto to_ascii(Char c) -> char {
 2202|    382|  return c <= 0xff ? static_cast<char>(c) : '\0';
  ------------------
  |  Branch (2202:10): [True: 382, False: 0]
  ------------------
 2203|    382|}
_ZN3fmt2v96detail11parse_alignEc:
 2267|    191|FMT_CONSTEXPR inline auto parse_align(char c) -> align_t {
 2268|    191|  switch (c) {
  ------------------
  |  Branch (2268:11): [True: 191, False: 0]
  ------------------
 2269|      0|  case '<':
  ------------------
  |  Branch (2269:3): [True: 0, False: 191]
  ------------------
 2270|      0|    return align::left;
 2271|      0|  case '>':
  ------------------
  |  Branch (2271:3): [True: 0, False: 191]
  ------------------
 2272|      0|    return align::right;
 2273|      0|  case '^':
  ------------------
  |  Branch (2273:3): [True: 0, False: 191]
  ------------------
 2274|      0|    return align::center;
 2275|    191|  }
 2276|    191|  return align::none;
 2277|    191|}
_ZN3fmt2v96detail2inENS1_4typeEi:
  643|    191|constexpr auto in(type t, int set) -> bool {
  644|    191|  return ((set >> static_cast<int>(t)) & 1) != 0;
  645|    191|}
_ZZN3fmt2v96detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeEENUt0_clENS0_17presentation_typeEi:
 2410|    191|    FMT_CONSTEXPR auto operator()(pres type, int set) -> const Char* {
 2411|    191|      if (!in(arg_type, set)) throw_format_error("invalid format specifier");
  ------------------
  |  Branch (2411:11): [True: 0, False: 191]
  ------------------
 2412|    191|      specs.type = type;
 2413|    191|      return begin + 1;
 2414|    191|    }
_ZN3fmt2v916visit_format_argIRNS0_6detail13arg_formatterIcEENS0_20basic_format_contextINS0_8appenderEcEEEEDTclfp_Li0EEEOT_RKNS0_16basic_format_argIT0_EE:
 1641|    191|    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
 1642|    191|  switch (arg.type_) {
  ------------------
  |  Branch (1642:11): [True: 0, False: 191]
  ------------------
 1643|      0|  case detail::type::none_type:
  ------------------
  |  Branch (1643:3): [True: 0, False: 191]
  ------------------
 1644|      0|    break;
 1645|      0|  case detail::type::int_type:
  ------------------
  |  Branch (1645:3): [True: 0, False: 191]
  ------------------
 1646|      0|    return vis(arg.value_.int_value);
 1647|      0|  case detail::type::uint_type:
  ------------------
  |  Branch (1647:3): [True: 0, False: 191]
  ------------------
 1648|      0|    return vis(arg.value_.uint_value);
 1649|      0|  case detail::type::long_long_type:
  ------------------
  |  Branch (1649:3): [True: 0, False: 191]
  ------------------
 1650|      0|    return vis(arg.value_.long_long_value);
 1651|      4|  case detail::type::ulong_long_type:
  ------------------
  |  Branch (1651:3): [True: 4, False: 187]
  ------------------
 1652|      4|    return vis(arg.value_.ulong_long_value);
 1653|      0|  case detail::type::int128_type:
  ------------------
  |  Branch (1653:3): [True: 0, False: 191]
  ------------------
 1654|      0|    return vis(detail::convert_for_visit(arg.value_.int128_value));
 1655|      0|  case detail::type::uint128_type:
  ------------------
  |  Branch (1655:3): [True: 0, False: 191]
  ------------------
 1656|      0|    return vis(detail::convert_for_visit(arg.value_.uint128_value));
 1657|      0|  case detail::type::bool_type:
  ------------------
  |  Branch (1657:3): [True: 0, False: 191]
  ------------------
 1658|      0|    return vis(arg.value_.bool_value);
 1659|      0|  case detail::type::char_type:
  ------------------
  |  Branch (1659:3): [True: 0, False: 191]
  ------------------
 1660|      0|    return vis(arg.value_.char_value);
 1661|      0|  case detail::type::float_type:
  ------------------
  |  Branch (1661:3): [True: 0, False: 191]
  ------------------
 1662|      0|    return vis(arg.value_.float_value);
 1663|      0|  case detail::type::double_type:
  ------------------
  |  Branch (1663:3): [True: 0, False: 191]
  ------------------
 1664|      0|    return vis(arg.value_.double_value);
 1665|      0|  case detail::type::long_double_type:
  ------------------
  |  Branch (1665:3): [True: 0, False: 191]
  ------------------
 1666|      0|    return vis(arg.value_.long_double_value);
 1667|    187|  case detail::type::cstring_type:
  ------------------
  |  Branch (1667:3): [True: 187, False: 4]
  ------------------
 1668|    187|    return vis(arg.value_.string.data);
 1669|      0|  case detail::type::string_type:
  ------------------
  |  Branch (1669:3): [True: 0, False: 191]
  ------------------
 1670|      0|    using sv = basic_string_view<typename Context::char_type>;
 1671|      0|    return vis(sv(arg.value_.string.data, arg.value_.string.size));
 1672|      0|  case detail::type::pointer_type:
  ------------------
  |  Branch (1672:3): [True: 0, False: 191]
  ------------------
 1673|      0|    return vis(arg.value_.pointer);
 1674|      0|  case detail::type::custom_type:
  ------------------
  |  Branch (1674:3): [True: 0, False: 191]
  ------------------
 1675|      0|    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
 1676|    191|  }
 1677|      0|  return vis(monostate());
 1678|    191|}
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2Ey:
 1301|      4|  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
_ZN3fmt2v96detail4findILb0EcPKcEEbT1_S5_T0_RS5_:
 2236|    656|                              const char*& out) -> bool {
 2237|    656|  out = static_cast<const char*>(
 2238|    656|      std::memchr(first, value, to_unsigned(last - first)));
 2239|    656|  return out != nullptr;
 2240|    656|}
_ZZN3fmt2v96detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_EN6writerclEPKcSL_:
 2611|    328|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2612|    328|      if (from == to) return;
  ------------------
  |  Branch (2612:11): [True: 0, False: 328]
  ------------------
 2613|    328|      for (;;) {
 2614|    328|        const Char* p = nullptr;
 2615|    328|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
  ------------------
  |  Branch (2615:13): [True: 328, False: 0]
  ------------------
 2616|    328|          return handler_.on_text(from, to);
 2617|      0|        ++p;
 2618|      0|        if (p == to || *p != '}')
  ------------------
  |  Branch (2618:13): [True: 0, False: 0]
  |  Branch (2618:24): [True: 0, False: 0]
  ------------------
 2619|      0|          return handler_.on_error("unmatched '}' in format string");
 2620|      0|        handler_.on_text(from, p);
 2621|      0|        from = p + 1;
 2622|      0|      }
 2623|    328|    }
_ZN3fmt2v96detail10arg_mapperINS0_20basic_format_contextINS0_8appenderEcEEE3mapEPKc:
 1441|    187|  FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
 1442|    187|    return val;
 1443|    187|  }
_ZN3fmt2v96detail5valueINS0_20basic_format_contextINS0_8appenderEcEEEC2EPKc:
 1309|    187|  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
 1310|    187|    string.data = val;
 1311|    187|    if (is_constant_evaluated()) string.size = {};
  ------------------
  |  Branch (1311:9): [Folded - Ignored]
  ------------------
 1312|    187|  }
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EEC2IJS7_S7_EEEDpRKT_:
 1203|     24|  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
_ZN3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EE10named_argsEv:
 1205|     24|  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
 1206|     24|    return nullptr;
 1207|     24|  }
_ZNK3fmt2v96detail8arg_dataINS1_5valueINS0_20basic_format_contextINS0_8appenderEcEEEEcLm2ELm0EE4argsEv:
 1204|     24|  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
_ZNK3fmt2v96detail6bufferIcE4dataEv:
  939|    163|  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }

_ZN3fmt2v97vformatENS0_17basic_string_viewIcEENS0_17basic_format_argsINS0_20basic_format_contextINS0_8appenderEcEEEE:
 1447|    163|FMT_FUNC std::string vformat(string_view fmt, format_args args) {
 1448|       |  // Don't optimize the "{}" case to keep the binary size small and because it
 1449|       |  // can be better optimized in fmt::format anyway.
 1450|    163|  auto buffer = memory_buffer();
 1451|    163|  detail::vformat_to(buffer, fmt, args);
 1452|    163|  return to_string(buffer);
 1453|    163|}

_ZN3fmt2v96detail6bufferIcE6appendIcEEvPKT_S7_:
  842|    519|void buffer<T>::append(const U* begin, const U* end) {
  843|  1.03k|  while (begin != end) {
  ------------------
  |  Branch (843:10): [True: 519, False: 519]
  ------------------
  844|    519|    auto count = to_unsigned(end - begin);
  845|    519|    try_reserve(size_ + count);
  846|    519|    auto free_cap = capacity_ - size_;
  847|    519|    if (free_cap < count) count = free_cap;
  ------------------
  |  Branch (847:9): [True: 0, False: 519]
  ------------------
  848|    519|    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
  849|    519|    size_ += count;
  850|    519|    begin += count;
  851|    519|  }
  852|    519|}
_ZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refE:
 4489|    163|                typename vformat_args<Char>::type args, locale_ref loc) {
 4490|       |  // workaround for msvc bug regarding name-lookup in module
 4491|       |  // link names into function scope
 4492|    163|  using detail::arg_formatter;
 4493|    163|  using detail::buffer_appender;
 4494|    163|  using detail::custom_formatter;
 4495|    163|  using detail::default_arg_formatter;
 4496|    163|  using detail::get_arg;
 4497|    163|  using detail::locale_ref;
 4498|    163|  using detail::parse_format_specs;
 4499|    163|  using detail::to_unsigned;
 4500|    163|  using detail::type;
 4501|    163|  using detail::write;
 4502|    163|  auto out = buffer_appender<Char>(buf);
 4503|    163|  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
  ------------------
  |  Branch (4503:7): [True: 0, False: 163]
  |  Branch (4503:26): [True: 0, False: 0]
  ------------------
 4504|      0|    auto arg = args.get(0);
 4505|      0|    if (!arg) error_handler().on_error("argument not found");
  ------------------
  |  Branch (4505:9): [True: 0, False: 0]
  ------------------
 4506|      0|    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
 4507|      0|    return;
 4508|      0|  }
 4509|       |
 4510|    163|  struct format_handler : error_handler {
 4511|    163|    basic_format_parse_context<Char> parse_context;
 4512|    163|    buffer_context<Char> context;
 4513|       |
 4514|    163|    format_handler(buffer_appender<Char> p_out, basic_string_view<Char> str,
 4515|    163|                   basic_format_args<buffer_context<Char>> p_args,
 4516|    163|                   locale_ref p_loc)
 4517|    163|        : parse_context(str), context(p_out, p_args, p_loc) {}
 4518|       |
 4519|    163|    void on_text(const Char* begin, const Char* end) {
 4520|    163|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4521|    163|      context.advance_to(write<Char>(context.out(), text));
 4522|    163|    }
 4523|       |
 4524|    163|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4525|    163|      return parse_context.next_arg_id();
 4526|    163|    }
 4527|    163|    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
 4528|    163|      return parse_context.check_arg_id(id), id;
 4529|    163|    }
 4530|    163|    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
 4531|    163|      int arg_id = context.arg_id(id);
 4532|    163|      if (arg_id < 0) on_error("argument not found");
 4533|    163|      return arg_id;
 4534|    163|    }
 4535|       |
 4536|    163|    FMT_INLINE void on_replacement_field(int id, const Char*) {
 4537|    163|      auto arg = get_arg(context, id);
 4538|    163|      context.advance_to(visit_format_arg(
 4539|    163|          default_arg_formatter<Char>{context.out(), context.args(),
 4540|    163|                                      context.locale()},
 4541|    163|          arg));
 4542|    163|    }
 4543|       |
 4544|    163|    auto on_format_specs(int id, const Char* begin, const Char* end)
 4545|    163|        -> const Char* {
 4546|    163|      auto arg = get_arg(context, id);
 4547|    163|      if (arg.type() == type::custom_type) {
 4548|    163|        parse_context.advance_to(begin);
 4549|    163|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4550|    163|        return parse_context.begin();
 4551|    163|      }
 4552|    163|      auto specs = detail::dynamic_format_specs<Char>();
 4553|    163|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4554|    163|      detail::handle_dynamic_spec<detail::width_checker>(
 4555|    163|          specs.width, specs.width_ref, context);
 4556|    163|      detail::handle_dynamic_spec<detail::precision_checker>(
 4557|    163|          specs.precision, specs.precision_ref, context);
 4558|    163|      if (begin == end || *begin != '}')
 4559|    163|        on_error("missing '}' in format string");
 4560|    163|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4561|    163|      context.advance_to(visit_format_arg(f, arg));
 4562|    163|      return begin;
 4563|    163|    }
 4564|    163|  };
 4565|    163|  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
 4566|    163|}
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEEC2ERKS4_:
  911|    163|      : alloc_(alloc) {
  912|    163|    this->set(store_, SIZE);
  913|    163|    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  ------------------
  |  Branch (913:9): [Folded - Ignored]
  ------------------
  914|    163|  }
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEED2Ev:
  915|    163|  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
_ZN3fmt2v919basic_memory_bufferIcLm500ENSt3__19allocatorIcEEE10deallocateEv:
  897|    163|  FMT_CONSTEXPR20 void deallocate() {
  898|    163|    T* data = this->data();
  899|    163|    if (data != store_) alloc_.deallocate(data, this->capacity());
  ------------------
  |  Branch (899:9): [True: 0, False: 163]
  ------------------
  900|    163|  }
_ZN3fmt2v96detail12make_checkedIcEEPT_S4_m:
  541|    519|template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
  542|    519|  return p;
  543|    519|}
_ZN3fmt2v96detail7reserveINS0_8appenderEEERT_S5_m:
  569|    519|constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
  570|    519|  return it;
  571|    519|}
_ZN3fmt2v96detail5copy2IcEEvPT_PKc:
 1300|      1|FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
 1301|      1|  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
  ------------------
  |  Branch (1301:7): [Folded - Ignored]
  |  Branch (1301:35): [Folded - Ignored]
  ------------------
 1302|      1|    memcpy(dst, src, 2);
 1303|      1|    return;
 1304|      1|  }
 1305|      0|  *dst++ = static_cast<Char>(*src++);
 1306|      0|  *dst = static_cast<Char>(*src);
 1307|      0|}
_ZN3fmt2v96detail7digits2Em:
 1137|      1|constexpr const char* digits2(size_t value) {
 1138|       |  // GCC generates slightly better code when value is pointer-size.
 1139|      1|  return &"0001020304050607080910111213141516171819"
 1140|      1|         "2021222324252627282930313233343536373839"
 1141|      1|         "4041424344454647484950515253545556575859"
 1142|      1|         "6061626364656667686970717273747576777879"
 1143|      1|         "8081828384858687888990919293949596979899"[value * 2];
 1144|      1|}
_ZN3fmt2v96detail17copy_str_noinlineIcPcNS0_8appenderEEET1_T0_S6_S5_:
  626|      4|                                                  OutputIt out) -> OutputIt {
  627|      4|  return copy_str<OutChar>(begin, end, out);
  628|      4|}
_ZN3fmt2v96detail13base_iteratorINS0_8appenderEEET_S4_S4_:
  597|    519|constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
  598|    519|  return it;
  599|    519|}
_ZN3fmt2v96detail12count_digitsEm:
 1197|      8|FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
 1198|      8|#ifdef FMT_BUILTIN_CLZLL
 1199|      8|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1199:7): [Folded - Ignored]
  ------------------
 1200|      8|    return do_count_digits(n);
 1201|      8|  }
 1202|      0|#endif
 1203|      0|  return count_digits_fallback(n);
 1204|      8|}
_ZN3fmt2v96detail15do_count_digitsEm:
 1177|      8|inline auto do_count_digits(uint64_t n) -> int {
 1178|       |  // This has comparable performance to the version by Kendall Willets
 1179|       |  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
 1180|       |  // but uses smaller tables.
 1181|       |  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
 1182|      8|  static constexpr uint8_t bsr2log10[] = {
 1183|      8|      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
 1184|      8|      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
 1185|      8|      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
 1186|      8|      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
 1187|      8|  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
  ------------------
  |  |  148|      8|#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
  ------------------
 1188|      8|  static constexpr const uint64_t zero_or_powers_of_10[] = {
 1189|      8|      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1132|      8|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1133|      8|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1134|      8|      (factor)*1000000000
  ------------------
                    0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1132|      8|  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
  |  | 1133|      8|      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
  |  | 1134|      8|      (factor)*1000000000
  ------------------
 1190|      8|      10000000000000000000ULL};
 1191|      8|  return t - (n < zero_or_powers_of_10[t]);
 1192|      8|}
_ZN3fmt2v96detail14format_decimalIcmEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1319|      4|    -> format_decimal_result<Char*> {
 1320|      4|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  368|      4|      ::fmt::detail::ignore_unused((condition), (message))
  ------------------
 1321|      4|  out += size;
 1322|      4|  Char* end = out;
 1323|      4|  while (value >= 100) {
  ------------------
  |  Branch (1323:10): [True: 0, False: 4]
  ------------------
 1324|       |    // Integer division is slow so do it for a group of two digits instead
 1325|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1326|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1327|      0|    out -= 2;
 1328|      0|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1329|      0|    value /= 100;
 1330|      0|  }
 1331|      4|  if (value < 10) {
  ------------------
  |  Branch (1331:7): [True: 3, False: 1]
  ------------------
 1332|      3|    *--out = static_cast<Char>('0' + value);
 1333|      3|    return {out, end};
 1334|      3|  }
 1335|      1|  out -= 2;
 1336|      1|  copy2(out, digits2(static_cast<size_t>(value)));
 1337|      1|  return {out, end};
 1338|      4|}
_ZN3fmt2v96detail14format_decimalIcmNS0_8appenderELi0EEENS1_21format_decimal_resultIT1_EES5_T0_i:
 1343|      4|    -> format_decimal_result<Iterator> {
 1344|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1345|      4|  Char buffer[digits10<UInt>() + 1] = {};
 1346|      4|  auto end = format_decimal(buffer, value, size).end;
 1347|      4|  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
 1348|      4|}
_ZN3fmt2v96detail11is_negativeIyLi0EEEbT_:
 1109|      4|constexpr auto is_negative(T) -> bool {
 1110|      4|  return false;
 1111|      4|}
_ZN3fmt2v96detail17copy_str_noinlineIcPKcNS0_8appenderEEET1_T0_S7_S6_:
  626|    328|                                                  OutputIt out) -> OutputIt {
  627|    328|  return copy_str<OutChar>(begin, end, out);
  628|    328|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EE:
 3819|    328|    -> OutputIt {
 3820|    328|  auto it = reserve(out, value.size());
 3821|    328|  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
 3822|    328|  return base_iterator(out, it);
 3823|    328|}
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler7on_textEPKcSF_:
 4519|    328|    void on_text(const Char* begin, const Char* end) {
 4520|    328|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4521|    328|      context.advance_to(write<Char>(context.out(), text));
 4522|    328|    }
_ZN3fmt2v96detail7get_argINS0_20basic_format_contextINS0_8appenderEcEEiEENT_10format_argERS6_T0_:
 4002|    191|    typename Context::format_arg {
 4003|    191|  auto arg = ctx.arg(id);
 4004|    191|  if (!arg) ctx.on_error("argument not found");
  ------------------
  |  Branch (4004:7): [True: 0, False: 191]
  ------------------
 4005|    191|  return arg;
 4006|    191|}
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler9on_arg_idEv:
 4524|    191|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4525|    191|      return parse_context.next_arg_id();
 4526|    191|    }
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler15on_format_specsEiPKcSF_:
 4545|    191|        -> const Char* {
 4546|    191|      auto arg = get_arg(context, id);
 4547|    191|      if (arg.type() == type::custom_type) {
  ------------------
  |  Branch (4547:11): [True: 0, False: 191]
  ------------------
 4548|      0|        parse_context.advance_to(begin);
 4549|      0|        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
 4550|      0|        return parse_context.begin();
 4551|      0|      }
 4552|    191|      auto specs = detail::dynamic_format_specs<Char>();
 4553|    191|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4554|    191|      detail::handle_dynamic_spec<detail::width_checker>(
 4555|    191|          specs.width, specs.width_ref, context);
 4556|    191|      detail::handle_dynamic_spec<detail::precision_checker>(
 4557|    191|          specs.precision, specs.precision_ref, context);
 4558|    191|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (4558:11): [True: 0, False: 191]
  |  Branch (4558:27): [True: 0, False: 191]
  ------------------
 4559|      0|        on_error("missing '}' in format string");
 4560|    191|      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
 4561|    191|      context.advance_to(visit_format_arg(f, arg));
 4562|    191|      return begin;
 4563|    191|    }
_ZN3fmt2v96detail19handle_dynamic_specINS1_13width_checkerENS0_20basic_format_contextINS0_8appenderEcEEEEvRiNS1_7arg_refINT0_9char_typeEEERS9_:
 4011|    191|                                       Context& ctx) {
 4012|    191|  switch (ref.kind) {
  ------------------
  |  Branch (4012:11): [True: 0, False: 191]
  ------------------
 4013|    191|  case arg_id_kind::none:
  ------------------
  |  Branch (4013:3): [True: 191, False: 0]
  ------------------
 4014|    191|    break;
 4015|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (4015:3): [True: 0, False: 191]
  ------------------
 4016|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index),
 4017|      0|                                              ctx.error_handler());
 4018|      0|    break;
 4019|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (4019:3): [True: 0, False: 191]
  ------------------
 4020|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name),
 4021|      0|                                              ctx.error_handler());
 4022|      0|    break;
 4023|    191|  }
 4024|    191|}
_ZN3fmt2v96detail19handle_dynamic_specINS1_17precision_checkerENS0_20basic_format_contextINS0_8appenderEcEEEEvRiNS1_7arg_refINT0_9char_typeEEERS9_:
 4011|    191|                                       Context& ctx) {
 4012|    191|  switch (ref.kind) {
  ------------------
  |  Branch (4012:11): [True: 0, False: 191]
  ------------------
 4013|    191|  case arg_id_kind::none:
  ------------------
  |  Branch (4013:3): [True: 191, False: 0]
  ------------------
 4014|    191|    break;
 4015|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (4015:3): [True: 0, False: 191]
  ------------------
 4016|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index),
 4017|      0|                                              ctx.error_handler());
 4018|      0|    break;
 4019|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (4019:3): [True: 0, False: 191]
  ------------------
 4020|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name),
 4021|      0|                                              ctx.error_handler());
 4022|      0|    break;
 4023|    191|  }
 4024|    191|}
_ZN3fmt2v96detail18write_int_noinlineIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2262|      4|    locale_ref loc) -> OutputIt {
 2263|      4|  return write_int(out, arg, specs, loc);
 2264|      4|}
_ZN3fmt2v96detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refE:
 2206|      4|                                        locale_ref) -> OutputIt {
 2207|      4|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2208|      4|  auto abs_value = arg.abs_value;
 2209|      4|  auto prefix = arg.prefix;
 2210|      4|  switch (specs.type) {
 2211|      0|  case presentation_type::none:
  ------------------
  |  Branch (2211:3): [True: 0, False: 4]
  ------------------
 2212|      4|  case presentation_type::dec: {
  ------------------
  |  Branch (2212:3): [True: 4, False: 0]
  ------------------
 2213|      4|    auto num_digits = count_digits(abs_value);
 2214|      4|    return write_int(
 2215|      4|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2216|      4|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2217|      4|        });
 2218|      0|  }
 2219|      0|  case presentation_type::hex_lower:
  ------------------
  |  Branch (2219:3): [True: 0, False: 4]
  ------------------
 2220|      0|  case presentation_type::hex_upper: {
  ------------------
  |  Branch (2220:3): [True: 0, False: 4]
  ------------------
 2221|      0|    bool upper = specs.type == presentation_type::hex_upper;
 2222|      0|    if (specs.alt)
  ------------------
  |  Branch (2222:9): [True: 0, False: 0]
  ------------------
 2223|      0|      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2223:38): [True: 0, False: 0]
  ------------------
 2224|      0|    int num_digits = count_digits<4>(abs_value);
 2225|      0|    return write_int(
 2226|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2227|      0|          return format_uint<4, Char>(it, abs_value, num_digits, upper);
 2228|      0|        });
 2229|      0|  }
 2230|      0|  case presentation_type::bin_lower:
  ------------------
  |  Branch (2230:3): [True: 0, False: 4]
  ------------------
 2231|      0|  case presentation_type::bin_upper: {
  ------------------
  |  Branch (2231:3): [True: 0, False: 4]
  ------------------
 2232|      0|    bool upper = specs.type == presentation_type::bin_upper;
 2233|      0|    if (specs.alt)
  ------------------
  |  Branch (2233:9): [True: 0, False: 0]
  ------------------
 2234|      0|      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2234:38): [True: 0, False: 0]
  ------------------
 2235|      0|    int num_digits = count_digits<1>(abs_value);
 2236|      0|    return write_int(out, num_digits, prefix, specs,
 2237|      0|                     [=](reserve_iterator<OutputIt> it) {
 2238|      0|                       return format_uint<1, Char>(it, abs_value, num_digits);
 2239|      0|                     });
 2240|      0|  }
 2241|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2241:3): [True: 0, False: 4]
  ------------------
 2242|      0|    int num_digits = count_digits<3>(abs_value);
 2243|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2244|       |    // is not greater than the number of digits.
 2245|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2245:9): [True: 0, False: 0]
  |  Branch (2245:22): [True: 0, False: 0]
  |  Branch (2245:55): [True: 0, False: 0]
  ------------------
 2246|      0|      prefix_append(prefix, '0');
 2247|      0|    return write_int(out, num_digits, prefix, specs,
 2248|      0|                     [=](reserve_iterator<OutputIt> it) {
 2249|      0|                       return format_uint<3, Char>(it, abs_value, num_digits);
 2250|      0|                     });
 2251|      0|  }
 2252|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2252:3): [True: 0, False: 4]
  ------------------
 2253|      0|    return write_char(out, static_cast<Char>(abs_value), specs);
 2254|      0|  default:
  ------------------
  |  Branch (2254:3): [True: 0, False: 4]
  ------------------
 2255|      0|    throw_format_error("invalid format specifier");
 2256|      4|  }
 2257|      0|  return out;
 2258|      4|}
_ZN3fmt2v96detail9write_intINS0_8appenderEcZNS1_9write_intIcS3_mEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEEUlS3_E_EESA_SA_ijRKNS9_IS5_EES7_:
 2041|      4|                                        W write_digits) -> OutputIt {
 2042|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 2043|      4|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (2043:7): [True: 4, False: 0]
  ------------------
 2044|      4|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 2045|      4|    if (prefix != 0) {
  ------------------
  |  Branch (2045:9): [True: 0, False: 4]
  ------------------
 2046|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (2046:44): [True: 0, False: 0]
  ------------------
 2047|      0|        *it++ = static_cast<Char>(p & 0xff);
 2048|      0|    }
 2049|      4|    return base_iterator(out, write_digits(it));
 2050|      4|  }
 2051|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 2052|      0|  return write_padded<align::right>(
 2053|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 2054|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 2055|      0|          *it++ = static_cast<Char>(p & 0xff);
 2056|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 2057|      0|        return write_digits(it);
 2058|      0|      });
 2059|      4|}
_ZZN3fmt2v96detail9write_intIcNS0_8appenderEmEET0_S4_NS1_13write_int_argIT1_EERKNS0_12format_specsIT_EENS1_10locale_refEENKUlS3_E_clES3_:
 2215|      4|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2216|      4|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2217|      4|        });
_ZN3fmt2v96detail13arg_formatterIcEclIyEENS0_8appenderET_:
 3931|      4|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3932|      4|    return detail::write(out, value, specs, locale);
 3933|      4|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEyLi0EEET0_S4_T1_RKNS0_12format_specsIT_EENS1_10locale_refE:
 2271|      4|                                    locale_ref loc) -> OutputIt {
 2272|      4|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2272:7): [True: 0, False: 4]
  |  Branch (2272:26): [True: 0, False: 0]
  ------------------
 2273|      4|  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
 2274|      4|                            loc);
 2275|      4|}
_ZN3fmt2v96detail18make_write_int_argIyEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2168|      4|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2169|      4|  auto prefix = 0u;
 2170|      4|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2171|      4|  if (is_negative(value)) {
  ------------------
  |  Branch (2171:7): [True: 0, False: 4]
  ------------------
 2172|      0|    prefix = 0x01000000 | '-';
 2173|      0|    abs_value = 0 - abs_value;
 2174|      4|  } else {
 2175|      4|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2176|      4|                                            0x1000000u | ' '};
 2177|      4|    prefix = prefixes[sign];
 2178|      4|  }
 2179|      4|  return {abs_value, prefix};
 2180|      4|}
_ZN3fmt2v96detail13arg_formatterIcEclIPKcEENS0_8appenderET_:
 3931|    187|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3932|    187|    return detail::write(out, value, specs, locale);
 3933|    187|  }
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_PKT_RKNS0_12format_specsIS5_EENS1_10locale_refE:
 2359|    187|    -> OutputIt {
 2360|    187|  return specs.type != presentation_type::pointer
  ------------------
  |  Branch (2360:10): [True: 187, False: 0]
  ------------------
 2361|    187|             ? write(out, basic_string_view<Char>(s), specs, {})
 2362|    187|             : write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
 2363|    187|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewINS0_13type_identityIT_E4typeEEERKNS0_12format_specsIS7_EENS1_10locale_refE:
 2353|    187|    -> OutputIt {
 2354|    187|  return write(out, s, specs);
 2355|    187|}
_ZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS6_EE:
 2330|    187|                         const format_specs<Char>& specs) -> OutputIt {
 2331|    187|  auto data = s.data();
 2332|    187|  auto size = s.size();
 2333|    187|  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
  ------------------
  |  Branch (2333:7): [True: 0, False: 187]
  |  Branch (2333:31): [True: 0, False: 0]
  ------------------
 2334|      0|    size = code_point_index(s, to_unsigned(specs.precision));
 2335|    187|  bool is_debug = specs.type == presentation_type::debug;
 2336|    187|  size_t width = 0;
 2337|    187|  if (specs.width != 0) {
  ------------------
  |  Branch (2337:7): [True: 0, False: 187]
  ------------------
 2338|      0|    if (is_debug)
  ------------------
  |  Branch (2338:9): [True: 0, False: 0]
  ------------------
 2339|      0|      width = write_escaped_string(counting_iterator{}, s).count();
 2340|      0|    else
 2341|      0|      width = compute_width(basic_string_view<Char>(data, size));
 2342|      0|  }
 2343|    187|  return write_padded(out, specs, size, width,
 2344|    187|                      [=](reserve_iterator<OutputIt> it) {
 2345|    187|                        if (is_debug) return write_escaped_string(it, s);
 2346|    187|                        return copy_str<Char>(data, data + size, it);
 2347|    187|                      });
 2348|    187|}
_ZN3fmt2v96detail12write_paddedILNS0_5align4typeE1ENS0_8appenderEcZNS1_5writeIcS5_EET0_S7_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS9_EEEUlS5_E_EES7_S7_RKNSB_IT1_EEmmOT2_:
 1783|    187|                                size_t size, size_t width, F&& f) -> OutputIt {
 1784|    187|  static_assert(align == align::left || align == align::right, "");
 1785|    187|  unsigned spec_width = to_unsigned(specs.width);
 1786|    187|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1786:20): [True: 0, False: 187]
  ------------------
 1787|       |  // Shifts are encoded as string literals because static constexpr is not
 1788|       |  // supported in constexpr functions.
 1789|    187|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1789:18): [Folded - Ignored]
  ------------------
 1790|    187|  size_t left_padding = padding >> shifts[specs.align];
 1791|    187|  size_t right_padding = padding - left_padding;
 1792|    187|  auto it = reserve(out, size + padding * specs.fill.size());
 1793|    187|  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
  ------------------
  |  Branch (1793:7): [True: 0, False: 187]
  ------------------
 1794|    187|  it = f(it);
 1795|    187|  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
  ------------------
  |  Branch (1795:7): [True: 0, False: 187]
  ------------------
 1796|    187|  return base_iterator(out, it);
 1797|    187|}
_ZZN3fmt2v96detail5writeIcNS0_8appenderEEET0_S4_NS0_17basic_string_viewIT_EERKNS0_12format_specsIS6_EEENKUlS3_E_clES3_:
 2344|    187|                      [=](reserve_iterator<OutputIt> it) {
 2345|    187|                        if (is_debug) return write_escaped_string(it, s);
  ------------------
  |  Branch (2345:29): [True: 0, False: 187]
  ------------------
 2346|    187|                        return copy_str<Char>(data, data + size, it);
 2347|    187|                      });
_ZZN3fmt2v96detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handlerC2ENS0_8appenderENS7_IcEENS0_17basic_format_argsINS0_20basic_format_contextISE_cEEEESC_:
 4517|    163|        : parse_context(str), context(p_out, p_args, p_loc) {}
_ZN3fmt2v99to_stringIcLm500EEENSt3__112basic_stringIT_NS2_11char_traitsIS4_EENS2_9allocatorIS4_EEEERKNS0_19basic_memory_bufferIS4_XT0_ES8_EE:
 4479|    163|    -> std::basic_string<Char> {
 4480|    163|  auto size = buf.size();
 4481|    163|  detail::assume(size < std::basic_string<Char>().max_size());
 4482|    163|  return std::basic_string<Char>(buf.data(), size);
 4483|    163|}
_ZN3fmt2v96detail6assumeEb:
  510|    163|FMT_INLINE void assume(bool condition) {
  511|    163|  (void)condition;
  512|    163|#if FMT_HAS_BUILTIN(__builtin_assume) && !FMT_ICC_VERSION
  513|    163|  __builtin_assume(condition);
  514|    163|#endif
  515|    163|}

_ZN10ImGuiStyleC2Ev:
 1113|      1|{
 1114|      1|    Alpha                   = 1.0f;             // Global alpha applies to everything in Dear ImGui.
 1115|      1|    DisabledAlpha           = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
 1116|      1|    WindowPadding           = ImVec2(8,8);      // Padding within a window
 1117|      1|    WindowRounding          = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
 1118|      1|    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1119|      1|    WindowMinSize           = ImVec2(32,32);    // Minimum window size
 1120|      1|    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
 1121|      1|    WindowMenuButtonPosition= ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
 1122|      1|    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
 1123|      1|    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1124|      1|    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
 1125|      1|    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1126|      1|    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
 1127|      1|    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
 1128|      1|    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
 1129|      1|    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
 1130|      1|    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
 1131|      1|    CellPadding             = ImVec2(4,2);      // Padding within a table cell
 1132|      1|    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
 1133|      1|    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
 1134|      1|    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
 1135|      1|    ScrollbarSize           = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
 1136|      1|    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
 1137|      1|    GrabMinSize             = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar
 1138|      1|    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
 1139|      1|    LogSliderDeadzone       = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
 1140|      1|    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
 1141|      1|    TabBorderSize           = 0.0f;             // Thickness of border around tabs.
 1142|      1|    TabMinWidthForCloseButton = 0.0f;           // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
 1143|      1|    ColorButtonPosition     = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
 1144|      1|    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
 1145|      1|    SelectableTextAlign     = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
 1146|      1|    SeparatorTextBorderSize = 3.0f;             // Thickkness of border in SeparatorText()
 1147|      1|    SeparatorTextAlign      = ImVec2(0.0f,0.5f);// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
 1148|      1|    SeparatorTextPadding    = ImVec2(20.0f,3.f);// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
 1149|      1|    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
 1150|      1|    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
 1151|      1|    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
 1152|      1|    AntiAliasedLines        = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
 1153|      1|    AntiAliasedLinesUseTex  = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
 1154|      1|    AntiAliasedFill         = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
 1155|      1|    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
 1156|      1|    CircleTessellationMaxError = 0.30f;         // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
 1157|       |
 1158|       |    // Default theme
 1159|      1|    ImGui::StyleColorsDark(this);
 1160|      1|}
_ZN7ImGuiIOC2Ev:
 1193|      1|{
 1194|       |    // Most fields are initialized with zero
 1195|      1|    memset(this, 0, sizeof(*this));
 1196|      1|    IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);
  ------------------
  |  |  239|      1|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
 1197|       |
 1198|       |    // Settings
 1199|      1|    ConfigFlags = ImGuiConfigFlags_None;
 1200|      1|    BackendFlags = ImGuiBackendFlags_None;
 1201|      1|    DisplaySize = ImVec2(-1.0f, -1.0f);
 1202|      1|    DeltaTime = 1.0f / 60.0f;
 1203|      1|    IniSavingRate = 5.0f;
 1204|      1|    IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
 1205|      1|    LogFilename = "imgui_log.txt";
 1206|      1|    MouseDoubleClickTime = 0.30f;
 1207|      1|    MouseDoubleClickMaxDist = 6.0f;
 1208|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1209|       |    for (int i = 0; i < ImGuiKey_COUNT; i++)
 1210|       |        KeyMap[i] = -1;
 1211|       |#endif
 1212|      1|    KeyRepeatDelay = 0.275f;
 1213|      1|    KeyRepeatRate = 0.050f;
 1214|      1|    HoverDelayNormal = 0.30f;
 1215|      1|    HoverDelayShort = 0.10f;
 1216|      1|    UserData = NULL;
 1217|       |
 1218|      1|    Fonts = NULL;
 1219|      1|    FontGlobalScale = 1.0f;
 1220|      1|    FontDefault = NULL;
 1221|      1|    FontAllowUserScaling = false;
 1222|      1|    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
 1223|       |
 1224|       |    // Docking options (when ImGuiConfigFlags_DockingEnable is set)
 1225|      1|    ConfigDockingNoSplit = false;
 1226|      1|    ConfigDockingWithShift = false;
 1227|      1|    ConfigDockingAlwaysTabBar = false;
 1228|      1|    ConfigDockingTransparentPayload = false;
 1229|       |
 1230|       |    // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
 1231|      1|    ConfigViewportsNoAutoMerge = false;
 1232|      1|    ConfigViewportsNoTaskBarIcon = false;
 1233|      1|    ConfigViewportsNoDecoration = true;
 1234|      1|    ConfigViewportsNoDefaultParent = false;
 1235|       |
 1236|       |    // Miscellaneous options
 1237|      1|    MouseDrawCursor = false;
 1238|       |#ifdef __APPLE__
 1239|       |    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
 1240|       |#else
 1241|      1|    ConfigMacOSXBehaviors = false;
 1242|      1|#endif
 1243|      1|    ConfigInputTrickleEventQueue = true;
 1244|      1|    ConfigInputTextCursorBlink = true;
 1245|      1|    ConfigInputTextEnterKeepActive = false;
 1246|      1|    ConfigDragClickToInputText = false;
 1247|      1|    ConfigWindowsResizeFromEdges = true;
 1248|      1|    ConfigWindowsMoveFromTitleBarOnly = false;
 1249|      1|    ConfigMemoryCompactTimer = 60.0f;
 1250|       |
 1251|       |    // Platform Functions
 1252|      1|    BackendPlatformName = BackendRendererName = NULL;
 1253|      1|    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
 1254|      1|    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
 1255|      1|    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
 1256|      1|    ClipboardUserData = NULL;
 1257|      1|    SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;
 1258|       |
 1259|       |    // Input (NB: we already have memset zero the entire structure!)
 1260|      1|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1261|      1|    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
 1262|      1|    MouseDragThreshold = 6.0f;
 1263|      6|    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
  ------------------
  |  |   87|      6|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1263:21): [True: 5, False: 1]
  ------------------
 1264|    141|    for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
  ------------------
  |  |   87|    141|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1264:21): [True: 140, False: 1]
  ------------------
 1265|      1|    AppAcceptingEvents = true;
 1266|      1|    BackendUsingLegacyKeyArrays = (ImS8)-1;
 1267|      1|    BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
 1268|      1|}
_ZN7ImGuiIO17AddInputCharacterEj:
 1275|  15.0k|{
 1276|  15.0k|    ImGuiContext& g = *GImGui;
 1277|  15.0k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  15.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1278|  15.0k|    if (c == 0 || !AppAcceptingEvents)
  ------------------
  |  Branch (1278:9): [True: 6.42k, False: 8.61k]
  |  Branch (1278:19): [True: 0, False: 8.61k]
  ------------------
 1279|  6.42k|        return;
 1280|       |
 1281|  8.61k|    ImGuiInputEvent e;
 1282|  8.61k|    e.Type = ImGuiInputEventType_Text;
 1283|  8.61k|    e.Source = ImGuiInputSource_Keyboard;
 1284|  8.61k|    e.Text.Char = c;
 1285|  8.61k|    g.InputEventsQueue.push_back(e);
 1286|  8.61k|}
_ZN7ImGuiIO22AddInputCharacterUTF16Et:
 1291|  1.68k|{
 1292|  1.68k|    if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
  ------------------
  |  Branch (1292:10): [True: 316, False: 1.37k]
  |  Branch (1292:20): [True: 76, False: 240]
  |  Branch (1292:49): [True: 0, False: 1.61k]
  ------------------
 1293|     76|        return;
 1294|       |
 1295|  1.61k|    if ((c & 0xFC00) == 0xD800) // High surrogate, must save
  ------------------
  |  Branch (1295:9): [True: 820, False: 793]
  ------------------
 1296|    820|    {
 1297|    820|        if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1297:13): [True: 233, False: 587]
  ------------------
 1298|    233|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2277|    233|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1299|    820|        InputQueueSurrogate = c;
 1300|    820|        return;
 1301|    820|    }
 1302|       |
 1303|    793|    ImWchar cp = c;
 1304|    793|    if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1304:9): [True: 579, False: 214]
  ------------------
 1305|    579|    {
 1306|    579|        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
  ------------------
  |  Branch (1306:13): [True: 579, False: 0]
  ------------------
 1307|    579|        {
 1308|    579|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2277|    579|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1309|    579|        }
 1310|      0|        else
 1311|      0|        {
 1312|      0|#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF
 1313|      0|            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
  ------------------
  |  | 2277|      0|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1314|       |#else
 1315|       |            cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
 1316|       |#endif
 1317|      0|        }
 1318|       |
 1319|    579|        InputQueueSurrogate = 0;
 1320|    579|    }
 1321|    793|    AddInputCharacter((unsigned)cp);
 1322|    793|}
_ZN7ImGuiIO22AddInputCharactersUTF8EPKc:
 1325|     70|{
 1326|     70|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1326:9): [True: 0, False: 70]
  ------------------
 1327|      0|        return;
 1328|     70|    while (*utf8_chars != 0)
  ------------------
  |  Branch (1328:12): [True: 0, False: 70]
  ------------------
 1329|      0|    {
 1330|      0|        unsigned int c = 0;
 1331|      0|        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
 1332|      0|        AddInputCharacter(c);
 1333|      0|    }
 1334|     70|}
_ZN7ImGuiIO20ClearInputCharactersEv:
 1338|  9.34k|{
 1339|  9.34k|    InputQueueCharacters.resize(0);
 1340|  9.34k|}
_ZN7ImGuiIO14ClearInputKeysEv:
 1344|  13.7k|{
 1345|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1346|       |    memset(KeysDown, 0, sizeof(KeysDown));
 1347|       |#endif
 1348|  1.93M|    for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++)
  ------------------
  |  |   87|  1.93M|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1348:21): [True: 1.92M, False: 13.7k]
  ------------------
 1349|  1.92M|    {
 1350|  1.92M|        KeysData[n].Down             = false;
 1351|  1.92M|        KeysData[n].DownDuration     = -1.0f;
 1352|  1.92M|        KeysData[n].DownDurationPrev = -1.0f;
 1353|  1.92M|    }
 1354|  13.7k|    KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
 1355|  13.7k|    KeyMods = ImGuiMod_None;
 1356|  13.7k|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1357|  82.4k|    for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)
  ------------------
  |  |   87|  82.4k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1357:21): [True: 68.7k, False: 13.7k]
  ------------------
 1358|  68.7k|    {
 1359|  68.7k|        MouseDown[n] = false;
 1360|  68.7k|        MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
 1361|  68.7k|    }
 1362|  13.7k|    MouseWheel = MouseWheelH = 0.0f;
 1363|  13.7k|}
_ZN7ImGuiIO17AddKeyAnalogEventE8ImGuiKeybf:
 1387|  3.73k|{
 1388|       |    //if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
 1389|  3.73k|    if (key == ImGuiKey_None || !AppAcceptingEvents)
  ------------------
  |  Branch (1389:9): [True: 0, False: 3.73k]
  |  Branch (1389:33): [True: 0, False: 3.73k]
  ------------------
 1390|      0|        return;
 1391|  3.73k|    ImGuiContext& g = *GImGui;
 1392|  3.73k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  3.73k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1393|  3.73k|    IM_ASSERT(ImGui::IsNamedKeyOrModKey(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
  ------------------
  |  |   23|  3.73k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1394|  3.73k|    IM_ASSERT(!ImGui::IsAliasKey(key)); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.
  ------------------
  |  |   23|  3.73k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1395|  3.73k|    IM_ASSERT(key != ImGuiMod_Shortcut); // We could easily support the translation here but it seems saner to not accept it (TestEngine perform a translation itself)
  ------------------
  |  |   23|  3.73k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1396|       |
 1397|       |    // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
 1398|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1399|       |    IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1400|       |    if (BackendUsingLegacyKeyArrays == -1)
 1401|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 1402|       |            IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1403|       |    BackendUsingLegacyKeyArrays = 0;
 1404|       |#endif
 1405|  3.73k|    if (ImGui::IsGamepadKey(key))
  ------------------
  |  Branch (1405:9): [True: 0, False: 3.73k]
  ------------------
 1406|      0|        BackendUsingLegacyNavInputArray = false;
 1407|       |
 1408|       |    // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
 1409|  3.73k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_Key, (int)key);
 1410|  3.73k|    const ImGuiKeyData* key_data = ImGui::GetKeyData(key);
 1411|  3.73k|    const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
  ------------------
  |  Branch (1411:34): [True: 105, False: 3.62k]
  ------------------
 1412|  3.73k|    const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
  ------------------
  |  Branch (1412:37): [True: 105, False: 3.62k]
  ------------------
 1413|  3.73k|    if (latest_key_down == down && latest_key_analog == analog_value)
  ------------------
  |  Branch (1413:9): [True: 549, False: 3.18k]
  |  Branch (1413:36): [True: 461, False: 88]
  ------------------
 1414|    461|        return;
 1415|       |
 1416|       |    // Add event
 1417|  3.27k|    ImGuiInputEvent e;
 1418|  3.27k|    e.Type = ImGuiInputEventType_Key;
 1419|  3.27k|    e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
  ------------------
  |  Branch (1419:16): [True: 0, False: 3.27k]
  ------------------
 1420|  3.27k|    e.Key.Key = key;
 1421|  3.27k|    e.Key.Down = down;
 1422|  3.27k|    e.Key.AnalogValue = analog_value;
 1423|  3.27k|    g.InputEventsQueue.push_back(e);
 1424|  3.27k|}
_ZN7ImGuiIO11AddKeyEventE8ImGuiKeyb:
 1427|    970|{
 1428|    970|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1428:9): [True: 0, False: 970]
  ------------------
 1429|      0|        return;
 1430|    970|    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
  ------------------
  |  Branch (1430:34): [True: 749, False: 221]
  ------------------
 1431|    970|}
_ZN7ImGuiIO16AddMousePosEventEff:
 1466|  9.30k|{
 1467|  9.30k|    ImGuiContext& g = *GImGui;
 1468|  9.30k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  9.30k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1469|  9.30k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1469:9): [True: 0, False: 9.30k]
  ------------------
 1470|      0|        return;
 1471|       |
 1472|       |    // Apply same flooring as UpdateMouseInputs()
 1473|  9.30k|    ImVec2 pos((x > -FLT_MAX) ? ImFloorSigned(x) : x, (y > -FLT_MAX) ? ImFloorSigned(y) : y);
  ------------------
  |  Branch (1473:16): [True: 9.30k, False: 0]
  |  Branch (1473:55): [True: 9.30k, False: 0]
  ------------------
 1474|       |
 1475|       |    // Filter duplicate
 1476|  9.30k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_MousePos);
 1477|  9.30k|    const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
  ------------------
  |  Branch (1477:31): [True: 3.32k, False: 5.97k]
  ------------------
 1478|  9.30k|    if (latest_pos.x == pos.x && latest_pos.y == pos.y)
  ------------------
  |  Branch (1478:9): [True: 4.03k, False: 5.26k]
  |  Branch (1478:34): [True: 3.79k, False: 237]
  ------------------
 1479|  3.79k|        return;
 1480|       |
 1481|  5.50k|    ImGuiInputEvent e;
 1482|  5.50k|    e.Type = ImGuiInputEventType_MousePos;
 1483|  5.50k|    e.Source = ImGuiInputSource_Mouse;
 1484|  5.50k|    e.MousePos.PosX = pos.x;
 1485|  5.50k|    e.MousePos.PosY = pos.y;
 1486|  5.50k|    g.InputEventsQueue.push_back(e);
 1487|  5.50k|}
_ZN7ImGuiIO19AddMouseButtonEventEib:
 1490|  23.5k|{
 1491|  23.5k|    ImGuiContext& g = *GImGui;
 1492|  23.5k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  23.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1493|  23.5k|    IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  23.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1494|  23.5k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1494:9): [True: 0, False: 23.5k]
  ------------------
 1495|      0|        return;
 1496|       |
 1497|       |    // Filter duplicate
 1498|  23.5k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_MouseButton, (int)mouse_button);
 1499|  23.5k|    const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
  ------------------
  |  Branch (1499:37): [True: 4.40k, False: 19.1k]
  ------------------
 1500|  23.5k|    if (latest_button_down == down)
  ------------------
  |  Branch (1500:9): [True: 12.7k, False: 10.7k]
  ------------------
 1501|  12.7k|        return;
 1502|       |
 1503|  10.7k|    ImGuiInputEvent e;
 1504|  10.7k|    e.Type = ImGuiInputEventType_MouseButton;
 1505|  10.7k|    e.Source = ImGuiInputSource_Mouse;
 1506|  10.7k|    e.MouseButton.Button = mouse_button;
 1507|  10.7k|    e.MouseButton.Down = down;
 1508|  10.7k|    g.InputEventsQueue.push_back(e);
 1509|  10.7k|}
_ZN7ImGuiIO18AddMouseWheelEventEff:
 1513|  4.18k|{
 1514|  4.18k|    ImGuiContext& g = *GImGui;
 1515|  4.18k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  4.18k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1516|       |
 1517|       |    // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
 1518|  4.18k|    if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
  ------------------
  |  Branch (1518:9): [True: 0, False: 4.18k]
  |  Branch (1518:33): [True: 3.71k, False: 470]
  |  Branch (1518:52): [True: 132, False: 3.58k]
  ------------------
 1519|    132|        return;
 1520|       |
 1521|  4.05k|    ImGuiInputEvent e;
 1522|  4.05k|    e.Type = ImGuiInputEventType_MouseWheel;
 1523|  4.05k|    e.Source = ImGuiInputSource_Mouse;
 1524|  4.05k|    e.MouseWheel.WheelX = wheel_x;
 1525|  4.05k|    e.MouseWheel.WheelY = wheel_y;
 1526|  4.05k|    g.InputEventsQueue.push_back(e);
 1527|  4.05k|}
_ZN7ImGuiIO13AddFocusEventEb:
 1551|  7.41k|{
 1552|  7.41k|    ImGuiContext& g = *GImGui;
 1553|  7.41k|    IM_ASSERT(&g.IO == this && "Can only add events to current context.");
  ------------------
  |  |   23|  7.41k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1554|       |
 1555|       |    // Filter duplicate
 1556|  7.41k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_Focus);
 1557|  7.41k|    const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
  ------------------
  |  Branch (1557:33): [True: 2.35k, False: 5.06k]
  ------------------
 1558|  7.41k|    if (latest_focused == focused)
  ------------------
  |  Branch (1558:9): [True: 1.08k, False: 6.33k]
  ------------------
 1559|  1.08k|        return;
 1560|       |
 1561|  6.33k|    ImGuiInputEvent e;
 1562|  6.33k|    e.Type = ImGuiInputEventType_Focus;
 1563|  6.33k|    e.AppFocused.Focused = focused;
 1564|  6.33k|    g.InputEventsQueue.push_back(e);
 1565|  6.33k|}
_Z9ImStrncpyPcPKcm:
 1707|     40|{
 1708|     40|    if (count < 1)
  ------------------
  |  Branch (1708:9): [True: 0, False: 40]
  ------------------
 1709|      0|        return;
 1710|     40|    if (count > 1)
  ------------------
  |  Branch (1710:9): [True: 40, False: 0]
  ------------------
 1711|     40|        strncpy(dst, src, count - 1);
 1712|     40|    dst[count - 1] = 0;
 1713|     40|}
_Z8ImStrdupPKc:
 1716|      3|{
 1717|      3|    size_t len = strlen(str);
 1718|      3|    void* buf = IM_ALLOC(len + 1);
  ------------------
  |  | 1820|      3|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 1719|      3|    return (char*)memcpy(buf, (const void*)str, len + 1);
 1720|      3|}
_Z14ImFormatStringPcmPKcz:
 1832|      1|{
 1833|      1|    va_list args;
 1834|      1|    va_start(args, fmt);
 1835|       |#ifdef IMGUI_USE_STB_SPRINTF
 1836|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 1837|       |#else
 1838|      1|    int w = vsnprintf(buf, buf_size, fmt, args);
 1839|      1|#endif
 1840|      1|    va_end(args);
 1841|      1|    if (buf == NULL)
  ------------------
  |  Branch (1841:9): [True: 0, False: 1]
  ------------------
 1842|      0|        return w;
 1843|      1|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (1843:9): [True: 0, False: 1]
  |  Branch (1843:20): [True: 0, False: 1]
  ------------------
 1844|      0|        w = (int)buf_size - 1;
 1845|      1|    buf[w] = 0;
 1846|      1|    return w;
 1847|      1|}
_Z15ImFormatStringVPcmPKcP13__va_list_tag:
 1850|    323|{
 1851|       |#ifdef IMGUI_USE_STB_SPRINTF
 1852|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 1853|       |#else
 1854|    323|    int w = vsnprintf(buf, buf_size, fmt, args);
 1855|    323|#endif
 1856|    323|    if (buf == NULL)
  ------------------
  |  Branch (1856:9): [True: 0, False: 323]
  ------------------
 1857|      0|        return w;
 1858|    323|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (1858:9): [True: 0, False: 323]
  |  Branch (1858:20): [True: 0, False: 323]
  ------------------
 1859|      0|        w = (int)buf_size - 1;
 1860|    323|    buf[w] = 0;
 1861|    323|    return w;
 1862|    323|}
_Z26ImFormatStringToTempBufferPPKcS1_S0_z:
 1866|    323|{
 1867|    323|    ImGuiContext& g = *GImGui;
 1868|    323|    va_list args;
 1869|    323|    va_start(args, fmt);
 1870|    323|    if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0)
  ------------------
  |  Branch (1870:9): [True: 323, False: 0]
  |  Branch (1870:26): [True: 323, False: 0]
  |  Branch (1870:43): [True: 0, False: 323]
  ------------------
 1871|      0|    {
 1872|      0|        const char* buf = va_arg(args, const char*); // Skip formatting when using "%s"
 1873|      0|        *out_buf = buf;
 1874|      0|        if (out_buf_end) { *out_buf_end = buf + strlen(buf); }
  ------------------
  |  Branch (1874:13): [True: 0, False: 0]
  ------------------
 1875|      0|    }
 1876|    323|    else
 1877|    323|    {
 1878|    323|        int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
 1879|    323|        *out_buf = g.TempBuffer.Data;
 1880|    323|        if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }
  ------------------
  |  Branch (1880:13): [True: 0, False: 323]
  ------------------
 1881|    323|    }
 1882|    323|    va_end(args);
 1883|    323|}
_Z10ImHashDataPKvmj:
 1929|    321|{
 1930|    321|    ImU32 crc = ~seed;
 1931|    321|    const unsigned char* data = (const unsigned char*)data_p;
 1932|    321|    const ImU32* crc32_lut = GCrc32LookupTable;
 1933|  1.60k|    while (data_size-- != 0)
  ------------------
  |  Branch (1933:12): [True: 1.28k, False: 321]
  ------------------
 1934|  1.28k|        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
 1935|    321|    return ~crc;
 1936|    321|}
_Z9ImHashStrPKcmj:
 1945|   362k|{
 1946|   362k|    seed = ~seed;
 1947|   362k|    ImU32 crc = seed;
 1948|   362k|    const unsigned char* data = (const unsigned char*)data_p;
 1949|   362k|    const ImU32* crc32_lut = GCrc32LookupTable;
 1950|   362k|    if (data_size != 0)
  ------------------
  |  Branch (1950:9): [True: 0, False: 362k]
  ------------------
 1951|      0|    {
 1952|      0|        while (data_size-- != 0)
  ------------------
  |  Branch (1952:16): [True: 0, False: 0]
  ------------------
 1953|      0|        {
 1954|      0|            unsigned char c = *data++;
 1955|      0|            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (1955:17): [True: 0, False: 0]
  |  Branch (1955:29): [True: 0, False: 0]
  |  Branch (1955:47): [True: 0, False: 0]
  |  Branch (1955:65): [True: 0, False: 0]
  ------------------
 1956|      0|                crc = seed;
 1957|      0|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 1958|      0|        }
 1959|      0|    }
 1960|   362k|    else
 1961|   362k|    {
 1962|  4.26M|        while (unsigned char c = *data++)
  ------------------
  |  Branch (1962:30): [True: 3.90M, False: 362k]
  ------------------
 1963|  3.90M|        {
 1964|  3.90M|            if (c == '#' && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (1964:17): [True: 361k, False: 3.53M]
  |  Branch (1964:29): [True: 90.2k, False: 271k]
  |  Branch (1964:47): [True: 0, False: 90.2k]
  ------------------
 1965|      0|                crc = seed;
 1966|  3.90M|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 1967|  3.90M|        }
 1968|   362k|    }
 1969|   362k|    return ~crc;
 1970|   362k|}
_Z18ImTextCharFromUtf8PjPKcS1_:
 2055|    845|{
 2056|    845|    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
 2057|    845|    static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
 2058|    845|    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
 2059|    845|    static const int shiftc[] = { 0, 18, 12, 6, 0 };
 2060|    845|    static const int shifte[] = { 0, 6, 4, 2, 0 };
 2061|    845|    int len = lengths[*(const unsigned char*)in_text >> 3];
 2062|    845|    int wanted = len + (len ? 0 : 1);
  ------------------
  |  Branch (2062:25): [True: 845, False: 0]
  ------------------
 2063|       |
 2064|    845|    if (in_text_end == NULL)
  ------------------
  |  Branch (2064:9): [True: 0, False: 845]
  ------------------
 2065|      0|        in_text_end = in_text + wanted; // Max length, nulls will be taken into account.
 2066|       |
 2067|       |    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
 2068|       |    // so it is fast even with excessive branching.
 2069|    845|    unsigned char s[4];
 2070|    845|    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
  ------------------
  |  Branch (2070:12): [True: 845, False: 0]
  ------------------
 2071|    845|    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
  ------------------
  |  Branch (2071:12): [True: 845, False: 0]
  ------------------
 2072|    845|    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
  ------------------
  |  Branch (2072:12): [True: 817, False: 28]
  ------------------
 2073|    845|    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;
  ------------------
  |  Branch (2073:12): [True: 374, False: 471]
  ------------------
 2074|       |
 2075|       |    // Assume a four-byte character and load four bytes. Unused bits are shifted out.
 2076|    845|    *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
 2077|    845|    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
 2078|    845|    *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
 2079|    845|    *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
 2080|    845|    *out_char >>= shiftc[len];
 2081|       |
 2082|       |    // Accumulate the various error conditions.
 2083|    845|    int e = 0;
 2084|    845|    e  = (*out_char < mins[len]) << 6; // non-canonical encoding
 2085|    845|    e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
 2086|    845|    e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
  ------------------
  |  | 2281|    845|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
 2087|    845|    e |= (s[1] & 0xc0) >> 2;
 2088|    845|    e |= (s[2] & 0xc0) >> 4;
 2089|    845|    e |= (s[3]       ) >> 6;
 2090|    845|    e ^= 0x2a; // top two bits of each tail byte correct?
 2091|    845|    e >>= shifte[len];
 2092|       |
 2093|    845|    if (e)
  ------------------
  |  Branch (2093:9): [True: 290, False: 555]
  ------------------
 2094|    290|    {
 2095|       |        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
 2096|       |        // One byte is consumed in case of invalid first byte of in_text.
 2097|       |        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
 2098|       |        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
 2099|    290|        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
 2100|    290|        *out_char = IM_UNICODE_CODEPOINT_INVALID;
  ------------------
  |  | 2277|    290|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 2101|    290|    }
 2102|       |
 2103|    845|    return wanted;
 2104|    845|}
_ZN5ImGui23ColorConvertU32ToFloat4Ej:
 2239|   221k|{
 2240|   221k|    float s = 1.0f / 255.0f;
 2241|   221k|    return ImVec4(
 2242|   221k|        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2446|   221k|#define IM_COL32_R_SHIFT    0
  ------------------
 2243|   221k|        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2447|   221k|#define IM_COL32_G_SHIFT    8
  ------------------
 2244|   221k|        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2448|   221k|#define IM_COL32_B_SHIFT    16
  ------------------
 2245|   221k|        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
  ------------------
  |  | 2449|   221k|#define IM_COL32_A_SHIFT    24
  ------------------
 2246|   221k|}
_ZN5ImGui23ColorConvertFloat4ToU32ERK6ImVec4:
 2249|  1.21M|{
 2250|  1.21M|    ImU32 out;
 2251|  1.21M|    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  |  268|  1.21M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  | 2446|  1.21M|#define IM_COL32_R_SHIFT    0
  ------------------
 2252|  1.21M|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  |  268|  1.21M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  | 2447|  1.21M|#define IM_COL32_G_SHIFT    8
  ------------------
 2253|  1.21M|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  |  268|  1.21M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  | 2448|  1.21M|#define IM_COL32_B_SHIFT    16
  ------------------
 2254|  1.21M|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  |  268|  1.21M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  | 2449|  1.21M|#define IM_COL32_A_SHIFT    24
  ------------------
 2255|  1.21M|    return out;
 2256|  1.21M|}
_ZNK12ImGuiStorage10GetVoidPtrEj:
 2375|   180k|{
 2376|   180k|    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
 2377|   180k|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2377:9): [True: 1, False: 180k]
  |  Branch (2377:29): [True: 2, False: 180k]
  ------------------
 2378|      3|        return NULL;
 2379|   180k|    return it->val_p;
 2380|   180k|}
_ZN12ImGuiStorage10SetVoidPtrEjPv:
 2441|      3|{
 2442|      3|    ImGuiStoragePair* it = LowerBound(Data, key);
 2443|      3|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2443:9): [True: 1, False: 2]
  |  Branch (2443:29): [True: 2, False: 0]
  ------------------
 2444|      3|    {
 2445|      3|        Data.insert(it, ImGuiStoragePair(key, val));
 2446|      3|        return;
 2447|      3|    }
 2448|      0|    it->val_p = val;
 2449|      0|}
_ZN5ImGui8GetStyleEv:
 2978|   130k|{
 2979|   130k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|   130k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2980|   130k|    return GImGui->Style;
 2981|   130k|}
_ZN5ImGui11GetColorU32Eif:
 2984|  1.08M|{
 2985|  1.08M|    ImGuiStyle& style = GImGui->Style;
 2986|  1.08M|    ImVec4 c = style.Colors[idx];
 2987|  1.08M|    c.w *= style.Alpha * alpha_mul;
 2988|  1.08M|    return ColorConvertFloat4ToU32(c);
 2989|  1.08M|}
_ZN5ImGui14PushStyleColorEiRK6ImVec4:
 3027|  90.2k|{
 3028|  90.2k|    ImGuiContext& g = *GImGui;
 3029|  90.2k|    ImGuiColorMod backup;
 3030|  90.2k|    backup.Col = idx;
 3031|  90.2k|    backup.BackupValue = g.Style.Colors[idx];
 3032|  90.2k|    g.ColorStack.push_back(backup);
 3033|  90.2k|    g.Style.Colors[idx] = col;
 3034|  90.2k|}
_ZN5ImGui13PopStyleColorEi:
 3037|  90.2k|{
 3038|  90.2k|    ImGuiContext& g = *GImGui;
 3039|  90.2k|    if (g.ColorStack.Size < count)
  ------------------
  |  Branch (3039:9): [True: 0, False: 90.2k]
  ------------------
 3040|      0|    {
 3041|      0|        IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times: stack underflow.");
  ------------------
  |  |  253|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3042|      0|        count = g.ColorStack.Size;
 3043|      0|    }
 3044|   180k|    while (count > 0)
  ------------------
  |  Branch (3044:12): [True: 90.2k, False: 90.2k]
  ------------------
 3045|  90.2k|    {
 3046|  90.2k|        ImGuiColorMod& backup = g.ColorStack.back();
 3047|  90.2k|        g.Style.Colors[backup.Col] = backup.BackupValue;
 3048|  90.2k|        g.ColorStack.pop_back();
 3049|  90.2k|        count--;
 3050|  90.2k|    }
 3051|  90.2k|}
_ZN5ImGui12PushStyleVarEiRK6ImVec2:
 3120|  90.2k|{
 3121|  90.2k|    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
 3122|  90.2k|    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
  ------------------
  |  Branch (3122:9): [True: 90.2k, False: 0]
  |  Branch (3122:50): [True: 90.2k, False: 0]
  ------------------
 3123|  90.2k|    {
 3124|  90.2k|        ImGuiContext& g = *GImGui;
 3125|  90.2k|        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
 3126|  90.2k|        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
 3127|  90.2k|        *pvar = val;
 3128|  90.2k|        return;
 3129|  90.2k|    }
 3130|      0|    IM_ASSERT(0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3131|      0|}
_ZN5ImGui11PopStyleVarEi:
 3134|  90.2k|{
 3135|  90.2k|    ImGuiContext& g = *GImGui;
 3136|  90.2k|    if (g.StyleVarStack.Size < count)
  ------------------
  |  Branch (3136:9): [True: 0, False: 90.2k]
  ------------------
 3137|      0|    {
 3138|      0|        IM_ASSERT_USER_ERROR(g.StyleVarStack.Size > count, "Calling PopStyleVar() too many times: stack underflow.");
  ------------------
  |  |  253|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3139|      0|        count = g.StyleVarStack.Size;
 3140|      0|    }
 3141|   180k|    while (count > 0)
  ------------------
  |  Branch (3141:12): [True: 90.2k, False: 90.2k]
  ------------------
 3142|  90.2k|    {
 3143|       |        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
 3144|  90.2k|        ImGuiStyleMod& backup = g.StyleVarStack.back();
 3145|  90.2k|        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
 3146|  90.2k|        void* data = info->GetVarPtr(&g.Style);
 3147|  90.2k|        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
  ------------------
  |  Branch (3147:13): [True: 90.2k, False: 0]
  |  Branch (3147:50): [True: 0, False: 90.2k]
  ------------------
 3148|  90.2k|        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
  ------------------
  |  Branch (3148:18): [True: 90.2k, False: 0]
  |  Branch (3148:55): [True: 90.2k, False: 0]
  ------------------
 3149|  90.2k|        g.StyleVarStack.pop_back();
 3150|  90.2k|        count--;
 3151|  90.2k|    }
 3152|  90.2k|}
_ZN5ImGui19FindRenderedTextEndEPKcS1_:
 3228|   360k|{
 3229|   360k|    const char* text_display_end = text;
 3230|   360k|    if (!text_end)
  ------------------
  |  Branch (3230:9): [True: 360k, False: 0]
  ------------------
 3231|   360k|        text_end = (const char*)-1;
 3232|       |
 3233|  3.24M|    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
  ------------------
  |  Branch (3233:12): [True: 3.24M, False: 0]
  |  Branch (3233:43): [True: 3.06M, False: 180k]
  |  Branch (3233:73): [True: 2.88M, False: 180k]
  |  Branch (3233:103): [True: 0, False: 180k]
  ------------------
 3234|  2.88M|        text_display_end++;
 3235|   360k|    return text_display_end;
 3236|   360k|}
_ZN5ImGui19RenderTextClippedExEP10ImDrawListRK6ImVec2S4_PKcS6_PS3_S4_PK6ImRect:
 3285|   180k|{
 3286|       |    // Perform CPU side clipping for single clipped element to avoid using scissor state
 3287|   180k|    ImVec2 pos = pos_min;
 3288|   180k|    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);
  ------------------
  |  Branch (3288:30): [True: 180k, False: 0]
  ------------------
 3289|       |
 3290|   180k|    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
  ------------------
  |  Branch (3290:30): [True: 180k, False: 0]
  ------------------
 3291|   180k|    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
  ------------------
  |  Branch (3291:30): [True: 180k, False: 0]
  ------------------
 3292|   180k|    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
  ------------------
  |  Branch (3292:26): [True: 90.2k, False: 90.2k]
  |  Branch (3292:66): [True: 0, False: 90.2k]
  ------------------
 3293|   180k|    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
  ------------------
  |  Branch (3293:9): [True: 180k, False: 0]
  ------------------
 3294|   180k|        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);
  ------------------
  |  Branch (3294:26): [True: 0, False: 180k]
  |  Branch (3294:51): [True: 0, False: 180k]
  ------------------
 3295|       |
 3296|       |    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
 3297|   180k|    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
  ------------------
  |  Branch (3297:9): [True: 0, False: 180k]
  ------------------
 3298|   180k|    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
  ------------------
  |  Branch (3298:9): [True: 180k, False: 0]
  ------------------
 3299|       |
 3300|       |    // Render
 3301|   180k|    if (need_clipping)
  ------------------
  |  Branch (3301:9): [True: 90.2k, False: 90.2k]
  ------------------
 3302|  90.2k|    {
 3303|  90.2k|        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
 3304|  90.2k|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
 3305|  90.2k|    }
 3306|  90.2k|    else
 3307|  90.2k|    {
 3308|  90.2k|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
 3309|  90.2k|    }
 3310|   180k|}
_ZN5ImGui17RenderTextClippedERK6ImVec2S2_PKcS4_PS1_S2_PK6ImRect:
 3313|   180k|{
 3314|       |    // Hide anything after a '##' string
 3315|   180k|    const char* text_display_end = FindRenderedTextEnd(text, text_end);
 3316|   180k|    const int text_len = (int)(text_display_end - text);
 3317|   180k|    if (text_len == 0)
  ------------------
  |  Branch (3317:9): [True: 0, False: 180k]
  ------------------
 3318|      0|        return;
 3319|       |
 3320|   180k|    ImGuiContext& g = *GImGui;
 3321|   180k|    ImGuiWindow* window = g.CurrentWindow;
 3322|   180k|    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
 3323|   180k|    if (g.LogEnabled)
  ------------------
  |  Branch (3323:9): [True: 0, False: 180k]
  ------------------
 3324|      0|        LogRenderedText(&pos_min, text, text_display_end);
 3325|   180k|}
_ZN5ImGui11RenderFrameE6ImVec2S0_jbf:
 3388|  89.9k|{
 3389|  89.9k|    ImGuiContext& g = *GImGui;
 3390|  89.9k|    ImGuiWindow* window = g.CurrentWindow;
 3391|  89.9k|    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
 3392|  89.9k|    const float border_size = g.Style.FrameBorderSize;
 3393|  89.9k|    if (border && border_size > 0.0f)
  ------------------
  |  Branch (3393:9): [True: 89.9k, False: 0]
  |  Branch (3393:19): [True: 89.9k, False: 0]
  ------------------
 3394|  89.9k|    {
 3395|  89.9k|        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
 3396|  89.9k|        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
 3397|  89.9k|    }
 3398|  89.9k|}
_ZN5ImGui18RenderNavHighlightERK6ImRectji:
 3413|    452|{
 3414|    452|    ImGuiContext& g = *GImGui;
 3415|    452|    if (id != g.NavId)
  ------------------
  |  Branch (3415:9): [True: 246, False: 206]
  ------------------
 3416|    246|        return;
 3417|    206|    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
  ------------------
  |  Branch (3417:9): [True: 66, False: 140]
  |  Branch (3417:34): [True: 66, False: 0]
  ------------------
 3418|     66|        return;
 3419|    140|    ImGuiWindow* window = g.CurrentWindow;
 3420|    140|    if (window->DC.NavHideHighlightOneFrame)
  ------------------
  |  Branch (3420:9): [True: 0, False: 140]
  ------------------
 3421|      0|        return;
 3422|       |
 3423|    140|    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
  ------------------
  |  Branch (3423:22): [True: 0, False: 140]
  ------------------
 3424|    140|    ImRect display_rect = bb;
 3425|    140|    display_rect.ClipWith(window->ClipRect);
 3426|    140|    if (flags & ImGuiNavHighlightFlags_TypeDefault)
  ------------------
  |  Branch (3426:9): [True: 4, False: 136]
  ------------------
 3427|      4|    {
 3428|      4|        const float THICKNESS = 2.0f;
 3429|      4|        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
 3430|      4|        display_rect.Expand(ImVec2(DISTANCE, DISTANCE));
 3431|      4|        bool fully_visible = window->ClipRect.Contains(display_rect);
 3432|      4|        if (!fully_visible)
  ------------------
  |  Branch (3432:13): [True: 0, False: 4]
  ------------------
 3433|      0|            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
 3434|      4|        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, 0, THICKNESS);
 3435|      4|        if (!fully_visible)
  ------------------
  |  Branch (3435:13): [True: 0, False: 4]
  ------------------
 3436|      0|            window->DrawList->PopClipRect();
 3437|      4|    }
 3438|    140|    if (flags & ImGuiNavHighlightFlags_TypeThin)
  ------------------
  |  Branch (3438:9): [True: 136, False: 4]
  ------------------
 3439|    136|    {
 3440|    136|        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, 1.0f);
 3441|    136|    }
 3442|    140|}
_ZN5ImGui17GetCurrentContextEv:
 3478|      1|{
 3479|      1|    return GImGui;
 3480|      1|}
_ZN5ImGui17SetCurrentContextEP12ImGuiContext:
 3483|      1|{
 3484|       |#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
 3485|       |    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
 3486|       |#else
 3487|      1|    GImGui = ctx;
 3488|      1|#endif
 3489|      1|}
_ZN5ImGui13CreateContextEP11ImFontAtlas:
 3507|      1|{
 3508|      1|    ImGuiContext* prev_ctx = GetCurrentContext();
 3509|      1|    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
  ------------------
  |  | 1823|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3510|      1|    SetCurrentContext(ctx);
 3511|      1|    Initialize();
 3512|      1|    if (prev_ctx != NULL)
  ------------------
  |  Branch (3512:9): [True: 0, False: 1]
  ------------------
 3513|      0|        SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
 3514|      1|    return ctx;
 3515|      1|}
_ZN5ImGui10InitializeEv:
 3542|      1|{
 3543|      1|    ImGuiContext& g = *GImGui;
 3544|      1|    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3545|       |
 3546|       |    // Add .ini handle for ImGuiWindow and ImGuiTable types
 3547|      1|    {
 3548|      1|        ImGuiSettingsHandler ini_handler;
 3549|      1|        ini_handler.TypeName = "Window";
 3550|      1|        ini_handler.TypeHash = ImHashStr("Window");
 3551|      1|        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
 3552|      1|        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
 3553|      1|        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
 3554|      1|        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
 3555|      1|        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
 3556|      1|        AddSettingsHandler(&ini_handler);
 3557|      1|    }
 3558|      1|    TableSettingsAddSettingsHandler();
 3559|       |
 3560|       |    // Setup default localization table
 3561|      1|    LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3562|       |
 3563|       |    // Create default viewport
 3564|      1|    ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 1823|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3565|      1|    viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
 3566|      1|    viewport->Idx = 0;
 3567|      1|    viewport->PlatformWindowCreated = true;
 3568|      1|    viewport->Flags = ImGuiViewportFlags_OwnedByApp;
 3569|      1|    g.Viewports.push_back(viewport);
 3570|      1|    g.TempBuffer.resize(1024 * 3 + 1, 0);
 3571|      1|    g.PlatformIO.Viewports.push_back(g.Viewports[0]);
 3572|       |
 3573|      1|#ifdef IMGUI_HAS_DOCK
 3574|       |    // Initialize Docking
 3575|      1|    DockContextInitialize(&g);
 3576|      1|#endif
 3577|       |
 3578|      1|    g.Initialized = true;
 3579|      1|}
_ZN5ImGui16CallContextHooksEP12ImGuiContext20ImGuiContextHookType:
 3688|   541k|{
 3689|   541k|    ImGuiContext& g = *ctx;
 3690|   541k|    for (int n = 0; n < g.Hooks.Size; n++)
  ------------------
  |  Branch (3690:21): [True: 0, False: 541k]
  ------------------
 3691|      0|        if (g.Hooks[n].Type == hook_type)
  ------------------
  |  Branch (3691:13): [True: 0, False: 0]
  ------------------
 3692|      0|            g.Hooks[n].Callback(&g, &g.Hooks[n]);
 3693|   541k|}
_ZN11ImGuiWindowC2EP12ImGuiContextPKc:
 3702|      3|{
 3703|      3|    memset(this, 0, sizeof(*this));
 3704|      3|    Name = ImStrdup(name);
 3705|      3|    NameBufLen = (int)strlen(name) + 1;
 3706|      3|    ID = ImHashStr(name);
 3707|      3|    IDStack.push_back(ID);
 3708|      3|    ViewportAllowPlatformMonitorExtend = -1;
 3709|      3|    ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
 3710|      3|    MoveId = GetID("#MOVE");
 3711|      3|    TabId = GetID("#TAB");
 3712|      3|    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 3713|      3|    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
 3714|      3|    AutoFitFramesX = AutoFitFramesY = -1;
 3715|      3|    AutoPosLastDirection = ImGuiDir_None;
 3716|      3|    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = 0;
 3717|      3|    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
 3718|      3|    LastFrameActive = -1;
 3719|      3|    LastFrameJustFocused = -1;
 3720|      3|    LastTimeActive = -1.0f;
 3721|      3|    FontWindowScale = FontDpiScale = 1.0f;
 3722|      3|    SettingsOffset = -1;
 3723|      3|    DockOrder = -1;
 3724|      3|    DrawList = &DrawListInst;
 3725|      3|    DrawList->_Data = &context->DrawListSharedData;
 3726|      3|    DrawList->_OwnerName = Name;
 3727|      3|    IM_PLACEMENT_NEW(&WindowClass) ImGuiWindowClass();
  ------------------
  |  | 1822|      6|#define IM_PLACEMENT_NEW(_PTR)              new(ImNewWrapper(), _PTR)
  ------------------
 3728|      3|}
_ZN11ImGuiWindow5GetIDEPKcS1_:
 3738|   181k|{
 3739|   181k|    ImGuiID seed = IDStack.back();
 3740|   181k|    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
  ------------------
  |  Branch (3740:33): [True: 0, False: 181k]
  ------------------
 3741|   181k|    ImGuiContext& g = *GImGui;
 3742|   181k|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (3742:9): [True: 0, False: 181k]
  ------------------
 3743|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
 3744|   181k|    return id;
 3745|   181k|}
_ZN11ImGuiWindow5GetIDEi:
 3758|    321|{
 3759|    321|    ImGuiID seed = IDStack.back();
 3760|    321|    ImGuiID id = ImHashData(&n, sizeof(n), seed);
 3761|    321|    ImGuiContext& g = *GImGui;
 3762|    321|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (3762:9): [True: 0, False: 321]
  ------------------
 3763|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
 3764|    321|    return id;
 3765|    321|}
_ZN5ImGui31GcCompactTransientWindowBuffersEP11ImGuiWindow:
 3798|      1|{
 3799|      1|    window->MemoryCompacted = true;
 3800|      1|    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
 3801|      1|    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
 3802|      1|    window->IDStack.clear();
 3803|      1|    window->DrawList->_ClearFreeMemory();
 3804|      1|    window->DC.ChildWindows.clear();
 3805|      1|    window->DC.ItemWidthStack.clear();
 3806|      1|    window->DC.TextWrapPosStack.clear();
 3807|      1|}
_ZN5ImGui11SetActiveIDEjP11ImGuiWindow:
 3820|     80|{
 3821|     80|    ImGuiContext& g = *GImGui;
 3822|       |
 3823|       |    // While most behaved code would make an effort to not steal active id during window move/drag operations,
 3824|       |    // we at least need to be resilient to it. Cancelling the move is rather aggressive and users of 'master' branch
 3825|       |    // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
 3826|     80|    if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)
  ------------------
  |  Branch (3826:9): [True: 0, False: 80]
  |  Branch (3826:35): [True: 0, False: 0]
  ------------------
 3827|      0|    {
 3828|      0|        IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
  ------------------
  |  |  229|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 0]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3829|      0|        g.MovingWindow = NULL;
 3830|      0|    }
 3831|       |
 3832|       |    // Set active id
 3833|     80|    g.ActiveIdIsJustActivated = (g.ActiveId != id);
 3834|     80|    if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (3834:9): [True: 80, False: 0]
  ------------------
 3835|     80|    {
 3836|     80|        IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
  ------------------
  |  |  229|     80|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (225:57): [True: 0, False: 0]
  |  |  |  |  |  Branch (225:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 80]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3837|     80|        g.ActiveIdTimer = 0.0f;
 3838|     80|        g.ActiveIdHasBeenPressedBefore = false;
 3839|     80|        g.ActiveIdHasBeenEditedBefore = false;
 3840|     80|        g.ActiveIdMouseButton = -1;
 3841|     80|        if (id != 0)
  ------------------
  |  Branch (3841:13): [True: 43, False: 37]
  ------------------
 3842|     43|        {
 3843|     43|            g.LastActiveId = id;
 3844|     43|            g.LastActiveIdTimer = 0.0f;
 3845|     43|        }
 3846|     80|    }
 3847|     80|    g.ActiveId = id;
 3848|     80|    g.ActiveIdAllowOverlap = false;
 3849|     80|    g.ActiveIdNoClearOnFocusLoss = false;
 3850|     80|    g.ActiveIdWindow = window;
 3851|     80|    g.ActiveIdHasBeenEditedThisFrame = false;
 3852|     80|    if (id)
  ------------------
  |  Branch (3852:9): [True: 43, False: 37]
  ------------------
 3853|     43|    {
 3854|     43|        g.ActiveIdIsAlive = id;
 3855|     43|        g.ActiveIdSource = (g.NavActivateId == id || g.NavActivateInputId == id || g.NavJustMovedToId == id) ? (ImGuiInputSource)ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
  ------------------
  |  Branch (3855:29): [True: 0, False: 43]
  |  Branch (3855:54): [True: 0, False: 43]
  |  Branch (3855:84): [True: 0, False: 43]
  ------------------
 3856|     43|    }
 3857|       |
 3858|       |    // Clear declaration of inputs claimed by the widget
 3859|       |    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
 3860|     80|    g.ActiveIdUsingNavDirMask = 0x00;
 3861|     80|    g.ActiveIdUsingAllKeyboardKeys = false;
 3862|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 3863|       |    g.ActiveIdUsingNavInputMask = 0x00;
 3864|       |#endif
 3865|     80|}
_ZN5ImGui13ClearActiveIDEv:
 3868|     37|{
 3869|     37|    SetActiveID(0, NULL); // g.ActiveId = 0;
 3870|     37|}
_ZN5ImGui12SetHoveredIDEj:
 3873|    334|{
 3874|    334|    ImGuiContext& g = *GImGui;
 3875|    334|    g.HoveredId = id;
 3876|    334|    g.HoveredIdAllowOverlap = false;
 3877|    334|    if (id != 0 && g.HoveredIdPreviousFrame != id)
  ------------------
  |  Branch (3877:9): [True: 334, False: 0]
  |  Branch (3877:20): [True: 41, False: 293]
  ------------------
 3878|     41|        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
 3879|    334|}
_ZN5ImGui11KeepAliveIDEj:
 3890|   181k|{
 3891|   181k|    ImGuiContext& g = *GImGui;
 3892|   181k|    if (g.ActiveId == id)
  ------------------
  |  Branch (3892:9): [True: 303, False: 181k]
  ------------------
 3893|    303|        g.ActiveIdIsAlive = id;
 3894|   181k|    if (g.ActiveIdPreviousFrame == id)
  ------------------
  |  Branch (3894:9): [True: 297, False: 181k]
  ------------------
 3895|    297|        g.ActiveIdPreviousFrameIsAlive = true;
 3896|   181k|}
_ZN5ImGui13ItemHoverableERK6ImRectj:
 4019|   181k|{
 4020|   181k|    ImGuiContext& g = *GImGui;
 4021|   181k|    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
  ------------------
  |  Branch (4021:9): [True: 24, False: 181k]
  |  Branch (4021:29): [True: 24, False: 0]
  |  Branch (4021:50): [True: 24, False: 0]
  ------------------
 4022|     24|        return false;
 4023|       |
 4024|   181k|    ImGuiWindow* window = g.CurrentWindow;
 4025|   181k|    if (g.HoveredWindow != window)
  ------------------
  |  Branch (4025:9): [True: 180k, False: 571]
  ------------------
 4026|   180k|        return false;
 4027|    571|    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (4027:9): [True: 273, False: 298]
  |  Branch (4027:28): [True: 191, False: 82]
  |  Branch (4027:48): [True: 191, False: 0]
  ------------------
 4028|    191|        return false;
 4029|    380|    if (!IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (4029:9): [True: 46, False: 334]
  ------------------
 4030|     46|        return false;
 4031|       |
 4032|       |    // Done with rectangle culling so we can perform heavier checks now.
 4033|    334|    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);
  ------------------
  |  Branch (4033:34): [True: 334, False: 0]
  ------------------
 4034|    334|    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
  ------------------
  |  Branch (4034:9): [True: 334, False: 0]
  |  Branch (4034:66): [True: 0, False: 334]
  ------------------
 4035|      0|    {
 4036|      0|        g.HoveredIdDisabled = true;
 4037|      0|        return false;
 4038|      0|    }
 4039|       |
 4040|       |    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
 4041|       |    // hover test in widgets code. We could also decide to split this function is two.
 4042|    334|    if (id != 0)
  ------------------
  |  Branch (4042:9): [True: 334, False: 0]
  ------------------
 4043|    334|        SetHoveredID(id);
 4044|       |
 4045|       |    // When disabled we'll return false but still set HoveredId
 4046|    334|    if (item_flags & ImGuiItemFlags_Disabled)
  ------------------
  |  Branch (4046:9): [True: 0, False: 334]
  ------------------
 4047|      0|    {
 4048|       |        // Release active id if turning disabled
 4049|      0|        if (g.ActiveId == id)
  ------------------
  |  Branch (4049:13): [True: 0, False: 0]
  ------------------
 4050|      0|            ClearActiveID();
 4051|      0|        g.HoveredIdDisabled = true;
 4052|      0|        return false;
 4053|      0|    }
 4054|       |
 4055|    334|    if (id != 0)
  ------------------
  |  Branch (4055:9): [True: 334, False: 0]
  ------------------
 4056|    334|    {
 4057|       |        // [DEBUG] Item Picker tool!
 4058|       |        // We perform the check here because SetHoveredID() is not frequently called (1~ time a frame), making
 4059|       |        // the cost of this tool near-zero. We can get slightly better call-stack and support picking non-hovered
 4060|       |        // items if we performed the test in ItemAdd(), but that would incur a small runtime cost.
 4061|    334|        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
  ------------------
  |  Branch (4061:13): [True: 0, False: 334]
  |  Branch (4061:40): [True: 0, False: 0]
  ------------------
 4062|      0|            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
  ------------------
  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 4063|    334|        if (g.DebugItemPickerBreakId == id)
  ------------------
  |  Branch (4063:13): [True: 0, False: 334]
  ------------------
 4064|      0|            IM_DEBUG_BREAK();
  ------------------
  |  |  293|      0|#define IM_DEBUG_BREAK()    __builtin_debugtrap()
  ------------------
 4065|    334|    }
 4066|       |
 4067|    334|    if (g.NavDisableMouseHover)
  ------------------
  |  Branch (4067:9): [True: 0, False: 334]
  ------------------
 4068|      0|        return false;
 4069|       |
 4070|    334|    return true;
 4071|    334|}
_ZN5ImGui15SetLastItemDataEjiiRK6ImRect:
 4088|   180k|{
 4089|   180k|    ImGuiContext& g = *GImGui;
 4090|   180k|    g.LastItemData.ID = item_id;
 4091|   180k|    g.LastItemData.InFlags = in_flags;
 4092|   180k|    g.LastItemData.StatusFlags = item_flags;
 4093|   180k|    g.LastItemData.Rect = item_rect;
 4094|   180k|}
_ZN5ImGui8MemAllocEm:
 4122|  1.20k|{
 4123|  1.20k|    if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4123:23): [True: 1.20k, False: 2]
  ------------------
 4124|  1.20k|        ctx->IO.MetricsActiveAllocations++;
 4125|  1.20k|    return (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
 4126|  1.20k|}
_ZN5ImGui7MemFreeEPv:
 4130|  1.16k|{
 4131|  1.16k|    if (ptr)
  ------------------
  |  Branch (4131:9): [True: 1.15k, False: 9]
  ------------------
 4132|  1.15k|        if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4132:27): [True: 1.15k, False: 0]
  ------------------
 4133|  1.15k|            ctx->IO.MetricsActiveAllocations--;
 4134|  1.16k|    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
 4135|  1.16k|}
_ZN5ImGui5GetIOEv:
 4156|   272k|{
 4157|   272k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|   272k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4158|   272k|    return GImGui->IO;
 4159|   272k|}
_ZN5ImGui11GetDrawDataEv:
 4169|  90.2k|{
 4170|  90.2k|    ImGuiContext& g = *GImGui;
 4171|  90.2k|    ImGuiViewportP* viewport = g.Viewports[0];
 4172|  90.2k|    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
  ------------------
  |  Branch (4172:12): [True: 90.2k, False: 0]
  ------------------
 4173|  90.2k|}
_ZN5ImGui22StartMouseMovingWindowEP11ImGuiWindow:
 4237|     16|{
 4238|       |    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
 4239|       |    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
 4240|       |    // This is because we want ActiveId to be set even when the window is not permitted to move.
 4241|     16|    ImGuiContext& g = *GImGui;
 4242|     16|    FocusWindow(window);
 4243|     16|    SetActiveID(window->MoveId, window);
 4244|     16|    g.NavDisableHighlight = true;
 4245|     16|    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;
 4246|     16|    g.ActiveIdNoClearOnFocusLoss = true;
 4247|     16|    SetActiveIdUsingAllKeyboardKeys();
 4248|       |
 4249|     16|    bool can_move_window = true;
 4250|     16|    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4250:9): [True: 0, False: 16]
  |  Branch (4250:54): [True: 0, False: 16]
  ------------------
 4251|      0|        can_move_window = false;
 4252|     16|    if (ImGuiDockNode* node = window->DockNodeAsHost)
  ------------------
  |  Branch (4252:24): [True: 0, False: 16]
  ------------------
 4253|      0|        if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4253:13): [True: 0, False: 0]
  |  Branch (4253:36): [True: 0, False: 0]
  ------------------
 4254|      0|            can_move_window = false;
 4255|     16|    if (can_move_window)
  ------------------
  |  Branch (4255:9): [True: 16, False: 0]
  ------------------
 4256|     16|        g.MovingWindow = window;
 4257|     16|}
_ZN5ImGui28StartMouseMovingWindowOrNodeEP11ImGuiWindowP13ImGuiDockNodeb:
 4263|      6|{
 4264|      6|    ImGuiContext& g = *GImGui;
 4265|      6|    bool can_undock_node = false;
 4266|      6|    if (node != NULL && node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove) == 0)
  ------------------
  |  Branch (4266:9): [True: 0, False: 6]
  |  Branch (4266:25): [True: 0, False: 0]
  |  Branch (4266:48): [True: 0, False: 0]
  ------------------
 4267|      0|    {
 4268|       |        // Can undock if:
 4269|       |        // - part of a floating node hierarchy with more than one visible node (if only one is visible, we'll just move the whole hierarchy)
 4270|       |        // - part of a dockspace node hierarchy (trivia: undocking from a fixed/central node will create a new node and copy windows)
 4271|      0|        ImGuiDockNode* root_node = DockNodeGetRootNode(node);
 4272|      0|        if (root_node->OnlyNodeWithWindows != node || root_node->CentralNode != NULL)   // -V1051 PVS-Studio thinks node should be root_node and is wrong about that.
  ------------------
  |  Branch (4272:13): [True: 0, False: 0]
  |  Branch (4272:55): [True: 0, False: 0]
  ------------------
 4273|      0|            if (undock_floating_node || root_node->IsDockSpace())
  ------------------
  |  Branch (4273:17): [True: 0, False: 0]
  |  Branch (4273:41): [True: 0, False: 0]
  ------------------
 4274|      0|                can_undock_node = true;
 4275|      0|    }
 4276|       |
 4277|      6|    const bool clicked = IsMouseClicked(0);
 4278|      6|    const bool dragging = IsMouseDragging(0, g.IO.MouseDragThreshold * 1.70f);
 4279|      6|    if (can_undock_node && dragging)
  ------------------
  |  Branch (4279:9): [True: 0, False: 6]
  |  Branch (4279:28): [True: 0, False: 0]
  ------------------
 4280|      0|        DockContextQueueUndockNode(&g, node); // Will lead to DockNodeStartMouseMovingWindow() -> StartMouseMovingWindow() being called next frame
 4281|      6|    else if (!can_undock_node && (clicked || dragging) && g.MovingWindow != window)
  ------------------
  |  Branch (4281:14): [True: 6, False: 0]
  |  Branch (4281:35): [True: 0, False: 6]
  |  Branch (4281:46): [True: 6, False: 0]
  |  Branch (4281:59): [True: 6, False: 0]
  ------------------
 4282|      6|        StartMouseMovingWindow(window);
 4283|      6|}
_ZN5ImGui31UpdateMouseMovingWindowNewFrameEv:
 4291|  90.2k|{
 4292|  90.2k|    ImGuiContext& g = *GImGui;
 4293|  90.2k|    if (g.MovingWindow != NULL)
  ------------------
  |  Branch (4293:9): [True: 173, False: 90.0k]
  ------------------
 4294|    173|    {
 4295|       |        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
 4296|       |        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
 4297|    173|        KeepAliveID(g.ActiveId);
 4298|    173|        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
  ------------------
  |  |   23|    173|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4299|    173|        ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
 4300|       |
 4301|       |        // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
 4302|    173|        const bool window_disappared = ((!moving_window->WasActive && !moving_window->Active) || moving_window->Viewport == NULL);
  ------------------
  |  Branch (4302:42): [True: 0, False: 173]
  |  Branch (4302:71): [True: 0, False: 0]
  |  Branch (4302:98): [True: 0, False: 173]
  ------------------
 4303|    173|        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared)
  ------------------
  |  Branch (4303:13): [True: 166, False: 7]
  |  Branch (4303:34): [True: 157, False: 9]
  |  Branch (4303:69): [True: 157, False: 0]
  ------------------
 4304|    157|        {
 4305|    157|            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
 4306|    157|            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
  ------------------
  |  Branch (4306:17): [True: 126, False: 31]
  |  Branch (4306:50): [True: 0, False: 31]
  ------------------
 4307|    126|            {
 4308|    126|                SetWindowPos(moving_window, pos, ImGuiCond_Always);
 4309|    126|                if (moving_window->ViewportOwned) // Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
  ------------------
  |  Branch (4309:21): [True: 0, False: 126]
  ------------------
 4310|      0|                {
 4311|      0|                    moving_window->Viewport->Pos = pos;
 4312|      0|                    moving_window->Viewport->UpdateWorkRect();
 4313|      0|                }
 4314|    126|            }
 4315|    157|            FocusWindow(g.MovingWindow);
 4316|    157|        }
 4317|     16|        else
 4318|     16|        {
 4319|     16|            if (!window_disappared)
  ------------------
  |  Branch (4319:17): [True: 16, False: 0]
  ------------------
 4320|     16|            {
 4321|       |                // Try to merge the window back into the main viewport.
 4322|       |                // This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
 4323|     16|                if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (4323:21): [True: 0, False: 16]
  ------------------
 4324|      0|                    UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport);
 4325|       |
 4326|       |                // Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
 4327|     16|                if (!IsDragDropPayloadBeingAccepted())
  ------------------
  |  Branch (4327:21): [True: 16, False: 0]
  ------------------
 4328|     16|                    g.MouseViewport = moving_window->Viewport;
 4329|       |
 4330|       |                // Clear the NoInput window flag set by the Viewport system
 4331|     16|                moving_window->Viewport->Flags &= ~ImGuiViewportFlags_NoInputs; // FIXME-VIEWPORT: Test engine managed to crash here because Viewport was NULL.
 4332|     16|            }
 4333|       |
 4334|     16|            g.MovingWindow = NULL;
 4335|     16|            ClearActiveID();
 4336|     16|        }
 4337|    173|    }
 4338|  90.0k|    else
 4339|  90.0k|    {
 4340|       |        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
 4341|  90.0k|        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
  ------------------
  |  Branch (4341:13): [True: 87, False: 89.9k]
  |  Branch (4341:33): [True: 0, False: 87]
  ------------------
 4342|      0|        {
 4343|      0|            KeepAliveID(g.ActiveId);
 4344|      0|            if (!g.IO.MouseDown[0])
  ------------------
  |  Branch (4344:17): [True: 0, False: 0]
  ------------------
 4345|      0|                ClearActiveID();
 4346|      0|        }
 4347|  90.0k|    }
 4348|  90.2k|}
_ZN5ImGui31UpdateMouseMovingWindowEndFrameEv:
 4353|  90.2k|{
 4354|  90.2k|    ImGuiContext& g = *GImGui;
 4355|  90.2k|    if (g.ActiveId != 0 || g.HoveredId != 0)
  ------------------
  |  Branch (4355:9): [True: 264, False: 89.9k]
  |  Branch (4355:28): [True: 232, False: 89.7k]
  ------------------
 4356|    496|        return;
 4357|       |
 4358|       |    // Unless we just made a window/popup appear
 4359|  89.7k|    if (g.NavWindow && g.NavWindow->Appearing)
  ------------------
  |  Branch (4359:9): [True: 220, False: 89.5k]
  |  Branch (4359:24): [True: 1, False: 219]
  ------------------
 4360|      1|        return;
 4361|       |
 4362|       |    // Click on empty space to focus window and start moving
 4363|       |    // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
 4364|  89.7k|    if (g.IO.MouseClicked[0])
  ------------------
  |  Branch (4364:9): [True: 3.72k, False: 86.0k]
  ------------------
 4365|  3.72k|    {
 4366|       |        // Handle the edge case of a popup being closed while clicking in its empty space.
 4367|       |        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
 4368|  3.72k|        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
  ------------------
  |  Branch (4368:36): [True: 10, False: 3.71k]
  ------------------
 4369|  3.72k|        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);
  ------------------
  |  Branch (4369:38): [True: 10, False: 3.71k]
  |  Branch (4369:53): [True: 0, False: 10]
  |  Branch (4369:102): [True: 0, False: 0]
  ------------------
 4370|       |
 4371|  3.72k|        if (root_window != NULL && !is_closed_popup)
  ------------------
  |  Branch (4371:13): [True: 10, False: 3.71k]
  |  Branch (4371:36): [True: 10, False: 0]
  ------------------
 4372|     10|        {
 4373|     10|            StartMouseMovingWindow(g.HoveredWindow); //-V595
 4374|       |
 4375|       |            // Cancel moving if clicked outside of title bar
 4376|     10|            if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
  ------------------
  |  Branch (4376:17): [True: 0, False: 10]
  ------------------
 4377|      0|                if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
  ------------------
  |  Branch (4377:21): [True: 0, False: 0]
  |  Branch (4377:76): [True: 0, False: 0]
  ------------------
 4378|      0|                    if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
  ------------------
  |  Branch (4378:25): [True: 0, False: 0]
  ------------------
 4379|      0|                        g.MovingWindow = NULL;
 4380|       |
 4381|       |            // Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
 4382|     10|            if (g.HoveredIdDisabled)
  ------------------
  |  Branch (4382:17): [True: 0, False: 10]
  ------------------
 4383|      0|                g.MovingWindow = NULL;
 4384|     10|        }
 4385|  3.71k|        else if (root_window == NULL && g.NavWindow != NULL && GetTopMostPopupModal() == NULL)
  ------------------
  |  Branch (4385:18): [True: 3.71k, False: 0]
  |  Branch (4385:41): [True: 2, False: 3.71k]
  |  Branch (4385:64): [True: 2, False: 0]
  ------------------
 4386|      2|        {
 4387|       |            // Clicking on void disable focus
 4388|      2|            FocusWindow(NULL);
 4389|      2|        }
 4390|  3.72k|    }
 4391|       |
 4392|       |    // With right mouse button we close popups without changing focus based on where the mouse is aimed
 4393|       |    // Instead, focus will be restored to the window under the bottom-most closed popup.
 4394|       |    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
 4395|  89.7k|    if (g.IO.MouseClicked[1])
  ------------------
  |  Branch (4395:9): [True: 511, False: 89.2k]
  ------------------
 4396|    511|    {
 4397|       |        // Find the top-most window between HoveredWindow and the top-most Modal Window.
 4398|       |        // This is where we can trim the popup stack.
 4399|    511|        ImGuiWindow* modal = GetTopMostPopupModal();
 4400|    511|        bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
  ------------------
  |  Branch (4400:43): [True: 0, False: 511]
  |  Branch (4400:63): [True: 0, False: 0]
  |  Branch (4400:80): [True: 0, False: 0]
  ------------------
 4401|    511|        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
  ------------------
  |  Branch (4401:31): [True: 0, False: 511]
  ------------------
 4402|    511|    }
 4403|  89.7k|}
_ZN5ImGui34UpdateHoveredWindowAndCaptureFlagsEv:
 4435|  90.2k|{
 4436|  90.2k|    ImGuiContext& g = *GImGui;
 4437|  90.2k|    ImGuiIO& io = g.IO;
 4438|  90.2k|    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));
 4439|       |
 4440|       |    // Find the window hovered by mouse:
 4441|       |    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
 4442|       |    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
 4443|       |    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
 4444|  90.2k|    bool clear_hovered_windows = false;
 4445|  90.2k|    FindHoveredWindow();
 4446|  90.2k|    IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4447|       |
 4448|       |    // Modal windows prevents mouse from hovering behind them.
 4449|  90.2k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
 4450|  90.2k|    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window)) // FIXME-MERGE: RootWindowDockTree ?
  ------------------
  |  Branch (4450:9): [True: 0, False: 90.2k]
  |  Branch (4450:25): [True: 0, False: 0]
  |  Branch (4450:44): [True: 0, False: 0]
  ------------------
 4451|      0|        clear_hovered_windows = true;
 4452|       |
 4453|       |    // Disabled mouse?
 4454|  90.2k|    if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
  ------------------
  |  Branch (4454:9): [True: 0, False: 90.2k]
  ------------------
 4455|      0|        clear_hovered_windows = true;
 4456|       |
 4457|       |    // We track click ownership. When clicked outside of a window the click is owned by the application and
 4458|       |    // won't report hovering nor request capture even while dragging over our windows afterward.
 4459|  90.2k|    const bool has_open_popup = (g.OpenPopupStack.Size > 0);
 4460|  90.2k|    const bool has_open_modal = (modal_window != NULL);
 4461|  90.2k|    int mouse_earliest_down = -1;
 4462|  90.2k|    bool mouse_any_down = false;
 4463|   541k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   87|   541k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4463:21): [True: 451k, False: 90.2k]
  ------------------
 4464|   451k|    {
 4465|   451k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (4465:13): [True: 6.99k, False: 444k]
  ------------------
 4466|  6.99k|        {
 4467|  6.99k|            io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
  ------------------
  |  Branch (4467:36): [True: 60, False: 6.93k]
  |  Branch (4467:65): [True: 0, False: 6.93k]
  ------------------
 4468|  6.99k|            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
  ------------------
  |  Branch (4468:52): [True: 60, False: 6.93k]
  |  Branch (4468:81): [True: 0, False: 6.93k]
  ------------------
 4469|  6.99k|        }
 4470|   451k|        mouse_any_down |= io.MouseDown[i];
 4471|   451k|        if (io.MouseDown[i])
  ------------------
  |  Branch (4471:13): [True: 48.1k, False: 402k]
  ------------------
 4472|  48.1k|            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
  ------------------
  |  Branch (4472:17): [True: 29.0k, False: 19.1k]
  |  Branch (4472:46): [True: 3.34k, False: 15.8k]
  ------------------
 4473|  32.3k|                mouse_earliest_down = i;
 4474|   451k|    }
 4475|  90.2k|    const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
  ------------------
  |  Branch (4475:30): [True: 61.2k, False: 29.0k]
  |  Branch (4475:61): [True: 296, False: 28.7k]
  ------------------
 4476|  90.2k|    const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];
  ------------------
  |  Branch (4476:49): [True: 61.2k, False: 29.0k]
  |  Branch (4476:80): [True: 296, False: 28.7k]
  ------------------
 4477|       |
 4478|       |    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
 4479|       |    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
 4480|  90.2k|    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
  ------------------
  |  Branch (4480:48): [True: 49, False: 90.1k]
  |  Branch (4480:68): [True: 0, False: 49]
  ------------------
 4481|  90.2k|    if (!mouse_avail && !mouse_dragging_extern_payload)
  ------------------
  |  Branch (4481:9): [True: 28.7k, False: 61.5k]
  |  Branch (4481:25): [True: 28.7k, False: 0]
  ------------------
 4482|  28.7k|        clear_hovered_windows = true;
 4483|       |
 4484|  90.2k|    if (clear_hovered_windows)
  ------------------
  |  Branch (4484:9): [True: 28.7k, False: 61.5k]
  ------------------
 4485|  28.7k|        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
 4486|       |
 4487|       |    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
 4488|       |    // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
 4489|  90.2k|    if (g.WantCaptureMouseNextFrame != -1)
  ------------------
  |  Branch (4489:9): [True: 0, False: 90.2k]
  ------------------
 4490|      0|    {
 4491|      0|        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
 4492|      0|    }
 4493|  90.2k|    else
 4494|  90.2k|    {
 4495|  90.2k|        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
  ------------------
  |  Branch (4495:32): [True: 61.5k, False: 28.7k]
  |  Branch (4495:48): [True: 508, False: 61.0k]
  |  Branch (4495:75): [True: 5, False: 61.0k]
  |  Branch (4495:95): [True: 0, False: 89.7k]
  ------------------
 4496|  90.2k|        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
  ------------------
  |  Branch (4496:48): [True: 61.5k, False: 28.7k]
  |  Branch (4496:83): [True: 508, False: 61.0k]
  |  Branch (4496:110): [True: 5, False: 61.0k]
  |  Branch (4496:130): [True: 0, False: 89.7k]
  ------------------
 4497|  90.2k|    }
 4498|       |
 4499|       |    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
 4500|  90.2k|    if (g.WantCaptureKeyboardNextFrame != -1)
  ------------------
  |  Branch (4500:9): [True: 0, False: 90.2k]
  ------------------
 4501|      0|        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
 4502|  90.2k|    else
 4503|  90.2k|        io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
  ------------------
  |  Branch (4503:34): [True: 260, False: 89.9k]
  |  Branch (4503:55): [True: 0, False: 89.9k]
  ------------------
 4504|  90.2k|    if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
  ------------------
  |  Branch (4504:9): [True: 447, False: 89.7k]
  |  Branch (4504:25): [True: 447, False: 0]
  |  Branch (4504:82): [True: 447, False: 0]
  ------------------
 4505|    447|        io.WantCaptureKeyboard = true;
 4506|       |
 4507|       |    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
 4508|  90.2k|    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
  ------------------
  |  Branch (4508:24): [True: 0, False: 90.2k]
  ------------------
 4509|  90.2k|}
_ZN5ImGui8NewFrameEv:
 4512|  90.2k|{
 4513|  90.2k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4514|  90.2k|    ImGuiContext& g = *GImGui;
 4515|       |
 4516|       |    // Remove pending delete hooks before frame start.
 4517|       |    // This deferred removal avoid issues of removal while iterating the hook vector
 4518|  90.2k|    for (int n = g.Hooks.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (4518:36): [True: 0, False: 90.2k]
  ------------------
 4519|      0|        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
  ------------------
  |  Branch (4519:13): [True: 0, False: 0]
  ------------------
 4520|      0|            g.Hooks.erase(&g.Hooks[n]);
 4521|       |
 4522|  90.2k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);
 4523|       |
 4524|       |    // Check and assert for various common IO and Configuration mistakes
 4525|  90.2k|    g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
 4526|  90.2k|    ErrorCheckNewFrameSanityChecks();
 4527|  90.2k|    g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;
 4528|       |
 4529|       |    // Load settings on first frame, save settings when modified (after a delay)
 4530|  90.2k|    UpdateSettings();
 4531|       |
 4532|  90.2k|    g.Time += g.IO.DeltaTime;
 4533|  90.2k|    g.WithinFrameScope = true;
 4534|  90.2k|    g.FrameCount += 1;
 4535|  90.2k|    g.TooltipOverrideCount = 0;
 4536|  90.2k|    g.WindowsActiveCount = 0;
 4537|  90.2k|    g.MenusIdSubmittedThisFrame.resize(0);
 4538|       |
 4539|       |    // Calculate frame-rate for the user, as a purely luxurious feature
 4540|  90.2k|    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
 4541|  90.2k|    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
 4542|  90.2k|    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
  ------------------
  |  |   87|  90.2k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4543|  90.2k|    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
  ------------------
  |  |   87|  90.2k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4544|  90.2k|    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;
  ------------------
  |  Branch (4544:22): [True: 90.2k, False: 0]
  ------------------
 4545|       |
 4546|       |    // Process input queue (trickle as many events as possible), turn events into writes to IO structure
 4547|  90.2k|    g.InputEventsTrail.resize(0);
 4548|  90.2k|    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);
 4549|       |
 4550|       |    // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
 4551|  90.2k|    UpdateViewportsNewFrame();
 4552|       |
 4553|       |    // Setup current font and draw list shared data
 4554|       |    // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
 4555|  90.2k|    g.IO.Fonts->Locked = true;
 4556|  90.2k|    SetCurrentFont(GetDefaultFont());
 4557|  90.2k|    IM_ASSERT(g.Font->IsLoaded());
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4558|  90.2k|    ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
 4559|   180k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (4559:21): [True: 90.2k, False: 90.2k]
  ------------------
 4560|  90.2k|        virtual_space.Add(g.Viewports[n]->GetMainRect());
 4561|  90.2k|    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
 4562|  90.2k|    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
 4563|  90.2k|    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
 4564|  90.2k|    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
 4565|  90.2k|    if (g.Style.AntiAliasedLines)
  ------------------
  |  Branch (4565:9): [True: 90.2k, False: 0]
  ------------------
 4566|  90.2k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
 4567|  90.2k|    if (g.Style.AntiAliasedLinesUseTex && !(g.Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (4567:9): [True: 90.2k, False: 0]
  |  Branch (4567:43): [True: 90.2k, False: 0]
  ------------------
 4568|  90.2k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
 4569|  90.2k|    if (g.Style.AntiAliasedFill)
  ------------------
  |  Branch (4569:9): [True: 90.2k, False: 0]
  ------------------
 4570|  90.2k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
 4571|  90.2k|    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
  ------------------
  |  Branch (4571:9): [True: 0, False: 90.2k]
  ------------------
 4572|      0|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
 4573|       |
 4574|       |    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
 4575|   180k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (4575:21): [True: 90.2k, False: 90.2k]
  ------------------
 4576|  90.2k|    {
 4577|  90.2k|        ImGuiViewportP* viewport = g.Viewports[n];
 4578|  90.2k|        viewport->DrawData = NULL;
 4579|  90.2k|        viewport->DrawDataP.Clear();
 4580|  90.2k|    }
 4581|       |
 4582|       |    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
 4583|  90.2k|    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
  ------------------
  |  Branch (4583:9): [True: 49, False: 90.1k]
  |  Branch (4583:29): [True: 43, False: 6]
  ------------------
 4584|     43|        KeepAliveID(g.DragDropPayload.SourceId);
 4585|       |
 4586|       |    // Update HoveredId data
 4587|  90.2k|    if (!g.HoveredIdPreviousFrame)
  ------------------
  |  Branch (4587:9): [True: 89.8k, False: 334]
  ------------------
 4588|  89.8k|        g.HoveredIdTimer = 0.0f;
 4589|  90.2k|    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
  ------------------
  |  Branch (4589:9): [True: 89.8k, False: 334]
  |  Branch (4589:39): [True: 293, False: 41]
  |  Branch (4589:54): [True: 82, False: 211]
  ------------------
 4590|  89.9k|        g.HoveredIdNotActiveTimer = 0.0f;
 4591|  90.2k|    if (g.HoveredId)
  ------------------
  |  Branch (4591:9): [True: 334, False: 89.8k]
  ------------------
 4592|    334|        g.HoveredIdTimer += g.IO.DeltaTime;
 4593|  90.2k|    if (g.HoveredId && g.ActiveId != g.HoveredId)
  ------------------
  |  Branch (4593:9): [True: 334, False: 89.8k]
  |  Branch (4593:24): [True: 247, False: 87]
  ------------------
 4594|    247|        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
 4595|  90.2k|    g.HoveredIdPreviousFrame = g.HoveredId;
 4596|  90.2k|    g.HoveredId = 0;
 4597|  90.2k|    g.HoveredIdAllowOverlap = false;
 4598|  90.2k|    g.HoveredIdDisabled = false;
 4599|       |
 4600|       |    // Clear ActiveID if the item is not alive anymore.
 4601|       |    // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
 4602|       |    // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
 4603|  90.2k|    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
  ------------------
  |  Branch (4603:9): [True: 260, False: 89.9k]
  |  Branch (4603:28): [True: 0, False: 260]
  |  Branch (4603:63): [True: 0, False: 0]
  ------------------
 4604|      0|    {
 4605|      0|        IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
  ------------------
  |  |  229|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (229:50): [True: 0, False: 0]
  |  |  |  Branch (229:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4606|      0|        ClearActiveID();
 4607|      0|    }
 4608|       |
 4609|       |    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
 4610|  90.2k|    if (g.ActiveId)
  ------------------
  |  Branch (4610:9): [True: 260, False: 89.9k]
  ------------------
 4611|    260|        g.ActiveIdTimer += g.IO.DeltaTime;
 4612|  90.2k|    g.LastActiveIdTimer += g.IO.DeltaTime;
 4613|  90.2k|    g.ActiveIdPreviousFrame = g.ActiveId;
 4614|  90.2k|    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
 4615|  90.2k|    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
 4616|  90.2k|    g.ActiveIdIsAlive = 0;
 4617|  90.2k|    g.ActiveIdHasBeenEditedThisFrame = false;
 4618|  90.2k|    g.ActiveIdPreviousFrameIsAlive = false;
 4619|  90.2k|    g.ActiveIdIsJustActivated = false;
 4620|  90.2k|    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
  ------------------
  |  Branch (4620:9): [True: 0, False: 90.2k]
  |  Branch (4620:31): [True: 0, False: 0]
  ------------------
 4621|      0|        g.TempInputId = 0;
 4622|  90.2k|    if (g.ActiveId == 0)
  ------------------
  |  Branch (4622:9): [True: 89.9k, False: 260]
  ------------------
 4623|  89.9k|    {
 4624|  89.9k|        g.ActiveIdUsingNavDirMask = 0x00;
 4625|  89.9k|        g.ActiveIdUsingAllKeyboardKeys = false;
 4626|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4627|       |        g.ActiveIdUsingNavInputMask = 0x00;
 4628|       |#endif
 4629|  89.9k|    }
 4630|       |
 4631|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4632|       |    if (g.ActiveId == 0)
 4633|       |        g.ActiveIdUsingNavInputMask = 0;
 4634|       |    else if (g.ActiveIdUsingNavInputMask != 0)
 4635|       |    {
 4636|       |        // If your custom widget code used:                 { g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel); }
 4637|       |        // Since IMGUI_VERSION_NUM >= 18804 it should be:   { SetKeyOwner(ImGuiKey_Escape, g.ActiveId); SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId); }
 4638|       |        if (g.ActiveIdUsingNavInputMask & (1 << ImGuiNavInput_Cancel))
 4639|       |            SetKeyOwner(ImGuiKey_Escape, g.ActiveId);
 4640|       |        if (g.ActiveIdUsingNavInputMask & ~(1 << ImGuiNavInput_Cancel))
 4641|       |            IM_ASSERT(0); // Other values unsupported
 4642|       |    }
 4643|       |#endif
 4644|       |
 4645|       |    // Update hover delay for IsItemHovered() with delays and tooltips
 4646|  90.2k|    g.HoverDelayIdPreviousFrame = g.HoverDelayId;
 4647|  90.2k|    if (g.HoverDelayId != 0)
  ------------------
  |  Branch (4647:9): [True: 0, False: 90.2k]
  ------------------
 4648|      0|    {
 4649|       |        //if (g.IO.MouseDelta.x == 0.0f && g.IO.MouseDelta.y == 0.0f) // Need design/flags
 4650|      0|        g.HoverDelayTimer += g.IO.DeltaTime;
 4651|      0|        g.HoverDelayClearTimer = 0.0f;
 4652|      0|        g.HoverDelayId = 0;
 4653|      0|    }
 4654|  90.2k|    else if (g.HoverDelayTimer > 0.0f)
  ------------------
  |  Branch (4654:14): [True: 0, False: 90.2k]
  ------------------
 4655|      0|    {
 4656|       |        // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
 4657|      0|        g.HoverDelayClearTimer += g.IO.DeltaTime;
 4658|      0|        if (g.HoverDelayClearTimer >= ImMax(0.20f, g.IO.DeltaTime * 2.0f)) // ~6 frames at 30 Hz + allow for low framerate
  ------------------
  |  Branch (4658:13): [True: 0, False: 0]
  ------------------
 4659|      0|            g.HoverDelayTimer = g.HoverDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
 4660|      0|    }
 4661|       |
 4662|       |    // Drag and drop
 4663|  90.2k|    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
 4664|  90.2k|    g.DragDropAcceptIdCurr = 0;
 4665|  90.2k|    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
 4666|  90.2k|    g.DragDropWithinSource = false;
 4667|  90.2k|    g.DragDropWithinTarget = false;
 4668|  90.2k|    g.DragDropHoldJustPressedId = 0;
 4669|       |
 4670|       |    // Close popups on focus lost (currently wip/opt-in)
 4671|       |    //if (g.IO.AppFocusLost)
 4672|       |    //    ClosePopupsExceptModals();
 4673|       |
 4674|       |    // Update keyboard input state
 4675|  90.2k|    UpdateKeyboardInputs();
 4676|       |
 4677|       |    //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
 4678|       |    //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
 4679|       |    //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
 4680|       |    //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));
 4681|       |
 4682|       |    // Update gamepad/keyboard navigation
 4683|  90.2k|    NavUpdate();
 4684|       |
 4685|       |    // Update mouse input state
 4686|  90.2k|    UpdateMouseInputs();
 4687|       |
 4688|       |    // Undocking
 4689|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
 4690|  90.2k|    DockContextNewFrameUpdateUndocking(&g);
 4691|       |
 4692|       |    // Find hovered window
 4693|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
 4694|  90.2k|    UpdateHoveredWindowAndCaptureFlags();
 4695|       |
 4696|       |    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
 4697|  90.2k|    UpdateMouseMovingWindowNewFrame();
 4698|       |
 4699|       |    // Background darkening/whitening
 4700|  90.2k|    if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
  ------------------
  |  Branch (4700:9): [True: 0, False: 90.2k]
  |  Branch (4700:44): [True: 0, False: 90.2k]
  |  Branch (4700:76): [True: 0, False: 0]
  ------------------
 4701|      0|        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
 4702|  90.2k|    else
 4703|  90.2k|        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);
 4704|       |
 4705|  90.2k|    g.MouseCursor = ImGuiMouseCursor_Arrow;
 4706|  90.2k|    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
 4707|       |
 4708|       |    // Platform IME data: reset for the frame
 4709|  90.2k|    g.PlatformImeDataPrev = g.PlatformImeData;
 4710|  90.2k|    g.PlatformImeData.WantVisible = false;
 4711|       |
 4712|       |    // Mouse wheel scrolling, scale
 4713|  90.2k|    UpdateMouseWheel();
 4714|       |
 4715|       |    // Mark all windows as not visible and compact unused memory.
 4716|  90.2k|    IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4717|  90.2k|    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
  ------------------
  |  Branch (4717:46): [True: 0, False: 90.2k]
  |  Branch (4717:64): [True: 0, False: 90.2k]
  ------------------
 4718|   360k|    for (int i = 0; i != g.Windows.Size; i++)
  ------------------
  |  Branch (4718:21): [True: 270k, False: 90.2k]
  ------------------
 4719|   270k|    {
 4720|   270k|        ImGuiWindow* window = g.Windows[i];
 4721|   270k|        window->WasActive = window->Active;
 4722|   270k|        window->Active = false;
 4723|   270k|        window->WriteAccessed = false;
 4724|   270k|        window->BeginCountPreviousFrame = window->BeginCount;
 4725|   270k|        window->BeginCount = 0;
 4726|       |
 4727|       |        // Garbage collect transient buffers of recently unused windows
 4728|   270k|        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (4728:13): [True: 180k, False: 90.5k]
  |  Branch (4728:35): [True: 93.8k, False: 86.2k]
  |  Branch (4728:63): [True: 1, False: 93.8k]
  ------------------
 4729|      1|            GcCompactTransientWindowBuffers(window);
 4730|   270k|    }
 4731|       |
 4732|       |    // Garbage collect transient buffers of recently unused tables
 4733|  90.2k|    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
  ------------------
  |  Branch (4733:21): [True: 0, False: 90.2k]
  ------------------
 4734|      0|        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
  ------------------
  |  Branch (4734:13): [True: 0, False: 0]
  |  Branch (4734:50): [True: 0, False: 0]
  ------------------
 4735|      0|            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
 4736|  90.2k|    for (int i = 0; i < g.TablesTempData.Size; i++)
  ------------------
  |  Branch (4736:21): [True: 0, False: 90.2k]
  ------------------
 4737|      0|        if (g.TablesTempData[i].LastTimeActive >= 0.0f && g.TablesTempData[i].LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (4737:13): [True: 0, False: 0]
  |  Branch (4737:59): [True: 0, False: 0]
  ------------------
 4738|      0|            TableGcCompactTransientBuffers(&g.TablesTempData[i]);
 4739|  90.2k|    if (g.GcCompactAll)
  ------------------
  |  Branch (4739:9): [True: 0, False: 90.2k]
  ------------------
 4740|      0|        GcCompactTransientMiscBuffers();
 4741|  90.2k|    g.GcCompactAll = false;
 4742|       |
 4743|       |    // Closing the focused window restore focus to the first active root window in descending z-order
 4744|  90.2k|    if (g.NavWindow && !g.NavWindow->WasActive)
  ------------------
  |  Branch (4744:9): [True: 449, False: 89.7k]
  |  Branch (4744:24): [True: 0, False: 449]
  ------------------
 4745|      0|        FocusTopMostWindowUnderOne(NULL, NULL);
 4746|       |
 4747|       |    // No window should be open at the beginning of the frame.
 4748|       |    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
 4749|  90.2k|    g.CurrentWindowStack.resize(0);
 4750|  90.2k|    g.BeginPopupStack.resize(0);
 4751|  90.2k|    g.ItemFlagsStack.resize(0);
 4752|  90.2k|    g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
 4753|  90.2k|    g.GroupStack.resize(0);
 4754|       |
 4755|       |    // Docking
 4756|  90.2k|    DockContextNewFrameUpdateDocking(&g);
 4757|       |
 4758|       |    // [DEBUG] Update debug features
 4759|  90.2k|    UpdateDebugToolItemPicker();
 4760|  90.2k|    UpdateDebugToolStackQueries();
 4761|  90.2k|    if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
  ------------------
  |  Branch (4761:9): [True: 0, False: 90.2k]
  |  Branch (4761:36): [True: 0, False: 0]
  ------------------
 4762|      0|        g.DebugLocateId = 0;
 4763|       |
 4764|       |    // Create implicit/fallback window - which we will only render it if the user has added something to it.
 4765|       |    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
 4766|       |    // This fallback is particularly important as it prevents ImGui:: calls from crashing.
 4767|  90.2k|    g.WithinFrameScopeWithImplicitWindow = true;
 4768|  90.2k|    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
 4769|  90.2k|    Begin("Debug##Default");
 4770|  90.2k|    IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4771|       |
 4772|  90.2k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
 4773|  90.2k|}
_ZN17ImDrawDataBuilder22FlattenIntoSingleLayerEv:
 4866|  90.2k|{
 4867|  90.2k|    int n = Layers[0].Size;
 4868|  90.2k|    int size = n;
 4869|   180k|    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
  ------------------
  |  |   87|   180k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4869:21): [True: 90.2k, False: 90.2k]
  ------------------
 4870|  90.2k|        size += Layers[i].Size;
 4871|  90.2k|    Layers[0].resize(size);
 4872|   180k|    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
  ------------------
  |  |   87|   180k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4872:27): [True: 90.2k, False: 90.2k]
  ------------------
 4873|  90.2k|    {
 4874|  90.2k|        ImVector<ImDrawList*>& layer = Layers[layer_n];
 4875|  90.2k|        if (layer.empty())
  ------------------
  |  Branch (4875:13): [True: 90.2k, False: 0]
  ------------------
 4876|  90.2k|            continue;
 4877|      0|        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
 4878|      0|        n += layer.Size;
 4879|      0|        layer.resize(0);
 4880|      0|    }
 4881|  90.2k|}
_ZN5ImGui12PushClipRectERK6ImVec2S2_b:
 4919|   361k|{
 4920|   361k|    ImGuiWindow* window = GetCurrentWindow();
 4921|   361k|    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
 4922|   361k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 4923|   361k|}
_ZN5ImGui11PopClipRectEv:
 4926|   180k|{
 4927|   180k|    ImGuiWindow* window = GetCurrentWindow();
 4928|   180k|    window->DrawList->PopClipRect();
 4929|   180k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 4930|   180k|}
_ZN5ImGui8EndFrameEv:
 5054|   180k|{
 5055|   180k|    ImGuiContext& g = *GImGui;
 5056|   180k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5057|       |
 5058|       |    // Don't process EndFrame() multiple times.
 5059|   180k|    if (g.FrameCountEnded == g.FrameCount)
  ------------------
  |  Branch (5059:9): [True: 90.2k, False: 90.2k]
  ------------------
 5060|  90.2k|        return;
 5061|  90.2k|    IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5062|       |
 5063|  90.2k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);
 5064|       |
 5065|  90.2k|    ErrorCheckEndFrameSanityChecks();
 5066|       |
 5067|       |    // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
 5068|  90.2k|    ImGuiPlatformImeData* ime_data = &g.PlatformImeData;
 5069|  90.2k|    if (g.IO.SetPlatformImeDataFn && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
  ------------------
  |  Branch (5069:9): [True: 90.2k, False: 0]
  |  Branch (5069:38): [True: 0, False: 90.2k]
  ------------------
 5070|      0|    {
 5071|      0|        ImGuiViewport* viewport = FindViewportByID(g.PlatformImeViewport);
 5072|      0|        IMGUI_DEBUG_LOG_IO("Calling io.SetPlatformImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);
  ------------------
  |  |  234|      0|#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (234:50): [True: 0, False: 0]
  |  |  |  Branch (234:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5073|      0|        g.IO.SetPlatformImeDataFn(viewport ? viewport : GetMainViewport(), ime_data);
  ------------------
  |  Branch (5073:35): [True: 0, False: 0]
  ------------------
 5074|      0|    }
 5075|       |
 5076|       |    // Hide implicit/fallback "Debug" window if it hasn't been used
 5077|  90.2k|    g.WithinFrameScopeWithImplicitWindow = false;
 5078|  90.2k|    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
  ------------------
  |  Branch (5078:9): [True: 90.2k, False: 0]
  |  Branch (5078:28): [True: 90.2k, False: 0]
  ------------------
 5079|  90.2k|        g.CurrentWindow->Active = false;
 5080|  90.2k|    End();
 5081|       |
 5082|       |    // Update navigation: CTRL+Tab, wrap-around requests
 5083|  90.2k|    NavEndFrame();
 5084|       |
 5085|       |    // Update docking
 5086|  90.2k|    DockContextEndFrame(&g);
 5087|       |
 5088|  90.2k|    SetCurrentViewport(NULL, NULL);
 5089|       |
 5090|       |    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
 5091|  90.2k|    if (g.DragDropActive)
  ------------------
  |  Branch (5091:9): [True: 56, False: 90.1k]
  ------------------
 5092|     56|    {
 5093|     56|        bool is_delivered = g.DragDropPayload.Delivery;
 5094|     56|        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
  ------------------
  |  Branch (5094:27): [True: 7, False: 49]
  |  Branch (5094:85): [True: 7, False: 0]
  |  Branch (5094:157): [True: 0, False: 0]
  ------------------
 5095|     56|        if (is_delivered || is_elapsed)
  ------------------
  |  Branch (5095:13): [True: 0, False: 56]
  |  Branch (5095:29): [True: 7, False: 49]
  ------------------
 5096|      7|            ClearDragDrop();
 5097|     56|    }
 5098|       |
 5099|       |    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
 5100|  90.2k|    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (5100:9): [True: 49, False: 90.1k]
  |  Branch (5100:29): [True: 9, False: 40]
  |  Branch (5100:74): [True: 0, False: 9]
  ------------------
 5101|      0|    {
 5102|      0|        g.DragDropWithinSource = true;
 5103|      0|        SetTooltip("...");
 5104|      0|        g.DragDropWithinSource = false;
 5105|      0|    }
 5106|       |
 5107|       |    // End frame
 5108|  90.2k|    g.WithinFrameScope = false;
 5109|  90.2k|    g.FrameCountEnded = g.FrameCount;
 5110|       |
 5111|       |    // Initiate moving window + handle left-click and right-click focus
 5112|  90.2k|    UpdateMouseMovingWindowEndFrame();
 5113|       |
 5114|       |    // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
 5115|  90.2k|    UpdateViewportsEndFrame();
 5116|       |
 5117|       |    // Sort the window list so that all child windows are after their parent
 5118|       |    // We cannot do that on FocusWindow() because children may not exist yet
 5119|  90.2k|    g.WindowsTempSortBuffer.resize(0);
 5120|  90.2k|    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
 5121|   360k|    for (int i = 0; i != g.Windows.Size; i++)
  ------------------
  |  Branch (5121:21): [True: 270k, False: 90.2k]
  ------------------
 5122|   270k|    {
 5123|   270k|        ImGuiWindow* window = g.Windows[i];
 5124|   270k|        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
  ------------------
  |  Branch (5124:13): [True: 90.5k, False: 180k]
  |  Branch (5124:31): [True: 323, False: 90.2k]
  ------------------
 5125|    323|            continue;
 5126|   270k|        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
 5127|   270k|    }
 5128|       |
 5129|       |    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
 5130|  90.2k|    IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5131|  90.2k|    g.Windows.swap(g.WindowsTempSortBuffer);
 5132|  90.2k|    g.IO.MetricsActiveWindows = g.WindowsActiveCount;
 5133|       |
 5134|       |    // Unlock font atlas
 5135|  90.2k|    g.IO.Fonts->Locked = false;
 5136|       |
 5137|       |    // Clear Input data for next frame
 5138|  90.2k|    g.IO.AppFocusLost = false;
 5139|  90.2k|    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
 5140|  90.2k|    g.IO.InputQueueCharacters.resize(0);
 5141|       |
 5142|  90.2k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
 5143|  90.2k|}
_ZN5ImGui6RenderEv:
 5149|  90.2k|{
 5150|  90.2k|    ImGuiContext& g = *GImGui;
 5151|  90.2k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5152|       |
 5153|  90.2k|    if (g.FrameCountEnded != g.FrameCount)
  ------------------
  |  Branch (5153:9): [True: 90.2k, False: 0]
  ------------------
 5154|  90.2k|        EndFrame();
 5155|  90.2k|    const bool first_render_of_frame = (g.FrameCountRendered != g.FrameCount);
 5156|  90.2k|    g.FrameCountRendered = g.FrameCount;
 5157|  90.2k|    g.IO.MetricsRenderWindows = 0;
 5158|       |
 5159|  90.2k|    CallContextHooks(&g, ImGuiContextHookType_RenderPre);
 5160|       |
 5161|       |    // Add background ImDrawList (for each active viewport)
 5162|   180k|    for (int n = 0; n != g.Viewports.Size; n++)
  ------------------
  |  Branch (5162:21): [True: 90.2k, False: 90.2k]
  ------------------
 5163|  90.2k|    {
 5164|  90.2k|        ImGuiViewportP* viewport = g.Viewports[n];
 5165|  90.2k|        viewport->DrawDataBuilder.Clear();
 5166|  90.2k|        if (viewport->DrawLists[0] != NULL)
  ------------------
  |  Branch (5166:13): [True: 0, False: 90.2k]
  ------------------
 5167|      0|            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
 5168|  90.2k|    }
 5169|       |
 5170|       |    // Add ImDrawList to render
 5171|  90.2k|    ImGuiWindow* windows_to_render_top_most[2];
 5172|  90.2k|    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
  ------------------
  |  Branch (5172:38): [True: 0, False: 90.2k]
  |  Branch (5172:62): [True: 0, False: 0]
  ------------------
 5173|  90.2k|    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
  ------------------
  |  Branch (5173:38): [True: 0, False: 90.2k]
  ------------------
 5174|   360k|    for (int n = 0; n != g.Windows.Size; n++)
  ------------------
  |  Branch (5174:21): [True: 270k, False: 90.2k]
  ------------------
 5175|   270k|    {
 5176|   270k|        ImGuiWindow* window = g.Windows[n];
 5177|   270k|        IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
 5178|   270k|        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
  ------------------
  |  Branch (5178:13): [True: 90.5k, False: 180k]
  |  Branch (5178:49): [True: 90.2k, False: 322]
  |  Branch (5178:104): [True: 90.2k, False: 0]
  |  Branch (5178:147): [True: 90.2k, False: 0]
  ------------------
 5179|  90.2k|            AddRootWindowToDrawData(window);
 5180|   270k|    }
 5181|   270k|    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
  ------------------
  |  |   87|   270k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5181:21): [True: 180k, False: 90.2k]
  ------------------
 5182|   180k|        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
  ------------------
  |  Branch (5182:13): [True: 0, False: 180k]
  |  Branch (5182:46): [True: 0, False: 0]
  ------------------
 5183|      0|            AddRootWindowToDrawData(windows_to_render_top_most[n]);
 5184|       |
 5185|       |    // Draw modal/window whitening backgrounds
 5186|  90.2k|    if (first_render_of_frame)
  ------------------
  |  Branch (5186:9): [True: 90.2k, False: 0]
  ------------------
 5187|  90.2k|        RenderDimmedBackgrounds();
 5188|       |
 5189|       |    // Draw software mouse cursor if requested by io.MouseDrawCursor flag
 5190|  90.2k|    if (g.IO.MouseDrawCursor && first_render_of_frame && g.MouseCursor != ImGuiMouseCursor_None)
  ------------------
  |  Branch (5190:9): [True: 0, False: 90.2k]
  |  Branch (5190:33): [True: 0, False: 0]
  |  Branch (5190:58): [True: 0, False: 0]
  ------------------
 5191|      0|        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2454|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2455|      0|#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
  |  |  ------------------
  |  |  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 5192|       |
 5193|       |    // Setup ImDrawData structures for end-user
 5194|  90.2k|    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
 5195|   180k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (5195:21): [True: 90.2k, False: 90.2k]
  ------------------
 5196|  90.2k|    {
 5197|  90.2k|        ImGuiViewportP* viewport = g.Viewports[n];
 5198|  90.2k|        viewport->DrawDataBuilder.FlattenIntoSingleLayer();
 5199|       |
 5200|       |        // Add foreground ImDrawList (for each active viewport)
 5201|  90.2k|        if (viewport->DrawLists[1] != NULL)
  ------------------
  |  Branch (5201:13): [True: 0, False: 90.2k]
  ------------------
 5202|      0|            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
 5203|       |
 5204|  90.2k|        SetupViewportDrawData(viewport, &viewport->DrawDataBuilder.Layers[0]);
 5205|  90.2k|        ImDrawData* draw_data = viewport->DrawData;
 5206|  90.2k|        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
 5207|  90.2k|        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
 5208|  90.2k|    }
 5209|       |
 5210|  90.2k|    CallContextHooks(&g, ImGuiContextHookType_RenderPost);
 5211|  90.2k|}
_ZN5ImGui12CalcTextSizeEPKcS1_bf:
 5216|   180k|{
 5217|   180k|    ImGuiContext& g = *GImGui;
 5218|       |
 5219|   180k|    const char* text_display_end;
 5220|   180k|    if (hide_text_after_double_hash)
  ------------------
  |  Branch (5220:9): [True: 180k, False: 0]
  ------------------
 5221|   180k|        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
 5222|      0|    else
 5223|      0|        text_display_end = text_end;
 5224|       |
 5225|   180k|    ImFont* font = g.Font;
 5226|   180k|    const float font_size = g.FontSize;
 5227|   180k|    if (text == text_display_end)
  ------------------
  |  Branch (5227:9): [True: 0, False: 180k]
  ------------------
 5228|      0|        return ImVec2(0.0f, font_size);
 5229|   180k|    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);
 5230|       |
 5231|       |    // Round
 5232|       |    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
 5233|       |    // FIXME: Investigate using ceilf or e.g.
 5234|       |    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
 5235|       |    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
 5236|   180k|    text_size.x = IM_FLOOR(text_size.x + 0.99999f);
  ------------------
  |  |  269|   180k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5237|       |
 5238|   180k|    return text_size;
 5239|   180k|}
_ZN5ImGui12IsItemActiveEv:
 5309|   180k|{
 5310|   180k|    ImGuiContext& g = *GImGui;
 5311|   180k|    if (g.ActiveId)
  ------------------
  |  Branch (5311:9): [True: 508, False: 179k]
  ------------------
 5312|    508|        return g.ActiveId == g.LastItemData.ID;
 5313|   179k|    return false;
 5314|   180k|}
_ZN5ImGui31SetActiveIdUsingAllKeyboardKeysEv:
 5418|     58|{
 5419|     58|    ImGuiContext& g = *GImGui;
 5420|     58|    IM_ASSERT(g.ActiveId != 0);
  ------------------
  |  |   23|     58|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5421|     58|    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
 5422|     58|    g.ActiveIdUsingAllKeyboardKeys = true;
 5423|     58|    NavMoveRequestCancel();
 5424|     58|}
_ZN5ImGui12BeginChildExEPKcjRK6ImVec2bi:
 5451|    323|{
 5452|    323|    ImGuiContext& g = *GImGui;
 5453|    323|    ImGuiWindow* parent_window = g.CurrentWindow;
 5454|       |
 5455|    323|    flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoDocking;
 5456|    323|    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag
 5457|       |
 5458|       |    // Size
 5459|    323|    const ImVec2 content_avail = GetContentRegionAvail();
 5460|    323|    ImVec2 size = ImFloor(size_arg);
 5461|    323|    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
  ------------------
  |  Branch (5461:34): [True: 251, False: 72]
  |  Branch (5461:83): [True: 235, False: 88]
  ------------------
 5462|    323|    if (size.x <= 0.0f)
  ------------------
  |  Branch (5462:9): [True: 251, False: 72]
  ------------------
 5463|    251|        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too many issues)
 5464|    323|    if (size.y <= 0.0f)
  ------------------
  |  Branch (5464:9): [True: 235, False: 88]
  ------------------
 5465|    235|        size.y = ImMax(content_avail.y + size.y, 4.0f);
 5466|    323|    SetNextWindowSize(size);
 5467|       |
 5468|       |    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
 5469|    323|    const char* temp_window_name;
 5470|    323|    if (name)
  ------------------
  |  Branch (5470:9): [True: 323, False: 0]
  ------------------
 5471|    323|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s_%08X", parent_window->Name, name, id);
 5472|      0|    else
 5473|      0|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%08X", parent_window->Name, id);
 5474|       |
 5475|    323|    const float backup_border_size = g.Style.ChildBorderSize;
 5476|    323|    if (!border)
  ------------------
  |  Branch (5476:9): [True: 201, False: 122]
  ------------------
 5477|    201|        g.Style.ChildBorderSize = 0.0f;
 5478|    323|    bool ret = Begin(temp_window_name, NULL, flags);
 5479|    323|    g.Style.ChildBorderSize = backup_border_size;
 5480|       |
 5481|    323|    ImGuiWindow* child_window = g.CurrentWindow;
 5482|    323|    child_window->ChildId = id;
 5483|    323|    child_window->AutoFitChildAxises = (ImS8)auto_fit_axises;
 5484|       |
 5485|       |    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
 5486|       |    // While this is not really documented/defined, it seems that the expected thing to do.
 5487|    323|    if (child_window->BeginCount == 1)
  ------------------
  |  Branch (5487:9): [True: 323, False: 0]
  ------------------
 5488|    323|        parent_window->DC.CursorPos = child_window->Pos;
 5489|       |
 5490|       |    // Process navigation-in immediately so NavInit can run on first frame
 5491|    323|    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavHasScroll))
  ------------------
  |  Branch (5491:9): [True: 0, False: 323]
  |  Branch (5491:34): [True: 0, False: 0]
  |  Branch (5491:79): [True: 0, False: 0]
  |  Branch (5491:124): [True: 0, False: 0]
  ------------------
 5492|      0|    {
 5493|      0|        FocusWindow(child_window);
 5494|      0|        NavInitWindow(child_window, false);
 5495|      0|        SetActiveID(id + 1, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
 5496|      0|        g.ActiveIdSource = ImGuiInputSource_Nav;
 5497|      0|    }
 5498|    323|    return ret;
 5499|    323|}
_ZN5ImGui10BeginChildEPKcRK6ImVec2bi:
 5502|    323|{
 5503|    323|    ImGuiWindow* window = GetCurrentWindow();
 5504|    323|    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
 5505|    323|}
_ZN5ImGui8EndChildEv:
 5514|    323|{
 5515|    323|    ImGuiContext& g = *GImGui;
 5516|    323|    ImGuiWindow* window = g.CurrentWindow;
 5517|       |
 5518|    323|    IM_ASSERT(g.WithinEndChild == false);
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5519|    323|    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() calls
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5520|       |
 5521|    323|    g.WithinEndChild = true;
 5522|    323|    if (window->BeginCount > 1)
  ------------------
  |  Branch (5522:9): [True: 0, False: 323]
  ------------------
 5523|      0|    {
 5524|      0|        End();
 5525|      0|    }
 5526|    323|    else
 5527|    323|    {
 5528|    323|        ImVec2 sz = window->Size;
 5529|    323|        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
  ------------------
  |  Branch (5529:13): [True: 251, False: 72]
  ------------------
 5530|    251|            sz.x = ImMax(4.0f, sz.x);
 5531|    323|        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
  ------------------
  |  Branch (5531:13): [True: 235, False: 88]
  ------------------
 5532|    235|            sz.y = ImMax(4.0f, sz.y);
 5533|    323|        End();
 5534|       |
 5535|    323|        ImGuiWindow* parent_window = g.CurrentWindow;
 5536|    323|        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
 5537|    323|        ItemSize(sz);
 5538|    323|        if ((window->DC.NavLayersActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
  ------------------
  |  Branch (5538:14): [True: 0, False: 323]
  |  Branch (5538:53): [True: 263, False: 60]
  |  Branch (5538:81): [True: 263, False: 0]
  ------------------
 5539|    263|        {
 5540|    263|            ItemAdd(bb, window->ChildId);
 5541|    263|            RenderNavHighlight(bb, window->ChildId);
 5542|       |
 5543|       |            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
 5544|    263|            if (window->DC.NavLayersActiveMask == 0 && window == g.NavWindow)
  ------------------
  |  Branch (5544:17): [True: 263, False: 0]
  |  Branch (5544:56): [True: 189, False: 74]
  ------------------
 5545|    189|                RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
 5546|    263|        }
 5547|     60|        else
 5548|     60|        {
 5549|       |            // Not navigable into
 5550|     60|            ItemAdd(bb, 0);
 5551|     60|        }
 5552|    323|        if (g.HoveredWindow == window)
  ------------------
  |  Branch (5552:13): [True: 0, False: 323]
  ------------------
 5553|      0|            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
 5554|    323|    }
 5555|    323|    g.WithinEndChild = false;
 5556|    323|    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
 5557|    323|}
_ZN5ImGui14FindWindowByIDEj:
 5588|   180k|{
 5589|   180k|    ImGuiContext& g = *GImGui;
 5590|   180k|    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
 5591|   180k|}
_ZN5ImGui16FindWindowByNameEPKc:
 5594|   180k|{
 5595|   180k|    ImGuiID id = ImHashStr(name);
 5596|   180k|    return FindWindowByID(id);
 5597|   180k|}
_ZN5ImGui30UpdateWindowParentAndRootLinksEP11ImGuiWindowiS1_:
 6320|   180k|{
 6321|   180k|    window->ParentWindow = parent_window;
 6322|   180k|    window->RootWindow = window->RootWindowPopupTree = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
 6323|   180k|    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (6323:9): [True: 323, False: 180k]
  |  Branch (6323:26): [True: 323, False: 0]
  |  Branch (6323:68): [True: 323, False: 0]
  ------------------
 6324|    323|    {
 6325|    323|        window->RootWindowDockTree = parent_window->RootWindowDockTree;
 6326|    323|        if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6326:13): [True: 323, False: 0]
  |  Branch (6326:38): [True: 323, False: 0]
  ------------------
 6327|    323|            window->RootWindow = parent_window->RootWindow;
 6328|    323|    }
 6329|   180k|    if (parent_window && (flags & ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (6329:9): [True: 323, False: 180k]
  |  Branch (6329:26): [True: 0, False: 323]
  ------------------
 6330|      0|        window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
 6331|   180k|    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) // FIXME: simply use _NoTitleBar ?
  ------------------
  |  Branch (6331:9): [True: 323, False: 180k]
  |  Branch (6331:26): [True: 323, False: 0]
  |  Branch (6331:63): [True: 323, False: 0]
  ------------------
 6332|    323|        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
 6333|   180k|    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
  ------------------
  |  Branch (6333:12): [True: 0, False: 180k]
  ------------------
 6334|      0|    {
 6335|      0|        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6336|      0|        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
 6337|      0|    }
 6338|   180k|}
_ZN5ImGui5BeginEPKcPbi:
 6380|   180k|{
 6381|   180k|    ImGuiContext& g = *GImGui;
 6382|   180k|    const ImGuiStyle& style = g.Style;
 6383|   180k|    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6384|   180k|    IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6385|   180k|    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6386|       |
 6387|       |    // Find or create
 6388|   180k|    ImGuiWindow* window = FindWindowByName(name);
 6389|   180k|    const bool window_just_created = (window == NULL);
 6390|   180k|    if (window_just_created)
  ------------------
  |  Branch (6390:9): [True: 3, False: 180k]
  ------------------
 6391|      3|        window = CreateNewWindow(name, flags);
 6392|       |
 6393|       |    // Automatically disable manual moving/resizing when NoInputs is set
 6394|   180k|    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
  ------------------
  |  Branch (6394:9): [True: 0, False: 180k]
  ------------------
 6395|      0|        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
 6396|       |
 6397|   180k|    if (flags & ImGuiWindowFlags_NavFlattened)
  ------------------
  |  Branch (6397:9): [True: 0, False: 180k]
  ------------------
 6398|   180k|        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6399|       |
 6400|   180k|    const int current_frame = g.FrameCount;
 6401|   180k|    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
 6402|   180k|    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);
  ------------------
  |  Branch (6402:33): [True: 90.2k, False: 90.5k]
  |  Branch (6402:67): [True: 90.2k, False: 0]
  ------------------
 6403|       |
 6404|       |    // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
 6405|   180k|    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
 6406|   180k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6406:9): [True: 0, False: 180k]
  ------------------
 6407|      0|    {
 6408|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 6409|      0|        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
 6410|      0|        window_just_activated_by_user |= (window != popup_ref.Window);
 6411|      0|    }
 6412|       |
 6413|       |    // Update Flags, LastFrameActive, BeginOrderXXX fields
 6414|   180k|    const bool window_was_appearing = window->Appearing;
 6415|   180k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6415:9): [True: 180k, False: 0]
  ------------------
 6416|   180k|    {
 6417|   180k|        UpdateWindowInFocusOrderList(window, window_just_created, flags);
 6418|   180k|        window->Appearing = window_just_activated_by_user;
 6419|   180k|        if (window->Appearing)
  ------------------
  |  Branch (6419:13): [True: 6, False: 180k]
  ------------------
 6420|      6|            SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6421|   180k|        window->FlagsPreviousFrame = window->Flags;
 6422|   180k|        window->Flags = (ImGuiWindowFlags)flags;
 6423|   180k|        window->LastFrameActive = current_frame;
 6424|   180k|        window->LastTimeActive = (float)g.Time;
 6425|   180k|        window->BeginOrderWithinParent = 0;
 6426|   180k|        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
 6427|   180k|    }
 6428|      0|    else
 6429|      0|    {
 6430|      0|        flags = window->Flags;
 6431|      0|    }
 6432|       |
 6433|       |    // Docking
 6434|       |    // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
 6435|   180k|    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6436|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
  ------------------
  |  Branch (6436:9): [True: 0, False: 180k]
  ------------------
 6437|      0|        SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
 6438|   180k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6438:9): [True: 180k, False: 0]
  ------------------
 6439|   180k|    {
 6440|   180k|        bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
  ------------------
  |  Branch (6440:31): [True: 0, False: 180k]
  |  Branch (6440:54): [True: 0, False: 180k]
  ------------------
 6441|   180k|        bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
  ------------------
  |  Branch (6441:35): [True: 180k, False: 0]
  |  Branch (6441:53): [True: 0, False: 180k]
  ------------------
 6442|   180k|        bool dock_node_was_visible = window->DockNodeIsVisible;
 6443|   180k|        bool dock_tab_was_visible = window->DockTabIsVisible;
 6444|   180k|        if (has_dock_node || new_auto_dock_node)
  ------------------
  |  Branch (6444:13): [True: 0, False: 180k]
  |  Branch (6444:30): [True: 0, False: 180k]
  ------------------
 6445|      0|        {
 6446|      0|            BeginDocked(window, p_open);
 6447|      0|            flags = window->Flags;
 6448|      0|            if (window->DockIsActive)
  ------------------
  |  Branch (6448:17): [True: 0, False: 0]
  ------------------
 6449|      0|            {
 6450|      0|                IM_ASSERT(window->DockNode != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6451|      0|                g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
 6452|      0|            }
 6453|       |
 6454|       |            // Amend the Appearing flag
 6455|      0|            if (window->DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window->Appearing && !window_was_appearing)
  ------------------
  |  Branch (6455:17): [True: 0, False: 0]
  |  Branch (6455:45): [True: 0, False: 0]
  |  Branch (6455:70): [True: 0, False: 0]
  |  Branch (6455:95): [True: 0, False: 0]
  |  Branch (6455:117): [True: 0, False: 0]
  ------------------
 6456|      0|            {
 6457|      0|                window->Appearing = true;
 6458|      0|                SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6459|      0|            }
 6460|      0|        }
 6461|   180k|        else
 6462|   180k|        {
 6463|   180k|            window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
 6464|   180k|        }
 6465|   180k|    }
 6466|       |
 6467|       |    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
 6468|   180k|    ImGuiWindow* parent_window_in_stack = (window->DockIsActive && window->DockNode->HostWindow) ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
  ------------------
  |  Branch (6468:44): [True: 0, False: 180k]
  |  Branch (6468:68): [True: 0, False: 0]
  |  Branch (6468:131): [True: 90.2k, False: 90.5k]
  ------------------
 6469|   180k|    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
  ------------------
  |  Branch (6469:34): [True: 180k, False: 0]
  |  Branch (6469:62): [True: 323, False: 180k]
  ------------------
 6470|   180k|    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6471|       |
 6472|       |    // We allow window memory to be compacted so recreate the base stack when needed.
 6473|   180k|    if (window->IDStack.Size == 0)
  ------------------
  |  Branch (6473:9): [True: 0, False: 180k]
  ------------------
 6474|      0|        window->IDStack.push_back(window->ID);
 6475|       |
 6476|       |    // Add to stack
 6477|       |    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
 6478|   180k|    g.CurrentWindow = window;
 6479|   180k|    ImGuiWindowStackData window_stack_data;
 6480|   180k|    window_stack_data.Window = window;
 6481|   180k|    window_stack_data.ParentLastItemDataBackup = g.LastItemData;
 6482|   180k|    window_stack_data.StackSizesOnBegin.SetToCurrentState();
 6483|   180k|    g.CurrentWindowStack.push_back(window_stack_data);
 6484|   180k|    if (flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (6484:9): [True: 0, False: 180k]
  ------------------
 6485|      0|        g.BeginMenuCount++;
 6486|       |
 6487|       |    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
 6488|   180k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6488:9): [True: 180k, False: 0]
  ------------------
 6489|   180k|    {
 6490|   180k|        UpdateWindowParentAndRootLinks(window, flags, parent_window);
 6491|   180k|        window->ParentWindowInBeginStack = parent_window_in_stack;
 6492|   180k|    }
 6493|       |
 6494|       |    // Add to focus scope stack
 6495|   180k|    PushFocusScope(window->ID);
 6496|   180k|    window->NavRootFocusScopeId = g.CurrentFocusScopeId;
 6497|   180k|    g.CurrentWindow = NULL;
 6498|       |
 6499|       |    // Add to popup stack
 6500|   180k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6500:9): [True: 0, False: 180k]
  ------------------
 6501|      0|    {
 6502|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 6503|      0|        popup_ref.Window = window;
 6504|      0|        popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
 6505|      0|        g.BeginPopupStack.push_back(popup_ref);
 6506|      0|        window->PopupId = popup_ref.PopupId;
 6507|      0|    }
 6508|       |
 6509|       |    // Process SetNextWindow***() calls
 6510|       |    // (FIXME: Consider splitting the HasXXX flags into X/Y components
 6511|   180k|    bool window_pos_set_by_api = false;
 6512|   180k|    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
 6513|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
  ------------------
  |  Branch (6513:9): [True: 0, False: 180k]
  ------------------
 6514|      0|    {
 6515|      0|        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
 6516|      0|        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
  ------------------
  |  Branch (6516:13): [True: 0, False: 0]
  |  Branch (6516:38): [True: 0, False: 0]
  ------------------
 6517|      0|        {
 6518|       |            // May be processed on the next frame if this is our first frame and we are measuring size
 6519|       |            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
 6520|      0|            window->SetWindowPosVal = g.NextWindowData.PosVal;
 6521|      0|            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
 6522|      0|            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 6523|      0|        }
 6524|      0|        else
 6525|      0|        {
 6526|      0|            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
 6527|      0|        }
 6528|      0|    }
 6529|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
  ------------------
  |  Branch (6529:9): [True: 90.5k, False: 90.2k]
  ------------------
 6530|  90.5k|    {
 6531|  90.5k|        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
  ------------------
  |  Branch (6531:36): [True: 324, False: 90.2k]
  |  Branch (6531:106): [True: 324, False: 0]
  ------------------
 6532|  90.5k|        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
  ------------------
  |  Branch (6532:36): [True: 324, False: 90.2k]
  |  Branch (6532:106): [True: 324, False: 0]
  ------------------
 6533|  90.5k|        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
 6534|  90.5k|    }
 6535|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
  ------------------
  |  Branch (6535:9): [True: 0, False: 180k]
  ------------------
 6536|      0|    {
 6537|      0|        if (g.NextWindowData.ScrollVal.x >= 0.0f)
  ------------------
  |  Branch (6537:13): [True: 0, False: 0]
  ------------------
 6538|      0|        {
 6539|      0|            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
 6540|      0|            window->ScrollTargetCenterRatio.x = 0.0f;
 6541|      0|        }
 6542|      0|        if (g.NextWindowData.ScrollVal.y >= 0.0f)
  ------------------
  |  Branch (6542:13): [True: 0, False: 0]
  ------------------
 6543|      0|        {
 6544|      0|            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
 6545|      0|            window->ScrollTargetCenterRatio.y = 0.0f;
 6546|      0|        }
 6547|      0|    }
 6548|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
  ------------------
  |  Branch (6548:9): [True: 0, False: 180k]
  ------------------
 6549|      0|        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
 6550|   180k|    else if (first_begin_of_the_frame)
  ------------------
  |  Branch (6550:14): [True: 180k, False: 0]
  ------------------
 6551|   180k|        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
 6552|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
  ------------------
  |  Branch (6552:9): [True: 0, False: 180k]
  ------------------
 6553|      0|        window->WindowClass = g.NextWindowData.WindowClass;
 6554|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
  ------------------
  |  Branch (6554:9): [True: 0, False: 180k]
  ------------------
 6555|      0|        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
 6556|   180k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
  ------------------
  |  Branch (6556:9): [True: 0, False: 180k]
  ------------------
 6557|      0|        FocusWindow(window);
 6558|   180k|    if (window->Appearing)
  ------------------
  |  Branch (6558:9): [True: 6, False: 180k]
  ------------------
 6559|      6|        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);
 6560|       |
 6561|       |    // When reusing window again multiple times a frame, just append content (don't need to setup again)
 6562|   180k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6562:9): [True: 180k, False: 0]
  ------------------
 6563|   180k|    {
 6564|       |        // Initialize
 6565|   180k|        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
  ------------------
  |  Branch (6565:46): [True: 323, False: 180k]
  |  Branch (6565:88): [True: 0, False: 323]
  ------------------
 6566|   180k|        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
 6567|   180k|        window->Active = true;
 6568|   180k|        window->HasCloseButton = (p_open != NULL);
 6569|   180k|        window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
 6570|   180k|        window->IDStack.resize(1);
 6571|   180k|        window->DrawList->_ResetForNewFrame();
 6572|   180k|        window->DC.CurrentTableIdx = -1;
 6573|   180k|        if (flags & ImGuiWindowFlags_DockNodeHost)
  ------------------
  |  Branch (6573:13): [True: 0, False: 180k]
  ------------------
 6574|      0|        {
 6575|      0|            window->DrawList->ChannelsSplit(2);
 6576|      0|            window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
  ------------------
  |  | 1582|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 6577|      0|        }
 6578|       |
 6579|       |        // Restore buffer capacity when woken from a compacted state, to avoid
 6580|   180k|        if (window->MemoryCompacted)
  ------------------
  |  Branch (6580:13): [True: 0, False: 180k]
  ------------------
 6581|      0|            GcAwakeTransientWindowBuffers(window);
 6582|       |
 6583|       |        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
 6584|       |        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
 6585|   180k|        bool window_title_visible_elsewhere = false;
 6586|   180k|        if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
  ------------------
  |  Branch (6586:14): [True: 180k, False: 3]
  |  Branch (6586:34): [True: 0, False: 180k]
  |  Branch (6586:73): [True: 0, False: 180k]
  ------------------
 6587|      0|            window_title_visible_elsewhere = true;
 6588|   180k|        else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
  ------------------
  |  Branch (6588:18): [True: 0, False: 180k]
  |  Branch (6588:54): [True: 0, False: 0]
  ------------------
 6589|      0|            window_title_visible_elsewhere = true;
 6590|   180k|        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
  ------------------
  |  Branch (6590:13): [True: 0, False: 180k]
  |  Branch (6590:47): [True: 0, False: 0]
  |  Branch (6590:71): [True: 0, False: 0]
  ------------------
 6591|      0|        {
 6592|      0|            size_t buf_len = (size_t)window->NameBufLen;
 6593|      0|            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
 6594|      0|            window->NameBufLen = (int)buf_len;
 6595|      0|        }
 6596|       |
 6597|       |        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
 6598|       |
 6599|       |        // Update contents size from last frame for auto-fitting (or use explicit size)
 6600|   180k|        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
 6601|       |
 6602|       |        // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
 6603|       |        // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
 6604|       |        // it has a single usage before this code block and may be set below before it is finally checked.
 6605|   180k|        if (window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (6605:13): [True: 0, False: 180k]
  ------------------
 6606|      0|            window->HiddenFramesCanSkipItems--;
 6607|   180k|        if (window->HiddenFramesCannotSkipItems > 0)
  ------------------
  |  Branch (6607:13): [True: 2, False: 180k]
  ------------------
 6608|      2|            window->HiddenFramesCannotSkipItems--;
 6609|   180k|        if (window->HiddenFramesForRenderOnly > 0)
  ------------------
  |  Branch (6609:13): [True: 0, False: 180k]
  ------------------
 6610|      0|            window->HiddenFramesForRenderOnly--;
 6611|       |
 6612|       |        // Hide new windows for one frame until they calculate their size
 6613|   180k|        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
  ------------------
  |  Branch (6613:13): [True: 3, False: 180k]
  |  Branch (6613:37): [True: 1, False: 2]
  |  Branch (6613:66): [True: 0, False: 2]
  ------------------
 6614|      1|            window->HiddenFramesCannotSkipItems = 1;
 6615|       |
 6616|       |        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
 6617|       |        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
 6618|   180k|        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
  ------------------
  |  Branch (6618:13): [True: 6, False: 180k]
  |  Branch (6618:46): [True: 0, False: 6]
  ------------------
 6619|      0|        {
 6620|      0|            window->HiddenFramesCannotSkipItems = 1;
 6621|      0|            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
  ------------------
  |  Branch (6621:17): [True: 0, False: 0]
  ------------------
 6622|      0|            {
 6623|      0|                if (!window_size_x_set_by_api)
  ------------------
  |  Branch (6623:21): [True: 0, False: 0]
  ------------------
 6624|      0|                    window->Size.x = window->SizeFull.x = 0.f;
 6625|      0|                if (!window_size_y_set_by_api)
  ------------------
  |  Branch (6625:21): [True: 0, False: 0]
  ------------------
 6626|      0|                    window->Size.y = window->SizeFull.y = 0.f;
 6627|      0|                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
 6628|      0|            }
 6629|      0|        }
 6630|       |
 6631|       |        // SELECT VIEWPORT
 6632|       |        // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.
 6633|       |
 6634|   180k|        WindowSelectViewport(window);
 6635|   180k|        SetCurrentViewport(window, window->Viewport);
 6636|   180k|        window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (6636:32): [True: 0, False: 180k]
  ------------------
 6637|   180k|        SetCurrentWindow(window);
 6638|   180k|        flags = window->Flags;
 6639|       |
 6640|       |        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
 6641|       |        // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.
 6642|       |
 6643|   180k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (6643:13): [True: 323, False: 180k]
  ------------------
 6644|    323|            window->WindowBorderSize = style.ChildBorderSize;
 6645|   180k|        else
 6646|   180k|            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
  ------------------
  |  Branch (6646:41): [True: 0, False: 180k]
  |  Branch (6646:106): [True: 0, False: 0]
  ------------------
 6647|   180k|        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
  ------------------
  |  Branch (6647:13): [True: 180k, False: 0]
  |  Branch (6647:38): [True: 323, False: 180k]
  |  Branch (6647:80): [True: 323, False: 0]
  |  Branch (6647:161): [True: 201, False: 122]
  ------------------
 6648|    201|            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
  ------------------
  |  Branch (6648:50): [True: 0, False: 201]
  ------------------
 6649|   180k|        else
 6650|   180k|            window->WindowPadding = style.WindowPadding;
 6651|       |
 6652|       |        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
 6653|   180k|        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
 6654|   180k|        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
 6655|       |
 6656|   180k|        bool use_current_size_for_scrollbar_x = window_just_created;
 6657|   180k|        bool use_current_size_for_scrollbar_y = window_just_created;
 6658|       |
 6659|       |        // Collapse window by double-clicking on title bar
 6660|       |        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
 6661|   180k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
  ------------------
  |  Branch (6661:13): [True: 180k, False: 323]
  |  Branch (6661:55): [True: 180k, False: 0]
  |  Branch (6661:97): [True: 180k, False: 0]
  ------------------
 6662|   180k|        {
 6663|       |            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
 6664|   180k|            ImRect title_bar_rect = window->TitleBarRect();
 6665|   180k|            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseClickedCount[0] == 2)
  ------------------
  |  Branch (6665:17): [True: 508, False: 179k]
  |  Branch (6665:46): [True: 508, False: 0]
  |  Branch (6665:66): [True: 213, False: 295]
  |  Branch (6665:99): [True: 76, False: 137]
  |  Branch (6665:162): [True: 0, False: 76]
  ------------------
 6666|      0|                window->WantCollapseToggle = true;
 6667|   180k|            if (window->WantCollapseToggle)
  ------------------
  |  Branch (6667:17): [True: 7, False: 180k]
  ------------------
 6668|      7|            {
 6669|      7|                window->Collapsed = !window->Collapsed;
 6670|      7|                if (!window->Collapsed)
  ------------------
  |  Branch (6670:21): [True: 3, False: 4]
  ------------------
 6671|      3|                    use_current_size_for_scrollbar_y = true;
 6672|      7|                MarkIniSettingsDirty(window);
 6673|      7|            }
 6674|   180k|        }
 6675|    323|        else
 6676|    323|        {
 6677|    323|            window->Collapsed = false;
 6678|    323|        }
 6679|   180k|        window->WantCollapseToggle = false;
 6680|       |
 6681|       |        // SIZE
 6682|       |
 6683|       |        // Outer Decoration Sizes
 6684|       |        // (we need to clear ScrollbarSize immediatly as CalcWindowAutoFitSize() needs it and can be called from other locations).
 6685|   180k|        const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
 6686|   180k|        window->DecoOuterSizeX1 = 0.0f;
 6687|   180k|        window->DecoOuterSizeX2 = 0.0f;
 6688|   180k|        window->DecoOuterSizeY1 = window->TitleBarHeight() + window->MenuBarHeight();
 6689|   180k|        window->DecoOuterSizeY2 = 0.0f;
 6690|   180k|        window->ScrollbarSizes = ImVec2(0.0f, 0.0f);
 6691|       |
 6692|       |        // Calculate auto-fit size, handle automatic resize
 6693|   180k|        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
 6694|   180k|        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
  ------------------
  |  Branch (6694:13): [True: 0, False: 180k]
  |  Branch (6694:60): [True: 0, False: 0]
  ------------------
 6695|      0|        {
 6696|       |            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
 6697|      0|            if (!window_size_x_set_by_api)
  ------------------
  |  Branch (6697:17): [True: 0, False: 0]
  ------------------
 6698|      0|            {
 6699|      0|                window->SizeFull.x = size_auto_fit.x;
 6700|      0|                use_current_size_for_scrollbar_x = true;
 6701|      0|            }
 6702|      0|            if (!window_size_y_set_by_api)
  ------------------
  |  Branch (6702:17): [True: 0, False: 0]
  ------------------
 6703|      0|            {
 6704|      0|                window->SizeFull.y = size_auto_fit.y;
 6705|      0|                use_current_size_for_scrollbar_y = true;
 6706|      0|            }
 6707|      0|        }
 6708|   180k|        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6708:18): [True: 2, False: 180k]
  |  Branch (6708:48): [True: 0, False: 180k]
  ------------------
 6709|      2|        {
 6710|       |            // Auto-fit may only grow window during the first few frames
 6711|       |            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
 6712|      2|            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
  ------------------
  |  Branch (6712:17): [True: 2, False: 0]
  |  Branch (6712:46): [True: 2, False: 0]
  ------------------
 6713|      2|            {
 6714|      2|                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
  ------------------
  |  Branch (6714:38): [True: 2, False: 0]
  ------------------
 6715|      2|                use_current_size_for_scrollbar_x = true;
 6716|      2|            }
 6717|      2|            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6717:17): [True: 2, False: 0]
  |  Branch (6717:46): [True: 2, False: 0]
  ------------------
 6718|      2|            {
 6719|      2|                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
  ------------------
  |  Branch (6719:38): [True: 2, False: 0]
  ------------------
 6720|      2|                use_current_size_for_scrollbar_y = true;
 6721|      2|            }
 6722|      2|            if (!window->Collapsed)
  ------------------
  |  Branch (6722:17): [True: 2, False: 0]
  ------------------
 6723|      2|                MarkIniSettingsDirty(window);
 6724|      2|        }
 6725|       |
 6726|       |        // Apply minimum/maximum window size constraints and final size
 6727|   180k|        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
 6728|   180k|        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;
  ------------------
  |  Branch (6728:24): [True: 89.9k, False: 90.8k]
  |  Branch (6728:45): [True: 89.9k, False: 0]
  ------------------
 6729|       |
 6730|       |        // POSITION
 6731|       |
 6732|       |        // Popup latch its initial position, will position itself when it appears next frame
 6733|   180k|        if (window_just_activated_by_user)
  ------------------
  |  Branch (6733:13): [True: 6, False: 180k]
  ------------------
 6734|      6|        {
 6735|      6|            window->AutoPosLastDirection = ImGuiDir_None;
 6736|      6|            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
  ------------------
  |  Branch (6736:17): [True: 0, False: 6]
  |  Branch (6736:58): [True: 0, False: 0]
  |  Branch (6736:95): [True: 0, False: 0]
  ------------------
 6737|      0|                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
 6738|      6|        }
 6739|       |
 6740|       |        // Position child window
 6741|   180k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (6741:13): [True: 323, False: 180k]
  ------------------
 6742|    323|        {
 6743|    323|            IM_ASSERT(parent_window && parent_window->Active);
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6744|    323|            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
 6745|    323|            parent_window->DC.ChildWindows.push_back(window);
 6746|    323|            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (6746:17): [True: 323, False: 0]
  |  Branch (6746:54): [True: 323, False: 0]
  |  Branch (6746:80): [True: 323, False: 0]
  ------------------
 6747|    323|                window->Pos = parent_window->DC.CursorPos;
 6748|    323|        }
 6749|       |
 6750|   180k|        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
  ------------------
  |  Branch (6750:45): [True: 0, False: 180k]
  |  Branch (6750:85): [True: 0, False: 0]
  ------------------
 6751|   180k|        if (window_pos_with_pivot)
  ------------------
  |  Branch (6751:13): [True: 0, False: 180k]
  ------------------
 6752|      0|            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
 6753|   180k|        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
  ------------------
  |  Branch (6753:18): [True: 0, False: 180k]
  ------------------
 6754|      0|            window->Pos = FindBestWindowPosForPopup(window);
 6755|   180k|        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
  ------------------
  |  Branch (6755:18): [True: 0, False: 180k]
  |  Branch (6755:59): [True: 0, False: 0]
  |  Branch (6755:85): [True: 0, False: 0]
  ------------------
 6756|      0|            window->Pos = FindBestWindowPosForPopup(window);
 6757|   180k|        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (6757:18): [True: 0, False: 180k]
  |  Branch (6757:61): [True: 0, False: 0]
  |  Branch (6757:87): [True: 0, False: 0]
  ------------------
 6758|      0|            window->Pos = FindBestWindowPosForPopup(window);
 6759|       |
 6760|       |        // Late create viewport if we don't fit within our current host viewport.
 6761|   180k|        if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_Minimized))
  ------------------
  |  Branch (6761:13): [True: 0, False: 180k]
  |  Branch (6761:64): [True: 0, False: 0]
  |  Branch (6761:90): [True: 0, False: 0]
  ------------------
 6762|      0|            if (!window->Viewport->GetMainRect().Contains(window->Rect()))
  ------------------
  |  Branch (6762:17): [True: 0, False: 0]
  ------------------
 6763|      0|            {
 6764|       |                // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
 6765|       |                //ImGuiViewport* old_viewport = window->Viewport;
 6766|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
 6767|       |
 6768|       |                // FIXME-DPI
 6769|       |                //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
 6770|      0|                SetCurrentViewport(window, window->Viewport);
 6771|      0|                window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (6771:40): [True: 0, False: 0]
  ------------------
 6772|      0|                SetCurrentWindow(window);
 6773|      0|            }
 6774|       |
 6775|   180k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6775:13): [True: 0, False: 180k]
  ------------------
 6776|      0|            WindowSyncOwnedViewport(window, parent_window_in_stack);
 6777|       |
 6778|       |        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
 6779|       |        // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
 6780|   180k|        ImRect viewport_rect(window->Viewport->GetMainRect());
 6781|   180k|        ImRect viewport_work_rect(window->Viewport->GetWorkRect());
 6782|   180k|        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
 6783|   180k|        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);
 6784|       |
 6785|       |        // Clamp position/size so window stays visible within its viewport or monitor
 6786|       |        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
 6787|       |        // FIXME: Similar to code in GetWindowAllowedExtentRect()
 6788|   180k|        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (6788:13): [True: 180k, False: 0]
  |  Branch (6788:39): [True: 180k, False: 323]
  ------------------
 6789|   180k|        {
 6790|   180k|            if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
  ------------------
  |  Branch (6790:17): [True: 180k, False: 0]
  |  Branch (6790:43): [True: 180k, False: 0]
  |  Branch (6790:75): [True: 180k, False: 0]
  ------------------
 6791|   180k|            {
 6792|   180k|                ClampWindowPos(window, visibility_rect);
 6793|   180k|            }
 6794|      0|            else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
  ------------------
  |  Branch (6794:22): [True: 0, False: 0]
  |  Branch (6794:47): [True: 0, False: 0]
  ------------------
 6795|      0|            {
 6796|       |                // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
 6797|      0|                const ImGuiPlatformMonitor* monitor = GetViewportPlatformMonitor(window->Viewport);
 6798|      0|                visibility_rect.Min = monitor->WorkPos + visibility_padding;
 6799|      0|                visibility_rect.Max = monitor->WorkPos + monitor->WorkSize - visibility_padding;
 6800|      0|                ClampWindowPos(window, visibility_rect);
 6801|      0|            }
 6802|   180k|        }
 6803|   180k|        window->Pos = ImFloor(window->Pos);
 6804|       |
 6805|       |        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
 6806|       |        // Large values tend to lead to variety of artifacts and are not recommended.
 6807|   180k|        if (window->ViewportOwned || window->DockIsActive)
  ------------------
  |  Branch (6807:13): [True: 0, False: 180k]
  |  Branch (6807:38): [True: 0, False: 180k]
  ------------------
 6808|      0|            window->WindowRounding = 0.0f;
 6809|   180k|        else
 6810|   180k|            window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
  ------------------
  |  Branch (6810:38): [True: 323, False: 180k]
  |  Branch (6810:102): [True: 0, False: 180k]
  |  Branch (6810:138): [True: 0, False: 0]
  ------------------
 6811|       |
 6812|       |        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
 6813|       |        //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
 6814|       |        //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);
 6815|       |
 6816|       |        // Apply window focus (new and reactivated windows are moved to front)
 6817|   180k|        bool want_focus = false;
 6818|   180k|        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
  ------------------
  |  Branch (6818:13): [True: 6, False: 180k]
  |  Branch (6818:46): [True: 6, False: 0]
  ------------------
 6819|      6|        {
 6820|      6|            if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6820:17): [True: 0, False: 6]
  ------------------
 6821|      0|                want_focus = true;
 6822|      6|            else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (6822:23): [True: 0, False: 6]
  |  Branch (6822:47): [True: 2, False: 4]
  |  Branch (6822:95): [True: 2, False: 0]
  ------------------
 6823|      2|                want_focus = true;
 6824|       |
 6825|      6|            ImGuiWindow* modal = GetTopMostPopupModal();
 6826|      6|            if (modal != NULL && !IsWindowWithinBeginStackOf(window, modal))
  ------------------
  |  Branch (6826:17): [True: 0, False: 6]
  |  Branch (6826:34): [True: 0, False: 0]
  ------------------
 6827|      0|            {
 6828|       |                // Avoid focusing a window that is created outside of active modal. This will prevent active modal from being closed.
 6829|       |                // Since window is not focused it would reappear at the same display position like the last time it was visible.
 6830|       |                // In case of completely new windows it would go to the top (over current modal), but input to such window would still be blocked by modal.
 6831|       |                // Position window behind a modal that is not a begin-parent of this window.
 6832|      0|                want_focus = false;
 6833|      0|                if (window == window->RootWindow)
  ------------------
  |  Branch (6833:21): [True: 0, False: 0]
  ------------------
 6834|      0|                {
 6835|      0|                    ImGuiWindow* blocking_modal = FindBlockingModal(window);
 6836|      0|                    IM_ASSERT(blocking_modal != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6837|      0|                    BringWindowToDisplayBehind(window, blocking_modal);
 6838|      0|                }
 6839|      0|            }
 6840|      6|        }
 6841|       |
 6842|       |        // [Test Engine] Register whole window in the item system
 6843|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 6844|       |        if (g.TestEngineHookItems)
 6845|       |        {
 6846|       |            IM_ASSERT(window->IDStack.Size == 1);
 6847|       |            window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
 6848|       |            IMGUI_TEST_ENGINE_ITEM_ADD(window->Rect(), window->ID);
 6849|       |            IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
 6850|       |            window->IDStack.Size = 1;
 6851|       |        }
 6852|       |#endif
 6853|       |
 6854|       |        // Decide if we are going to handle borders and resize grips
 6855|   180k|        const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);
  ------------------
  |  Branch (6855:55): [True: 0, False: 180k]
  |  Branch (6855:81): [True: 180k, False: 0]
  ------------------
 6856|       |
 6857|       |        // Handle manual resize: Resize Grips, Borders, Gamepad
 6858|   180k|        int border_held = -1;
 6859|   180k|        ImU32 resize_grip_col[4] = {};
 6860|   180k|        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
  ------------------
  |  Branch (6860:39): [True: 0, False: 180k]
  ------------------
 6861|   180k|        const float resize_grip_draw_size = IM_FLOOR(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  269|   180k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 6862|   180k|        if (handle_borders_and_resize_grips && !window->Collapsed)
  ------------------
  |  Branch (6862:13): [True: 180k, False: 0]
  |  Branch (6862:48): [True: 90.8k, False: 89.9k]
  ------------------
 6863|  90.8k|            if (UpdateWindowManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
  ------------------
  |  Branch (6863:17): [True: 0, False: 90.8k]
  ------------------
 6864|      0|                use_current_size_for_scrollbar_x = use_current_size_for_scrollbar_y = true;
 6865|   180k|        window->ResizeBorderHeld = (signed char)border_held;
 6866|       |
 6867|       |        // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
 6868|   180k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6868:13): [True: 0, False: 180k]
  ------------------
 6869|      0|        {
 6870|      0|            if (!window->Viewport->PlatformRequestMove)
  ------------------
  |  Branch (6870:17): [True: 0, False: 0]
  ------------------
 6871|      0|                window->Viewport->Pos = window->Pos;
 6872|      0|            if (!window->Viewport->PlatformRequestResize)
  ------------------
  |  Branch (6872:17): [True: 0, False: 0]
  ------------------
 6873|      0|                window->Viewport->Size = window->Size;
 6874|      0|            window->Viewport->UpdateWorkRect();
 6875|      0|            viewport_rect = window->Viewport->GetMainRect();
 6876|      0|        }
 6877|       |
 6878|       |        // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
 6879|   180k|        window->ViewportPos = window->Viewport->Pos;
 6880|       |
 6881|       |        // SCROLLBAR VISIBILITY
 6882|       |
 6883|       |        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
 6884|   180k|        if (!window->Collapsed)
  ------------------
  |  Branch (6884:13): [True: 90.8k, False: 89.9k]
  ------------------
 6885|  90.8k|        {
 6886|       |            // When reading the current size we need to read it after size constraints have been applied.
 6887|       |            // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
 6888|       |            // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
 6889|  90.8k|            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
 6890|  90.8k|            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
 6891|  90.8k|            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
  ------------------
  |  Branch (6891:50): [True: 3, False: 90.8k]
  ------------------
 6892|  90.8k|            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
  ------------------
  |  Branch (6892:43): [True: 4, False: 90.8k]
  ------------------
 6893|  90.8k|            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
  ------------------
  |  Branch (6893:43): [True: 7, False: 90.8k]
  ------------------
 6894|       |            //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
 6895|  90.8k|            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
  ------------------
  |  Branch (6895:34): [True: 0, False: 90.8k]
  |  Branch (6895:89): [True: 324, False: 90.5k]
  |  Branch (6895:148): [True: 324, False: 0]
  ------------------
 6896|  90.8k|            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
  ------------------
  |  Branch (6896:34): [True: 323, False: 90.5k]
  |  Branch (6896:91): [True: 64, False: 90.4k]
  |  Branch (6896:149): [True: 64, False: 90.4k]
  |  Branch (6896:202): [True: 64, False: 0]
  |  Branch (6896:245): [True: 0, False: 64]
  ------------------
 6897|  90.8k|            if (window->ScrollbarX && !window->ScrollbarY)
  ------------------
  |  Branch (6897:17): [True: 323, False: 90.5k]
  |  Branch (6897:39): [True: 63, False: 260]
  ------------------
 6898|     63|                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar);
  ------------------
  |  Branch (6898:38): [True: 0, False: 63]
  |  Branch (6898:97): [True: 0, False: 0]
  ------------------
 6899|  90.8k|            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
  ------------------
  |  Branch (6899:45): [True: 324, False: 90.5k]
  |  Branch (6899:94): [True: 323, False: 90.5k]
  ------------------
 6900|       |
 6901|       |            // Amend the partially filled window->DecorationXXX values.
 6902|  90.8k|            window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
 6903|  90.8k|            window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
 6904|  90.8k|        }
 6905|       |
 6906|       |        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
 6907|       |        // Update various regions. Variables they depend on should be set above in this function.
 6908|       |        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.
 6909|       |
 6910|       |        // Outer rectangle
 6911|       |        // Not affected by window border size. Used by:
 6912|       |        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
 6913|       |        // - Begin() initial clipping rect for drawing window background and borders.
 6914|       |        // - Begin() clipping whole child
 6915|   180k|        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
  ------------------
  |  Branch (6915:35): [True: 323, False: 180k]
  |  Branch (6915:77): [True: 323, False: 0]
  |  Branch (6915:114): [True: 323, False: 0]
  ------------------
 6916|   180k|        const ImRect outer_rect = window->Rect();
 6917|   180k|        const ImRect title_bar_rect = window->TitleBarRect();
 6918|   180k|        window->OuterRectClipped = outer_rect;
 6919|   180k|        if (window->DockIsActive)
  ------------------
  |  Branch (6919:13): [True: 0, False: 180k]
  ------------------
 6920|      0|            window->OuterRectClipped.Min.y += window->TitleBarHeight();
 6921|   180k|        window->OuterRectClipped.ClipWith(host_rect);
 6922|       |
 6923|       |        // Inner rectangle
 6924|       |        // Not affected by window border size. Used by:
 6925|       |        // - InnerClipRect
 6926|       |        // - ScrollToRectEx()
 6927|       |        // - NavUpdatePageUpPageDown()
 6928|       |        // - Scrollbar()
 6929|   180k|        window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
 6930|   180k|        window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
 6931|   180k|        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
 6932|   180k|        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;
 6933|       |
 6934|       |        // Inner clipping rectangle.
 6935|       |        // Will extend a little bit outside the normal work region.
 6936|       |        // This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
 6937|       |        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
 6938|       |        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
 6939|       |        // Affected by window/frame border size. Used by:
 6940|       |        // - Begin() initial clip rect
 6941|   180k|        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
  ------------------
  |  Branch (6941:35): [True: 0, False: 180k]
  |  Branch (6941:73): [True: 180k, False: 323]
  ------------------
 6942|   180k|        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
 6943|   180k|        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
 6944|   180k|        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
 6945|   180k|        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
 6946|   180k|        window->InnerClipRect.ClipWithFull(host_rect);
 6947|       |
 6948|       |        // Default item width. Make it proportional to window size if window manually resizes
 6949|   180k|        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
  ------------------
  |  Branch (6949:13): [True: 180k, False: 121]
  |  Branch (6949:38): [True: 180k, False: 0]
  |  Branch (6949:77): [True: 180k, False: 0]
  ------------------
 6950|   180k|            window->ItemWidthDefault = ImFloor(window->Size.x * 0.65f);
 6951|    121|        else
 6952|    121|            window->ItemWidthDefault = ImFloor(g.FontSize * 16.0f);
 6953|       |
 6954|       |        // SCROLLING
 6955|       |
 6956|       |        // Lock down maximum scrolling
 6957|       |        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
 6958|       |        // for right/bottom aligned items without creating a scrollbar.
 6959|   180k|        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
 6960|   180k|        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());
 6961|       |
 6962|       |        // Apply scrolling
 6963|   180k|        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
 6964|   180k|        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 6965|   180k|        window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;
 6966|       |
 6967|       |        // DRAWING
 6968|       |
 6969|       |        // Setup draw list and outer clipping rectangle
 6970|   180k|        IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6971|   180k|        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
 6972|   180k|        PushClipRect(host_rect.Min, host_rect.Max, false);
 6973|       |
 6974|       |        // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
 6975|       |        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
 6976|       |        // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
 6977|   180k|        const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
  ------------------
  |  Branch (6977:52): [True: 180k, False: 0]
  |  Branch (6977:77): [True: 0, False: 0]
  ------------------
 6978|   180k|        if (is_undocked_or_docked_visible)
  ------------------
  |  Branch (6978:13): [True: 180k, False: 0]
  ------------------
 6979|   180k|        {
 6980|   180k|            bool render_decorations_in_parent = false;
 6981|   180k|            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
  ------------------
  |  Branch (6981:17): [True: 323, False: 180k]
  |  Branch (6981:59): [True: 323, False: 0]
  |  Branch (6981:96): [True: 323, False: 0]
  ------------------
 6982|    323|            {
 6983|       |                // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
 6984|       |                // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
 6985|    323|                ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
  ------------------
  |  Branch (6985:47): [True: 0, False: 323]
  ------------------
 6986|    323|                bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
  ------------------
  |  Branch (6986:51): [True: 0, False: 323]
  ------------------
 6987|    323|                bool parent_is_empty = parent_window->DrawList->VtxBuffer.Size > 0;
 6988|    323|                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && parent_is_empty && !previous_child_overlapping)
  ------------------
  |  Branch (6988:21): [True: 323, False: 0]
  |  Branch (6988:74): [True: 323, False: 0]
  |  Branch (6988:93): [True: 323, False: 0]
  ------------------
 6989|    323|                    render_decorations_in_parent = true;
 6990|    323|            }
 6991|   180k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (6991:17): [True: 323, False: 180k]
  ------------------
 6992|    323|                window->DrawList = parent_window->DrawList;
 6993|       |
 6994|       |            // Handle title bar, scrollbar, resize grips and resize borders
 6995|   180k|            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
  ------------------
  |  Branch (6995:54): [True: 0, False: 180k]
  ------------------
 6996|   180k|            const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
  ------------------
  |  Branch (6996:49): [True: 2, False: 180k]
  |  Branch (6996:64): [True: 1.12k, False: 179k]
  |  Branch (6996:88): [True: 678, False: 449]
  |  Branch (6996:186): [True: 0, False: 449]
  |  Branch (6996:206): [True: 0, False: 0]
  ------------------
 6997|   180k|            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);
 6998|       |
 6999|   180k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (6999:17): [True: 323, False: 180k]
  ------------------
 7000|    323|                window->DrawList = &window->DrawListInst;
 7001|   180k|        }
 7002|       |
 7003|       |        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)
 7004|       |
 7005|       |        // Work rectangle.
 7006|       |        // Affected by window padding and border size. Used by:
 7007|       |        // - Columns() for right-most edge
 7008|       |        // - TreeNode(), CollapsingHeader() for right-most edge
 7009|       |        // - BeginTabBar() for right-most edge
 7010|   180k|        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
  ------------------
  |  Branch (7010:40): [True: 180k, False: 0]
  |  Branch (7010:83): [True: 323, False: 180k]
  ------------------
 7011|   180k|        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
 7012|   180k|        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (7012:41): [True: 0, False: 180k]
  |  Branch (7012:119): [True: 323, False: 180k]
  ------------------
 7013|   180k|        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (7013:41): [True: 0, False: 180k]
  |  Branch (7013:119): [True: 180k, False: 0]
  ------------------
 7014|   180k|        window->WorkRect.Min.x = ImFloor(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
 7015|   180k|        window->WorkRect.Min.y = ImFloor(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
 7016|   180k|        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
 7017|   180k|        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
 7018|   180k|        window->ParentWorkRect = window->WorkRect;
 7019|       |
 7020|       |        // [LEGACY] Content Region
 7021|       |        // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
 7022|       |        // Used by:
 7023|       |        // - Mouse wheel scrolling + many other things
 7024|   180k|        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
 7025|   180k|        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
 7026|   180k|        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (7026:78): [True: 0, False: 180k]
  ------------------
 7027|   180k|        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (7027:78): [True: 0, False: 180k]
  ------------------
 7028|       |
 7029|       |        // Setup drawing context
 7030|       |        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
 7031|   180k|        window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
 7032|   180k|        window->DC.GroupOffset.x = 0.0f;
 7033|   180k|        window->DC.ColumnsOffset.x = 0.0f;
 7034|       |
 7035|       |        // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
 7036|       |        // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
 7037|   180k|        double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
 7038|   180k|        double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
 7039|   180k|        window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
 7040|   180k|        window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
 7041|   180k|        window->DC.CursorPos = window->DC.CursorStartPos;
 7042|   180k|        window->DC.CursorPosPrevLine = window->DC.CursorPos;
 7043|   180k|        window->DC.CursorMaxPos = window->DC.CursorStartPos;
 7044|   180k|        window->DC.IdealMaxPos = window->DC.CursorStartPos;
 7045|   180k|        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
 7046|   180k|        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
 7047|   180k|        window->DC.IsSameLine = window->DC.IsSetPos = false;
 7048|       |
 7049|   180k|        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 7050|   180k|        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
 7051|   180k|        window->DC.NavLayersActiveMaskNext = 0x00;
 7052|   180k|        window->DC.NavHideHighlightOneFrame = false;
 7053|   180k|        window->DC.NavHasScroll = (window->ScrollMax.y > 0.0f);
 7054|       |
 7055|   180k|        window->DC.MenuBarAppending = false;
 7056|   180k|        window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
 7057|   180k|        window->DC.TreeDepth = 0;
 7058|   180k|        window->DC.TreeJumpToParentOnPopMask = 0x00;
 7059|   180k|        window->DC.ChildWindows.resize(0);
 7060|   180k|        window->DC.StateStorage = &window->StateStorage;
 7061|   180k|        window->DC.CurrentColumns = NULL;
 7062|   180k|        window->DC.LayoutType = ImGuiLayoutType_Vertical;
 7063|   180k|        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
  ------------------
  |  Branch (7063:39): [True: 323, False: 180k]
  ------------------
 7064|       |
 7065|   180k|        window->DC.ItemWidth = window->ItemWidthDefault;
 7066|   180k|        window->DC.TextWrapPos = -1.0f; // disabled
 7067|   180k|        window->DC.ItemWidthStack.resize(0);
 7068|   180k|        window->DC.TextWrapPosStack.resize(0);
 7069|       |
 7070|   180k|        if (window->AutoFitFramesX > 0)
  ------------------
  |  Branch (7070:13): [True: 2, False: 180k]
  ------------------
 7071|      2|            window->AutoFitFramesX--;
 7072|   180k|        if (window->AutoFitFramesY > 0)
  ------------------
  |  Branch (7072:13): [True: 2, False: 180k]
  ------------------
 7073|      2|            window->AutoFitFramesY--;
 7074|       |
 7075|       |        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
 7076|   180k|        if (want_focus)
  ------------------
  |  Branch (7076:13): [True: 2, False: 180k]
  ------------------
 7077|      2|        {
 7078|      2|            FocusWindow(window);
 7079|      2|            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
 7080|      2|        }
 7081|       |
 7082|       |        // Close requested by platform window
 7083|   180k|        if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
  ------------------
  |  Branch (7083:13): [True: 0, False: 180k]
  |  Branch (7083:31): [True: 0, False: 0]
  |  Branch (7083:73): [True: 0, False: 0]
  ------------------
 7084|      0|        {
 7085|      0|            if (!window->DockIsActive || window->DockTabIsVisible)
  ------------------
  |  Branch (7085:17): [True: 0, False: 0]
  |  Branch (7085:42): [True: 0, False: 0]
  ------------------
 7086|      0|            {
 7087|      0|                window->Viewport->PlatformRequestClose = false;
 7088|      0|                g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue.
 7089|      0|                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' PlatformRequestClose\n", window->Name);
  ------------------
  |  |  236|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (236:50): [True: 0, False: 0]
  |  |  |  Branch (236:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7090|      0|                *p_open = false;
 7091|      0|            }
 7092|      0|        }
 7093|       |
 7094|       |        // Title bar
 7095|   180k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (7095:13): [True: 180k, False: 323]
  |  Branch (7095:55): [True: 180k, False: 0]
  ------------------
 7096|   180k|            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);
 7097|       |
 7098|       |        // Clear hit test shape every frame
 7099|   180k|        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
 7100|       |
 7101|       |        // Pressing CTRL+C while holding on a window copy its content to the clipboard
 7102|       |        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
 7103|       |        // Maybe we can support CTRL+C on every element?
 7104|       |        /*
 7105|       |        //if (g.NavWindow == window && g.ActiveId == 0)
 7106|       |        if (g.ActiveId == window->MoveId)
 7107|       |            if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
 7108|       |                LogToClipboard();
 7109|       |        */
 7110|       |
 7111|   180k|        if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
  ------------------
  |  Branch (7111:13): [True: 180k, False: 0]
  ------------------
 7112|   180k|        {
 7113|       |            // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
 7114|       |            // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
 7115|   180k|            if ((g.MovingWindow == window) && (g.IO.ConfigDockingWithShift == g.IO.KeyShift))
  ------------------
  |  Branch (7115:17): [True: 163, False: 180k]
  |  Branch (7115:47): [True: 163, False: 0]
  ------------------
 7116|    163|                if ((window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
  ------------------
  |  Branch (7116:21): [True: 163, False: 0]
  ------------------
 7117|    163|                    BeginDockableDragDropSource(window);
 7118|       |
 7119|       |            // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
 7120|   180k|            if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
  ------------------
  |  Branch (7120:17): [True: 129, False: 180k]
  |  Branch (7120:37): [True: 105, False: 24]
  ------------------
 7121|    105|                if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
  ------------------
  |  Branch (7121:21): [True: 26, False: 79]
  |  Branch (7121:47): [True: 36, False: 43]
  ------------------
 7122|     62|                    if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (7122:25): [True: 62, False: 0]
  |  Branch (7122:67): [True: 62, False: 0]
  ------------------
 7123|     62|                        BeginDockableDragDropTarget(window);
 7124|   180k|        }
 7125|       |
 7126|       |        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
 7127|       |        // This is useful to allow creating context menus on title bar only, etc.
 7128|   180k|        if (window->DockIsActive)
  ------------------
  |  Branch (7128:13): [True: 0, False: 180k]
  ------------------
 7129|      0|            SetLastItemData(window->MoveId, g.CurrentItemFlags, window->DockTabItemStatusFlags, window->DockTabItemRect);
 7130|   180k|        else
 7131|   180k|            SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, title_bar_rect);
  ------------------
  |  Branch (7131:65): [True: 4.96k, False: 175k]
  ------------------
 7132|       |
 7133|       |        // [DEBUG]
 7134|   180k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 7135|   180k|        if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
  ------------------
  |  Branch (7135:13): [True: 0, False: 180k]
  |  Branch (7135:38): [True: 0, False: 0]
  |  Branch (7135:71): [True: 0, False: 0]
  ------------------
 7136|      0|            DebugLocateItemResolveWithLastItem();
 7137|   180k|#endif
 7138|       |
 7139|       |        // [Test Engine] Register title bar / tab
 7140|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 7141|       |        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
 7142|       |            IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.Rect, g.LastItemData.ID);
 7143|       |#endif
 7144|   180k|    }
 7145|      0|    else
 7146|      0|    {
 7147|       |        // Append
 7148|      0|        SetCurrentViewport(window, window->Viewport);
 7149|      0|        SetCurrentWindow(window);
 7150|      0|    }
 7151|       |
 7152|   180k|    if (!(flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (7152:9): [True: 180k, False: 0]
  ------------------
 7153|   180k|        PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);
 7154|       |
 7155|       |    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
 7156|   180k|    window->WriteAccessed = false;
 7157|   180k|    window->BeginCount++;
 7158|   180k|    g.NextWindowData.ClearFlags();
 7159|       |
 7160|       |    // Update visibility
 7161|   180k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (7161:9): [True: 180k, False: 0]
  ------------------
 7162|   180k|    {
 7163|       |        // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
 7164|       |        // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
 7165|       |        // This is analogous to regular windows being hidden from one frame.
 7166|       |        // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
 7167|   180k|        if (window->DockIsActive && !window->DockTabIsVisible)
  ------------------
  |  Branch (7167:13): [True: 0, False: 180k]
  |  Branch (7167:37): [True: 0, False: 0]
  ------------------
 7168|      0|        {
 7169|      0|            if (window->LastFrameJustFocused == g.FrameCount)
  ------------------
  |  Branch (7169:17): [True: 0, False: 0]
  ------------------
 7170|      0|                window->HiddenFramesCannotSkipItems = 1;
 7171|      0|            else
 7172|      0|                window->HiddenFramesCanSkipItems = 1;
 7173|      0|        }
 7174|       |
 7175|   180k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (7175:13): [True: 323, False: 180k]
  ------------------
 7176|    323|        {
 7177|       |            // Child window can be out of sight and have "negative" clip windows.
 7178|       |            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
 7179|    323|            IM_ASSERT((flags& ImGuiWindowFlags_NoTitleBar) != 0 || (window->DockIsActive));
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7180|    323|            if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0) // FIXME: Doesn't make sense for ChildWindow??
  ------------------
  |  Branch (7180:17): [True: 323, False: 0]
  |  Branch (7180:65): [True: 323, False: 0]
  |  Branch (7180:96): [True: 323, False: 0]
  ------------------
 7181|    323|            {
 7182|    323|                const bool nav_request = (flags & ImGuiWindowFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
  ------------------
  |  Branch (7182:42): [True: 0, False: 323]
  |  Branch (7182:86): [True: 0, False: 0]
  |  Branch (7182:105): [True: 0, False: 0]
  |  Branch (7182:120): [True: 0, False: 0]
  ------------------
 7183|    323|                if (!g.LogEnabled && !nav_request)
  ------------------
  |  Branch (7183:21): [True: 323, False: 0]
  |  Branch (7183:38): [True: 323, False: 0]
  ------------------
 7184|    323|                    if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
  ------------------
  |  Branch (7184:25): [True: 0, False: 323]
  |  Branch (7184:93): [True: 0, False: 323]
  ------------------
 7185|      0|                        window->HiddenFramesCanSkipItems = 1;
 7186|    323|            }
 7187|       |
 7188|       |            // Hide along with parent or if parent is collapsed
 7189|    323|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
  ------------------
  |  Branch (7189:17): [True: 323, False: 0]
  |  Branch (7189:35): [True: 0, False: 323]
  |  Branch (7189:63): [True: 0, False: 323]
  ------------------
 7190|      0|                window->HiddenFramesCanSkipItems = 1;
 7191|    323|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
  ------------------
  |  Branch (7191:17): [True: 323, False: 0]
  |  Branch (7191:35): [True: 0, False: 323]
  |  Branch (7191:63): [True: 1, False: 322]
  ------------------
 7192|      1|                window->HiddenFramesCannotSkipItems = 1;
 7193|    323|        }
 7194|       |
 7195|       |        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
 7196|   180k|        if (style.Alpha <= 0.0f)
  ------------------
  |  Branch (7196:13): [True: 0, False: 180k]
  ------------------
 7197|      0|            window->HiddenFramesCanSkipItems = 1;
 7198|       |
 7199|       |        // Update the Hidden flag
 7200|   180k|        bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
  ------------------
  |  Branch (7200:31): [True: 0, False: 180k]
  |  Branch (7200:73): [True: 2, False: 180k]
  ------------------
 7201|   180k|        window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);
  ------------------
  |  Branch (7201:26): [True: 2, False: 180k]
  |  Branch (7201:44): [True: 0, False: 180k]
  ------------------
 7202|       |
 7203|       |        // Disable inputs for requested number of frames
 7204|   180k|        if (window->DisableInputsFrames > 0)
  ------------------
  |  Branch (7204:13): [True: 0, False: 180k]
  ------------------
 7205|      0|        {
 7206|      0|            window->DisableInputsFrames--;
 7207|      0|            window->Flags |= ImGuiWindowFlags_NoInputs;
 7208|      0|        }
 7209|       |
 7210|       |        // Update the SkipItems flag, used to early out of all items functions (no layout required)
 7211|   180k|        bool skip_items = false;
 7212|   180k|        if (window->Collapsed || !window->Active || hidden_regular)
  ------------------
  |  Branch (7212:13): [True: 89.9k, False: 90.8k]
  |  Branch (7212:34): [True: 0, False: 90.8k]
  |  Branch (7212:53): [True: 2, False: 90.8k]
  ------------------
 7213|  89.9k|            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
  ------------------
  |  Branch (7213:17): [True: 89.9k, False: 1]
  |  Branch (7213:48): [True: 89.9k, False: 0]
  |  Branch (7213:79): [True: 89.9k, False: 1]
  ------------------
 7214|  89.9k|                skip_items = true;
 7215|   180k|        window->SkipItems = skip_items;
 7216|       |
 7217|       |        // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
 7218|   180k|        if (window->SkipItems)
  ------------------
  |  Branch (7218:13): [True: 89.9k, False: 90.8k]
  ------------------
 7219|  89.9k|            window->DC.NavLayersActiveMaskNext = window->DC.NavLayersActiveMask;
 7220|       |
 7221|       |        // Sanity check: there are two spots which can set Appearing = true
 7222|       |        // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
 7223|       |        // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
 7224|   180k|        if (window->SkipItems && !window->Appearing)
  ------------------
  |  Branch (7224:13): [True: 89.9k, False: 90.8k]
  |  Branch (7224:34): [True: 89.9k, False: 0]
  ------------------
 7225|   180k|            IM_ASSERT(window->Appearing == false); // Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7226|   180k|    }
 7227|       |
 7228|   180k|    return !window->SkipItems;
 7229|   180k|}
_ZN5ImGui3EndEv:
 7232|   180k|{
 7233|   180k|    ImGuiContext& g = *GImGui;
 7234|   180k|    ImGuiWindow* window = g.CurrentWindow;
 7235|       |
 7236|       |    // Error checking: verify that user hasn't called End() too many times!
 7237|   180k|    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
  ------------------
  |  Branch (7237:9): [True: 90.2k, False: 90.5k]
  |  Branch (7237:43): [True: 0, False: 90.2k]
  ------------------
 7238|      0|    {
 7239|      0|        IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
  ------------------
  |  |  253|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7240|      0|        return;
 7241|      0|    }
 7242|   180k|    IM_ASSERT(g.CurrentWindowStack.Size > 0);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7243|       |
 7244|       |    // Error checking: verify that user doesn't directly call End() on a child window.
 7245|   180k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
  ------------------
  |  Branch (7245:9): [True: 323, False: 180k]
  |  Branch (7245:59): [True: 323, False: 0]
  |  Branch (7245:111): [True: 323, False: 0]
  ------------------
 7246|   180k|        IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");
  ------------------
  |  |  253|   180k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7247|       |
 7248|       |    // Close anything that is open
 7249|   180k|    if (window->DC.CurrentColumns)
  ------------------
  |  Branch (7249:9): [True: 0, False: 180k]
  ------------------
 7250|      0|        EndColumns();
 7251|   180k|    if (!(window->Flags & ImGuiWindowFlags_DockNodeHost))   // Pop inner window clip rectangle
  ------------------
  |  Branch (7251:9): [True: 180k, False: 0]
  ------------------
 7252|   180k|        PopClipRect();
 7253|   180k|    PopFocusScope();
 7254|       |
 7255|       |    // Stop logging
 7256|   180k|    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
  ------------------
  |  Branch (7256:9): [True: 180k, False: 323]
  ------------------
 7257|   180k|        LogFinish();
 7258|       |
 7259|   180k|    if (window->DC.IsSetPos)
  ------------------
  |  Branch (7259:9): [True: 0, False: 180k]
  ------------------
 7260|      0|        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
 7261|       |
 7262|       |    // Docking: report contents sizes to parent to allow for auto-resize
 7263|   180k|    if (window->DockNode && window->DockTabIsVisible)
  ------------------
  |  Branch (7263:9): [True: 0, False: 180k]
  |  Branch (7263:29): [True: 0, False: 0]
  ------------------
 7264|      0|        if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
  ------------------
  |  Branch (7264:26): [True: 0, False: 0]
  ------------------
 7265|      0|            host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;
 7266|       |
 7267|       |    // Pop from window stack
 7268|   180k|    g.LastItemData = g.CurrentWindowStack.back().ParentLastItemDataBackup;
 7269|   180k|    if (window->Flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (7269:9): [True: 0, False: 180k]
  ------------------
 7270|      0|        g.BeginMenuCount--;
 7271|   180k|    if (window->Flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (7271:9): [True: 0, False: 180k]
  ------------------
 7272|      0|        g.BeginPopupStack.pop_back();
 7273|   180k|    g.CurrentWindowStack.back().StackSizesOnBegin.CompareWithCurrentState();
 7274|   180k|    g.CurrentWindowStack.pop_back();
 7275|   180k|    SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
  ------------------
  |  Branch (7275:22): [True: 90.2k, False: 90.5k]
  ------------------
 7276|   180k|    if (g.CurrentWindow)
  ------------------
  |  Branch (7276:9): [True: 90.5k, False: 90.2k]
  ------------------
 7277|  90.5k|        SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
 7278|   180k|}
_ZN5ImGui23BringWindowToFocusFrontEP11ImGuiWindow:
 7281|    295|{
 7282|    295|    ImGuiContext& g = *GImGui;
 7283|    295|    IM_ASSERT(window == window->RootWindow);
  ------------------
  |  |   23|    295|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7284|       |
 7285|    295|    const int cur_order = window->FocusOrder;
 7286|    295|    IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
  ------------------
  |  |   23|    295|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7287|    295|    if (g.WindowsFocusOrder.back() == window)
  ------------------
  |  Branch (7287:9): [True: 295, False: 0]
  ------------------
 7288|    295|        return;
 7289|       |
 7290|      0|    const int new_order = g.WindowsFocusOrder.Size - 1;
 7291|      0|    for (int n = cur_order; n < new_order; n++)
  ------------------
  |  Branch (7291:29): [True: 0, False: 0]
  ------------------
 7292|      0|    {
 7293|      0|        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
 7294|      0|        g.WindowsFocusOrder[n]->FocusOrder--;
 7295|      0|        IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7296|      0|    }
 7297|      0|    g.WindowsFocusOrder[new_order] = window;
 7298|      0|    window->FocusOrder = (short)new_order;
 7299|      0|}
_ZN5ImGui25BringWindowToDisplayFrontEP11ImGuiWindow:
 7302|    295|{
 7303|    295|    ImGuiContext& g = *GImGui;
 7304|    295|    ImGuiWindow* current_front_window = g.Windows.back();
 7305|    295|    if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
  ------------------
  |  Branch (7305:9): [True: 2, False: 293]
  |  Branch (7305:43): [True: 293, False: 0]
  ------------------
 7306|    295|        return;
 7307|      0|    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
  ------------------
  |  Branch (7307:38): [True: 0, False: 0]
  ------------------
 7308|      0|        if (g.Windows[i] == window)
  ------------------
  |  Branch (7308:13): [True: 0, False: 0]
  ------------------
 7309|      0|        {
 7310|      0|            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
 7311|      0|            g.Windows[g.Windows.Size - 1] = window;
 7312|      0|            break;
 7313|      0|        }
 7314|      0|}
_ZN5ImGui11FocusWindowEP11ImGuiWindow:
 7360|  9.64k|{
 7361|  9.64k|    ImGuiContext& g = *GImGui;
 7362|       |
 7363|  9.64k|    if (g.NavWindow != window)
  ------------------
  |  Branch (7363:9): [True: 125, False: 9.51k]
  ------------------
 7364|    125|    {
 7365|    125|        SetNavWindow(window);
 7366|    125|        if (window && g.NavDisableMouseHover)
  ------------------
  |  Branch (7366:13): [True: 57, False: 68]
  |  Branch (7366:23): [True: 2, False: 55]
  ------------------
 7367|      2|            g.NavMousePosDirty = true;
 7368|    125|        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
  ------------------
  |  Branch (7368:19): [True: 57, False: 68]
  ------------------
 7369|    125|        g.NavLayer = ImGuiNavLayer_Main;
 7370|    125|        g.NavFocusScopeId = window ? window->NavRootFocusScopeId : 0;
  ------------------
  |  Branch (7370:29): [True: 57, False: 68]
  ------------------
 7371|    125|        g.NavIdIsAlive = false;
 7372|       |
 7373|       |        // Close popups if any
 7374|    125|        ClosePopupsOverWindow(window, false);
 7375|    125|    }
 7376|       |
 7377|       |    // Move the root window to the top of the pile
 7378|  9.64k|    IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
  ------------------
  |  |   23|  9.64k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7379|  9.64k|    ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
  ------------------
  |  Branch (7379:39): [True: 295, False: 9.34k]
  ------------------
 7380|  9.64k|    ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
  ------------------
  |  Branch (7380:41): [True: 295, False: 9.34k]
  ------------------
 7381|  9.64k|    ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
  ------------------
  |  Branch (7381:32): [True: 295, False: 9.34k]
  ------------------
 7382|  9.64k|    bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);
  ------------------
  |  Branch (7382:48): [True: 233, False: 9.40k]
  |  Branch (7382:68): [True: 0, False: 233]
  |  Branch (7382:81): [True: 0, False: 0]
  ------------------
 7383|       |
 7384|       |    // Steal active widgets. Some of the cases it triggers includes:
 7385|       |    // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
 7386|       |    // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
 7387|       |    // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
 7388|  9.64k|    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
  ------------------
  |  Branch (7388:9): [True: 233, False: 9.40k]
  |  Branch (7388:28): [True: 233, False: 0]
  |  Branch (7388:48): [True: 42, False: 191]
  ------------------
 7389|     42|        if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
  ------------------
  |  Branch (7389:13): [True: 14, False: 28]
  |  Branch (7389:46): [True: 14, False: 0]
  ------------------
 7390|     14|            ClearActiveID();
 7391|       |
 7392|       |    // Passing NULL allow to disable keyboard focus
 7393|  9.64k|    if (!window)
  ------------------
  |  Branch (7393:9): [True: 9.34k, False: 295]
  ------------------
 7394|  9.34k|        return;
 7395|    295|    window->LastFrameJustFocused = g.FrameCount;
 7396|       |
 7397|       |    // Select in dock node
 7398|    295|    if (dock_node && dock_node->TabBar)
  ------------------
  |  Branch (7398:9): [True: 0, False: 295]
  |  Branch (7398:22): [True: 0, False: 0]
  ------------------
 7399|      0|        dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;
 7400|       |
 7401|       |    // Bring to front
 7402|    295|    BringWindowToFocusFront(focus_front_window);
 7403|    295|    if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
  ------------------
  |  Branch (7403:9): [True: 295, False: 0]
  ------------------
 7404|    295|        BringWindowToDisplayFront(display_front_window);
 7405|    295|}
_ZN5ImGui14SetCurrentFontEP6ImFont:
 7444|  90.2k|{
 7445|  90.2k|    ImGuiContext& g = *GImGui;
 7446|  90.2k|    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7447|  90.2k|    IM_ASSERT(font->Scale > 0.0f);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7448|  90.2k|    g.Font = font;
 7449|  90.2k|    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
 7450|  90.2k|    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
  ------------------
  |  Branch (7450:18): [True: 0, False: 90.2k]
  ------------------
 7451|       |
 7452|  90.2k|    ImFontAtlas* atlas = g.Font->ContainerAtlas;
 7453|  90.2k|    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
 7454|  90.2k|    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
 7455|  90.2k|    g.DrawListSharedData.Font = g.Font;
 7456|  90.2k|    g.DrawListSharedData.FontSize = g.FontSize;
 7457|  90.2k|}
_ZN5ImGui12PushItemFlagEib:
 7478|    323|{
 7479|    323|    ImGuiContext& g = *GImGui;
 7480|    323|    ImGuiItemFlags item_flags = g.CurrentItemFlags;
 7481|    323|    IM_ASSERT(item_flags == g.ItemFlagsStack.back());
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7482|    323|    if (enabled)
  ------------------
  |  Branch (7482:9): [True: 0, False: 323]
  ------------------
 7483|      0|        item_flags |= option;
 7484|    323|    else
 7485|    323|        item_flags &= ~option;
 7486|    323|    g.CurrentItemFlags = item_flags;
 7487|    323|    g.ItemFlagsStack.push_back(item_flags);
 7488|    323|}
_ZN5ImGui11PopItemFlagEv:
 7491|    323|{
 7492|    323|    ImGuiContext& g = *GImGui;
 7493|    323|    IM_ASSERT(g.ItemFlagsStack.Size > 1); // Too many calls to PopItemFlag() - we always leave a 0 at the bottom of the stack.
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7494|    323|    g.ItemFlagsStack.pop_back();
 7495|    323|    g.CurrentItemFlags = g.ItemFlagsStack.back();
 7496|    323|}
_ZN5ImGui22PushAllowKeyboardFocusEb:
 7534|    323|{
 7535|    323|    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);
 7536|    323|}
_ZN5ImGui21PopAllowKeyboardFocusEv:
 7539|    323|{
 7540|    323|    PopItemFlag();
 7541|    323|}
_ZN5ImGui15IsWindowHoveredEi:
 7632|    514|{
 7633|    514|    IM_ASSERT((flags & (ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_AllowWhenDisabled)) == 0);   // Flags not supported by this function
  ------------------
  |  |   23|    514|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7634|    514|    ImGuiContext& g = *GImGui;
 7635|    514|    ImGuiWindow* ref_window = g.HoveredWindow;
 7636|    514|    ImGuiWindow* cur_window = g.CurrentWindow;
 7637|    514|    if (ref_window == NULL)
  ------------------
  |  Branch (7637:9): [True: 456, False: 58]
  ------------------
 7638|    456|        return false;
 7639|       |
 7640|     58|    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
  ------------------
  |  Branch (7640:9): [True: 58, False: 0]
  ------------------
 7641|     58|    {
 7642|     58|        IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|     58|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7643|     58|        const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
 7644|     58|        const bool dock_hierarchy = (flags & ImGuiHoveredFlags_DockHierarchy) != 0;
 7645|     58|        if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (7645:13): [True: 0, False: 58]
  ------------------
 7646|      0|            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 7647|       |
 7648|     58|        bool result;
 7649|     58|        if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (7649:13): [True: 0, False: 58]
  ------------------
 7650|      0|            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 7651|     58|        else
 7652|     58|            result = (ref_window == cur_window);
 7653|     58|        if (!result)
  ------------------
  |  Branch (7653:13): [True: 58, False: 0]
  ------------------
 7654|     58|            return false;
 7655|     58|    }
 7656|       |
 7657|      0|    if (!IsWindowContentHoverable(ref_window, flags))
  ------------------
  |  Branch (7657:9): [True: 0, False: 0]
  ------------------
 7658|      0|        return false;
 7659|      0|    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (7659:9): [True: 0, False: 0]
  ------------------
 7660|      0|        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)
  ------------------
  |  Branch (7660:13): [True: 0, False: 0]
  |  Branch (7660:32): [True: 0, False: 0]
  |  Branch (7660:59): [True: 0, False: 0]
  ------------------
 7661|      0|            return false;
 7662|      0|    return true;
 7663|      0|}
_ZN5ImGui15IsWindowFocusedEi:
 7666|    643|{
 7667|    643|    ImGuiContext& g = *GImGui;
 7668|    643|    ImGuiWindow* ref_window = g.NavWindow;
 7669|    643|    ImGuiWindow* cur_window = g.CurrentWindow;
 7670|       |
 7671|    643|    if (ref_window == NULL)
  ------------------
  |  Branch (7671:9): [True: 186, False: 457]
  ------------------
 7672|    186|        return false;
 7673|    457|    if (flags & ImGuiFocusedFlags_AnyWindow)
  ------------------
  |  Branch (7673:9): [True: 0, False: 457]
  ------------------
 7674|      0|        return true;
 7675|       |
 7676|    457|    IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|    457|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7677|    457|    const bool popup_hierarchy = (flags & ImGuiFocusedFlags_NoPopupHierarchy) == 0;
 7678|    457|    const bool dock_hierarchy = (flags & ImGuiFocusedFlags_DockHierarchy) != 0;
 7679|    457|    if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (7679:9): [True: 0, False: 457]
  ------------------
 7680|      0|        cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 7681|       |
 7682|    457|    if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (7682:9): [True: 0, False: 457]
  ------------------
 7683|      0|        return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 7684|    457|    else
 7685|    457|        return (ref_window == cur_window);
 7686|    457|}
_ZN5ImGui14GetWindowWidthEv:
 7709|     91|{
 7710|     91|    ImGuiWindow* window = GImGui->CurrentWindow;
 7711|     91|    return window->Size.x;
 7712|     91|}
_ZN5ImGui15GetWindowHeightEv:
 7715|     91|{
 7716|     91|    ImGuiWindow* window = GImGui->CurrentWindow;
 7717|     91|    return window->Size.y;
 7718|     91|}
_ZN5ImGui12SetWindowPosEP11ImGuiWindowRK6ImVec2i:
 7728|    126|{
 7729|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 7730|    126|    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
  ------------------
  |  Branch (7730:9): [True: 126, False: 0]
  |  Branch (7730:17): [True: 0, False: 126]
  ------------------
 7731|      0|        return;
 7732|       |
 7733|    126|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|    126|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7734|    126|    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 7735|    126|    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);
 7736|       |
 7737|       |    // Set
 7738|    126|    const ImVec2 old_pos = window->Pos;
 7739|    126|    window->Pos = ImFloor(pos);
 7740|    126|    ImVec2 offset = window->Pos - old_pos;
 7741|    126|    if (offset.x == 0.0f && offset.y == 0.0f)
  ------------------
  |  Branch (7741:9): [True: 0, False: 126]
  |  Branch (7741:29): [True: 0, False: 0]
  ------------------
 7742|      0|        return;
 7743|    126|    MarkIniSettingsDirty(window);
 7744|       |    // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
 7745|    126|    window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
 7746|    126|    window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
 7747|    126|    window->DC.IdealMaxPos += offset;
 7748|    126|    window->DC.CursorStartPos += offset;
 7749|    126|}
_ZN5ImGui13SetWindowSizeEP11ImGuiWindowRK6ImVec2i:
 7770|  90.5k|{
 7771|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 7772|  90.5k|    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
  ------------------
  |  Branch (7772:9): [True: 90.5k, False: 0]
  |  Branch (7772:17): [True: 90.2k, False: 324]
  ------------------
 7773|  90.2k|        return;
 7774|       |
 7775|    324|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|    324|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7776|    324|    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 7777|       |
 7778|       |    // Set
 7779|    324|    ImVec2 old_size = window->SizeFull;
 7780|    324|    window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (7780:30): [True: 0, False: 324]
  ------------------
 7781|    324|    window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (7781:30): [True: 0, False: 324]
  ------------------
 7782|    324|    if (size.x <= 0.0f)
  ------------------
  |  Branch (7782:9): [True: 0, False: 324]
  ------------------
 7783|      0|        window->AutoFitOnlyGrows = false;
 7784|    324|    else
 7785|    324|        window->SizeFull.x = IM_FLOOR(size.x);
  ------------------
  |  |  269|    324|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 7786|    324|    if (size.y <= 0.0f)
  ------------------
  |  Branch (7786:9): [True: 0, False: 324]
  ------------------
 7787|      0|        window->AutoFitOnlyGrows = false;
 7788|    324|    else
 7789|    324|        window->SizeFull.y = IM_FLOOR(size.y);
  ------------------
  |  |  269|    324|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 7790|    324|    if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
  ------------------
  |  Branch (7790:9): [True: 77, False: 247]
  |  Branch (7790:45): [True: 78, False: 169]
  ------------------
 7791|    155|        MarkIniSettingsDirty(window);
 7792|    324|}
_ZN5ImGui14SetWindowFocusEv:
 7847|     91|{
 7848|     91|    FocusWindow(GImGui->CurrentWindow);
 7849|     91|}
_ZN5ImGui17SetNextWindowSizeERK6ImVec2i:
 7876|  90.5k|{
 7877|  90.5k|    ImGuiContext& g = *GImGui;
 7878|  90.5k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  90.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7879|  90.5k|    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
 7880|  90.5k|    g.NextWindowData.SizeVal = size;
 7881|  90.5k|    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
  ------------------
  |  Branch (7881:33): [True: 90.2k, False: 323]
  ------------------
 7882|  90.5k|}
_ZN5ImGui17GetWindowDrawListEv:
 7955|    323|{
 7956|    323|    ImGuiWindow* window = GetCurrentWindow();
 7957|    323|    return window->DrawList;
 7958|    323|}
_ZN5ImGui7GetFontEv:
 7974|  4.20k|{
 7975|  4.20k|    return GImGui->Font;
 7976|  4.20k|}
_ZN5ImGui11GetFontSizeEv:
 7979|  4.20k|{
 7980|  4.20k|    return GImGui->FontSize;
 7981|  4.20k|}
_ZN5ImGui14PushFocusScopeEj:
 8005|   180k|{
 8006|   180k|    ImGuiContext& g = *GImGui;
 8007|   180k|    g.FocusScopeStack.push_back(id);
 8008|   180k|    g.CurrentFocusScopeId = id;
 8009|   180k|}
_ZN5ImGui13PopFocusScopeEv:
 8012|   180k|{
 8013|   180k|    ImGuiContext& g = *GImGui;
 8014|   180k|    IM_ASSERT(g.FocusScopeStack.Size > 0); // Too many PopFocusScope() ?
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8015|   180k|    g.FocusScopeStack.pop_back();
 8016|   180k|    g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back() : 0;
  ------------------
  |  Branch (8016:29): [True: 90.5k, False: 90.2k]
  ------------------
 8017|   180k|}
_ZN5ImGui6PushIDEPKc:
 8084|    321|{
 8085|    321|    ImGuiContext& g = *GImGui;
 8086|    321|    ImGuiWindow* window = g.CurrentWindow;
 8087|    321|    ImGuiID id = window->GetID(str_id);
 8088|    321|    window->IDStack.push_back(id);
 8089|    321|}
_ZN5ImGui5PopIDEv:
 8147|    321|{
 8148|    321|    ImGuiWindow* window = GImGui->CurrentWindow;
 8149|    321|    IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
  ------------------
  |  |   23|    321|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8150|    321|    window->IDStack.pop_back();
 8151|    321|}
_ZN5ImGui10GetKeyDataE8ImGuiKey:
 8248|  2.17M|{
 8249|  2.17M|    ImGuiContext& g = *GImGui;
 8250|       |
 8251|       |    // Special storage location for mods
 8252|  2.17M|    if (key & ImGuiMod_Mask_)
  ------------------
  |  Branch (8252:9): [True: 812k, False: 1.36M]
  ------------------
 8253|   812k|        key = ConvertSingleModFlagToKey(key);
 8254|       |
 8255|  2.17M|    int index;
 8256|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 8257|       |    IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
 8258|       |    if (IsLegacyKey(key))
 8259|       |        index = (g.IO.KeyMap[key] != -1) ? g.IO.KeyMap[key] : key; // Remap native->imgui or imgui->native
 8260|       |    else
 8261|       |        index = key;
 8262|       |#else
 8263|  2.17M|    IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
  ------------------
  |  |   23|  2.17M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8264|  2.17M|    index = key - ImGuiKey_NamedKey_BEGIN;
 8265|  2.17M|#endif
 8266|  2.17M|    return &g.IO.KeysData[index];
 8267|  2.17M|}
_ZN5ImGui25CalcTypematicRepeatAmountEffff:
 8347|     20|{
 8348|     20|    if (t1 == 0.0f)
  ------------------
  |  Branch (8348:9): [True: 0, False: 20]
  ------------------
 8349|      0|        return 1;
 8350|     20|    if (t0 >= t1)
  ------------------
  |  Branch (8350:9): [True: 0, False: 20]
  ------------------
 8351|      0|        return 0;
 8352|     20|    if (repeat_rate <= 0.0f)
  ------------------
  |  Branch (8352:9): [True: 0, False: 20]
  ------------------
 8353|      0|        return (t0 < repeat_delay) && (t1 >= repeat_delay);
  ------------------
  |  Branch (8353:16): [True: 0, False: 0]
  |  Branch (8353:39): [True: 0, False: 0]
  ------------------
 8354|     20|    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (8354:26): [True: 4, False: 16]
  ------------------
 8355|     20|    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (8355:26): [True: 0, False: 20]
  ------------------
 8356|     20|    const int count = count_t1 - count_t0;
 8357|     20|    return count;
 8358|     20|}
_ZN5ImGui22GetTypematicRepeatRateEiPfS0_:
 8361|    203|{
 8362|    203|    ImGuiContext& g = *GImGui;
 8363|    203|    switch (flags & ImGuiInputFlags_RepeatRateMask_)
 8364|    203|    {
 8365|     73|    case ImGuiInputFlags_RepeatRateNavMove:             *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.80f; return;
  ------------------
  |  Branch (8365:5): [True: 73, False: 130]
  ------------------
 8366|      0|    case ImGuiInputFlags_RepeatRateNavTweak:            *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.30f; return;
  ------------------
  |  Branch (8366:5): [True: 0, False: 203]
  ------------------
 8367|    130|    case ImGuiInputFlags_RepeatRateDefault: default:    *repeat_delay = g.IO.KeyRepeatDelay * 1.00f; *repeat_rate = g.IO.KeyRepeatRate * 1.00f; return;
  ------------------
  |  Branch (8367:5): [True: 0, False: 203]
  |  Branch (8367:45): [True: 130, False: 73]
  ------------------
 8368|    203|    }
 8369|    203|}
_ZN5ImGui19GetKeyPressedAmountE8ImGuiKeyff:
 8374|     20|{
 8375|     20|    ImGuiContext& g = *GImGui;
 8376|     20|    const ImGuiKeyData* key_data = GetKeyData(key);
 8377|     20|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8377:9): [True: 0, False: 20]
  ------------------
 8378|      0|        return 0;
 8379|     20|    const float t = key_data->DownDuration;
 8380|     20|    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
 8381|     20|}
_ZN5ImGui18SetShortcutRoutingEiji:
 8530|   180k|{
 8531|   180k|    ImGuiContext& g = *GImGui;
 8532|   180k|    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
  ------------------
  |  Branch (8532:9): [True: 0, False: 180k]
  ------------------
 8533|      0|        flags |= ImGuiInputFlags_RouteGlobalHigh; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
 8534|   180k|    else
 8535|   180k|        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteMask_)); // Check that only 1 routing flag is used
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8536|       |
 8537|   180k|    if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
  ------------------
  |  Branch (8537:9): [True: 0, False: 180k]
  ------------------
 8538|      0|        if (g.NavWindow == NULL)
  ------------------
  |  Branch (8538:13): [True: 0, False: 0]
  ------------------
 8539|      0|            return false;
 8540|   180k|    if (flags & ImGuiInputFlags_RouteAlways)
  ------------------
  |  Branch (8540:9): [True: 180k, False: 0]
  ------------------
 8541|   180k|        return true;
 8542|       |
 8543|      0|    const int score = CalcRoutingScore(g.CurrentWindow, owner_id, flags);
 8544|      0|    if (score == 255)
  ------------------
  |  Branch (8544:9): [True: 0, False: 0]
  ------------------
 8545|      0|        return false;
 8546|       |
 8547|       |    // Submit routing for NEXT frame (assuming score is sufficient)
 8548|       |    // FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
 8549|      0|    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);
 8550|      0|    const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
 8551|       |    //const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
 8552|      0|    if (score < routing_data->RoutingNextScore)
  ------------------
  |  Branch (8552:9): [True: 0, False: 0]
  ------------------
 8553|      0|    {
 8554|      0|        routing_data->RoutingNext = routing_id;
 8555|      0|        routing_data->RoutingNextScore = (ImU8)score;
 8556|      0|    }
 8557|       |
 8558|       |    // Return routing state for CURRENT frame
 8559|      0|    return routing_data->RoutingCurr == routing_id;
 8560|      0|}
_ZN5ImGui9IsKeyDownE8ImGuiKey:
 8574|  1.35M|{
 8575|  1.35M|    return IsKeyDown(key, ImGuiKeyOwner_Any);
  ------------------
  |  | 1319|  1.35M|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
 8576|  1.35M|}
_ZN5ImGui9IsKeyDownE8ImGuiKeyj:
 8579|  1.35M|{
 8580|  1.35M|    const ImGuiKeyData* key_data = GetKeyData(key);
 8581|  1.35M|    if (!key_data->Down)
  ------------------
  |  Branch (8581:9): [True: 1.32M, False: 26.1k]
  ------------------
 8582|  1.32M|        return false;
 8583|  26.1k|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (8583:9): [True: 10, False: 26.1k]
  ------------------
 8584|     10|        return false;
 8585|  26.1k|    return true;
 8586|  26.1k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyb:
 8589|  2.56k|{
 8590|  2.56k|    return IsKeyPressed(key, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
  ------------------
  |  | 1319|  2.56k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8590:49): [True: 2.56k, False: 0]
  ------------------
 8591|  2.56k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyji:
 8595|   185k|{
 8596|   185k|    const ImGuiKeyData* key_data = GetKeyData(key);
 8597|   185k|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8597:9): [True: 180k, False: 5.15k]
  ------------------
 8598|   180k|        return false;
 8599|  5.15k|    const float t = key_data->DownDuration;
 8600|  5.15k|    if (t < 0.0f)
  ------------------
  |  Branch (8600:9): [True: 0, False: 5.15k]
  ------------------
 8601|      0|        return false;
 8602|  5.15k|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|  5.15k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8603|       |
 8604|  5.15k|    bool pressed = (t == 0.0f);
 8605|  5.15k|    if (!pressed && ((flags & ImGuiInputFlags_Repeat) != 0))
  ------------------
  |  Branch (8605:9): [True: 4.59k, False: 555]
  |  Branch (8605:21): [True: 203, False: 4.39k]
  ------------------
 8606|    203|    {
 8607|    203|        float repeat_delay, repeat_rate;
 8608|    203|        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
 8609|    203|        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
  ------------------
  |  Branch (8609:19): [True: 20, False: 183]
  |  Branch (8609:41): [True: 9, False: 11]
  ------------------
 8610|    203|    }
 8611|  5.15k|    if (!pressed)
  ------------------
  |  Branch (8611:9): [True: 4.58k, False: 564]
  ------------------
 8612|  4.58k|        return false;
 8613|    564|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (8613:9): [True: 0, False: 564]
  ------------------
 8614|      0|        return false;
 8615|    564|    return true;
 8616|    564|}
_ZN5ImGui11IsMouseDownEij:
 8641|    114|{
 8642|    114|    ImGuiContext& g = *GImGui;
 8643|    114|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    114|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8644|    114|    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
  ------------------
  |  Branch (8644:12): [True: 107, False: 7]
  |  Branch (8644:38): [True: 107, False: 0]
  ------------------
 8645|    114|}
_ZN5ImGui14IsMouseClickedEib:
 8648|      6|{
 8649|      6|    return IsMouseClicked(button, ImGuiKeyOwner_Any, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
  ------------------
  |  | 1319|      6|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (8649:54): [True: 0, False: 6]
  ------------------
 8650|      6|}
_ZN5ImGui14IsMouseClickedEiji:
 8653|    340|{
 8654|    340|    ImGuiContext& g = *GImGui;
 8655|    340|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    340|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8656|    340|    if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (8656:9): [True: 232, False: 108]
  ------------------
 8657|    232|        return false;
 8658|    108|    const float t = g.IO.MouseDownDuration[button];
 8659|    108|    if (t < 0.0f)
  ------------------
  |  Branch (8659:9): [True: 0, False: 108]
  ------------------
 8660|      0|        return false;
 8661|    108|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|    108|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8662|       |
 8663|    108|    const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
 8664|    108|    const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
  ------------------
  |  Branch (8664:26): [True: 27, False: 81]
  |  Branch (8664:42): [True: 0, False: 81]
  |  Branch (8664:52): [True: 0, False: 0]
  |  Branch (8664:79): [True: 0, False: 0]
  ------------------
 8665|    108|    if (!pressed)
  ------------------
  |  Branch (8665:9): [True: 81, False: 27]
  ------------------
 8666|     81|        return false;
 8667|       |
 8668|     27|    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
  ------------------
  |  Branch (8668:9): [True: 0, False: 27]
  ------------------
 8669|      0|        return false;
 8670|       |
 8671|     27|    return true;
 8672|     27|}
_ZN5ImGui15IsMouseReleasedEij:
 8682|    334|{
 8683|    334|    ImGuiContext& g = *GImGui;
 8684|    334|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    334|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8685|    334|    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
  ------------------
  |  Branch (8685:12): [True: 9, False: 325]
  |  Branch (8685:42): [True: 9, False: 0]
  ------------------
 8686|    334|}
_ZN5ImGui19IsMouseHoveringRectERK6ImVec2S2_b:
 8706|   362k|{
 8707|   362k|    ImGuiContext& g = *GImGui;
 8708|       |
 8709|       |    // Clip
 8710|   362k|    ImRect rect_clipped(r_min, r_max);
 8711|   362k|    if (clip)
  ------------------
  |  Branch (8711:9): [True: 182k, False: 180k]
  ------------------
 8712|   182k|        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);
 8713|       |
 8714|       |    // Expand for touch input
 8715|   362k|    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
 8716|   362k|    if (!rect_for_touch.Contains(g.IO.MousePos))
  ------------------
  |  Branch (8716:9): [True: 352k, False: 10.3k]
  ------------------
 8717|   352k|        return false;
 8718|  10.3k|    if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
  ------------------
  |  Branch (8718:9): [True: 0, False: 10.3k]
  ------------------
 8719|      0|        return false;
 8720|  10.3k|    return true;
 8721|  10.3k|}
_ZN5ImGui24IsMouseDragPastThresholdEif:
 8726|    155|{
 8727|    155|    ImGuiContext& g = *GImGui;
 8728|    155|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    155|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8729|    155|    if (lock_threshold < 0.0f)
  ------------------
  |  Branch (8729:9): [True: 149, False: 6]
  ------------------
 8730|    149|        lock_threshold = g.IO.MouseDragThreshold;
 8731|    155|    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
 8732|    155|}
_ZN5ImGui15IsMouseDraggingEif:
 8735|    155|{
 8736|    155|    ImGuiContext& g = *GImGui;
 8737|    155|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    155|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8738|    155|    if (!g.IO.MouseDown[button])
  ------------------
  |  Branch (8738:9): [True: 0, False: 155]
  ------------------
 8739|      0|        return false;
 8740|    155|    return IsMouseDragPastThreshold(button, lock_threshold);
 8741|    155|}
_ZN5ImGui11GetMousePosEv:
 8744|     87|{
 8745|     87|    ImGuiContext& g = *GImGui;
 8746|     87|    return g.IO.MousePos;
 8747|     87|}
_ZN5ImGui15IsMousePosValidEPK6ImVec2:
 8760|   260k|{
 8761|       |    // The assert is only to silence a false-positive in XCode Static Analysis.
 8762|       |    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
 8763|   260k|    IM_ASSERT(GImGui != NULL);
  ------------------
  |  |   23|   260k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8764|   260k|    const float MOUSE_INVALID = -256000.0f;
 8765|   260k|    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
  ------------------
  |  Branch (8765:16): [True: 260k, False: 323]
  ------------------
 8766|   260k|    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
  ------------------
  |  Branch (8766:12): [True: 126k, False: 133k]
  |  Branch (8766:36): [True: 126k, False: 0]
  ------------------
 8767|   260k|}
_ZN5ImGui17UpdateInputEventsEb:
 9208|  90.2k|{
 9209|  90.2k|    ImGuiContext& g = *GImGui;
 9210|  90.2k|    ImGuiIO& io = g.IO;
 9211|       |
 9212|       |    // Only trickle chars<>key when working with InputText()
 9213|       |    // FIXME: InputText() could parse event trail?
 9214|       |    // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
 9215|  90.2k|    const bool trickle_interleaved_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);
  ------------------
  |  Branch (9215:53): [True: 90.2k, False: 0]
  |  Branch (9215:76): [True: 0, False: 90.2k]
  ------------------
 9216|       |
 9217|  90.2k|    bool mouse_moved = false, mouse_wheeled = false, key_changed = false, text_inputted = false;
 9218|  90.2k|    int  mouse_button_changed = 0x00;
 9219|  90.2k|    ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;
 9220|       |
 9221|  90.2k|    int event_n = 0;
 9222|   124k|    for (; event_n < g.InputEventsQueue.Size; event_n++)
  ------------------
  |  Branch (9222:12): [True: 41.2k, False: 83.2k]
  ------------------
 9223|  41.2k|    {
 9224|  41.2k|        ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
 9225|  41.2k|        if (e->Type == ImGuiInputEventType_MousePos)
  ------------------
  |  Branch (9225:13): [True: 5.77k, False: 35.4k]
  ------------------
 9226|  5.77k|        {
 9227|       |            // Trickling Rule: Stop processing queued events if we already handled a mouse button change
 9228|  5.77k|            ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
 9229|  5.77k|            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
  ------------------
  |  Branch (9229:17): [True: 5.77k, False: 0]
  |  Branch (9229:41): [True: 341, False: 5.43k]
  |  Branch (9229:70): [True: 795, False: 4.63k]
  |  Branch (9229:87): [True: 84, False: 4.55k]
  |  Branch (9229:102): [True: 0, False: 4.55k]
  ------------------
 9230|  1.22k|                break;
 9231|  4.55k|            io.MousePos = event_pos;
 9232|  4.55k|            mouse_moved = true;
 9233|  4.55k|        }
 9234|  35.4k|        else if (e->Type == ImGuiInputEventType_MouseButton)
  ------------------
  |  Branch (9234:18): [True: 12.3k, False: 23.0k]
  ------------------
 9235|  12.3k|        {
 9236|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
 9237|  12.3k|            const ImGuiMouseButton button = e->MouseButton.Button;
 9238|  12.3k|            IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  12.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9239|  12.3k|            if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
  ------------------
  |  Branch (9239:17): [True: 12.3k, False: 0]
  |  Branch (9239:41): [True: 1.86k, False: 10.5k]
  |  Branch (9239:83): [True: 517, False: 9.99k]
  ------------------
 9240|  2.38k|                break;
 9241|  9.99k|            io.MouseDown[button] = e->MouseButton.Down;
 9242|  9.99k|            mouse_button_changed |= (1 << button);
 9243|  9.99k|        }
 9244|  23.0k|        else if (e->Type == ImGuiInputEventType_MouseWheel)
  ------------------
  |  Branch (9244:18): [True: 5.69k, False: 17.3k]
  ------------------
 9245|  5.69k|        {
 9246|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the event
 9247|  5.69k|            if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
  ------------------
  |  Branch (9247:17): [True: 5.69k, False: 0]
  |  Branch (9247:41): [True: 1.92k, False: 3.77k]
  |  Branch (9247:56): [True: 252, False: 3.52k]
  ------------------
 9248|  2.17k|                break;
 9249|  3.52k|            io.MouseWheelH += e->MouseWheel.WheelX;
 9250|  3.52k|            io.MouseWheel += e->MouseWheel.WheelY;
 9251|  3.52k|            mouse_wheeled = true;
 9252|  3.52k|        }
 9253|  17.3k|        else if (e->Type == ImGuiInputEventType_MouseViewport)
  ------------------
  |  Branch (9253:18): [True: 0, False: 17.3k]
  ------------------
 9254|      0|        {
 9255|      0|            io.MouseHoveredViewport = e->MouseViewport.HoveredViewportID;
 9256|      0|        }
 9257|  17.3k|        else if (e->Type == ImGuiInputEventType_Key)
  ------------------
  |  Branch (9257:18): [True: 3.21k, False: 14.1k]
  ------------------
 9258|  3.21k|        {
 9259|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
 9260|  3.21k|            ImGuiKey key = e->Key.Key;
 9261|  3.21k|            IM_ASSERT(key != ImGuiKey_None);
  ------------------
  |  |   23|  3.21k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9262|  3.21k|            ImGuiKeyData* key_data = GetKeyData(key);
 9263|  3.21k|            const int key_data_index = (int)(key_data - g.IO.KeysData);
 9264|  3.21k|            if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || text_inputted || mouse_button_changed != 0))
  ------------------
  |  Branch (9264:17): [True: 3.21k, False: 0]
  |  Branch (9264:40): [True: 3.14k, False: 70]
  |  Branch (9264:74): [True: 0, False: 3.14k]
  |  Branch (9264:118): [True: 0, False: 3.14k]
  |  Branch (9264:135): [True: 88, False: 3.05k]
  ------------------
 9265|     88|                break;
 9266|  3.12k|            key_data->Down = e->Key.Down;
 9267|  3.12k|            key_data->AnalogValue = e->Key.AnalogValue;
 9268|  3.12k|            key_changed = true;
 9269|  3.12k|            key_changed_mask.SetBit(key_data_index);
 9270|       |
 9271|       |            // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
 9272|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9273|       |            io.KeysDown[key_data_index] = key_data->Down;
 9274|       |            if (io.KeyMap[key_data_index] != -1)
 9275|       |                io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
 9276|       |#endif
 9277|  3.12k|        }
 9278|  14.1k|        else if (e->Type == ImGuiInputEventType_Text)
  ------------------
  |  Branch (9278:18): [True: 8.67k, False: 5.49k]
  ------------------
 9279|  8.67k|        {
 9280|       |            // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
 9281|  8.67k|            if (trickle_fast_inputs && ((key_changed && trickle_interleaved_keys_and_text) || mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
  ------------------
  |  Branch (9281:17): [True: 8.67k, False: 0]
  |  Branch (9281:42): [True: 293, False: 8.38k]
  |  Branch (9281:57): [True: 0, False: 293]
  |  Branch (9281:95): [True: 517, False: 8.15k]
  |  Branch (9281:124): [True: 491, False: 7.66k]
  |  Branch (9281:139): [True: 145, False: 7.52k]
  ------------------
 9282|  1.15k|                break;
 9283|  7.52k|            unsigned int c = e->Text.Char;
 9284|  7.52k|            io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2281|  7.52k|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
                          io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2277|  13.2k|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
  |  Branch (9284:47): [True: 1.76k, False: 5.76k]
  ------------------
 9285|  7.52k|            if (trickle_interleaved_keys_and_text)
  ------------------
  |  Branch (9285:17): [True: 0, False: 7.52k]
  ------------------
 9286|      0|                text_inputted = true;
 9287|  7.52k|        }
 9288|  5.49k|        else if (e->Type == ImGuiInputEventType_Focus)
  ------------------
  |  Branch (9288:18): [True: 5.49k, False: 0]
  ------------------
 9289|  5.49k|        {
 9290|       |            // We intentionally overwrite this and process in NewFrame(), in order to give a chance
 9291|       |            // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
 9292|  5.49k|            const bool focus_lost = !e->AppFocused.Focused;
 9293|  5.49k|            io.AppFocusLost = focus_lost;
 9294|  5.49k|        }
 9295|      0|        else
 9296|      0|        {
 9297|      0|            IM_ASSERT(0 && "Unknown event!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9298|      0|        }
 9299|  41.2k|    }
 9300|       |
 9301|       |    // Record trail (for domain-specific applications wanting to access a precise trail)
 9302|       |    //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
 9303|   124k|    for (int n = 0; n < event_n; n++)
  ------------------
  |  Branch (9303:21): [True: 34.2k, False: 90.2k]
  ------------------
 9304|  34.2k|        g.InputEventsTrail.push_back(g.InputEventsQueue[n]);
 9305|       |
 9306|       |    // [DEBUG]
 9307|  90.2k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 9308|  90.2k|    if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
  ------------------
  |  Branch (9308:9): [True: 23.7k, False: 66.4k]
  |  Branch (9308:25): [True: 0, False: 23.7k]
  ------------------
 9309|      0|        for (int n = 0; n < g.InputEventsQueue.Size; n++)
  ------------------
  |  Branch (9309:25): [True: 0, False: 0]
  ------------------
 9310|      0|            DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
  ------------------
  |  Branch (9310:34): [True: 0, False: 0]
  ------------------
 9311|  90.2k|#endif
 9312|       |
 9313|       |    // Remaining events will be processed on the next frame
 9314|  90.2k|    if (event_n == g.InputEventsQueue.Size)
  ------------------
  |  Branch (9314:9): [True: 83.2k, False: 7.02k]
  ------------------
 9315|  83.2k|        g.InputEventsQueue.resize(0);
 9316|  7.02k|    else
 9317|  7.02k|        g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
 9318|       |
 9319|       |    // Clear buttons state when focus is lost
 9320|       |    // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
 9321|       |    // - we clear in EndFrame() and not now in order allow application/user code polling this flag
 9322|       |    //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
 9323|  90.2k|    if (g.IO.AppFocusLost)
  ------------------
  |  Branch (9323:9): [True: 4.40k, False: 85.8k]
  ------------------
 9324|  4.40k|        g.IO.ClearInputKeys();
 9325|  90.2k|}
_ZN5ImGui12TestKeyOwnerE8ImGuiKeyj:
 9348|   207k|{
 9349|   207k|    if (!IsNamedKeyOrModKey(key))
  ------------------
  |  Branch (9349:9): [True: 0, False: 207k]
  ------------------
 9350|      0|        return true;
 9351|       |
 9352|   207k|    ImGuiContext& g = *GImGui;
 9353|   207k|    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
  ------------------
  |  | 1319|    331|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9353:9): [True: 331, False: 206k]
  |  Branch (9353:43): [True: 331, False: 0]
  |  Branch (9353:69): [True: 324, False: 7]
  ------------------
 9354|    324|        if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1246|    648|#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
  ------------------
                      if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1247|    324|#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
  ------------------
  |  Branch (9354:13): [True: 324, False: 0]
  |  Branch (9354:47): [True: 10, False: 314]
  ------------------
 9355|     10|            return false;
 9356|       |
 9357|   207k|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
 9358|   207k|    if (owner_id == ImGuiKeyOwner_Any)
  ------------------
  |  | 1319|   207k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9358:9): [True: 26.0k, False: 181k]
  ------------------
 9359|  26.0k|        return (owner_data->LockThisFrame == false);
 9360|       |
 9361|       |    // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
 9362|       |    // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
 9363|       |    // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
 9364|   181k|    if (owner_data->OwnerCurr != owner_id)
  ------------------
  |  Branch (9364:9): [True: 29, False: 181k]
  ------------------
 9365|     29|    {
 9366|     29|        if (owner_data->LockThisFrame)
  ------------------
  |  Branch (9366:13): [True: 0, False: 29]
  ------------------
 9367|      0|            return false;
 9368|     29|        if (owner_data->OwnerCurr != ImGuiKeyOwner_None)
  ------------------
  |  | 1320|     29|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9368:13): [True: 0, False: 29]
  ------------------
 9369|      0|            return false;
 9370|     29|    }
 9371|       |
 9372|   181k|    return true;
 9373|   181k|}
_ZN5ImGui11SetKeyOwnerE8ImGuiKeyji:
 9381|     27|{
 9382|     27|    IM_ASSERT(IsNamedKeyOrModKey(key) && (owner_id != ImGuiKeyOwner_Any || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
  ------------------
  |  |   23|     27|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9383|     27|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|     27|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9384|       |
 9385|     27|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
 9386|     27|    owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;
 9387|       |
 9388|       |    // We cannot lock by default as it would likely break lots of legacy code.
 9389|       |    // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
 9390|     27|    owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
 9391|     27|    owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);
  ------------------
  |  Branch (9391:33): [True: 0, False: 27]
  |  Branch (9391:81): [True: 0, False: 27]
  ------------------
 9392|     27|}
_ZN5ImGui8ShortcutEiji:
 9416|   180k|{
 9417|   180k|    ImGuiContext& g = *GImGui;
 9418|       |
 9419|       |    // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
 9420|   180k|    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
  ------------------
  |  Branch (9420:9): [True: 180k, False: 0]
  ------------------
 9421|   180k|        flags |= ImGuiInputFlags_RouteFocused;
 9422|   180k|    if (!SetShortcutRouting(key_chord, owner_id, flags))
  ------------------
  |  Branch (9422:9): [True: 0, False: 180k]
  ------------------
 9423|      0|        return false;
 9424|       |
 9425|   180k|    if (key_chord & ImGuiMod_Shortcut)
  ------------------
  |  Branch (9425:9): [True: 0, False: 180k]
  ------------------
 9426|      0|        key_chord = ConvertShortcutMod(key_chord);
 9427|   180k|    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
 9428|   180k|    if (g.IO.KeyMods != mods)
  ------------------
  |  Branch (9428:9): [True: 180k, False: 0]
  ------------------
 9429|   180k|        return false;
 9430|       |
 9431|       |    // Special storage location for mods
 9432|      0|    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
 9433|      0|    if (key == ImGuiKey_None)
  ------------------
  |  Branch (9433:9): [True: 0, False: 0]
  ------------------
 9434|      0|        key = ConvertSingleModFlagToKey(mods);
 9435|       |
 9436|      0|    if (!IsKeyPressed(key, owner_id, (flags & (ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateMask_))))
  ------------------
  |  Branch (9436:9): [True: 0, False: 0]
  ------------------
 9437|      0|        return false;
 9438|      0|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9439|       |
 9440|      0|    return true;
 9441|      0|}
_ZN5ImGui30DebugCheckVersionAndDataLayoutEPKcmmmmmm:
 9457|      1|{
 9458|      1|    bool error = false;
 9459|      1|    if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   25|      1|#define IMGUI_VERSION               "1.89.4 WIP"
  ------------------
                  if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9459:9): [True: 0, False: 1]
  ------------------
 9460|      1|    if (sz_io != sizeof(ImGuiIO)) { error = true; IM_ASSERT(sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9460:9): [True: 0, False: 1]
  ------------------
 9461|      1|    if (sz_style != sizeof(ImGuiStyle)) { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9461:9): [True: 0, False: 1]
  ------------------
 9462|      1|    if (sz_vec2 != sizeof(ImVec2)) { error = true; IM_ASSERT(sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9462:9): [True: 0, False: 1]
  ------------------
 9463|      1|    if (sz_vec4 != sizeof(ImVec4)) { error = true; IM_ASSERT(sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9463:9): [True: 0, False: 1]
  ------------------
 9464|      1|    if (sz_vert != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9464:9): [True: 0, False: 1]
  ------------------
 9465|      1|    if (sz_idx != sizeof(ImDrawIdx)) { error = true; IM_ASSERT(sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9465:9): [True: 0, False: 1]
  ------------------
 9466|      1|    return !error;
 9467|      1|}
_ZN15ImGuiStackSizes17SetToCurrentStateEv:
 9716|   180k|{
 9717|   180k|    ImGuiContext& g = *GImGui;
 9718|   180k|    ImGuiWindow* window = g.CurrentWindow;
 9719|   180k|    SizeOfIDStack = (short)window->IDStack.Size;
 9720|   180k|    SizeOfColorStack = (short)g.ColorStack.Size;
 9721|   180k|    SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
 9722|   180k|    SizeOfFontStack = (short)g.FontStack.Size;
 9723|   180k|    SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
 9724|   180k|    SizeOfGroupStack = (short)g.GroupStack.Size;
 9725|   180k|    SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
 9726|   180k|    SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
 9727|   180k|    SizeOfDisabledStack = (short)g.DisabledStackSize;
 9728|   180k|}
_ZN15ImGuiStackSizes23CompareWithCurrentStateEv:
 9732|   180k|{
 9733|   180k|    ImGuiContext& g = *GImGui;
 9734|   180k|    ImGuiWindow* window = g.CurrentWindow;
 9735|   180k|    IM_UNUSED(window);
  ------------------
  |  |   88|   180k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9736|       |
 9737|       |    // Window stacks
 9738|       |    // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
 9739|   180k|    IM_ASSERT(SizeOfIDStack         == window->IDStack.Size     && "PushID/PopID or TreeNode/TreePop Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9740|       |
 9741|       |    // Global stacks
 9742|       |    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
 9743|   180k|    IM_ASSERT(SizeOfGroupStack      == g.GroupStack.Size        && "BeginGroup/EndGroup Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9744|   180k|    IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size   && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9745|   180k|    IM_ASSERT(SizeOfDisabledStack   == g.DisabledStackSize      && "BeginDisabled/EndDisabled Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9746|   180k|    IM_ASSERT(SizeOfItemFlagsStack  >= g.ItemFlagsStack.Size    && "PushItemFlag/PopItemFlag Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9747|   180k|    IM_ASSERT(SizeOfColorStack      >= g.ColorStack.Size        && "PushStyleColor/PopStyleColor Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9748|   180k|    IM_ASSERT(SizeOfStyleVarStack   >= g.StyleVarStack.Size     && "PushStyleVar/PopStyleVar Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9749|   180k|    IM_ASSERT(SizeOfFontStack       >= g.FontStack.Size         && "PushFont/PopFont Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9750|   180k|    IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size   && "PushFocusScope/PopFocusScope Mismatch!");
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9751|   180k|}
_ZN5ImGui8ItemSizeERK6ImVec2f:
 9790|    646|{
 9791|    646|    ImGuiContext& g = *GImGui;
 9792|    646|    ImGuiWindow* window = g.CurrentWindow;
 9793|    646|    if (window->SkipItems)
  ------------------
  |  Branch (9793:9): [True: 0, False: 646]
  ------------------
 9794|      0|        return;
 9795|       |
 9796|       |    // We increase the height in this function to accommodate for baseline offset.
 9797|       |    // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
 9798|       |    // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
 9799|    646|    const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
  ------------------
  |  Branch (9799:46): [True: 0, False: 646]
  ------------------
 9800|       |
 9801|    646|    const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
  ------------------
  |  Branch (9801:27): [True: 0, False: 646]
  ------------------
 9802|    646|    const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/window->DC.CursorPos.y - line_y1/*, 0.0f)*/ + size.y + offset_to_match_baseline_y);
 9803|       |
 9804|       |    // Always align ourselves on pixel boundaries
 9805|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
 9806|    646|    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
 9807|    646|    window->DC.CursorPosPrevLine.y = line_y1;
 9808|    646|    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
  ------------------
  |  |  269|    646|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 9809|    646|    window->DC.CursorPos.y = IM_FLOOR(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
  ------------------
  |  |  269|    646|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 9810|    646|    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
 9811|    646|    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
 9812|       |    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
 9813|       |
 9814|    646|    window->DC.PrevLineSize.y = line_height;
 9815|    646|    window->DC.CurrLineSize.y = 0.0f;
 9816|    646|    window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
 9817|    646|    window->DC.CurrLineTextBaseOffset = 0.0f;
 9818|    646|    window->DC.IsSameLine = window->DC.IsSetPos = false;
 9819|       |
 9820|       |    // Horizontal layout mode
 9821|    646|    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
  ------------------
  |  Branch (9821:9): [True: 0, False: 646]
  ------------------
 9822|      0|        SameLine();
 9823|    646|}
_ZN5ImGui7ItemAddERK6ImRectjPS1_i:
 9829|   181k|{
 9830|   181k|    ImGuiContext& g = *GImGui;
 9831|   181k|    ImGuiWindow* window = g.CurrentWindow;
 9832|       |
 9833|       |    // Set item data
 9834|       |    // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
 9835|   181k|    g.LastItemData.ID = id;
 9836|   181k|    g.LastItemData.Rect = bb;
 9837|   181k|    g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
  ------------------
  |  Branch (9837:30): [True: 0, False: 181k]
  ------------------
 9838|   181k|    g.LastItemData.InFlags = g.CurrentItemFlags | extra_flags;
 9839|   181k|    g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
 9840|       |
 9841|       |    // Directional navigation processing
 9842|   181k|    if (id != 0)
  ------------------
  |  Branch (9842:9): [True: 181k, False: 383]
  ------------------
 9843|   181k|    {
 9844|   181k|        KeepAliveID(id);
 9845|       |
 9846|       |        // Runs prior to clipping early-out
 9847|       |        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
 9848|       |        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
 9849|       |        //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
 9850|       |        //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
 9851|       |        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
 9852|       |        //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
 9853|       |        // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
 9854|       |        // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
 9855|   181k|        if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
  ------------------
  |  Branch (9855:13): [True: 180k, False: 664]
  ------------------
 9856|   180k|        {
 9857|   180k|            window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
 9858|   180k|            if (g.NavId == id || g.NavAnyRequest)
  ------------------
  |  Branch (9858:17): [True: 107, False: 180k]
  |  Branch (9858:34): [True: 40, False: 180k]
  ------------------
 9859|    147|                if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
  ------------------
  |  Branch (9859:21): [True: 112, False: 35]
  ------------------
 9860|    112|                    if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
  ------------------
  |  Branch (9860:25): [True: 112, False: 0]
  |  Branch (9860:50): [True: 0, False: 0]
  ------------------
 9861|    112|                        NavProcessItem();
 9862|   180k|        }
 9863|       |
 9864|       |        // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
 9865|       |        // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
 9866|       |        // READ THE FAQ: https://dearimgui.org/faq
 9867|   181k|        IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
  ------------------
  |  |   23|   181k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9868|   181k|    }
 9869|   181k|    g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
 9870|       |
 9871|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 9872|       |    if (id != 0)
 9873|       |        IMGUI_TEST_ENGINE_ITEM_ADD(nav_bb_arg ? *nav_bb_arg : bb, id);
 9874|       |#endif
 9875|       |
 9876|       |    // Clipping test
 9877|       |    // (FIXME: This is a modified copy of IsClippedEx() so we can reuse the is_rect_visible value)
 9878|       |    //const bool is_clipped = IsClippedEx(bb, id);
 9879|       |    //if (is_clipped)
 9880|       |    //    return false;
 9881|   181k|    const bool is_rect_visible = bb.Overlaps(window->ClipRect);
 9882|   181k|    if (!is_rect_visible)
  ------------------
  |  Branch (9882:9): [True: 319, False: 181k]
  ------------------
 9883|    319|        if (id == 0 || (id != g.ActiveId && id != g.NavId))
  ------------------
  |  Branch (9883:13): [True: 256, False: 63]
  |  Branch (9883:25): [True: 63, False: 0]
  |  Branch (9883:45): [True: 63, False: 0]
  ------------------
 9884|    319|            if (!g.LogEnabled)
  ------------------
  |  Branch (9884:17): [True: 319, False: 0]
  ------------------
 9885|    319|                return false;
 9886|       |
 9887|       |    // [DEBUG]
 9888|   181k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 9889|   181k|    if (id != 0 && id == g.DebugLocateId)
  ------------------
  |  Branch (9889:9): [True: 181k, False: 127]
  |  Branch (9889:20): [True: 0, False: 181k]
  ------------------
 9890|      0|        DebugLocateItemResolveWithLastItem();
 9891|   181k|#endif
 9892|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
 9893|       |
 9894|       |    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
 9895|   181k|    if (is_rect_visible)
  ------------------
  |  Branch (9895:9): [True: 181k, False: 0]
  ------------------
 9896|   181k|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
 9897|   181k|    if (IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (9897:9): [True: 4.95k, False: 176k]
  ------------------
 9898|  4.95k|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
 9899|   181k|    return true;
 9900|   181k|}
_ZN5ImGui18GetCursorScreenPosEv:
 9934|    410|{
 9935|    410|    ImGuiWindow* window = GetCurrentWindowRead();
 9936|    410|    return window->DC.CursorPos;
 9937|    410|}
_ZN5ImGui28GetTextLineHeightWithSpacingEv:
10109|    323|{
10110|    323|    ImGuiContext& g = *GImGui;
10111|    323|    return g.FontSize + g.Style.ItemSpacing.y;
10112|    323|}
_ZN5ImGui14GetFrameHeightEv:
10115|    163|{
10116|    163|    ImGuiContext& g = *GImGui;
10117|    163|    return g.FontSize + g.Style.FramePadding.y * 2.0f;
10118|    163|}
_ZN5ImGui22GetContentRegionMaxAbsEv:
10141|    323|{
10142|    323|    ImGuiContext& g = *GImGui;
10143|    323|    ImGuiWindow* window = g.CurrentWindow;
10144|    323|    ImVec2 mx = window->ContentRegionRect.Max;
10145|    323|    if (window->DC.CurrentColumns || g.CurrentTable)
  ------------------
  |  Branch (10145:9): [True: 0, False: 323]
  |  Branch (10145:38): [True: 0, False: 323]
  ------------------
10146|      0|        mx.x = window->WorkRect.Max.x;
10147|    323|    return mx;
10148|    323|}
_ZN5ImGui21GetContentRegionAvailEv:
10151|    323|{
10152|    323|    ImGuiWindow* window = GImGui->CurrentWindow;
10153|    323|    return GetContentRegionMaxAbs() - window->DC.CursorPos;
10154|    323|}
_ZN5ImGui25GetWindowContentRegionMaxEv:
10164|    323|{
10165|    323|    ImGuiWindow* window = GImGui->CurrentWindow;
10166|    323|    return window->ContentRegionRect.Max - window->Pos;
10167|    323|}
_ZN5ImGui10GetScrollXEv:
10391|    414|{
10392|    414|    ImGuiWindow* window = GImGui->CurrentWindow;
10393|    414|    return window->Scroll.x;
10394|    414|}
_ZN5ImGui10GetScrollYEv:
10397|    414|{
10398|    414|    ImGuiWindow* window = GImGui->CurrentWindow;
10399|    414|    return window->Scroll.y;
10400|    414|}
_ZN5ImGui10SetScrollXEP11ImGuiWindowf:
10415|     96|{
10416|     96|    window->ScrollTarget.x = scroll_x;
10417|     96|    window->ScrollTargetCenterRatio.x = 0.0f;
10418|     96|    window->ScrollTargetEdgeSnapDist.x = 0.0f;
10419|     96|}
_ZN5ImGui10SetScrollYEP11ImGuiWindowf:
10422|     50|{
10423|     50|    window->ScrollTarget.y = scroll_y;
10424|     50|    window->ScrollTargetCenterRatio.y = 0.0f;
10425|     50|    window->ScrollTargetEdgeSnapDist.y = 0.0f;
10426|     50|}
_ZN5ImGui10SetScrollXEf:
10429|     91|{
10430|     91|    ImGuiContext& g = *GImGui;
10431|     91|    SetScrollX(g.CurrentWindow, scroll_x);
10432|     91|}
_ZN5ImGui10SetScrollYEf:
10435|     49|{
10436|     49|    ImGuiContext& g = *GImGui;
10437|     49|    SetScrollY(g.CurrentWindow, scroll_y);
10438|     49|}
_ZN5ImGui20GetTopMostPopupModalEv:
10612|   271k|{
10613|   271k|    ImGuiContext& g = *GImGui;
10614|   271k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (10614:45): [True: 0, False: 271k]
  ------------------
10615|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (10615:26): [True: 0, False: 0]
  ------------------
10616|      0|            if (popup->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (10616:17): [True: 0, False: 0]
  ------------------
10617|      0|                return popup;
10618|   271k|    return NULL;
10619|   271k|}
_ZN5ImGui30GetTopMostAndVisiblePopupModalEv:
10622|  90.2k|{
10623|  90.2k|    ImGuiContext& g = *GImGui;
10624|  90.2k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (10624:45): [True: 0, False: 90.2k]
  ------------------
10625|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (10625:26): [True: 0, False: 0]
  ------------------
10626|      0|            if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
  ------------------
  |  Branch (10626:17): [True: 0, False: 0]
  |  Branch (10626:60): [True: 0, False: 0]
  ------------------
10627|      0|                return popup;
10628|  90.2k|    return NULL;
10629|  90.2k|}
_ZN5ImGui21ClosePopupsOverWindowEP11ImGuiWindowb:
10698|    636|{
10699|    636|    ImGuiContext& g = *GImGui;
10700|    636|    if (g.OpenPopupStack.Size == 0)
  ------------------
  |  Branch (10700:9): [True: 636, False: 0]
  ------------------
10701|    636|        return;
10702|       |
10703|       |    // Don't close our own child popup windows.
10704|      0|    int popup_count_to_keep = 0;
10705|      0|    if (ref_window)
  ------------------
  |  Branch (10705:9): [True: 0, False: 0]
  ------------------
10706|      0|    {
10707|       |        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
10708|      0|        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
  ------------------
  |  Branch (10708:16): [True: 0, False: 0]
  ------------------
10709|      0|        {
10710|      0|            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
10711|      0|            if (!popup.Window)
  ------------------
  |  Branch (10711:17): [True: 0, False: 0]
  ------------------
10712|      0|                continue;
10713|      0|            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10714|      0|            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (10714:17): [True: 0, False: 0]
  ------------------
10715|      0|                continue;
10716|       |
10717|       |            // Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
10718|       |            // - With this stack of window, clicking/focusing Popup1 will close Popup2 and Popup3:
10719|       |            //     Window -> Popup1 -> Popup2 -> Popup3
10720|       |            // - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
10721|       |            //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
10722|      0|            bool ref_window_is_descendent_of_popup = false;
10723|      0|            for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
  ------------------
  |  Branch (10723:47): [True: 0, False: 0]
  ------------------
10724|      0|                if (ImGuiWindow* popup_window = g.OpenPopupStack[n].Window)
  ------------------
  |  Branch (10724:34): [True: 0, False: 0]
  ------------------
10725|       |                    //if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree) // FIXME-MERGE
10726|      0|                    if (IsWindowWithinBeginStackOf(ref_window, popup_window))
  ------------------
  |  Branch (10726:25): [True: 0, False: 0]
  ------------------
10727|      0|                    {
10728|      0|                        ref_window_is_descendent_of_popup = true;
10729|      0|                        break;
10730|      0|                    }
10731|      0|            if (!ref_window_is_descendent_of_popup)
  ------------------
  |  Branch (10731:17): [True: 0, False: 0]
  ------------------
10732|      0|                break;
10733|      0|        }
10734|      0|    }
10735|      0|    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
  ------------------
  |  Branch (10735:9): [True: 0, False: 0]
  ------------------
10736|      0|    {
10737|      0|        IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
  ------------------
  |  |  231|      0|#define IMGUI_DEBUG_LOG_POPUP(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (225:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (231:50): [True: 0, False: 0]
  |  |  |  Branch (231:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
10738|      0|        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
10739|      0|    }
10740|      0|}
_ZN5ImGui12SetNavWindowEP11ImGuiWindow:
11127|    145|{
11128|    145|    ImGuiContext& g = *GImGui;
11129|    145|    if (g.NavWindow != window)
  ------------------
  |  Branch (11129:9): [True: 145, False: 0]
  ------------------
11130|    145|    {
11131|    145|        IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
  ------------------
  |  |  230|    145|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (225:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (230:50): [True: 0, False: 145]
  |  |  |  Branch (230:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11132|    145|        g.NavWindow = window;
11133|    145|    }
11134|    145|    g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11135|    145|    NavUpdateAnyRequestFlag();
11136|    145|}
_ZN5ImGui8SetNavIDEj13ImGuiNavLayerjRK6ImRect:
11139|      7|{
11140|      7|    ImGuiContext& g = *GImGui;
11141|      7|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11142|      7|    IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11143|      7|    g.NavId = id;
11144|      7|    g.NavLayer = nav_layer;
11145|      7|    g.NavFocusScopeId = focus_scope_id;
11146|      7|    g.NavWindow->NavLastIds[nav_layer] = id;
11147|      7|    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
11148|      7|}
_ZN5ImGui10SetFocusIDEjP11ImGuiWindow:
11151|     27|{
11152|     27|    ImGuiContext& g = *GImGui;
11153|     27|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|     27|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11154|       |
11155|     27|    if (g.NavWindow != window)
  ------------------
  |  Branch (11155:9): [True: 20, False: 7]
  ------------------
11156|     20|       SetNavWindow(window);
11157|       |
11158|       |    // Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
11159|       |    // Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
11160|     27|    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
11161|     27|    g.NavId = id;
11162|     27|    g.NavLayer = nav_layer;
11163|     27|    g.NavFocusScopeId = g.CurrentFocusScopeId;
11164|     27|    window->NavLastIds[nav_layer] = id;
11165|     27|    if (g.LastItemData.ID == id)
  ------------------
  |  Branch (11165:9): [True: 27, False: 0]
  ------------------
11166|     27|        window->NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect);
11167|       |
11168|     27|    if (g.ActiveIdSource == ImGuiInputSource_Nav)
  ------------------
  |  Branch (11168:9): [True: 0, False: 27]
  ------------------
11169|      0|        g.NavDisableMouseHover = true;
11170|     27|    else
11171|     27|        g.NavDisableHighlight = true;
11172|     27|}
_ZN5ImGui28NavMoveRequestButNoResultYetEv:
11465|    505|{
11466|    505|    ImGuiContext& g = *GImGui;
11467|    505|    return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
  ------------------
  |  Branch (11467:12): [True: 12, False: 493]
  |  Branch (11467:37): [True: 12, False: 0]
  |  Branch (11467:69): [True: 12, False: 0]
  ------------------
11468|    505|}
_ZN5ImGui20NavMoveRequestSubmitEiiii:
11472|     15|{
11473|     15|    ImGuiContext& g = *GImGui;
11474|     15|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|     15|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11475|       |
11476|     15|    if (move_flags & ImGuiNavMoveFlags_Tabbing)
  ------------------
  |  Branch (11476:9): [True: 0, False: 15]
  ------------------
11477|      0|        move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;
11478|       |
11479|     15|    g.NavMoveSubmitted = g.NavMoveScoringItems = true;
11480|     15|    g.NavMoveDir = move_dir;
11481|     15|    g.NavMoveDirForDebug = move_dir;
11482|     15|    g.NavMoveClipDir = clip_dir;
11483|     15|    g.NavMoveFlags = move_flags;
11484|     15|    g.NavMoveScrollFlags = scroll_flags;
11485|     15|    g.NavMoveForwardToNextFrame = false;
11486|     15|    g.NavMoveKeyMods = g.IO.KeyMods;
11487|     15|    g.NavMoveResultLocal.Clear();
11488|     15|    g.NavMoveResultLocalVisible.Clear();
11489|     15|    g.NavMoveResultOther.Clear();
11490|     15|    g.NavTabbingCounter = 0;
11491|     15|    g.NavTabbingResultFirst.Clear();
11492|     15|    NavUpdateAnyRequestFlag();
11493|     15|}
_ZN5ImGui20NavMoveRequestCancelEv:
11504|     58|{
11505|     58|    ImGuiContext& g = *GImGui;
11506|     58|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11507|     58|    NavUpdateAnyRequestFlag();
11508|     58|}
_ZN5ImGui13NavInitWindowEP11ImGuiWindowb:
11596|      2|{
11597|       |    // FIXME: ChildWindow test here is wrong for docking
11598|      2|    ImGuiContext& g = *GImGui;
11599|      2|    IM_ASSERT(window == g.NavWindow);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11600|       |
11601|      2|    if (window->Flags & ImGuiWindowFlags_NoNavInputs)
  ------------------
  |  Branch (11601:9): [True: 0, False: 2]
  ------------------
11602|      0|    {
11603|      0|        g.NavId = 0;
11604|      0|        g.NavFocusScopeId = window->NavRootFocusScopeId;
11605|      0|        return;
11606|      0|    }
11607|       |
11608|      2|    bool init_for_nav = false;
11609|      2|    if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
  ------------------
  |  Branch (11609:9): [True: 2, False: 0]
  |  Branch (11609:41): [True: 0, False: 0]
  |  Branch (11609:85): [True: 0, False: 0]
  |  Branch (11609:117): [True: 0, False: 0]
  ------------------
11610|      2|        init_for_nav = true;
11611|      2|    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
  ------------------
  |  |  232|      2|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (232:50): [True: 0, False: 2]
  |  |  |  Branch (232:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11612|      2|    if (init_for_nav)
  ------------------
  |  Branch (11612:9): [True: 2, False: 0]
  ------------------
11613|      2|    {
11614|      2|        SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
11615|      2|        g.NavInitRequest = true;
11616|      2|        g.NavInitRequestFromMove = false;
11617|      2|        g.NavInitResultId = 0;
11618|      2|        g.NavInitResultRectRel = ImRect();
11619|      2|        NavUpdateAnyRequestFlag();
11620|      2|    }
11621|      0|    else
11622|      0|    {
11623|      0|        g.NavId = window->NavLastIds[0];
11624|      0|        g.NavFocusScopeId = window->NavRootFocusScopeId;
11625|      0|    }
11626|      2|}
_ZN5ImGui25NavMoveRequestApplyResultEv:
11995|     10|{
11996|     10|    ImGuiContext& g = *GImGui;
11997|       |#if IMGUI_DEBUG_NAV_SCORING
11998|       |    if (g.NavMoveFlags & ImGuiNavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items in NavWindow at all times
11999|       |        return;
12000|       |#endif
12001|       |
12002|       |    // Select which result to use
12003|     10|    ImGuiNavItemData* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : NULL;
  ------------------
  |  Branch (12003:32): [True: 0, False: 10]
  |  Branch (12003:89): [True: 0, False: 10]
  ------------------
12004|       |
12005|       |    // Tabbing forward wrap
12006|     10|    if (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing)
  ------------------
  |  Branch (12006:9): [True: 0, False: 10]
  ------------------
12007|      0|        if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID)
  ------------------
  |  Branch (12007:14): [True: 0, False: 0]
  |  Branch (12007:42): [True: 0, False: 0]
  |  Branch (12007:67): [True: 0, False: 0]
  ------------------
12008|      0|            result = &g.NavTabbingResultFirst;
12009|       |
12010|       |    // In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
12011|     10|    if (result == NULL)
  ------------------
  |  Branch (12011:9): [True: 10, False: 0]
  ------------------
12012|     10|    {
12013|     10|        if (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing)
  ------------------
  |  Branch (12013:13): [True: 0, False: 10]
  ------------------
12014|      0|            g.NavMoveFlags |= ImGuiNavMoveFlags_DontSetNavHighlight;
12015|     10|        if (g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_DontSetNavHighlight) == 0)
  ------------------
  |  Branch (12015:13): [True: 0, False: 10]
  |  Branch (12015:29): [True: 0, False: 0]
  ------------------
12016|      0|            NavRestoreHighlightAfterMove();
12017|     10|        return;
12018|     10|    }
12019|       |
12020|       |    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
12021|      0|    if (g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
  ------------------
  |  Branch (12021:9): [True: 0, False: 0]
  ------------------
12022|      0|        if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId)
  ------------------
  |  Branch (12022:13): [True: 0, False: 0]
  |  Branch (12022:52): [True: 0, False: 0]
  ------------------
12023|      0|            result = &g.NavMoveResultLocalVisible;
12024|       |
12025|       |    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
12026|      0|    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (12026:9): [True: 0, False: 0]
  |  Branch (12026:44): [True: 0, False: 0]
  |  Branch (12026:76): [True: 0, False: 0]
  ------------------
12027|      0|        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
  ------------------
  |  Branch (12027:13): [True: 0, False: 0]
  |  Branch (12027:66): [True: 0, False: 0]
  |  Branch (12027:117): [True: 0, False: 0]
  ------------------
12028|      0|            result = &g.NavMoveResultOther;
12029|      0|    IM_ASSERT(g.NavWindow && result->Window);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12030|       |
12031|       |    // Scroll to keep newly navigated item fully into view.
12032|      0|    if (g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (12032:9): [True: 0, False: 0]
  ------------------
12033|      0|    {
12034|      0|        if (g.NavMoveFlags & ImGuiNavMoveFlags_ScrollToEdgeY)
  ------------------
  |  Branch (12034:13): [True: 0, False: 0]
  ------------------
12035|      0|        {
12036|       |            // FIXME: Should remove this
12037|      0|            float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
  ------------------
  |  Branch (12037:35): [True: 0, False: 0]
  ------------------
12038|      0|            SetScrollY(result->Window, scroll_target);
12039|      0|        }
12040|      0|        else
12041|      0|        {
12042|      0|            ImRect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
12043|      0|            ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);
12044|      0|        }
12045|      0|    }
12046|       |
12047|      0|    if (g.NavWindow != result->Window)
  ------------------
  |  Branch (12047:9): [True: 0, False: 0]
  ------------------
12048|      0|    {
12049|      0|        IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result->Window->Name);
  ------------------
  |  |  230|      0|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (230:50): [True: 0, False: 0]
  |  |  |  Branch (230:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12050|      0|        g.NavWindow = result->Window;
12051|      0|    }
12052|      0|    if (g.ActiveId != result->ID)
  ------------------
  |  Branch (12052:9): [True: 0, False: 0]
  ------------------
12053|      0|        ClearActiveID();
12054|      0|    if (g.NavId != result->ID)
  ------------------
  |  Branch (12054:9): [True: 0, False: 0]
  ------------------
12055|      0|    {
12056|       |        // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
12057|      0|        g.NavJustMovedToId = result->ID;
12058|      0|        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
12059|      0|        g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
12060|      0|    }
12061|       |
12062|       |    // Focus
12063|      0|    IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
  ------------------
  |  |  232|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (232:50): [True: 0, False: 0]
  |  |  |  Branch (232:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12064|      0|    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
12065|       |
12066|       |    // Tabbing: Activates Inputable or Focus non-Inputable
12067|      0|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing) && (result->InFlags & ImGuiItemFlags_Inputable))
  ------------------
  |  Branch (12067:9): [True: 0, False: 0]
  |  Branch (12067:57): [True: 0, False: 0]
  ------------------
12068|      0|    {
12069|      0|        g.NavNextActivateId = result->ID;
12070|      0|        g.NavNextActivateFlags = ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState;
12071|      0|        g.NavMoveFlags |= ImGuiNavMoveFlags_DontSetNavHighlight;
12072|      0|    }
12073|       |
12074|       |    // Activate
12075|      0|    if (g.NavMoveFlags & ImGuiNavMoveFlags_Activate)
  ------------------
  |  Branch (12075:9): [True: 0, False: 0]
  ------------------
12076|      0|    {
12077|      0|        g.NavNextActivateId = result->ID;
12078|      0|        g.NavNextActivateFlags = ImGuiActivateFlags_None;
12079|      0|    }
12080|       |
12081|       |    // Enable nav highlight
12082|      0|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_DontSetNavHighlight) == 0)
  ------------------
  |  Branch (12082:9): [True: 0, False: 0]
  ------------------
12083|      0|        NavRestoreHighlightAfterMove();
12084|      0|}
_ZN5ImGui13ClearDragDropEv:
12569|     14|{
12570|     14|    ImGuiContext& g = *GImGui;
12571|     14|    g.DragDropActive = false;
12572|     14|    g.DragDropPayload.Clear();
12573|     14|    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
12574|     14|    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
12575|     14|    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
12576|     14|    g.DragDropAcceptFrameCount = -1;
12577|       |
12578|     14|    g.DragDropPayloadBufHeap.clear();
12579|     14|    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
12580|     14|}
_ZN5ImGui19BeginDragDropSourceEi:
12590|     42|{
12591|     42|    ImGuiContext& g = *GImGui;
12592|     42|    ImGuiWindow* window = g.CurrentWindow;
12593|       |
12594|       |    // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
12595|       |    // in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
12596|     42|    ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;
12597|       |
12598|     42|    bool source_drag_active = false;
12599|     42|    ImGuiID source_id = 0;
12600|     42|    ImGuiID source_parent_id = 0;
12601|     42|    if (!(flags & ImGuiDragDropFlags_SourceExtern))
  ------------------
  |  Branch (12601:9): [True: 42, False: 0]
  ------------------
12602|     42|    {
12603|     42|        source_id = g.LastItemData.ID;
12604|     42|        if (source_id != 0)
  ------------------
  |  Branch (12604:13): [True: 42, False: 0]
  ------------------
12605|     42|        {
12606|       |            // Common path: items with ID
12607|     42|            if (g.ActiveId != source_id)
  ------------------
  |  Branch (12607:17): [True: 0, False: 42]
  ------------------
12608|      0|                return false;
12609|     42|            if (g.ActiveIdMouseButton != -1)
  ------------------
  |  Branch (12609:17): [True: 0, False: 42]
  ------------------
12610|      0|                mouse_button = g.ActiveIdMouseButton;
12611|     42|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (12611:17): [True: 0, False: 42]
  |  Branch (12611:58): [True: 0, False: 42]
  ------------------
12612|      0|                return false;
12613|     42|            g.ActiveIdAllowOverlap = false;
12614|     42|        }
12615|      0|        else
12616|      0|        {
12617|       |            // Uncommon path: items without ID
12618|      0|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (12618:17): [True: 0, False: 0]
  |  Branch (12618:58): [True: 0, False: 0]
  ------------------
12619|      0|                return false;
12620|      0|            if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
  ------------------
  |  Branch (12620:17): [True: 0, False: 0]
  |  Branch (12620:90): [True: 0, False: 0]
  |  Branch (12620:109): [True: 0, False: 0]
  ------------------
12621|      0|                return false;
12622|       |
12623|       |            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
12624|       |            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
12625|      0|            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
  ------------------
  |  Branch (12625:17): [True: 0, False: 0]
  ------------------
12626|      0|            {
12627|      0|                IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12628|      0|                return false;
12629|      0|            }
12630|       |
12631|       |            // Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
12632|       |            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
12633|       |            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
12634|       |            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
12635|       |            // Rely on keeping other window->LastItemXXX fields intact.
12636|      0|            source_id = g.LastItemData.ID = window->GetIDFromRectangle(g.LastItemData.Rect);
12637|      0|            KeepAliveID(source_id);
12638|      0|            bool is_hovered = ItemHoverable(g.LastItemData.Rect, source_id);
12639|      0|            if (is_hovered && g.IO.MouseClicked[mouse_button])
  ------------------
  |  Branch (12639:17): [True: 0, False: 0]
  |  Branch (12639:31): [True: 0, False: 0]
  ------------------
12640|      0|            {
12641|      0|                SetActiveID(source_id, window);
12642|      0|                FocusWindow(window);
12643|      0|            }
12644|      0|            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
  ------------------
  |  Branch (12644:17): [True: 0, False: 0]
  ------------------
12645|      0|                g.ActiveIdAllowOverlap = is_hovered;
12646|      0|        }
12647|     42|        if (g.ActiveId != source_id)
  ------------------
  |  Branch (12647:13): [True: 0, False: 42]
  ------------------
12648|      0|            return false;
12649|     42|        source_parent_id = window->IDStack.back();
12650|     42|        source_drag_active = IsMouseDragging(mouse_button);
12651|       |
12652|       |        // Disable navigation and key inputs while dragging + cancel existing request if any
12653|     42|        SetActiveIdUsingAllKeyboardKeys();
12654|     42|    }
12655|      0|    else
12656|      0|    {
12657|      0|        window = NULL;
12658|      0|        source_id = ImHashStr("#SourceExtern");
12659|      0|        source_drag_active = true;
12660|      0|    }
12661|       |
12662|     42|    if (source_drag_active)
  ------------------
  |  Branch (12662:9): [True: 40, False: 2]
  ------------------
12663|     40|    {
12664|     40|        if (!g.DragDropActive)
  ------------------
  |  Branch (12664:13): [True: 7, False: 33]
  ------------------
12665|      7|        {
12666|      7|            IM_ASSERT(source_id != 0);
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12667|      7|            ClearDragDrop();
12668|      7|            ImGuiPayload& payload = g.DragDropPayload;
12669|      7|            payload.SourceId = source_id;
12670|      7|            payload.SourceParentId = source_parent_id;
12671|      7|            g.DragDropActive = true;
12672|      7|            g.DragDropSourceFlags = flags;
12673|      7|            g.DragDropMouseButton = mouse_button;
12674|      7|            if (payload.SourceId == g.ActiveId)
  ------------------
  |  Branch (12674:17): [True: 7, False: 0]
  ------------------
12675|      7|                g.ActiveIdNoClearOnFocusLoss = true;
12676|      7|        }
12677|     40|        g.DragDropSourceFrameCount = g.FrameCount;
12678|     40|        g.DragDropWithinSource = true;
12679|       |
12680|     40|        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (12680:13): [True: 0, False: 40]
  ------------------
12681|      0|        {
12682|       |            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
12683|       |            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
12684|      0|            BeginTooltip();
12685|      0|            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
  ------------------
  |  Branch (12685:17): [True: 0, False: 0]
  |  Branch (12685:43): [True: 0, False: 0]
  ------------------
12686|      0|            {
12687|      0|                ImGuiWindow* tooltip_window = g.CurrentWindow;
12688|      0|                tooltip_window->Hidden = tooltip_window->SkipItems = true;
12689|      0|                tooltip_window->HiddenFramesCanSkipItems = 1;
12690|      0|            }
12691|      0|        }
12692|       |
12693|     40|        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
  ------------------
  |  Branch (12693:13): [True: 40, False: 0]
  |  Branch (12693:67): [True: 40, False: 0]
  ------------------
12694|     40|            g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;
12695|       |
12696|     40|        return true;
12697|     40|    }
12698|      2|    return false;
12699|     42|}
_ZN5ImGui17EndDragDropSourceEv:
12702|     40|{
12703|     40|    ImGuiContext& g = *GImGui;
12704|     40|    IM_ASSERT(g.DragDropActive);
  ------------------
  |  |   23|     40|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12705|     40|    IM_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?");
  ------------------
  |  |   23|     40|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12706|       |
12707|     40|    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (12707:9): [True: 0, False: 40]
  ------------------
12708|      0|        EndTooltip();
12709|       |
12710|       |    // Discard the drag if have not called SetDragDropPayload()
12711|     40|    if (g.DragDropPayload.DataFrameCount == -1)
  ------------------
  |  Branch (12711:9): [True: 0, False: 40]
  ------------------
12712|      0|        ClearDragDrop();
12713|     40|    g.DragDropWithinSource = false;
12714|     40|}
_ZN5ImGui18SetDragDropPayloadEPKcPKvmi:
12718|     40|{
12719|     40|    ImGuiContext& g = *GImGui;
12720|     40|    ImGuiPayload& payload = g.DragDropPayload;
12721|     40|    if (cond == 0)
  ------------------
  |  Branch (12721:9): [True: 40, False: 0]
  ------------------
12722|     40|        cond = ImGuiCond_Always;
12723|       |
12724|     40|    IM_ASSERT(type != NULL);
  ------------------
  |  |   23|     40|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12725|     40|    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
  ------------------
  |  |   23|     40|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12726|     40|    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
  ------------------
  |  |   23|     40|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12727|     40|    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
  ------------------
  |  |   23|     40|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12728|     40|    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()
  ------------------
  |  |   23|     40|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12729|       |
12730|     40|    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
  ------------------
  |  Branch (12730:9): [True: 40, False: 0]
  |  Branch (12730:37): [True: 0, False: 0]
  ------------------
12731|     40|    {
12732|       |        // Copy payload
12733|     40|        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
  ------------------
  |  |   87|     40|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
12734|     40|        g.DragDropPayloadBufHeap.resize(0);
12735|     40|        if (data_size > sizeof(g.DragDropPayloadBufLocal))
  ------------------
  |  Branch (12735:13): [True: 0, False: 40]
  ------------------
12736|      0|        {
12737|       |            // Store in heap
12738|      0|            g.DragDropPayloadBufHeap.resize((int)data_size);
12739|      0|            payload.Data = g.DragDropPayloadBufHeap.Data;
12740|      0|            memcpy(payload.Data, data, data_size);
12741|      0|        }
12742|     40|        else if (data_size > 0)
  ------------------
  |  Branch (12742:18): [True: 40, False: 0]
  ------------------
12743|     40|        {
12744|       |            // Store locally
12745|     40|            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
12746|     40|            payload.Data = g.DragDropPayloadBufLocal;
12747|     40|            memcpy(payload.Data, data, data_size);
12748|     40|        }
12749|      0|        else
12750|      0|        {
12751|      0|            payload.Data = NULL;
12752|      0|        }
12753|     40|        payload.DataSize = (int)data_size;
12754|     40|    }
12755|     40|    payload.DataFrameCount = g.FrameCount;
12756|       |
12757|       |    // Return whether the payload has been accepted
12758|     40|    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
  ------------------
  |  Branch (12758:12): [True: 0, False: 40]
  |  Branch (12758:60): [True: 0, False: 40]
  ------------------
12759|     40|}
_ZN5ImGui25BeginDragDropTargetCustomERK6ImRectj:
12762|     62|{
12763|     62|    ImGuiContext& g = *GImGui;
12764|     62|    if (!g.DragDropActive)
  ------------------
  |  Branch (12764:9): [True: 0, False: 62]
  ------------------
12765|      0|        return false;
12766|       |
12767|     62|    ImGuiWindow* window = g.CurrentWindow;
12768|     62|    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
12769|     62|    if (hovered_window == NULL || window->RootWindowDockTree != hovered_window->RootWindowDockTree)
  ------------------
  |  Branch (12769:9): [True: 62, False: 0]
  |  Branch (12769:35): [True: 0, False: 0]
  ------------------
12770|     62|        return false;
12771|      0|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12772|      0|    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
  ------------------
  |  Branch (12772:9): [True: 0, False: 0]
  |  Branch (12772:49): [True: 0, False: 0]
  ------------------
12773|      0|        return false;
12774|      0|    if (window->SkipItems)
  ------------------
  |  Branch (12774:9): [True: 0, False: 0]
  ------------------
12775|      0|        return false;
12776|       |
12777|      0|    IM_ASSERT(g.DragDropWithinTarget == false);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12778|      0|    g.DragDropTargetRect = bb;
12779|      0|    g.DragDropTargetId = id;
12780|      0|    g.DragDropWithinTarget = true;
12781|      0|    return true;
12782|      0|}
_ZN5ImGui30IsDragDropPayloadBeingAcceptedEv:
12819|     16|{
12820|     16|    ImGuiContext& g = *GImGui;
12821|     16|    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
  ------------------
  |  Branch (12821:12): [True: 7, False: 9]
  |  Branch (12821:32): [True: 0, False: 7]
  ------------------
12822|     16|}
_ZN5ImGui9LogFinishEv:
13065|   180k|{
13066|   180k|    ImGuiContext& g = *GImGui;
13067|   180k|    if (!g.LogEnabled)
  ------------------
  |  Branch (13067:9): [True: 180k, False: 0]
  ------------------
13068|   180k|        return;
13069|       |
13070|      0|    LogText(IM_NEWLINE);
  ------------------
  |  |  261|      0|#define IM_NEWLINE                      "\n"
  ------------------
13071|      0|    switch (g.LogType)
  ------------------
  |  Branch (13071:13): [True: 0, False: 0]
  ------------------
13072|      0|    {
13073|      0|    case ImGuiLogType_TTY:
  ------------------
  |  Branch (13073:5): [True: 0, False: 0]
  ------------------
13074|      0|#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
13075|      0|        fflush(g.LogFile);
13076|      0|#endif
13077|      0|        break;
13078|      0|    case ImGuiLogType_File:
  ------------------
  |  Branch (13078:5): [True: 0, False: 0]
  ------------------
13079|      0|        ImFileClose(g.LogFile);
13080|      0|        break;
13081|      0|    case ImGuiLogType_Buffer:
  ------------------
  |  Branch (13081:5): [True: 0, False: 0]
  ------------------
13082|      0|        break;
13083|      0|    case ImGuiLogType_Clipboard:
  ------------------
  |  Branch (13083:5): [True: 0, False: 0]
  ------------------
13084|      0|        if (!g.LogBuffer.empty())
  ------------------
  |  Branch (13084:13): [True: 0, False: 0]
  ------------------
13085|      0|            SetClipboardText(g.LogBuffer.begin());
13086|      0|        break;
13087|      0|    case ImGuiLogType_None:
  ------------------
  |  Branch (13087:5): [True: 0, False: 0]
  ------------------
13088|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13089|      0|        break;
13090|      0|    }
13091|       |
13092|      0|    g.LogEnabled = false;
13093|      0|    g.LogType = ImGuiLogType_None;
13094|      0|    g.LogFile = NULL;
13095|      0|    g.LogBuffer.clear();
13096|      0|}
_ZN5ImGui20MarkIniSettingsDirtyEP11ImGuiWindow:
13183|    290|{
13184|    290|    ImGuiContext& g = *GImGui;
13185|    290|    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (13185:9): [True: 136, False: 154]
  ------------------
13186|    136|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (13186:13): [True: 4, False: 132]
  ------------------
13187|      4|            g.SettingsDirtyTimer = g.IO.IniSavingRate;
13188|    290|}
_ZN5ImGui18AddSettingsHandlerEPK20ImGuiSettingsHandler:
13191|      2|{
13192|      2|    ImGuiContext& g = *GImGui;
13193|      2|    IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13194|      2|    g.SettingsHandlers.push_back(*handler);
13195|      2|}
_ZN5ImGui19FindSettingsHandlerEPKc:
13205|      2|{
13206|      2|    ImGuiContext& g = *GImGui;
13207|      2|    const ImGuiID type_hash = ImHashStr(type_name);
13208|      3|    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
  ------------------
  |  Branch (13208:29): [True: 1, False: 2]
  ------------------
13209|      1|        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
  ------------------
  |  Branch (13209:13): [True: 0, False: 1]
  ------------------
13210|      0|            return &g.SettingsHandlers[handler_n];
13211|      2|    return NULL;
13212|      2|}
_ZN5ImGui22FindWindowSettingsByIDEj:
13364|      2|{
13365|      2|    ImGuiContext& g = *GImGui;
13366|      2|    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
  ------------------
  |  Branch (13366:69): [True: 0, False: 2]
  ------------------
13367|      0|        if (settings->ID == id)
  ------------------
  |  Branch (13367:13): [True: 0, False: 0]
  ------------------
13368|      0|            return settings;
13369|      2|    return NULL;
13370|      2|}
_ZN5ImGui26FindWindowSettingsByWindowEP11ImGuiWindow:
13374|      2|{
13375|      2|    ImGuiContext& g = *GImGui;
13376|      2|    if (window->SettingsOffset != -1)
  ------------------
  |  Branch (13376:9): [True: 0, False: 2]
  ------------------
13377|      0|        return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
13378|      2|    return FindWindowSettingsByID(window->ID);
13379|      2|}
_ZN5ImGui23LocalizeRegisterEntriesEPK13ImGuiLocEntryi:
13516|      1|{
13517|      1|    ImGuiContext& g = *GImGui;
13518|      9|    for (int n = 0; n < count; n++)
  ------------------
  |  Branch (13518:21): [True: 8, False: 1]
  ------------------
13519|      8|        g.LocalizationTable[entries[n].Key] = entries[n].Text;
13520|      1|}
_ZN5ImGui15GetMainViewportEv:
13552|   180k|{
13553|   180k|    ImGuiContext& g = *GImGui;
13554|   180k|    return g.Viewports[0];
13555|   180k|}
_ZN5ImGui16FindViewportByIDEj:
13559|  90.2k|{
13560|  90.2k|    ImGuiContext& g = *GImGui;
13561|  90.2k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (13561:21): [True: 90.2k, False: 0]
  ------------------
13562|  90.2k|        if (g.Viewports[n]->ID == id)
  ------------------
  |  Branch (13562:13): [True: 90.2k, False: 0]
  ------------------
13563|  90.2k|            return g.Viewports[n];
13564|      0|    return NULL;
13565|  90.2k|}
_ZN5ImGui18SetCurrentViewportEP11ImGuiWindowP14ImGuiViewportP:
13577|   361k|{
13578|   361k|    ImGuiContext& g = *GImGui;
13579|   361k|    (void)current_window;
13580|       |
13581|   361k|    if (viewport)
  ------------------
  |  Branch (13581:9): [True: 271k, False: 90.2k]
  ------------------
13582|   271k|        viewport->LastFrameActive = g.FrameCount;
13583|   361k|    if (g.CurrentViewport == viewport)
  ------------------
  |  Branch (13583:9): [True: 181k, False: 180k]
  ------------------
13584|   181k|        return;
13585|   180k|    g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (13585:25): [True: 90.2k, False: 90.2k]
  ------------------
13586|   180k|    g.CurrentViewport = viewport;
13587|       |    //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
13588|       |
13589|       |    // Notify platform layer of viewport changes
13590|       |    // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
13591|   180k|    if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
  ------------------
  |  Branch (13591:9): [True: 90.2k, False: 90.2k]
  |  Branch (13591:30): [True: 0, False: 90.2k]
  ------------------
13592|      0|        g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
13593|   180k|}
_ZN5ImGui17SetWindowViewportEP11ImGuiWindowP14ImGuiViewportP:
13596|   180k|{
13597|       |    // Abandon viewport
13598|   180k|    if (window->ViewportOwned && window->Viewport->Window == window)
  ------------------
  |  Branch (13598:9): [True: 0, False: 180k]
  |  Branch (13598:34): [True: 0, False: 0]
  ------------------
13599|      0|        window->Viewport->Size = ImVec2(0.0f, 0.0f);
13600|       |
13601|   180k|    window->Viewport = viewport;
13602|   180k|    window->ViewportId = viewport->ID;
13603|   180k|    window->ViewportOwned = (viewport->Window == window);
13604|   180k|}
_ZN5ImGui21DockContextInitializeEP12ImGuiContext:
14709|      1|{
14710|      1|    ImGuiContext& g = *ctx;
14711|       |
14712|       |    // Add .ini handle for persistent docking data
14713|      1|    ImGuiSettingsHandler ini_handler;
14714|      1|    ini_handler.TypeName = "Docking";
14715|      1|    ini_handler.TypeHash = ImHashStr("Docking");
14716|      1|    ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
14717|      1|    ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
14718|      1|    ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
14719|      1|    ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
14720|      1|    ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
14721|      1|    ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
14722|      1|    g.SettingsHandlers.push_back(ini_handler);
14723|      1|}
_ZN5ImGui34DockContextNewFrameUpdateUndockingEP12ImGuiContext:
14757|  90.2k|{
14758|  90.2k|    ImGuiContext& g = *ctx;
14759|  90.2k|    ImGuiDockContext* dc = &ctx->DockContext;
14760|  90.2k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (14760:9): [True: 0, False: 90.2k]
  ------------------
14761|      0|    {
14762|      0|        if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
  ------------------
  |  Branch (14762:13): [True: 0, False: 0]
  |  Branch (14762:40): [True: 0, False: 0]
  ------------------
14763|      0|            DockContextClearNodes(ctx, 0, true);
14764|      0|        return;
14765|      0|    }
14766|       |
14767|       |    // Setting NoSplit at runtime merges all nodes
14768|  90.2k|    if (g.IO.ConfigDockingNoSplit)
  ------------------
  |  Branch (14768:9): [True: 0, False: 90.2k]
  ------------------
14769|      0|        for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (14769:25): [True: 0, False: 0]
  ------------------
14770|      0|            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (14770:32): [True: 0, False: 0]
  ------------------
14771|      0|                if (node->IsRootNode() && node->IsSplitNode())
  ------------------
  |  Branch (14771:21): [True: 0, False: 0]
  |  Branch (14771:43): [True: 0, False: 0]
  ------------------
14772|      0|                {
14773|      0|                    DockBuilderRemoveNodeChildNodes(node->ID);
14774|       |                    //dc->WantFullRebuild = true;
14775|      0|                }
14776|       |
14777|       |    // Process full rebuild
14778|       |#if 0
14779|       |    if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
14780|       |        dc->WantFullRebuild = true;
14781|       |#endif
14782|  90.2k|    if (dc->WantFullRebuild)
  ------------------
  |  Branch (14782:9): [True: 0, False: 90.2k]
  ------------------
14783|      0|    {
14784|      0|        DockContextRebuildNodes(ctx);
14785|      0|        dc->WantFullRebuild = false;
14786|      0|    }
14787|       |
14788|       |    // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
14789|  90.2k|    for (int n = 0; n < dc->Requests.Size; n++)
  ------------------
  |  Branch (14789:21): [True: 0, False: 90.2k]
  ------------------
14790|      0|    {
14791|      0|        ImGuiDockRequest* req = &dc->Requests[n];
14792|      0|        if (req->Type == ImGuiDockRequestType_Undock && req->UndockTargetWindow)
  ------------------
  |  Branch (14792:13): [True: 0, False: 0]
  |  Branch (14792:57): [True: 0, False: 0]
  ------------------
14793|      0|            DockContextProcessUndockWindow(ctx, req->UndockTargetWindow);
14794|      0|        else if (req->Type == ImGuiDockRequestType_Undock && req->UndockTargetNode)
  ------------------
  |  Branch (14794:18): [True: 0, False: 0]
  |  Branch (14794:62): [True: 0, False: 0]
  ------------------
14795|      0|            DockContextProcessUndockNode(ctx, req->UndockTargetNode);
14796|      0|    }
14797|  90.2k|}
_ZN5ImGui32DockContextNewFrameUpdateDockingEP12ImGuiContext:
14801|  90.2k|{
14802|  90.2k|    ImGuiContext& g = *ctx;
14803|  90.2k|    ImGuiDockContext* dc  = &ctx->DockContext;
14804|  90.2k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (14804:9): [True: 0, False: 90.2k]
  ------------------
14805|      0|        return;
14806|       |
14807|       |    // [DEBUG] Store hovered dock node.
14808|       |    // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
14809|       |    // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
14810|  90.2k|    g.DebugHoveredDockNode = NULL;
14811|  90.2k|    if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
  ------------------
  |  Branch (14811:22): [True: 335, False: 89.8k]
  ------------------
14812|    335|    {
14813|    335|        if (hovered_window->DockNodeAsHost)
  ------------------
  |  Branch (14813:13): [True: 0, False: 335]
  ------------------
14814|      0|            g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
14815|    335|        else if (hovered_window->RootWindow->DockNode)
  ------------------
  |  Branch (14815:18): [True: 0, False: 335]
  ------------------
14816|      0|            g.DebugHoveredDockNode = hovered_window->RootWindow->DockNode;
14817|    335|    }
14818|       |
14819|       |    // Process Docking requests
14820|  90.2k|    for (int n = 0; n < dc->Requests.Size; n++)
  ------------------
  |  Branch (14820:21): [True: 0, False: 90.2k]
  ------------------
14821|      0|        if (dc->Requests[n].Type == ImGuiDockRequestType_Dock)
  ------------------
  |  Branch (14821:13): [True: 0, False: 0]
  ------------------
14822|      0|            DockContextProcessDock(ctx, &dc->Requests[n]);
14823|  90.2k|    dc->Requests.resize(0);
14824|       |
14825|       |    // Create windows for each automatic docking nodes
14826|       |    // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
14827|  90.2k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (14827:21): [True: 0, False: 90.2k]
  ------------------
14828|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (14828:28): [True: 0, False: 0]
  ------------------
14829|      0|            if (node->IsFloatingNode())
  ------------------
  |  Branch (14829:17): [True: 0, False: 0]
  ------------------
14830|      0|                DockNodeUpdate(node);
14831|  90.2k|}
_ZN5ImGui19DockContextEndFrameEP12ImGuiContext:
14834|  90.2k|{
14835|       |    // Draw backgrounds of node missing their window
14836|  90.2k|    ImGuiContext& g = *ctx;
14837|  90.2k|    ImGuiDockContext* dc = &g.DockContext;
14838|  90.2k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (14838:21): [True: 0, False: 90.2k]
  ------------------
14839|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (14839:28): [True: 0, False: 0]
  ------------------
14840|      0|            if (node->LastFrameActive == g.FrameCount && node->IsVisible && node->HostWindow && node->IsLeafNode() && !node->IsBgDrawnThisFrame)
  ------------------
  |  Branch (14840:17): [True: 0, False: 0]
  |  Branch (14840:58): [True: 0, False: 0]
  |  Branch (14840:77): [True: 0, False: 0]
  |  Branch (14840:97): [True: 0, False: 0]
  |  Branch (14840:119): [True: 0, False: 0]
  ------------------
14841|      0|            {
14842|      0|                ImRect bg_rect(node->Pos + ImVec2(0.0f, GetFrameHeight()), node->Pos + node->Size);
14843|      0|                ImDrawFlags bg_rounding_flags = CalcRoundingFlagsForRectInRect(bg_rect, node->HostWindow->Rect(), DOCKING_SPLITTER_SIZE);
14844|      0|                node->HostWindow->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1581|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
14845|      0|                node->HostWindow->DrawList->AddRectFilled(bg_rect.Min, bg_rect.Max, node->LastBgColor, node->HostWindow->WindowRounding, bg_rounding_flags);
14846|      0|            }
14847|  90.2k|}
_ZN5ImGui28GetWindowAlwaysWantOwnTabBarEP11ImGuiWindow:
17852|   180k|{
17853|   180k|    ImGuiContext& g = *GImGui;
17854|   180k|    if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
  ------------------
  |  Branch (17854:9): [True: 0, False: 180k]
  |  Branch (17854:43): [True: 0, False: 180k]
  ------------------
17855|      0|        if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
  ------------------
  |  Branch (17855:13): [True: 0, False: 0]
  ------------------
17856|      0|            if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
  ------------------
  |  Branch (17856:17): [True: 0, False: 0]
  ------------------
17857|      0|                return true;
17858|   180k|    return false;
17859|   180k|}
_ZN5ImGui27BeginDockableDragDropSourceEP11ImGuiWindow:
18032|    163|{
18033|    163|    ImGuiContext& g = *GImGui;
18034|    163|    IM_ASSERT(g.ActiveId == window->MoveId);
  ------------------
  |  |   23|    163|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18035|    163|    IM_ASSERT(g.MovingWindow == window);
  ------------------
  |  |   23|    163|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18036|    163|    IM_ASSERT(g.CurrentWindow == window);
  ------------------
  |  |   23|    163|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18037|       |
18038|    163|    g.LastItemData.ID = window->MoveId;
18039|    163|    window = window->RootWindowDockTree;
18040|    163|    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
  ------------------
  |  |   23|    163|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18041|    163|    bool is_drag_docking = (g.IO.ConfigDockingWithShift) || ImRect(0, 0, window->SizeFull.x, GetFrameHeight()).Contains(g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
  ------------------
  |  Branch (18041:28): [True: 0, False: 163]
  |  Branch (18041:61): [True: 42, False: 121]
  ------------------
18042|    163|    if (is_drag_docking && BeginDragDropSource(ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_SourceAutoExpirePayload))
  ------------------
  |  Branch (18042:9): [True: 42, False: 121]
  |  Branch (18042:28): [True: 40, False: 2]
  ------------------
18043|     40|    {
18044|     40|        SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
  ------------------
  |  |  211|     40|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
18045|     40|        EndDragDropSource();
18046|       |
18047|       |        // Store style overrides
18048|    280|        for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
  ------------------
  |  Branch (18048:31): [True: 240, False: 40]
  ------------------
18049|    240|            window->DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
18050|     40|    }
18051|    163|}
_ZN5ImGui27BeginDockableDragDropTargetEP11ImGuiWindow:
18054|     62|{
18055|     62|    ImGuiContext* ctx = GImGui;
18056|     62|    ImGuiContext& g = *ctx;
18057|       |
18058|       |    //IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
18059|     62|    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
  ------------------
  |  |   23|     62|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
18060|     62|    if (!g.DragDropActive)
  ------------------
  |  Branch (18060:9): [True: 0, False: 62]
  ------------------
18061|      0|        return;
18062|       |    //GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
18063|     62|    if (!BeginDragDropTargetCustom(window->Rect(), window->ID))
  ------------------
  |  Branch (18063:9): [True: 62, False: 0]
  ------------------
18064|     62|        return;
18065|       |
18066|       |    // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
18067|       |    // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
18068|      0|    const ImGuiPayload* payload = &g.DragDropPayload;
18069|      0|    if (!payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, *(ImGuiWindow**)payload->Data))
  ------------------
  |  |  211|      0|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (18069:9): [True: 0, False: 0]
  |  Branch (18069:60): [True: 0, False: 0]
  ------------------
18070|      0|    {
18071|      0|        EndDragDropTarget();
18072|      0|        return;
18073|      0|    }
18074|       |
18075|      0|    ImGuiWindow* payload_window = *(ImGuiWindow**)payload->Data;
18076|      0|    if (AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect))
  ------------------
  |  |  211|      0|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (18076:9): [True: 0, False: 0]
  ------------------
18077|      0|    {
18078|       |        // Select target node
18079|       |        // (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
18080|      0|        bool dock_into_floating_window = false;
18081|      0|        ImGuiDockNode* node = NULL;
18082|      0|        if (window->DockNodeAsHost)
  ------------------
  |  Branch (18082:13): [True: 0, False: 0]
  ------------------
18083|      0|        {
18084|       |            // Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
18085|      0|            node = DockNodeTreeFindVisibleNodeByPos(window->DockNodeAsHost, g.IO.MousePos);
18086|       |
18087|       |            // There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
18088|       |            // In this case we need to fallback into any leaf mode, possibly the central node.
18089|       |            // FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
18090|      0|            if (node && node->IsDockSpace() && node->IsRootNode())
  ------------------
  |  Branch (18090:17): [True: 0, False: 0]
  |  Branch (18090:25): [True: 0, False: 0]
  |  Branch (18090:48): [True: 0, False: 0]
  ------------------
18091|      0|                node = (node->CentralNode && node->IsLeafNode()) ? node->CentralNode : DockNodeTreeFindFallbackLeafNode(node);
  ------------------
  |  Branch (18091:25): [True: 0, False: 0]
  |  Branch (18091:46): [True: 0, False: 0]
  ------------------
18092|      0|        }
18093|      0|        else
18094|      0|        {
18095|      0|            if (window->DockNode)
  ------------------
  |  Branch (18095:17): [True: 0, False: 0]
  ------------------
18096|      0|                node = window->DockNode;
18097|      0|            else
18098|      0|                dock_into_floating_window = true; // Dock into a regular window
18099|      0|        }
18100|       |
18101|      0|        const ImRect explicit_target_rect = (node && node->TabBar && !node->IsHiddenTabBar() && !node->IsNoTabBar()) ? node->TabBar->BarRect : ImRect(window->Pos, window->Pos + ImVec2(window->Size.x, GetFrameHeight()));
  ------------------
  |  Branch (18101:46): [True: 0, False: 0]
  |  Branch (18101:54): [True: 0, False: 0]
  |  Branch (18101:70): [True: 0, False: 0]
  |  Branch (18101:97): [True: 0, False: 0]
  ------------------
18102|      0|        const bool is_explicit_target = g.IO.ConfigDockingWithShift || IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max);
  ------------------
  |  Branch (18102:41): [True: 0, False: 0]
  |  Branch (18102:72): [True: 0, False: 0]
  ------------------
18103|       |
18104|       |        // Preview docking request and find out split direction/ratio
18105|       |        //const bool do_preview = true;     // Ignore testing for payload->IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
18106|      0|        const bool do_preview = payload->IsPreview() || payload->IsDelivery();
  ------------------
  |  Branch (18106:33): [True: 0, False: 0]
  |  Branch (18106:57): [True: 0, False: 0]
  ------------------
18107|      0|        if (do_preview && (node != NULL || dock_into_floating_window))
  ------------------
  |  Branch (18107:13): [True: 0, False: 0]
  |  Branch (18107:28): [True: 0, False: 0]
  |  Branch (18107:44): [True: 0, False: 0]
  ------------------
18108|      0|        {
18109|       |            // If we have a non-leaf node it means we are hovering the border of a parent node, in which case only outer markers will appear.
18110|      0|            ImGuiDockPreviewData split_inner;
18111|      0|            ImGuiDockPreviewData split_outer;
18112|      0|            ImGuiDockPreviewData* split_data = &split_inner;
18113|      0|            if (node && (node->ParentNode || node->IsCentralNode() || !node->IsLeafNode()))
  ------------------
  |  Branch (18113:17): [True: 0, False: 0]
  |  Branch (18113:26): [True: 0, False: 0]
  |  Branch (18113:46): [True: 0, False: 0]
  |  Branch (18113:71): [True: 0, False: 0]
  ------------------
18114|      0|                if (ImGuiDockNode* root_node = DockNodeGetRootNode(node))
  ------------------
  |  Branch (18114:36): [True: 0, False: 0]
  ------------------
18115|      0|                {
18116|      0|                    DockNodePreviewDockSetup(window, root_node, payload_window, NULL, &split_outer, is_explicit_target, true);
18117|      0|                    if (split_outer.IsSplitDirExplicit)
  ------------------
  |  Branch (18117:25): [True: 0, False: 0]
  ------------------
18118|      0|                        split_data = &split_outer;
18119|      0|                }
18120|      0|            if (!node || node->IsLeafNode())
  ------------------
  |  Branch (18120:17): [True: 0, False: 0]
  |  Branch (18120:26): [True: 0, False: 0]
  ------------------
18121|      0|                DockNodePreviewDockSetup(window, node, payload_window, NULL, &split_inner, is_explicit_target, false);
18122|      0|            if (split_data == &split_outer)
  ------------------
  |  Branch (18122:17): [True: 0, False: 0]
  ------------------
18123|      0|                split_inner.IsDropAllowed = false;
18124|       |
18125|       |            // Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
18126|      0|            DockNodePreviewDockRender(window, node, payload_window, &split_inner);
18127|      0|            DockNodePreviewDockRender(window, node, payload_window, &split_outer);
18128|       |
18129|       |            // Queue docking request
18130|      0|            if (split_data->IsDropAllowed && payload->IsDelivery())
  ------------------
  |  Branch (18130:17): [True: 0, False: 0]
  |  Branch (18130:46): [True: 0, False: 0]
  ------------------
18131|      0|                DockContextQueueDock(ctx, window, split_data->SplitNode, payload_window, split_data->SplitDir, split_data->SplitRatio, split_data == &split_outer);
18132|      0|        }
18133|      0|    }
18134|      0|    EndDragDropTarget();
18135|      0|}
imgui.cpp:_ZL20FindLatestInputEvent19ImGuiInputEventTypei:
 1366|  44.0k|{
 1367|  44.0k|    ImGuiContext& g = *GImGui;
 1368|  74.5k|    for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (1368:47): [True: 40.6k, False: 33.8k]
  ------------------
 1369|  40.6k|    {
 1370|  40.6k|        ImGuiInputEvent* e = &g.InputEventsQueue[n];
 1371|  40.6k|        if (e->Type != type)
  ------------------
  |  Branch (1371:13): [True: 25.6k, False: 15.0k]
  ------------------
 1372|  25.6k|            continue;
 1373|  15.0k|        if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
  ------------------
  |  Branch (1373:13): [True: 392, False: 14.6k]
  |  Branch (1373:48): [True: 287, False: 105]
  ------------------
 1374|    287|            continue;
 1375|  14.7k|        if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
  ------------------
  |  Branch (1375:13): [True: 8.97k, False: 5.78k]
  |  Branch (1375:56): [True: 4.57k, False: 4.40k]
  ------------------
 1376|  4.57k|            continue;
 1377|  10.1k|        return e;
 1378|  14.7k|    }
 1379|  33.8k|    return NULL;
 1380|  44.0k|}
imgui.cpp:_ZL10LowerBoundR8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEj:
 2316|   180k|{
 2317|   180k|    ImGuiStorage::ImGuiStoragePair* first = data.Data;
 2318|   180k|    ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
 2319|   180k|    size_t count = (size_t)(last - first);
 2320|   542k|    while (count > 0)
  ------------------
  |  Branch (2320:12): [True: 361k, False: 180k]
  ------------------
 2321|   361k|    {
 2322|   361k|        size_t count2 = count >> 1;
 2323|   361k|        ImGuiStorage::ImGuiStoragePair* mid = first + count2;
 2324|   361k|        if (mid->key < key)
  ------------------
  |  Branch (2324:13): [True: 90.5k, False: 271k]
  ------------------
 2325|  90.5k|        {
 2326|  90.5k|            first = ++mid;
 2327|  90.5k|            count -= count2 + 1;
 2328|  90.5k|        }
 2329|   271k|        else
 2330|   271k|        {
 2331|   271k|            count = count2;
 2332|   271k|        }
 2333|   361k|    }
 2334|   180k|    return first;
 2335|   180k|}
imgui.cpp:_ZL15GetStyleVarInfoi:
 3099|   180k|{
 3100|   180k|    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3101|   180k|    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3102|   180k|    return &GStyleVarInfo[idx];
 3103|   180k|}
_ZNK17ImGuiStyleVarInfo9GetVarPtrEP10ImGuiStyle:
 3058|   180k|    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
imgui.cpp:_ZL13MallocWrappermPv:
 1098|  1.20k|static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
  ------------------
  |  |   88|  1.20k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL11FreeWrapperPvS_:
 1099|  1.16k|static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
  ------------------
  |  |   88|  1.16k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL24IsWindowContentHoverableP11ImGuiWindowi:
 3912|    334|{
 3913|       |    // An active popup disable hovering on other windows (apart from its own children)
 3914|       |    // FIXME-OPT: This could be cached/stored within the window.
 3915|    334|    ImGuiContext& g = *GImGui;
 3916|    334|    if (g.NavWindow)
  ------------------
  |  Branch (3916:9): [True: 103, False: 231]
  ------------------
 3917|    103|        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindowDockTree)
  ------------------
  |  Branch (3917:26): [True: 103, False: 0]
  ------------------
 3918|    103|            if (focused_root_window->WasActive && focused_root_window != window->RootWindowDockTree)
  ------------------
  |  Branch (3918:17): [True: 103, False: 0]
  |  Branch (3918:51): [True: 0, False: 103]
  ------------------
 3919|      0|            {
 3920|       |                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
 3921|       |                // NB: The 'else' is important because Modal windows are also Popups.
 3922|      0|                bool want_inhibit = false;
 3923|      0|                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (3923:21): [True: 0, False: 0]
  ------------------
 3924|      0|                    want_inhibit = true;
 3925|      0|                else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
  ------------------
  |  Branch (3925:26): [True: 0, False: 0]
  |  Branch (3925:83): [True: 0, False: 0]
  ------------------
 3926|      0|                    want_inhibit = true;
 3927|       |
 3928|       |                // Inhibit hover unless the window is within the stack of our modal/popup
 3929|      0|                if (want_inhibit)
  ------------------
  |  Branch (3929:21): [True: 0, False: 0]
  ------------------
 3930|      0|                    if (!ImGui::IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))
  ------------------
  |  Branch (3930:25): [True: 0, False: 0]
  ------------------
 3931|      0|                        return false;
 3932|      0|            }
 3933|       |
 3934|       |    // Filter by viewport
 3935|    334|    if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (3935:9): [True: 0, False: 334]
  ------------------
 3936|      0|        if (g.MovingWindow == NULL || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree)
  ------------------
  |  Branch (3936:13): [True: 0, False: 0]
  |  Branch (3936:39): [True: 0, False: 0]
  ------------------
 3937|      0|            return false;
 3938|       |
 3939|    334|    return true;
 3940|    334|}
imgui.cpp:_ZL24IsWindowActiveAndVisibleP11ImGuiWindow:
 4429|   271k|{
 4430|   271k|    return (window->Active) && (!window->Hidden);
  ------------------
  |  Branch (4430:12): [True: 90.8k, False: 180k]
  |  Branch (4430:32): [True: 90.8k, False: 2]
  ------------------
 4431|   271k|}
imgui.cpp:_ZL21GetWindowDisplayLayerP11ImGuiWindow:
 4855|  90.2k|{
 4856|  90.2k|    return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
  ------------------
  |  Branch (4856:12): [True: 0, False: 90.2k]
  ------------------
 4857|  90.2k|}
imgui.cpp:_ZL21AddWindowToSortBufferP8ImVectorIP11ImGuiWindowES1_:
 4788|   270k|{
 4789|   270k|    out_sorted_windows->push_back(window);
 4790|   270k|    if (window->Active)
  ------------------
  |  Branch (4790:9): [True: 90.5k, False: 180k]
  ------------------
 4791|  90.5k|    {
 4792|  90.5k|        int count = window->DC.ChildWindows.Size;
 4793|  90.5k|        ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
 4794|  90.8k|        for (int i = 0; i < count; i++)
  ------------------
  |  Branch (4794:25): [True: 323, False: 90.5k]
  ------------------
 4795|    323|        {
 4796|    323|            ImGuiWindow* child = window->DC.ChildWindows[i];
 4797|    323|            if (child->Active)
  ------------------
  |  Branch (4797:17): [True: 323, False: 0]
  ------------------
 4798|    323|                AddWindowToSortBuffer(out_sorted_windows, child);
 4799|    323|        }
 4800|  90.5k|    }
 4801|   270k|}
imgui.cpp:_ZL21AddDrawListToDrawDataP8ImVectorIP10ImDrawListES1_:
 4804|  90.5k|{
 4805|  90.5k|    if (draw_list->CmdBuffer.Size == 0)
  ------------------
  |  Branch (4805:9): [True: 0, False: 90.5k]
  ------------------
 4806|      0|        return;
 4807|  90.5k|    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
  ------------------
  |  Branch (4807:9): [True: 89.9k, False: 641]
  |  Branch (4807:43): [True: 3, False: 89.9k]
  |  Branch (4807:85): [True: 3, False: 0]
  ------------------
 4808|      3|        return;
 4809|       |
 4810|       |    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
 4811|       |    // May trigger for you if you are using PrimXXX functions incorrectly.
 4812|  90.5k|    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  90.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4813|  90.5k|    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
  ------------------
  |  |   23|  90.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4814|  90.5k|    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (4814:9): [True: 90.5k, False: 0]
  ------------------
 4815|  90.5k|        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  90.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4816|       |
 4817|       |    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
 4818|       |    // If this assert triggers because you are drawing lots of stuff manually:
 4819|       |    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
 4820|       |    //   Be mindful that the ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
 4821|       |    // - If you want large meshes with more than 64K vertices, you can either:
 4822|       |    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
 4823|       |    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
 4824|       |    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
 4825|       |    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
 4826|       |    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
 4827|       |    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
 4828|       |    //       Your own engine or render API may use different parameters or function calls to specify index sizes.
 4829|       |    //       2 and 4 bytes indices are generally supported by most graphics API.
 4830|       |    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
 4831|       |    //   the 64K limit to split your draw commands in multiple draw lists.
 4832|  90.5k|    if (sizeof(ImDrawIdx) == 2)
  ------------------
  |  Branch (4832:9): [Folded - Ignored]
  ------------------
 4833|  90.5k|        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
  ------------------
  |  |   23|  90.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4834|       |
 4835|  90.5k|    out_list->push_back(draw_list);
 4836|  90.5k|}
imgui.cpp:_ZL23AddRootWindowToDrawDataP11ImGuiWindow:
 4861|  90.2k|{
 4862|  90.2k|    AddWindowToDrawData(window, GetWindowDisplayLayer(window));
 4863|  90.2k|}
imgui.cpp:_ZL19AddWindowToDrawDataP11ImGuiWindowi:
 4839|  90.5k|{
 4840|  90.5k|    ImGuiContext& g = *GImGui;
 4841|  90.5k|    ImGuiViewportP* viewport = window->Viewport;
 4842|  90.5k|    g.IO.MetricsRenderWindows++;
 4843|  90.5k|    if (window->Flags & ImGuiWindowFlags_DockNodeHost)
  ------------------
  |  Branch (4843:9): [True: 0, False: 90.5k]
  ------------------
 4844|      0|        window->DrawList->ChannelsMerge();
 4845|  90.5k|    AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[layer], window->DrawList);
 4846|  90.8k|    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
  ------------------
  |  Branch (4846:21): [True: 322, False: 90.5k]
  ------------------
 4847|    322|    {
 4848|    322|        ImGuiWindow* child = window->DC.ChildWindows[i];
 4849|    322|        if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
  ------------------
  |  Branch (4849:13): [True: 322, False: 0]
  ------------------
 4850|    322|            AddWindowToDrawData(child, layer);
 4851|    322|    }
 4852|  90.5k|}
imgui.cpp:_ZN5ImGuiL23RenderDimmedBackgroundsEv:
 4996|  90.2k|{
 4997|  90.2k|    ImGuiContext& g = *GImGui;
 4998|  90.2k|    ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
 4999|  90.2k|    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (4999:9): [True: 90.2k, False: 0]
  |  Branch (4999:33): [True: 90.2k, False: 0]
  ------------------
 5000|  90.2k|        return;
 5001|      0|    const bool dim_bg_for_modal = (modal_window != NULL);
 5002|      0|    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
  ------------------
  |  Branch (5002:42): [True: 0, False: 0]
  |  Branch (5002:78): [True: 0, False: 0]
  ------------------
 5003|      0|    if (!dim_bg_for_modal && !dim_bg_for_window_list)
  ------------------
  |  Branch (5003:9): [True: 0, False: 0]
  |  Branch (5003:30): [True: 0, False: 0]
  ------------------
 5004|      0|        return;
 5005|       |
 5006|      0|    ImGuiViewport* viewports_already_dimmed[2] = { NULL, NULL };
 5007|      0|    if (dim_bg_for_modal)
  ------------------
  |  Branch (5007:9): [True: 0, False: 0]
  ------------------
 5008|      0|    {
 5009|       |        // Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
 5010|      0|        ImGuiWindow* dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);
 5011|      0|        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(ImGuiCol_ModalWindowDimBg, g.DimBgRatio));
 5012|      0|        viewports_already_dimmed[0] = modal_window->Viewport;
 5013|      0|    }
 5014|      0|    else if (dim_bg_for_window_list)
  ------------------
  |  Branch (5014:14): [True: 0, False: 0]
  ------------------
 5015|      0|    {
 5016|       |        // Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
 5017|      0|        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5018|      0|        if (g.NavWindowingListWindow != NULL && g.NavWindowingListWindow->Viewport && g.NavWindowingListWindow->Viewport != g.NavWindowingTargetAnim->Viewport)
  ------------------
  |  Branch (5018:13): [True: 0, False: 0]
  |  Branch (5018:49): [True: 0, False: 0]
  |  Branch (5018:87): [True: 0, False: 0]
  ------------------
 5019|      0|            RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5020|      0|        viewports_already_dimmed[0] = g.NavWindowingTargetAnim->Viewport;
 5021|      0|        viewports_already_dimmed[1] = g.NavWindowingListWindow ? g.NavWindowingListWindow->Viewport : NULL;
  ------------------
  |  Branch (5021:39): [True: 0, False: 0]
  ------------------
 5022|       |
 5023|       |        // Draw border around CTRL+Tab target window
 5024|      0|        ImGuiWindow* window = g.NavWindowingTargetAnim;
 5025|      0|        ImGuiViewport* viewport = window->Viewport;
 5026|      0|        float distance = g.FontSize;
 5027|      0|        ImRect bb = window->Rect();
 5028|      0|        bb.Expand(distance);
 5029|      0|        if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
  ------------------
  |  Branch (5029:13): [True: 0, False: 0]
  |  Branch (5029:50): [True: 0, False: 0]
  ------------------
 5030|      0|            bb.Expand(-distance - 1.0f); // If a window fits the entire viewport, adjust its highlight inward
 5031|      0|        if (window->DrawList->CmdBuffer.Size == 0)
  ------------------
  |  Branch (5031:13): [True: 0, False: 0]
  ------------------
 5032|      0|            window->DrawList->AddDrawCmd();
 5033|      0|        window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);
 5034|      0|        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);
 5035|      0|        window->DrawList->PopClipRect();
 5036|      0|    }
 5037|       |
 5038|       |    // Draw dimming background on _other_ viewports than the ones our windows are in
 5039|      0|    for (int viewport_n = 0; viewport_n < g.Viewports.Size; viewport_n++)
  ------------------
  |  Branch (5039:30): [True: 0, False: 0]
  ------------------
 5040|      0|    {
 5041|      0|        ImGuiViewportP* viewport = g.Viewports[viewport_n];
 5042|      0|        if (viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1])
  ------------------
  |  Branch (5042:13): [True: 0, False: 0]
  |  Branch (5042:56): [True: 0, False: 0]
  ------------------
 5043|      0|            continue;
 5044|      0|        if (modal_window && viewport->Window && IsWindowAbove(viewport->Window, modal_window))
  ------------------
  |  Branch (5044:13): [True: 0, False: 0]
  |  Branch (5044:29): [True: 0, False: 0]
  |  Branch (5044:49): [True: 0, False: 0]
  ------------------
 5045|      0|            continue;
 5046|      0|        ImDrawList* draw_list = GetForegroundDrawList(viewport);
 5047|      0|        const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
  ------------------
  |  Branch (5047:46): [True: 0, False: 0]
  ------------------
 5048|      0|        draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
 5049|      0|    }
 5050|      0|}
imgui.cpp:_ZL21SetupViewportDrawDataP14ImGuiViewportPP8ImVectorIP10ImDrawListE:
 4884|  90.2k|{
 4885|       |    // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
 4886|       |    // and to allow applications/backends to easily skip rendering.
 4887|       |    // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
 4888|       |    // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
 4889|       |    // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
 4890|  90.2k|    const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_Minimized) != 0;
 4891|       |
 4892|  90.2k|    ImGuiIO& io = ImGui::GetIO();
 4893|  90.2k|    ImDrawData* draw_data = &viewport->DrawDataP;
 4894|  90.2k|    viewport->DrawData = draw_data; // Make publicly accessible
 4895|  90.2k|    draw_data->Valid = true;
 4896|  90.2k|    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
  ------------------
  |  Branch (4896:27): [True: 90.2k, False: 1]
  ------------------
 4897|  90.2k|    draw_data->CmdListsCount = draw_lists->Size;
 4898|  90.2k|    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
 4899|  90.2k|    draw_data->DisplayPos = viewport->Pos;
 4900|  90.2k|    draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
  ------------------
  |  Branch (4900:30): [True: 0, False: 90.2k]
  ------------------
 4901|  90.2k|    draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
 4902|  90.2k|    draw_data->OwnerViewport = viewport;
 4903|   180k|    for (int n = 0; n < draw_lists->Size; n++)
  ------------------
  |  Branch (4903:21): [True: 90.5k, False: 90.2k]
  ------------------
 4904|  90.5k|    {
 4905|  90.5k|        ImDrawList* draw_list = draw_lists->Data[n];
 4906|  90.5k|        draw_list->_PopUnusedDrawCmd();
 4907|  90.5k|        draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
 4908|  90.5k|        draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
 4909|  90.5k|    }
 4910|  90.2k|}
imgui.cpp:_ZL17FindHoveredWindowv:
 5246|  90.2k|{
 5247|  90.2k|    ImGuiContext& g = *GImGui;
 5248|       |
 5249|       |    // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
 5250|  90.2k|    ImGuiViewportP* moving_window_viewport = g.MovingWindow ? g.MovingWindow->Viewport : NULL;
  ------------------
  |  Branch (5250:46): [True: 173, False: 90.0k]
  ------------------
 5251|  90.2k|    if (g.MovingWindow)
  ------------------
  |  Branch (5251:9): [True: 173, False: 90.0k]
  ------------------
 5252|    173|        g.MovingWindow->Viewport = g.MouseViewport;
 5253|       |
 5254|  90.2k|    ImGuiWindow* hovered_window = NULL;
 5255|  90.2k|    ImGuiWindow* hovered_window_ignoring_moving_window = NULL;
 5256|  90.2k|    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (5256:9): [True: 173, False: 90.0k]
  |  Branch (5256:27): [True: 173, False: 0]
  ------------------
 5257|    173|        hovered_window = g.MovingWindow;
 5258|       |
 5259|  90.2k|    ImVec2 padding_regular = g.Style.TouchExtraPadding;
 5260|  90.2k|    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
  ------------------
  |  Branch (5260:33): [True: 0, False: 90.2k]
  ------------------
 5261|   359k|    for (int i = g.Windows.Size - 1; i >= 0; i--)
  ------------------
  |  Branch (5261:38): [True: 269k, False: 89.5k]
  ------------------
 5262|   269k|    {
 5263|   269k|        ImGuiWindow* window = g.Windows[i];
 5264|   269k|        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5265|   269k|        if (!window->Active || window->Hidden)
  ------------------
  |  Branch (5265:13): [True: 179k, False: 90.5k]
  |  Branch (5265:32): [True: 2, False: 90.5k]
  ------------------
 5266|   179k|            continue;
 5267|  90.5k|        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
  ------------------
  |  Branch (5267:13): [True: 0, False: 90.5k]
  ------------------
 5268|      0|            continue;
 5269|  90.5k|        IM_ASSERT(window->Viewport);
  ------------------
  |  |   23|  90.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5270|  90.5k|        if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (5270:13): [True: 0, False: 90.5k]
  ------------------
 5271|      0|            continue;
 5272|       |
 5273|       |        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
 5274|  90.5k|        ImRect bb(window->OuterRectClipped);
 5275|  90.5k|        if (window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
  ------------------
  |  Branch (5275:13): [True: 322, False: 90.2k]
  ------------------
 5276|    322|            bb.Expand(padding_regular);
 5277|  90.2k|        else
 5278|  90.2k|            bb.Expand(padding_for_resize);
 5279|  90.5k|        if (!bb.Contains(g.IO.MousePos))
  ------------------
  |  Branch (5279:13): [True: 89.7k, False: 756]
  ------------------
 5280|  89.7k|            continue;
 5281|       |
 5282|       |        // Support for one rectangular hole in any given window
 5283|       |        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
 5284|    756|        if (window->HitTestHoleSize.x != 0)
  ------------------
  |  Branch (5284:13): [True: 0, False: 756]
  ------------------
 5285|      0|        {
 5286|      0|            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
 5287|      0|            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
 5288|      0|            if (ImRect(hole_pos, hole_pos + hole_size).Contains(g.IO.MousePos))
  ------------------
  |  Branch (5288:17): [True: 0, False: 0]
  ------------------
 5289|      0|                continue;
 5290|      0|        }
 5291|       |
 5292|    756|        if (hovered_window == NULL)
  ------------------
  |  Branch (5292:13): [True: 720, False: 36]
  ------------------
 5293|    720|            hovered_window = window;
 5294|    756|        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5295|    756|        if (hovered_window_ignoring_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
  ------------------
  |  Branch (5295:13): [True: 756, False: 0]
  |  Branch (5295:63): [True: 720, False: 36]
  |  Branch (5295:82): [True: 0, False: 36]
  ------------------
 5296|    720|            hovered_window_ignoring_moving_window = window;
 5297|    756|        if (hovered_window && hovered_window_ignoring_moving_window)
  ------------------
  |  Branch (5297:13): [True: 756, False: 0]
  |  Branch (5297:31): [True: 720, False: 36]
  ------------------
 5298|    720|            break;
 5299|    756|    }
 5300|       |
 5301|  90.2k|    g.HoveredWindow = hovered_window;
 5302|  90.2k|    g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;
 5303|       |
 5304|  90.2k|    if (g.MovingWindow)
  ------------------
  |  Branch (5304:9): [True: 173, False: 90.0k]
  ------------------
 5305|    173|        g.MovingWindow->Viewport = moving_window_viewport;
 5306|  90.2k|}
imgui.cpp:_ZL22CalcWindowContentSizesP11ImGuiWindowP6ImVec2S2_:
 5740|   180k|{
 5741|   180k|    bool preserve_old_content_sizes = false;
 5742|   180k|    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
  ------------------
  |  Branch (5742:9): [True: 89.9k, False: 90.8k]
  |  Branch (5742:30): [True: 89.9k, False: 0]
  |  Branch (5742:61): [True: 89.9k, False: 0]
  ------------------
 5743|  89.9k|        preserve_old_content_sizes = true;
 5744|  90.8k|    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (5744:14): [True: 2, False: 90.8k]
  |  Branch (5744:32): [True: 0, False: 2]
  |  Branch (5744:76): [True: 0, False: 0]
  ------------------
 5745|      0|        preserve_old_content_sizes = true;
 5746|   180k|    if (preserve_old_content_sizes)
  ------------------
  |  Branch (5746:9): [True: 89.9k, False: 90.8k]
  ------------------
 5747|  89.9k|    {
 5748|  89.9k|        *content_size_current = window->ContentSize;
 5749|  89.9k|        *content_size_ideal = window->ContentSizeIdeal;
 5750|  89.9k|        return;
 5751|  89.9k|    }
 5752|       |
 5753|  90.8k|    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_FLOOR(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
  ------------------
  |  |  269|   181k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5753:31): [True: 0, False: 90.8k]
  ------------------
 5754|  90.8k|    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_FLOOR(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
  ------------------
  |  |  269|   181k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5754:31): [True: 0, False: 90.8k]
  ------------------
 5755|  90.8k|    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_FLOOR(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
  ------------------
  |  |  269|   181k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5755:29): [True: 0, False: 90.8k]
  ------------------
 5756|  90.8k|    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_FLOOR(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
  ------------------
  |  |  269|   181k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  |  Branch (5756:29): [True: 0, False: 90.8k]
  ------------------
 5757|  90.8k|}
imgui.cpp:_ZL21CalcWindowAutoFitSizeP11ImGuiWindowRK6ImVec2:
 5760|   180k|{
 5761|   180k|    ImGuiContext& g = *GImGui;
 5762|   180k|    ImGuiStyle& style = g.Style;
 5763|   180k|    const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
 5764|   180k|    const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
 5765|   180k|    ImVec2 size_pad = window->WindowPadding * 2.0f;
 5766|   180k|    ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
 5767|   180k|    if (window->Flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (5767:9): [True: 0, False: 180k]
  ------------------
 5768|      0|    {
 5769|       |        // Tooltip always resize
 5770|      0|        return size_desired;
 5771|      0|    }
 5772|   180k|    else
 5773|   180k|    {
 5774|       |        // Maximum window size is determined by the viewport size or monitor size
 5775|   180k|        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
 5776|   180k|        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
 5777|   180k|        ImVec2 size_min = style.WindowMinSize;
 5778|   180k|        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
  ------------------
  |  Branch (5778:13): [True: 0, False: 180k]
  |  Branch (5778:25): [True: 0, False: 180k]
  ------------------
 5779|      0|            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));
 5780|       |
 5781|   180k|        ImVec2 avail_size = window->Viewport->WorkSize;
 5782|   180k|        if (window->ViewportOwned)
  ------------------
  |  Branch (5782:13): [True: 0, False: 180k]
  ------------------
 5783|      0|            avail_size = ImVec2(FLT_MAX, FLT_MAX);
 5784|   180k|        const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
 5785|   180k|        if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
  ------------------
  |  Branch (5785:13): [True: 0, False: 180k]
  |  Branch (5785:33): [True: 0, False: 0]
  ------------------
 5786|      0|            avail_size = g.PlatformIO.Monitors[monitor_idx].WorkSize;
 5787|   180k|        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, avail_size - style.DisplaySafeAreaPadding * 2.0f));
 5788|       |
 5789|       |        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
 5790|       |        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
 5791|   180k|        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 5792|   180k|        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x  && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
  ------------------
  |  Branch (5792:39): [True: 0, False: 180k]
  |  Branch (5792:141): [True: 0, False: 0]
  |  Branch (5792:192): [True: 0, False: 0]
  |  Branch (5792:251): [True: 323, False: 180k]
  ------------------
 5793|   180k|        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
  ------------------
  |  Branch (5793:39): [True: 26, False: 180k]
  |  Branch (5793:140): [True: 26, False: 0]
  |  Branch (5793:192): [True: 0, False: 180k]
  ------------------
 5794|   180k|        if (will_have_scrollbar_x)
  ------------------
  |  Branch (5794:13): [True: 323, False: 180k]
  ------------------
 5795|    323|            size_auto_fit.y += style.ScrollbarSize;
 5796|   180k|        if (will_have_scrollbar_y)
  ------------------
  |  Branch (5796:13): [True: 26, False: 180k]
  ------------------
 5797|     26|            size_auto_fit.x += style.ScrollbarSize;
 5798|   180k|        return size_auto_fit;
 5799|   180k|    }
 5800|   180k|}
imgui.cpp:_ZL29CalcWindowSizeAfterConstraintP11ImGuiWindowRK6ImVec2:
 5705|   361k|{
 5706|   361k|    ImGuiContext& g = *GImGui;
 5707|   361k|    ImVec2 new_size = size_desired;
 5708|   361k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
  ------------------
  |  Branch (5708:9): [True: 0, False: 361k]
  ------------------
 5709|      0|    {
 5710|       |        // Using -1,-1 on either X/Y axis to preserve the current size.
 5711|      0|        ImRect cr = g.NextWindowData.SizeConstraintRect;
 5712|      0|        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
  ------------------
  |  Branch (5712:23): [True: 0, False: 0]
  |  Branch (5712:40): [True: 0, False: 0]
  ------------------
 5713|      0|        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
  ------------------
  |  Branch (5713:23): [True: 0, False: 0]
  |  Branch (5713:40): [True: 0, False: 0]
  ------------------
 5714|      0|        if (g.NextWindowData.SizeCallback)
  ------------------
  |  Branch (5714:13): [True: 0, False: 0]
  ------------------
 5715|      0|        {
 5716|      0|            ImGuiSizeCallbackData data;
 5717|      0|            data.UserData = g.NextWindowData.SizeCallbackUserData;
 5718|      0|            data.Pos = window->Pos;
 5719|      0|            data.CurrentSize = window->SizeFull;
 5720|      0|            data.DesiredSize = new_size;
 5721|      0|            g.NextWindowData.SizeCallback(&data);
 5722|      0|            new_size = data.DesiredSize;
 5723|      0|        }
 5724|      0|        new_size.x = IM_FLOOR(new_size.x);
  ------------------
  |  |  269|      0|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5725|      0|        new_size.y = IM_FLOOR(new_size.y);
  ------------------
  |  |  269|      0|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5726|      0|    }
 5727|       |
 5728|       |    // Minimum size
 5729|   361k|    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
  ------------------
  |  Branch (5729:9): [True: 360k, False: 646]
  ------------------
 5730|   360k|    {
 5731|   360k|        ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
 5732|   360k|        new_size = ImMax(new_size, g.Style.WindowMinSize);
 5733|   360k|        const float minimum_height = window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f);
 5734|   360k|        new_size.y = ImMax(new_size.y, minimum_height); // Reduce artifacts with very small windows
 5735|   360k|    }
 5736|   361k|    return new_size;
 5737|   361k|}
imgui.cpp:_ZL30GetWindowForTitleAndMenuHeightP11ImGuiWindow:
 5700|   360k|{
 5701|   360k|    return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
  ------------------
  |  Branch (5701:13): [True: 0, False: 360k]
  |  Branch (5701:39): [True: 0, False: 0]
  ------------------
 5702|   360k|}
imgui.cpp:_ZL15CreateNewWindowPKci:
 5671|      3|{
 5672|       |    // Create window the first time
 5673|       |    //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
 5674|      3|    ImGuiContext& g = *GImGui;
 5675|      3|    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
  ------------------
  |  | 1823|      6|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 5676|      3|    window->Flags = flags;
 5677|      3|    g.WindowsById.SetVoidPtr(window->ID, window);
 5678|       |
 5679|      3|    ImGuiWindowSettings* settings = NULL;
 5680|      3|    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (5680:9): [True: 2, False: 1]
  ------------------
 5681|      2|        if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)
  ------------------
  |  Branch (5681:13): [True: 0, False: 2]
  ------------------
 5682|      0|            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
 5683|       |
 5684|      3|    InitOrLoadWindowSettings(window, settings);
 5685|       |
 5686|      3|    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
  ------------------
  |  Branch (5686:9): [True: 0, False: 3]
  ------------------
 5687|      0|        g.Windows.push_front(window); // Quite slow but rare and only once
 5688|      3|    else
 5689|      3|        g.Windows.push_back(window);
 5690|       |
 5691|      3|    return window;
 5692|      3|}
imgui.cpp:_ZL28UpdateWindowInFocusOrderListP11ImGuiWindowbi:
 5617|   180k|{
 5618|   180k|    ImGuiContext& g = *GImGui;
 5619|       |
 5620|   180k|    const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
  ------------------
  |  Branch (5620:40): [True: 323, False: 180k]
  |  Branch (5620:92): [True: 323, False: 0]
  |  Branch (5620:137): [True: 0, False: 0]
  ------------------
 5621|   180k|    const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
 5622|   180k|    if ((just_created || child_flag_changed) && !new_is_explicit_child)
  ------------------
  |  Branch (5622:10): [True: 3, False: 180k]
  |  Branch (5622:26): [True: 0, False: 180k]
  |  Branch (5622:49): [True: 2, False: 1]
  ------------------
 5623|      2|    {
 5624|      2|        IM_ASSERT(!g.WindowsFocusOrder.contains(window));
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5625|      2|        g.WindowsFocusOrder.push_back(window);
 5626|      2|        window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
 5627|      2|    }
 5628|   180k|    else if (!just_created && child_flag_changed && new_is_explicit_child)
  ------------------
  |  Branch (5628:14): [True: 180k, False: 1]
  |  Branch (5628:31): [True: 0, False: 180k]
  |  Branch (5628:53): [True: 0, False: 0]
  ------------------
 5629|      0|    {
 5630|      0|        IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5631|      0|        for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
  ------------------
  |  Branch (5631:46): [True: 0, False: 0]
  ------------------
 5632|      0|            g.WindowsFocusOrder[n]->FocusOrder--;
 5633|      0|        g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
 5634|      0|        window->FocusOrder = -1;
 5635|      0|    }
 5636|   180k|    window->IsExplicitChild = new_is_explicit_child;
 5637|   180k|}
imgui.cpp:_ZL28SetWindowConditionAllowFlagsP11ImGuiWindowib:
 5580|     12|{
 5581|     12|    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
  ------------------
  |  Branch (5581:44): [True: 6, False: 6]
  ------------------
 5582|     12|    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
  ------------------
  |  Branch (5582:44): [True: 6, False: 6]
  ------------------
 5583|     12|    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
  ------------------
  |  Branch (5583:44): [True: 6, False: 6]
  ------------------
 5584|     12|    window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
  ------------------
  |  Branch (5584:44): [True: 6, False: 6]
  ------------------
 5585|     12|}
imgui.cpp:_ZL16SetCurrentWindowP11ImGuiWindow:
 3777|   361k|{
 3778|   361k|    ImGuiContext& g = *GImGui;
 3779|   361k|    g.CurrentWindow = window;
 3780|   361k|    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
  ------------------
  |  Branch (3780:22): [True: 271k, False: 90.2k]
  |  Branch (3780:32): [True: 0, False: 271k]
  ------------------
 3781|   361k|    if (window)
  ------------------
  |  Branch (3781:9): [True: 271k, False: 90.2k]
  ------------------
 3782|   271k|        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
 3783|   361k|}
imgui.cpp:_ZL14ClampWindowPosP11ImGuiWindowRK6ImRect:
 6052|   180k|{
 6053|   180k|    ImGuiContext& g = *GImGui;
 6054|   180k|    ImVec2 size_for_clamping = window->Size;
 6055|   180k|    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && (!(window->Flags & ImGuiWindowFlags_NoTitleBar) || window->DockNodeAsHost))
  ------------------
  |  Branch (6055:9): [True: 0, False: 180k]
  |  Branch (6055:52): [True: 0, False: 0]
  |  Branch (6055:102): [True: 0, False: 0]
  ------------------
 6056|      0|        size_for_clamping.y = ImGui::GetFrameHeight(); // Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
 6057|   180k|    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
 6058|   180k|}
imgui.cpp:_ZN5ImGuiL24UpdateWindowManualResizeEP11ImGuiWindowRK6ImVec2PiiPjRK6ImRect:
 5902|  90.8k|{
 5903|  90.8k|    ImGuiContext& g = *GImGui;
 5904|  90.8k|    ImGuiWindowFlags flags = window->Flags;
 5905|       |
 5906|  90.8k|    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (5906:9): [True: 323, False: 90.5k]
  |  Branch (5906:48): [True: 0, False: 90.5k]
  |  Branch (5906:95): [True: 2, False: 90.5k]
  |  Branch (5906:125): [True: 0, False: 90.5k]
  ------------------
 5907|    325|        return false;
 5908|  90.5k|    if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
  ------------------
  |  Branch (5908:9): [True: 90.2k, False: 321]
  ------------------
 5909|  90.2k|        return false;
 5910|       |
 5911|    321|    bool ret_auto_fit = false;
 5912|    321|    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
  ------------------
  |  Branch (5912:37): [True: 0, False: 321]
  ------------------
 5913|    321|    const float grip_draw_size = IM_FLOOR(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  269|    321|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5914|    321|    const float grip_hover_inner_size = IM_FLOOR(grip_draw_size * 0.75f);
  ------------------
  |  |  269|    321|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 5915|    321|    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;
  ------------------
  |  Branch (5915:41): [True: 0, False: 321]
  ------------------
 5916|       |
 5917|    321|    ImVec2 pos_target(FLT_MAX, FLT_MAX);
 5918|    321|    ImVec2 size_target(FLT_MAX, FLT_MAX);
 5919|       |
 5920|       |    // Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
 5921|       |    // - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
 5922|       |    //   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
 5923|       |    // - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
 5924|       |    // - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
 5925|       |    // We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
 5926|    321|    const bool clip_with_viewport_rect = !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport) || (g.IO.MouseHoveredViewport != window->ViewportId) || !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration);
  ------------------
  |  Branch (5926:42): [True: 321, False: 0]
  |  Branch (5926:110): [True: 0, False: 0]
  |  Branch (5926:163): [True: 0, False: 0]
  ------------------
 5927|    321|    if (clip_with_viewport_rect)
  ------------------
  |  Branch (5927:9): [True: 321, False: 0]
  ------------------
 5928|    321|        window->ClipRect = window->Viewport->GetMainRect();
 5929|       |
 5930|       |    // Resize grips and borders are on layer 1
 5931|    321|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 5932|       |
 5933|       |    // Manual resize grips
 5934|    321|    PushID("#RESIZE");
 5935|    642|    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (5935:33): [True: 321, False: 321]
  ------------------
 5936|    321|    {
 5937|    321|        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];
 5938|    321|        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);
 5939|       |
 5940|       |        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
 5941|    321|        bool hovered, held;
 5942|    321|        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
 5943|    321|        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
  ------------------
  |  Branch (5943:13): [True: 321, False: 0]
  ------------------
 5944|    321|        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
  ------------------
  |  Branch (5944:13): [True: 321, False: 0]
  ------------------
 5945|    321|        ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
 5946|    321|        ItemAdd(resize_rect, resize_grip_id, NULL, ImGuiItemFlags_NoNav);
 5947|    321|        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 5948|       |        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
 5949|    321|        if (hovered || held)
  ------------------
  |  Branch (5949:13): [True: 0, False: 321]
  |  Branch (5949:24): [True: 0, False: 321]
  ------------------
 5950|      0|            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;
  ------------------
  |  Branch (5950:29): [True: 0, False: 0]
  ------------------
 5951|       |
 5952|    321|        if (held && g.IO.MouseClickedCount[0] == 2 && resize_grip_n == 0)
  ------------------
  |  Branch (5952:13): [True: 0, False: 321]
  |  Branch (5952:21): [True: 0, False: 0]
  |  Branch (5952:55): [True: 0, False: 0]
  ------------------
 5953|      0|        {
 5954|       |            // Manual auto-fit when double-clicking
 5955|      0|            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 5956|      0|            ret_auto_fit = true;
 5957|      0|            ClearActiveID();
 5958|      0|        }
 5959|    321|        else if (held)
  ------------------
  |  Branch (5959:18): [True: 0, False: 321]
  ------------------
 5960|      0|        {
 5961|       |            // Resize from any of the four corners
 5962|       |            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
 5963|      0|            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? visibility_rect.Min.x : -FLT_MAX, def.CornerPosN.y == 1.0f ? visibility_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (5963:39): [True: 0, False: 0]
  |  Branch (5963:100): [True: 0, False: 0]
  ------------------
 5964|      0|            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? visibility_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? visibility_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (5964:39): [True: 0, False: 0]
  |  Branch (5964:100): [True: 0, False: 0]
  ------------------
 5965|      0|            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
 5966|      0|            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
 5967|      0|            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
 5968|      0|        }
 5969|       |
 5970|       |        // Only lower-left grip is visible before hovering/activating
 5971|    321|        if (resize_grip_n == 0 || held || hovered)
  ------------------
  |  Branch (5971:13): [True: 321, False: 0]
  |  Branch (5971:35): [True: 0, False: 0]
  |  Branch (5971:43): [True: 0, False: 0]
  ------------------
 5972|    321|            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
  ------------------
  |  Branch (5972:58): [True: 0, False: 321]
  |  Branch (5972:93): [True: 0, False: 321]
  ------------------
 5973|    321|    }
 5974|    321|    for (int border_n = 0; border_n < resize_border_count; border_n++)
  ------------------
  |  Branch (5974:28): [True: 0, False: 321]
  ------------------
 5975|      0|    {
 5976|      0|        const ImGuiResizeBorderDef& def = resize_border_def[border_n];
 5977|      0|        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
  ------------------
  |  Branch (5977:33): [True: 0, False: 0]
  |  Branch (5977:62): [True: 0, False: 0]
  ------------------
 5978|       |
 5979|      0|        bool hovered, held;
 5980|      0|        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
 5981|      0|        ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
 5982|      0|        ItemAdd(border_rect, border_id, NULL, ImGuiItemFlags_NoNav);
 5983|      0|        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 5984|       |        //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
 5985|      0|        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
  ------------------
  |  Branch (5985:14): [True: 0, False: 0]
  |  Branch (5985:25): [True: 0, False: 0]
  |  Branch (5985:89): [True: 0, False: 0]
  ------------------
 5986|      0|        {
 5987|      0|            g.MouseCursor = (axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
  ------------------
  |  Branch (5987:29): [True: 0, False: 0]
  ------------------
 5988|      0|            if (held)
  ------------------
  |  Branch (5988:17): [True: 0, False: 0]
  ------------------
 5989|      0|                *border_held = border_n;
 5990|      0|        }
 5991|      0|        if (held)
  ------------------
  |  Branch (5991:13): [True: 0, False: 0]
  ------------------
 5992|      0|        {
 5993|      0|            ImVec2 clamp_min(border_n == ImGuiDir_Right ? visibility_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down ? visibility_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (5993:30): [True: 0, False: 0]
  |  Branch (5993:93): [True: 0, False: 0]
  ------------------
 5994|      0|            ImVec2 clamp_max(border_n == ImGuiDir_Left  ? visibility_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up   ? visibility_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (5994:30): [True: 0, False: 0]
  |  Branch (5994:93): [True: 0, False: 0]
  ------------------
 5995|      0|            ImVec2 border_target = window->Pos;
 5996|      0|            border_target[axis] = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING;
 5997|      0|            border_target = ImClamp(border_target, clamp_min, clamp_max);
 5998|      0|            CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
 5999|      0|        }
 6000|      0|    }
 6001|    321|    PopID();
 6002|       |
 6003|       |    // Restore nav layer
 6004|    321|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 6005|       |
 6006|       |    // Navigation resize (keyboard/gamepad)
 6007|       |    // FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
 6008|       |    // Not even sure the callback works here.
 6009|    321|    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindowDockTree == window)
  ------------------
  |  Branch (6009:9): [True: 0, False: 321]
  |  Branch (6009:33): [True: 0, False: 0]
  ------------------
 6010|      0|    {
 6011|      0|        ImVec2 nav_resize_dir;
 6012|      0|        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
  ------------------
  |  Branch (6012:13): [True: 0, False: 0]
  |  Branch (6012:62): [True: 0, False: 0]
  ------------------
 6013|      0|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
 6014|      0|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (6014:13): [True: 0, False: 0]
  ------------------
 6015|      0|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);
 6016|      0|        if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f)
  ------------------
  |  Branch (6016:13): [True: 0, False: 0]
  |  Branch (6016:41): [True: 0, False: 0]
  ------------------
 6017|      0|        {
 6018|      0|            const float NAV_RESIZE_SPEED = 600.0f;
 6019|      0|            const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
 6020|      0|            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
 6021|      0|            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, visibility_rect.Min - window->Pos - window->Size); // We need Pos+Size >= visibility_rect.Min, so Size >= visibility_rect.Min - Pos, so size_delta >= visibility_rect.Min - window->Pos - window->Size
 6022|      0|            g.NavWindowingToggleLayer = false;
 6023|      0|            g.NavDisableMouseHover = true;
 6024|      0|            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
 6025|      0|            ImVec2 accum_floored = ImFloor(g.NavWindowingAccumDeltaSize);
 6026|      0|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (6026:17): [True: 0, False: 0]
  |  Branch (6026:44): [True: 0, False: 0]
  ------------------
 6027|      0|            {
 6028|       |                // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
 6029|      0|                size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);
 6030|      0|                g.NavWindowingAccumDeltaSize -= accum_floored;
 6031|      0|            }
 6032|      0|        }
 6033|      0|    }
 6034|       |
 6035|       |    // Apply back modified position/size to window
 6036|    321|    if (size_target.x != FLT_MAX)
  ------------------
  |  Branch (6036:9): [True: 0, False: 321]
  ------------------
 6037|      0|    {
 6038|      0|        window->SizeFull = size_target;
 6039|      0|        MarkIniSettingsDirty(window);
 6040|      0|    }
 6041|    321|    if (pos_target.x != FLT_MAX)
  ------------------
  |  Branch (6041:9): [True: 0, False: 321]
  ------------------
 6042|      0|    {
 6043|      0|        window->Pos = ImFloor(pos_target);
 6044|      0|        MarkIniSettingsDirty(window);
 6045|      0|    }
 6046|       |
 6047|    321|    window->Size = window->SizeFull;
 6048|    321|    return ret_auto_fit;
 6049|  90.5k|}
imgui.cpp:_ZN5ImGuiL23RenderWindowDecorationsEP11ImGuiWindowRK6ImRectbbiPKjf:
 6087|   180k|{
 6088|   180k|    ImGuiContext& g = *GImGui;
 6089|   180k|    ImGuiStyle& style = g.Style;
 6090|   180k|    ImGuiWindowFlags flags = window->Flags;
 6091|       |
 6092|       |    // Ensure that ScrollBar doesn't read last frame's SkipItems
 6093|   180k|    IM_ASSERT(window->BeginCount == 0);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6094|   180k|    window->SkipItems = false;
 6095|       |
 6096|       |    // Draw window + handle manual resize
 6097|       |    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
 6098|   180k|    const float window_rounding = window->WindowRounding;
 6099|   180k|    const float window_border_size = window->WindowBorderSize;
 6100|   180k|    if (window->Collapsed)
  ------------------
  |  Branch (6100:9): [True: 89.9k, False: 90.8k]
  ------------------
 6101|  89.9k|    {
 6102|       |        // Title bar only
 6103|  89.9k|        const float backup_border_size = style.FrameBorderSize;
 6104|  89.9k|        g.Style.FrameBorderSize = window->WindowBorderSize;
 6105|  89.9k|        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
  ------------------
  |  Branch (6105:44): [True: 222, False: 89.6k]
  |  Branch (6105:70): [True: 0, False: 222]
  ------------------
 6106|  89.9k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6106:13): [True: 0, False: 89.9k]
  ------------------
 6107|      0|            title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
  ------------------
  |  | 2450|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6108|  89.9k|        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
 6109|  89.9k|        g.Style.FrameBorderSize = backup_border_size;
 6110|  89.9k|    }
 6111|  90.8k|    else
 6112|  90.8k|    {
 6113|       |        // Window background
 6114|  90.8k|        if (!(flags & ImGuiWindowFlags_NoBackground))
  ------------------
  |  Branch (6114:13): [True: 90.8k, False: 0]
  ------------------
 6115|  90.8k|        {
 6116|  90.8k|            bool is_docking_transparent_payload = false;
 6117|  90.8k|            if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
  ------------------
  |  Branch (6117:17): [True: 96, False: 90.7k]
  |  Branch (6117:37): [True: 0, False: 96]
  |  Branch (6117:89): [True: 0, False: 0]
  ------------------
 6118|      0|                if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
  ------------------
  |  |  211|      0|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (6118:21): [True: 0, False: 0]
  |  Branch (6118:80): [True: 0, False: 0]
  ------------------
 6119|      0|                    is_docking_transparent_payload = true;
 6120|       |
 6121|  90.8k|            ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
 6122|  90.8k|            if (window->ViewportOwned)
  ------------------
  |  Branch (6122:17): [True: 0, False: 90.8k]
  ------------------
 6123|      0|            {
 6124|      0|                bg_col |= IM_COL32_A_MASK; // No alpha
  ------------------
  |  | 2450|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6125|      0|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6125:21): [True: 0, False: 0]
  ------------------
 6126|      0|                    window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
 6127|      0|            }
 6128|  90.8k|            else
 6129|  90.8k|            {
 6130|       |                // Adjust alpha. For docking
 6131|  90.8k|                bool override_alpha = false;
 6132|  90.8k|                float alpha = 1.0f;
 6133|  90.8k|                if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
  ------------------
  |  Branch (6133:21): [True: 0, False: 90.8k]
  ------------------
 6134|      0|                {
 6135|      0|                    alpha = g.NextWindowData.BgAlphaVal;
 6136|      0|                    override_alpha = true;
 6137|      0|                }
 6138|  90.8k|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6138:21): [True: 0, False: 90.8k]
  ------------------
 6139|      0|                {
 6140|      0|                    alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
 6141|      0|                    override_alpha = true;
 6142|      0|                }
 6143|  90.8k|                if (override_alpha)
  ------------------
  |  Branch (6143:21): [True: 0, False: 90.8k]
  ------------------
 6144|      0|                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2450|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  |  268|      0|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  ------------------
 6145|  90.8k|            }
 6146|       |
 6147|       |            // Render, for docked windows and host windows we ensure bg goes before decorations
 6148|  90.8k|            if (window->DockIsActive)
  ------------------
  |  Branch (6148:17): [True: 0, False: 90.8k]
  ------------------
 6149|      0|                window->DockNode->LastBgColor = bg_col;
 6150|  90.8k|            ImDrawList* bg_draw_list = window->DockIsActive ? window->DockNode->HostWindow->DrawList : window->DrawList;
  ------------------
  |  Branch (6150:40): [True: 0, False: 90.8k]
  ------------------
 6151|  90.8k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6151:17): [True: 0, False: 90.8k]
  |  Branch (6151:41): [True: 0, False: 90.8k]
  ------------------
 6152|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1581|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
 6153|  90.8k|            bg_draw_list->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
  ------------------
  |  Branch (6153:145): [True: 323, False: 90.5k]
  ------------------
 6154|  90.8k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6154:17): [True: 0, False: 90.8k]
  |  Branch (6154:41): [True: 0, False: 90.8k]
  ------------------
 6155|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
  ------------------
  |  | 1582|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 6156|  90.8k|        }
 6157|  90.8k|        if (window->DockIsActive)
  ------------------
  |  Branch (6157:13): [True: 0, False: 90.8k]
  ------------------
 6158|      0|            window->DockNode->IsBgDrawnThisFrame = true;
 6159|       |
 6160|       |        // Title bar
 6161|       |        // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
 6162|       |        // in order for their pos/size to be matching their undocking state.)
 6163|  90.8k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6163:13): [True: 90.5k, False: 323]
  |  Branch (6163:55): [True: 90.5k, False: 0]
  ------------------
 6164|  90.5k|        {
 6165|  90.5k|            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
  ------------------
  |  Branch (6165:47): [True: 229, False: 90.3k]
  ------------------
 6166|  90.5k|            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
 6167|  90.5k|        }
 6168|       |
 6169|       |        // Menu bar
 6170|  90.8k|        if (flags & ImGuiWindowFlags_MenuBar)
  ------------------
  |  Branch (6170:13): [True: 0, False: 90.8k]
  ------------------
 6171|      0|        {
 6172|      0|            ImRect menu_bar_rect = window->MenuBarRect();
 6173|      0|            menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
 6174|      0|            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
  ------------------
  |  Branch (6174:180): [True: 0, False: 0]
  ------------------
 6175|      0|            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
  ------------------
  |  Branch (6175:17): [True: 0, False: 0]
  |  Branch (6175:49): [True: 0, False: 0]
  ------------------
 6176|      0|                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
 6177|      0|        }
 6178|       |
 6179|       |        // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
 6180|  90.8k|        ImGuiDockNode* node = window->DockNode;
 6181|  90.8k|        if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
  ------------------
  |  Branch (6181:13): [True: 0, False: 90.8k]
  |  Branch (6181:37): [True: 0, False: 0]
  |  Branch (6181:63): [True: 0, False: 0]
  ------------------
 6182|      0|        {
 6183|      0|            float unhide_sz_draw = ImFloor(g.FontSize * 0.70f);
 6184|      0|            float unhide_sz_hit = ImFloor(g.FontSize * 0.55f);
 6185|      0|            ImVec2 p = node->Pos;
 6186|      0|            ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
 6187|      0|            ImGuiID unhide_id = window->GetID("#UNHIDE");
 6188|      0|            KeepAliveID(unhide_id);
 6189|      0|            bool hovered, held;
 6190|      0|            if (ButtonBehavior(r, unhide_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren))
  ------------------
  |  Branch (6190:17): [True: 0, False: 0]
  ------------------
 6191|      0|                node->WantHiddenTabBarToggle = true;
 6192|      0|            else if (held && IsMouseDragging(0))
  ------------------
  |  Branch (6192:22): [True: 0, False: 0]
  |  Branch (6192:30): [True: 0, False: 0]
  ------------------
 6193|      0|                StartMouseMovingWindowOrNode(window, node, true);
 6194|       |
 6195|       |            // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
 6196|      0|            ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (6196:39): [True: 0, False: 0]
  |  Branch (6196:47): [True: 0, False: 0]
  |  Branch (6196:60): [True: 0, False: 0]
  |  Branch (6196:79): [True: 0, False: 0]
  |  Branch (6196:116): [True: 0, False: 0]
  ------------------
 6197|      0|            window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
 6198|      0|        }
 6199|       |
 6200|       |        // Scrollbars
 6201|  90.8k|        if (window->ScrollbarX)
  ------------------
  |  Branch (6201:13): [True: 323, False: 90.5k]
  ------------------
 6202|    323|            Scrollbar(ImGuiAxis_X);
 6203|  90.8k|        if (window->ScrollbarY)
  ------------------
  |  Branch (6203:13): [True: 324, False: 90.5k]
  ------------------
 6204|    324|            Scrollbar(ImGuiAxis_Y);
 6205|       |
 6206|       |        // Render resize grips (after their input handling so we don't have a frame of latency)
 6207|  90.8k|        if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
  ------------------
  |  Branch (6207:13): [True: 90.8k, False: 0]
  |  Branch (6207:48): [True: 90.5k, False: 323]
  ------------------
 6208|  90.5k|        {
 6209|   181k|            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (6209:41): [True: 90.5k, False: 90.5k]
  ------------------
 6210|  90.5k|            {
 6211|  90.5k|                const ImU32 col = resize_grip_col[resize_grip_n];
 6212|  90.5k|                if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2450|  90.5k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (6212:21): [True: 90.2k, False: 321]
  ------------------
 6213|  90.2k|                    continue;
 6214|    321|                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
 6215|    321|                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
 6216|    321|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
  ------------------
  |  Branch (6216:72): [True: 0, False: 321]
  ------------------
 6217|    321|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
  ------------------
  |  Branch (6217:72): [True: 0, False: 321]
  ------------------
 6218|    321|                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
 6219|    321|                window->DrawList->PathFillConvex(col);
 6220|    321|            }
 6221|  90.5k|        }
 6222|       |
 6223|       |        // Borders (for dock node host they will be rendered over after the tab bar)
 6224|  90.8k|        if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
  ------------------
  |  Branch (6224:13): [True: 90.8k, False: 0]
  |  Branch (6224:48): [True: 90.8k, False: 0]
  ------------------
 6225|  90.8k|            RenderWindowOuterBorders(window);
 6226|  90.8k|    }
 6227|   180k|}
imgui.cpp:_ZL19GetWindowBgColorIdxP11ImGuiWindow:
 5813|  90.8k|{
 5814|  90.8k|    if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (5814:9): [True: 0, False: 90.8k]
  ------------------
 5815|      0|        return ImGuiCol_PopupBg;
 5816|  90.8k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !window->DockIsActive)
  ------------------
  |  Branch (5816:9): [True: 323, False: 90.5k]
  |  Branch (5816:59): [True: 323, False: 0]
  ------------------
 5817|    323|        return ImGuiCol_ChildBg;
 5818|  90.5k|    return ImGuiCol_WindowBg;
 5819|  90.8k|}
imgui.cpp:_ZN5ImGuiL24RenderWindowOuterBordersEP11ImGuiWindow:
 6061|  90.8k|{
 6062|  90.8k|    ImGuiContext& g = *GImGui;
 6063|  90.8k|    float rounding = window->WindowRounding;
 6064|  90.8k|    float border_size = window->WindowBorderSize;
 6065|  90.8k|    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))
  ------------------
  |  Branch (6065:9): [True: 90.6k, False: 201]
  |  Branch (6065:31): [True: 90.6k, False: 0]
  ------------------
 6066|  90.6k|        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
 6067|       |
 6068|  90.8k|    int border_held = window->ResizeBorderHeld;
 6069|  90.8k|    if (border_held != -1)
  ------------------
  |  Branch (6069:9): [True: 0, False: 90.8k]
  ------------------
 6070|      0|    {
 6071|      0|        const ImGuiResizeBorderDef& def = resize_border_def[border_held];
 6072|      0|        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
 6073|      0|        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
  ------------------
  |  |  257|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 6074|      0|        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
  ------------------
  |  |  257|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 6075|      0|        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), 0, ImMax(2.0f, border_size)); // Thicker than usual
 6076|      0|    }
 6077|  90.8k|    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6077:9): [True: 0, False: 90.8k]
  |  Branch (6077:40): [True: 0, False: 0]
  |  Branch (6077:90): [True: 0, False: 0]
  ------------------
 6078|      0|    {
 6079|      0|        float y = window->Pos.y + window->TitleBarHeight() - 1;
 6080|      0|        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);
 6081|      0|    }
 6082|  90.8k|}
imgui.cpp:_ZN5ImGuiL28RenderWindowTitleBarContentsEP11ImGuiWindowRK6ImRectPKcPb:
 6232|   180k|{
 6233|   180k|    ImGuiContext& g = *GImGui;
 6234|   180k|    ImGuiStyle& style = g.Style;
 6235|   180k|    ImGuiWindowFlags flags = window->Flags;
 6236|       |
 6237|   180k|    const bool has_close_button = (p_open != NULL);
 6238|   180k|    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);
  ------------------
  |  Branch (6238:38): [True: 180k, False: 0]
  |  Branch (6238:80): [True: 180k, False: 0]
  ------------------
 6239|       |
 6240|       |    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
 6241|       |    // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
 6242|   180k|    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
 6243|   180k|    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
 6244|   180k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 6245|       |
 6246|       |    // Layout buttons
 6247|       |    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
 6248|   180k|    float pad_l = style.FramePadding.x;
 6249|   180k|    float pad_r = style.FramePadding.x;
 6250|   180k|    float button_sz = g.FontSize;
 6251|   180k|    ImVec2 close_button_pos;
 6252|   180k|    ImVec2 collapse_button_pos;
 6253|   180k|    if (has_close_button)
  ------------------
  |  Branch (6253:9): [True: 0, False: 180k]
  ------------------
 6254|      0|    {
 6255|      0|        pad_r += button_sz;
 6256|      0|        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
 6257|      0|    }
 6258|   180k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
  ------------------
  |  Branch (6258:9): [True: 180k, False: 0]
  |  Branch (6258:32): [True: 0, False: 180k]
  ------------------
 6259|      0|    {
 6260|      0|        pad_r += button_sz;
 6261|      0|        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
 6262|      0|    }
 6263|   180k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
  ------------------
  |  Branch (6263:9): [True: 180k, False: 0]
  |  Branch (6263:32): [True: 180k, False: 0]
  ------------------
 6264|   180k|    {
 6265|   180k|        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l - style.FramePadding.x, title_bar_rect.Min.y);
 6266|   180k|        pad_l += button_sz;
 6267|   180k|    }
 6268|       |
 6269|       |    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
 6270|   180k|    if (has_collapse_button)
  ------------------
  |  Branch (6270:9): [True: 180k, False: 0]
  ------------------
 6271|   180k|        if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
  ------------------
  |  Branch (6271:13): [True: 7, False: 180k]
  ------------------
 6272|      7|            window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
 6273|       |
 6274|       |    // Close button
 6275|   180k|    if (has_close_button)
  ------------------
  |  Branch (6275:9): [True: 0, False: 180k]
  ------------------
 6276|      0|        if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
  ------------------
  |  Branch (6276:13): [True: 0, False: 0]
  ------------------
 6277|      0|            *p_open = false;
 6278|       |
 6279|   180k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 6280|   180k|    g.CurrentItemFlags = item_flags_backup;
 6281|       |
 6282|       |    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
 6283|       |    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
 6284|   180k|    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
  ------------------
  |  Branch (6284:33): [True: 0, False: 180k]
  ------------------
 6285|   180k|    const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
 6286|       |
 6287|       |    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
 6288|       |    // while uncentered title text will still reach edges correctly.
 6289|   180k|    if (pad_l > style.FramePadding.x)
  ------------------
  |  Branch (6289:9): [True: 180k, False: 0]
  ------------------
 6290|   180k|        pad_l += g.Style.ItemInnerSpacing.x;
 6291|   180k|    if (pad_r > style.FramePadding.x)
  ------------------
  |  Branch (6291:9): [True: 0, False: 180k]
  ------------------
 6292|      0|        pad_r += g.Style.ItemInnerSpacing.x;
 6293|   180k|    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
  ------------------
  |  Branch (6293:9): [True: 0, False: 180k]
  |  Branch (6293:44): [True: 0, False: 0]
  ------------------
 6294|      0|    {
 6295|      0|        float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
  ------------------
  |  |  436|      0|#define ImFabs(X)           fabsf(X)
  ------------------
 6296|      0|        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
 6297|      0|        pad_l = ImMax(pad_l, pad_extend * centerness);
 6298|      0|        pad_r = ImMax(pad_r, pad_extend * centerness);
 6299|      0|    }
 6300|       |
 6301|   180k|    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
 6302|   180k|    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
 6303|   180k|    if (flags & ImGuiWindowFlags_UnsavedDocument)
  ------------------
  |  Branch (6303:9): [True: 0, False: 180k]
  ------------------
 6304|      0|    {
 6305|      0|        ImVec2 marker_pos;
 6306|      0|        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
 6307|      0|        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
 6308|      0|        if (marker_pos.x > layout_r.Min.x)
  ------------------
  |  Branch (6308:13): [True: 0, False: 0]
  ------------------
 6309|      0|        {
 6310|      0|            RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
 6311|      0|            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
 6312|      0|        }
 6313|      0|    }
 6314|       |    //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6315|       |    //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6316|   180k|    RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
 6317|   180k|}
imgui.cpp:_ZN5ImGuiL20UpdateKeyboardInputsEv:
 8839|  90.2k|{
 8840|  90.2k|    ImGuiContext& g = *GImGui;
 8841|  90.2k|    ImGuiIO& io = g.IO;
 8842|       |
 8843|       |    // Import legacy keys or verify they are not used
 8844|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 8845|       |    if (io.BackendUsingLegacyKeyArrays == 0)
 8846|       |    {
 8847|       |        // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
 8848|       |        for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
 8849|       |            IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 8850|       |    }
 8851|       |    else
 8852|       |    {
 8853|       |        if (g.FrameCount == 0)
 8854|       |            for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 8855|       |                IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");
 8856|       |
 8857|       |        // Build reverse KeyMap (Named -> Legacy)
 8858|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 8859|       |            if (io.KeyMap[n] != -1)
 8860|       |            {
 8861|       |                IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
 8862|       |                io.KeyMap[io.KeyMap[n]] = n;
 8863|       |            }
 8864|       |
 8865|       |        // Import legacy keys into new ones
 8866|       |        for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 8867|       |            if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
 8868|       |            {
 8869|       |                const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
 8870|       |                IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
 8871|       |                io.KeysData[key].Down = io.KeysDown[n];
 8872|       |                if (key != n)
 8873|       |                    io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
 8874|       |                io.BackendUsingLegacyKeyArrays = 1;
 8875|       |            }
 8876|       |        if (io.BackendUsingLegacyKeyArrays == 1)
 8877|       |        {
 8878|       |            GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
 8879|       |            GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
 8880|       |            GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
 8881|       |            GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
 8882|       |        }
 8883|       |    }
 8884|       |
 8885|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 8886|       |    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
 8887|       |    if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
 8888|       |    {
 8889|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)           do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1]; } while (0)
 8890|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)    do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]); } while (0)
 8891|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
 8892|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
 8893|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
 8894|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
 8895|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
 8896|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadRight, ImGuiNavInput_DpadRight);
 8897|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadUp, ImGuiNavInput_DpadUp);
 8898|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadDown, ImGuiNavInput_DpadDown);
 8899|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadL1, ImGuiNavInput_FocusPrev, ImGuiNavInput_TweakSlow);
 8900|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadR1, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakFast);
 8901|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickLeft, ImGuiNavInput_LStickLeft);
 8902|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickRight, ImGuiNavInput_LStickRight);
 8903|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
 8904|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
 8905|       |        #undef NAV_MAP_KEY
 8906|       |    }
 8907|       |#endif
 8908|       |#endif
 8909|       |
 8910|       |    // Update aliases
 8911|   541k|    for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
  ------------------
  |  Branch (8911:21): [True: 451k, False: 90.2k]
  ------------------
 8912|   451k|        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
  ------------------
  |  Branch (8912:62): [True: 48.1k, False: 402k]
  ------------------
 8913|  90.2k|    UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
 8914|  90.2k|    UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);
 8915|       |
 8916|       |    // Synchronize io.KeyMods and io.KeyXXX values.
 8917|       |    // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 8918|       |    // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 8919|       |    // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
 8920|  90.2k|    io.KeyMods = GetMergedModsFromKeys();
 8921|  90.2k|    io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
 8922|  90.2k|    io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
 8923|  90.2k|    io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
 8924|  90.2k|    io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
 8925|       |
 8926|       |    // Clear gamepad data if disabled
 8927|  90.2k|    if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
  ------------------
  |  Branch (8927:9): [True: 90.2k, False: 0]
  ------------------
 8928|  2.25M|        for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1248|  90.2k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                      for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1249|  2.25M|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (8928:46): [True: 2.16M, False: 90.2k]
  ------------------
 8929|  2.16M|        {
 8930|  2.16M|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
 8931|  2.16M|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
 8932|  2.16M|        }
 8933|       |
 8934|       |    // Update keys
 8935|  12.7M|    for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
  ------------------
  |  Branch (8935:21): [True: 12.6M, False: 90.2k]
  ------------------
 8936|  12.6M|    {
 8937|  12.6M|        ImGuiKeyData* key_data = &io.KeysData[i];
 8938|  12.6M|        key_data->DownDurationPrev = key_data->DownDuration;
 8939|  12.6M|        key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (8939:34): [True: 114k, False: 12.5M]
  |  Branch (8939:52): [True: 12.4k, False: 101k]
  ------------------
 8940|  12.6M|    }
 8941|       |
 8942|       |    // Update keys/input owner (named keys only): one entry per key
 8943|  12.7M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (8943:50): [True: 12.6M, False: 90.2k]
  ------------------
 8944|  12.6M|    {
 8945|  12.6M|        ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
 8946|  12.6M|        ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
 8947|  12.6M|        owner_data->OwnerCurr = owner_data->OwnerNext;
 8948|  12.6M|        if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
  ------------------
  |  Branch (8948:13): [True: 12.5M, False: 114k]
  ------------------
 8949|  12.5M|            owner_data->OwnerNext = ImGuiKeyOwner_None;
  ------------------
  |  | 1320|  12.5M|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 8950|  12.6M|        owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;  // Clear LockUntilRelease when key is not Down anymore
  ------------------
  |  Branch (8950:68): [True: 0, False: 12.6M]
  |  Branch (8950:100): [True: 0, False: 0]
  ------------------
 8951|  12.6M|    }
 8952|       |
 8953|  90.2k|    UpdateKeyRoutingTable(&g.KeysRoutingTable);
 8954|  90.2k|}
imgui.cpp:_ZL14UpdateAliasKey8ImGuiKeybf:
 8820|   631k|{
 8821|   631k|    IM_ASSERT(ImGui::IsAliasKey(key));
  ------------------
  |  |   23|   631k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8822|   631k|    ImGuiKeyData* key_data = ImGui::GetKeyData(key);
 8823|   631k|    key_data->Down = v;
 8824|   631k|    key_data->AnalogValue = analog_value;
 8825|   631k|}
imgui.cpp:_ZL21GetMergedModsFromKeysv:
 8829|   180k|{
 8830|   180k|    ImGuiKeyChord mods = 0;
 8831|   180k|    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }
  ------------------
  |  Branch (8831:9): [True: 0, False: 180k]
  ------------------
 8832|   180k|    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }
  ------------------
  |  Branch (8832:9): [True: 0, False: 180k]
  ------------------
 8833|   180k|    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }
  ------------------
  |  Branch (8833:9): [True: 0, False: 180k]
  ------------------
 8834|   180k|    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }
  ------------------
  |  Branch (8834:9): [True: 0, False: 180k]
  ------------------
 8835|   180k|    return mods;
 8836|   180k|}
imgui.cpp:_ZN5ImGuiL21UpdateKeyRoutingTableEP20ImGuiKeyRoutingTable:
 8396|  90.2k|{
 8397|  90.2k|    ImGuiContext& g = *GImGui;
 8398|  90.2k|    rt->EntriesNext.resize(0);
 8399|  12.7M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (8399:50): [True: 12.6M, False: 90.2k]
  ------------------
 8400|  12.6M|    {
 8401|  12.6M|        const int new_routing_start_idx = rt->EntriesNext.Size;
 8402|  12.6M|        ImGuiKeyRoutingData* routing_entry;
 8403|  12.6M|        for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
  ------------------
  |  Branch (8403:78): [True: 0, False: 12.6M]
  ------------------
 8404|      0|        {
 8405|      0|            routing_entry = &rt->Entries[old_routing_idx];
 8406|      0|            routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
 8407|      0|            routing_entry->RoutingNext = ImGuiKeyOwner_None;
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 8408|      0|            routing_entry->RoutingNextScore = 255;
 8409|      0|            if (routing_entry->RoutingCurr == ImGuiKeyOwner_None)
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (8409:17): [True: 0, False: 0]
  ------------------
 8410|      0|                continue;
 8411|      0|            rt->EntriesNext.push_back(*routing_entry); // Write alive ones into new buffer
 8412|       |
 8413|       |            // Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
 8414|      0|            if (routing_entry->Mods == g.IO.KeyMods)
  ------------------
  |  Branch (8414:17): [True: 0, False: 0]
  ------------------
 8415|      0|            {
 8416|      0|                ImGuiKeyOwnerData* owner_data = ImGui::GetKeyOwnerData(key);
 8417|      0|                if (owner_data->OwnerCurr == ImGuiKeyOwner_None)
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (8417:21): [True: 0, False: 0]
  ------------------
 8418|      0|                    owner_data->OwnerCurr = routing_entry->RoutingCurr;
 8419|      0|            }
 8420|      0|        }
 8421|       |
 8422|       |        // Rewrite linked-list
 8423|  12.6M|        rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
  ------------------
  |  Branch (8423:75): [True: 0, False: 12.6M]
  ------------------
 8424|  12.6M|        for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
  ------------------
  |  Branch (8424:45): [True: 0, False: 12.6M]
  ------------------
 8425|      0|            rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
  ------------------
  |  Branch (8425:72): [True: 0, False: 0]
  ------------------
 8426|  12.6M|    }
 8427|  90.2k|    rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
 8428|  90.2k|}
imgui.cpp:_ZN5ImGuiL17UpdateMouseInputsEv:
 8957|  90.2k|{
 8958|  90.2k|    ImGuiContext& g = *GImGui;
 8959|  90.2k|    ImGuiIO& io = g.IO;
 8960|       |
 8961|       |    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
 8962|  90.2k|    if (IsMousePosValid(&io.MousePos))
  ------------------
  |  Branch (8962:9): [True: 33.4k, False: 56.7k]
  ------------------
 8963|  33.4k|        io.MousePos = g.MouseLastValidPos = ImFloorSigned(io.MousePos);
 8964|       |
 8965|       |    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
 8966|  90.2k|    if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (8966:9): [True: 33.4k, False: 56.7k]
  |  Branch (8966:42): [True: 32.1k, False: 1.33k]
  ------------------
 8967|  32.1k|        io.MouseDelta = io.MousePos - io.MousePosPrev;
 8968|  58.0k|    else
 8969|  58.0k|        io.MouseDelta = ImVec2(0.0f, 0.0f);
 8970|       |
 8971|       |    // If mouse moved we re-enable mouse hovering in case it was disabled by gamepad/keyboard. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
 8972|  90.2k|    if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
  ------------------
  |  Branch (8972:9): [True: 1.57k, False: 88.6k]
  |  Branch (8972:36): [True: 131, False: 88.5k]
  ------------------
 8973|  1.70k|        g.NavDisableMouseHover = false;
 8974|       |
 8975|  90.2k|    io.MousePosPrev = io.MousePos;
 8976|   541k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   87|   541k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (8976:21): [True: 451k, False: 90.2k]
  ------------------
 8977|   451k|    {
 8978|   451k|        io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
  ------------------
  |  Branch (8978:30): [True: 48.1k, False: 402k]
  |  Branch (8978:49): [True: 6.99k, False: 41.1k]
  ------------------
 8979|   451k|        io.MouseClickedCount[i] = 0; // Will be filled below
 8980|   451k|        io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
  ------------------
  |  Branch (8980:31): [True: 402k, False: 48.1k]
  |  Branch (8980:51): [True: 2.76k, False: 400k]
  ------------------
 8981|   451k|        io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
 8982|   451k|        io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (8982:35): [True: 48.1k, False: 402k]
  |  Branch (8982:54): [True: 6.99k, False: 41.1k]
  ------------------
 8983|   451k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (8983:13): [True: 6.99k, False: 444k]
  ------------------
 8984|  6.99k|        {
 8985|  6.99k|            bool is_repeated_click = false;
 8986|  6.99k|            if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
  ------------------
  |  Branch (8986:17): [True: 4.78k, False: 2.20k]
  ------------------
 8987|  4.78k|            {
 8988|  4.78k|                ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (8988:47): [True: 1.90k, False: 2.87k]
  ------------------
 8989|  4.78k|                if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
  ------------------
  |  Branch (8989:21): [True: 4.46k, False: 326]
  ------------------
 8990|  4.46k|                    is_repeated_click = true;
 8991|  4.78k|            }
 8992|  6.99k|            if (is_repeated_click)
  ------------------
  |  Branch (8992:17): [True: 4.46k, False: 2.53k]
  ------------------
 8993|  4.46k|                io.MouseClickedLastCount[i]++;
 8994|  2.53k|            else
 8995|  2.53k|                io.MouseClickedLastCount[i] = 1;
 8996|  6.99k|            io.MouseClickedTime[i] = g.Time;
 8997|  6.99k|            io.MouseClickedPos[i] = io.MousePos;
 8998|  6.99k|            io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
 8999|  6.99k|            io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
 9000|  6.99k|            io.MouseDragMaxDistanceSqr[i] = 0.0f;
 9001|  6.99k|        }
 9002|   444k|        else if (io.MouseDown[i])
  ------------------
  |  Branch (9002:18): [True: 41.1k, False: 402k]
  ------------------
 9003|  41.1k|        {
 9004|       |            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
 9005|  41.1k|            ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (9005:43): [True: 25.5k, False: 15.6k]
  ------------------
 9006|  41.1k|            io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
 9007|  41.1k|            io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
  ------------------
  |  Branch (9007:86): [True: 2.87k, False: 38.3k]
  ------------------
 9008|  41.1k|            io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
  ------------------
  |  Branch (9008:86): [True: 1.36k, False: 39.8k]
  ------------------
 9009|  41.1k|        }
 9010|       |
 9011|       |        // We provide io.MouseDoubleClicked[] as a legacy service
 9012|   451k|        io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);
 9013|       |
 9014|       |        // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
 9015|   451k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (9015:13): [True: 6.99k, False: 444k]
  ------------------
 9016|  6.99k|            g.NavDisableMouseHover = false;
 9017|   451k|    }
 9018|  90.2k|}
imgui.cpp:_ZN5ImGuiL16UpdateMouseWheelEv:
 9080|  90.2k|{
 9081|       |    // Reset the locked window if we move the mouse or after the timer elapses.
 9082|       |    // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
 9083|  90.2k|    ImGuiContext& g = *GImGui;
 9084|  90.2k|    if (g.WheelingWindow != NULL)
  ------------------
  |  Branch (9084:9): [True: 0, False: 90.2k]
  ------------------
 9085|      0|    {
 9086|      0|        g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
 9087|      0|        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
  ------------------
  |  Branch (9087:13): [True: 0, False: 0]
  |  Branch (9087:13): [True: 0, False: 0]
  |  Branch (9087:34): [True: 0, False: 0]
  ------------------
 9088|      0|            g.WheelingWindowReleaseTimer = 0.0f;
 9089|      0|        if (g.WheelingWindowReleaseTimer <= 0.0f)
  ------------------
  |  Branch (9089:13): [True: 0, False: 0]
  ------------------
 9090|      0|            LockWheelingWindow(NULL, 0.0f);
 9091|      0|    }
 9092|       |
 9093|  90.2k|    ImVec2 wheel;
 9094|  90.2k|    wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_None) ? g.IO.MouseWheelH : 0.0f;
  ------------------
  |  | 1320|  90.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9094:15): [True: 90.2k, False: 0]
  ------------------
 9095|  90.2k|    wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_None) ? g.IO.MouseWheel : 0.0f;
  ------------------
  |  | 1320|  90.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9095:15): [True: 90.2k, False: 0]
  ------------------
 9096|       |
 9097|       |    //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
 9098|  90.2k|    ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
  ------------------
  |  Branch (9098:33): [True: 0, False: 90.2k]
  ------------------
 9099|  90.2k|    if (!mouse_window || mouse_window->Collapsed)
  ------------------
  |  Branch (9099:9): [True: 89.7k, False: 508]
  |  Branch (9099:26): [True: 462, False: 46]
  ------------------
 9100|  90.1k|        return;
 9101|       |
 9102|       |    // Zoom / Scale window
 9103|       |    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
 9104|     46|    if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
  ------------------
  |  Branch (9104:9): [True: 0, False: 46]
  |  Branch (9104:28): [True: 0, False: 0]
  |  Branch (9104:44): [True: 0, False: 0]
  ------------------
 9105|      0|    {
 9106|      0|        LockWheelingWindow(mouse_window, wheel.y);
 9107|      0|        ImGuiWindow* window = mouse_window;
 9108|      0|        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
 9109|      0|        const float scale = new_font_scale / window->FontWindowScale;
 9110|      0|        window->FontWindowScale = new_font_scale;
 9111|      0|        if (window == window->RootWindow)
  ------------------
  |  Branch (9111:13): [True: 0, False: 0]
  ------------------
 9112|      0|        {
 9113|      0|            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
 9114|      0|            SetWindowPos(window, window->Pos + offset, 0);
 9115|      0|            window->Size = ImFloor(window->Size * scale);
 9116|      0|            window->SizeFull = ImFloor(window->SizeFull * scale);
 9117|      0|        }
 9118|      0|        return;
 9119|      0|    }
 9120|     46|    if (g.IO.KeyCtrl)
  ------------------
  |  Branch (9120:9): [True: 0, False: 46]
  ------------------
 9121|      0|        return;
 9122|       |
 9123|       |    // Mouse wheel scrolling
 9124|       |    // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
 9125|       |    // - We avoid doing it on OSX as it the OS input layer handles this already.
 9126|       |    // - However this means when running on OSX over Emcripten, Shift+WheelY will incur two swappings (1 in OS, 1 here), cancelling the feature.
 9127|     46|    const bool swap_axis = g.IO.KeyShift && !g.IO.ConfigMacOSXBehaviors;
  ------------------
  |  Branch (9127:28): [True: 0, False: 46]
  |  Branch (9127:45): [True: 0, False: 0]
  ------------------
 9128|     46|    if (swap_axis)
  ------------------
  |  Branch (9128:9): [True: 0, False: 46]
  ------------------
 9129|      0|    {
 9130|      0|        wheel.x = wheel.y;
 9131|      0|        wheel.y = 0.0f;
 9132|      0|    }
 9133|       |
 9134|       |    // Maintain a rough average of moving magnitude on both axises
 9135|       |    // FIXME: should by based on wall clock time rather than frame-counter
 9136|     46|    g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
 9137|     46|    g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);
 9138|       |
 9139|       |    // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
 9140|     46|    wheel += g.WheelingWindowWheelRemainder;
 9141|     46|    g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
 9142|     46|    if (wheel.x == 0.0f && wheel.y == 0.0f)
  ------------------
  |  Branch (9142:9): [True: 46, False: 0]
  |  Branch (9142:28): [True: 46, False: 0]
  ------------------
 9143|     46|        return;
 9144|       |
 9145|       |    // Mouse wheel scrolling: find target and apply
 9146|       |    // - don't renew lock if axis doesn't apply on the window.
 9147|       |    // - select a main axis when both axises are being moved.
 9148|      0|    if (ImGuiWindow* window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
  ------------------
  |  Branch (9148:22): [True: 0, False: 0]
  ------------------
 9149|      0|        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (9149:13): [True: 0, False: 0]
  |  Branch (9149:70): [True: 0, False: 0]
  ------------------
 9150|      0|        {
 9151|      0|            bool do_scroll[2] = { wheel.x != 0.0f && window->ScrollMax.x != 0.0f, wheel.y != 0.0f && window->ScrollMax.y != 0.0f };
  ------------------
  |  Branch (9151:35): [True: 0, False: 0]
  |  Branch (9151:54): [True: 0, False: 0]
  |  Branch (9151:83): [True: 0, False: 0]
  |  Branch (9151:102): [True: 0, False: 0]
  ------------------
 9152|      0|            if (do_scroll[ImGuiAxis_X] && do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (9152:17): [True: 0, False: 0]
  |  Branch (9152:43): [True: 0, False: 0]
  ------------------
 9153|      0|                do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis_Y : ImGuiAxis_X] = false;
  ------------------
  |  Branch (9153:27): [True: 0, False: 0]
  ------------------
 9154|      0|            if (do_scroll[ImGuiAxis_X])
  ------------------
  |  Branch (9154:17): [True: 0, False: 0]
  ------------------
 9155|      0|            {
 9156|      0|                LockWheelingWindow(window, wheel.x);
 9157|      0|                float max_step = window->InnerRect.GetWidth() * 0.67f;
 9158|      0|                float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step));
 9159|      0|                SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
 9160|      0|            }
 9161|      0|            if (do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (9161:17): [True: 0, False: 0]
  ------------------
 9162|      0|            {
 9163|      0|                LockWheelingWindow(window, wheel.y);
 9164|      0|                float max_step = window->InnerRect.GetHeight() * 0.67f;
 9165|      0|                float scroll_step = ImFloor(ImMin(5 * window->CalcFontSize(), max_step));
 9166|      0|                SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
 9167|      0|            }
 9168|      0|        }
 9169|      0|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckNewFrameSanityChecksEv:
 9502|  90.2k|{
 9503|  90.2k|    ImGuiContext& g = *GImGui;
 9504|       |
 9505|       |    // Check user IM_ASSERT macro
 9506|       |    // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
 9507|       |    //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
 9508|       |    //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
 9509|       |    // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
 9510|       |    // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
 9511|  90.2k|    if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (9511:9): [Folded - Ignored]
  ------------------
 9512|       |
 9513|       |    // Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
 9514|       |    // Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
 9515|       |#ifdef __EMSCRIPTEN__
 9516|       |    if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
 9517|       |        g.IO.DeltaTime = 0.00001f;
 9518|       |#endif
 9519|       |
 9520|       |    // Check user data
 9521|       |    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
 9522|  90.2k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9523|  90.2k|    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9524|  90.2k|    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9525|  90.2k|    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9526|  90.2k|    IM_ASSERT(g.IO.Fonts->IsBuilt()                                     && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9527|  90.2k|    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9528|  90.2k|    IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f                 && "Invalid style setting!");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9529|  90.2k|    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9530|  90.2k|    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9531|  90.2k|    IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9532|  90.2k|    IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9533|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9534|       |    for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
 9535|       |        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");
 9536|       |
 9537|       |    // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
 9538|       |    if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
 9539|       |        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
 9540|       |#endif
 9541|       |
 9542|       |    // Check: the io.ConfigWindowsResizeFromEdges option requires backend to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
 9543|  90.2k|    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
  ------------------
  |  Branch (9543:9): [True: 1, False: 90.2k]
  |  Branch (9543:46): [True: 1, False: 0]
  ------------------
 9544|      1|        g.IO.ConfigWindowsResizeFromEdges = false;
 9545|       |
 9546|       |    // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
 9547|  90.2k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
  ------------------
  |  Branch (9547:9): [True: 6, False: 90.2k]
  |  Branch (9547:30): [True: 6, False: 0]
  |  Branch (9547:85): [True: 0, False: 6]
  ------------------
 9548|  90.2k|        IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9549|  90.2k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
  ------------------
  |  Branch (9549:9): [True: 6, False: 90.2k]
  |  Branch (9549:30): [True: 0, False: 6]
  |  Branch (9549:87): [True: 0, False: 0]
  ------------------
 9550|  90.2k|        IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9551|       |
 9552|       |    // Perform simple checks: multi-viewport and platform windows support
 9553|  90.2k|    if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (9553:9): [True: 1, False: 90.2k]
  ------------------
 9554|      1|    {
 9555|      1|        if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
  ------------------
  |  Branch (9555:13): [True: 0, False: 1]
  |  Branch (9555:77): [True: 0, False: 0]
  ------------------
 9556|      0|        {
 9557|      0|            IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9558|      0|            IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9559|      0|            IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9560|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9561|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9562|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9563|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9564|      0|            IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9565|      0|            IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9566|      0|            if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (9566:17): [True: 0, False: 0]
  |  Branch (9566:57): [True: 0, False: 0]
  ------------------
 9567|      0|                IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9568|      0|        }
 9569|      1|        else
 9570|      1|        {
 9571|       |            // Disable feature, our backends do not support it
 9572|      1|            g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
 9573|      1|        }
 9574|       |
 9575|       |        // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
 9576|      1|        for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n++)
  ------------------
  |  Branch (9576:33): [True: 0, False: 1]
  ------------------
 9577|      0|        {
 9578|      0|            ImGuiPlatformMonitor& mon = g.PlatformIO.Monitors[monitor_n];
 9579|      0|            IM_UNUSED(mon);
  ------------------
  |  |   88|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9580|      0|            IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9581|      0|            IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9582|      0|            IM_ASSERT(mon.DpiScale != 0.0f);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9583|      0|        }
 9584|      1|    }
 9585|  90.2k|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckEndFrameSanityChecksEv:
 9588|  90.2k|{
 9589|  90.2k|    ImGuiContext& g = *GImGui;
 9590|       |
 9591|       |    // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
 9592|       |    // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
 9593|       |    // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
 9594|       |    // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
 9595|       |    // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
 9596|       |    // while still correctly asserting on mid-frame key press events.
 9597|  90.2k|    const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
 9598|  90.2k|    IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9599|  90.2k|    IM_UNUSED(key_mods);
  ------------------
  |  |   88|  90.2k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 9600|       |
 9601|       |    // [EXPERIMENTAL] Recover from errors: You may call this yourself before EndFrame().
 9602|       |    //ErrorCheckEndFrameRecover();
 9603|       |
 9604|       |    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
 9605|       |    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
 9606|  90.2k|    if (g.CurrentWindowStack.Size != 1)
  ------------------
  |  Branch (9606:9): [True: 0, False: 90.2k]
  ------------------
 9607|      0|    {
 9608|      0|        if (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (9608:13): [True: 0, False: 0]
  ------------------
 9609|      0|        {
 9610|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
  ------------------
  |  |  253|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9611|      0|            while (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (9611:20): [True: 0, False: 0]
  ------------------
 9612|      0|                End();
 9613|      0|        }
 9614|      0|        else
 9615|      0|        {
 9616|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
  ------------------
  |  |  253|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9617|      0|        }
 9618|      0|    }
 9619|       |
 9620|  90.2k|    IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
  ------------------
  |  |  253|  90.2k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 9621|  90.2k|}
imgui.cpp:_ZL38CalcNextScrollFromScrollTargetAndClampP11ImGuiWindow:
10281|   180k|{
10282|   180k|    ImVec2 scroll = window->Scroll;
10283|   180k|    ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
10284|   542k|    for (int axis = 0; axis < 2; axis++)
  ------------------
  |  Branch (10284:24): [True: 361k, False: 180k]
  ------------------
10285|   361k|    {
10286|   361k|        if (window->ScrollTarget[axis] < FLT_MAX)
  ------------------
  |  Branch (10286:13): [True: 142, False: 361k]
  ------------------
10287|    142|        {
10288|    142|            float center_ratio = window->ScrollTargetCenterRatio[axis];
10289|    142|            float scroll_target = window->ScrollTarget[axis];
10290|    142|            if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f)
  ------------------
  |  Branch (10290:17): [True: 0, False: 142]
  ------------------
10291|      0|            {
10292|      0|                float snap_min = 0.0f;
10293|      0|                float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
10294|      0|                scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
10295|      0|            }
10296|    142|            scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
10297|    142|        }
10298|   361k|        scroll[axis] = IM_FLOOR(ImMax(scroll[axis], 0.0f));
  ------------------
  |  |  269|   361k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
10299|   361k|        if (!window->Collapsed && !window->SkipItems)
  ------------------
  |  Branch (10299:13): [True: 181k, False: 179k]
  |  Branch (10299:35): [True: 181k, False: 6]
  ------------------
10300|   181k|            scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
10301|   361k|    }
10302|   180k|    return scroll;
10303|   180k|}
imgui.cpp:_ZN5ImGuiL14NavProcessItemEv:
11352|    112|{
11353|    112|    ImGuiContext& g = *GImGui;
11354|    112|    ImGuiWindow* window = g.CurrentWindow;
11355|    112|    const ImGuiID id = g.LastItemData.ID;
11356|    112|    const ImRect nav_bb = g.LastItemData.NavRect;
11357|    112|    const ImGuiItemFlags item_flags = g.LastItemData.InFlags;
11358|       |
11359|       |    // Process Init Request
11360|    112|    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
  ------------------
  |  Branch (11360:9): [True: 2, False: 110]
  |  Branch (11360:29): [True: 0, False: 2]
  |  Branch (11360:73): [True: 0, False: 0]
  ------------------
11361|      0|    {
11362|       |        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
11363|      0|        const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
11364|      0|        if (candidate_for_nav_default_focus || g.NavInitResultId == 0)
  ------------------
  |  Branch (11364:13): [True: 0, False: 0]
  |  Branch (11364:48): [True: 0, False: 0]
  ------------------
11365|      0|        {
11366|      0|            g.NavInitResultId = id;
11367|      0|            g.NavInitResultRectRel = WindowRectAbsToRel(window, nav_bb);
11368|      0|        }
11369|      0|        if (candidate_for_nav_default_focus)
  ------------------
  |  Branch (11369:13): [True: 0, False: 0]
  ------------------
11370|      0|        {
11371|      0|            g.NavInitRequest = false; // Found a match, clear request
11372|      0|            NavUpdateAnyRequestFlag();
11373|      0|        }
11374|      0|    }
11375|       |
11376|       |    // Process Move Request (scoring for navigation)
11377|       |    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
11378|    112|    if (g.NavMoveScoringItems)
  ------------------
  |  Branch (11378:9): [True: 3, False: 109]
  ------------------
11379|      3|    {
11380|      3|        const bool is_tab_stop = (item_flags & ImGuiItemFlags_Inputable) && (item_flags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;
  ------------------
  |  Branch (11380:34): [True: 0, False: 3]
  |  Branch (11380:77): [True: 0, False: 0]
  ------------------
11381|      3|        const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing) != 0;
11382|      3|        if (is_tabbing)
  ------------------
  |  Branch (11382:13): [True: 0, False: 3]
  ------------------
11383|      0|        {
11384|      0|            if (is_tab_stop || (g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi))
  ------------------
  |  Branch (11384:17): [True: 0, False: 0]
  |  Branch (11384:32): [True: 0, False: 0]
  ------------------
11385|      0|                NavProcessItemForTabbingRequest(id);
11386|      0|        }
11387|      3|        else if ((g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_Disabled))
  ------------------
  |  Branch (11387:19): [True: 3, False: 0]
  |  Branch (11387:36): [True: 0, False: 0]
  |  Branch (11387:95): [True: 3, False: 0]
  ------------------
11388|      3|        {
11389|      3|            ImGuiNavItemData* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
  ------------------
  |  Branch (11389:40): [True: 3, False: 0]
  ------------------
11390|      3|            if (!is_tabbing)
  ------------------
  |  Branch (11390:17): [True: 3, False: 0]
  ------------------
11391|      3|            {
11392|      3|                if (NavScoreItem(result))
  ------------------
  |  Branch (11392:21): [True: 0, False: 3]
  ------------------
11393|      0|                    NavApplyItemToResult(result);
11394|       |
11395|       |                // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
11396|      3|                const float VISIBLE_RATIO = 0.70f;
11397|      3|                if ((g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
  ------------------
  |  Branch (11397:21): [True: 3, False: 0]
  |  Branch (11397:81): [True: 3, False: 0]
  ------------------
11398|      3|                    if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
  ------------------
  |  Branch (11398:25): [True: 3, False: 0]
  ------------------
11399|      3|                        if (NavScoreItem(&g.NavMoveResultLocalVisible))
  ------------------
  |  Branch (11399:29): [True: 0, False: 3]
  ------------------
11400|      0|                            NavApplyItemToResult(&g.NavMoveResultLocalVisible);
11401|      3|            }
11402|      3|        }
11403|      3|    }
11404|       |
11405|       |    // Update window-relative bounding box of navigated item
11406|    112|    if (g.NavId == id)
  ------------------
  |  Branch (11406:9): [True: 107, False: 5]
  ------------------
11407|    107|    {
11408|    107|        if (g.NavWindow != window)
  ------------------
  |  Branch (11408:13): [True: 0, False: 107]
  ------------------
11409|      0|            SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
11410|    107|        g.NavLayer = window->DC.NavLayerCurrent;
11411|    107|        g.NavFocusScopeId = g.CurrentFocusScopeId;
11412|    107|        g.NavIdIsAlive = true;
11413|    107|        window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb);    // Store item bounding box (relative to window position)
11414|    107|    }
11415|    112|}
imgui.cpp:_ZN5ImGuiL12NavScoreItemEP16ImGuiNavItemData:
11206|      6|{
11207|      6|    ImGuiContext& g = *GImGui;
11208|      6|    ImGuiWindow* window = g.CurrentWindow;
11209|      6|    if (g.NavLayer != window->DC.NavLayerCurrent)
  ------------------
  |  Branch (11209:9): [True: 6, False: 0]
  ------------------
11210|      6|        return false;
11211|       |
11212|       |    // FIXME: Those are not good variables names
11213|      0|    ImRect cand = g.LastItemData.NavRect;   // Current item nav rectangle
11214|      0|    const ImRect curr = g.NavScoringRect;   // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
11215|      0|    g.NavScoringDebugCount++;
11216|       |
11217|       |    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
11218|      0|    if (window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (11218:9): [True: 0, False: 0]
  ------------------
11219|      0|    {
11220|      0|        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11221|      0|        if (!window->ClipRect.Overlaps(cand))
  ------------------
  |  Branch (11221:13): [True: 0, False: 0]
  ------------------
11222|      0|            return false;
11223|      0|        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
11224|      0|    }
11225|       |
11226|       |    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
11227|       |    // For example, this ensures that items in one column are not reached when moving vertically from items in another column.
11228|      0|    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);
11229|       |
11230|       |    // Compute distance between boxes
11231|       |    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
11232|      0|    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
11233|      0|    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
11234|      0|    if (dby != 0.0f && dbx != 0.0f)
  ------------------
  |  Branch (11234:9): [True: 0, False: 0]
  |  Branch (11234:24): [True: 0, False: 0]
  ------------------
11235|      0|        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
  ------------------
  |  Branch (11235:34): [True: 0, False: 0]
  ------------------
11236|      0|    float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  436|      0|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  436|      0|#define ImFabs(X)           fabsf(X)
  ------------------
11237|       |
11238|       |    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
11239|      0|    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
11240|      0|    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
11241|      0|    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  436|      0|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  436|      0|#define ImFabs(X)           fabsf(X)
  ------------------
11242|       |
11243|       |    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
11244|      0|    ImGuiDir quadrant;
11245|      0|    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
11246|      0|    if (dbx != 0.0f || dby != 0.0f)
  ------------------
  |  Branch (11246:9): [True: 0, False: 0]
  |  Branch (11246:24): [True: 0, False: 0]
  ------------------
11247|      0|    {
11248|       |        // For non-overlapping boxes, use distance between boxes
11249|      0|        dax = dbx;
11250|      0|        day = dby;
11251|      0|        dist_axial = dist_box;
11252|      0|        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
11253|      0|    }
11254|      0|    else if (dcx != 0.0f || dcy != 0.0f)
  ------------------
  |  Branch (11254:14): [True: 0, False: 0]
  |  Branch (11254:29): [True: 0, False: 0]
  ------------------
11255|      0|    {
11256|       |        // For overlapping boxes with different centers, use distance between centers
11257|      0|        dax = dcx;
11258|      0|        day = dcy;
11259|      0|        dist_axial = dist_center;
11260|      0|        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
11261|      0|    }
11262|      0|    else
11263|      0|    {
11264|       |        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
11265|      0|        quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
  ------------------
  |  Branch (11265:20): [True: 0, False: 0]
  ------------------
11266|      0|    }
11267|       |
11268|       |#if IMGUI_DEBUG_NAV_SCORING
11269|       |    char buf[128];
11270|       |    if (IsMouseHoveringRect(cand.Min, cand.Max))
11271|       |    {
11272|       |        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
11273|       |        ImDrawList* draw_list = GetForegroundDrawList(window);
11274|       |        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));
11275|       |        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
11276|       |        draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40,0,0,150));
11277|       |        draw_list->AddText(cand.Max, ~0U, buf);
11278|       |    }
11279|       |    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
11280|       |    {
11281|       |        if (quadrant == g.NavMoveDir)
11282|       |        {
11283|       |            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
11284|       |            ImDrawList* draw_list = GetForegroundDrawList(window);
11285|       |            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
11286|       |            draw_list->AddText(cand.Min, IM_COL32(255, 255, 255, 255), buf);
11287|       |        }
11288|       |    }
11289|       |#endif
11290|       |
11291|       |    // Is it in the quadrant we're interested in moving to?
11292|      0|    bool new_best = false;
11293|      0|    const ImGuiDir move_dir = g.NavMoveDir;
11294|      0|    if (quadrant == move_dir)
  ------------------
  |  Branch (11294:9): [True: 0, False: 0]
  ------------------
11295|      0|    {
11296|       |        // Does it beat the current best candidate?
11297|      0|        if (dist_box < result->DistBox)
  ------------------
  |  Branch (11297:13): [True: 0, False: 0]
  ------------------
11298|      0|        {
11299|      0|            result->DistBox = dist_box;
11300|      0|            result->DistCenter = dist_center;
11301|      0|            return true;
11302|      0|        }
11303|      0|        if (dist_box == result->DistBox)
  ------------------
  |  Branch (11303:13): [True: 0, False: 0]
  ------------------
11304|      0|        {
11305|       |            // Try using distance between center points to break ties
11306|      0|            if (dist_center < result->DistCenter)
  ------------------
  |  Branch (11306:17): [True: 0, False: 0]
  ------------------
11307|      0|            {
11308|      0|                result->DistCenter = dist_center;
11309|      0|                new_best = true;
11310|      0|            }
11311|      0|            else if (dist_center == result->DistCenter)
  ------------------
  |  Branch (11311:22): [True: 0, False: 0]
  ------------------
11312|      0|            {
11313|       |                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
11314|       |                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
11315|       |                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
11316|      0|                if (((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
  ------------------
  |  Branch (11316:21): [True: 0, False: 0]
  |  Branch (11316:23): [True: 0, False: 0]
  |  Branch (11316:50): [True: 0, False: 0]
  ------------------
11317|      0|                    new_best = true;
11318|      0|            }
11319|      0|        }
11320|      0|    }
11321|       |
11322|       |    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
11323|       |    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
11324|       |    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
11325|       |    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
11326|       |    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
11327|      0|    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
  ------------------
  |  Branch (11327:9): [True: 0, False: 0]
  |  Branch (11327:39): [True: 0, False: 0]
  ------------------
11328|      0|        if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (11328:13): [True: 0, False: 0]
  |  Branch (11328:49): [True: 0, False: 0]
  ------------------
11329|      0|            if ((move_dir == ImGuiDir_Left && dax < 0.0f) || (move_dir == ImGuiDir_Right && dax > 0.0f) || (move_dir == ImGuiDir_Up && day < 0.0f) || (move_dir == ImGuiDir_Down && day > 0.0f))
  ------------------
  |  Branch (11329:18): [True: 0, False: 0]
  |  Branch (11329:47): [True: 0, False: 0]
  |  Branch (11329:63): [True: 0, False: 0]
  |  Branch (11329:93): [True: 0, False: 0]
  |  Branch (11329:109): [True: 0, False: 0]
  |  Branch (11329:136): [True: 0, False: 0]
  |  Branch (11329:152): [True: 0, False: 0]
  |  Branch (11329:181): [True: 0, False: 0]
  ------------------
11330|      0|            {
11331|      0|                result->DistAxial = dist_axial;
11332|      0|                new_best = true;
11333|      0|            }
11334|       |
11335|      0|    return new_best;
11336|      0|}
imgui.cpp:_ZN5ImGuiL28NavRestoreLastChildNavWindowEP11ImGuiWindow:
11548|      3|{
11549|      3|    if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
  ------------------
  |  Branch (11549:9): [True: 1, False: 2]
  |  Branch (11549:42): [True: 0, False: 1]
  ------------------
11550|      0|        return window->NavLastChildNavWindow;
11551|      3|    if (window->DockNodeAsHost && window->DockNodeAsHost->TabBar)
  ------------------
  |  Branch (11551:9): [True: 0, False: 3]
  |  Branch (11551:35): [True: 0, False: 0]
  ------------------
11552|      0|        if (ImGuiTabItem* tab = TabBarFindMostRecentlySelectedTabForActiveWindow(window->DockNodeAsHost->TabBar))
  ------------------
  |  Branch (11552:27): [True: 0, False: 0]
  ------------------
11553|      0|            return tab->Window;
11554|      3|    return window;
11555|      3|}
imgui.cpp:_ZN5ImGuiL23NavUpdateAnyRequestFlagEv:
11587|  90.4k|{
11588|  90.4k|    ImGuiContext& g = *GImGui;
11589|  90.4k|    g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
  ------------------
  |  |  962|   180k|#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
  |  |  ------------------
  |  |  |  Branch (962:37): [Folded - Ignored]
  |  |  ------------------
  ------------------
  |  Branch (11589:23): [True: 30, False: 90.4k]
  |  Branch (11589:48): [True: 2, False: 90.4k]
  |  Branch (11589:96): [True: 0, False: 0]
  ------------------
11590|  90.4k|    if (g.NavAnyRequest)
  ------------------
  |  Branch (11590:9): [True: 32, False: 90.4k]
  ------------------
11591|  90.4k|        IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|  90.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11592|  90.4k|}
imgui.cpp:_ZN5ImGuiL9NavUpdateEv:
11680|  90.2k|{
11681|  90.2k|    ImGuiContext& g = *GImGui;
11682|  90.2k|    ImGuiIO& io = g.IO;
11683|       |
11684|  90.2k|    io.WantSetMousePos = false;
11685|       |    //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
11686|       |
11687|       |    // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
11688|       |    // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
11689|  90.2k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (11689:37): [True: 90.2k, False: 0]
  |  Branch (11689:98): [True: 0, False: 90.2k]
  ------------------
11690|  90.2k|    const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
11691|  90.2k|    if (nav_gamepad_active)
  ------------------
  |  Branch (11691:9): [True: 0, False: 90.2k]
  ------------------
11692|      0|        for (ImGuiKey key : nav_gamepad_keys_to_change_source)
  ------------------
  |  Branch (11692:27): [True: 0, False: 0]
  ------------------
11693|      0|            if (IsKeyDown(key))
  ------------------
  |  Branch (11693:17): [True: 0, False: 0]
  ------------------
11694|      0|                g.NavInputSource = ImGuiInputSource_Gamepad;
11695|  90.2k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
11696|  90.2k|    const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
11697|  90.2k|    if (nav_keyboard_active)
  ------------------
  |  Branch (11697:9): [True: 90.2k, False: 0]
  ------------------
11698|  90.2k|        for (ImGuiKey key : nav_keyboard_keys_to_change_source)
  ------------------
  |  Branch (11698:27): [True: 631k, False: 90.2k]
  ------------------
11699|   631k|            if (IsKeyDown(key))
  ------------------
  |  Branch (11699:17): [True: 26.0k, False: 605k]
  ------------------
11700|  26.0k|                g.NavInputSource = ImGuiInputSource_Keyboard;
11701|       |
11702|       |    // Process navigation init request (select first/default focus)
11703|  90.2k|    if (g.NavInitResultId != 0)
  ------------------
  |  Branch (11703:9): [True: 0, False: 90.2k]
  ------------------
11704|      0|        NavInitRequestApplyResult();
11705|  90.2k|    g.NavInitRequest = false;
11706|  90.2k|    g.NavInitRequestFromMove = false;
11707|  90.2k|    g.NavInitResultId = 0;
11708|  90.2k|    g.NavJustMovedToId = 0;
11709|       |
11710|       |    // Process navigation move request
11711|  90.2k|    if (g.NavMoveSubmitted)
  ------------------
  |  Branch (11711:9): [True: 10, False: 90.2k]
  ------------------
11712|     10|        NavMoveRequestApplyResult();
11713|  90.2k|    g.NavTabbingCounter = 0;
11714|  90.2k|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
11715|       |
11716|       |    // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
11717|  90.2k|    bool set_mouse_pos = false;
11718|  90.2k|    if (g.NavMousePosDirty && g.NavIdIsAlive)
  ------------------
  |  Branch (11718:9): [True: 4, False: 90.2k]
  |  Branch (11718:31): [True: 2, False: 2]
  ------------------
11719|      2|        if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
  ------------------
  |  Branch (11719:13): [True: 2, False: 0]
  |  Branch (11719:39): [True: 2, False: 0]
  |  Branch (11719:65): [True: 2, False: 0]
  ------------------
11720|      2|            set_mouse_pos = true;
11721|  90.2k|    g.NavMousePosDirty = false;
11722|  90.2k|    IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11723|       |
11724|       |    // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
11725|  90.2k|    if (g.NavWindow)
  ------------------
  |  Branch (11725:9): [True: 447, False: 89.7k]
  ------------------
11726|    447|        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
11727|  90.2k|    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (11727:9): [True: 447, False: 89.7k]
  |  Branch (11727:24): [True: 51, False: 396]
  |  Branch (11727:70): [True: 4, False: 47]
  ------------------
11728|      4|        g.NavWindow->NavLastChildNavWindow = NULL;
11729|       |
11730|       |    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
11731|  90.2k|    NavUpdateWindowing();
11732|       |
11733|       |    // Set output flags for user application
11734|  90.2k|    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
  ------------------
  |  Branch (11734:21): [True: 90.2k, False: 0]
  |  Branch (11734:44): [True: 0, False: 0]
  |  Branch (11734:67): [True: 447, False: 89.7k]
  |  Branch (11734:82): [True: 447, False: 0]
  ------------------
11735|  90.2k|    io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);
  ------------------
  |  Branch (11735:22): [True: 447, False: 89.7k]
  |  Branch (11735:38): [True: 252, False: 195]
  |  Branch (11735:54): [True: 4, False: 248]
  |  Branch (11735:81): [True: 0, False: 90.2k]
  ------------------
11736|       |
11737|       |    // Process NavCancel input (to close a popup, get back to parent, clear focus)
11738|  90.2k|    NavUpdateCancelRequest();
11739|       |
11740|       |    // Process manual activation request
11741|  90.2k|    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavActivateInputId = 0;
11742|  90.2k|    g.NavActivateFlags = ImGuiActivateFlags_None;
11743|  90.2k|    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11743:9): [True: 254, False: 89.9k]
  |  Branch (11743:25): [True: 6, False: 248]
  |  Branch (11743:51): [True: 6, False: 0]
  |  Branch (11743:76): [True: 6, False: 0]
  |  Branch (11743:91): [True: 6, False: 0]
  ------------------
11744|      6|    {
11745|      6|        const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate));
  ------------------
  |  | 1260|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  |  Branch (11745:37): [True: 6, False: 0]
  |  Branch (11745:60): [True: 0, False: 6]
  |  Branch (11745:91): [True: 0, False: 6]
  |  Branch (11745:113): [True: 0, False: 0]
  ------------------
11746|      6|        const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, false)));
  ------------------
  |  | 1260|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  |  Branch (11746:39): [True: 0, False: 6]
  |  Branch (11746:58): [True: 0, False: 0]
  |  Branch (11746:81): [True: 0, False: 0]
  |  Branch (11746:122): [True: 0, False: 0]
  |  Branch (11746:144): [True: 0, False: 0]
  ------------------
11747|      6|        const bool input_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Enter)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput));
  ------------------
  |  | 1263|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
  |  Branch (11747:34): [True: 6, False: 0]
  |  Branch (11747:57): [True: 0, False: 6]
  |  Branch (11747:88): [True: 0, False: 6]
  |  Branch (11747:110): [True: 0, False: 0]
  ------------------
11748|      6|        const bool input_pressed = input_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Enter, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, false)));
  ------------------
  |  | 1263|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
  |  Branch (11748:36): [True: 0, False: 6]
  |  Branch (11748:52): [True: 0, False: 0]
  |  Branch (11748:75): [True: 0, False: 0]
  |  Branch (11748:116): [True: 0, False: 0]
  |  Branch (11748:138): [True: 0, False: 0]
  ------------------
11749|      6|        if (g.ActiveId == 0 && activate_pressed)
  ------------------
  |  Branch (11749:13): [True: 6, False: 0]
  |  Branch (11749:32): [True: 0, False: 6]
  ------------------
11750|      0|        {
11751|      0|            g.NavActivateId = g.NavId;
11752|      0|            g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
11753|      0|        }
11754|      6|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed)
  ------------------
  |  Branch (11754:14): [True: 6, False: 0]
  |  Branch (11754:33): [True: 0, False: 0]
  |  Branch (11754:59): [True: 0, False: 6]
  ------------------
11755|      0|        {
11756|      0|            g.NavActivateInputId = g.NavId;
11757|      0|            g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
11758|      0|        }
11759|      6|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
  ------------------
  |  Branch (11759:14): [True: 6, False: 0]
  |  Branch (11759:33): [True: 0, False: 0]
  |  Branch (11759:59): [True: 0, False: 6]
  ------------------
11760|      0|            g.NavActivateDownId = g.NavId;
11761|      6|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
  ------------------
  |  Branch (11761:14): [True: 6, False: 0]
  |  Branch (11761:33): [True: 0, False: 0]
  |  Branch (11761:59): [True: 0, False: 6]
  ------------------
11762|      0|            g.NavActivatePressedId = g.NavId;
11763|      6|    }
11764|  90.2k|    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11764:9): [True: 447, False: 89.7k]
  |  Branch (11764:24): [True: 0, False: 447]
  ------------------
11765|      0|        g.NavDisableHighlight = true;
11766|  90.2k|    if (g.NavActivateId != 0)
  ------------------
  |  Branch (11766:9): [True: 0, False: 90.2k]
  ------------------
11767|  90.2k|        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11768|       |
11769|       |    // Process programmatic activation request
11770|       |    // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
11771|  90.2k|    if (g.NavNextActivateId != 0)
  ------------------
  |  Branch (11771:9): [True: 0, False: 90.2k]
  ------------------
11772|      0|    {
11773|      0|        if (g.NavNextActivateFlags & ImGuiActivateFlags_PreferInput)
  ------------------
  |  Branch (11773:13): [True: 0, False: 0]
  ------------------
11774|      0|            g.NavActivateInputId = g.NavNextActivateId;
11775|      0|        else
11776|      0|            g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
11777|      0|        g.NavActivateFlags = g.NavNextActivateFlags;
11778|      0|    }
11779|  90.2k|    g.NavNextActivateId = 0;
11780|       |
11781|       |    // Process move requests
11782|  90.2k|    NavUpdateCreateMoveRequest();
11783|  90.2k|    if (g.NavMoveDir == ImGuiDir_None)
  ------------------
  |  Branch (11783:9): [True: 90.2k, False: 15]
  ------------------
11784|  90.2k|        NavUpdateCreateTabbingRequest();
11785|  90.2k|    NavUpdateAnyRequestFlag();
11786|  90.2k|    g.NavIdIsAlive = false;
11787|       |
11788|       |    // Scrolling
11789|  90.2k|    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
  ------------------
  |  Branch (11789:9): [True: 447, False: 89.7k]
  |  Branch (11789:24): [True: 447, False: 0]
  |  Branch (11789:80): [True: 447, False: 0]
  ------------------
11790|    447|    {
11791|       |        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
11792|    447|        ImGuiWindow* window = g.NavWindow;
11793|    447|        const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
  ------------------
  |  |  270|    447|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
11794|    447|        const ImGuiDir move_dir = g.NavMoveDir;
11795|    447|        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll && move_dir != ImGuiDir_None)
  ------------------
  |  Branch (11795:13): [True: 193, False: 254]
  |  Branch (11795:55): [True: 155, False: 38]
  |  Branch (11795:82): [True: 6, False: 149]
  ------------------
11796|      6|        {
11797|      6|            if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
  ------------------
  |  Branch (11797:17): [True: 0, False: 6]
  |  Branch (11797:46): [True: 5, False: 1]
  ------------------
11798|      5|                SetScrollX(window, ImFloor(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (11798:64): [True: 0, False: 5]
  ------------------
11799|      6|            if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
  ------------------
  |  Branch (11799:17): [True: 1, False: 5]
  |  Branch (11799:44): [True: 0, False: 5]
  ------------------
11800|      1|                SetScrollY(window, ImFloor(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (11800:64): [True: 1, False: 0]
  ------------------
11801|      6|        }
11802|       |
11803|       |        // *Normal* Manual scroll with LStick
11804|       |        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
11805|    447|        if (nav_gamepad_active)
  ------------------
  |  Branch (11805:13): [True: 0, False: 447]
  ------------------
11806|      0|        {
11807|      0|            const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
11808|      0|            const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1258|      0|#define ImGuiKey_NavGamepadTweakSlow    ImGuiKey_GamepadL1
  ------------------
                          const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1259|      0|#define ImGuiKey_NavGamepadTweakFast    ImGuiKey_GamepadR1
  ------------------
  |  Branch (11808:40): [True: 0, False: 0]
  |  Branch (11808:97): [True: 0, False: 0]
  ------------------
11809|      0|            if (scroll_dir.x != 0.0f && window->ScrollbarX)
  ------------------
  |  Branch (11809:17): [True: 0, False: 0]
  |  Branch (11809:41): [True: 0, False: 0]
  ------------------
11810|      0|                SetScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
11811|      0|            if (scroll_dir.y != 0.0f)
  ------------------
  |  Branch (11811:17): [True: 0, False: 0]
  ------------------
11812|      0|                SetScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
11813|      0|        }
11814|    447|    }
11815|       |
11816|       |    // Always prioritize mouse highlight if navigation is disabled
11817|  90.2k|    if (!nav_keyboard_active && !nav_gamepad_active)
  ------------------
  |  Branch (11817:9): [True: 0, False: 90.2k]
  |  Branch (11817:33): [True: 0, False: 0]
  ------------------
11818|      0|    {
11819|      0|        g.NavDisableHighlight = true;
11820|      0|        g.NavDisableMouseHover = set_mouse_pos = false;
11821|      0|    }
11822|       |
11823|       |    // Update mouse position if requested
11824|       |    // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
11825|  90.2k|    if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
  ------------------
  |  Branch (11825:9): [True: 2, False: 90.2k]
  |  Branch (11825:26): [True: 0, False: 2]
  |  Branch (11825:86): [True: 0, False: 0]
  ------------------
11826|      0|    {
11827|      0|        io.MousePos = io.MousePosPrev = NavCalcPreferredRefPos();
11828|      0|        io.WantSetMousePos = true;
11829|       |        //IMGUI_DEBUG_LOG_IO("SetMousePos: (%.1f,%.1f)\n", io.MousePos.x, io.MousePos.y);
11830|      0|    }
11831|       |
11832|       |    // [DEBUG]
11833|  90.2k|    g.NavScoringDebugCount = 0;
11834|       |#if IMGUI_DEBUG_NAV_RECTS
11835|       |    if (g.NavWindow)
11836|       |    {
11837|       |        ImDrawList* draw_list = GetForegroundDrawList(g.NavWindow);
11838|       |        if (1) { for (int layer = 0; layer < 2; layer++) { ImRect r = WindowRectRelToAbs(g.NavWindow, g.NavWindow->NavRectRel[layer]); draw_list->AddRect(r.Min, r.Max, IM_COL32(255,200,0,255)); } } // [DEBUG]
11839|       |        if (1) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
11840|       |    }
11841|       |#endif
11842|  90.2k|}
imgui.cpp:_ZN5ImGuiL35NavSaveLastChildNavWindowIntoParentEP11ImGuiWindow:
11537|    447|{
11538|    447|    ImGuiWindow* parent = nav_window;
11539|    642|    while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (11539:12): [True: 642, False: 0]
  |  Branch (11539:22): [True: 195, False: 447]
  |  Branch (11539:54): [True: 195, False: 0]
  ------------------
11540|    195|        parent = parent->ParentWindow;
11541|    447|    if (parent && parent != nav_window)
  ------------------
  |  Branch (11541:9): [True: 447, False: 0]
  |  Branch (11541:19): [True: 195, False: 252]
  ------------------
11542|    195|        parent->NavLastChildNavWindow = nav_window;
11543|    447|}
imgui.cpp:_ZN5ImGuiL18NavUpdateWindowingEv:
12325|  90.2k|{
12326|  90.2k|    ImGuiContext& g = *GImGui;
12327|  90.2k|    ImGuiIO& io = g.IO;
12328|       |
12329|  90.2k|    ImGuiWindow* apply_focus_window = NULL;
12330|  90.2k|    bool apply_toggle_layer = false;
12331|       |
12332|  90.2k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
12333|  90.2k|    bool allow_windowing = (modal_window == NULL);
12334|  90.2k|    if (!allow_windowing)
  ------------------
  |  Branch (12334:9): [True: 0, False: 90.2k]
  ------------------
12335|      0|        g.NavWindowingTarget = NULL;
12336|       |
12337|       |    // Fade out
12338|  90.2k|    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
  ------------------
  |  Branch (12338:9): [True: 0, False: 90.2k]
  |  Branch (12338:37): [True: 0, False: 0]
  ------------------
12339|      0|    {
12340|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
12341|      0|        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (12341:13): [True: 0, False: 0]
  |  Branch (12341:37): [True: 0, False: 0]
  ------------------
12342|      0|            g.NavWindowingTargetAnim = NULL;
12343|      0|    }
12344|       |
12345|       |    // Start CTRL+Tab or Square+L/R window selection
12346|  90.2k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12346:37): [True: 90.2k, False: 0]
  |  Branch (12346:98): [True: 0, False: 90.2k]
  ------------------
12347|  90.2k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12348|  90.2k|    const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
  ------------------
  |  | 1320|  90.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12348:39): [True: 90.2k, False: 0]
  |  Branch (12348:58): [True: 90.2k, False: 0]
  |  Branch (12348:89): [True: 0, False: 90.2k]
  ------------------
12349|  90.2k|    const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
  ------------------
  |  | 1320|  90.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12349:39): [True: 90.2k, False: 0]
  |  Branch (12349:58): [True: 90.2k, False: 0]
  |  Branch (12349:89): [True: 0, False: 90.2k]
  ------------------
12350|  90.2k|    const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, 0, ImGuiInputFlags_None);
  ------------------
  |  | 1262|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (12350:47): [True: 90.2k, False: 0]
  |  Branch (12350:66): [True: 0, False: 90.2k]
  |  Branch (12350:88): [True: 0, False: 0]
  |  Branch (12350:113): [True: 0, False: 0]
  ------------------
12351|  90.2k|    const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
  ------------------
  |  Branch (12351:48): [True: 90.2k, False: 0]
  |  Branch (12351:67): [True: 90.2k, False: 0]
  |  Branch (12351:93): [True: 0, False: 90.2k]
  |  Branch (12351:117): [True: 0, False: 90.2k]
  ------------------
12352|  90.2k|    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
  ------------------
  |  Branch (12352:9): [True: 0, False: 90.2k]
  |  Branch (12352:41): [True: 0, False: 90.2k]
  ------------------
12353|      0|        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
  ------------------
  |  Branch (12353:26): [True: 0, False: 0]
  ------------------
12354|      0|        {
12355|      0|            g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
12356|      0|            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
12357|      0|            g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
12358|      0|            g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
  ------------------
  |  Branch (12358:41): [True: 0, False: 0]
  ------------------
12359|      0|            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
  ------------------
  |  Branch (12359:32): [True: 0, False: 0]
  ------------------
12360|      0|        }
12361|       |
12362|       |    // Gamepad update
12363|  90.2k|    g.NavWindowingTimer += io.DeltaTime;
12364|  90.2k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (12364:9): [True: 0, False: 90.2k]
  |  Branch (12364:33): [True: 0, False: 0]
  ------------------
12365|      0|    {
12366|       |        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
12367|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
12368|       |
12369|       |        // Select window to focus
12370|      0|        const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
12371|      0|        if (focus_change_dir != 0)
  ------------------
  |  Branch (12371:13): [True: 0, False: 0]
  ------------------
12372|      0|        {
12373|      0|            NavUpdateWindowingHighlightWindow(focus_change_dir);
12374|      0|            g.NavWindowingHighlightAlpha = 1.0f;
12375|      0|        }
12376|       |
12377|       |        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
12378|      0|        if (!IsKeyDown(ImGuiKey_NavGamepadMenu))
  ------------------
  |  | 1262|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (12378:13): [True: 0, False: 0]
  ------------------
12379|      0|        {
12380|      0|            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
12381|      0|            if (g.NavWindowingToggleLayer && g.NavWindow)
  ------------------
  |  Branch (12381:17): [True: 0, False: 0]
  |  Branch (12381:46): [True: 0, False: 0]
  ------------------
12382|      0|                apply_toggle_layer = true;
12383|      0|            else if (!g.NavWindowingToggleLayer)
  ------------------
  |  Branch (12383:22): [True: 0, False: 0]
  ------------------
12384|      0|                apply_focus_window = g.NavWindowingTarget;
12385|      0|            g.NavWindowingTarget = NULL;
12386|      0|        }
12387|      0|    }
12388|       |
12389|       |    // Keyboard: Focus
12390|  90.2k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (12390:9): [True: 0, False: 90.2k]
  |  Branch (12390:33): [True: 0, False: 0]
  ------------------
12391|      0|    {
12392|       |        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
12393|      0|        ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
  ------------------
  |  Branch (12393:39): [True: 0, False: 0]
  |  Branch (12393:118): [True: 0, False: 0]
  ------------------
12394|      0|        IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12395|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
12396|      0|        if (keyboard_next_window || keyboard_prev_window)
  ------------------
  |  Branch (12396:13): [True: 0, False: 0]
  |  Branch (12396:37): [True: 0, False: 0]
  ------------------
12397|      0|            NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
  ------------------
  |  Branch (12397:47): [True: 0, False: 0]
  ------------------
12398|      0|        else if ((io.KeyMods & shared_mods) != shared_mods)
  ------------------
  |  Branch (12398:18): [True: 0, False: 0]
  ------------------
12399|      0|            apply_focus_window = g.NavWindowingTarget;
12400|      0|    }
12401|       |
12402|       |    // Keyboard: Press and Release ALT to toggle menu layer
12403|       |    // - Testing that only Alt is tested prevents Alt+Shift or AltGR from toggling menu layer.
12404|       |    // - AltGR is normally Alt+Ctrl but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl). But even on keyboards without AltGR we don't want Alt+Ctrl to open menu anyway.
12405|  90.2k|    if (nav_keyboard_active && IsKeyPressed(ImGuiMod_Alt, ImGuiKeyOwner_None))
  ------------------
  |  | 1320|  90.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12405:9): [True: 90.2k, False: 0]
  |  Branch (12405:32): [True: 0, False: 90.2k]
  ------------------
12406|      0|    {
12407|      0|        g.NavWindowingToggleLayer = true;
12408|      0|        g.NavInputSource = ImGuiInputSource_Keyboard;
12409|      0|    }
12410|  90.2k|    if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (12410:9): [True: 0, False: 90.2k]
  |  Branch (12410:38): [True: 0, False: 0]
  ------------------
12411|      0|    {
12412|       |        // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
12413|       |        // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
12414|       |        // We cancel toggling nav layer if an owner has claimed the key.
12415|      0|        if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_None) == false)
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12415:13): [True: 0, False: 0]
  |  Branch (12415:49): [True: 0, False: 0]
  |  Branch (12415:63): [True: 0, False: 0]
  |  Branch (12415:78): [True: 0, False: 0]
  |  Branch (12415:93): [True: 0, False: 0]
  ------------------
12416|      0|            g.NavWindowingToggleLayer = false;
12417|       |
12418|       |        // Apply layer toggle on release
12419|       |        // Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
12420|      0|        if (IsKeyReleased(ImGuiMod_Alt) && g.NavWindowingToggleLayer)
  ------------------
  |  Branch (12420:13): [True: 0, False: 0]
  |  Branch (12420:44): [True: 0, False: 0]
  ------------------
12421|      0|            if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (12421:17): [True: 0, False: 0]
  |  Branch (12421:36): [True: 0, False: 0]
  ------------------
12422|      0|                if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (12422:21): [True: 0, False: 0]
  ------------------
12423|      0|                    apply_toggle_layer = true;
12424|      0|        if (!IsKeyDown(ImGuiMod_Alt))
  ------------------
  |  Branch (12424:13): [True: 0, False: 0]
  ------------------
12425|      0|            g.NavWindowingToggleLayer = false;
12426|      0|    }
12427|       |
12428|       |    // Move window
12429|  90.2k|    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (12429:9): [True: 0, False: 90.2k]
  |  Branch (12429:33): [True: 0, False: 0]
  ------------------
12430|      0|    {
12431|      0|        ImVec2 nav_move_dir;
12432|      0|        if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
  ------------------
  |  Branch (12432:13): [True: 0, False: 0]
  |  Branch (12432:62): [True: 0, False: 0]
  ------------------
12433|      0|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
12434|      0|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (12434:13): [True: 0, False: 0]
  ------------------
12435|      0|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
12436|      0|        if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
  ------------------
  |  Branch (12436:13): [True: 0, False: 0]
  |  Branch (12436:39): [True: 0, False: 0]
  ------------------
12437|      0|        {
12438|      0|            const float NAV_MOVE_SPEED = 800.0f;
12439|      0|            const float move_step = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
12440|      0|            g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
12441|      0|            g.NavDisableMouseHover = true;
12442|      0|            ImVec2 accum_floored = ImFloor(g.NavWindowingAccumDeltaPos);
12443|      0|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (12443:17): [True: 0, False: 0]
  |  Branch (12443:44): [True: 0, False: 0]
  ------------------
12444|      0|            {
12445|      0|                ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
12446|      0|                SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
12447|      0|                g.NavWindowingAccumDeltaPos -= accum_floored;
12448|      0|            }
12449|      0|        }
12450|      0|    }
12451|       |
12452|       |    // Apply final focus
12453|  90.2k|    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
  ------------------
  |  Branch (12453:9): [True: 0, False: 90.2k]
  |  Branch (12453:32): [True: 0, False: 0]
  |  Branch (12453:55): [True: 0, False: 0]
  ------------------
12454|      0|    {
12455|      0|        ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
  ------------------
  |  Branch (12455:44): [True: 0, False: 0]
  ------------------
12456|      0|        ClearActiveID();
12457|      0|        NavRestoreHighlightAfterMove();
12458|      0|        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
12459|      0|        ClosePopupsOverWindow(apply_focus_window, false);
12460|      0|        FocusWindow(apply_focus_window);
12461|      0|        if (apply_focus_window->NavLastIds[0] == 0)
  ------------------
  |  Branch (12461:13): [True: 0, False: 0]
  ------------------
12462|      0|            NavInitWindow(apply_focus_window, false);
12463|       |
12464|       |        // If the window has ONLY a menu layer (no main layer), select it directly
12465|       |        // Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
12466|       |        // so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
12467|       |        // the target window as already been previewed once.
12468|       |        // FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
12469|       |        // we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
12470|       |        // won't be valid.
12471|      0|        if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
  ------------------
  |  Branch (12471:13): [True: 0, False: 0]
  ------------------
12472|      0|            g.NavLayer = ImGuiNavLayer_Menu;
12473|       |
12474|       |        // Request OS level focus
12475|      0|        if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
  ------------------
  |  Branch (12475:13): [True: 0, False: 0]
  |  Branch (12475:66): [True: 0, False: 0]
  ------------------
12476|      0|            g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
12477|      0|    }
12478|  90.2k|    if (apply_focus_window)
  ------------------
  |  Branch (12478:9): [True: 0, False: 90.2k]
  ------------------
12479|      0|        g.NavWindowingTarget = NULL;
12480|       |
12481|       |    // Apply menu/layer toggle
12482|  90.2k|    if (apply_toggle_layer && g.NavWindow)
  ------------------
  |  Branch (12482:9): [True: 0, False: 90.2k]
  |  Branch (12482:31): [True: 0, False: 0]
  ------------------
12483|      0|    {
12484|      0|        ClearActiveID();
12485|       |
12486|       |        // Move to parent menu if necessary
12487|      0|        ImGuiWindow* new_nav_window = g.NavWindow;
12488|      0|        while (new_nav_window->ParentWindow
  ------------------
  |  Branch (12488:16): [True: 0, False: 0]
  ------------------
12489|      0|            && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
  ------------------
  |  Branch (12489:16): [True: 0, False: 0]
  ------------------
12490|      0|            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
  ------------------
  |  Branch (12490:16): [True: 0, False: 0]
  ------------------
12491|      0|            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (12491:16): [True: 0, False: 0]
  ------------------
12492|      0|            new_nav_window = new_nav_window->ParentWindow;
12493|      0|        if (new_nav_window != g.NavWindow)
  ------------------
  |  Branch (12493:13): [True: 0, False: 0]
  ------------------
12494|      0|        {
12495|      0|            ImGuiWindow* old_nav_window = g.NavWindow;
12496|      0|            FocusWindow(new_nav_window);
12497|      0|            new_nav_window->NavLastChildNavWindow = old_nav_window;
12498|      0|        }
12499|       |
12500|       |        // Toggle layer
12501|      0|        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
  ------------------
  |  Branch (12501:45): [True: 0, False: 0]
  ------------------
12502|      0|        if (new_nav_layer != g.NavLayer)
  ------------------
  |  Branch (12502:13): [True: 0, False: 0]
  ------------------
12503|      0|        {
12504|       |            // Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
12505|      0|            const bool preserve_layer_1_nav_id = (new_nav_window->DockNodeAsHost != NULL);
12506|      0|            if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id)
  ------------------
  |  Branch (12506:17): [True: 0, False: 0]
  |  Branch (12506:56): [True: 0, False: 0]
  ------------------
12507|      0|                g.NavWindow->NavLastIds[new_nav_layer] = 0;
12508|      0|            NavRestoreLayer(new_nav_layer);
12509|      0|            NavRestoreHighlightAfterMove();
12510|      0|        }
12511|      0|    }
12512|  90.2k|}
imgui.cpp:_ZN5ImGuiL15NavRestoreLayerE13ImGuiNavLayer:
11558|      3|{
11559|      3|    ImGuiContext& g = *GImGui;
11560|      3|    if (layer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (11560:9): [True: 3, False: 0]
  ------------------
11561|      3|    {
11562|      3|        ImGuiWindow* prev_nav_window = g.NavWindow;
11563|      3|        g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);    // FIXME-NAV: Should clear ongoing nav requests?
11564|      3|        if (prev_nav_window)
  ------------------
  |  Branch (11564:13): [True: 3, False: 0]
  ------------------
11565|      3|            IMGUI_DEBUG_LOG_FOCUS("[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window->Name, g.NavWindow->Name);
  ------------------
  |  |  230|      3|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (230:50): [True: 0, False: 3]
  |  |  |  Branch (230:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11566|      3|    }
11567|      3|    ImGuiWindow* window = g.NavWindow;
11568|      3|    if (window->NavLastIds[layer] != 0)
  ------------------
  |  Branch (11568:9): [True: 3, False: 0]
  ------------------
11569|      3|    {
11570|      3|        SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
11571|      3|    }
11572|      0|    else
11573|      0|    {
11574|      0|        g.NavLayer = layer;
11575|      0|        NavInitWindow(window, true);
11576|      0|    }
11577|      3|}
imgui.cpp:_ZN5ImGuiL22NavUpdateCancelRequestEv:
12091|  90.2k|{
12092|  90.2k|    ImGuiContext& g = *GImGui;
12093|  90.2k|    const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12093:37): [True: 90.2k, False: 0]
  |  Branch (12093:100): [True: 0, False: 90.2k]
  ------------------
12094|  90.2k|    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12095|  90.2k|    if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1320|  90.2k|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1261|      0|#define ImGuiKey_NavGamepadCancel       ImGuiKey_GamepadFaceRight
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ImGuiKeyOwner_None)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, ImGuiKeyOwner_None)))
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12095:11): [True: 90.2k, False: 0]
  |  Branch (12095:34): [True: 542, False: 89.6k]
  |  Branch (12095:90): [True: 0, False: 89.6k]
  |  Branch (12095:112): [True: 0, False: 0]
  ------------------
12096|  89.6k|        return;
12097|       |
12098|    542|    IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
  ------------------
  |  |  232|    542|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (232:50): [True: 0, False: 542]
  |  |  |  Branch (232:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
12099|    542|    if (g.ActiveId != 0)
  ------------------
  |  Branch (12099:9): [True: 0, False: 542]
  ------------------
12100|      0|    {
12101|      0|        ClearActiveID();
12102|      0|    }
12103|    542|    else if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (12103:14): [True: 0, False: 542]
  ------------------
12104|      0|    {
12105|       |        // Leave the "menu" layer
12106|      0|        NavRestoreLayer(ImGuiNavLayer_Main);
12107|      0|        NavRestoreHighlightAfterMove();
12108|      0|    }
12109|    542|    else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
  ------------------
  |  Branch (12109:14): [True: 2, False: 540]
  |  Branch (12109:29): [True: 2, False: 0]
  |  Branch (12109:71): [True: 2, False: 0]
  |  Branch (12109:121): [True: 2, False: 0]
  ------------------
12110|      2|    {
12111|       |        // Exit child window
12112|      2|        ImGuiWindow* child_window = g.NavWindow;
12113|      2|        ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
12114|      2|        IM_ASSERT(child_window->ChildId != 0);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12115|      2|        ImRect child_rect = child_window->Rect();
12116|      2|        FocusWindow(parent_window);
12117|      2|        SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_rect));
12118|      2|        NavRestoreHighlightAfterMove();
12119|      2|    }
12120|    540|    else if (g.OpenPopupStack.Size > 0 && g.OpenPopupStack.back().Window != NULL && !(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
  ------------------
  |  Branch (12120:14): [True: 0, False: 540]
  |  Branch (12120:43): [True: 0, False: 0]
  |  Branch (12120:85): [True: 0, False: 0]
  ------------------
12121|      0|    {
12122|       |        // Close open popup/menu
12123|      0|        ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
12124|      0|    }
12125|    540|    else
12126|    540|    {
12127|       |        // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
12128|    540|        if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
  ------------------
  |  Branch (12128:13): [True: 0, False: 540]
  |  Branch (12128:29): [True: 0, False: 0]
  |  Branch (12128:78): [True: 0, False: 0]
  ------------------
12129|      0|            g.NavWindow->NavLastIds[0] = 0;
12130|    540|        g.NavId = 0;
12131|    540|    }
12132|    542|}
imgui.cpp:_ZN5ImGuiL26NavUpdateCreateMoveRequestEv:
11861|  90.2k|{
11862|  90.2k|    ImGuiContext& g = *GImGui;
11863|  90.2k|    ImGuiIO& io = g.IO;
11864|  90.2k|    ImGuiWindow* window = g.NavWindow;
11865|  90.2k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (11865:37): [True: 90.2k, False: 0]
  |  Branch (11865:98): [True: 0, False: 90.2k]
  ------------------
11866|  90.2k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
11867|       |
11868|  90.2k|    if (g.NavMoveForwardToNextFrame && window != NULL)
  ------------------
  |  Branch (11868:9): [True: 0, False: 90.2k]
  |  Branch (11868:40): [True: 0, False: 0]
  ------------------
11869|      0|    {
11870|       |        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
11871|       |        // (preserve most state, which were already set by the NavMoveRequestForward() function)
11872|      0|        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11873|      0|        IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11874|      0|        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
  ------------------
  |  |  232|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (232:50): [True: 0, False: 0]
  |  |  |  Branch (232:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11875|      0|    }
11876|  90.2k|    else
11877|  90.2k|    {
11878|       |        // Initiate directional inputs request
11879|  90.2k|        g.NavMoveDir = ImGuiDir_None;
11880|  90.2k|        g.NavMoveFlags = ImGuiNavMoveFlags_None;
11881|  90.2k|        g.NavMoveScrollFlags = ImGuiScrollFlags_None;
11882|  90.2k|        if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11882:13): [True: 447, False: 89.7k]
  |  Branch (11882:23): [True: 447, False: 0]
  |  Branch (11882:48): [True: 447, False: 0]
  ------------------
11883|    447|        {
11884|    447|            const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateNavMove;
11885|    447|            if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1320|    292|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11885:17): [True: 292, False: 155]
  |  Branch (11885:61): [True: 0, False: 292]
  |  Branch (11885:83): [True: 0, False: 0]
  |  Branch (11885:161): [True: 292, False: 0]
  |  Branch (11885:184): [True: 0, False: 292]
  ------------------
11886|    447|            if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1320|    292|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11886:17): [True: 292, False: 155]
  |  Branch (11886:61): [True: 0, False: 292]
  |  Branch (11886:83): [True: 0, False: 0]
  |  Branch (11886:161): [True: 292, False: 0]
  |  Branch (11886:184): [True: 9, False: 283]
  ------------------
11887|    447|            if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1320|    292|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11887:17): [True: 292, False: 155]
  |  Branch (11887:61): [True: 0, False: 292]
  |  Branch (11887:83): [True: 0, False: 0]
  |  Branch (11887:161): [True: 292, False: 0]
  |  Branch (11887:184): [True: 3, False: 289]
  ------------------
11888|    447|            if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1320|      0|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  ImGuiKeyOwner_None, repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  ImGuiKeyOwner_None, repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1320|    292|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11888:17): [True: 292, False: 155]
  |  Branch (11888:61): [True: 0, False: 292]
  |  Branch (11888:83): [True: 0, False: 0]
  |  Branch (11888:161): [True: 292, False: 0]
  |  Branch (11888:184): [True: 0, False: 292]
  ------------------
11889|    447|        }
11890|  90.2k|        g.NavMoveClipDir = g.NavMoveDir;
11891|  90.2k|        g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
11892|  90.2k|    }
11893|       |
11894|       |    // Update PageUp/PageDown/Home/End scroll
11895|       |    // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
11896|  90.2k|    float scoring_rect_offset_y = 0.0f;
11897|  90.2k|    if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
  ------------------
  |  Branch (11897:9): [True: 447, False: 89.7k]
  |  Branch (11897:19): [True: 435, False: 12]
  |  Branch (11897:52): [True: 435, False: 0]
  ------------------
11898|    435|        scoring_rect_offset_y = NavUpdatePageUpPageDown();
11899|  90.2k|    if (scoring_rect_offset_y != 0.0f)
  ------------------
  |  Branch (11899:9): [True: 0, False: 90.2k]
  ------------------
11900|      0|    {
11901|      0|        g.NavScoringNoClipRect = window->InnerRect;
11902|      0|        g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
11903|      0|    }
11904|       |
11905|       |    // [DEBUG] Always send a request
11906|       |#if IMGUI_DEBUG_NAV_SCORING
11907|       |    if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
11908|       |        g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
11909|       |    if (io.KeyCtrl && g.NavMoveDir == ImGuiDir_None)
11910|       |    {
11911|       |        g.NavMoveDir = g.NavMoveDirForDebug;
11912|       |        g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
11913|       |    }
11914|       |#endif
11915|       |
11916|       |    // Submit
11917|  90.2k|    g.NavMoveForwardToNextFrame = false;
11918|  90.2k|    if (g.NavMoveDir != ImGuiDir_None)
  ------------------
  |  Branch (11918:9): [True: 15, False: 90.2k]
  ------------------
11919|     15|        NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
11920|       |
11921|       |    // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
11922|  90.2k|    if (g.NavMoveSubmitted && g.NavId == 0)
  ------------------
  |  Branch (11922:9): [True: 15, False: 90.2k]
  |  Branch (11922:31): [True: 12, False: 3]
  ------------------
11923|     12|    {
11924|     12|        IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
  ------------------
  |  |  232|     12|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (225:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (232:50): [True: 0, False: 12]
  |  |  |  Branch (232:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
11925|     12|        g.NavInitRequest = g.NavInitRequestFromMove = true;
11926|     12|        g.NavInitResultId = 0;
11927|     12|        g.NavDisableHighlight = false;
11928|     12|    }
11929|       |
11930|       |    // When using gamepad, we project the reference nav bounding box into window visible area.
11931|       |    // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling, since with gamepad all movements are relative
11932|       |    // (can't focus a visible object like we can with the mouse).
11933|  90.2k|    if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != NULL)// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
  ------------------
  |  Branch (11933:9): [True: 15, False: 90.2k]
  |  Branch (11933:31): [True: 0, False: 15]
  |  Branch (11933:79): [True: 0, False: 0]
  |  Branch (11933:115): [True: 0, False: 0]
  ------------------
11934|      0|    {
11935|      0|        bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
11936|      0|        bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
11937|      0|        ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));
11938|      0|        if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
  ------------------
  |  Branch (11938:14): [True: 0, False: 0]
  |  Branch (11938:25): [True: 0, False: 0]
  |  Branch (11938:37): [True: 0, False: 0]
  ------------------
11939|      0|        {
11940|       |            //IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
11941|      0|            float pad_x = ImMin(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
11942|      0|            float pad_y = ImMin(inner_rect_rel.GetHeight(), window->CalcFontSize() * 0.5f); // Terrible approximation for the intent of starting navigation from first fully visible item
11943|      0|            inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX;
  ------------------
  |  Branch (11943:36): [True: 0, False: 0]
  ------------------
11944|      0|            inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX;
  ------------------
  |  Branch (11944:36): [True: 0, False: 0]
  ------------------
11945|      0|            inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
  ------------------
  |  Branch (11945:36): [True: 0, False: 0]
  ------------------
11946|      0|            inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
  ------------------
  |  Branch (11946:36): [True: 0, False: 0]
  ------------------
11947|      0|            window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
11948|      0|            g.NavId = 0;
11949|      0|        }
11950|      0|    }
11951|       |
11952|       |    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
11953|  90.2k|    ImRect scoring_rect;
11954|  90.2k|    if (window != NULL)
  ------------------
  |  Branch (11954:9): [True: 447, False: 89.7k]
  ------------------
11955|    447|    {
11956|    447|        ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
  ------------------
  |  Branch (11956:31): [True: 447, False: 0]
  ------------------
11957|    447|        scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
11958|    447|        scoring_rect.TranslateY(scoring_rect_offset_y);
11959|    447|        scoring_rect.Min.x = ImMin(scoring_rect.Min.x + 1.0f, scoring_rect.Max.x);
11960|    447|        scoring_rect.Max.x = scoring_rect.Min.x;
11961|    447|        IM_ASSERT(!scoring_rect.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
  ------------------
  |  |   23|    447|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11962|       |        //GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
11963|       |        //if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
11964|    447|    }
11965|  90.2k|    g.NavScoringRect = scoring_rect;
11966|  90.2k|    g.NavScoringNoClipRect.Add(scoring_rect);
11967|  90.2k|}
imgui.cpp:_ZN5ImGuiL23NavUpdatePageUpPageDownEv:
12139|    435|{
12140|    435|    ImGuiContext& g = *GImGui;
12141|    435|    ImGuiWindow* window = g.NavWindow;
12142|    435|    if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (12142:9): [True: 0, False: 435]
  |  Branch (12142:59): [True: 0, False: 435]
  ------------------
12143|      0|        return 0.0f;
12144|       |
12145|    435|    const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ImGuiKeyOwner_None);
  ------------------
  |  | 1320|    435|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12146|    435|    const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ImGuiKeyOwner_None);
  ------------------
  |  | 1320|    435|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12147|    435|    const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
  ------------------
  |  | 1320|    435|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12148|    435|    const bool end_pressed = IsKeyPressed(ImGuiKey_End, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat);
  ------------------
  |  | 1320|    435|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
12149|    435|    if (page_up_held == page_down_held && home_pressed == end_pressed) // Proceed if either (not both) are pressed, otherwise early out
  ------------------
  |  Branch (12149:9): [True: 420, False: 15]
  |  Branch (12149:43): [True: 420, False: 0]
  ------------------
12150|    420|        return 0.0f;
12151|       |
12152|     15|    if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (12152:9): [True: 3, False: 12]
  ------------------
12153|      3|        NavRestoreLayer(ImGuiNavLayer_Main);
12154|       |
12155|     15|    if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll)
  ------------------
  |  Branch (12155:9): [True: 12, False: 3]
  |  Branch (12155:51): [True: 3, False: 9]
  ------------------
12156|      3|    {
12157|       |        // Fallback manual-scroll when window has no navigable item
12158|      3|        if (IsKeyPressed(ImGuiKey_PageUp, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat))
  ------------------
  |  | 1320|      3|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12158:13): [True: 0, False: 3]
  ------------------
12159|      0|            SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
12160|      3|        else if (IsKeyPressed(ImGuiKey_PageDown, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat))
  ------------------
  |  | 1320|      3|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12160:18): [True: 0, False: 3]
  ------------------
12161|      0|            SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
12162|      3|        else if (home_pressed)
  ------------------
  |  Branch (12162:18): [True: 0, False: 3]
  ------------------
12163|      0|            SetScrollY(window, 0.0f);
12164|      3|        else if (end_pressed)
  ------------------
  |  Branch (12164:18): [True: 0, False: 3]
  ------------------
12165|      0|            SetScrollY(window, window->ScrollMax.y);
12166|      3|    }
12167|     12|    else
12168|     12|    {
12169|     12|        ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
12170|     12|        const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
12171|     12|        float nav_scoring_rect_offset_y = 0.0f;
12172|     12|        if (IsKeyPressed(ImGuiKey_PageUp, true))
  ------------------
  |  Branch (12172:13): [True: 0, False: 12]
  ------------------
12173|      0|        {
12174|      0|            nav_scoring_rect_offset_y = -page_offset_y;
12175|      0|            g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
12176|      0|            g.NavMoveClipDir = ImGuiDir_Up;
12177|      0|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
12178|      0|        }
12179|     12|        else if (IsKeyPressed(ImGuiKey_PageDown, true))
  ------------------
  |  Branch (12179:18): [True: 3, False: 9]
  ------------------
12180|      3|        {
12181|      3|            nav_scoring_rect_offset_y = +page_offset_y;
12182|      3|            g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
12183|      3|            g.NavMoveClipDir = ImGuiDir_Down;
12184|      3|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
12185|      3|        }
12186|      9|        else if (home_pressed)
  ------------------
  |  Branch (12186:18): [True: 0, False: 9]
  ------------------
12187|      0|        {
12188|       |            // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
12189|       |            // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
12190|       |            // Preserve current horizontal position if we have any.
12191|      0|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
12192|      0|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (12192:17): [True: 0, False: 0]
  ------------------
12193|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
12194|      0|            g.NavMoveDir = ImGuiDir_Down;
12195|      0|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
12196|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
12197|      0|        }
12198|      9|        else if (end_pressed)
  ------------------
  |  Branch (12198:18): [True: 0, False: 9]
  ------------------
12199|      0|        {
12200|      0|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
12201|      0|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (12201:17): [True: 0, False: 0]
  ------------------
12202|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
12203|      0|            g.NavMoveDir = ImGuiDir_Up;
12204|      0|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
12205|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
12206|      0|        }
12207|     12|        return nav_scoring_rect_offset_y;
12208|     12|    }
12209|      3|    return 0.0f;
12210|     15|}
imgui.cpp:_ZN5ImGuiL29NavUpdateCreateTabbingRequestEv:
11970|  90.2k|{
11971|  90.2k|    ImGuiContext& g = *GImGui;
11972|  90.2k|    ImGuiWindow* window = g.NavWindow;
11973|  90.2k|    IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11974|  90.2k|    if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (11974:9): [True: 89.7k, False: 432]
  |  Branch (11974:27): [True: 0, False: 432]
  |  Branch (11974:59): [True: 0, False: 432]
  ------------------
11975|  89.7k|        return;
11976|       |
11977|    432|    const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiKeyOwner_None, ImGuiInputFlags_Repeat) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
  ------------------
  |  | 1320|    432|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (11977:30): [True: 0, False: 432]
  |  Branch (11977:104): [True: 0, False: 0]
  |  Branch (11977:121): [True: 0, False: 0]
  ------------------
11978|    432|    if (!tab_pressed)
  ------------------
  |  Branch (11978:9): [True: 432, False: 0]
  ------------------
11979|    432|        return;
11980|       |
11981|       |    // Initiate tabbing request
11982|       |    // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
11983|       |    // Initially this was designed to use counters and modulo arithmetic, but that could not work with unsubmitted items (list clipper). Instead we use a strategy close to other move requests.
11984|       |    // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
11985|       |    //// FIXME: We use (g.ActiveId == 0) but (g.NavDisableHighlight == false) might be righter once we can tab through anything
11986|      0|    g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
  ------------------
  |  Branch (11986:23): [True: 0, False: 0]
  |  Branch (11986:44): [True: 0, False: 0]
  ------------------
11987|      0|    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
  ------------------
  |  Branch (11987:37): [True: 0, False: 0]
  ------------------
11988|      0|    ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
  ------------------
  |  Branch (11988:25): [True: 0, False: 0]
  ------------------
11989|      0|    NavMoveRequestSubmit(ImGuiDir_None, clip_dir, ImGuiNavMoveFlags_Tabbing, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
11990|      0|    g.NavTabbingCounter = -1;
11991|      0|}
imgui.cpp:_ZN5ImGuiL28NavRestoreHighlightAfterMoveEv:
11580|      2|{
11581|      2|    ImGuiContext& g = *GImGui;
11582|      2|    g.NavDisableHighlight = false;
11583|      2|    g.NavDisableMouseHover = g.NavMousePosDirty = true;
11584|      2|}
imgui.cpp:_ZN5ImGuiL11NavEndFrameEv:
12213|  90.2k|{
12214|  90.2k|    ImGuiContext& g = *GImGui;
12215|       |
12216|       |    // Show CTRL+TAB list window
12217|  90.2k|    if (g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (12217:9): [True: 0, False: 90.2k]
  ------------------
12218|      0|        NavUpdateWindowingOverlay();
12219|       |
12220|       |    // Perform wrap-around in menus
12221|       |    // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
12222|       |    // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
12223|  90.2k|    const ImGuiNavMoveFlags wanted_flags = ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY;
12224|  90.2k|    if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & wanted_flags) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
  ------------------
  |  Branch (12224:9): [True: 505, False: 89.7k]
  |  Branch (12224:24): [True: 12, False: 493]
  |  Branch (12224:58): [True: 0, False: 12]
  |  Branch (12224:93): [True: 0, False: 0]
  ------------------
12225|      0|        NavUpdateCreateWrappingRequest();
12226|  90.2k|}
imgui.cpp:_ZN5ImGuiL14UpdateSettingsEv:
13149|  90.2k|{
13150|       |    // Load settings on first frame (if not explicitly loaded manually before)
13151|  90.2k|    ImGuiContext& g = *GImGui;
13152|  90.2k|    if (!g.SettingsLoaded)
  ------------------
  |  Branch (13152:9): [True: 1, False: 90.2k]
  ------------------
13153|      1|    {
13154|      1|        IM_ASSERT(g.SettingsWindows.empty());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13155|      1|        if (g.IO.IniFilename)
  ------------------
  |  Branch (13155:13): [True: 0, False: 1]
  ------------------
13156|      0|            LoadIniSettingsFromDisk(g.IO.IniFilename);
13157|      1|        g.SettingsLoaded = true;
13158|      1|    }
13159|       |
13160|       |    // Save settings (with a delay after the last modification, so we don't spam disk too much)
13161|  90.2k|    if (g.SettingsDirtyTimer > 0.0f)
  ------------------
  |  Branch (13161:9): [True: 1.20k, False: 89.0k]
  ------------------
13162|  1.20k|    {
13163|  1.20k|        g.SettingsDirtyTimer -= g.IO.DeltaTime;
13164|  1.20k|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (13164:13): [True: 4, False: 1.19k]
  ------------------
13165|      4|        {
13166|      4|            if (g.IO.IniFilename != NULL)
  ------------------
  |  Branch (13166:17): [True: 0, False: 4]
  ------------------
13167|      0|                SaveIniSettingsToDisk(g.IO.IniFilename);
13168|      4|            else
13169|      4|                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
13170|      4|            g.SettingsDirtyTimer = 0.0f;
13171|      4|        }
13172|  1.20k|    }
13173|  90.2k|}
imgui.cpp:_ZL24InitOrLoadWindowSettingsP11ImGuiWindowP19ImGuiWindowSettings:
 5640|      3|{
 5641|       |    // Initial window state with e.g. default/arbitrary window position
 5642|       |    // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
 5643|      3|    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
 5644|      3|    window->Pos = main_viewport->Pos + ImVec2(60, 60);
 5645|      3|    window->ViewportPos = main_viewport->Pos;
 5646|      3|    window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = window->SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
 5647|       |
 5648|      3|    if (settings != NULL)
  ------------------
  |  Branch (5648:9): [True: 0, False: 3]
  ------------------
 5649|      0|    {
 5650|      0|        SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
 5651|      0|        ApplyWindowSettings(window, settings);
 5652|      0|    }
 5653|      3|    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values
 5654|       |
 5655|      3|    if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
  ------------------
  |  Branch (5655:9): [True: 0, False: 3]
  ------------------
 5656|      0|    {
 5657|      0|        window->AutoFitFramesX = window->AutoFitFramesY = 2;
 5658|      0|        window->AutoFitOnlyGrows = false;
 5659|      0|    }
 5660|      3|    else
 5661|      3|    {
 5662|      3|        if (window->Size.x <= 0.0f)
  ------------------
  |  Branch (5662:13): [True: 3, False: 0]
  ------------------
 5663|      3|            window->AutoFitFramesX = 2;
 5664|      3|        if (window->Size.y <= 0.0f)
  ------------------
  |  Branch (5664:13): [True: 3, False: 0]
  ------------------
 5665|      3|            window->AutoFitFramesY = 2;
 5666|      3|        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
  ------------------
  |  Branch (5666:36): [True: 3, False: 0]
  |  Branch (5666:68): [True: 0, False: 0]
  ------------------
 5667|      3|    }
 5668|      3|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsNewFrameEv:
13719|  90.2k|{
13720|  90.2k|    ImGuiContext& g = *GImGui;
13721|  90.2k|    IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13722|       |
13723|       |    // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
13724|  90.2k|    const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
13725|  90.2k|    if (viewports_enabled)
  ------------------
  |  Branch (13725:9): [True: 0, False: 90.2k]
  ------------------
13726|      0|    {
13727|      0|        for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (13727:25): [True: 0, False: 0]
  ------------------
13728|      0|        {
13729|      0|            ImGuiViewportP* viewport = g.Viewports[n];
13730|      0|            const bool platform_funcs_available = viewport->PlatformWindowCreated;
13731|      0|            if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
  ------------------
  |  Branch (13731:17): [True: 0, False: 0]
  |  Branch (13731:61): [True: 0, False: 0]
  ------------------
13732|      0|            {
13733|      0|                bool minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
13734|      0|                if (minimized)
  ------------------
  |  Branch (13734:21): [True: 0, False: 0]
  ------------------
13735|      0|                    viewport->Flags |= ImGuiViewportFlags_Minimized;
13736|      0|                else
13737|      0|                    viewport->Flags &= ~ImGuiViewportFlags_Minimized;
13738|      0|            }
13739|      0|        }
13740|      0|    }
13741|       |
13742|       |    // Create/update main viewport with current platform position.
13743|       |    // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
13744|  90.2k|    ImGuiViewportP* main_viewport = g.Viewports[0];
13745|  90.2k|    IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13746|  90.2k|    IM_ASSERT(main_viewport->Window == NULL);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13747|  90.2k|    ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (13747:32): [True: 0, False: 90.2k]
  ------------------
13748|  90.2k|    ImVec2 main_viewport_size = g.IO.DisplaySize;
13749|  90.2k|    if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_Minimized))
  ------------------
  |  Branch (13749:9): [True: 0, False: 90.2k]
  |  Branch (13749:30): [True: 0, False: 0]
  ------------------
13750|      0|    {
13751|      0|        main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
13752|      0|        main_viewport_size = main_viewport->Size;
13753|      0|    }
13754|  90.2k|    AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);
13755|       |
13756|  90.2k|    g.CurrentDpiScale = 0.0f;
13757|  90.2k|    g.CurrentViewport = NULL;
13758|  90.2k|    g.MouseViewport = NULL;
13759|   180k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (13759:21): [True: 90.2k, False: 90.2k]
  ------------------
13760|  90.2k|    {
13761|  90.2k|        ImGuiViewportP* viewport = g.Viewports[n];
13762|  90.2k|        viewport->Idx = n;
13763|       |
13764|       |        // Erase unused viewports
13765|  90.2k|        if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
  ------------------
  |  Branch (13765:13): [True: 0, False: 90.2k]
  |  Branch (13765:22): [True: 0, False: 0]
  ------------------
13766|      0|        {
13767|      0|            DestroyViewport(viewport);
13768|      0|            n--;
13769|      0|            continue;
13770|      0|        }
13771|       |
13772|  90.2k|        const bool platform_funcs_available = viewport->PlatformWindowCreated;
13773|  90.2k|        if (viewports_enabled)
  ------------------
  |  Branch (13773:13): [True: 0, False: 90.2k]
  ------------------
13774|      0|        {
13775|       |            // Update Position and Size (from Platform Window to ImGui) if requested.
13776|       |            // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
13777|      0|            if (!(viewport->Flags & ImGuiViewportFlags_Minimized) && platform_funcs_available)
  ------------------
  |  Branch (13777:17): [True: 0, False: 0]
  |  Branch (13777:70): [True: 0, False: 0]
  ------------------
13778|      0|            {
13779|       |                // Viewport->WorkPos and WorkSize will be updated below
13780|      0|                if (viewport->PlatformRequestMove)
  ------------------
  |  Branch (13780:21): [True: 0, False: 0]
  ------------------
13781|      0|                    viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
13782|      0|                if (viewport->PlatformRequestResize)
  ------------------
  |  Branch (13782:21): [True: 0, False: 0]
  ------------------
13783|      0|                    viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
13784|      0|            }
13785|      0|        }
13786|       |
13787|       |        // Update/copy monitor info
13788|  90.2k|        UpdateViewportPlatformMonitor(viewport);
13789|       |
13790|       |        // Lock down space taken by menu bars and status bars, reset the offset for functions like BeginMainMenuBar() to alter them again.
13791|  90.2k|        viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
13792|  90.2k|        viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
13793|  90.2k|        viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
13794|  90.2k|        viewport->UpdateWorkRect();
13795|       |
13796|       |        // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
13797|  90.2k|        viewport->Alpha = 1.0f;
13798|       |
13799|       |        // Translate Dear ImGui windows when a Host Viewport has been moved
13800|       |        // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
13801|  90.2k|        const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
13802|  90.2k|        if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
  ------------------
  |  Branch (13802:13): [True: 90.2k, False: 0]
  |  Branch (13802:76): [True: 0, False: 90.2k]
  |  Branch (13802:108): [True: 0, False: 90.2k]
  ------------------
13803|      0|            TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos);
13804|       |
13805|       |        // Update DPI scale
13806|  90.2k|        float new_dpi_scale;
13807|  90.2k|        if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
  ------------------
  |  Branch (13807:13): [True: 0, False: 90.2k]
  |  Branch (13807:56): [True: 0, False: 0]
  ------------------
13808|      0|            new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
13809|  90.2k|        else if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (13809:18): [True: 0, False: 90.2k]
  ------------------
13810|      0|            new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
13811|  90.2k|        else
13812|  90.2k|            new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (13812:29): [True: 90.2k, False: 1]
  ------------------
13813|  90.2k|        if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
  ------------------
  |  Branch (13813:13): [True: 90.2k, False: 1]
  |  Branch (13813:43): [True: 0, False: 90.2k]
  ------------------
13814|      0|        {
13815|      0|            float scale_factor = new_dpi_scale / viewport->DpiScale;
13816|      0|            if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
  ------------------
  |  Branch (13816:17): [True: 0, False: 0]
  ------------------
13817|      0|                ScaleWindowsInViewport(viewport, scale_factor);
13818|       |            //if (viewport == GetMainViewport())
13819|       |            //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);
13820|       |
13821|       |            // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
13822|       |            // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
13823|       |            // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
13824|       |            //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
13825|       |            //    g.ActiveIdClickOffset = ImFloor(g.ActiveIdClickOffset * scale_factor);
13826|      0|        }
13827|  90.2k|        viewport->DpiScale = new_dpi_scale;
13828|  90.2k|    }
13829|       |
13830|       |    // Update fallback monitor
13831|  90.2k|    if (g.PlatformIO.Monitors.Size == 0)
  ------------------
  |  Branch (13831:9): [True: 90.2k, False: 0]
  ------------------
13832|  90.2k|    {
13833|  90.2k|        ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
13834|  90.2k|        monitor->MainPos = main_viewport->Pos;
13835|  90.2k|        monitor->MainSize = main_viewport->Size;
13836|  90.2k|        monitor->WorkPos = main_viewport->WorkPos;
13837|  90.2k|        monitor->WorkSize = main_viewport->WorkSize;
13838|  90.2k|        monitor->DpiScale = main_viewport->DpiScale;
13839|  90.2k|    }
13840|       |
13841|  90.2k|    if (!viewports_enabled)
  ------------------
  |  Branch (13841:9): [True: 90.2k, False: 0]
  ------------------
13842|  90.2k|    {
13843|  90.2k|        g.MouseViewport = main_viewport;
13844|  90.2k|        return;
13845|  90.2k|    }
13846|       |
13847|       |    // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
13848|       |    // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
13849|      0|    ImGuiViewportP* viewport_hovered = NULL;
13850|      0|    if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
  ------------------
  |  Branch (13850:9): [True: 0, False: 0]
  ------------------
13851|      0|    {
13852|      0|        viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
  ------------------
  |  Branch (13852:28): [True: 0, False: 0]
  ------------------
13853|      0|        if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (13853:13): [True: 0, False: 0]
  |  Branch (13853:33): [True: 0, False: 0]
  ------------------
13854|      0|            viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
13855|      0|    }
13856|      0|    else
13857|      0|    {
13858|       |        // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
13859|       |        // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
13860|       |        // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
13861|       |        // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
13862|      0|        viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
13863|      0|    }
13864|      0|    if (viewport_hovered != NULL)
  ------------------
  |  Branch (13864:9): [True: 0, False: 0]
  ------------------
13865|      0|        g.MouseLastHoveredViewport = viewport_hovered;
13866|      0|    else if (g.MouseLastHoveredViewport == NULL)
  ------------------
  |  Branch (13866:14): [True: 0, False: 0]
  ------------------
13867|      0|        g.MouseLastHoveredViewport = g.Viewports[0];
13868|       |
13869|       |    // Update mouse reference viewport
13870|       |    // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
13871|       |    // (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
13872|      0|    if (g.MovingWindow && g.MovingWindow->Viewport)
  ------------------
  |  Branch (13872:9): [True: 0, False: 0]
  |  Branch (13872:27): [True: 0, False: 0]
  ------------------
13873|      0|        g.MouseViewport = g.MovingWindow->Viewport;
13874|      0|    else
13875|      0|        g.MouseViewport = g.MouseLastHoveredViewport;
13876|       |
13877|       |    // When dragging something, always refer to the last hovered viewport.
13878|       |    // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
13879|       |    // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
13880|       |    // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
13881|       |    // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
13882|      0|    const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
13883|      0|    if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
  ------------------
  |  Branch (13883:9): [True: 0, False: 0]
  |  Branch (13883:59): [True: 0, False: 0]
  ------------------
13884|      0|        viewport_hovered = g.MouseLastHoveredViewport;
13885|      0|    if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
  ------------------
  |  Branch (13885:9): [True: 0, False: 0]
  |  Branch (13885:59): [True: 0, False: 0]
  |  Branch (13885:78): [True: 0, False: 0]
  ------------------
13886|      0|        if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (13886:13): [True: 0, False: 0]
  |  Branch (13886:41): [True: 0, False: 0]
  |  Branch (13886:80): [True: 0, False: 0]
  ------------------
13887|      0|            g.MouseViewport = viewport_hovered;
13888|       |
13889|      0|    IM_ASSERT(g.MouseViewport != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13890|      0|}
imgui.cpp:_ZN5ImGuiL29UpdateViewportPlatformMonitorEP14ImGuiViewportP:
14431|  90.2k|{
14432|  90.2k|    viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
14433|  90.2k|}
imgui.cpp:_ZN5ImGuiL26FindPlatformMonitorForRectERK6ImRect:
14399|  90.2k|{
14400|  90.2k|    ImGuiContext& g = *GImGui;
14401|       |
14402|  90.2k|    const int monitor_count = g.PlatformIO.Monitors.Size;
14403|  90.2k|    if (monitor_count <= 1)
  ------------------
  |  Branch (14403:9): [True: 90.2k, False: 0]
  ------------------
14404|  90.2k|        return monitor_count - 1;
14405|       |
14406|       |    // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
14407|       |    // This is necessary for tooltips which always resize down to zero at first.
14408|      0|    const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
14409|      0|    int best_monitor_n = -1;
14410|      0|    float best_monitor_surface = 0.001f;
14411|       |
14412|      0|    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
  ------------------
  |  Branch (14412:29): [True: 0, False: 0]
  |  Branch (14412:71): [True: 0, False: 0]
  ------------------
14413|      0|    {
14414|      0|        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
14415|      0|        const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
14416|      0|        if (monitor_rect.Contains(rect))
  ------------------
  |  Branch (14416:13): [True: 0, False: 0]
  ------------------
14417|      0|            return monitor_n;
14418|      0|        ImRect overlapping_rect = rect;
14419|      0|        overlapping_rect.ClipWithFull(monitor_rect);
14420|      0|        float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
14421|      0|        if (overlapping_surface < best_monitor_surface)
  ------------------
  |  Branch (14421:13): [True: 0, False: 0]
  ------------------
14422|      0|            continue;
14423|      0|        best_monitor_surface = overlapping_surface;
14424|      0|        best_monitor_n = monitor_n;
14425|      0|    }
14426|      0|    return best_monitor_n;
14427|      0|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsEndFrameEv:
13894|  90.2k|{
13895|  90.2k|    ImGuiContext& g = *GImGui;
13896|  90.2k|    g.PlatformIO.Viewports.resize(0);
13897|   180k|    for (int i = 0; i < g.Viewports.Size; i++)
  ------------------
  |  Branch (13897:21): [True: 90.2k, False: 90.2k]
  ------------------
13898|  90.2k|    {
13899|  90.2k|        ImGuiViewportP* viewport = g.Viewports[i];
13900|  90.2k|        viewport->LastPos = viewport->Pos;
13901|  90.2k|        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
  ------------------
  |  Branch (13901:13): [True: 0, False: 90.2k]
  |  Branch (13901:57): [True: 0, False: 90.2k]
  |  Branch (13901:85): [True: 0, False: 90.2k]
  ------------------
13902|      0|            if (i > 0) // Always include main viewport in the list
  ------------------
  |  Branch (13902:17): [True: 0, False: 0]
  ------------------
13903|      0|                continue;
13904|  90.2k|        if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
  ------------------
  |  Branch (13904:13): [True: 0, False: 90.2k]
  |  Branch (13904:33): [True: 0, False: 0]
  ------------------
13905|      0|            continue;
13906|  90.2k|        if (i > 0)
  ------------------
  |  Branch (13906:13): [True: 0, False: 90.2k]
  ------------------
13907|  90.2k|            IM_ASSERT(viewport->Window != NULL);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13908|  90.2k|        g.PlatformIO.Viewports.push_back(viewport);
13909|  90.2k|    }
13910|  90.2k|    g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
13911|  90.2k|}
imgui.cpp:_ZN5ImGuiL17AddUpdateViewportEP11ImGuiWindowjRK6ImVec2S4_i:
13915|  90.2k|{
13916|  90.2k|    ImGuiContext& g = *GImGui;
13917|  90.2k|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13918|       |
13919|  90.2k|    flags |= ImGuiViewportFlags_IsPlatformWindow;
13920|  90.2k|    if (window != NULL)
  ------------------
  |  Branch (13920:9): [True: 0, False: 90.2k]
  ------------------
13921|      0|    {
13922|      0|        if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
  ------------------
  |  Branch (13922:13): [True: 0, False: 0]
  |  Branch (13922:31): [True: 0, False: 0]
  ------------------
13923|      0|            flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
13924|      0|        if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (13924:13): [True: 0, False: 0]
  |  Branch (13924:65): [True: 0, False: 0]
  ------------------
13925|      0|            flags |= ImGuiViewportFlags_NoInputs;
13926|      0|        if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
  ------------------
  |  Branch (13926:13): [True: 0, False: 0]
  ------------------
13927|      0|            flags |= ImGuiViewportFlags_NoFocusOnAppearing;
13928|      0|    }
13929|       |
13930|  90.2k|    ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
13931|  90.2k|    if (viewport)
  ------------------
  |  Branch (13931:9): [True: 90.2k, False: 0]
  ------------------
13932|  90.2k|    {
13933|       |        // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
13934|  90.2k|        if (!viewport->PlatformRequestMove || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (13934:13): [True: 90.2k, False: 0]
  |  Branch (13934:47): [True: 0, False: 0]
  ------------------
13935|  90.2k|            viewport->Pos = pos;
13936|  90.2k|        if (!viewport->PlatformRequestResize || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (13936:13): [True: 90.2k, False: 0]
  |  Branch (13936:49): [True: 0, False: 0]
  ------------------
13937|  90.2k|            viewport->Size = size;
13938|  90.2k|        viewport->Flags = flags | (viewport->Flags & ImGuiViewportFlags_Minimized); // Preserve existing flags
13939|  90.2k|    }
13940|      0|    else
13941|      0|    {
13942|       |        // New viewport
13943|      0|        viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 1823|      0|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
13944|      0|        viewport->ID = id;
13945|      0|        viewport->Idx = g.Viewports.Size;
13946|      0|        viewport->Pos = viewport->LastPos = pos;
13947|      0|        viewport->Size = size;
13948|      0|        viewport->Flags = flags;
13949|      0|        UpdateViewportPlatformMonitor(viewport);
13950|      0|        g.Viewports.push_back(viewport);
13951|      0|        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window->Name : "<NULL>");
  ------------------
  |  |  236|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (225:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (236:50): [True: 0, False: 0]
  |  |  |  Branch (236:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
13952|       |
13953|       |        // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
13954|       |        // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
13955|      0|        g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
13956|      0|        g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
13957|      0|        g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
13958|      0|        g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);
13959|       |
13960|       |        // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
13961|       |        // This is so we can select an appropriate font size on the first frame of our window lifetime
13962|      0|        if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (13962:13): [True: 0, False: 0]
  ------------------
13963|      0|            viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
13964|      0|    }
13965|       |
13966|  90.2k|    viewport->Window = window;
13967|  90.2k|    viewport->LastFrameActive = g.FrameCount;
13968|  90.2k|    viewport->UpdateWorkRect();
13969|  90.2k|    IM_ASSERT(window == NULL || viewport->ID == window->ID);
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13970|       |
13971|  90.2k|    if (window != NULL)
  ------------------
  |  Branch (13971:9): [True: 0, False: 90.2k]
  ------------------
13972|      0|        window->ViewportOwned = true;
13973|       |
13974|  90.2k|    return viewport;
13975|  90.2k|}
imgui.cpp:_ZN5ImGuiL20WindowSelectViewportEP11ImGuiWindow:
14003|   180k|{
14004|   180k|    ImGuiContext& g = *GImGui;
14005|   180k|    ImGuiWindowFlags flags = window->Flags;
14006|   180k|    window->ViewportAllowPlatformMonitorExtend = -1;
14007|       |
14008|       |    // Restore main viewport if multi-viewport is not supported by the backend
14009|   180k|    ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
14010|   180k|    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
  ------------------
  |  Branch (14010:9): [True: 180k, False: 0]
  ------------------
14011|   180k|    {
14012|   180k|        SetWindowViewport(window, main_viewport);
14013|   180k|        return;
14014|   180k|    }
14015|      0|    window->ViewportOwned = false;
14016|       |
14017|       |    // Appearing popups reset their viewport so they can inherit again
14018|      0|    if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
  ------------------
  |  Branch (14018:9): [True: 0, False: 0]
  |  Branch (14018:74): [True: 0, False: 0]
  ------------------
14019|      0|    {
14020|      0|        window->Viewport = NULL;
14021|      0|        window->ViewportId = 0;
14022|      0|    }
14023|       |
14024|      0|    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
  ------------------
  |  Branch (14024:9): [True: 0, False: 0]
  ------------------
14025|      0|    {
14026|       |        // By default inherit from parent window
14027|      0|        if (window->Viewport == NULL && window->ParentWindow && (!window->ParentWindow->IsFallbackWindow || window->ParentWindow->WasActive))
  ------------------
  |  Branch (14027:13): [True: 0, False: 0]
  |  Branch (14027:41): [True: 0, False: 0]
  |  Branch (14027:66): [True: 0, False: 0]
  |  Branch (14027:109): [True: 0, False: 0]
  ------------------
14028|      0|            window->Viewport = window->ParentWindow->Viewport;
14029|       |
14030|       |        // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
14031|      0|        if (window->Viewport == NULL && window->ViewportId != 0)
  ------------------
  |  Branch (14031:13): [True: 0, False: 0]
  |  Branch (14031:41): [True: 0, False: 0]
  ------------------
14032|      0|        {
14033|      0|            window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
14034|      0|            if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
  ------------------
  |  Branch (14034:17): [True: 0, False: 0]
  |  Branch (14034:45): [True: 0, False: 0]
  |  Branch (14034:81): [True: 0, False: 0]
  ------------------
14035|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
14036|      0|        }
14037|      0|    }
14038|       |
14039|      0|    bool lock_viewport = false;
14040|      0|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
  ------------------
  |  Branch (14040:9): [True: 0, False: 0]
  ------------------
14041|      0|    {
14042|       |        // Code explicitly request a viewport
14043|      0|        window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
14044|      0|        window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
14045|      0|        lock_viewport = true;
14046|      0|    }
14047|      0|    else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (14047:14): [True: 0, False: 0]
  |  Branch (14047:56): [True: 0, False: 0]
  ------------------
14048|      0|    {
14049|       |        // Always inherit viewport from parent window
14050|      0|        if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (14050:13): [True: 0, False: 0]
  |  Branch (14050:33): [True: 0, False: 0]
  ------------------
14051|      0|            IM_ASSERT(window->DockNode->HostWindow->Viewport == window->ParentWindow->Viewport);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14052|      0|        window->Viewport = window->ParentWindow->Viewport;
14053|      0|    }
14054|      0|    else if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (14054:14): [True: 0, False: 0]
  |  Branch (14054:34): [True: 0, False: 0]
  ------------------
14055|      0|    {
14056|       |        // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
14057|      0|        window->Viewport = window->DockNode->HostWindow->Viewport;
14058|      0|    }
14059|      0|    else if (flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (14059:14): [True: 0, False: 0]
  ------------------
14060|      0|    {
14061|      0|        window->Viewport = g.MouseViewport;
14062|      0|    }
14063|      0|    else if (GetWindowAlwaysWantOwnViewport(window))
  ------------------
  |  Branch (14063:14): [True: 0, False: 0]
  ------------------
14064|      0|    {
14065|      0|        window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14066|      0|    }
14067|      0|    else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
  ------------------
  |  Branch (14067:14): [True: 0, False: 0]
  |  Branch (14067:32): [True: 0, False: 0]
  |  Branch (14067:80): [True: 0, False: 0]
  ------------------
14068|      0|    {
14069|      0|        if (window->Viewport != NULL && window->Viewport->Window == window)
  ------------------
  |  Branch (14069:13): [True: 0, False: 0]
  |  Branch (14069:41): [True: 0, False: 0]
  ------------------
14070|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14071|      0|    }
14072|      0|    else
14073|      0|    {
14074|       |        // Merge into host viewport?
14075|       |        // We cannot test window->ViewportOwned as it set lower in the function.
14076|       |        // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
14077|      0|        bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
  ------------------
  |  Branch (14077:49): [True: 0, False: 0]
  |  Branch (14077:69): [True: 0, False: 0]
  |  Branch (14077:108): [True: 0, False: 0]
  |  Branch (14077:127): [True: 0, False: 0]
  ------------------
14078|      0|        if (try_to_merge_into_host_viewport)
  ------------------
  |  Branch (14078:13): [True: 0, False: 0]
  ------------------
14079|      0|            UpdateTryMergeWindowIntoHostViewports(window);
14080|      0|    }
14081|       |
14082|       |    // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
14083|      0|    if (window->Viewport == NULL)
  ------------------
  |  Branch (14083:9): [True: 0, False: 0]
  ------------------
14084|      0|        if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
  ------------------
  |  Branch (14084:13): [True: 0, False: 0]
  ------------------
14085|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
14086|       |
14087|       |    // Mark window as allowed to protrude outside of its viewport and into the current monitor
14088|      0|    if (!lock_viewport)
  ------------------
  |  Branch (14088:9): [True: 0, False: 0]
  ------------------
14089|      0|    {
14090|      0|        if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (14090:13): [True: 0, False: 0]
  ------------------
14091|      0|        {
14092|       |            // We need to take account of the possibility that mouse may become invalid.
14093|       |            // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
14094|      0|            ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
  ------------------
  |  Branch (14094:32): [True: 0, False: 0]
  ------------------
14095|      0|            bool use_mouse_ref = (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow);
  ------------------
  |  Branch (14095:35): [True: 0, False: 0]
  |  Branch (14095:60): [True: 0, False: 0]
  |  Branch (14095:87): [True: 0, False: 0]
  ------------------
14096|      0|            bool mouse_valid = IsMousePosValid(&mouse_ref);
14097|      0|            if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
  ------------------
  |  Branch (14097:18): [True: 0, False: 0]
  |  Branch (14097:39): [True: 0, False: 0]
  |  Branch (14097:110): [True: 0, False: 0]
  |  Branch (14097:128): [True: 0, False: 0]
  ------------------
14098|      0|                window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
  ------------------
  |  Branch (14098:89): [True: 0, False: 0]
  |  Branch (14098:106): [True: 0, False: 0]
  ------------------
14099|      0|            else
14100|      0|                window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
14101|      0|        }
14102|      0|        else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow) && window->DockNode == NULL)
  ------------------
  |  Branch (14102:18): [True: 0, False: 0]
  |  Branch (14102:38): [True: 0, False: 0]
  |  Branch (14102:76): [True: 0, False: 0]
  |  Branch (14102:104): [True: 0, False: 0]
  |  Branch (14102:147): [True: 0, False: 0]
  ------------------
14103|      0|        {
14104|       |            // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
14105|      0|            const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
  ------------------
  |  Branch (14105:43): [True: 0, False: 0]
  |  Branch (14105:67): [True: 0, False: 0]
  ------------------
14106|      0|            if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
  ------------------
  |  Branch (14106:17): [True: 0, False: 0]
  |  Branch (14106:68): [True: 0, False: 0]
  |  Branch (14106:120): [True: 0, False: 0]
  ------------------
14107|      0|            {
14108|       |                // Steal/transfer ownership
14109|      0|                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
  ------------------
  |  |  236|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  225|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (236:50): [True: 0, False: 0]
  |  |  |  Branch (236:141): [Folded - Ignored]
  |  |  ------------------
  ------------------
14110|      0|                window->Viewport->Window = window;
14111|      0|                window->Viewport->ID = window->ID;
14112|      0|                window->Viewport->LastNameHash = 0;
14113|      0|            }
14114|      0|            else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
  ------------------
  |  Branch (14114:22): [True: 0, False: 0]
  ------------------
14115|      0|            {
14116|       |                // New viewport
14117|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
14118|      0|            }
14119|      0|        }
14120|      0|        else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
  ------------------
  |  Branch (14120:18): [True: 0, False: 0]
  |  Branch (14120:68): [True: 0, False: 0]
  ------------------
14121|      0|        {
14122|       |            // Regular (non-child, non-popup) windows by default are also allowed to protrude
14123|       |            // Child windows are kept contained within their parent.
14124|      0|            window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
14125|      0|        }
14126|      0|    }
14127|       |
14128|       |    // Update flags
14129|      0|    window->ViewportOwned = (window == window->Viewport->Window);
14130|      0|    window->ViewportId = window->Viewport->ID;
14131|       |
14132|       |    // If the OS window has a title bar, hide our imgui title bar
14133|       |    //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
14134|       |    //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
14135|      0|}
imgui.cpp:_ZN5ImGuiL25UpdateDebugToolItemPickerEv:
19987|  90.2k|{
19988|  90.2k|    ImGuiContext& g = *GImGui;
19989|  90.2k|    g.DebugItemPickerBreakId = 0;
19990|  90.2k|    if (!g.DebugItemPickerActive)
  ------------------
  |  Branch (19990:9): [True: 90.2k, False: 0]
  ------------------
19991|  90.2k|        return;
19992|       |
19993|      0|    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
19994|      0|    SetMouseCursor(ImGuiMouseCursor_Hand);
19995|      0|    if (IsKeyPressed(ImGuiKey_Escape))
  ------------------
  |  Branch (19995:9): [True: 0, False: 0]
  ------------------
19996|      0|        g.DebugItemPickerActive = false;
19997|      0|    const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
19998|      0|    if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
  ------------------
  |  Branch (19998:9): [True: 0, False: 0]
  |  Branch (19998:28): [True: 0, False: 0]
  |  Branch (19998:76): [True: 0, False: 0]
  ------------------
19999|      0|    {
20000|      0|        g.DebugItemPickerBreakId = hovered_id;
20001|      0|        g.DebugItemPickerActive = false;
20002|      0|    }
20003|      0|    for (int mouse_button = 0; mouse_button < 3; mouse_button++)
  ------------------
  |  Branch (20003:32): [True: 0, False: 0]
  ------------------
20004|      0|        if (change_mapping && IsMouseClicked(mouse_button))
  ------------------
  |  Branch (20004:13): [True: 0, False: 0]
  |  Branch (20004:31): [True: 0, False: 0]
  ------------------
20005|      0|            g.DebugItemPickerMouseButton = (ImU8)mouse_button;
20006|      0|    SetNextWindowBgAlpha(0.70f);
20007|      0|    BeginTooltip();
20008|      0|    Text("HoveredId: 0x%08X", hovered_id);
20009|      0|    Text("Press ESC to abort picking.");
20010|      0|    const char* mouse_button_names[] = { "Left", "Right", "Middle" };
20011|      0|    if (change_mapping)
  ------------------
  |  Branch (20011:9): [True: 0, False: 0]
  ------------------
20012|      0|        Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
20013|      0|    else
20014|      0|        TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
  ------------------
  |  Branch (20014:39): [True: 0, False: 0]
  ------------------
20015|      0|    EndTooltip();
20016|      0|}
imgui.cpp:_ZN5ImGuiL27UpdateDebugToolStackQueriesEv:
20020|  90.2k|{
20021|  90.2k|    ImGuiContext& g = *GImGui;
20022|  90.2k|    ImGuiStackTool* tool = &g.DebugStackTool;
20023|       |
20024|       |    // Clear hook when stack tool is not visible
20025|  90.2k|    g.DebugHookIdInfo = 0;
20026|  90.2k|    if (g.FrameCount != tool->LastActiveFrame + 1)
  ------------------
  |  Branch (20026:9): [True: 90.2k, False: 6]
  ------------------
20027|  90.2k|        return;
20028|       |
20029|       |    // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
20030|       |    // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
20031|      6|    const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
  ------------------
  |  Branch (20031:30): [True: 0, False: 6]
  ------------------
20032|      6|    if (tool->QueryId != query_id)
  ------------------
  |  Branch (20032:9): [True: 0, False: 6]
  ------------------
20033|      0|    {
20034|      0|        tool->QueryId = query_id;
20035|      0|        tool->StackLevel = -1;
20036|      0|        tool->Results.resize(0);
20037|      0|    }
20038|      6|    if (query_id == 0)
  ------------------
  |  Branch (20038:9): [True: 6, False: 0]
  ------------------
20039|      6|        return;
20040|       |
20041|       |    // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
20042|      0|    int stack_level = tool->StackLevel;
20043|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (20043:9): [True: 0, False: 0]
  |  Branch (20043:29): [True: 0, False: 0]
  ------------------
20044|      0|        if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
  ------------------
  |  Branch (20044:13): [True: 0, False: 0]
  |  Branch (20044:56): [True: 0, False: 0]
  ------------------
20045|      0|            tool->StackLevel++;
20046|       |
20047|       |    // Update hook
20048|      0|    stack_level = tool->StackLevel;
20049|      0|    if (stack_level == -1)
  ------------------
  |  Branch (20049:9): [True: 0, False: 0]
  ------------------
20050|      0|        g.DebugHookIdInfo = query_id;
20051|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (20051:9): [True: 0, False: 0]
  |  Branch (20051:29): [True: 0, False: 0]
  ------------------
20052|      0|    {
20053|      0|        g.DebugHookIdInfo = tool->Results[stack_level].ID;
20054|      0|        tool->Results[stack_level].QueryFrameCount++;
20055|      0|    }
20056|      0|}

_ZN6ImVec2C2Ev:
  262|  1.01M|    constexpr ImVec2()                      : x(0.0f), y(0.0f) { }
_ZN6ImVec4C2Ev:
  275|   452k|    constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
_ZN6ImVec2C2Eff:
  263|  20.3M|    constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }
_ZN6ImVec4C2Effff:
  276|   943k|    constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }
_ZN12ImGuiStorage16ImGuiStoragePairC2EjPv:
 2357|      3|        ImGuiStoragePair(ImGuiID _key, void* _val_p)    { key = _key; val_p = _val_p; }
_Znwm12ImNewWrapperPv:
 1818|     10|inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
_ZN15ImGuiPlatformIOC2Ev:
 3189|      1|    ImGuiPlatformIO()               { memset(this, 0, sizeof(*this)); }     // Zero clear
_ZN8ImVectorI20ImGuiPlatformMonitorEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP13ImGuiViewportEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiInputEventEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiWindowStackDataEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiColorModEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiStyleModEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP6ImFontEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIiEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiGroupDataEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiPopupDataEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformMonitorC2Ev:
 3199|      1|    ImGuiPlatformMonitor()          { MainPos = MainSize = WorkPos = WorkSize = ImVec2(0, 0); DpiScale = 1.0f; }
_ZN12ImGuiPayloadC2Ev:
 2241|      1|    ImGuiPayload()  { Clear(); }
_ZN8ImVectorIhEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiListClipperDataEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImGuiTableTempDataEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImGuiTableEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIfEC2Ev:
 1851|      9|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImDrawChannelEC2Ev:
 1851|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImGuiTabBarEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiPtrOrIndexEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiShrinkWidthItemEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIcEC2Ev:
 1851|      9|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformImeDataC2Ev:
 3209|      2|    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
_ZN8ImVectorI16ImGuiDockRequestEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI21ImGuiDockNodeSettingsEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN15ImGuiTextBufferC2Ev:
 2326|      3|    ImGuiTextBuffer()   { }
_ZN8ImVectorI20ImGuiSettingsHandlerEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16ImGuiContextHookEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiStackLevelInfoEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN13ImGuiViewportC2Ev:
 3073|      1|    ImGuiViewport()     { memset(this, 0, sizeof(*this)); }
_ZN10ImDrawDataC2Ev:
 2757|      1|    ImDrawData()    { Clear(); }
_ZN8ImVectorIP10ImDrawListEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE5clearEv:
 1856|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorItE5clearEv:
 1856|      3|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 2]
  ------------------
_ZN16ImGuiWindowClassC2Ev:
 2223|      7|    ImGuiWindowClass() { memset(this, 0, sizeof(*this)); ParentViewportId = (ImGuiID)-1; DockingAllowUnclassed = true; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEEC2Ev:
 1851|      7|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN10ImDrawListC2EP20ImDrawListSharedData:
 2638|      3|    ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }
_ZN8ImVectorI9ImDrawCmdEC2Ev:
 1851|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImDrawVertEC2Ev:
 1851|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI6ImVec4EC2Ev:
 1851|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIPvEC2Ev:
 1851|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI6ImVec2EC2Ev:
 1851|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN18ImDrawListSplitterC2Ev:
 2567|      3|    inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }
_ZNK6ImFont8IsLoadedEv:
 2997|   180k|    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
_ZN10ImDrawData5ClearEv:
 2758|  90.2k|    void Clear()    { memset(this, 0, sizeof(*this)); }     // The ImDrawList are owned by ImGuiContext!
_ZN8ImVectorIP10ImDrawListE9push_backERKS1_:
 1886|  90.5k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 90.5k]
  ------------------
_ZN8ImVectorIP10ImDrawListE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI9ImDrawCmdE8pop_backEv:
 1887|   180k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_:
 1886|   361k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 3, False: 361k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE7reserveEi:
 1882|      3|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      3|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 3]
  |  Branch (1882:167): [True: 0, False: 3]
  ------------------
_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi:
 1878|      3|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 3]
  |  Branch (1878:131): [True: 3, False: 0]
  ------------------
_ZNK8ImVectorIP11ImGuiWindowE14_grow_capacityEi:
 1878|      3|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 3]
  |  Branch (1878:131): [True: 3, False: 0]
  ------------------
_ZNK8ImVectorIP11ImGuiWindowE8containsERKS1_:
 1893|      3|    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
  ------------------
  |  Branch (1893:126): [True: 1, False: 2]
  |  Branch (1893:147): [True: 0, False: 1]
  ------------------
_ZN6ImVec2ixEm:
  265|  1.63M|    float& operator[] (size_t idx)          { IM_ASSERT(idx == 0 || idx == 1); return (&x)[idx]; }  // We very rarely use this [] operator, the assert overhead is fine.
  ------------------
  |  |   23|  1.63M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN10ImDrawList10PathLineToERK6ImVec2:
 2686|  1.26M|    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
_ZN8ImVectorI6ImVec2E9push_backERKS0_:
 1886|  1.27M|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 2, False: 1.27M]
  ------------------
_ZN8ImVectorI6ImVec2E7reserveEi:
 1882|    344|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      5|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 339, False: 5]
  |  Branch (1882:167): [True: 2, False: 3]
  ------------------
_ZNK8ImVectorI6ImVec2E14_grow_capacityEi:
 1878|      5|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 2, False: 3]
  |  Branch (1878:131): [True: 5, False: 0]
  ------------------
_ZN10ImDrawList14PathFillConvexEj:
 2688|   181k|    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
_ZN10ImDrawList10PathStrokeEjif:
 2689|   181k|    inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE6resizeEi:
 1879|  90.2k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 90.2k]
  ------------------
_ZN8ImVectorI19ImGuiKeyRoutingDataE4swapERS1_:
 1876|  90.2k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZNK11ImFontAtlas7IsBuiltEv:
 2884|  90.2k|    bool                        IsBuilt() const             { return Fonts.Size > 0 && TexReady; } // Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
  ------------------
  |  Branch (2884:70): [True: 90.2k, False: 0]
  |  Branch (2884:88): [True: 90.2k, False: 0]
  ------------------
_ZN12ImGuiPayload5ClearEv:
 2242|     15|    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
_ZN8ImVectorIP13ImGuiViewportE6resizeEi:
 1879|  90.2k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 90.2k]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP13ImGuiViewportE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiEixEi:
 1865|    446|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIcE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorItEC2Ev:
 1851|      7|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjEC2Ev:
 1851|      5|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjED2Ev:
 1854|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1854:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIjE6resizeEi:
 1879|   271k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 2, False: 271k]
  ------------------
_ZN8ImVectorIjE7reserveEi:
 1882|      6|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      6|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 6]
  |  Branch (1882:167): [True: 0, False: 6]
  ------------------
_ZNK8ImVectorIjE14_grow_capacityEi:
 1878|      6|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 6]
  |  Branch (1878:131): [True: 4, False: 2]
  ------------------
_ZN8ImVectorIjE5clearEv:
 1856|      3|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      3|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 3, False: 0]
  ------------------
_ZN8ImVectorIP10ImDrawListE6resizeEi:
 1879|   270k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 270k]
  ------------------
_ZN8ImVectorItEixEi:
 1865|    230|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    230|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowEC2Ev:
 1851|      6|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP14ImGuiViewportPEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP6ImFontEixEi:
 1865|  90.2k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI15ImGuiInputEventE9push_backERKS0_:
 1886|  72.7k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 16, False: 72.7k]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE7reserveEi:
 1882|     16|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|     16|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|     14|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 16]
  |  Branch (1882:167): [True: 14, False: 2]
  ------------------
_ZNK8ImVectorI15ImGuiInputEventE14_grow_capacityEi:
 1878|     16|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 14, False: 2]
  |  Branch (1878:131): [True: 16, False: 0]
  ------------------
_ZN8ImVectorItE6resizeEi:
 1879|  1.09M|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 20, False: 1.09M]
  ------------------
_ZNK8ImVectorItE14_grow_capacityEi:
 1878|     29|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 24, False: 5]
  |  Branch (1878:131): [True: 16, False: 13]
  ------------------
_ZN8ImVectorI15ImGuiInputEventEixEi:
 1865|   116k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   116k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE3endEv:
 1871|   180k|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE3endEv:
 1870|      3|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE6insertEPKS1_RS3_:
 1892|      3|    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (1892:144): [True: 1, False: 2]
  |  Branch (1892:201): [True: 2, False: 1]
  ------------------
_ZNK8ImVectorIN12ImGuiStorage16ImGuiStoragePairEE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorIcE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiE9push_backERKi:
 1886|  90.7k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 90.7k]
  ------------------
_ZN8ImVectorIiE7reserveEi:
 1882|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 2]
  |  Branch (1882:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorIiE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE9push_backERKS0_:
 1886|  90.2k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 90.2k]
  ------------------
_ZN8ImVectorI13ImGuiColorModE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiColorModE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE4backEv:
 1874|  90.2k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiColorModE8pop_backEv:
 1887|  90.2k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE9push_backERKS0_:
 1886|  90.2k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 90.2k]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiStyleModE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE4backEv:
 1874|  90.2k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE8pop_backEv:
 1887|  90.2k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  90.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP14ImGuiViewportPEixEi:
 1865|  1.17M|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  1.17M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiED2Ev:
 1854|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1854:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE9push_backERKS1_:
 1886|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP14ImGuiViewportPE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIcE6resizeEiRKc:
 1880|  3.07k|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1880:67): [True: 1, False: 0]
  |  Branch (1880:127): [True: 1, False: 0]
  |  Branch (1880:163): [True: 3.07k, False: 1]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE9push_backERKS1_:
 1886|  90.2k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 90.2k]
  ------------------
_ZN8ImVectorI6ImVec2E5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI13ImDrawChannelE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI15ImGuiOldColumnsEC2Ev:
 1851|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjE9push_backERKj:
 1886|   181k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 4, False: 181k]
  ------------------
_ZN8ImVectorIjE4backEv:
 1874|   272k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   272k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIfE5clearEv:
 1856|      4|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 0, False: 4]
  ------------------
_ZN8ImVectorItE7reserveEi:
 1882|     29|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|     29|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|     24|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 29]
  |  Branch (1882:167): [True: 24, False: 5]
  ------------------
_ZN8ImVectorI10ImDrawVertE7reserveEi:
 1882|     16|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|     16|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|     13|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 16]
  |  Branch (1882:167): [True: 13, False: 3]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE6resizeEi:
 1879|   182k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 182k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowEixEi:
 1865|  1.08M|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  1.08M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIfEixEi:
 1865|    512|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    512|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE6resizeEi:
 1879|  90.2k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 90.2k]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiWindowStackDataE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI14ImGuiPopupDataE6resizeEi:
 1879|  90.2k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 90.2k]
  ------------------
_ZN8ImVectorIiE6resizeEi:
 1879|  90.2k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 90.2k]
  ------------------
_ZN8ImVectorI14ImGuiGroupDataE6resizeEi:
 1879|  90.2k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 90.2k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE9push_backERKS1_:
 1886|   271k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 3, False: 271k]
  ------------------
_ZN8ImVectorI9ImDrawCmdEixEi:
 1865|   451k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   451k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIP10ImDrawListE5emptyEv:
 1860|  90.2k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI6ImVec4E4backEv:
 1874|   542k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   542k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE4backEv:
 1874|    323|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE6resizeEi:
 1879|   271k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 271k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE7reserveEi:
 1882|  90.2k|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 90.2k, False: 4]
  |  Branch (1882:167): [True: 0, False: 4]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4swapERS2_:
 1876|  90.2k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZNK8ImVectorI20ImGuiWindowStackDataE5emptyEv:
 1860|   180k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI20ImGuiWindowStackDataE4backEv:
 1874|   542k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   542k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE9push_backERKS0_:
 1886|   180k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 180k]
  ------------------
_ZN8ImVectorIfE6resizeEi:
 1879|   361k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 361k]
  ------------------
_ZN8ImVectorIfE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIfE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE8pop_backEv:
 1887|   180k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4backEv:
 1874|    590|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|    590|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP6ImFontE9push_backERKS1_:
 1886|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP6ImFontE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE4backEv:
 1874|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE4backEv:
 1874|    646|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|    646|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE8pop_backEv:
 1887|    323|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|    323|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIjE8pop_backEv:
 1887|   181k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   181k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorItE9push_backERKt:
 1886|  7.52k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 8, False: 7.51k]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE5eraseEPKS0_S3_:
 1890|  7.02k|    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
  ------------------
  |  |   23|  7.02k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIhE5clearEv:
 1856|     14|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 0, False: 14]
  ------------------
_ZN8ImVectorIhE6resizeEi:
 1879|     40|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 40]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE9push_backERKS0_:
 1886|      3|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 2]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiSettingsHandlerE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerEixEi:
 1865|      1|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI16ImGuiDockRequestE6resizeEi:
 1879|  90.2k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 90.2k]
  ------------------
_ZN9ImDrawCmdC2Ev:
 2521|   361k|    ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed
_ZN18ImDrawListSplitter5ClearEv:
 2569|   180k|    inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame
_ZN21ImFontAtlasCustomRectC2Ev:
 2831|      2|    ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
_ZNK21ImFontAtlasCustomRect8IsPackedEv:
 2832|      2|    bool IsPacked() const           { return X != 0xFFFF; }
_ZN11ImFontAtlas20GetCustomRectByIndexEi:
 2917|      2|    ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectEixEi:
 1865|     16|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildDstDataEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildSrcDataE6resizeEi:
 1879|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE6resizeEi:
 1879|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildDstDataE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE13size_in_bytesEv:
 1862|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZNK8ImVectorI18ImFontBuildDstDataE13size_in_bytesEv:
 1862|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI18ImFontBuildSrcDataEixEi:
 1865|      7|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataEixEi:
 1865|      3|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIjE5emptyEv:
 1860|      1|    inline bool         empty() const                       { return Size == 0; }
_ZNK8ImVectorIjE5beginEv:
 1869|      1|    inline const T*     begin() const                       { return Data; }
_ZNK8ImVectorIjE3endEv:
 1871|      1|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorI18ImFontBuildDstDataE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16stbtt_packedcharE6resizeEi:
 1879|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE13size_in_bytesEv:
 1862|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI16stbtt_packedcharEixEi:
 1865|      1|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI10stbrp_rectE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE14clear_destructEv:
 1858|      2|    inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.
  ------------------
  |  Branch (1858:79): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharED2Ev:
 1854|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1854:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataED2Ev:
 1854|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1854:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataED2Ev:
 1854|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1854:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI9ImDrawCmdE6resizeEi:
 1879|   180k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 180k]
  ------------------
_ZN8ImVectorI10ImDrawVertE6resizeEi:
 1879|   996k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 16, False: 996k]
  ------------------
_ZNK8ImVectorI10ImDrawVertE14_grow_capacityEi:
 1878|     16|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 13, False: 3]
  |  Branch (1878:131): [True: 8, False: 8]
  ------------------
_ZN8ImVectorI6ImVec4E6resizeEi:
 1879|   180k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 180k]
  ------------------
_ZN8ImVectorI6ImVec4E7reserveEi:
 1882|      3|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      3|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 3]
  |  Branch (1882:167): [True: 0, False: 3]
  ------------------
_ZNK8ImVectorI6ImVec4E14_grow_capacityEi:
 1878|      3|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 3]
  |  Branch (1878:131): [True: 3, False: 0]
  ------------------
_ZN8ImVectorIPvE6resizeEi:
 1879|   180k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 0, False: 180k]
  ------------------
_ZN8ImVectorIPvE7reserveEi:
 1882|      3|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      3|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 3]
  |  Branch (1882:167): [True: 0, False: 3]
  ------------------
_ZNK8ImVectorIPvE14_grow_capacityEi:
 1878|      3|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 3]
  |  Branch (1878:131): [True: 3, False: 0]
  ------------------
_ZN8ImVectorI6ImVec2E6resizeEi:
 1879|   182k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 3, False: 182k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI10ImDrawVertE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIPvE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E9push_backERKS0_:
 1886|   361k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 3, False: 361k]
  ------------------
_ZN8ImVectorI6ImVec4E8pop_backEv:
 1887|   180k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIPvE9push_backERKS0_:
 1886|   180k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 3, False: 180k]
  ------------------
_ZN8ImVectorI6ImVec2E15reserve_discardEi:
 1883|   362k|    inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
                  inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 1820|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
  |  Branch (1883:67): [True: 362k, False: 2]
  |  Branch (1883:105): [True: 1, False: 1]
  ------------------
_ZNK8ImVectorItE5emptyEv:
 1860|    176|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI21ImFontAtlasCustomRectEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigEC2Ev:
 1851|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigEixEi:
 1865|      4|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      4|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI12ImFontConfigE9push_backERKS0_:
 1886|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI12ImFontConfigE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE4backEv:
 1874|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_:
 1886|      2|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (1886:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE7reserveEi:
 1882|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 1]
  |  Branch (1882:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI21ImFontAtlasCustomRectE14_grow_capacityEi:
 1878|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 1]
  |  Branch (1878:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10stbrp_rectED2Ev:
 1854|      2|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1854:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI10stbrp_rectE6resizeEi:
 1879|      2|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectE7reserveEi:
 1882|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 2]
  |  Branch (1882:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorI10stbrp_rectE14_grow_capacityEi:
 1878|      2|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 0, False: 2]
  |  Branch (1878:131): [True: 1, False: 1]
  ------------------
_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv:
 1862|      2|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI10stbrp_rectEixEi:
 1865|     20|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     20|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphEC2Ev:
 1851|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImFontGlyphE5clearEv:
 1856|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1856:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI11ImFontGlyphEixEi:
 1865|    669|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    669|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE4backEv:
 1874|    225|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE6resizeEi:
 1879|    224|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (1879:67): [True: 10, False: 214]
  ------------------
_ZN8ImVectorI11ImFontGlyphE7reserveEi:
 1882|     10|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1820|     10|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 1821|      9|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (1882:67): [True: 0, False: 10]
  |  Branch (1882:167): [True: 9, False: 1]
  ------------------
_ZNK8ImVectorI11ImFontGlyphE14_grow_capacityEi:
 1878|     10|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (1878:82): [True: 9, False: 1]
  |  Branch (1878:131): [True: 10, False: 0]
  ------------------
_ZN8ImVectorIfE6resizeEiRKf:
 1880|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1880:67): [True: 1, False: 0]
  |  Branch (1880:127): [True: 1, False: 0]
  |  Branch (1880:163): [True: 256, False: 1]
  ------------------
_ZN8ImVectorItE6resizeEiRKt:
 1880|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (1880:67): [True: 1, False: 0]
  |  Branch (1880:127): [True: 1, False: 0]
  |  Branch (1880:163): [True: 256, False: 1]
  ------------------

_ZN5ImGui15StyleColorsDarkEP10ImGuiStyle:
  175|      1|{
  176|      1|    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
  ------------------
  |  Branch (176:25): [True: 1, False: 0]
  ------------------
  177|      1|    ImVec4* colors = style->Colors;
  178|       |
  179|      1|    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
  180|      1|    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
  181|      1|    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
  182|      1|    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  183|      1|    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
  184|      1|    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
  185|      1|    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  186|      1|    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
  187|      1|    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  188|      1|    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  189|      1|    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
  190|      1|    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
  191|      1|    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
  192|      1|    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
  193|      1|    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
  194|      1|    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
  195|      1|    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
  196|      1|    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
  197|      1|    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  198|      1|    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
  199|      1|    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  200|      1|    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  201|      1|    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  202|      1|    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
  203|      1|    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
  204|      1|    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
  205|      1|    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  206|      1|    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
  207|      1|    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
  208|      1|    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
  209|      1|    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
  210|      1|    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  211|      1|    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
  212|      1|    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
  213|      1|    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
  214|      1|    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
  215|      1|    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
  216|      1|    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);
  217|      1|    colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
  218|      1|    colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
  219|      1|    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
  220|      1|    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
  221|      1|    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
  222|      1|    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
  223|      1|    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
  224|      1|    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
  225|      1|    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
  226|      1|    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  227|      1|    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
  228|      1|    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
  229|      1|    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
  230|      1|    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  231|      1|    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
  232|      1|    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
  233|      1|    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
  234|      1|}
_ZN20ImDrawListSharedDataC2Ev:
  366|      1|{
  367|      1|    memset(this, 0, sizeof(*this));
  368|     49|    for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
  ------------------
  |  |   87|     49|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (368:21): [True: 48, False: 1]
  ------------------
  369|     48|    {
  370|     48|        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |  257|     48|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |   87|     48|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  371|     48|        ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  439|     48|#define ImCos(X)            cosf(X)
  ------------------
                      ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  440|     48|#define ImSin(X)            sinf(X)
  ------------------
  372|     48|    }
  373|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  761|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  439|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  374|      1|}
_ZN20ImDrawListSharedData29SetCircleTessellationMaxErrorEf:
  377|  90.2k|{
  378|  90.2k|    if (CircleSegmentMaxError == max_error)
  ------------------
  |  Branch (378:9): [True: 90.2k, False: 1]
  ------------------
  379|  90.2k|        return;
  380|       |
  381|      1|    IM_ASSERT(max_error > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  382|      1|    CircleSegmentMaxError = max_error;
  383|     65|    for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
  ------------------
  |  |   87|     65|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (383:21): [True: 64, False: 1]
  ------------------
  384|     64|    {
  385|     64|        const float radius = (float)i;
  386|     64|        CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  758|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  755|     63|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  756|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  757|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
                      CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  768|      1|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      1|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (386:41): [True: 63, False: 1]
  ------------------
  387|     64|    }
  388|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  761|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  439|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  389|      1|}
_ZN10ImDrawList17_ResetForNewFrameEv:
  393|   180k|{
  394|       |    // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
  395|   180k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, ClipRect) == 0);
  ------------------
  |  |  239|   180k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  396|   180k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, TextureId) == sizeof(ImVec4));
  ------------------
  |  |  239|   180k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  397|   180k|    IM_STATIC_ASSERT(IM_OFFSETOF(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
  ------------------
  |  |  239|   180k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  398|   180k|    if (_Splitter._Count > 1)
  ------------------
  |  Branch (398:9): [True: 0, False: 180k]
  ------------------
  399|      0|        _Splitter.Merge(this);
  400|       |
  401|   180k|    CmdBuffer.resize(0);
  402|   180k|    IdxBuffer.resize(0);
  403|   180k|    VtxBuffer.resize(0);
  404|   180k|    Flags = _Data->InitialFlags;
  405|   180k|    memset(&_CmdHeader, 0, sizeof(_CmdHeader));
  406|   180k|    _VtxCurrentIdx = 0;
  407|   180k|    _VtxWritePtr = NULL;
  408|   180k|    _IdxWritePtr = NULL;
  409|   180k|    _ClipRectStack.resize(0);
  410|   180k|    _TextureIdStack.resize(0);
  411|   180k|    _Path.resize(0);
  412|   180k|    _Splitter.Clear();
  413|   180k|    CmdBuffer.push_back(ImDrawCmd());
  414|   180k|    _FringeScale = 1.0f;
  415|   180k|}
_ZN10ImDrawList16_ClearFreeMemoryEv:
  418|      1|{
  419|      1|    CmdBuffer.clear();
  420|      1|    IdxBuffer.clear();
  421|      1|    VtxBuffer.clear();
  422|      1|    Flags = ImDrawListFlags_None;
  423|      1|    _VtxCurrentIdx = 0;
  424|      1|    _VtxWritePtr = NULL;
  425|      1|    _IdxWritePtr = NULL;
  426|      1|    _ClipRectStack.clear();
  427|      1|    _TextureIdStack.clear();
  428|      1|    _Path.clear();
  429|      1|    _Splitter.ClearFreeMemory();
  430|      1|}
_ZN10ImDrawList10AddDrawCmdEv:
  443|   181k|{
  444|   181k|    ImDrawCmd draw_cmd;
  445|   181k|    draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
  446|   181k|    draw_cmd.TextureId = _CmdHeader.TextureId;
  447|   181k|    draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
  448|   181k|    draw_cmd.IdxOffset = IdxBuffer.Size;
  449|       |
  450|   181k|    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
  ------------------
  |  |   23|   181k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  451|   181k|    CmdBuffer.push_back(draw_cmd);
  452|   181k|}
_ZN10ImDrawList17_PopUnusedDrawCmdEv:
  457|  90.5k|{
  458|  91.1k|    while (CmdBuffer.Size > 0)
  ------------------
  |  Branch (458:12): [True: 91.1k, False: 0]
  ------------------
  459|  91.1k|    {
  460|  91.1k|        ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  461|  91.1k|        if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
  ------------------
  |  Branch (461:13): [True: 90.5k, False: 641]
  |  Branch (461:41): [True: 0, False: 641]
  ------------------
  462|  90.5k|            return;// break;
  463|    641|        CmdBuffer.pop_back();
  464|    641|    }
  465|  90.5k|}
_ZN10ImDrawList18_OnChangedClipRectEv:
  505|   542k|{
  506|       |    // If current command is used with different settings we need to add a new command
  507|   542k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  245|   542k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   542k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  508|   542k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  509|   542k|    if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
  ------------------
  |  Branch (509:9): [True: 181k, False: 361k]
  |  Branch (509:37): [True: 181k, False: 0]
  ------------------
  510|   181k|    {
  511|   181k|        AddDrawCmd();
  512|   181k|        return;
  513|   181k|    }
  514|   361k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|   361k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  515|       |
  516|       |    // Try to merge with previous command if it matches, else use current command
  517|   361k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  518|   361k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  485|   180k|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  484|   180k|#define ImDrawCmd_HeaderSize                            (IM_OFFSETOF(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  |  |  ------------------
  |  |  |  |  |  |   89|   180k|#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  487|   541k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (487:57): [True: 180k, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (518:9): [True: 361k, False: 0]
  |  Branch (518:37): [True: 180k, False: 181k]
  |  Branch (518:59): [True: 180k, False: 0]
  |  Branch (518:170): [True: 180k, False: 0]
  ------------------
  519|   180k|    {
  520|   180k|        CmdBuffer.pop_back();
  521|   180k|        return;
  522|   180k|    }
  523|       |
  524|   181k|    curr_cmd->ClipRect = _CmdHeader.ClipRect;
  525|   181k|}
_ZN10ImDrawList19_OnChangedTextureIDEv:
  528|   180k|{
  529|       |    // If current command is used with different settings we need to add a new command
  530|   180k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  245|   180k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  531|   180k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  532|   180k|    if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
  ------------------
  |  Branch (532:9): [True: 0, False: 180k]
  |  Branch (532:37): [True: 0, False: 0]
  ------------------
  533|      0|    {
  534|      0|        AddDrawCmd();
  535|      0|        return;
  536|      0|    }
  537|   180k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|   180k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  538|       |
  539|       |    // Try to merge with previous command if it matches, else use current command
  540|   180k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  541|   180k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  485|      0|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  484|      0|#define ImDrawCmd_HeaderSize                            (IM_OFFSETOF(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  |  |  ------------------
  |  |  |  |  |  |   89|      0|#define IM_OFFSETOF(_TYPE,_MEMBER)  offsetof(_TYPE, _MEMBER)                    // Offset of _MEMBER within _TYPE. Standardized as offsetof() in C++11
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  487|   180k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (487:57): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (541:9): [True: 180k, False: 0]
  |  Branch (541:37): [True: 0, False: 180k]
  |  Branch (541:59): [True: 0, False: 0]
  |  Branch (541:170): [True: 0, False: 0]
  ------------------
  542|      0|    {
  543|      0|        CmdBuffer.pop_back();
  544|      0|        return;
  545|      0|    }
  546|       |
  547|   180k|    curr_cmd->TextureId = _CmdHeader.TextureId;
  548|   180k|}
_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf:
  567|  1.45k|{
  568|       |    // Automatic segment count
  569|  1.45k|    const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy
  570|  1.45k|    if (radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
  ------------------
  |  |   87|  1.45k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (570:9): [True: 1.45k, False: 0]
  ------------------
  571|  1.45k|        return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
  572|      0|    else
  573|      0|        return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
  ------------------
  |  |  758|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  755|      0|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  756|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  757|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
  574|  1.45k|}
_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b:
  578|   361k|{
  579|   361k|    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
  580|   361k|    if (intersect_with_current_clip_rect)
  ------------------
  |  Branch (580:9): [True: 180k, False: 180k]
  ------------------
  581|   180k|    {
  582|   180k|        ImVec4 current = _CmdHeader.ClipRect;
  583|   180k|        if (cr.x < current.x) cr.x = current.x;
  ------------------
  |  Branch (583:13): [True: 0, False: 180k]
  ------------------
  584|   180k|        if (cr.y < current.y) cr.y = current.y;
  ------------------
  |  Branch (584:13): [True: 0, False: 180k]
  ------------------
  585|   180k|        if (cr.z > current.z) cr.z = current.z;
  ------------------
  |  Branch (585:13): [True: 0, False: 180k]
  ------------------
  586|   180k|        if (cr.w > current.w) cr.w = current.w;
  ------------------
  |  Branch (586:13): [True: 0, False: 180k]
  ------------------
  587|   180k|    }
  588|   361k|    cr.z = ImMax(cr.x, cr.z);
  589|   361k|    cr.w = ImMax(cr.y, cr.w);
  590|       |
  591|   361k|    _ClipRectStack.push_back(cr);
  592|   361k|    _CmdHeader.ClipRect = cr;
  593|   361k|    _OnChangedClipRect();
  594|   361k|}
_ZN10ImDrawList11PopClipRectEv:
  602|   180k|{
  603|   180k|    _ClipRectStack.pop_back();
  604|   180k|    _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
  ------------------
  |  Branch (604:27): [True: 0, False: 180k]
  ------------------
  605|   180k|    _OnChangedClipRect();
  606|   180k|}
_ZN10ImDrawList13PushTextureIDEPv:
  609|   180k|{
  610|   180k|    _TextureIdStack.push_back(texture_id);
  611|   180k|    _CmdHeader.TextureId = texture_id;
  612|   180k|    _OnChangedTextureID();
  613|   180k|}
_ZN10ImDrawList11PrimReserveEii:
  626|   815k|{
  627|       |    // Large mesh support (when enabled)
  628|   815k|    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
  ------------------
  |  |  245|   815k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   815k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  629|   815k|    if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (629:9): [Folded - Ignored]
  |  Branch (629:35): [True: 0, False: 815k]
  |  Branch (629:80): [True: 0, False: 0]
  ------------------
  630|      0|    {
  631|       |        // FIXME: In theory we should be testing that vtx_count <64k here.
  632|       |        // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
  633|       |        // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
  634|      0|        _CmdHeader.VtxOffset = VtxBuffer.Size;
  635|      0|        _OnChangedVtxOffset();
  636|      0|    }
  637|       |
  638|   815k|    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  639|   815k|    draw_cmd->ElemCount += idx_count;
  640|       |
  641|   815k|    int vtx_buffer_old_size = VtxBuffer.Size;
  642|   815k|    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
  643|   815k|    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;
  644|       |
  645|   815k|    int idx_buffer_old_size = IdxBuffer.Size;
  646|   815k|    IdxBuffer.resize(idx_buffer_old_size + idx_count);
  647|   815k|    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
  648|   815k|}
_ZN10ImDrawList8PrimRectERK6ImVec2S2_j:
  663|   272k|{
  664|   272k|    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
  665|   272k|    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
  666|   272k|    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
  667|   272k|    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
  668|   272k|    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
  669|   272k|    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
  670|   272k|    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
  671|   272k|    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
  672|   272k|    _VtxWritePtr += 4;
  673|   272k|    _VtxCurrentIdx += 4;
  674|   272k|    _IdxWritePtr += 6;
  675|   272k|}
_ZN10ImDrawList11AddPolylineEPK6ImVec2ijif:
  716|   181k|{
  717|   181k|    if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2450|   181k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (717:9): [True: 0, False: 181k]
  |  Branch (717:29): [True: 0, False: 181k]
  ------------------
  718|      0|        return;
  719|       |
  720|   181k|    const bool closed = (flags & ImDrawFlags_Closed) != 0;
  721|   181k|    const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
  722|   181k|    const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
  ------------------
  |  Branch (722:23): [True: 181k, False: 0]
  ------------------
  723|   181k|    const bool thick_line = (thickness > _FringeScale);
  724|       |
  725|   181k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (725:9): [True: 181k, False: 0]
  ------------------
  726|   181k|    {
  727|       |        // Anti-aliased stroke
  728|   181k|        const float AA_SIZE = _FringeScale;
  729|   181k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2450|   181k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  730|       |
  731|       |        // Thicknesses <1.0 should behave like thickness 1.0
  732|   181k|        thickness = ImMax(thickness, 1.0f);
  733|   181k|        const int integer_thickness = (int)thickness;
  734|   181k|        const float fractional_thickness = thickness - integer_thickness;
  735|       |
  736|       |        // Do we want to draw this line using a texture?
  737|       |        // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
  738|       |        // - If AA_SIZE is not 1.0f we cannot use the texture path.
  739|   181k|        const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);
  ------------------
  |  | 2486|   181k|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (739:34): [True: 181k, False: 0]
  |  Branch (739:86): [True: 181k, False: 0]
  |  Branch (739:143): [True: 181k, False: 0]
  |  Branch (739:181): [True: 181k, False: 0]
  ------------------
  740|       |
  741|       |        // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
  742|   181k|        IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
  ------------------
  |  |  245|   181k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   181k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  743|       |
  744|   181k|        const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
  ------------------
  |  Branch (744:31): [True: 181k, False: 0]
  |  Branch (744:60): [True: 0, False: 0]
  ------------------
  745|   181k|        const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
  ------------------
  |  Branch (745:31): [True: 181k, False: 0]
  |  Branch (745:67): [True: 0, False: 0]
  ------------------
  746|   181k|        PrimReserve(idx_count, vtx_count);
  747|       |
  748|       |        // Temporary buffer
  749|       |        // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
  750|   181k|        _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
  ------------------
  |  Branch (750:60): [True: 181k, False: 0]
  |  Branch (750:75): [True: 0, False: 0]
  ------------------
  751|   181k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
  752|   181k|        ImVec2* temp_points = temp_normals + points_count;
  753|       |
  754|       |        // Calculate normals (tangents) for each line segment
  755|   906k|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (755:26): [True: 724k, False: 181k]
  ------------------
  756|   724k|        {
  757|   724k|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (757:28): [True: 181k, False: 543k]
  ------------------
  758|   724k|            float dx = points[i2].x - points[i1].x;
  759|   724k|            float dy = points[i2].y - points[i1].y;
  760|   724k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|   724k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 724k, False: 104]
  |  |  ------------------
  ------------------
  761|   724k|            temp_normals[i1].x = dy;
  762|   724k|            temp_normals[i1].y = -dx;
  763|   724k|        }
  764|   181k|        if (!closed)
  ------------------
  |  Branch (764:13): [True: 0, False: 181k]
  ------------------
  765|      0|            temp_normals[points_count - 1] = temp_normals[points_count - 2];
  766|       |
  767|       |        // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
  768|   181k|        if (use_texture || !thick_line)
  ------------------
  |  Branch (768:13): [True: 181k, False: 0]
  |  Branch (768:28): [True: 0, False: 0]
  ------------------
  769|   181k|        {
  770|       |            // [PATH 1] Texture-based lines (thick or non-thick)
  771|       |            // [PATH 2] Non texture-based lines (non-thick)
  772|       |
  773|       |            // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
  774|       |            // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
  775|       |            //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
  776|       |            // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
  777|       |            //   allow scaling geometry while preserving one-screen-pixel AA fringe).
  778|   181k|            const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;
  ------------------
  |  Branch (778:42): [True: 181k, False: 0]
  ------------------
  779|       |
  780|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  781|   181k|            if (!closed)
  ------------------
  |  Branch (781:17): [True: 0, False: 181k]
  ------------------
  782|      0|            {
  783|      0|                temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
  784|      0|                temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
  785|      0|                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
  786|      0|                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
  787|      0|            }
  788|       |
  789|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  790|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  791|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  792|   181k|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  793|   906k|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (793:30): [True: 724k, False: 181k]
  ------------------
  794|   724k|            {
  795|   724k|                const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
  ------------------
  |  Branch (795:32): [True: 181k, False: 543k]
  ------------------
  796|   724k|                const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment
  ------------------
  |  Branch (796:43): [True: 181k, False: 543k]
  |  Branch (796:98): [True: 543k, False: 0]
  ------------------
  797|       |
  798|       |                // Average normals
  799|   724k|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  800|   724k|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  801|   724k|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|   724k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|   724k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 724k, False: 80]
  |  |  |  Branch (711:127): [True: 0, False: 724k]
  |  |  ------------------
  ------------------
  802|   724k|                dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
  803|   724k|                dm_y *= half_draw_size;
  804|       |
  805|       |                // Add temporary vertexes for the outer edges
  806|   724k|                ImVec2* out_vtx = &temp_points[i2 * 2];
  807|   724k|                out_vtx[0].x = points[i2].x + dm_x;
  808|   724k|                out_vtx[0].y = points[i2].y + dm_y;
  809|   724k|                out_vtx[1].x = points[i2].x - dm_x;
  810|   724k|                out_vtx[1].y = points[i2].y - dm_y;
  811|       |
  812|   724k|                if (use_texture)
  ------------------
  |  Branch (812:21): [True: 724k, False: 0]
  ------------------
  813|   724k|                {
  814|       |                    // Add indices for two triangles
  815|   724k|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
  816|   724k|                    _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
  817|   724k|                    _IdxWritePtr += 6;
  818|   724k|                }
  819|      0|                else
  820|      0|                {
  821|       |                    // Add indexes for four triangles
  822|      0|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
  823|      0|                    _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
  824|      0|                    _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
  825|      0|                    _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
  826|      0|                    _IdxWritePtr += 12;
  827|      0|                }
  828|       |
  829|   724k|                idx1 = idx2;
  830|   724k|            }
  831|       |
  832|       |            // Add vertexes for each point on the line
  833|   181k|            if (use_texture)
  ------------------
  |  Branch (833:17): [True: 181k, False: 0]
  ------------------
  834|   181k|            {
  835|       |                // If we're using textures we only need to emit the left/right edge vertices
  836|   181k|                ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
  837|       |                /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
  838|       |                {
  839|       |                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
  840|       |                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
  841|       |                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
  842|       |                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
  843|       |                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
  844|       |                }*/
  845|   181k|                ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
  846|   181k|                ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
  847|   906k|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (847:33): [True: 724k, False: 181k]
  ------------------
  848|   724k|                {
  849|   724k|                    _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
  850|   724k|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
  851|   724k|                    _VtxWritePtr += 2;
  852|   724k|                }
  853|   181k|            }
  854|      0|            else
  855|      0|            {
  856|       |                // If we're not using a texture, we need the center vertex as well
  857|      0|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (857:33): [True: 0, False: 0]
  ------------------
  858|      0|                {
  859|      0|                    _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
  860|      0|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge
  861|      0|                    _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge
  862|      0|                    _VtxWritePtr += 3;
  863|      0|                }
  864|      0|            }
  865|   181k|        }
  866|      0|        else
  867|      0|        {
  868|       |            // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
  869|      0|            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
  870|       |
  871|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  872|      0|            if (!closed)
  ------------------
  |  Branch (872:17): [True: 0, False: 0]
  ------------------
  873|      0|            {
  874|      0|                const int points_last = points_count - 1;
  875|      0|                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
  876|      0|                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
  877|      0|                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
  878|      0|                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
  879|      0|                temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  880|      0|                temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
  881|      0|                temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
  882|      0|                temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  883|      0|            }
  884|       |
  885|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  886|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  887|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  888|      0|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  889|      0|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (889:30): [True: 0, False: 0]
  ------------------
  890|      0|            {
  891|      0|                const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
  ------------------
  |  Branch (891:32): [True: 0, False: 0]
  ------------------
  892|      0|                const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment
  ------------------
  |  Branch (892:43): [True: 0, False: 0]
  ------------------
  893|       |
  894|       |                // Average normals
  895|      0|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  896|      0|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  897|      0|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|      0|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 0, False: 0]
  |  |  |  Branch (711:127): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  898|      0|                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
  899|      0|                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
  900|      0|                float dm_in_x = dm_x * half_inner_thickness;
  901|      0|                float dm_in_y = dm_y * half_inner_thickness;
  902|       |
  903|       |                // Add temporary vertices
  904|      0|                ImVec2* out_vtx = &temp_points[i2 * 4];
  905|      0|                out_vtx[0].x = points[i2].x + dm_out_x;
  906|      0|                out_vtx[0].y = points[i2].y + dm_out_y;
  907|      0|                out_vtx[1].x = points[i2].x + dm_in_x;
  908|      0|                out_vtx[1].y = points[i2].y + dm_in_y;
  909|      0|                out_vtx[2].x = points[i2].x - dm_in_x;
  910|      0|                out_vtx[2].y = points[i2].y - dm_in_y;
  911|      0|                out_vtx[3].x = points[i2].x - dm_out_x;
  912|      0|                out_vtx[3].y = points[i2].y - dm_out_y;
  913|       |
  914|       |                // Add indexes
  915|      0|                _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);
  916|      0|                _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);
  917|      0|                _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);
  918|      0|                _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
  919|      0|                _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
  920|      0|                _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
  921|      0|                _IdxWritePtr += 18;
  922|       |
  923|      0|                idx1 = idx2;
  924|      0|            }
  925|       |
  926|       |            // Add vertices
  927|      0|            for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (927:29): [True: 0, False: 0]
  ------------------
  928|      0|            {
  929|      0|                _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
  930|      0|                _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  931|      0|                _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  932|      0|                _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
  933|      0|                _VtxWritePtr += 4;
  934|      0|            }
  935|      0|        }
  936|   181k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
  937|   181k|    }
  938|      0|    else
  939|      0|    {
  940|       |        // [PATH 4] Non texture-based, Non anti-aliased lines
  941|      0|        const int idx_count = count * 6;
  942|      0|        const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
  943|      0|        PrimReserve(idx_count, vtx_count);
  944|       |
  945|      0|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (945:26): [True: 0, False: 0]
  ------------------
  946|      0|        {
  947|      0|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (947:28): [True: 0, False: 0]
  ------------------
  948|      0|            const ImVec2& p1 = points[i1];
  949|      0|            const ImVec2& p2 = points[i2];
  950|       |
  951|      0|            float dx = p2.x - p1.x;
  952|      0|            float dy = p2.y - p1.y;
  953|      0|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|      0|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  954|      0|            dx *= (thickness * 0.5f);
  955|      0|            dy *= (thickness * 0.5f);
  956|       |
  957|      0|            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;
  958|      0|            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  959|      0|            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  960|      0|            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;
  961|      0|            _VtxWritePtr += 4;
  962|       |
  963|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
  964|      0|            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
  965|      0|            _IdxWritePtr += 6;
  966|      0|            _VtxCurrentIdx += 4;
  967|      0|        }
  968|      0|    }
  969|   181k|}
_ZN10ImDrawList19AddConvexPolyFilledEPK6ImVec2ij:
  974|   181k|{
  975|   181k|    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2450|   181k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (975:9): [True: 0, False: 181k]
  |  Branch (975:29): [True: 0, False: 181k]
  ------------------
  976|      0|        return;
  977|       |
  978|   181k|    const ImVec2 uv = _Data->TexUvWhitePixel;
  979|       |
  980|   181k|    if (Flags & ImDrawListFlags_AntiAliasedFill)
  ------------------
  |  Branch (980:9): [True: 181k, False: 0]
  ------------------
  981|   181k|    {
  982|       |        // Anti-aliased Fill
  983|   181k|        const float AA_SIZE = _FringeScale;
  984|   181k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2450|   181k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  985|   181k|        const int idx_count = (points_count - 2)*3 + points_count * 6;
  986|   181k|        const int vtx_count = (points_count * 2);
  987|   181k|        PrimReserve(idx_count, vtx_count);
  988|       |
  989|       |        // Add indexes for fill
  990|   181k|        unsigned int vtx_inner_idx = _VtxCurrentIdx;
  991|   181k|        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
  992|   367k|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (992:25): [True: 186k, False: 181k]
  ------------------
  993|   186k|        {
  994|   186k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
  995|   186k|            _IdxWritePtr += 3;
  996|   186k|        }
  997|       |
  998|       |        // Compute normals
  999|   181k|        _Data->TempBuffer.reserve_discard(points_count);
 1000|   181k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
 1001|   730k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1001:49): [True: 549k, False: 181k]
  ------------------
 1002|   549k|        {
 1003|   549k|            const ImVec2& p0 = points[i0];
 1004|   549k|            const ImVec2& p1 = points[i1];
 1005|   549k|            float dx = p1.x - p0.x;
 1006|   549k|            float dy = p1.y - p0.y;
 1007|   549k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  709|   549k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (709:77): [True: 549k, False: 0]
  |  |  ------------------
  ------------------
 1008|   549k|            temp_normals[i0].x = dy;
 1009|   549k|            temp_normals[i0].y = -dx;
 1010|   549k|        }
 1011|       |
 1012|   730k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1012:49): [True: 549k, False: 181k]
  ------------------
 1013|   549k|        {
 1014|       |            // Average normals
 1015|   549k|            const ImVec2& n0 = temp_normals[i0];
 1016|   549k|            const ImVec2& n1 = temp_normals[i1];
 1017|   549k|            float dm_x = (n0.x + n1.x) * 0.5f;
 1018|   549k|            float dm_y = (n0.y + n1.y) * 0.5f;
 1019|   549k|            IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  711|   549k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|   549k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  710|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (711:77): [True: 549k, False: 0]
  |  |  |  Branch (711:127): [True: 0, False: 549k]
  |  |  ------------------
  ------------------
 1020|   549k|            dm_x *= AA_SIZE * 0.5f;
 1021|   549k|            dm_y *= AA_SIZE * 0.5f;
 1022|       |
 1023|       |            // Add vertices
 1024|   549k|            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
 1025|   549k|            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
 1026|   549k|            _VtxWritePtr += 2;
 1027|       |
 1028|       |            // Add indexes for fringes
 1029|   549k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
 1030|   549k|            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
 1031|   549k|            _IdxWritePtr += 6;
 1032|   549k|        }
 1033|   181k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1034|   181k|    }
 1035|      0|    else
 1036|      0|    {
 1037|       |        // Non Anti-aliased Fill
 1038|      0|        const int idx_count = (points_count - 2)*3;
 1039|      0|        const int vtx_count = points_count;
 1040|      0|        PrimReserve(idx_count, vtx_count);
 1041|      0|        for (int i = 0; i < vtx_count; i++)
  ------------------
  |  Branch (1041:25): [True: 0, False: 0]
  ------------------
 1042|      0|        {
 1043|      0|            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
 1044|      0|            _VtxWritePtr++;
 1045|      0|        }
 1046|      0|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (1046:25): [True: 0, False: 0]
  ------------------
 1047|      0|        {
 1048|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
 1049|      0|            _IdxWritePtr += 3;
 1050|      0|        }
 1051|      0|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1052|      0|    }
 1053|   181k|}
_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii:
 1056|  1.45k|{
 1057|  1.45k|    if (radius < 0.5f)
  ------------------
  |  Branch (1057:9): [True: 0, False: 1.45k]
  ------------------
 1058|      0|    {
 1059|      0|        _Path.push_back(center);
 1060|      0|        return;
 1061|      0|    }
 1062|       |
 1063|       |    // Calculate arc auto segment step size
 1064|  1.45k|    if (a_step <= 0)
  ------------------
  |  Branch (1064:9): [True: 1.45k, False: 0]
  ------------------
 1065|  1.45k|        a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);
  ------------------
  |  |  768|  1.45k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|  1.45k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1066|       |
 1067|       |    // Make sure we never do steps larger than one quarter of the circle
 1068|  1.45k|    a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);
  ------------------
  |  |  766|  1.45k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  ------------------
 1069|       |
 1070|  1.45k|    const int sample_range = ImAbs(a_max_sample - a_min_sample);
 1071|  1.45k|    const int a_next_step = a_step;
 1072|       |
 1073|  1.45k|    int samples = sample_range + 1;
 1074|  1.45k|    bool extra_max_sample = false;
 1075|  1.45k|    if (a_step > 1)
  ------------------
  |  Branch (1075:9): [True: 1.45k, False: 0]
  ------------------
 1076|  1.45k|    {
 1077|  1.45k|        samples            = sample_range / a_step + 1;
 1078|  1.45k|        const int overstep = sample_range % a_step;
 1079|       |
 1080|  1.45k|        if (overstep > 0)
  ------------------
  |  Branch (1080:13): [True: 0, False: 1.45k]
  ------------------
 1081|      0|        {
 1082|      0|            extra_max_sample = true;
 1083|      0|            samples++;
 1084|       |
 1085|       |            // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
 1086|       |            // distribute first step range evenly between them by reducing first step size.
 1087|      0|            if (sample_range > 0)
  ------------------
  |  Branch (1087:17): [True: 0, False: 0]
  ------------------
 1088|      0|                a_step -= (a_step - overstep) / 2;
 1089|      0|        }
 1090|  1.45k|    }
 1091|       |
 1092|  1.45k|    _Path.resize(_Path.Size + samples);
 1093|  1.45k|    ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);
 1094|       |
 1095|  1.45k|    int sample_index = a_min_sample;
 1096|  1.45k|    if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  768|  1.45k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|  1.45k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1096:9): [True: 0, False: 1.45k]
  |  Branch (1096:29): [True: 0, False: 1.45k]
  ------------------
 1097|      0|    {
 1098|      0|        sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1099|      0|        if (sample_index < 0)
  ------------------
  |  Branch (1099:13): [True: 0, False: 0]
  ------------------
 1100|      0|            sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1101|      0|    }
 1102|       |
 1103|  1.45k|    if (a_max_sample >= a_min_sample)
  ------------------
  |  Branch (1103:9): [True: 1.45k, False: 0]
  ------------------
 1104|  1.45k|    {
 1105|  5.28k|        for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
  ------------------
  |  Branch (1105:36): [True: 3.82k, False: 1.45k]
  ------------------
 1106|  3.82k|        {
 1107|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1108|  3.82k|            if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  768|  3.82k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|  3.82k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1108:17): [True: 364, False: 3.46k]
  ------------------
 1109|    364|                sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|    364|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|    364|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1110|       |
 1111|  3.82k|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1112|  3.82k|            out_ptr->x = center.x + s.x * radius;
 1113|  3.82k|            out_ptr->y = center.y + s.y * radius;
 1114|  3.82k|            out_ptr++;
 1115|  3.82k|        }
 1116|  1.45k|    }
 1117|      0|    else
 1118|      0|    {
 1119|      0|        for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
  ------------------
  |  Branch (1119:36): [True: 0, False: 0]
  ------------------
 1120|      0|        {
 1121|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1122|      0|            if (sample_index < 0)
  ------------------
  |  Branch (1122:17): [True: 0, False: 0]
  ------------------
 1123|      0|                sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1124|       |
 1125|      0|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1126|      0|            out_ptr->x = center.x + s.x * radius;
 1127|      0|            out_ptr->y = center.y + s.y * radius;
 1128|      0|            out_ptr++;
 1129|      0|        }
 1130|      0|    }
 1131|       |
 1132|  1.45k|    if (extra_max_sample)
  ------------------
  |  Branch (1132:9): [True: 0, False: 1.45k]
  ------------------
 1133|      0|    {
 1134|      0|        int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1135|      0|        if (normalized_max_sample < 0)
  ------------------
  |  Branch (1135:13): [True: 0, False: 0]
  ------------------
 1136|      0|            normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1137|       |
 1138|      0|        const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];
 1139|      0|        out_ptr->x = center.x + s.x * radius;
 1140|      0|        out_ptr->y = center.y + s.y * radius;
 1141|      0|        out_ptr++;
 1142|      0|    }
 1143|       |
 1144|  1.45k|    IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
  ------------------
  |  |  245|  1.45k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|  1.45k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 1145|  1.45k|}
_ZN10ImDrawList11_PathArcToNERK6ImVec2fffi:
 1148|    339|{
 1149|    339|    if (radius < 0.5f)
  ------------------
  |  Branch (1149:9): [True: 0, False: 339]
  ------------------
 1150|      0|    {
 1151|      0|        _Path.push_back(center);
 1152|      0|        return;
 1153|      0|    }
 1154|       |
 1155|       |    // Note that we are adding a point at both a_min and a_max.
 1156|       |    // If you are trying to draw a full closed circle you don't want the overlapping points!
 1157|    339|    _Path.reserve(_Path.Size + (num_segments + 1));
 1158|  4.40k|    for (int i = 0; i <= num_segments; i++)
  ------------------
  |  Branch (1158:21): [True: 4.06k, False: 339]
  ------------------
 1159|  4.06k|    {
 1160|  4.06k|        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
 1161|  4.06k|        _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  439|  4.06k|#define ImCos(X)            cosf(X)
  ------------------
                      _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  440|  4.06k|#define ImSin(X)            sinf(X)
  ------------------
 1162|  4.06k|    }
 1163|    339|}
_ZN10ImDrawList13PathArcToFastERK6ImVec2fii:
 1167|  1.77k|{
 1168|  1.77k|    if (radius < 0.5f)
  ------------------
  |  Branch (1168:9): [True: 321, False: 1.45k]
  ------------------
 1169|    321|    {
 1170|    321|        _Path.push_back(center);
 1171|    321|        return;
 1172|    321|    }
 1173|  1.45k|    _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  768|  1.45k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|  1.45k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                  _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  768|  1.45k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|  1.45k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1174|  1.45k|}
_ZN10ImDrawList9PathArcToERK6ImVec2fffi:
 1177|    339|{
 1178|    339|    if (radius < 0.5f)
  ------------------
  |  Branch (1178:9): [True: 0, False: 339]
  ------------------
 1179|      0|    {
 1180|      0|        _Path.push_back(center);
 1181|      0|        return;
 1182|      0|    }
 1183|       |
 1184|    339|    if (num_segments > 0)
  ------------------
  |  Branch (1184:9): [True: 339, False: 0]
  ------------------
 1185|    339|    {
 1186|    339|        _PathArcToN(center, radius, a_min, a_max, num_segments);
 1187|    339|        return;
 1188|    339|    }
 1189|       |
 1190|       |    // Automatic segment count
 1191|      0|    if (radius <= _Data->ArcFastRadiusCutoff)
  ------------------
  |  Branch (1191:9): [True: 0, False: 0]
  ------------------
 1192|      0|    {
 1193|      0|        const bool a_is_reverse = a_max < a_min;
 1194|       |
 1195|       |        // We are going to use precomputed values for mid samples.
 1196|       |        // Determine first and last sample in lookup table that belong to the arc.
 1197|      0|        const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  257|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1198|      0|        const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  257|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1199|       |
 1200|      0|        const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);
  ------------------
  |  |  445|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1200:34): [True: 0, False: 0]
  ------------------
 1201|      0|        const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloorSigned(a_max_sample_f);
  ------------------
  |  |  445|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1201:34): [True: 0, False: 0]
  ------------------
 1202|      0|        const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);
  ------------------
  |  Branch (1202:35): [True: 0, False: 0]
  ------------------
 1203|       |
 1204|      0|        const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  257|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1205|      0|        const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  257|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1206|      0|        const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;
 1207|      0|        const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;
 1208|       |
 1209|      0|        _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));
  ------------------
  |  Branch (1209:58): [True: 0, False: 0]
  |  Branch (1209:83): [True: 0, False: 0]
  ------------------
 1210|      0|        if (a_emit_start)
  ------------------
  |  Branch (1210:13): [True: 0, False: 0]
  ------------------
 1211|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  439|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  440|      0|#define ImSin(X)            sinf(X)
  ------------------
 1212|      0|        if (a_mid_samples > 0)
  ------------------
  |  Branch (1212:13): [True: 0, False: 0]
  ------------------
 1213|      0|            _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
 1214|      0|        if (a_emit_end)
  ------------------
  |  Branch (1214:13): [True: 0, False: 0]
  ------------------
 1215|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  439|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  440|      0|#define ImSin(X)            sinf(X)
  ------------------
 1216|      0|    }
 1217|      0|    else
 1218|      0|    {
 1219|      0|        const float arc_length = ImAbs(a_max - a_min);
 1220|      0|        const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
 1221|      0|        const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  445|      0|#define ImCeil(X)           ceilf(X)
  ------------------
                      const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  257|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1222|      0|        _PathArcToN(center, radius, a_min, a_max, arc_segment_count);
 1223|      0|    }
 1224|      0|}
_ZN10ImDrawList8PathRectERK6ImVec2S2_fi:
 1357|   181k|{
 1358|   181k|    flags = FixRectCornerFlags(flags);
 1359|   181k|    rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((flags & ImDrawFlags_RoundCornersTop)  == ImDrawFlags_RoundCornersTop)  || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f ) - 1.0f);
  ------------------
  |  |  436|   181k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1359:54): [True: 181k, False: 0]
  |  Branch (1359:130): [True: 0, False: 0]
  ------------------
 1360|   181k|    rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight)  == ImDrawFlags_RoundCornersRight)  ? 0.5f : 1.0f ) - 1.0f);
  ------------------
  |  |  436|   181k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1360:54): [True: 181k, False: 0]
  |  Branch (1360:130): [True: 0, False: 0]
  ------------------
 1361|       |
 1362|   181k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1362:9): [True: 181k, False: 364]
  |  Branch (1362:28): [True: 0, False: 364]
  ------------------
 1363|   181k|    {
 1364|   181k|        PathLineTo(a);
 1365|   181k|        PathLineTo(ImVec2(b.x, a.y));
 1366|   181k|        PathLineTo(b);
 1367|   181k|        PathLineTo(ImVec2(a.x, b.y));
 1368|   181k|    }
 1369|    364|    else
 1370|    364|    {
 1371|    364|        const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;
  ------------------
  |  Branch (1371:35): [True: 364, False: 0]
  ------------------
 1372|    364|        const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
  ------------------
  |  Branch (1372:35): [True: 364, False: 0]
  ------------------
 1373|    364|        const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
  ------------------
  |  Branch (1373:35): [True: 364, False: 0]
  ------------------
 1374|    364|        const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
  ------------------
  |  Branch (1374:35): [True: 364, False: 0]
  ------------------
 1375|    364|        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
 1376|    364|        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
 1377|    364|        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
 1378|    364|        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
 1379|    364|    }
 1380|   181k|}
_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif:
 1394|   270k|{
 1395|   270k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2450|   270k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1395:9): [True: 89.9k, False: 181k]
  ------------------
 1396|  89.9k|        return;
 1397|   181k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (1397:9): [True: 181k, False: 0]
  ------------------
 1398|   181k|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
 1399|      0|    else
 1400|      0|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
 1401|   181k|    PathStroke(col, ImDrawFlags_Closed, thickness);
 1402|   181k|}
_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi:
 1405|   272k|{
 1406|   272k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2450|   272k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1406:9): [True: 0, False: 272k]
  ------------------
 1407|      0|        return;
 1408|   272k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1408:9): [True: 272k, False: 343]
  |  Branch (1408:28): [True: 0, False: 343]
  ------------------
 1409|   272k|    {
 1410|   272k|        PrimReserve(6, 4);
 1411|   272k|        PrimRect(p_min, p_max, col);
 1412|   272k|    }
 1413|    343|    else
 1414|    343|    {
 1415|    343|        PathRect(p_min, p_max, rounding, flags);
 1416|    343|        PathFillConvex(col);
 1417|    343|    }
 1418|   272k|}
_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j:
 1472|   180k|{
 1473|   180k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2450|   180k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1473:9): [True: 0, False: 180k]
  ------------------
 1474|      0|        return;
 1475|       |
 1476|   180k|    PathLineTo(p1);
 1477|   180k|    PathLineTo(p2);
 1478|   180k|    PathLineTo(p3);
 1479|   180k|    PathFillConvex(col);
 1480|   180k|}
_ZN10ImDrawList15AddCircleFilledERK6ImVec2fji:
 1507|    339|{
 1508|    339|    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
  ------------------
  |  | 2450|    339|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1508:9): [True: 0, False: 339]
  |  Branch (1508:41): [True: 0, False: 339]
  ------------------
 1509|      0|        return;
 1510|       |
 1511|    339|    if (num_segments <= 0)
  ------------------
  |  Branch (1511:9): [True: 0, False: 339]
  ------------------
 1512|      0|    {
 1513|       |        // Use arc with automatic segment count
 1514|      0|        _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
  ------------------
  |  |  768|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  766|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1515|      0|        _Path.Size--;
 1516|      0|    }
 1517|    339|    else
 1518|    339|    {
 1519|       |        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
 1520|    339|        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
  ------------------
  |  |  757|    339|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  ------------------
 1521|       |
 1522|       |        // Because we are filling a closed shape we remove 1 from the count of segments/points
 1523|    339|        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
  ------------------
  |  |  257|    339|#define IM_PI                           3.14159265358979323846f
  ------------------
 1524|    339|        PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
 1525|    339|    }
 1526|       |
 1527|    339|    PathFillConvex(col);
 1528|    339|}
_ZN10ImDrawList7AddTextEPK6ImFontfRK6ImVec2jPKcS7_fPK6ImVec4:
 1577|   181k|{
 1578|   181k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2450|   181k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1578:9): [True: 0, False: 181k]
  ------------------
 1579|      0|        return;
 1580|       |
 1581|   181k|    if (text_end == NULL)
  ------------------
  |  Branch (1581:9): [True: 1.06k, False: 180k]
  ------------------
 1582|  1.06k|        text_end = text_begin + strlen(text_begin);
 1583|   181k|    if (text_begin == text_end)
  ------------------
  |  Branch (1583:9): [True: 0, False: 181k]
  ------------------
 1584|      0|        return;
 1585|       |
 1586|       |    // Pull default font/size from the shared ImDrawListSharedData instance
 1587|   181k|    if (font == NULL)
  ------------------
  |  Branch (1587:9): [True: 181k, False: 0]
  ------------------
 1588|   181k|        font = _Data->Font;
 1589|   181k|    if (font_size == 0.0f)
  ------------------
  |  Branch (1589:9): [True: 181k, False: 0]
  ------------------
 1590|   181k|        font_size = _Data->FontSize;
 1591|       |
 1592|   181k|    IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
  ------------------
  |  |   23|   181k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1593|       |
 1594|   181k|    ImVec4 clip_rect = _CmdHeader.ClipRect;
 1595|   181k|    if (cpu_fine_clip_rect)
  ------------------
  |  Branch (1595:9): [True: 90.2k, False: 91.2k]
  ------------------
 1596|  90.2k|    {
 1597|  90.2k|        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
 1598|  90.2k|        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
 1599|  90.2k|        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
 1600|  90.2k|        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
 1601|  90.2k|    }
 1602|   181k|    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
 1603|   181k|}
_ZN10ImDrawList7AddTextERK6ImVec2jPKcS4_:
 1606|  1.06k|{
 1607|  1.06k|    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
 1608|  1.06k|}
_ZN18ImDrawListSplitter15ClearFreeMemoryEv:
 1676|      1|{
 1677|      1|    for (int i = 0; i < _Channels.Size; i++)
  ------------------
  |  Branch (1677:21): [True: 0, False: 1]
  ------------------
 1678|      0|    {
 1679|      0|        if (i == _Current)
  ------------------
  |  Branch (1679:13): [True: 0, False: 0]
  ------------------
 1680|      0|            memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
 1681|      0|        _Channels[i]._CmdBuffer.clear();
 1682|      0|        _Channels[i]._IdxBuffer.clear();
 1683|      0|    }
 1684|      1|    _Current = 0;
 1685|      1|    _Count = 1;
 1686|      1|    _Channels.clear();
 1687|      1|}
_ZN12ImFontConfigC2Ev:
 1911|      1|{
 1912|      1|    memset(this, 0, sizeof(*this));
 1913|      1|    FontDataOwnedByAtlas = true;
 1914|      1|    OversampleH = 3; // FIXME: 2 may be a better default?
 1915|      1|    OversampleV = 1;
 1916|      1|    GlyphMaxAdvanceX = FLT_MAX;
 1917|      1|    RasterizerMultiply = 1.0f;
 1918|      1|    EllipsisChar = (ImWchar)-1;
 1919|      1|}
_ZN11ImFontAtlasC2Ev:
 1976|      1|{
 1977|      1|    memset(this, 0, sizeof(*this));
 1978|      1|    TexGlyphPadding = 1;
 1979|      1|    PackIdMouseCursors = PackIdLines = -1;
 1980|      1|}
_ZN11ImFontAtlas12ClearTexDataEv:
 2012|      2|{
 2013|      2|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2014|      2|    if (TexPixelsAlpha8)
  ------------------
  |  Branch (2014:9): [True: 0, False: 2]
  ------------------
 2015|      0|        IM_FREE(TexPixelsAlpha8);
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2016|      2|    if (TexPixelsRGBA32)
  ------------------
  |  Branch (2016:9): [True: 0, False: 2]
  ------------------
 2017|      0|        IM_FREE(TexPixelsRGBA32);
  ------------------
  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2018|      2|    TexPixelsAlpha8 = NULL;
 2019|      2|    TexPixelsRGBA32 = NULL;
 2020|      2|    TexPixelsUseColors = false;
 2021|       |    // Important: we leave TexReady untouched
 2022|      2|}
_ZN11ImFontAtlas18GetTexDataAsAlpha8EPPhPiS2_S2_:
 2039|      1|{
 2040|       |    // Build atlas on demand
 2041|      1|    if (TexPixelsAlpha8 == NULL)
  ------------------
  |  Branch (2041:9): [True: 1, False: 0]
  ------------------
 2042|      1|        Build();
 2043|       |
 2044|      1|    *out_pixels = TexPixelsAlpha8;
 2045|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2045:9): [True: 0, False: 1]
  ------------------
 2046|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2046:9): [True: 0, False: 1]
  ------------------
 2047|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
  ------------------
  |  Branch (2047:9): [True: 0, False: 1]
  ------------------
 2048|      1|}
_ZN11ImFontAtlas18GetTexDataAsRGBA32EPPhPiS2_S2_:
 2051|      1|{
 2052|       |    // Convert to RGBA32 format on demand
 2053|       |    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
 2054|      1|    if (!TexPixelsRGBA32)
  ------------------
  |  Branch (2054:9): [True: 1, False: 0]
  ------------------
 2055|      1|    {
 2056|      1|        unsigned char* pixels = NULL;
 2057|      1|        GetTexDataAsAlpha8(&pixels, NULL, NULL);
 2058|      1|        if (pixels)
  ------------------
  |  Branch (2058:13): [True: 1, False: 0]
  ------------------
 2059|      1|        {
 2060|      1|            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2061|      1|            const unsigned char* src = pixels;
 2062|      1|            unsigned int* dst = TexPixelsRGBA32;
 2063|  32.7k|            for (int n = TexWidth * TexHeight; n > 0; n--)
  ------------------
  |  Branch (2063:48): [True: 32.7k, False: 1]
  ------------------
 2064|  32.7k|                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
  ------------------
  |  | 2453|  32.7k|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2449|  32.7k|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2448|  32.7k|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2447|  32.7k|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2446|  32.7k|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2065|      1|        }
 2066|      1|    }
 2067|       |
 2068|      1|    *out_pixels = (unsigned char*)TexPixelsRGBA32;
 2069|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2069:9): [True: 1, False: 0]
  ------------------
 2070|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2070:9): [True: 1, False: 0]
  ------------------
 2071|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
  ------------------
  |  Branch (2071:9): [True: 0, False: 1]
  ------------------
 2072|      1|}
_ZN11ImFontAtlas7AddFontEPK12ImFontConfig:
 2075|      1|{
 2076|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2077|      1|    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2078|      1|    IM_ASSERT(font_cfg->SizePixels > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2079|       |
 2080|       |    // Create new font
 2081|      1|    if (!font_cfg->MergeMode)
  ------------------
  |  Branch (2081:9): [True: 1, False: 0]
  ------------------
 2082|      1|        Fonts.push_back(IM_NEW(ImFont));
  ------------------
  |  | 1823|      1|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 2083|      0|    else
 2084|      1|        IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2085|       |
 2086|      1|    ConfigData.push_back(*font_cfg);
 2087|      1|    ImFontConfig& new_font_cfg = ConfigData.back();
 2088|      1|    if (new_font_cfg.DstFont == NULL)
  ------------------
  |  Branch (2088:9): [True: 1, False: 0]
  ------------------
 2089|      1|        new_font_cfg.DstFont = Fonts.back();
 2090|      1|    if (!new_font_cfg.FontDataOwnedByAtlas)
  ------------------
  |  Branch (2090:9): [True: 0, False: 1]
  ------------------
 2091|      0|    {
 2092|      0|        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
  ------------------
  |  | 1820|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2093|      0|        new_font_cfg.FontDataOwnedByAtlas = true;
 2094|      0|        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
 2095|      0|    }
 2096|       |
 2097|      1|    if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (2097:9): [True: 1, False: 0]
  ------------------
 2098|      1|        new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;
 2099|       |
 2100|       |    // Invalidate texture
 2101|      1|    TexReady = false;
 2102|      1|    ClearTexData();
 2103|      1|    return new_font_cfg.DstFont;
 2104|      1|}
_ZN11ImFontAtlas14AddFontDefaultEPK12ImFontConfig:
 2124|      1|{
 2125|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2125:29): [True: 0, False: 1]
  ------------------
 2126|      1|    if (!font_cfg_template)
  ------------------
  |  Branch (2126:9): [True: 1, False: 0]
  ------------------
 2127|      1|    {
 2128|      1|        font_cfg.OversampleH = font_cfg.OversampleV = 1;
 2129|      1|        font_cfg.PixelSnapH = true;
 2130|      1|    }
 2131|      1|    if (font_cfg.SizePixels <= 0.0f)
  ------------------
  |  Branch (2131:9): [True: 1, False: 0]
  ------------------
 2132|      1|        font_cfg.SizePixels = 13.0f * 1.0f;
 2133|      1|    if (font_cfg.Name[0] == '\0')
  ------------------
  |  Branch (2133:9): [True: 1, False: 0]
  ------------------
 2134|      1|        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 2135|      1|    font_cfg.EllipsisChar = (ImWchar)0x0085;
 2136|      1|    font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units
  ------------------
  |  |  269|      1|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 2137|       |
 2138|      1|    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
 2139|      1|    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
  ------------------
  |  Branch (2139:35): [True: 0, False: 1]
  ------------------
 2140|      1|    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
 2141|      1|    return font;
 2142|      1|}
_ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt:
 2167|      1|{
 2168|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2169|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2169:29): [True: 1, False: 0]
  ------------------
 2170|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2171|      1|    font_cfg.FontData = ttf_data;
 2172|      1|    font_cfg.FontDataSize = ttf_size;
 2173|      1|    font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
  ------------------
  |  Branch (2173:27): [True: 1, False: 0]
  ------------------
 2174|      1|    if (glyph_ranges)
  ------------------
  |  Branch (2174:9): [True: 1, False: 0]
  ------------------
 2175|      1|        font_cfg.GlyphRanges = glyph_ranges;
 2176|      1|    return AddFont(&font_cfg);
 2177|      1|}
_ZN11ImFontAtlas30AddFontFromMemoryCompressedTTFEPKvifPK12ImFontConfigPKt:
 2180|      1|{
 2181|      1|    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
 2182|      1|    unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2183|      1|    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
 2184|       |
 2185|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2185:29): [True: 1, False: 0]
  ------------------
 2186|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2187|      1|    font_cfg.FontDataOwnedByAtlas = true;
 2188|      1|    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
 2189|      1|}
_ZN11ImFontAtlas36AddFontFromMemoryCompressedBase85TTFEPKcfPK12ImFontConfigPKt:
 2192|      1|{
 2193|      1|    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
 2194|      1|    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2195|      1|    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
 2196|      1|    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
 2197|      1|    IM_FREE(compressed_ttf);
  ------------------
  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2198|      1|    return font;
 2199|      1|}
_ZN11ImFontAtlas20AddCustomRectRegularEii:
 2202|      2|{
 2203|      2|    IM_ASSERT(width > 0 && width <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2204|      2|    IM_ASSERT(height > 0 && height <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2205|      2|    ImFontAtlasCustomRect r;
 2206|      2|    r.Width = (unsigned short)width;
 2207|      2|    r.Height = (unsigned short)height;
 2208|      2|    CustomRects.push_back(r);
 2209|      2|    return CustomRects.Size - 1; // Return index
 2210|      2|}
_ZN11ImFontAtlas5BuildEv:
 2261|      1|{
 2262|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2263|       |
 2264|       |    // Default font is none are specified
 2265|      1|    if (ConfigData.Size == 0)
  ------------------
  |  Branch (2265:9): [True: 1, False: 0]
  ------------------
 2266|      1|        AddFontDefault();
 2267|       |
 2268|       |    // Select builder
 2269|       |    // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
 2270|       |    //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
 2271|       |    //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
 2272|       |    //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
 2273|      1|    const ImFontBuilderIO* builder_io = FontBuilderIO;
 2274|      1|    if (builder_io == NULL)
  ------------------
  |  Branch (2274:9): [True: 1, False: 0]
  ------------------
 2275|      1|    {
 2276|       |#ifdef IMGUI_ENABLE_FREETYPE
 2277|       |        builder_io = ImGuiFreeType::GetBuilderForFreeType();
 2278|       |#elif defined(IMGUI_ENABLE_STB_TRUETYPE)
 2279|      1|        builder_io = ImFontAtlasGetBuilderForStbTruetype();
 2280|       |#else
 2281|       |        IM_ASSERT(0); // Invalid Build function
 2282|       |#endif
 2283|      1|    }
 2284|       |
 2285|       |    // Build
 2286|      1|    return builder_io->FontBuilder_Build(this);
 2287|      1|}
_Z35ImFontAtlasGetBuilderForStbTruetypev:
 2603|      1|{
 2604|      1|    static ImFontBuilderIO io;
 2605|      1|    io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
 2606|      1|    return &io;
 2607|      1|}
_Z25ImFontAtlasBuildSetupFontP11ImFontAtlasP6ImFontP12ImFontConfigff:
 2612|      1|{
 2613|      1|    if (!font_config->MergeMode)
  ------------------
  |  Branch (2613:9): [True: 1, False: 0]
  ------------------
 2614|      1|    {
 2615|      1|        font->ClearOutputData();
 2616|      1|        font->FontSize = font_config->SizePixels;
 2617|      1|        font->ConfigData = font_config;
 2618|      1|        font->ConfigDataCount = 0;
 2619|      1|        font->ContainerAtlas = atlas;
 2620|      1|        font->Ascent = ascent;
 2621|      1|        font->Descent = descent;
 2622|      1|    }
 2623|      1|    font->ConfigDataCount++;
 2624|      1|}
_Z31ImFontAtlasBuildPackCustomRectsP11ImFontAtlasPv:
 2627|      1|{
 2628|      1|    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
 2629|      1|    IM_ASSERT(pack_context != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2630|       |
 2631|      1|    ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
 2632|      1|    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2633|       |
 2634|      1|    ImVector<stbrp_rect> pack_rects;
 2635|      1|    pack_rects.resize(user_rects.Size);
 2636|      1|    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
 2637|      3|    for (int i = 0; i < user_rects.Size; i++)
  ------------------
  |  Branch (2637:21): [True: 2, False: 1]
  ------------------
 2638|      2|    {
 2639|      2|        pack_rects[i].w = user_rects[i].Width;
 2640|      2|        pack_rects[i].h = user_rects[i].Height;
 2641|      2|    }
 2642|      1|    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
 2643|      3|    for (int i = 0; i < pack_rects.Size; i++)
  ------------------
  |  Branch (2643:21): [True: 2, False: 1]
  ------------------
 2644|      2|        if (pack_rects[i].was_packed)
  ------------------
  |  Branch (2644:13): [True: 2, False: 0]
  ------------------
 2645|      2|        {
 2646|      2|            user_rects[i].X = (unsigned short)pack_rects[i].x;
 2647|      2|            user_rects[i].Y = (unsigned short)pack_rects[i].y;
 2648|      2|            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2649|      2|            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
 2650|      2|        }
 2651|      1|}
_Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch:
 2654|      2|{
 2655|      2|    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2656|      2|    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2657|      2|    unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
 2658|     56|    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
  ------------------
  |  Branch (2658:25): [True: 54, False: 2]
  ------------------
 2659|  6.64k|        for (int off_x = 0; off_x < w; off_x++)
  ------------------
  |  Branch (2659:29): [True: 6.58k, False: 54]
  ------------------
 2660|  6.58k|            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
  ------------------
  |  Branch (2660:32): [True: 1.12k, False: 5.46k]
  ------------------
 2661|      2|}
_Z20ImFontAtlasBuildInitP11ImFontAtlas:
 2766|      1|{
 2767|       |    // Register texture region for mouse cursors or standard white pixels
 2768|      1|    if (atlas->PackIdMouseCursors < 0)
  ------------------
  |  Branch (2768:9): [True: 1, False: 0]
  ------------------
 2769|      1|    {
 2770|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (2770:13): [True: 1, False: 0]
  ------------------
 2771|      1|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
 2772|      0|        else
 2773|      0|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
 2774|      1|    }
 2775|       |
 2776|       |    // Register texture region for thick lines
 2777|       |    // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
 2778|      1|    if (atlas->PackIdLines < 0)
  ------------------
  |  Branch (2778:9): [True: 1, False: 0]
  ------------------
 2779|      1|    {
 2780|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (2780:13): [True: 1, False: 0]
  ------------------
 2781|      1|            atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2486|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
                          atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2486|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
 2782|      1|    }
 2783|      1|}
_Z22ImFontAtlasBuildFinishP11ImFontAtlas:
 2787|      1|{
 2788|       |    // Render into our custom data blocks
 2789|      1|    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2790|      1|    ImFontAtlasBuildRenderDefaultTexData(atlas);
 2791|      1|    ImFontAtlasBuildRenderLinesTexData(atlas);
 2792|       |
 2793|       |    // Register custom rectangle glyphs
 2794|      3|    for (int i = 0; i < atlas->CustomRects.Size; i++)
  ------------------
  |  Branch (2794:21): [True: 2, False: 1]
  ------------------
 2795|      2|    {
 2796|      2|        const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
 2797|      2|        if (r->Font == NULL || r->GlyphID == 0)
  ------------------
  |  Branch (2797:13): [True: 2, False: 0]
  |  Branch (2797:32): [True: 0, False: 0]
  ------------------
 2798|      2|            continue;
 2799|       |
 2800|       |        // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
 2801|      0|        IM_ASSERT(r->Font->ContainerAtlas == atlas);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2802|      0|        ImVec2 uv0, uv1;
 2803|      0|        atlas->CalcCustomRectUV(r, &uv0, &uv1);
 2804|      0|        r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
 2805|      0|    }
 2806|       |
 2807|       |    // Build all fonts lookup tables
 2808|      2|    for (int i = 0; i < atlas->Fonts.Size; i++)
  ------------------
  |  Branch (2808:21): [True: 1, False: 1]
  ------------------
 2809|      1|        if (atlas->Fonts[i]->DirtyLookupTables)
  ------------------
  |  Branch (2809:13): [True: 1, False: 0]
  ------------------
 2810|      1|            atlas->Fonts[i]->BuildLookupTable();
 2811|       |
 2812|      1|    atlas->TexReady = true;
 2813|      1|}
_ZN11ImFontAtlas21GetGlyphRangesDefaultEv:
 2817|      1|{
 2818|      1|    static const ImWchar ranges[] =
 2819|      1|    {
 2820|      1|        0x0020, 0x00FF, // Basic Latin + Latin Supplement
 2821|      1|        0,
 2822|      1|    };
 2823|      1|    return &ranges[0];
 2824|      1|}
_ZN6ImFontC2Ev:
 3123|      2|{
 3124|      2|    FontSize = 0.0f;
 3125|      2|    FallbackAdvanceX = 0.0f;
 3126|      2|    FallbackChar = (ImWchar)-1;
 3127|      2|    EllipsisChar = (ImWchar)-1;
 3128|      2|    EllipsisWidth = EllipsisCharStep = 0.0f;
 3129|      2|    EllipsisCharCount = 0;
 3130|      2|    FallbackGlyph = NULL;
 3131|      2|    ContainerAtlas = NULL;
 3132|      2|    ConfigData = NULL;
 3133|      2|    ConfigDataCount = 0;
 3134|      2|    DirtyLookupTables = false;
 3135|      2|    Scale = 1.0f;
 3136|      2|    Ascent = Descent = 0.0f;
 3137|      2|    MetricsTotalSurface = 0;
 3138|      2|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3139|      2|}
_ZN6ImFont15ClearOutputDataEv:
 3147|      1|{
 3148|      1|    FontSize = 0.0f;
 3149|      1|    FallbackAdvanceX = 0.0f;
 3150|      1|    Glyphs.clear();
 3151|      1|    IndexAdvanceX.clear();
 3152|      1|    IndexLookup.clear();
 3153|      1|    FallbackGlyph = NULL;
 3154|      1|    ContainerAtlas = NULL;
 3155|      1|    DirtyLookupTables = true;
 3156|      1|    Ascent = Descent = 0.0f;
 3157|      1|    MetricsTotalSurface = 0;
 3158|      1|}
_ZN6ImFont16BuildLookupTableEv:
 3169|      1|{
 3170|      1|    int max_codepoint = 0;
 3171|    224|    for (int i = 0; i != Glyphs.Size; i++)
  ------------------
  |  Branch (3171:21): [True: 223, False: 1]
  ------------------
 3172|    223|        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);
 3173|       |
 3174|       |    // Build lookup table
 3175|      1|    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3176|      1|    IndexAdvanceX.clear();
 3177|      1|    IndexLookup.clear();
 3178|      1|    DirtyLookupTables = false;
 3179|      1|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3180|      1|    GrowIndex(max_codepoint + 1);
 3181|    224|    for (int i = 0; i < Glyphs.Size; i++)
  ------------------
  |  Branch (3181:21): [True: 223, False: 1]
  ------------------
 3182|    223|    {
 3183|    223|        int codepoint = (int)Glyphs[i].Codepoint;
 3184|    223|        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
 3185|    223|        IndexLookup[codepoint] = (ImWchar)i;
 3186|       |
 3187|       |        // Mark 4K page as used
 3188|    223|        const int page_n = codepoint / 4096;
 3189|    223|        Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
 3190|    223|    }
 3191|       |
 3192|       |    // Create a glyph to handle TAB
 3193|       |    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
 3194|      1|    if (FindGlyph((ImWchar)' '))
  ------------------
  |  Branch (3194:9): [True: 1, False: 0]
  ------------------
 3195|      1|    {
 3196|      1|        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
  ------------------
  |  Branch (3196:13): [True: 1, False: 0]
  ------------------
 3197|      1|            Glyphs.resize(Glyphs.Size + 1);
 3198|      1|        ImFontGlyph& tab_glyph = Glyphs.back();
 3199|      1|        tab_glyph = *FindGlyph((ImWchar)' ');
 3200|      1|        tab_glyph.Codepoint = '\t';
 3201|      1|        tab_glyph.AdvanceX *= IM_TABSIZE;
  ------------------
  |  |  264|      1|#define IM_TABSIZE                      (4)
  ------------------
 3202|      1|        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
 3203|      1|        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
 3204|      1|    }
 3205|       |
 3206|       |    // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
 3207|      1|    SetGlyphVisible((ImWchar)' ', false);
 3208|      1|    SetGlyphVisible((ImWchar)'\t', false);
 3209|       |
 3210|       |    // Ellipsis character is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
 3211|       |    // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
 3212|       |    // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
 3213|      1|    const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
 3214|      1|    const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
 3215|      1|    if (EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (3215:9): [True: 0, False: 1]
  ------------------
 3216|      0|        EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
  ------------------
  |  |   87|      0|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3217|      1|    const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3218|      1|    if (EllipsisChar != (ImWchar)-1)
  ------------------
  |  Branch (3218:9): [True: 1, False: 0]
  ------------------
 3219|      1|    {
 3220|      1|        EllipsisCharCount = 1;
 3221|      1|        EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
 3222|      1|    }
 3223|      0|    else if (dot_char != (ImWchar)-1)
  ------------------
  |  Branch (3223:14): [True: 0, False: 0]
  ------------------
 3224|      0|    {
 3225|      0|        const ImFontGlyph* glyph = FindGlyph(dot_char);
 3226|      0|        EllipsisChar = dot_char;
 3227|      0|        EllipsisCharCount = 3;
 3228|      0|        EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
 3229|      0|        EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
 3230|      0|    }
 3231|       |
 3232|       |    // Setup fallback character
 3233|      1|    const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
  ------------------
  |  | 2277|      1|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 3234|      1|    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3235|      1|    if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3235:9): [True: 1, False: 0]
  ------------------
 3236|      1|    {
 3237|      1|        FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
  ------------------
  |  |   87|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3238|      1|        FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3239|      1|        if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3239:13): [True: 0, False: 1]
  ------------------
 3240|      0|        {
 3241|      0|            FallbackGlyph = &Glyphs.back();
 3242|      0|            FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
 3243|      0|        }
 3244|      1|    }
 3245|       |
 3246|      1|    FallbackAdvanceX = FallbackGlyph->AdvanceX;
 3247|    257|    for (int i = 0; i < max_codepoint + 1; i++)
  ------------------
  |  Branch (3247:21): [True: 256, False: 1]
  ------------------
 3248|    256|        if (IndexAdvanceX[i] < 0.0f)
  ------------------
  |  Branch (3248:13): [True: 32, False: 224]
  ------------------
 3249|     32|            IndexAdvanceX[i] = FallbackAdvanceX;
 3250|      1|}
_ZN6ImFont15SetGlyphVisibleEtb:
 3266|      2|{
 3267|      2|    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))
  ------------------
  |  Branch (3267:22): [True: 2, False: 0]
  ------------------
 3268|      2|        glyph->Visible = visible ? 1 : 0;
  ------------------
  |  Branch (3268:26): [True: 0, False: 2]
  ------------------
 3269|      2|}
_ZN6ImFont9GrowIndexEi:
 3272|      1|{
 3273|      1|    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3274|      1|    if (new_size <= IndexLookup.Size)
  ------------------
  |  Branch (3274:9): [True: 0, False: 1]
  ------------------
 3275|      0|        return;
 3276|      1|    IndexAdvanceX.resize(new_size, -1.0f);
 3277|      1|    IndexLookup.resize(new_size, (ImWchar)-1);
 3278|      1|}
_ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff:
 3284|    223|{
 3285|    223|    if (cfg != NULL)
  ------------------
  |  Branch (3285:9): [True: 223, False: 0]
  ------------------
 3286|    223|    {
 3287|       |        // Clamp & recenter if needed
 3288|    223|        const float advance_x_original = advance_x;
 3289|    223|        advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
 3290|    223|        if (advance_x != advance_x_original)
  ------------------
  |  Branch (3290:13): [True: 0, False: 223]
  ------------------
 3291|      0|        {
 3292|      0|            float char_off_x = cfg->PixelSnapH ? ImFloor((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
  ------------------
  |  Branch (3292:32): [True: 0, False: 0]
  ------------------
 3293|      0|            x0 += char_off_x;
 3294|      0|            x1 += char_off_x;
 3295|      0|        }
 3296|       |
 3297|       |        // Snap to pixel
 3298|    223|        if (cfg->PixelSnapH)
  ------------------
  |  Branch (3298:13): [True: 223, False: 0]
  ------------------
 3299|    223|            advance_x = IM_ROUND(advance_x);
  ------------------
  |  |  270|    223|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 3300|       |
 3301|       |        // Bake spacing
 3302|    223|        advance_x += cfg->GlyphExtraSpacing.x;
 3303|    223|    }
 3304|       |
 3305|    223|    Glyphs.resize(Glyphs.Size + 1);
 3306|    223|    ImFontGlyph& glyph = Glyphs.back();
 3307|    223|    glyph.Codepoint = (unsigned int)codepoint;
 3308|    223|    glyph.Visible = (x0 != x1) && (y0 != y1);
  ------------------
  |  Branch (3308:21): [True: 214, False: 9]
  |  Branch (3308:35): [True: 214, False: 0]
  ------------------
 3309|    223|    glyph.Colored = false;
 3310|    223|    glyph.X0 = x0;
 3311|    223|    glyph.Y0 = y0;
 3312|    223|    glyph.X1 = x1;
 3313|    223|    glyph.Y1 = y1;
 3314|    223|    glyph.U0 = u0;
 3315|    223|    glyph.V0 = v0;
 3316|    223|    glyph.U1 = u1;
 3317|    223|    glyph.V1 = v1;
 3318|    223|    glyph.AdvanceX = advance_x;
 3319|       |
 3320|       |    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
 3321|       |    // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
 3322|    223|    float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
 3323|    223|    DirtyLookupTables = true;
 3324|    223|    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
 3325|    223|}
_ZNK6ImFont9FindGlyphEt:
 3343|  1.44M|{
 3344|  1.44M|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3344:9): [True: 176, False: 1.44M]
  ------------------
 3345|    176|        return FallbackGlyph;
 3346|  1.44M|    const ImWchar i = IndexLookup.Data[c];
 3347|  1.44M|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3347:9): [True: 21, False: 1.44M]
  ------------------
 3348|     21|        return FallbackGlyph;
 3349|  1.44M|    return &Glyphs.Data[i];
 3350|  1.44M|}
_ZNK6ImFont19FindGlyphNoFallbackEt:
 3353|      5|{
 3354|      5|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3354:9): [True: 2, False: 3]
  ------------------
 3355|      2|        return NULL;
 3356|      3|    const ImWchar i = IndexLookup.Data[c];
 3357|      3|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3357:9): [True: 0, False: 3]
  ------------------
 3358|      0|        return NULL;
 3359|      3|    return &Glyphs.Data[i];
 3360|      3|}
_ZNK6ImFont13CalcTextSizeAEfffPKcS1_PS1_:
 3474|   184k|{
 3475|   184k|    if (!text_end)
  ------------------
  |  Branch (3475:9): [True: 4.20k, False: 180k]
  ------------------
 3476|  4.20k|        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.
 3477|       |
 3478|   184k|    const float line_height = size;
 3479|   184k|    const float scale = size / FontSize;
 3480|       |
 3481|   184k|    ImVec2 text_size = ImVec2(0, 0);
 3482|   184k|    float line_width = 0.0f;
 3483|       |
 3484|   184k|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 3485|   184k|    const char* word_wrap_eol = NULL;
 3486|       |
 3487|   184k|    const char* s = text_begin;
 3488|  1.63M|    while (s < text_end)
  ------------------
  |  Branch (3488:12): [True: 1.45M, False: 184k]
  ------------------
 3489|  1.45M|    {
 3490|  1.45M|        if (word_wrap_enabled)
  ------------------
  |  Branch (3490:13): [True: 0, False: 1.45M]
  ------------------
 3491|      0|        {
 3492|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 3493|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (3493:17): [True: 0, False: 0]
  ------------------
 3494|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
 3495|       |
 3496|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (3496:17): [True: 0, False: 0]
  ------------------
 3497|      0|            {
 3498|      0|                if (text_size.x < line_width)
  ------------------
  |  Branch (3498:21): [True: 0, False: 0]
  ------------------
 3499|      0|                    text_size.x = line_width;
 3500|      0|                text_size.y += line_height;
 3501|      0|                line_width = 0.0f;
 3502|      0|                word_wrap_eol = NULL;
 3503|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 3504|      0|                continue;
 3505|      0|            }
 3506|      0|        }
 3507|       |
 3508|       |        // Decode and advance source
 3509|  1.45M|        const char* prev_s = s;
 3510|  1.45M|        unsigned int c = (unsigned int)*s;
 3511|  1.45M|        if (c < 0x80)
  ------------------
  |  Branch (3511:13): [True: 1.44M, False: 655]
  ------------------
 3512|  1.44M|            s += 1;
 3513|    655|        else
 3514|    655|            s += ImTextCharFromUtf8(&c, s, text_end);
 3515|       |
 3516|  1.45M|        if (c < 32)
  ------------------
  |  Branch (3516:13): [True: 58, False: 1.45M]
  ------------------
 3517|     58|        {
 3518|     58|            if (c == '\n')
  ------------------
  |  Branch (3518:17): [True: 0, False: 58]
  ------------------
 3519|      0|            {
 3520|      0|                text_size.x = ImMax(text_size.x, line_width);
 3521|      0|                text_size.y += line_height;
 3522|      0|                line_width = 0.0f;
 3523|      0|                continue;
 3524|      0|            }
 3525|     58|            if (c == '\r')
  ------------------
  |  Branch (3525:17): [True: 0, False: 58]
  ------------------
 3526|      0|                continue;
 3527|     58|        }
 3528|       |
 3529|  1.45M|        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
  ------------------
  |  Branch (3529:35): [True: 1.44M, False: 633]
  ------------------
 3530|  1.45M|        if (line_width + char_width >= max_width)
  ------------------
  |  Branch (3530:13): [True: 0, False: 1.45M]
  ------------------
 3531|      0|        {
 3532|      0|            s = prev_s;
 3533|      0|            break;
 3534|      0|        }
 3535|       |
 3536|  1.45M|        line_width += char_width;
 3537|  1.45M|    }
 3538|       |
 3539|   184k|    if (text_size.x < line_width)
  ------------------
  |  Branch (3539:9): [True: 184k, False: 0]
  ------------------
 3540|   184k|        text_size.x = line_width;
 3541|       |
 3542|   184k|    if (line_width > 0 || text_size.y == 0.0f)
  ------------------
  |  Branch (3542:9): [True: 184k, False: 0]
  |  Branch (3542:27): [True: 0, False: 0]
  ------------------
 3543|   184k|        text_size.y += line_height;
 3544|       |
 3545|   184k|    if (remaining)
  ------------------
  |  Branch (3545:9): [True: 0, False: 184k]
  ------------------
 3546|      0|        *remaining = s;
 3547|       |
 3548|   184k|    return text_size;
 3549|   184k|}
_ZNK6ImFont10RenderTextEP10ImDrawListfRK6ImVec2jRK6ImVec4PKcS9_fb:
 3568|   181k|{
 3569|   181k|    if (!text_end)
  ------------------
  |  Branch (3569:9): [True: 0, False: 181k]
  ------------------
 3570|      0|        text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.
 3571|       |
 3572|       |    // Align to be pixel perfect
 3573|   181k|    float x = IM_FLOOR(pos.x);
  ------------------
  |  |  269|   181k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 3574|   181k|    float y = IM_FLOOR(pos.y);
  ------------------
  |  |  269|   181k|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
 3575|   181k|    if (y > clip_rect.w)
  ------------------
  |  Branch (3575:9): [True: 777, False: 180k]
  ------------------
 3576|    777|        return;
 3577|       |
 3578|   180k|    const float start_x = x;
 3579|   180k|    const float scale = size / FontSize;
 3580|   180k|    const float line_height = FontSize * scale;
 3581|   180k|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 3582|       |
 3583|       |    // Fast-forward to first visible line
 3584|   180k|    const char* s = text_begin;
 3585|   180k|    if (y + line_height < clip_rect.y)
  ------------------
  |  Branch (3585:9): [True: 0, False: 180k]
  ------------------
 3586|      0|        while (y + line_height < clip_rect.y && s < text_end)
  ------------------
  |  Branch (3586:16): [True: 0, False: 0]
  |  Branch (3586:49): [True: 0, False: 0]
  ------------------
 3587|      0|        {
 3588|      0|            const char* line_end = (const char*)memchr(s, '\n', text_end - s);
 3589|      0|            if (word_wrap_enabled)
  ------------------
  |  Branch (3589:17): [True: 0, False: 0]
  ------------------
 3590|      0|            {
 3591|       |                // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
 3592|       |                // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
 3593|       |                // However it is still better than nothing performing the fast-forward!
 3594|      0|                s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);
  ------------------
  |  Branch (3594:53): [True: 0, False: 0]
  ------------------
 3595|      0|                s = CalcWordWrapNextLineStartA(s, text_end);
 3596|      0|            }
 3597|      0|            else
 3598|      0|            {
 3599|      0|                s = line_end ? line_end + 1 : text_end;
  ------------------
  |  Branch (3599:21): [True: 0, False: 0]
  ------------------
 3600|      0|            }
 3601|      0|            y += line_height;
 3602|      0|        }
 3603|       |
 3604|       |    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
 3605|       |    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
 3606|   180k|    if (text_end - s > 10000 && !word_wrap_enabled)
  ------------------
  |  Branch (3606:9): [True: 0, False: 180k]
  |  Branch (3606:33): [True: 0, False: 0]
  ------------------
 3607|      0|    {
 3608|      0|        const char* s_end = s;
 3609|      0|        float y_end = y;
 3610|      0|        while (y_end < clip_rect.w && s_end < text_end)
  ------------------
  |  Branch (3610:16): [True: 0, False: 0]
  |  Branch (3610:39): [True: 0, False: 0]
  ------------------
 3611|      0|        {
 3612|      0|            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
 3613|      0|            s_end = s_end ? s_end + 1 : text_end;
  ------------------
  |  Branch (3613:21): [True: 0, False: 0]
  ------------------
 3614|      0|            y_end += line_height;
 3615|      0|        }
 3616|      0|        text_end = s_end;
 3617|      0|    }
 3618|   180k|    if (s == text_end)
  ------------------
  |  Branch (3618:9): [True: 0, False: 180k]
  ------------------
 3619|      0|        return;
 3620|       |
 3621|       |    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
 3622|   180k|    const int vtx_count_max = (int)(text_end - s) * 4;
 3623|   180k|    const int idx_count_max = (int)(text_end - s) * 6;
 3624|   180k|    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
 3625|   180k|    draw_list->PrimReserve(idx_count_max, vtx_count_max);
 3626|   180k|    ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;
 3627|   180k|    ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
 3628|   180k|    unsigned int vtx_index = draw_list->_VtxCurrentIdx;
 3629|       |
 3630|   180k|    const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
  ------------------
  |  | 2450|   180k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 3631|   180k|    const char* word_wrap_eol = NULL;
 3632|       |
 3633|  1.62M|    while (s < text_end)
  ------------------
  |  Branch (3633:12): [True: 1.44M, False: 180k]
  ------------------
 3634|  1.44M|    {
 3635|  1.44M|        if (word_wrap_enabled)
  ------------------
  |  Branch (3635:13): [True: 0, False: 1.44M]
  ------------------
 3636|      0|        {
 3637|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 3638|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (3638:17): [True: 0, False: 0]
  ------------------
 3639|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));
 3640|       |
 3641|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (3641:17): [True: 0, False: 0]
  ------------------
 3642|      0|            {
 3643|      0|                x = start_x;
 3644|      0|                y += line_height;
 3645|      0|                word_wrap_eol = NULL;
 3646|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 3647|      0|                continue;
 3648|      0|            }
 3649|      0|        }
 3650|       |
 3651|       |        // Decode and advance source
 3652|  1.44M|        unsigned int c = (unsigned int)*s;
 3653|  1.44M|        if (c < 0x80)
  ------------------
  |  Branch (3653:13): [True: 1.44M, False: 190]
  ------------------
 3654|  1.44M|            s += 1;
 3655|    190|        else
 3656|    190|            s += ImTextCharFromUtf8(&c, s, text_end);
 3657|       |
 3658|  1.44M|        if (c < 32)
  ------------------
  |  Branch (3658:13): [True: 21, False: 1.44M]
  ------------------
 3659|     21|        {
 3660|     21|            if (c == '\n')
  ------------------
  |  Branch (3660:17): [True: 0, False: 21]
  ------------------
 3661|      0|            {
 3662|      0|                x = start_x;
 3663|      0|                y += line_height;
 3664|      0|                if (y > clip_rect.w)
  ------------------
  |  Branch (3664:21): [True: 0, False: 0]
  ------------------
 3665|      0|                    break; // break out of main loop
 3666|      0|                continue;
 3667|      0|            }
 3668|     21|            if (c == '\r')
  ------------------
  |  Branch (3668:17): [True: 0, False: 21]
  ------------------
 3669|      0|                continue;
 3670|     21|        }
 3671|       |
 3672|  1.44M|        const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
 3673|  1.44M|        if (glyph == NULL)
  ------------------
  |  Branch (3673:13): [True: 0, False: 1.44M]
  ------------------
 3674|      0|            continue;
 3675|       |
 3676|  1.44M|        float char_width = glyph->AdvanceX * scale;
 3677|  1.44M|        if (glyph->Visible)
  ------------------
  |  Branch (3677:13): [True: 1.35M, False: 90.6k]
  ------------------
 3678|  1.35M|        {
 3679|       |            // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
 3680|  1.35M|            float x1 = x + glyph->X0 * scale;
 3681|  1.35M|            float x2 = x + glyph->X1 * scale;
 3682|  1.35M|            float y1 = y + glyph->Y0 * scale;
 3683|  1.35M|            float y2 = y + glyph->Y1 * scale;
 3684|  1.35M|            if (x1 <= clip_rect.z && x2 >= clip_rect.x)
  ------------------
  |  Branch (3684:17): [True: 632k, False: 722k]
  |  Branch (3684:38): [True: 631k, False: 364]
  ------------------
 3685|   631k|            {
 3686|       |                // Render a character
 3687|   631k|                float u1 = glyph->U0;
 3688|   631k|                float v1 = glyph->V0;
 3689|   631k|                float u2 = glyph->U1;
 3690|   631k|                float v2 = glyph->V1;
 3691|       |
 3692|       |                // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
 3693|   631k|                if (cpu_fine_clip)
  ------------------
  |  Branch (3693:21): [True: 180k, False: 451k]
  ------------------
 3694|   180k|                {
 3695|   180k|                    if (x1 < clip_rect.x)
  ------------------
  |  Branch (3695:25): [True: 0, False: 180k]
  ------------------
 3696|      0|                    {
 3697|      0|                        u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
 3698|      0|                        x1 = clip_rect.x;
 3699|      0|                    }
 3700|   180k|                    if (y1 < clip_rect.y)
  ------------------
  |  Branch (3700:25): [True: 564, False: 179k]
  ------------------
 3701|    564|                    {
 3702|    564|                        v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
 3703|    564|                        y1 = clip_rect.y;
 3704|    564|                    }
 3705|   180k|                    if (x2 > clip_rect.z)
  ------------------
  |  Branch (3705:25): [True: 90.2k, False: 90.2k]
  ------------------
 3706|  90.2k|                    {
 3707|  90.2k|                        u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
 3708|  90.2k|                        x2 = clip_rect.z;
 3709|  90.2k|                    }
 3710|   180k|                    if (y2 > clip_rect.w)
  ------------------
  |  Branch (3710:25): [True: 0, False: 180k]
  ------------------
 3711|      0|                    {
 3712|      0|                        v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
 3713|      0|                        y2 = clip_rect.w;
 3714|      0|                    }
 3715|   180k|                    if (y1 >= y2)
  ------------------
  |  Branch (3715:25): [True: 564, False: 179k]
  ------------------
 3716|    564|                    {
 3717|    564|                        x += char_width;
 3718|    564|                        continue;
 3719|    564|                    }
 3720|   180k|                }
 3721|       |
 3722|       |                // Support for untinted glyphs
 3723|   631k|                ImU32 glyph_col = glyph->Colored ? col_untinted : col;
  ------------------
  |  Branch (3723:35): [True: 0, False: 631k]
  ------------------
 3724|       |
 3725|       |                // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
 3726|   631k|                {
 3727|   631k|                    vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
 3728|   631k|                    vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
 3729|   631k|                    vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
 3730|   631k|                    vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
 3731|   631k|                    idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);
 3732|   631k|                    idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
 3733|   631k|                    vtx_write += 4;
 3734|   631k|                    vtx_index += 4;
 3735|   631k|                    idx_write += 6;
 3736|   631k|                }
 3737|   631k|            }
 3738|  1.35M|        }
 3739|  1.44M|        x += char_width;
 3740|  1.44M|    }
 3741|       |
 3742|       |    // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
 3743|   180k|    draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
 3744|   180k|    draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
 3745|   180k|    draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
 3746|   180k|    draw_list->_VtxWritePtr = vtx_write;
 3747|   180k|    draw_list->_IdxWritePtr = idx_write;
 3748|   180k|    draw_list->_VtxCurrentIdx = vtx_index;
 3749|   180k|}
_ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2jif:
 3769|   180k|{
 3770|   180k|    const float h = draw_list->_Data->FontSize * 1.00f;
 3771|   180k|    float r = h * 0.40f * scale;
 3772|   180k|    ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
 3773|       |
 3774|   180k|    ImVec2 a, b, c;
 3775|   180k|    switch (dir)
  ------------------
  |  Branch (3775:13): [True: 0, False: 180k]
  ------------------
 3776|   180k|    {
 3777|      0|    case ImGuiDir_Up:
  ------------------
  |  Branch (3777:5): [True: 0, False: 180k]
  ------------------
 3778|  90.5k|    case ImGuiDir_Down:
  ------------------
  |  Branch (3778:5): [True: 90.5k, False: 89.9k]
  ------------------
 3779|  90.5k|        if (dir == ImGuiDir_Up) r = -r;
  ------------------
  |  Branch (3779:13): [True: 0, False: 90.5k]
  ------------------
 3780|  90.5k|        a = ImVec2(+0.000f, +0.750f) * r;
 3781|  90.5k|        b = ImVec2(-0.866f, -0.750f) * r;
 3782|  90.5k|        c = ImVec2(+0.866f, -0.750f) * r;
 3783|  90.5k|        break;
 3784|      0|    case ImGuiDir_Left:
  ------------------
  |  Branch (3784:5): [True: 0, False: 180k]
  ------------------
 3785|  89.9k|    case ImGuiDir_Right:
  ------------------
  |  Branch (3785:5): [True: 89.9k, False: 90.5k]
  ------------------
 3786|  89.9k|        if (dir == ImGuiDir_Left) r = -r;
  ------------------
  |  Branch (3786:13): [True: 0, False: 89.9k]
  ------------------
 3787|  89.9k|        a = ImVec2(+0.750f, +0.000f) * r;
 3788|  89.9k|        b = ImVec2(-0.750f, +0.866f) * r;
 3789|  89.9k|        c = ImVec2(-0.750f, -0.866f) * r;
 3790|  89.9k|        break;
 3791|      0|    case ImGuiDir_None:
  ------------------
  |  Branch (3791:5): [True: 0, False: 180k]
  ------------------
 3792|      0|    case ImGuiDir_COUNT:
  ------------------
  |  Branch (3792:5): [True: 0, False: 180k]
  ------------------
 3793|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3794|      0|        break;
 3795|   180k|    }
 3796|   180k|    draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
 3797|   180k|}
imgui_draw.cpp:_ZL18FixRectCornerFlagsi:
 1323|   181k|{
 1324|       |#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
 1325|       |    // Obsoleted in 1.82 (from February 2021)
 1326|       |    // Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
 1327|       |    //   ~0   --> ImDrawFlags_RoundCornersAll or 0
 1328|       |    if (flags == ~0)
 1329|       |        return ImDrawFlags_RoundCornersAll;
 1330|       |
 1331|       |    // Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations)
 1332|       |    //   0x01 --> ImDrawFlags_RoundCornersTopLeft (VALUE 0x01 OVERLAPS ImDrawFlags_Closed but ImDrawFlags_Closed is never valid in this path!)
 1333|       |    //   0x02 --> ImDrawFlags_RoundCornersTopRight
 1334|       |    //   0x03 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight
 1335|       |    //   0x04 --> ImDrawFlags_RoundCornersBotLeft
 1336|       |    //   0x05 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBotLeft
 1337|       |    //   ...
 1338|       |    //   0x0F --> ImDrawFlags_RoundCornersAll or 0
 1339|       |    // (See all values in ImDrawCornerFlags_)
 1340|       |    if (flags >= 0x01 && flags <= 0x0F)
 1341|       |        return (flags << 4);
 1342|       |
 1343|       |    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
 1344|       |#endif
 1345|       |
 1346|       |    // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
 1347|       |    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
 1348|   181k|    IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");
  ------------------
  |  |   23|   181k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1349|       |
 1350|   181k|    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
  ------------------
  |  Branch (1350:9): [True: 181k, False: 0]
  ------------------
 1351|   181k|        flags |= ImDrawFlags_RoundCornersAll;
 1352|       |
 1353|   181k|    return flags;
 1354|   181k|}
imgui_draw.cpp:_ZL8Decode85PKhPh:
 2112|      1|{
 2113|  2.39k|    while (*src)
  ------------------
  |  Branch (2113:12): [True: 2.39k, False: 1]
  ------------------
 2114|  2.39k|    {
 2115|  2.39k|        unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
 2116|  2.39k|        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
 2117|  2.39k|        src += 5;
 2118|  2.39k|        dst += 4;
 2119|  2.39k|    }
 2120|      1|}
imgui_draw.cpp:_ZL12Decode85Bytec:
 2110|  11.9k|static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
  ------------------
  |  Branch (2110:86): [True: 3.28k, False: 8.70k]
  ------------------
imgui_draw.cpp:_ZL31ImFontAtlasBuildWithStbTruetypeP11ImFontAtlas:
 2346|      1|{
 2347|      1|    IM_ASSERT(atlas->ConfigData.Size > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2348|       |
 2349|      1|    ImFontAtlasBuildInit(atlas);
 2350|       |
 2351|       |    // Clear atlas
 2352|      1|    atlas->TexID = (ImTextureID)NULL;
 2353|      1|    atlas->TexWidth = atlas->TexHeight = 0;
 2354|      1|    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
 2355|      1|    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
 2356|      1|    atlas->ClearTexData();
 2357|       |
 2358|       |    // Temporary storage for building
 2359|      1|    ImVector<ImFontBuildSrcData> src_tmp_array;
 2360|      1|    ImVector<ImFontBuildDstData> dst_tmp_array;
 2361|      1|    src_tmp_array.resize(atlas->ConfigData.Size);
 2362|      1|    dst_tmp_array.resize(atlas->Fonts.Size);
 2363|      1|    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
 2364|      1|    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());
 2365|       |
 2366|       |    // 1. Initialize font loading structure, check font data validity
 2367|      2|    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
  ------------------
  |  Branch (2367:25): [True: 1, False: 1]
  ------------------
 2368|      1|    {
 2369|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2370|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2371|      1|        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2372|       |
 2373|       |        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
 2374|      1|        src_tmp.DstIndex = -1;
 2375|      2|        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
  ------------------
  |  Branch (2375:32): [True: 1, False: 1]
  |  Branch (2375:64): [True: 1, False: 0]
  ------------------
 2376|      1|            if (cfg.DstFont == atlas->Fonts[output_i])
  ------------------
  |  Branch (2376:17): [True: 1, False: 0]
  ------------------
 2377|      1|                src_tmp.DstIndex = output_i;
 2378|      1|        if (src_tmp.DstIndex == -1)
  ------------------
  |  Branch (2378:13): [True: 0, False: 1]
  ------------------
 2379|      0|        {
 2380|      0|            IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2381|      0|            return false;
 2382|      0|        }
 2383|       |        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
 2384|      1|        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
 2385|      1|        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2386|      1|        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
  ------------------
  |  Branch (2386:13): [True: 0, False: 1]
  ------------------
 2387|      0|            return false;
 2388|       |
 2389|       |        // Measure highest codepoints
 2390|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2391|      1|        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
  ------------------
  |  Branch (2391:29): [True: 1, False: 0]
  ------------------
 2392|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2392:60): [True: 1, False: 1]
  |  Branch (2392:76): [True: 1, False: 0]
  ------------------
 2393|      1|        {
 2394|       |            // Check for valid range. This may also help detect *some* dangling pointers, because a common
 2395|       |            // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent.
 2396|      1|            IM_ASSERT(src_range[0] <= src_range[1]);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2397|      1|            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
 2398|      1|        }
 2399|      1|        dst_tmp.SrcCount++;
 2400|      1|        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
 2401|      1|    }
 2402|       |
 2403|       |    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
 2404|      1|    int total_glyphs_count = 0;
 2405|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2405:25): [True: 1, False: 1]
  ------------------
 2406|      1|    {
 2407|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2408|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2409|      1|        src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
 2410|      1|        if (dst_tmp.GlyphsSet.Storage.empty())
  ------------------
  |  Branch (2410:13): [True: 1, False: 0]
  ------------------
 2411|      1|            dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);
 2412|       |
 2413|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2413:60): [True: 1, False: 1]
  |  Branch (2413:76): [True: 1, False: 0]
  ------------------
 2414|    225|            for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
  ------------------
  |  Branch (2414:57): [True: 224, False: 1]
  ------------------
 2415|    224|            {
 2416|    224|                if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
  ------------------
  |  Branch (2416:21): [True: 0, False: 224]
  ------------------
 2417|      0|                    continue;
 2418|    224|                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
  ------------------
  |  Branch (2418:21): [True: 1, False: 223]
  ------------------
 2419|      1|                    continue;
 2420|       |
 2421|       |                // Add to avail set/counters
 2422|    223|                src_tmp.GlyphsCount++;
 2423|    223|                dst_tmp.GlyphsCount++;
 2424|    223|                src_tmp.GlyphsSet.SetBit(codepoint);
 2425|    223|                dst_tmp.GlyphsSet.SetBit(codepoint);
 2426|    223|                total_glyphs_count++;
 2427|    223|            }
 2428|      1|    }
 2429|       |
 2430|       |    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
 2431|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2431:25): [True: 1, False: 1]
  ------------------
 2432|      1|    {
 2433|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2434|      1|        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
 2435|      1|        UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
 2436|      1|        src_tmp.GlyphsSet.Clear();
 2437|      1|        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2438|      1|    }
 2439|      2|    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
  ------------------
  |  Branch (2439:25): [True: 1, False: 1]
  ------------------
 2440|      1|        dst_tmp_array[dst_i].GlyphsSet.Clear();
 2441|      1|    dst_tmp_array.clear();
 2442|       |
 2443|       |    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
 2444|       |    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
 2445|      1|    ImVector<stbrp_rect> buf_rects;
 2446|      1|    ImVector<stbtt_packedchar> buf_packedchars;
 2447|      1|    buf_rects.resize(total_glyphs_count);
 2448|      1|    buf_packedchars.resize(total_glyphs_count);
 2449|      1|    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
 2450|      1|    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());
 2451|       |
 2452|       |    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
 2453|      1|    int total_surface = 0;
 2454|      1|    int buf_rects_out_n = 0;
 2455|      1|    int buf_packedchars_out_n = 0;
 2456|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2456:25): [True: 1, False: 1]
  ------------------
 2457|      1|    {
 2458|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2459|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2459:13): [True: 0, False: 1]
  ------------------
 2460|      0|            continue;
 2461|       |
 2462|      1|        src_tmp.Rects = &buf_rects[buf_rects_out_n];
 2463|      1|        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
 2464|      1|        buf_rects_out_n += src_tmp.GlyphsCount;
 2465|      1|        buf_packedchars_out_n += src_tmp.GlyphsCount;
 2466|       |
 2467|       |        // Convert our ranges in the format stb_truetype wants
 2468|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2469|      1|        src_tmp.PackRange.font_size = cfg.SizePixels;
 2470|      1|        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
 2471|      1|        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
 2472|      1|        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
 2473|      1|        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
 2474|      1|        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
 2475|      1|        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;
 2476|       |
 2477|       |        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
 2478|      1|        const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);
  ------------------
  |  Branch (2478:29): [True: 1, False: 0]
  ------------------
 2479|      1|        const int padding = atlas->TexGlyphPadding;
 2480|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
  ------------------
  |  Branch (2480:31): [True: 223, False: 1]
  ------------------
 2481|    223|        {
 2482|    223|            int x0, y0, x1, y1;
 2483|    223|            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
 2484|    223|            IM_ASSERT(glyph_index_in_font != 0);
  ------------------
  |  |   23|    223|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2485|    223|            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
 2486|    223|            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
 2487|    223|            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
 2488|    223|            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
 2489|    223|        }
 2490|      1|    }
 2491|       |
 2492|       |    // We need a width for the skyline algorithm, any width!
 2493|       |    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
 2494|       |    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
 2495|      1|    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
  ------------------
  |  |  437|      1|#define ImSqrt(X)           sqrtf(X)
  ------------------
 2496|      1|    atlas->TexHeight = 0;
 2497|      1|    if (atlas->TexDesiredWidth > 0)
  ------------------
  |  Branch (2497:9): [True: 0, False: 1]
  ------------------
 2498|      0|        atlas->TexWidth = atlas->TexDesiredWidth;
 2499|      1|    else
 2500|      1|        atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;
  ------------------
  |  Branch (2500:27): [True: 0, False: 1]
  |  Branch (2500:66): [True: 0, False: 1]
  |  Branch (2500:105): [True: 0, False: 1]
  ------------------
 2501|       |
 2502|       |    // 5. Start packing
 2503|       |    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
 2504|      1|    const int TEX_HEIGHT_MAX = 1024 * 32;
 2505|      1|    stbtt_pack_context spc = {};
 2506|      1|    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
 2507|      1|    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);
 2508|       |
 2509|       |    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
 2510|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2510:25): [True: 1, False: 1]
  ------------------
 2511|      1|    {
 2512|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2513|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2513:13): [True: 0, False: 1]
  ------------------
 2514|      0|            continue;
 2515|       |
 2516|      1|        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);
 2517|       |
 2518|       |        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
 2519|       |        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
 2520|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (2520:31): [True: 223, False: 1]
  ------------------
 2521|    223|            if (src_tmp.Rects[glyph_i].was_packed)
  ------------------
  |  Branch (2521:17): [True: 223, False: 0]
  ------------------
 2522|    223|                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
 2523|      1|    }
 2524|       |
 2525|       |    // 7. Allocate texture
 2526|      1|    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
  ------------------
  |  Branch (2526:24): [True: 0, False: 1]
  ------------------
 2527|      1|    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
 2528|      1|    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
  ------------------
  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2529|      1|    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
 2530|      1|    spc.pixels = atlas->TexPixelsAlpha8;
 2531|      1|    spc.height = atlas->TexHeight;
 2532|       |
 2533|       |    // 8. Render/rasterize font characters into the texture
 2534|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2534:25): [True: 1, False: 1]
  ------------------
 2535|      1|    {
 2536|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2537|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2538|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2538:13): [True: 0, False: 1]
  ------------------
 2539|      0|            continue;
 2540|       |
 2541|      1|        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);
 2542|       |
 2543|       |        // Apply multiply operator
 2544|      1|        if (cfg.RasterizerMultiply != 1.0f)
  ------------------
  |  Branch (2544:13): [True: 0, False: 1]
  ------------------
 2545|      0|        {
 2546|      0|            unsigned char multiply_table[256];
 2547|      0|            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
 2548|      0|            stbrp_rect* r = &src_tmp.Rects[0];
 2549|      0|            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
  ------------------
  |  Branch (2549:35): [True: 0, False: 0]
  ------------------
 2550|      0|                if (r->was_packed)
  ------------------
  |  Branch (2550:21): [True: 0, False: 0]
  ------------------
 2551|      0|                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
 2552|      0|        }
 2553|      1|        src_tmp.Rects = NULL;
 2554|      1|    }
 2555|       |
 2556|       |    // End packing
 2557|      1|    stbtt_PackEnd(&spc);
 2558|      1|    buf_rects.clear();
 2559|       |
 2560|       |    // 9. Setup ImFont and glyphs for runtime
 2561|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2561:25): [True: 1, False: 1]
  ------------------
 2562|      1|    {
 2563|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2564|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2564:13): [True: 0, False: 1]
  ------------------
 2565|      0|            continue;
 2566|       |
 2567|       |        // When merging fonts with MergeMode=true:
 2568|       |        // - We can have multiple input fonts writing into a same destination font.
 2569|       |        // - dst_font->ConfigData is != from cfg which is our source configuration.
 2570|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2571|      1|        ImFont* dst_font = cfg.DstFont;
 2572|       |
 2573|      1|        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
 2574|      1|        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
 2575|      1|        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
 2576|       |
 2577|      1|        const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));
  ------------------
  |  Branch (2577:70): [True: 1, False: 0]
  ------------------
 2578|      1|        const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));
  ------------------
  |  Branch (2578:72): [True: 0, False: 1]
  ------------------
 2579|      1|        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
 2580|      1|        const float font_off_x = cfg.GlyphOffset.x;
 2581|      1|        const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);
  ------------------
  |  |  270|      1|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 2582|       |
 2583|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (2583:31): [True: 223, False: 1]
  ------------------
 2584|    223|        {
 2585|       |            // Register glyph
 2586|    223|            const int codepoint = src_tmp.GlyphsList[glyph_i];
 2587|    223|            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
 2588|    223|            stbtt_aligned_quad q;
 2589|    223|            float unused_x = 0.0f, unused_y = 0.0f;
 2590|    223|            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
 2591|    223|            dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);
 2592|    223|        }
 2593|      1|    }
 2594|       |
 2595|       |    // Cleanup
 2596|      1|    src_tmp_array.clear_destruct();
 2597|       |
 2598|      1|    ImFontAtlasBuildFinish(atlas);
 2599|      1|    return true;
 2600|      1|}
imgui_draw.cpp:_ZL30UnpackBitVectorToFlatIndexListPK11ImBitVectorP8ImVectorIiE:
 2334|      1|{
 2335|      1|    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2336|      1|    const ImU32* it_begin = in->Storage.begin();
 2337|      1|    const ImU32* it_end = in->Storage.end();
 2338|      9|    for (const ImU32* it = it_begin; it < it_end; it++)
  ------------------
  |  Branch (2338:38): [True: 8, False: 1]
  ------------------
 2339|      8|        if (ImU32 entries_32 = *it)
  ------------------
  |  Branch (2339:19): [True: 7, False: 1]
  ------------------
 2340|    231|            for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
  ------------------
  |  Branch (2340:35): [True: 224, False: 7]
  ------------------
 2341|    224|                if (entries_32 & ((ImU32)1 << bit_n))
  ------------------
  |  Branch (2341:21): [True: 223, False: 1]
  ------------------
 2342|    223|                    out->push_back((int)(((it - it_begin) << 5) + bit_n));
 2343|      1|}
imgui_draw.cpp:_ZL36ImFontAtlasBuildRenderDefaultTexDataP11ImFontAtlas:
 2674|      1|{
 2675|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
 2676|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2677|       |
 2678|      1|    const int w = atlas->TexWidth;
 2679|      1|    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (2679:9): [True: 1, False: 0]
  ------------------
 2680|      1|    {
 2681|       |        // Render/copy pixels
 2682|      1|        IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2683|      1|        const int x_for_white = r->X;
 2684|      1|        const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
 2685|      1|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2685:13): [True: 1, False: 0]
  ------------------
 2686|      1|        {
 2687|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
 2688|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
 2689|      1|        }
 2690|      0|        else
 2691|      0|        {
 2692|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
  ------------------
  |  | 2454|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2693|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
  ------------------
  |  | 2454|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2694|      0|        }
 2695|      1|    }
 2696|      0|    else
 2697|      0|    {
 2698|       |        // Render 4 white pixels
 2699|      0|        IM_ASSERT(r->Width == 2 && r->Height == 2);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2700|      0|        const int offset = (int)r->X + (int)r->Y * w;
 2701|      0|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2701:13): [True: 0, False: 0]
  ------------------
 2702|      0|        {
 2703|      0|            atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
 2704|      0|        }
 2705|      0|        else
 2706|      0|        {
 2707|      0|            atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
  ------------------
  |  | 2454|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2708|      0|        }
 2709|      0|    }
 2710|      1|    atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
 2711|      1|}
imgui_draw.cpp:_ZL34ImFontAtlasBuildRenderLinesTexDataP11ImFontAtlas:
 2714|      1|{
 2715|      1|    if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
  ------------------
  |  Branch (2715:9): [True: 0, False: 1]
  ------------------
 2716|      0|        return;
 2717|       |
 2718|       |    // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
 2719|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
 2720|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2721|     65|    for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
  ------------------
  |  | 2486|     65|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (2721:30): [True: 64, False: 1]
  ------------------
 2722|     64|    {
 2723|       |        // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
 2724|     64|        unsigned int y = n;
 2725|     64|        unsigned int line_width = n;
 2726|     64|        unsigned int pad_left = (r->Width - line_width) / 2;
 2727|     64|        unsigned int pad_right = r->Width - (pad_left + line_width);
 2728|       |
 2729|       |        // Write each slice
 2730|     64|        IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
  ------------------
  |  |   23|     64|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2731|     64|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (2731:13): [True: 64, False: 0]
  ------------------
 2732|     64|        {
 2733|     64|            unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
 2734|  1.12k|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (2734:38): [True: 1.05k, False: 64]
  ------------------
 2735|  1.05k|                *(write_ptr + i) = 0x00;
 2736|       |
 2737|  2.08k|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (2737:38): [True: 2.01k, False: 64]
  ------------------
 2738|  2.01k|                *(write_ptr + pad_left + i) = 0xFF;
 2739|       |
 2740|  1.15k|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (2740:38): [True: 1.08k, False: 64]
  ------------------
 2741|  1.08k|                *(write_ptr + pad_left + line_width + i) = 0x00;
 2742|     64|        }
 2743|      0|        else
 2744|      0|        {
 2745|      0|            unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
 2746|      0|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (2746:38): [True: 0, False: 0]
  ------------------
 2747|      0|                *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2748|       |
 2749|      0|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (2749:38): [True: 0, False: 0]
  ------------------
 2750|      0|                *(write_ptr + pad_left + i) = IM_COL32_WHITE;
  ------------------
  |  | 2454|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2751|       |
 2752|      0|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (2752:38): [True: 0, False: 0]
  ------------------
 2753|      0|                *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2453|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2449|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2448|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2447|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2446|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2754|      0|        }
 2755|       |
 2756|       |        // Calculate UVs for this line
 2757|     64|        ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
 2758|     64|        ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
 2759|     64|        float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
 2760|     64|        atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
 2761|     64|    }
 2762|      1|}
imgui_draw.cpp:_ZL22FindFirstExistingGlyphP6ImFontPKti:
 3161|      2|{
 3162|      3|    for (int n = 0; n < candidate_chars_count; n++)
  ------------------
  |  Branch (3162:21): [True: 3, False: 0]
  ------------------
 3163|      3|        if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
  ------------------
  |  Branch (3163:13): [True: 2, False: 1]
  ------------------
 3164|      2|            return candidate_chars[n];
 3165|      0|    return (ImWchar)-1;
 3166|      2|}
imgui_draw.cpp:_ZL21stb_decompress_lengthPKh:
 3987|      2|{
 3988|      2|    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
 3989|      2|}
imgui_draw.cpp:_ZL14stb_decompressPhPKhj:
 4065|      1|{
 4066|      1|    if (stb__in4(0) != 0x57bC0000) return 0;
  ------------------
  |  | 4014|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4013|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4012|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4066:9): [True: 0, False: 1]
  ------------------
 4067|      1|    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
  ------------------
  |  | 4014|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4013|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4012|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4067:9): [True: 0, False: 1]
  ------------------
 4068|      1|    const unsigned int olen = stb_decompress_length(i);
 4069|      1|    stb__barrier_in_b = i;
 4070|      1|    stb__barrier_out_e = output + olen;
 4071|      1|    stb__barrier_out_b = output;
 4072|      1|    i += 16;
 4073|       |
 4074|      1|    stb__dout = output;
 4075|  2.98k|    for (;;) {
 4076|  2.98k|        const unsigned char *old_i = i;
 4077|  2.98k|        i = stb_decompress_token(i);
 4078|  2.98k|        if (i == old_i) {
  ------------------
  |  Branch (4078:13): [True: 1, False: 2.98k]
  ------------------
 4079|      1|            if (*i == 0x05 && i[1] == 0xfa) {
  ------------------
  |  Branch (4079:17): [True: 1, False: 0]
  |  Branch (4079:31): [True: 1, False: 0]
  ------------------
 4080|      1|                IM_ASSERT(stb__dout == output + olen);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4081|      1|                if (stb__dout != output + olen) return 0;
  ------------------
  |  Branch (4081:21): [True: 0, False: 1]
  ------------------
 4082|      1|                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
  ------------------
  |  | 4014|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4013|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4012|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4082:21): [True: 0, False: 1]
  ------------------
 4083|      0|                    return 0;
 4084|      1|                return olen;
 4085|      1|            } else {
 4086|      0|                IM_ASSERT(0); /* NOTREACHED */
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4087|      0|                return 0;
 4088|      0|            }
 4089|      1|        }
 4090|  2.98k|        IM_ASSERT(stb__dout <= output + olen);
  ------------------
  |  |   23|  2.98k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4091|  2.98k|        if (stb__dout > output + olen)
  ------------------
  |  Branch (4091:13): [True: 0, False: 2.98k]
  ------------------
 4092|      0|            return 0;
 4093|  2.98k|    }
 4094|      1|}
imgui_draw.cpp:_ZL20stb_decompress_tokenPKh:
 4017|  2.98k|{
 4018|  2.98k|    if (*i >= 0x20) { // use fewer if's for cases that expand small
  ------------------
  |  Branch (4018:9): [True: 2.86k, False: 119]
  ------------------
 4019|  2.86k|        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
  ------------------
  |  Branch (4019:13): [True: 818, False: 2.04k]
  ------------------
 4020|  2.04k|        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
  ------------------
  |  | 4012|  1.39k|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4020:18): [True: 1.39k, False: 653]
  ------------------
 4021|    653|        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
 4022|  2.86k|    } else { // more ifs for cases that expand large, since overhead is amortized
 4023|    119|        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
  ------------------
  |  | 4013|    111|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4012|    111|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4023:13): [True: 111, False: 8]
  ------------------
 4024|      8|        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4013|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4012|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4012|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4024:18): [True: 0, False: 8]
  ------------------
 4025|      8|        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4012|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4012|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4025:18): [True: 7, False: 1]
  ------------------
 4026|      1|        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4012|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4012|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4026:18): [True: 0, False: 1]
  ------------------
 4027|      1|        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
  ------------------
  |  | 4013|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4012|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4027:18): [True: 0, False: 1]
  ------------------
 4028|      1|        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4013|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4012|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4012|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4028:18): [True: 0, False: 1]
  ------------------
 4029|    119|    }
 4030|  2.98k|    return i;
 4031|  2.98k|}
imgui_draw.cpp:_ZL10stb__matchPKhj:
 3995|  2.32k|{
 3996|       |    // INVERSE of memmove... write each byte before copying the next...
 3997|  2.32k|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|  2.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3998|  2.32k|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (3998:9): [True: 0, False: 2.32k]
  ------------------
 3999|  2.32k|    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (3999:9): [True: 0, False: 2.32k]
  ------------------
 4000|  40.8k|    while (length--) *stb__dout++ = *data++;
  ------------------
  |  Branch (4000:12): [True: 38.5k, False: 2.32k]
  ------------------
 4001|  2.32k|}
imgui_draw.cpp:_ZL8stb__litPKhj:
 4004|    660|{
 4005|    660|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|    660|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4006|    660|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (4006:9): [True: 0, False: 660]
  ------------------
 4007|    660|    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (4007:9): [True: 0, False: 660]
  ------------------
 4008|    660|    memcpy(stb__dout, data, length);
 4009|    660|    stb__dout += length;
 4010|    660|}
imgui_draw.cpp:_ZL11stb_adler32jPhj:
 4034|      1|{
 4035|      1|    const unsigned long ADLER_MOD = 65521;
 4036|      1|    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
 4037|      1|    unsigned long blocklen = buflen % 5552;
 4038|       |
 4039|      1|    unsigned long i;
 4040|      9|    while (buflen) {
  ------------------
  |  Branch (4040:12): [True: 8, False: 1]
  ------------------
 4041|  5.15k|        for (i=0; i + 7 < blocklen; i += 8) {
  ------------------
  |  Branch (4041:19): [True: 5.15k, False: 8]
  ------------------
 4042|  5.15k|            s1 += buffer[0], s2 += s1;
 4043|  5.15k|            s1 += buffer[1], s2 += s1;
 4044|  5.15k|            s1 += buffer[2], s2 += s1;
 4045|  5.15k|            s1 += buffer[3], s2 += s1;
 4046|  5.15k|            s1 += buffer[4], s2 += s1;
 4047|  5.15k|            s1 += buffer[5], s2 += s1;
 4048|  5.15k|            s1 += buffer[6], s2 += s1;
 4049|  5.15k|            s1 += buffer[7], s2 += s1;
 4050|       |
 4051|  5.15k|            buffer += 8;
 4052|  5.15k|        }
 4053|       |
 4054|      8|        for (; i < blocklen; ++i)
  ------------------
  |  Branch (4054:16): [True: 0, False: 8]
  ------------------
 4055|      0|            s1 += *buffer++, s2 += s1;
 4056|       |
 4057|      8|        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
 4058|      8|        buflen -= blocklen;
 4059|      8|        blocklen = 5552;
 4060|      8|    }
 4061|      1|    return (unsigned int)(s2 << 16) + (unsigned int)s1;
 4062|      1|}
imgui_draw.cpp:_ZL37GetDefaultCompressedFontDataTTFBase85v:
 4197|      1|{
 4198|      1|    return proggy_clean_ttf_compressed_data_base85;
 4199|      1|}

imgui.cpp:_ZL7ImFloorRK6ImVec2:
  484|   181k|static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }
imgui.cpp:_ZmlRK6ImVec2f:
  392|   453k|static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui.cpp:_ZL7ImFloorf:
  482|  1.62M|static inline float  ImFloor(float f)                                           { return (float)(int)(f); }
_ZN15ImGuiInputEventC2Ev:
 1315|  38.5k|    ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }
_ZN5ImGui18IsNamedKeyOrModKeyE8ImGuiKey:
 3115|   211k|    inline bool             IsNamedKeyOrModKey(ImGuiKey key)                            { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super || key == ImGuiMod_Shortcut; }
  ------------------
  |  Branch (3115:99): [True: 211k, False: 0]
  |  Branch (3115:133): [True: 211k, False: 0]
  |  Branch (3115:165): [True: 0, False: 0]
  |  Branch (3115:189): [True: 0, False: 0]
  |  Branch (3115:214): [True: 0, False: 0]
  |  Branch (3115:237): [True: 0, False: 0]
  |  Branch (3115:262): [True: 0, False: 0]
  ------------------
_ZN5ImGui10IsAliasKeyE8ImGuiKey:
 3120|   643k|    inline bool             IsAliasKey(ImGuiKey key)                                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1252|  1.28M|#define ImGuiKey_Aliases_BEGIN          (ImGuiKey_Mouse_BEGIN)
  |  |  ------------------
  |  |  |  | 1250|   643k|#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)
  |  |  ------------------
  ------------------
                  inline bool             IsAliasKey(ImGuiKey key)                                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1253|   635k|#define ImGuiKey_Aliases_END            (ImGuiKey_Mouse_END)
  |  |  ------------------
  |  |  |  | 1251|   635k|#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)
  |  |  ------------------
  ------------------
  |  Branch (3120:98): [True: 635k, False: 7.46k]
  |  Branch (3120:131): [True: 631k, False: 4.27k]
  ------------------
_ZN5ImGui12IsGamepadKeyE8ImGuiKey:
 3118|  7.00k|    inline bool             IsGamepadKey(ImGuiKey key)                                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1248|  14.0k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                  inline bool             IsGamepadKey(ImGuiKey key)                                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1249|      0|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (3118:98): [True: 0, False: 7.00k]
  |  Branch (3118:131): [True: 0, False: 0]
  ------------------
_ZN5ImGui10IsNamedKeyE8ImGuiKey:
 3114|  2.39M|    inline bool             IsNamedKey(ImGuiKey key)                                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }
  ------------------
  |  Branch (3114:98): [True: 2.39M, False: 4]
  |  Branch (3114:132): [True: 2.39M, False: 1]
  ------------------
imgui.cpp:_ZL13ImFloorSignedf:
  483|  85.5k|static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (483:99): [True: 82.8k, False: 2.69k]
  |  Branch (483:109): [True: 2.23k, False: 456]
  ------------------
imgui.cpp:_ZL11ImLengthSqrRK6ImVec2:
  479|  45.9k|static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }
imgui.cpp:_ZmiRK6ImVec2S1_:
  395|  1.05M|static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui.cpp:_ZplRK6ImVec2S1_:
  394|  1.72M|static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui.cpp:_ZL10ImSaturatef:
  478|  4.86M|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (478:90): [True: 0, False: 4.86M]
  |  Branch (478:110): [True: 0, False: 4.86M]
  ------------------
imgui.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  336|  90.5k|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (336:147): [True: 0, False: 90.5k]
  ------------------
_ZN13ImGuiStyleModC2Ei6ImVec2:
 1017|  90.2k|    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
_ZN6ImRect8ClipWithERKS_:
  557|   362k|    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
imgui.cpp:_ZL5ImMinRK6ImVec2S1_:
  472|   362k|static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (472:97): [True: 362k, False: 80]
  |  Branch (472:128): [True: 362k, False: 228]
  ------------------
_ZN6ImRect6ExpandERK6ImVec2:
  553|  90.8k|    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
_ZNK6ImRect8ContainsERKS_:
  548|      4|    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
  ------------------
  |  Branch (548:62): [True: 4, False: 0]
  |  Branch (548:82): [True: 4, False: 0]
  |  Branch (548:102): [True: 4, False: 0]
  |  Branch (548:122): [True: 4, False: 0]
  ------------------
_ZNK14ImGuiViewportP11GetMainRectEv:
 1760|   371k|    ImRect  GetMainRect() const         { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK6ImRect8OverlapsERKS_:
  549|   192k|    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
  ------------------
  |  Branch (549:62): [True: 192k, False: 1]
  |  Branch (549:82): [True: 191k, False: 316]
  |  Branch (549:102): [True: 191k, False: 2]
  |  Branch (549:122): [True: 191k, False: 0]
  ------------------
_ZN6ImRectC2ERK6ImVec2S2_:
  534|  1.53M|    constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}
_ZN12ImGuiContextC2EP11ImFontAtlas:
 2217|      1|    {
 2218|      1|        Initialized = false;
 2219|      1|        ConfigFlagsCurrFrame = ConfigFlagsLastFrame = ImGuiConfigFlags_None;
 2220|      1|        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
  ------------------
  |  Branch (2220:35): [True: 0, False: 1]
  ------------------
 2221|      1|        Font = NULL;
 2222|      1|        FontSize = FontBaseSize = 0.0f;
 2223|      1|        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
  ------------------
  |  | 1823|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
  |  Branch (2223:20): [True: 0, False: 1]
  ------------------
 2224|      1|        Time = 0.0f;
 2225|      1|        FrameCount = 0;
 2226|      1|        FrameCountEnded = FrameCountPlatformEnded = FrameCountRendered = -1;
 2227|      1|        WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
 2228|      1|        GcCompactAll = false;
 2229|      1|        TestEngineHookItems = false;
 2230|      1|        TestEngine = NULL;
 2231|       |
 2232|      1|        WindowsActiveCount = 0;
 2233|      1|        CurrentWindow = NULL;
 2234|      1|        HoveredWindow = NULL;
 2235|      1|        HoveredWindowUnderMovingWindow = NULL;
 2236|      1|        MovingWindow = NULL;
 2237|      1|        WheelingWindow = NULL;
 2238|      1|        WheelingWindowStartFrame = -1;
 2239|      1|        WheelingWindowReleaseTimer = 0.0f;
 2240|       |
 2241|      1|        DebugHookIdInfo = 0;
 2242|      1|        HoveredId = HoveredIdPreviousFrame = 0;
 2243|      1|        HoveredIdAllowOverlap = false;
 2244|      1|        HoveredIdDisabled = false;
 2245|      1|        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
 2246|      1|        ActiveId = 0;
 2247|      1|        ActiveIdIsAlive = 0;
 2248|      1|        ActiveIdTimer = 0.0f;
 2249|      1|        ActiveIdIsJustActivated = false;
 2250|      1|        ActiveIdAllowOverlap = false;
 2251|      1|        ActiveIdNoClearOnFocusLoss = false;
 2252|      1|        ActiveIdHasBeenPressedBefore = false;
 2253|      1|        ActiveIdHasBeenEditedBefore = false;
 2254|      1|        ActiveIdHasBeenEditedThisFrame = false;
 2255|      1|        ActiveIdClickOffset = ImVec2(-1, -1);
 2256|      1|        ActiveIdWindow = NULL;
 2257|      1|        ActiveIdSource = ImGuiInputSource_None;
 2258|      1|        ActiveIdMouseButton = -1;
 2259|      1|        ActiveIdPreviousFrame = 0;
 2260|      1|        ActiveIdPreviousFrameIsAlive = false;
 2261|      1|        ActiveIdPreviousFrameHasBeenEditedBefore = false;
 2262|      1|        ActiveIdPreviousFrameWindow = NULL;
 2263|      1|        LastActiveId = 0;
 2264|      1|        LastActiveIdTimer = 0.0f;
 2265|       |
 2266|      1|        ActiveIdUsingNavDirMask = 0x00;
 2267|      1|        ActiveIdUsingAllKeyboardKeys = false;
 2268|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 2269|       |        ActiveIdUsingNavInputMask = 0x00;
 2270|       |#endif
 2271|       |
 2272|      1|        CurrentFocusScopeId = 0;
 2273|      1|        CurrentItemFlags = ImGuiItemFlags_None;
 2274|      1|        BeginMenuCount = 0;
 2275|       |
 2276|      1|        CurrentDpiScale = 0.0f;
 2277|      1|        CurrentViewport = NULL;
 2278|      1|        MouseViewport = MouseLastHoveredViewport = NULL;
 2279|      1|        PlatformLastFocusedViewportId = 0;
 2280|      1|        ViewportFrontMostStampCount = 0;
 2281|       |
 2282|      1|        NavWindow = NULL;
 2283|      1|        NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavActivateInputId = 0;
 2284|      1|        NavJustMovedToId = NavJustMovedToFocusScopeId = NavNextActivateId = 0;
 2285|      1|        NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
 2286|      1|        NavJustMovedToKeyMods = ImGuiMod_None;
 2287|      1|        NavInputSource = ImGuiInputSource_None;
 2288|      1|        NavLayer = ImGuiNavLayer_Main;
 2289|      1|        NavIdIsAlive = false;
 2290|      1|        NavMousePosDirty = false;
 2291|      1|        NavDisableHighlight = true;
 2292|      1|        NavDisableMouseHover = false;
 2293|      1|        NavAnyRequest = false;
 2294|      1|        NavInitRequest = false;
 2295|      1|        NavInitRequestFromMove = false;
 2296|      1|        NavInitResultId = 0;
 2297|      1|        NavMoveSubmitted = false;
 2298|      1|        NavMoveScoringItems = false;
 2299|      1|        NavMoveForwardToNextFrame = false;
 2300|      1|        NavMoveFlags = ImGuiNavMoveFlags_None;
 2301|      1|        NavMoveScrollFlags = ImGuiScrollFlags_None;
 2302|      1|        NavMoveKeyMods = ImGuiMod_None;
 2303|      1|        NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
 2304|      1|        NavScoringDebugCount = 0;
 2305|      1|        NavTabbingDir = 0;
 2306|      1|        NavTabbingCounter = 0;
 2307|       |
 2308|      1|        ConfigNavWindowingKeyNext = ImGuiMod_Ctrl | ImGuiKey_Tab;
 2309|      1|        ConfigNavWindowingKeyPrev = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab;
 2310|      1|        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
 2311|      1|        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
 2312|      1|        NavWindowingToggleLayer = false;
 2313|       |
 2314|      1|        DimBgRatio = 0.0f;
 2315|      1|        MouseCursor = ImGuiMouseCursor_Arrow;
 2316|       |
 2317|      1|        DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
 2318|      1|        DragDropSourceFlags = ImGuiDragDropFlags_None;
 2319|      1|        DragDropSourceFrameCount = -1;
 2320|      1|        DragDropMouseButton = -1;
 2321|      1|        DragDropTargetId = 0;
 2322|      1|        DragDropAcceptFlags = ImGuiDragDropFlags_None;
 2323|      1|        DragDropAcceptIdCurrRectSurface = 0.0f;
 2324|      1|        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
 2325|      1|        DragDropAcceptFrameCount = -1;
 2326|      1|        DragDropHoldJustPressedId = 0;
 2327|      1|        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));
 2328|       |
 2329|      1|        ClipperTempDataStacked = 0;
 2330|       |
 2331|      1|        CurrentTable = NULL;
 2332|      1|        TablesTempDataStacked = 0;
 2333|      1|        CurrentTabBar = NULL;
 2334|       |
 2335|      1|        HoverDelayId = HoverDelayIdPreviousFrame = 0;
 2336|      1|        HoverDelayTimer = HoverDelayClearTimer = 0.0f;
 2337|       |
 2338|      1|        TempInputId = 0;
 2339|      1|        ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
 2340|      1|        ColorEditCurrentID = ColorEditSavedID = 0;
 2341|      1|        ColorEditSavedHue = ColorEditSavedSat = 0.0f;
 2342|      1|        ColorEditSavedColor = 0;
 2343|      1|        SliderGrabClickOffset = 0.0f;
 2344|      1|        SliderCurrentAccum = 0.0f;
 2345|      1|        SliderCurrentAccumDirty = false;
 2346|      1|        DragCurrentAccumDirty = false;
 2347|      1|        DragCurrentAccum = 0.0f;
 2348|      1|        DragSpeedDefaultRatio = 1.0f / 100.0f;
 2349|      1|        ScrollbarClickDeltaToGrabCenter = 0.0f;
 2350|      1|        DisabledAlphaBackup = 0.0f;
 2351|      1|        DisabledStackSize = 0;
 2352|      1|        TooltipOverrideCount = 0;
 2353|       |
 2354|      1|        PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
 2355|      1|        PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission
 2356|      1|        PlatformImeViewport = 0;
 2357|      1|        PlatformLocaleDecimalPoint = '.';
 2358|       |
 2359|      1|        SettingsLoaded = false;
 2360|      1|        SettingsDirtyTimer = 0.0f;
 2361|      1|        HookIdNext = 0;
 2362|       |
 2363|      1|        memset(LocalizationTable, 0, sizeof(LocalizationTable));
 2364|       |
 2365|      1|        LogEnabled = false;
 2366|      1|        LogType = ImGuiLogType_None;
 2367|      1|        LogNextPrefix = LogNextSuffix = NULL;
 2368|      1|        LogFile = NULL;
 2369|      1|        LogLinePosY = FLT_MAX;
 2370|      1|        LogLineFirstItem = false;
 2371|      1|        LogDepthRef = 0;
 2372|      1|        LogDepthToExpand = LogDepthToExpandDefault = 2;
 2373|       |
 2374|      1|        DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
 2375|      1|        DebugLocateId = 0;
 2376|      1|        DebugLocateFrames = 0;
 2377|      1|        DebugItemPickerActive = false;
 2378|      1|        DebugItemPickerMouseButton = ImGuiMouseButton_Left;
 2379|      1|        DebugItemPickerBreakId = 0;
 2380|      1|        DebugHoveredDockNode = NULL;
 2381|       |
 2382|      1|        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
 2383|      1|        FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
 2384|      1|        FramerateSecPerFrameAccum = 0.0f;
 2385|      1|        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
 2386|      1|    }
_ZN17ImGuiKeyOwnerDataC2Ev:
 1357|    140|    ImGuiKeyOwnerData()             { OwnerCurr = OwnerNext = ImGuiKeyOwner_None; LockThisFrame = LockUntilRelease = false; }
  ------------------
  |  | 1320|    140|#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
_ZN20ImGuiKeyRoutingTableC2Ev:
 1344|      1|    ImGuiKeyRoutingTable()          { Clear(); }
_ZN17ImGuiNextItemDataC2Ev:
 1179|      1|    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); }
_ZN17ImGuiLastItemDataC2Ev:
 1193|   180k|    ImGuiLastItemData()     { memset(this, 0, sizeof(*this)); }
_ZN19ImGuiNextWindowDataC2Ev:
 1160|      1|    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiNavItemDataC2Ev:
 1509|      4|    ImGuiNavItemData()  { Clear(); }
_ZN6ImPoolI10ImGuiTableEC2Ev:
  679|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN6ImPoolI11ImGuiTabBarEC2Ev:
  679|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN19ImGuiInputTextStateC2EP12ImGuiContext:
 1087|      1|    ImGuiInputTextState(ImGuiContext* ctx)  { memset(this, 0, sizeof(*this)); Ctx = ctx;}
_ZN21ImGuiComboPreviewDataC2Ev:
 1030|      1|    ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiDockContextC2Ev:
 1716|      1|    ImGuiDockContext()              { memset(this, 0, sizeof(*this)); }
_ZN14ImGuiStackToolC2Ev:
 1886|      1|    ImGuiStackTool()        { memset(this, 0, sizeof(*this)); CopyToClipboardLastTime = -FLT_MAX; }
_ZN20ImGuiSettingsHandlerC2Ev:
 1802|      3|    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
_ZN14ImGuiViewportPC2Ev:
 1750|      1|    ImGuiViewportP()                    { Idx = -1; LastFrameActive = DrawListsLastFrame[0] = DrawListsLastFrame[1] = LastFrontMostStampCount = -1; LastNameHash = 0; Alpha = LastAlpha = 1.0f; PlatformMonitor = -1; Window = NULL; DrawLists[0] = DrawLists[1] = NULL; LastPlatformPos = LastPlatformSize = LastRendererSize = ImVec2(FLT_MAX, FLT_MAX); }
_ZN20ImGuiKeyRoutingTable5ClearEv:
 1345|    141|    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Index); n++) Index[n] = -1; Entries.clear(); EntriesNext.clear(); }
  ------------------
  |  |   87|    141|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1345:55): [True: 140, False: 1]
  ------------------
_ZN6ImVec1C2Ev:
  513|      9|    constexpr ImVec1()         : x(0.0f) { }
_ZN16ImGuiMenuColumnsC2Ev:
 1061|      3|    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }
_ZN6ImRectC2Ev:
  533|   632k|    constexpr ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}
_ZN8ImVec2ihC2Ev:
  521|      6|    constexpr ImVec2ih()                           : x(0), y(0) {}
_ZN5ImGui18WindowRectAbsToRelEP11ImGuiWindowRK6ImRect:
 2957|    136|    inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }
_ZN14ImGuiViewportP14UpdateWorkRectEv:
 1757|   180k|    void    UpdateWorkRect()            { WorkPos = CalcWorkRectPos(WorkOffsetMin); WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax); } // Update public fields
_ZNK14ImGuiViewportP15CalcWorkRectPosERK6ImVec2:
 1755|   180k|    ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }
_ZNK14ImGuiViewportP16CalcWorkRectSizeERK6ImVec2S2_:
 1756|   180k|    ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }
_ZNK11ImGuiWindow12TitleBarRectEv:
 2581|   451k|    ImRect      TitleBarRect() const    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
_ZNK6ImRect8ContainsERK6ImVec2:
  547|   453k|    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
  ------------------
  |  Branch (547:62): [True: 41.7k, False: 411k]
  |  Branch (547:82): [True: 32.6k, False: 9.14k]
  |  Branch (547:102): [True: 13.3k, False: 19.2k]
  |  Branch (547:122): [True: 11.1k, False: 2.25k]
  ------------------
imgui.cpp:_ZL5ImMaxRK6ImVec2S1_:
  473|  1.17M|static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (473:97): [True: 899k, False: 276k]
  |  Branch (473:129): [True: 904k, False: 271k]
  ------------------
_ZN5ImGui14GetDefaultFontEv:
 2972|  90.2k|    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }
  ------------------
  |  Branch (2972:82): [True: 0, False: 90.2k]
  ------------------
_ZN6ImRectC2Effff:
  536|  1.45M|    constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}
_ZN6ImRect3AddERKS_:
  551|   180k|    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
  ------------------
  |  Branch (551:59): [True: 180k, False: 0]
  |  Branch (551:97): [True: 180k, False: 0]
  |  Branch (551:135): [True: 180k, False: 0]
  |  Branch (551:173): [True: 180k, False: 0]
  ------------------
_ZNK6ImRect6ToVec4Ev:
  561|  90.2k|    ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }
_ZN5ImGui16GetCurrentWindowEv:
 2944|   724k|    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
_ZN6ImRectC2ERK6ImVec4:
  535|   723k|    constexpr ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}
_ZN17ImDrawDataBuilder5ClearEv:
  799|   270k|    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
  ------------------
  |  |   87|   270k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (799:55): [True: 180k, False: 90.2k]
  ------------------
_ZNK6ImRect7GetSizeEv:
  539|   180k|    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
imgui.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  466|      6|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (466:90): [True: 0, False: 6]
  |  Branch (466:106): [True: 0, False: 6]
  ------------------
_ZN15ImGuiStackSizesC2Ev:
 1208|   180k|    ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }
_ZNK11ImGuiWindow14TitleBarHeightEv:
 2580|  1.08M|    float       TitleBarHeight() const  { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }
  ------------------
  |  Branch (2580:77): [True: 969, False: 1.08M]
  ------------------
_ZNK11ImGuiWindow13MenuBarHeightEv:
 2582|   541k|    float       MenuBarHeight() const   { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }
  ------------------
  |  Branch (2582:77): [True: 0, False: 541k]
  ------------------
imgui.cpp:_ZmlRK6ImVec2S1_:
  396|    642|static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
_ZNK11ImGuiWindow4RectEv:
 2578|   181k|    ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK14ImGuiViewportP11GetWorkRectEv:
 1761|   180k|    ImRect  GetWorkRect() const         { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }
_ZNK6ImRect8GetWidthEv:
  540|   362k|    float       GetWidth() const                    { return Max.x - Min.x; }
_ZNK6ImRect9GetHeightEv:
  541|   361k|    float       GetHeight() const                   { return Max.y - Min.y; }
imgui.cpp:_ZL6ImLerpRK6ImVec2S1_S1_:
  476|    642|static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
_ZN6ImRect12ClipWithFullERKS_:
  558|   180k|    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
_ZN19ImGuiNextWindowData10ClearFlagsEv:
 1161|   180k|    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }
_ZNK11ImGuiWindow12CalcFontSizeEv:
 2579|  1.35M|    float       CalcFontSize() const    { ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale * FontDpiScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }
  ------------------
  |  Branch (2579:137): [True: 525, False: 1.35M]
  ------------------
imgui.cpp:_ZL14ImIsPowerOfTwoi:
  343|   271k|static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
  ------------------
  |  Branch (343:66): [True: 271k, False: 0]
  |  Branch (343:76): [True: 271k, False: 0]
  ------------------
imgui.cpp:_ZpLR6ImVec2RKS_:
  400|    550|static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
_ZN5ImGui20GetCurrentWindowReadEv:
 2943|    410|    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
_ZN5ImGui25ConvertSingleModFlagToKeyE8ImGuiKey:
 3123|   812k|    {
 3124|   812k|        ImGuiContext& g = *GImGui;
 3125|   812k|        if (key == ImGuiMod_Ctrl) return ImGuiKey_ReservedForModCtrl;
  ------------------
  |  Branch (3125:13): [True: 180k, False: 631k]
  ------------------
 3126|   631k|        if (key == ImGuiMod_Shift) return ImGuiKey_ReservedForModShift;
  ------------------
  |  Branch (3126:13): [True: 180k, False: 451k]
  ------------------
 3127|   451k|        if (key == ImGuiMod_Alt) return ImGuiKey_ReservedForModAlt;
  ------------------
  |  Branch (3127:13): [True: 270k, False: 180k]
  ------------------
 3128|   180k|        if (key == ImGuiMod_Super) return ImGuiKey_ReservedForModSuper;
  ------------------
  |  Branch (3128:13): [True: 180k, False: 0]
  ------------------
 3129|      0|        if (key == ImGuiMod_Shortcut) return (g.IO.ConfigMacOSXBehaviors ? ImGuiKey_ReservedForModSuper : ImGuiKey_ReservedForModCtrl);
  ------------------
  |  Branch (3129:13): [True: 0, False: 0]
  |  Branch (3129:47): [True: 0, False: 0]
  ------------------
 3130|      0|        return key;
 3131|      0|    }
_ZN5ImGui16MouseButtonToKeyEi:
 3135|   451k|    inline ImGuiKey         MouseButtonToKey(ImGuiMouseButton button)                   { IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT); return (ImGuiKey)(ImGuiKey_MouseLeft + button); }
  ------------------
  |  |   23|   451k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui.cpp:_ZL13ImFloorSignedRK6ImVec2:
  485|  33.4k|static inline ImVec2 ImFloorSigned(const ImVec2& v)                             { return ImVec2(ImFloorSigned(v.x), ImFloorSigned(v.y)); }
imgui.cpp:_ZL26ImExponentialMovingAverageffi:
  492|     92|static inline float  ImExponentialMovingAverage(float avg, float sample, int n) { avg -= avg / n; avg += sample / n; return avg; }
imgui.cpp:_ZL5ImAbsf:
  451|     92|static inline float  ImAbs(float x)             { return fabsf(x); }
_ZN5ImGui15GetKeyOwnerDataE8ImGuiKey:
 3159|   207k|    inline ImGuiKeyOwnerData*   GetKeyOwnerData(ImGuiKey key)     { if (key & ImGuiMod_Mask_) key = ConvertSingleModFlagToKey(key); IM_ASSERT(IsNamedKey(key)); return &GImGui->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN]; }
  ------------------
  |  |   23|   207k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (3159:73): [True: 0, False: 207k]
  ------------------
imgui.cpp:_ZL7ImClampRK6ImVec2S1_S_:
  474|   722k|static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
  ------------------
  |  Branch (474:97): [True: 91.5k, False: 631k]
  |  Branch (474:119): [True: 0, False: 631k]
  |  Branch (474:146): [True: 637, False: 722k]
  |  Branch (474:168): [True: 89, False: 722k]
  ------------------
_ZN16ImGuiNavItemData5ClearEv:
 1510|     64|    void Clear()        { Window = NULL; ID = FocusScopeId = 0; InFlags = 0; DistBox = DistCenter = DistAxial = FLT_MAX; }
_ZN5ImGui21IsActiveIdUsingNavDirEi:
 3142|  1.78k|    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }
_ZN6ImRect10TranslateYEf:
  556|    447|    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
_ZN5ImGui18WindowRectRelToAbsEP11ImGuiWindowRK6ImRect:
 2958|    447|    inline ImRect           WindowRectRelToAbs(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y); }
_ZNK13ImChunkStreamI19ImGuiWindowSettingsE5emptyEv:
  714|      1|    bool    empty() const               { return Buf.Size == 0; }
_ZN14ImGuiViewportP17ClearRequestFlagsEv:
 1752|  90.2k|    void    ClearRequestFlags()         { PlatformRequestClose = PlatformRequestMove = PlatformRequestResize = false; }
_ZNK6ImRect10IsInvertedEv:
  560|    894|    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
  ------------------
  |  Branch (560:62): [True: 0, False: 894]
  |  Branch (560:79): [True: 0, False: 894]
  ------------------
_ZNK6ImRect9GetCenterEv:
  538|    339|    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
imgui.cpp:_ZL5ImMinIfET_S0_S0_:
  464|   362k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (464:90): [True: 920, False: 361k]
  ------------------
imgui.cpp:_ZL5ImMaxIfET_S0_S0_:
  465|  4.10M|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (465:90): [True: 3.01M, False: 1.08M]
  ------------------
imgui.cpp:_ZL5ImMinIiET_S0_S0_:
  464|  90.5k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (464:90): [True: 59, False: 90.4k]
  ------------------
imgui.cpp:_ZL6ImSwapIfEvRT_S1_:
  468|    642|template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
_ZN10ImBitArrayILi140ELi0EEC2Ev:
  593|  90.2k|    ImBitArray()                                { ClearAllBits(); }
_ZN10ImBitArrayILi140ELi0EE12ClearAllBitsEv:
  594|  90.2k|    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }
_ZNK10ImBitArrayILi140ELi0EE7TestBitEi:
  596|  3.14k|    bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
  ------------------
  |  |   23|  3.14k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
  ------------------
  |  |  565|  3.14k|#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
  ------------------
_ZN10ImBitArrayILi140ELi0EE6SetBitEi:
  597|  3.12k|    void            SetBit(int n)               { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(Storage, n); }
  ------------------
  |  |   23|  3.12k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_Z16ImBitArraySetBitPji:
  571|  3.57k|inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }
_ZN13ImChunkStreamI19ImGuiWindowSettingsE5beginEv:
  717|      2|    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }
  ------------------
  |  Branch (717:66): [True: 2, False: 0]
  ------------------
_ZN11ImBitVector6CreateEi:
  608|      2|    void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
_ZN11ImBitVector5ClearEv:
  609|      2|    void            Clear()                     { Storage.clear(); }
_ZNK11ImBitVector7TestBitEi:
  610|    224|    bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }
  ------------------
  |  |   23|    224|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }
  ------------------
  |  |  565|    224|#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
  ------------------
_ZN11ImBitVector6SetBitEi:
  611|    446|    void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui_draw.cpp:_ZL6ImLerpRK6ImVec4S1_f:
  477|      4|static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
imgui_draw.cpp:_ZmlRK6ImVec4S1_:
  406|      1|static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }
imgui_draw.cpp:_ZL7ImRsqrtf:
  456|  1.27M|static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }
imgui_draw.cpp:_ZplRK6ImVec2S1_:
  394|   902k|static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui_draw.cpp:_ZmlRK6ImVec2f:
  392|   541k|static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui_draw.cpp:_ZmiRK6ImVec2S1_:
  395|   181k|static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui_draw.cpp:_ZL5ImAbsi:
  450|  1.45k|static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }
  ------------------
  |  Branch (450:58): [True: 0, False: 1.45k]
  ------------------
imgui_draw.cpp:_ZL13ImFloorSignedf:
  483|  1.28k|static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (483:99): [True: 648, False: 636]
  |  Branch (483:109): [True: 636, False: 0]
  ------------------
imgui_draw.cpp:_ZmlRK6ImVec2S1_:
  396|    128|static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
imgui_draw.cpp:_ZL17ImUpperPowerOfTwoi:
  345|      1|static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
imgui_draw.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  336|      4|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (336:147): [True: 4, False: 0]
  ------------------
imgui_draw.cpp:_ZL7ImFloorf:
  482|      2|static inline float  ImFloor(float f)                                           { return (float)(int)(f); }
imgui_draw.cpp:_ZL5ImMinIfET_S0_S0_:
  464|   543k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (464:90): [True: 362k, False: 181k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIfET_S0_S0_:
  465|  1.08M|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (465:90): [True: 273k, False: 810k]
  ------------------
imgui_draw.cpp:_ZL7ImClampIiET_S0_S0_S0_:
  466|  1.85k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (466:90): [True: 0, False: 1.85k]
  |  Branch (466:106): [True: 0, False: 1.85k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIiET_S0_S0_:
  465|    450|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (465:90): [True: 223, False: 227]
  ------------------
imgui_draw.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  466|    223|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (466:90): [True: 0, False: 223]
  |  Branch (466:106): [True: 0, False: 223]
  ------------------
imgui_widgets.cpp:_ZplRK6ImVec2S1_:
  394|   542k|static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui_widgets.cpp:_ZmiRK6ImVec2S1_:
  395|     27|static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui_widgets.cpp:_ZmlRK6ImVec2f:
  392|   180k|static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui_widgets.cpp:_ZL10ImSaturatef:
  478|    345|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (478:90): [True: 1, False: 344]
  |  Branch (478:110): [True: 0, False: 344]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIfET_S0_S0_:
  465|    647|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (465:90): [True: 331, False: 316]
  ------------------
imgui_widgets.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  466|  1.02k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (466:90): [True: 316, False: 713]
  |  Branch (466:106): [True: 249, False: 464]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIxET_S0_S0_:
  465|  1.37k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (465:90): [True: 1.00k, False: 369]
  ------------------
imgui_widgets.cpp:_ZL6ImLerpIfET_S0_S0_f:
  467|    686|template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

_ZN5ImGui31TableSettingsAddSettingsHandlerEv:
 3496|      1|{
 3497|      1|    ImGuiSettingsHandler ini_handler;
 3498|      1|    ini_handler.TypeName = "Table";
 3499|      1|    ini_handler.TypeHash = ImHashStr("Table");
 3500|      1|    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
 3501|      1|    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
 3502|      1|    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
 3503|      1|    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
 3504|      1|    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
 3505|      1|    AddSettingsHandler(&ini_handler);
 3506|      1|}

_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i:
  483|   181k|{
  484|   181k|    ImGuiContext& g = *GImGui;
  485|   181k|    ImGuiWindow* window = GetCurrentWindow();
  486|       |
  487|       |    // Default only reacts to left mouse button
  488|   181k|    if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)
  ------------------
  |  Branch (488:9): [True: 181k, False: 0]
  ------------------
  489|   181k|        flags |= ImGuiButtonFlags_MouseButtonDefault_;
  490|       |
  491|       |    // Default behavior requires click + release inside bounding box
  492|   181k|    if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)
  ------------------
  |  Branch (492:9): [True: 181k, False: 0]
  ------------------
  493|   181k|        flags |= ImGuiButtonFlags_PressedOnDefault_;
  494|       |
  495|   181k|    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
  496|   181k|    const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;
  ------------------
  |  Branch (496:43): [True: 321, False: 180k]
  |  Branch (496:89): [True: 45, False: 276]
  |  Branch (496:108): [True: 45, False: 0]
  ------------------
  497|   181k|    if (flatten_hovered_children)
  ------------------
  |  Branch (497:9): [True: 45, False: 181k]
  ------------------
  498|     45|        g.HoveredWindow = window;
  499|       |
  500|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
  501|       |    if (id != 0 && g.LastItemData.ID != id)
  502|       |        IMGUI_TEST_ENGINE_ITEM_ADD(bb, id);
  503|       |#endif
  504|       |
  505|   181k|    bool pressed = false;
  506|   181k|    bool hovered = ItemHoverable(bb, id);
  507|       |
  508|       |    // Drag source doesn't report as hovered
  509|   181k|    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
  ------------------
  |  Branch (509:9): [True: 334, False: 180k]
  |  Branch (509:20): [True: 0, False: 334]
  |  Branch (509:40): [True: 0, False: 0]
  |  Branch (509:76): [True: 0, False: 0]
  ------------------
  510|      0|        hovered = false;
  511|       |
  512|       |    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
  513|   181k|    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
  ------------------
  |  Branch (513:9): [True: 160, False: 180k]
  |  Branch (513:29): [True: 0, False: 160]
  |  Branch (513:81): [True: 0, False: 0]
  ------------------
  514|      0|        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (514:13): [True: 0, False: 0]
  ------------------
  515|      0|        {
  516|      0|            hovered = true;
  517|      0|            SetHoveredID(id);
  518|      0|            if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)
  ------------------
  |  Branch (518:17): [True: 0, False: 0]
  |  Branch (518:85): [True: 0, False: 0]
  ------------------
  519|      0|            {
  520|      0|                pressed = true;
  521|      0|                g.DragDropHoldJustPressedId = id;
  522|      0|                FocusWindow(window);
  523|      0|            }
  524|      0|        }
  525|       |
  526|   181k|    if (flatten_hovered_children)
  ------------------
  |  Branch (526:9): [True: 45, False: 181k]
  ------------------
  527|     45|        g.HoveredWindow = backup_hovered_window;
  528|       |
  529|       |    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
  530|   181k|    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
  ------------------
  |  Branch (530:9): [True: 334, False: 180k]
  |  Branch (530:20): [True: 0, False: 334]
  |  Branch (530:68): [True: 0, False: 0]
  |  Branch (530:102): [True: 0, False: 0]
  ------------------
  531|      0|        hovered = false;
  532|       |
  533|       |    // Mouse handling
  534|   181k|    const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;
  ------------------
  |  | 1319|      0|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (534:35): [True: 0, False: 181k]
  ------------------
  535|   181k|    if (hovered)
  ------------------
  |  Branch (535:9): [True: 334, False: 180k]
  ------------------
  536|    334|    {
  537|       |        // Poll mouse buttons
  538|       |        // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
  539|       |        // - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
  540|    334|        int mouse_button_clicked = -1;
  541|    334|        int mouse_button_released = -1;
  542|  1.33k|        for (int button = 0; button < 3; button++)
  ------------------
  |  Branch (542:30): [True: 1.00k, False: 334]
  ------------------
  543|  1.00k|            if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
  ------------------
  |  Branch (543:17): [True: 334, False: 668]
  ------------------
  544|    334|            {
  545|    334|                if (IsMouseClicked(button, test_owner_id) && mouse_button_clicked == -1) { mouse_button_clicked = button; }
  ------------------
  |  Branch (545:21): [True: 27, False: 307]
  |  Branch (545:62): [True: 27, False: 0]
  ------------------
  546|    334|                if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) { mouse_button_released = button; }
  ------------------
  |  Branch (546:21): [True: 9, False: 325]
  |  Branch (546:63): [True: 9, False: 0]
  ------------------
  547|    334|            }
  548|       |
  549|       |        // Process initial action
  550|    334|        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
  ------------------
  |  Branch (550:13): [True: 334, False: 0]
  |  Branch (550:60): [True: 0, False: 0]
  |  Branch (550:77): [True: 0, False: 0]
  |  Branch (550:95): [True: 0, False: 0]
  ------------------
  551|    334|        {
  552|    334|            if (mouse_button_clicked != -1 && g.ActiveId != id)
  ------------------
  |  Branch (552:17): [True: 27, False: 307]
  |  Branch (552:47): [True: 27, False: 0]
  ------------------
  553|     27|            {
  554|     27|                if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))
  ------------------
  |  Branch (554:21): [True: 27, False: 0]
  ------------------
  555|     27|                    SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);
  556|     27|                if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))
  ------------------
  |  Branch (556:21): [True: 27, False: 0]
  ------------------
  557|     27|                {
  558|     27|                    SetActiveID(id, window);
  559|     27|                    g.ActiveIdMouseButton = mouse_button_clicked;
  560|     27|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (560:25): [True: 27, False: 0]
  ------------------
  561|     27|                        SetFocusID(id, window);
  562|     27|                    FocusWindow(window);
  563|     27|                }
  564|     27|                if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2))
  ------------------
  |  Branch (564:21): [True: 0, False: 27]
  |  Branch (564:67): [True: 0, False: 27]
  |  Branch (564:118): [True: 0, False: 0]
  ------------------
  565|      0|                {
  566|      0|                    pressed = true;
  567|      0|                    if (flags & ImGuiButtonFlags_NoHoldingActiveId)
  ------------------
  |  Branch (567:25): [True: 0, False: 0]
  ------------------
  568|      0|                        ClearActiveID();
  569|      0|                    else
  570|      0|                        SetActiveID(id, window); // Hold on ID
  571|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (571:25): [True: 0, False: 0]
  ------------------
  572|      0|                        SetFocusID(id, window);
  573|      0|                    g.ActiveIdMouseButton = mouse_button_clicked;
  574|      0|                    FocusWindow(window);
  575|      0|                }
  576|     27|            }
  577|    334|            if (flags & ImGuiButtonFlags_PressedOnRelease)
  ------------------
  |  Branch (577:17): [True: 0, False: 334]
  ------------------
  578|      0|            {
  579|      0|                if (mouse_button_released != -1)
  ------------------
  |  Branch (579:21): [True: 0, False: 0]
  ------------------
  580|      0|                {
  581|      0|                    const bool has_repeated_at_least_once = (flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
  ------------------
  |  Branch (581:61): [True: 0, False: 0]
  |  Branch (581:98): [True: 0, False: 0]
  ------------------
  582|      0|                    if (!has_repeated_at_least_once)
  ------------------
  |  Branch (582:25): [True: 0, False: 0]
  ------------------
  583|      0|                        pressed = true;
  584|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (584:25): [True: 0, False: 0]
  ------------------
  585|      0|                        SetFocusID(id, window);
  586|      0|                    ClearActiveID();
  587|      0|                }
  588|      0|            }
  589|       |
  590|       |            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
  591|       |            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
  592|    334|            if (g.ActiveId == id && (flags & ImGuiButtonFlags_Repeat))
  ------------------
  |  Branch (592:17): [True: 109, False: 225]
  |  Branch (592:37): [True: 0, False: 109]
  ------------------
  593|      0|                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, test_owner_id, ImGuiInputFlags_Repeat))
  ------------------
  |  Branch (593:21): [True: 0, False: 0]
  |  Branch (593:77): [True: 0, False: 0]
  ------------------
  594|      0|                    pressed = true;
  595|    334|        }
  596|       |
  597|    334|        if (pressed)
  ------------------
  |  Branch (597:13): [True: 0, False: 334]
  ------------------
  598|      0|            g.NavDisableHighlight = true;
  599|    334|    }
  600|       |
  601|       |    // Gamepad/Keyboard navigation
  602|       |    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
  603|   181k|    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
  ------------------
  |  Branch (603:9): [True: 110, False: 181k]
  |  Branch (603:26): [True: 0, False: 110]
  |  Branch (603:52): [True: 0, False: 0]
  |  Branch (603:79): [True: 0, False: 0]
  |  Branch (603:98): [True: 0, False: 0]
  |  Branch (603:118): [True: 0, False: 0]
  ------------------
  604|      0|        if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))
  ------------------
  |  Branch (604:13): [True: 0, False: 0]
  ------------------
  605|      0|            hovered = true;
  606|   181k|    if (g.NavActivateDownId == id)
  ------------------
  |  Branch (606:9): [True: 0, False: 181k]
  ------------------
  607|      0|    {
  608|      0|        bool nav_activated_by_code = (g.NavActivateId == id);
  609|      0|        bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
  610|      0|        if (!nav_activated_by_inputs && (flags & ImGuiButtonFlags_Repeat))
  ------------------
  |  Branch (610:13): [True: 0, False: 0]
  |  Branch (610:41): [True: 0, False: 0]
  ------------------
  611|      0|        {
  612|       |            // Avoid pressing both keys from triggering double amount of repeat events
  613|      0|            const ImGuiKeyData* key1 = GetKeyData(ImGuiKey_Space);
  614|      0|            const ImGuiKeyData* key2 = GetKeyData(ImGuiKey_NavGamepadActivate);
  ------------------
  |  | 1260|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  615|      0|            const float t1 = ImMax(key1->DownDuration, key2->DownDuration);
  616|      0|            nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
  617|      0|        }
  618|      0|        if (nav_activated_by_code || nav_activated_by_inputs)
  ------------------
  |  Branch (618:13): [True: 0, False: 0]
  |  Branch (618:38): [True: 0, False: 0]
  ------------------
  619|      0|        {
  620|       |            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
  621|      0|            pressed = true;
  622|      0|            SetActiveID(id, window);
  623|      0|            g.ActiveIdSource = ImGuiInputSource_Nav;
  624|      0|            if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (624:17): [True: 0, False: 0]
  ------------------
  625|      0|                SetFocusID(id, window);
  626|      0|        }
  627|      0|    }
  628|       |
  629|       |    // Process while held
  630|   181k|    bool held = false;
  631|   181k|    if (g.ActiveId == id)
  ------------------
  |  Branch (631:9): [True: 114, False: 181k]
  ------------------
  632|    114|    {
  633|    114|        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
  ------------------
  |  Branch (633:13): [True: 114, False: 0]
  ------------------
  634|    114|        {
  635|    114|            if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (635:17): [True: 27, False: 87]
  ------------------
  636|     27|                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
  637|       |
  638|    114|            const int mouse_button = g.ActiveIdMouseButton;
  639|    114|            if (IsMouseDown(mouse_button, test_owner_id))
  ------------------
  |  Branch (639:17): [True: 107, False: 7]
  ------------------
  640|    107|            {
  641|    107|                held = true;
  642|    107|            }
  643|      7|            else
  644|      7|            {
  645|      7|                bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;
  ------------------
  |  Branch (645:35): [True: 7, False: 0]
  |  Branch (645:46): [True: 7, False: 0]
  ------------------
  646|      7|                bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
  647|      7|                if ((release_in || release_anywhere) && !g.DragDropActive)
  ------------------
  |  Branch (647:22): [True: 7, False: 0]
  |  Branch (647:36): [True: 0, False: 0]
  |  Branch (647:57): [True: 7, False: 0]
  ------------------
  648|      7|                {
  649|       |                    // Report as pressed when releasing the mouse (this is the most common path)
  650|      7|                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;
  ------------------
  |  Branch (650:52): [True: 0, False: 7]
  |  Branch (650:103): [True: 0, False: 0]
  |  Branch (650:139): [True: 0, False: 0]
  ------------------
  651|      7|                    bool is_repeating_already = (flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
  ------------------
  |  Branch (651:49): [True: 0, False: 7]
  |  Branch (651:86): [True: 0, False: 0]
  ------------------
  652|      7|                    bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);
  653|      7|                    if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)
  ------------------
  |  Branch (653:25): [True: 7, False: 0]
  |  Branch (653:53): [True: 7, False: 0]
  |  Branch (653:78): [True: 7, False: 0]
  ------------------
  654|      7|                        pressed = true;
  655|      7|                }
  656|      7|                ClearActiveID();
  657|      7|            }
  658|    114|            if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (658:17): [True: 114, False: 0]
  ------------------
  659|    114|                g.NavDisableHighlight = true;
  660|    114|        }
  661|      0|        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
  ------------------
  |  Branch (661:18): [True: 0, False: 0]
  ------------------
  662|      0|        {
  663|       |            // When activated using Nav, we hold on the ActiveID until activation button is released
  664|      0|            if (g.NavActivateDownId != id)
  ------------------
  |  Branch (664:17): [True: 0, False: 0]
  ------------------
  665|      0|                ClearActiveID();
  666|      0|        }
  667|    114|        if (pressed)
  ------------------
  |  Branch (667:13): [True: 7, False: 107]
  ------------------
  668|      7|            g.ActiveIdHasBeenPressedBefore = true;
  669|    114|    }
  670|       |
  671|   181k|    if (out_hovered) *out_hovered = hovered;
  ------------------
  |  Branch (671:9): [True: 181k, False: 0]
  ------------------
  672|   181k|    if (out_held) *out_held = held;
  ------------------
  |  Branch (672:9): [True: 181k, False: 0]
  ------------------
  673|       |
  674|   181k|    return pressed;
  675|   181k|}
_ZN5ImGui14CollapseButtonEjRK6ImVec2P13ImGuiDockNode:
  841|   180k|{
  842|   180k|    ImGuiContext& g = *GImGui;
  843|   180k|    ImGuiWindow* window = g.CurrentWindow;
  844|       |
  845|   180k|    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
  846|   180k|    ItemAdd(bb, id);
  847|   180k|    bool hovered, held;
  848|   180k|    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);
  849|       |
  850|       |    // Render
  851|       |    //bool is_dock_menu = (window->DockNodeAsHost && !window->Collapsed);
  852|   180k|    ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (852:33): [True: 107, False: 180k]
  |  Branch (852:41): [True: 102, False: 5]
  |  Branch (852:76): [True: 232, False: 180k]
  ------------------
  853|   180k|    ImU32 text_col = GetColorU32(ImGuiCol_Text);
  854|   180k|    if (hovered || held)
  ------------------
  |  Branch (854:9): [True: 334, False: 180k]
  |  Branch (854:20): [True: 5, False: 180k]
  ------------------
  855|    339|        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0,-0.5f), g.FontSize * 0.5f + 1.0f, bg_col, 12);
  856|       |
  857|   180k|    if (dock_node)
  ------------------
  |  Branch (857:9): [True: 0, False: 180k]
  ------------------
  858|      0|        RenderArrowDockMenu(window->DrawList, bb.Min + g.Style.FramePadding, g.FontSize, text_col);
  859|   180k|    else
  860|   180k|        RenderArrow(window->DrawList, bb.Min + g.Style.FramePadding, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);
  ------------------
  |  Branch (860:80): [True: 89.9k, False: 90.5k]
  ------------------
  861|       |
  862|       |    // Switch to moving the window after mouse is moved beyond the initial drag threshold
  863|   180k|    if (IsItemActive() && IsMouseDragging(0))
  ------------------
  |  Branch (863:9): [True: 107, False: 180k]
  |  Branch (863:27): [True: 6, False: 101]
  ------------------
  864|      6|        StartMouseMovingWindowOrNode(window, dock_node, true);
  865|       |
  866|   180k|    return pressed;
  867|   180k|}
_ZN5ImGui20GetWindowScrollbarIDEP11ImGuiWindow9ImGuiAxis:
  870|    647|{
  871|    647|    return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
  ------------------
  |  Branch (871:26): [True: 323, False: 324]
  ------------------
  872|    647|}
_ZN5ImGui22GetWindowScrollbarRectEP11ImGuiWindow9ImGuiAxis:
  876|    647|{
  877|    647|    const ImRect outer_rect = window->Rect();
  878|    647|    const ImRect inner_rect = window->InnerRect;
  879|    647|    const float border_size = window->WindowBorderSize;
  880|    647|    const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
  881|    647|    IM_ASSERT(scrollbar_size > 0.0f);
  ------------------
  |  |   23|    647|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  882|    647|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (882:9): [True: 323, False: 324]
  ------------------
  883|    323|        return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x, outer_rect.Max.y);
  884|    324|    else
  885|    324|        return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x, inner_rect.Max.y);
  886|    647|}
_ZN5ImGui9ScrollbarE9ImGuiAxis:
  889|    647|{
  890|    647|    ImGuiContext& g = *GImGui;
  891|    647|    ImGuiWindow* window = g.CurrentWindow;
  892|    647|    const ImGuiID id = GetWindowScrollbarID(window, axis);
  893|       |
  894|       |    // Calculate scrollbar bounding box
  895|    647|    ImRect bb = GetWindowScrollbarRect(window, axis);
  896|    647|    ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;
  897|    647|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (897:9): [True: 323, False: 324]
  ------------------
  898|    323|    {
  899|    323|        rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;
  900|    323|        if (!window->ScrollbarY)
  ------------------
  |  Branch (900:13): [True: 63, False: 260]
  ------------------
  901|     63|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  902|    323|    }
  903|    324|    else
  904|    324|    {
  905|    324|        if ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar))
  ------------------
  |  Branch (905:13): [True: 260, False: 64]
  |  Branch (905:62): [True: 260, False: 0]
  ------------------
  906|    260|            rounding_corners |= ImDrawFlags_RoundCornersTopRight;
  907|    324|        if (!window->ScrollbarX)
  ------------------
  |  Branch (907:13): [True: 64, False: 260]
  ------------------
  908|     64|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  909|    324|    }
  910|    647|    float size_avail = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
  911|    647|    float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;
  912|    647|    ImS64 scroll = (ImS64)window->Scroll[axis];
  913|    647|    ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_avail, (ImS64)size_contents, rounding_corners);
  914|    647|    window->Scroll[axis] = (float)scroll;
  915|    647|}
_ZN5ImGui11ScrollbarExERK6ImRectj9ImGuiAxisPxxxi:
  924|    647|{
  925|    647|    ImGuiContext& g = *GImGui;
  926|    647|    ImGuiWindow* window = g.CurrentWindow;
  927|    647|    if (window->SkipItems)
  ------------------
  |  Branch (927:9): [True: 0, False: 647]
  ------------------
  928|      0|        return false;
  929|       |
  930|    647|    const float bb_frame_width = bb_frame.GetWidth();
  931|    647|    const float bb_frame_height = bb_frame.GetHeight();
  932|    647|    if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)
  ------------------
  |  Branch (932:9): [True: 72, False: 575]
  |  Branch (932:35): [True: 231, False: 344]
  ------------------
  933|    303|        return false;
  934|       |
  935|       |    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
  936|    344|    float alpha = 1.0f;
  937|    344|    if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
  ------------------
  |  Branch (937:9): [True: 93, False: 251]
  |  Branch (937:34): [True: 2, False: 91]
  ------------------
  938|      2|        alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
  939|    344|    if (alpha <= 0.0f)
  ------------------
  |  Branch (939:9): [True: 1, False: 343]
  ------------------
  940|      1|        return false;
  941|       |
  942|    343|    const ImGuiStyle& style = g.Style;
  943|    343|    const bool allow_interaction = (alpha >= 1.0f);
  944|       |
  945|    343|    ImRect bb = bb_frame;
  946|    343|    bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  269|    343|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
                  bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  269|    343|#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
  ------------------
  947|       |
  948|       |    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
  949|    343|    const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();
  ------------------
  |  Branch (949:36): [True: 251, False: 92]
  ------------------
  950|       |
  951|       |    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
  952|       |    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
  953|    343|    IM_ASSERT(ImMax(size_contents_v, size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
  ------------------
  |  |   23|    343|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  954|    343|    const ImS64 win_size_v = ImMax(ImMax(size_contents_v, size_avail_v), (ImS64)1);
  955|    343|    const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_avail_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);
  956|    343|    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;
  957|       |
  958|       |    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
  959|    343|    bool held = false;
  960|    343|    bool hovered = false;
  961|    343|    ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);
  962|    343|    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);
  963|       |
  964|    343|    const ImS64 scroll_max = ImMax((ImS64)1, size_contents_v - size_avail_v);
  965|    343|    float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
  966|    343|    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
  967|    343|    if (held && allow_interaction && grab_h_norm < 1.0f)
  ------------------
  |  Branch (967:9): [True: 0, False: 343]
  |  Branch (967:17): [True: 0, False: 0]
  |  Branch (967:38): [True: 0, False: 0]
  ------------------
  968|      0|    {
  969|      0|        const float scrollbar_pos_v = bb.Min[axis];
  970|      0|        const float mouse_pos_v = g.IO.MousePos[axis];
  971|       |
  972|       |        // Click position in scrollbar normalized space (0.0f->1.0f)
  973|      0|        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
  974|      0|        SetHoveredID(id);
  975|       |
  976|      0|        bool seek_absolute = false;
  977|      0|        if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (977:13): [True: 0, False: 0]
  ------------------
  978|      0|        {
  979|       |            // On initial click calculate the distance between mouse and the center of the grab
  980|      0|            seek_absolute = (clicked_v_norm < grab_v_norm || clicked_v_norm > grab_v_norm + grab_h_norm);
  ------------------
  |  Branch (980:30): [True: 0, False: 0]
  |  Branch (980:62): [True: 0, False: 0]
  ------------------
  981|      0|            if (seek_absolute)
  ------------------
  |  Branch (981:17): [True: 0, False: 0]
  ------------------
  982|      0|                g.ScrollbarClickDeltaToGrabCenter = 0.0f;
  983|      0|            else
  984|      0|                g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
  985|      0|        }
  986|       |
  987|       |        // Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
  988|       |        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
  989|      0|        const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
  990|      0|        *p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);
  991|       |
  992|       |        // Update values for rendering
  993|      0|        scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
  994|      0|        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
  995|       |
  996|       |        // Update distance to grab now that we have seeked and saturated
  997|      0|        if (seek_absolute)
  ------------------
  |  Branch (997:13): [True: 0, False: 0]
  ------------------
  998|      0|            g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
  999|      0|    }
 1000|       |
 1001|       |    // Render
 1002|    343|    const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);
 1003|    343|    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
  ------------------
  |  Branch (1003:40): [True: 0, False: 343]
  |  Branch (1003:78): [True: 0, False: 343]
  ------------------
 1004|    343|    window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);
 1005|    343|    ImRect grab_rect;
 1006|    343|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (1006:9): [True: 251, False: 92]
  ------------------
 1007|    251|        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);
 1008|     92|    else
 1009|     92|        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
 1010|    343|    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
 1011|       |
 1012|    343|    return held;
 1013|    344|}
_ZN5ImGui5DummyERK6ImVec2:
 1354|    323|{
 1355|    323|    ImGuiWindow* window = GetCurrentWindow();
 1356|    323|    if (window->SkipItems)
  ------------------
  |  Branch (1356:9): [True: 0, False: 323]
  ------------------
 1357|      0|        return;
 1358|       |
 1359|    323|    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
 1360|    323|    ItemSize(size);
 1361|    323|    ItemAdd(bb, 0);
 1362|    323|}
_ZN16ImGuiMenuColumns6UpdateEfb:
 6844|   180k|{
 6845|   180k|    if (window_reappearing)
  ------------------
  |  Branch (6845:9): [True: 6, False: 180k]
  ------------------
 6846|      6|        memset(Widths, 0, sizeof(Widths));
 6847|   180k|    Spacing = (ImU16)spacing;
 6848|   180k|    CalcNextTotalWidth(true);
 6849|   180k|    memset(Widths, 0, sizeof(Widths));
 6850|   180k|    TotalWidth = NextTotalWidth;
 6851|   180k|    NextTotalWidth = 0;
 6852|   180k|}
_ZN16ImGuiMenuColumns18CalcNextTotalWidthEb:
 6855|   180k|{
 6856|   180k|    ImU16 offset = 0;
 6857|   180k|    bool want_spacing = false;
 6858|   903k|    for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)
  ------------------
  |  |   87|   903k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (6858:21): [True: 723k, False: 180k]
  ------------------
 6859|   723k|    {
 6860|   723k|        ImU16 width = Widths[i];
 6861|   723k|        if (want_spacing && width > 0)
  ------------------
  |  Branch (6861:13): [True: 0, False: 723k]
  |  Branch (6861:29): [True: 0, False: 0]
  ------------------
 6862|      0|            offset += Spacing;
 6863|   723k|        want_spacing |= (width > 0);
 6864|   723k|        if (update_offsets)
  ------------------
  |  Branch (6864:13): [True: 723k, False: 0]
  ------------------
 6865|   723k|        {
 6866|   723k|            if (i == 1) { OffsetLabel = offset; }
  ------------------
  |  Branch (6866:17): [True: 180k, False: 542k]
  ------------------
 6867|   723k|            if (i == 2) { OffsetShortcut = offset; }
  ------------------
  |  Branch (6867:17): [True: 180k, False: 542k]
  ------------------
 6868|   723k|            if (i == 3) { OffsetMark = offset; }
  ------------------
  |  Branch (6868:17): [True: 180k, False: 542k]
  ------------------
 6869|   723k|        }
 6870|   723k|        offset += width;
 6871|   723k|    }
 6872|   180k|    NextTotalWidth = offset;
 6873|   180k|}

imgui_draw.cpp:_ZL17stbrp_init_targetP13stbrp_contextiiP10stbrp_nodei:
  266|      1|{
  267|      1|   int i;
  268|       |
  269|    511|   for (i=0; i < num_nodes-1; ++i)
  ------------------
  |  Branch (269:14): [True: 510, False: 1]
  ------------------
  270|    510|      nodes[i].next = &nodes[i+1];
  271|      1|   nodes[i].next = NULL;
  272|      1|   context->init_mode = STBRP__INIT_skyline;
  273|      1|   context->heuristic = STBRP_HEURISTIC_Skyline_default;
  274|      1|   context->free_head = &nodes[0];
  275|      1|   context->active_head = &context->extra[0];
  276|      1|   context->width = width;
  277|      1|   context->height = height;
  278|      1|   context->num_nodes = num_nodes;
  279|      1|   stbrp_setup_allow_out_of_mem(context, 0);
  280|       |
  281|       |   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
  282|      1|   context->extra[0].x = 0;
  283|      1|   context->extra[0].y = 0;
  284|      1|   context->extra[0].next = &context->extra[1];
  285|      1|   context->extra[1].x = (stbrp_coord) width;
  286|      1|   context->extra[1].y = (1<<30);
  287|      1|   context->extra[1].next = NULL;
  288|      1|}
imgui_draw.cpp:_ZL28stbrp_setup_allow_out_of_memP13stbrp_contexti:
  246|      1|{
  247|      1|   if (allow_out_of_mem)
  ------------------
  |  Branch (247:8): [True: 0, False: 1]
  ------------------
  248|       |      // if it's ok to run out of memory, then don't bother aligning them;
  249|       |      // this gives better packing, but may fail due to OOM (even though
  250|       |      // the rectangles easily fit). @TODO a smarter approach would be to only
  251|       |      // quantize once we've hit OOM, then we could get rid of this parameter.
  252|      0|      context->align = 1;
  253|      1|   else {
  254|       |      // if it's not ok to run out of memory, then quantize the widths
  255|       |      // so that num_nodes is always enough nodes.
  256|       |      //
  257|       |      // I.e. num_nodes * align >= width
  258|       |      //                  align >= width / num_nodes
  259|       |      //                  align = ceil(width/num_nodes)
  260|       |
  261|      1|      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
  262|      1|   }
  263|      1|}
imgui_draw.cpp:_ZL16stbrp_pack_rectsP13stbrp_contextP10stbrp_recti:
  547|      2|{
  548|      2|   int i, all_rects_packed = 1;
  549|       |
  550|       |   // we use the 'was_packed' field internally to allow sorting/unsorting
  551|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (551:14): [True: 225, False: 2]
  ------------------
  552|    225|      rects[i].was_packed = i;
  553|    225|   }
  554|       |
  555|       |   // sort according to heuristic
  556|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);
  ------------------
  |  |  118|      2|#define STBRP_SORT          ImQsort
  ------------------
  557|       |
  558|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (558:14): [True: 225, False: 2]
  ------------------
  559|    225|      if (rects[i].w == 0 || rects[i].h == 0) {
  ------------------
  |  Branch (559:11): [True: 0, False: 225]
  |  Branch (559:30): [True: 0, False: 225]
  ------------------
  560|      0|         rects[i].x = rects[i].y = 0;  // empty rect needs no space
  561|    225|      } else {
  562|    225|         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
  563|    225|         if (fr.prev_link) {
  ------------------
  |  Branch (563:14): [True: 225, False: 0]
  ------------------
  564|    225|            rects[i].x = (stbrp_coord) fr.x;
  565|    225|            rects[i].y = (stbrp_coord) fr.y;
  566|    225|         } else {
  567|      0|            rects[i].x = rects[i].y = STBRP__MAXVAL;
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  568|      0|         }
  569|    225|      }
  570|    225|   }
  571|       |
  572|       |   // unsort
  573|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);
  ------------------
  |  |  118|      2|#define STBRP_SORT          ImQsort
  ------------------
  574|       |
  575|       |   // set was_packed flags and all_rects_packed status
  576|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (576:14): [True: 225, False: 2]
  ------------------
  577|    225|      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|    450|#define STBRP__MAXVAL  0x7fffffff
  ------------------
                    rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  |  Branch (577:31): [True: 0, False: 225]
  |  Branch (577:62): [True: 0, False: 0]
  ------------------
  578|    225|      if (!rects[i].was_packed)
  ------------------
  |  Branch (578:11): [True: 0, False: 225]
  ------------------
  579|      0|         all_rects_packed = 0;
  580|    225|   }
  581|       |
  582|       |   // return the all_rects_packed status
  583|      2|   return all_rects_packed;
  584|      2|}
imgui_draw.cpp:_ZL19rect_height_comparePKvS0_:
  529|  1.40k|{
  530|  1.40k|   const stbrp_rect *p = (const stbrp_rect *) a;
  531|  1.40k|   const stbrp_rect *q = (const stbrp_rect *) b;
  532|  1.40k|   if (p->h > q->h)
  ------------------
  |  Branch (532:8): [True: 224, False: 1.17k]
  ------------------
  533|    224|      return -1;
  534|  1.17k|   if (p->h < q->h)
  ------------------
  |  Branch (534:8): [True: 383, False: 795]
  ------------------
  535|    383|      return  1;
  536|    795|   return (p->w > q->w) ? -1 : (p->w < q->w);
  ------------------
  |  Branch (536:11): [True: 97, False: 698]
  ------------------
  537|  1.17k|}
imgui_draw.cpp:_ZL29stbrp__skyline_pack_rectangleP13stbrp_contextii:
  450|    225|{
  451|       |   // find best position according to heuristic
  452|    225|   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
  453|    225|   stbrp_node *node, *cur;
  454|       |
  455|       |   // bail if:
  456|       |   //    1. it failed
  457|       |   //    2. the best node doesn't fit (we don't always check this)
  458|       |   //    3. we're out of memory
  459|    225|   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
  ------------------
  |  Branch (459:8): [True: 0, False: 225]
  |  Branch (459:33): [True: 0, False: 225]
  |  Branch (459:69): [True: 0, False: 225]
  ------------------
  460|      0|      res.prev_link = NULL;
  461|      0|      return res;
  462|      0|   }
  463|       |
  464|       |   // on success, create new node
  465|    225|   node = context->free_head;
  466|    225|   node->x = (stbrp_coord) res.x;
  467|    225|   node->y = (stbrp_coord) (res.y + height);
  468|       |
  469|    225|   context->free_head = node->next;
  470|       |
  471|       |   // insert the new node into the right starting point, and
  472|       |   // let 'cur' point to the remaining nodes needing to be
  473|       |   // stiched back in
  474|       |
  475|    225|   cur = *res.prev_link;
  476|    225|   if (cur->x < res.x) {
  ------------------
  |  Branch (476:8): [True: 0, False: 225]
  ------------------
  477|       |      // preserve the existing one, so start testing with the next one
  478|      0|      stbrp_node *next = cur->next;
  479|      0|      cur->next = node;
  480|      0|      cur = next;
  481|    225|   } else {
  482|    225|      *res.prev_link = node;
  483|    225|   }
  484|       |
  485|       |   // from here, traverse cur and free the nodes, until we get to one
  486|       |   // that shouldn't be freed
  487|    361|   while (cur->next && cur->next->x <= res.x + width) {
  ------------------
  |  Branch (487:11): [True: 358, False: 3]
  |  Branch (487:24): [True: 136, False: 222]
  ------------------
  488|    136|      stbrp_node *next = cur->next;
  489|       |      // move the current node to the free list
  490|    136|      cur->next = context->free_head;
  491|    136|      context->free_head = cur;
  492|    136|      cur = next;
  493|    136|   }
  494|       |
  495|       |   // stitch the list back in
  496|    225|   node->next = cur;
  497|       |
  498|    225|   if (cur->x < res.x + width)
  ------------------
  |  Branch (498:8): [True: 177, False: 48]
  ------------------
  499|    177|      cur->x = (stbrp_coord) (res.x + width);
  500|       |
  501|       |#ifdef _DEBUG
  502|       |   cur = context->active_head;
  503|       |   while (cur->x < context->width) {
  504|       |      STBRP_ASSERT(cur->x < cur->next->x);
  505|       |      cur = cur->next;
  506|       |   }
  507|       |   STBRP_ASSERT(cur->next == NULL);
  508|       |
  509|       |   {
  510|       |      int count=0;
  511|       |      cur = context->active_head;
  512|       |      while (cur) {
  513|       |         cur = cur->next;
  514|       |         ++count;
  515|       |      }
  516|       |      cur = context->free_head;
  517|       |      while (cur) {
  518|       |         cur = cur->next;
  519|       |         ++count;
  520|       |      }
  521|       |      STBRP_ASSERT(count == context->num_nodes+2);
  522|       |   }
  523|       |#endif
  524|       |
  525|    225|   return res;
  526|    225|}
imgui_draw.cpp:_ZL28stbrp__skyline_find_best_posP13stbrp_contextii:
  348|    225|{
  349|    225|   int best_waste = (1<<30), best_x, best_y = (1 << 30);
  350|    225|   stbrp__findresult fr;
  351|    225|   stbrp_node **prev, *node, *tail, **best = NULL;
  352|       |
  353|       |   // align to multiple of c->align
  354|    225|   width = (width + c->align - 1);
  355|    225|   width -= width % c->align;
  356|    225|   STBRP_ASSERT(width % c->align == 0);
  ------------------
  |  |  117|    225|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  357|       |
  358|       |   // if it can't possibly fit, bail immediately
  359|    225|   if (width > c->width || height > c->height) {
  ------------------
  |  Branch (359:8): [True: 0, False: 225]
  |  Branch (359:28): [True: 0, False: 225]
  ------------------
  360|      0|      fr.prev_link = NULL;
  361|      0|      fr.x = fr.y = 0;
  362|      0|      return fr;
  363|      0|   }
  364|       |
  365|    225|   node = c->active_head;
  366|    225|   prev = &c->active_head;
  367|  11.9k|   while (node->x + width <= c->width) {
  ------------------
  |  Branch (367:11): [True: 11.7k, False: 225]
  ------------------
  368|  11.7k|      int y,waste;
  369|  11.7k|      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
  370|  11.7k|      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
  ------------------
  |  Branch (370:11): [True: 11.7k, False: 0]
  ------------------
  371|       |         // bottom left
  372|  11.7k|         if (y < best_y) {
  ------------------
  |  Branch (372:14): [True: 1.03k, False: 10.7k]
  ------------------
  373|  1.03k|            best_y = y;
  374|  1.03k|            best = prev;
  375|  1.03k|         }
  376|  11.7k|      } else {
  377|       |         // best-fit
  378|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (378:14): [True: 0, False: 0]
  ------------------
  379|       |            // can only use it if it first vertically
  380|      0|            if (y < best_y || (y == best_y && waste < best_waste)) {
  ------------------
  |  Branch (380:17): [True: 0, False: 0]
  |  Branch (380:32): [True: 0, False: 0]
  |  Branch (380:47): [True: 0, False: 0]
  ------------------
  381|      0|               best_y = y;
  382|      0|               best_waste = waste;
  383|      0|               best = prev;
  384|      0|            }
  385|      0|         }
  386|      0|      }
  387|  11.7k|      prev = &node->next;
  388|  11.7k|      node = node->next;
  389|  11.7k|   }
  390|       |
  391|    225|   best_x = (best == NULL) ? 0 : (*best)->x;
  ------------------
  |  Branch (391:13): [True: 0, False: 225]
  ------------------
  392|       |
  393|       |   // if doing best-fit (BF), we also have to try aligning right edge to each node position
  394|       |   //
  395|       |   // e.g, if fitting
  396|       |   //
  397|       |   //     ____________________
  398|       |   //    |____________________|
  399|       |   //
  400|       |   //            into
  401|       |   //
  402|       |   //   |                         |
  403|       |   //   |             ____________|
  404|       |   //   |____________|
  405|       |   //
  406|       |   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
  407|       |   //
  408|       |   // This makes BF take about 2x the time
  409|       |
  410|    225|   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
  ------------------
  |  Branch (410:8): [True: 0, False: 225]
  ------------------
  411|      0|      tail = c->active_head;
  412|      0|      node = c->active_head;
  413|      0|      prev = &c->active_head;
  414|       |      // find first node that's admissible
  415|      0|      while (tail->x < width)
  ------------------
  |  Branch (415:14): [True: 0, False: 0]
  ------------------
  416|      0|         tail = tail->next;
  417|      0|      while (tail) {
  ------------------
  |  Branch (417:14): [True: 0, False: 0]
  ------------------
  418|      0|         int xpos = tail->x - width;
  419|      0|         int y,waste;
  420|      0|         STBRP_ASSERT(xpos >= 0);
  ------------------
  |  |  117|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  421|       |         // find the left position that matches this
  422|      0|         while (node->next->x <= xpos) {
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|            prev = &node->next;
  424|      0|            node = node->next;
  425|      0|         }
  426|      0|         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
  ------------------
  |  |  117|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  427|      0|         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
  428|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (428:14): [True: 0, False: 0]
  ------------------
  429|      0|            if (y <= best_y) {
  ------------------
  |  Branch (429:17): [True: 0, False: 0]
  ------------------
  430|      0|               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
  ------------------
  |  Branch (430:20): [True: 0, False: 0]
  |  Branch (430:34): [True: 0, False: 0]
  |  Branch (430:57): [True: 0, False: 0]
  |  Branch (430:78): [True: 0, False: 0]
  ------------------
  431|      0|                  best_x = xpos;
  432|       |                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
  433|      0|                  best_y = y;
  434|      0|                  best_waste = waste;
  435|      0|                  best = prev;
  436|      0|               }
  437|      0|            }
  438|      0|         }
  439|      0|         tail = tail->next;
  440|      0|      }
  441|      0|   }
  442|       |
  443|    225|   fr.prev_link = best;
  444|    225|   fr.x = best_x;
  445|    225|   fr.y = best_y;
  446|    225|   return fr;
  447|    225|}
imgui_draw.cpp:_ZL25stbrp__skyline_find_min_yP13stbrp_contextP10stbrp_nodeiiPi:
  292|  11.7k|{
  293|  11.7k|   stbrp_node *node = first;
  294|  11.7k|   int x1 = x0 + width;
  295|  11.7k|   int min_y, visited_width, waste_area;
  296|       |
  297|  11.7k|   STBRP__NOTUSED(c);
  ------------------
  |  |  224|  11.7k|#define STBRP__NOTUSED(v)  (void)sizeof(v)
  ------------------
  298|       |
  299|  11.7k|   STBRP_ASSERT(first->x <= x0);
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  300|       |
  301|       |   #if 0
  302|       |   // skip in case we're past the node
  303|       |   while (node->next->x <= x0)
  304|       |      ++node;
  305|       |   #else
  306|  11.7k|   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  307|  11.7k|   #endif
  308|       |
  309|  11.7k|   STBRP_ASSERT(node->x <= x0);
  ------------------
  |  |  117|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (117:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  310|       |
  311|  11.7k|   min_y = 0;
  312|  11.7k|   waste_area = 0;
  313|  11.7k|   visited_width = 0;
  314|  26.9k|   while (node->x < x1) {
  ------------------
  |  Branch (314:11): [True: 15.1k, False: 11.7k]
  ------------------
  315|  15.1k|      if (node->y > min_y) {
  ------------------
  |  Branch (315:11): [True: 11.9k, False: 3.19k]
  ------------------
  316|       |         // raise min_y higher.
  317|       |         // we've accounted for all waste up to min_y,
  318|       |         // but we'll now add more waste for everything we've visted
  319|  11.9k|         waste_area += visited_width * (node->y - min_y);
  320|  11.9k|         min_y = node->y;
  321|       |         // the first time through, visited_width might be reduced
  322|  11.9k|         if (node->x < x0)
  ------------------
  |  Branch (322:14): [True: 0, False: 11.9k]
  ------------------
  323|      0|            visited_width += node->next->x - x0;
  324|  11.9k|         else
  325|  11.9k|            visited_width += node->next->x - node->x;
  326|  11.9k|      } else {
  327|       |         // add waste area
  328|  3.19k|         int under_width = node->next->x - node->x;
  329|  3.19k|         if (under_width + visited_width > width)
  ------------------
  |  Branch (329:14): [True: 2.55k, False: 636]
  ------------------
  330|  2.55k|            under_width = width - visited_width;
  331|  3.19k|         waste_area += under_width * (min_y - node->y);
  332|  3.19k|         visited_width += under_width;
  333|  3.19k|      }
  334|  15.1k|      node = node->next;
  335|  15.1k|   }
  336|       |
  337|  11.7k|   *pwaste = waste_area;
  338|  11.7k|   return min_y;
  339|  11.7k|}
imgui_draw.cpp:_ZL19rect_original_orderPKvS0_:
  540|  1.33k|{
  541|  1.33k|   const stbrp_rect *p = (const stbrp_rect *) a;
  542|  1.33k|   const stbrp_rect *q = (const stbrp_rect *) b;
  543|  1.33k|   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
  ------------------
  |  Branch (543:11): [True: 722, False: 616]
  ------------------
  544|  1.33k|}

imgui_draw.cpp:_ZL27stbtt_GetFontOffsetForIndexPKhi:
 4951|      1|{
 4952|      1|   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
 4953|      1|}
imgui_draw.cpp:_ZL36stbtt_GetFontOffsetForIndex_internalPhi:
 1325|      1|{
 1326|       |   // if it's just a font, there's only one valid index
 1327|      1|   if (stbtt__isfont(font_collection))
  ------------------
  |  Branch (1327:8): [True: 1, False: 0]
  ------------------
 1328|      1|      return index == 0 ? 0 : -1;
  ------------------
  |  Branch (1328:14): [True: 1, False: 0]
  ------------------
 1329|       |
 1330|       |   // check if it's a TTC
 1331|      0|   if (stbtt_tag(font_collection, "ttcf")) {
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1332|       |      // version 1?
 1333|      0|      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
  ------------------
  |  Branch (1333:11): [True: 0, False: 0]
  |  Branch (1333:55): [True: 0, False: 0]
  ------------------
 1334|      0|         stbtt_int32 n = ttLONG(font_collection+8);
 1335|      0|         if (index >= n)
  ------------------
  |  Branch (1335:14): [True: 0, False: 0]
  ------------------
 1336|      0|            return -1;
 1337|      0|         return ttULONG(font_collection+12+index*4);
 1338|      0|      }
 1339|      0|   }
 1340|      0|   return -1;
 1341|      0|}
imgui_draw.cpp:_ZL13stbtt__isfontPh:
 1300|      1|{
 1301|       |   // check the version number
 1302|      1|   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1303|      1|   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1304|      1|   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1305|      1|   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 1, False: 0]
  |  |  |  Branch (1296:54): [True: 1, False: 0]
  |  |  |  Branch (1296:72): [True: 1, False: 0]
  |  |  |  Branch (1296:90): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 1306|      0|   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1307|      0|   return 0;
 1308|      0|}
imgui_draw.cpp:_ZL7ttULONGPh:
 1293|      9|static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
imgui_draw.cpp:_ZL14stbtt_InitFontP14stbtt_fontinfoPKhi:
 4961|      1|{
 4962|      1|   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
 4963|      1|}
imgui_draw.cpp:_ZL23stbtt_InitFont_internalP14stbtt_fontinfoPhi:
 1389|      1|{
 1390|      1|   stbtt_uint32 cmap, t;
 1391|      1|   stbtt_int32 i,numTables;
 1392|       |
 1393|      1|   info->data = data;
 1394|      1|   info->fontstart = fontstart;
 1395|      1|   info->cff = stbtt__new_buf(NULL, 0);
 1396|       |
 1397|      1|   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
 1398|      1|   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
 1399|      1|   info->head = stbtt__find_table(data, fontstart, "head"); // required
 1400|      1|   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
 1401|      1|   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
 1402|      1|   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
 1403|      1|   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
 1404|      1|   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required
 1405|       |
 1406|      1|   if (!cmap || !info->head || !info->hhea || !info->hmtx)
  ------------------
  |  Branch (1406:8): [True: 0, False: 1]
  |  Branch (1406:17): [True: 0, False: 1]
  |  Branch (1406:32): [True: 0, False: 1]
  |  Branch (1406:47): [True: 0, False: 1]
  ------------------
 1407|      0|      return 0;
 1408|      1|   if (info->glyf) {
  ------------------
  |  Branch (1408:8): [True: 1, False: 0]
  ------------------
 1409|       |      // required for truetype
 1410|      1|      if (!info->loca) return 0;
  ------------------
  |  Branch (1410:11): [True: 0, False: 1]
  ------------------
 1411|      1|   } else {
 1412|       |      // initialization for CFF / Type2 fonts (OTF)
 1413|      0|      stbtt__buf b, topdict, topdictidx;
 1414|      0|      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
 1415|      0|      stbtt_uint32 cff;
 1416|       |
 1417|      0|      cff = stbtt__find_table(data, fontstart, "CFF ");
 1418|      0|      if (!cff) return 0;
  ------------------
  |  Branch (1418:11): [True: 0, False: 0]
  ------------------
 1419|       |
 1420|      0|      info->fontdicts = stbtt__new_buf(NULL, 0);
 1421|      0|      info->fdselect = stbtt__new_buf(NULL, 0);
 1422|       |
 1423|       |      // @TODO this should use size from table (not 512MB)
 1424|      0|      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
 1425|      0|      b = info->cff;
 1426|       |
 1427|       |      // read the header
 1428|      0|      stbtt__buf_skip(&b, 2);
 1429|      0|      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize
 1430|       |
 1431|       |      // @TODO the name INDEX could list multiple fonts,
 1432|       |      // but we just use the first one.
 1433|      0|      stbtt__cff_get_index(&b);  // name INDEX
 1434|      0|      topdictidx = stbtt__cff_get_index(&b);
 1435|      0|      topdict = stbtt__cff_index_get(topdictidx, 0);
 1436|      0|      stbtt__cff_get_index(&b);  // string INDEX
 1437|      0|      info->gsubrs = stbtt__cff_get_index(&b);
 1438|       |
 1439|      0|      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
 1440|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
 1441|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
 1442|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
 1443|      0|      info->subrs = stbtt__get_subrs(b, topdict);
 1444|       |
 1445|       |      // we only support Type 2 charstrings
 1446|      0|      if (cstype != 2) return 0;
  ------------------
  |  Branch (1446:11): [True: 0, False: 0]
  ------------------
 1447|      0|      if (charstrings == 0) return 0;
  ------------------
  |  Branch (1447:11): [True: 0, False: 0]
  ------------------
 1448|       |
 1449|      0|      if (fdarrayoff) {
  ------------------
  |  Branch (1449:11): [True: 0, False: 0]
  ------------------
 1450|       |         // looks like a CID font
 1451|      0|         if (!fdselectoff) return 0;
  ------------------
  |  Branch (1451:14): [True: 0, False: 0]
  ------------------
 1452|      0|         stbtt__buf_seek(&b, fdarrayoff);
 1453|      0|         info->fontdicts = stbtt__cff_get_index(&b);
 1454|      0|         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
 1455|      0|      }
 1456|       |
 1457|      0|      stbtt__buf_seek(&b, charstrings);
 1458|      0|      info->charstrings = stbtt__cff_get_index(&b);
 1459|      0|   }
 1460|       |
 1461|      1|   t = stbtt__find_table(data, fontstart, "maxp");
 1462|      1|   if (t)
  ------------------
  |  Branch (1462:8): [True: 1, False: 0]
  ------------------
 1463|      1|      info->numGlyphs = ttUSHORT(data+t+4);
 1464|      0|   else
 1465|      0|      info->numGlyphs = 0xffff;
 1466|       |
 1467|      1|   info->svg = -1;
 1468|       |
 1469|       |   // find a cmap encoding table we understand *now* to avoid searching
 1470|       |   // later. (todo: could make this installable)
 1471|       |   // the same regardless of glyph.
 1472|      1|   numTables = ttUSHORT(data + cmap + 2);
 1473|      1|   info->index_map = 0;
 1474|      4|   for (i=0; i < numTables; ++i) {
  ------------------
  |  Branch (1474:14): [True: 3, False: 1]
  ------------------
 1475|      3|      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
 1476|       |      // find an encoding we understand:
 1477|      3|      switch(ttUSHORT(data+encoding_record)) {
  ------------------
  |  Branch (1477:14): [True: 1, False: 2]
  ------------------
 1478|      1|         case STBTT_PLATFORM_ID_MICROSOFT:
  ------------------
  |  Branch (1478:10): [True: 1, False: 2]
  ------------------
 1479|      1|            switch (ttUSHORT(data+encoding_record+2)) {
  ------------------
  |  Branch (1479:21): [True: 0, False: 1]
  ------------------
 1480|      1|               case STBTT_MS_EID_UNICODE_BMP:
  ------------------
  |  Branch (1480:16): [True: 1, False: 0]
  ------------------
 1481|      1|               case STBTT_MS_EID_UNICODE_FULL:
  ------------------
  |  Branch (1481:16): [True: 0, False: 1]
  ------------------
 1482|       |                  // MS/Unicode
 1483|      1|                  info->index_map = cmap + ttULONG(data+encoding_record+4);
 1484|      1|                  break;
 1485|      1|            }
 1486|      1|            break;
 1487|      1|        case STBTT_PLATFORM_ID_UNICODE:
  ------------------
  |  Branch (1487:9): [True: 1, False: 2]
  ------------------
 1488|       |            // Mac/iOS has these
 1489|       |            // all the encodingIDs are unicode, so we don't bother to check it
 1490|      1|            info->index_map = cmap + ttULONG(data+encoding_record+4);
 1491|      1|            break;
 1492|      3|      }
 1493|      3|   }
 1494|      1|   if (info->index_map == 0)
  ------------------
  |  Branch (1494:8): [True: 0, False: 1]
  ------------------
 1495|      0|      return 0;
 1496|       |
 1497|      1|   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
 1498|      1|   return 1;
 1499|      1|}
imgui_draw.cpp:_ZL14stbtt__new_bufPKvm:
 1174|      1|{
 1175|      1|   stbtt__buf r;
 1176|      1|   STBTT_assert(size < 0x40000000);
  ------------------
  |  |  133|      1|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1177|      1|   r.data = (stbtt_uint8*) p;
 1178|      1|   r.size = (int) size;
 1179|      1|   r.cursor = 0;
 1180|      1|   return r;
 1181|      1|}
imgui_draw.cpp:_ZL17stbtt__find_tablePhjPKc:
 1312|      9|{
 1313|      9|   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
 1314|      9|   stbtt_uint32 tabledir = fontstart + 12;
 1315|      9|   stbtt_int32 i;
 1316|     67|   for (i=0; i < num_tables; ++i) {
  ------------------
  |  Branch (1316:14): [True: 65, False: 2]
  ------------------
 1317|     65|      stbtt_uint32 loc = tabledir + 16*i;
 1318|     65|      if (stbtt_tag(data+loc+0, tag))
  ------------------
  |  | 1297|     65|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|     65|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 10, False: 55]
  |  |  |  |  |  Branch (1296:54): [True: 7, False: 3]
  |  |  |  |  |  Branch (1296:72): [True: 7, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 7, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1319|      7|         return ttULONG(data+loc+8);
 1320|     65|   }
 1321|      2|   return 0;
 1322|      9|}
imgui_draw.cpp:_ZL8ttUSHORTPh:
 1291|  12.9k|static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi:
 1502|    670|{
 1503|    670|   stbtt_uint8 *data = info->data;
 1504|    670|   stbtt_uint32 index_map = info->index_map;
 1505|       |
 1506|    670|   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
 1507|    670|   if (format == 0) { // apple byte encoding
  ------------------
  |  Branch (1507:8): [True: 0, False: 670]
  ------------------
 1508|      0|      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
 1509|      0|      if (unicode_codepoint < bytes-6)
  ------------------
  |  Branch (1509:11): [True: 0, False: 0]
  ------------------
 1510|      0|         return ttBYTE(data + index_map + 6 + unicode_codepoint);
  ------------------
  |  | 1287|      0|#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
  ------------------
 1511|      0|      return 0;
 1512|    670|   } else if (format == 6) {
  ------------------
  |  Branch (1512:15): [True: 0, False: 670]
  ------------------
 1513|      0|      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
 1514|      0|      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
 1515|      0|      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
  ------------------
  |  Branch (1515:11): [True: 0, False: 0]
  |  Branch (1515:56): [True: 0, False: 0]
  ------------------
 1516|      0|         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
 1517|      0|      return 0;
 1518|    670|   } else if (format == 2) {
  ------------------
  |  Branch (1518:15): [True: 0, False: 670]
  ------------------
 1519|      0|      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1520|      0|      return 0;
 1521|    670|   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
  ------------------
  |  Branch (1521:15): [True: 670, False: 0]
  ------------------
 1522|    670|      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
 1523|    670|      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
 1524|    670|      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
 1525|    670|      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;
 1526|       |
 1527|       |      // do a binary search of the segments
 1528|    670|      stbtt_uint32 endCount = index_map + 14;
 1529|    670|      stbtt_uint32 search = endCount;
 1530|       |
 1531|    670|      if (unicode_codepoint > 0xffff)
  ------------------
  |  Branch (1531:11): [True: 0, False: 670]
  ------------------
 1532|      0|         return 0;
 1533|       |
 1534|       |      // they lie from endCount .. endCount + segCount
 1535|       |      // but searchRange is the nearest power of two, so...
 1536|    670|      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
  ------------------
  |  Branch (1536:11): [True: 385, False: 285]
  ------------------
 1537|    385|         search += rangeShift*2;
 1538|       |
 1539|       |      // now decrement to bias correctly to find smallest
 1540|    670|      search -= 2;
 1541|  2.01k|      while (entrySelector) {
  ------------------
  |  Branch (1541:14): [True: 1.34k, False: 670]
  ------------------
 1542|  1.34k|         stbtt_uint16 end;
 1543|  1.34k|         searchRange >>= 1;
 1544|  1.34k|         end = ttUSHORT(data + search + searchRange*2);
 1545|  1.34k|         if (unicode_codepoint > end)
  ------------------
  |  Branch (1545:14): [True: 382, False: 958]
  ------------------
 1546|    382|            search += searchRange*2;
 1547|  1.34k|         --entrySelector;
 1548|  1.34k|      }
 1549|    670|      search += 2;
 1550|       |
 1551|    670|      {
 1552|    670|         stbtt_uint16 offset, start, last;
 1553|    670|         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
 1554|       |
 1555|    670|         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
 1556|    670|         last = ttUSHORT(data + endCount + 2*item);
 1557|    670|         if (unicode_codepoint < start || unicode_codepoint > last)
  ------------------
  |  Branch (1557:14): [True: 1, False: 669]
  |  Branch (1557:43): [True: 0, False: 669]
  ------------------
 1558|      1|            return 0;
 1559|       |
 1560|    669|         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
 1561|    669|         if (offset == 0)
  ------------------
  |  Branch (1561:14): [True: 669, False: 0]
  ------------------
 1562|    669|            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));
 1563|       |
 1564|      0|         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
 1565|    669|      }
 1566|    669|   } else if (format == 12 || format == 13) {
  ------------------
  |  Branch (1566:15): [True: 0, False: 0]
  |  Branch (1566:31): [True: 0, False: 0]
  ------------------
 1567|      0|      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
 1568|      0|      stbtt_int32 low,high;
 1569|      0|      low = 0; high = (stbtt_int32)ngroups;
 1570|       |      // Binary search the right group.
 1571|      0|      while (low < high) {
  ------------------
  |  Branch (1571:14): [True: 0, False: 0]
  ------------------
 1572|      0|         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
 1573|      0|         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
 1574|      0|         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
 1575|      0|         if ((stbtt_uint32) unicode_codepoint < start_char)
  ------------------
  |  Branch (1575:14): [True: 0, False: 0]
  ------------------
 1576|      0|            high = mid;
 1577|      0|         else if ((stbtt_uint32) unicode_codepoint > end_char)
  ------------------
  |  Branch (1577:19): [True: 0, False: 0]
  ------------------
 1578|      0|            low = mid+1;
 1579|      0|         else {
 1580|      0|            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
 1581|      0|            if (format == 12)
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|               return start_glyph + unicode_codepoint-start_char;
 1583|      0|            else // format == 13
 1584|      0|               return start_glyph;
 1585|      0|         }
 1586|      0|      }
 1587|      0|      return 0; // not found
 1588|      0|   }
 1589|       |   // @TODO
 1590|      0|   STBTT_assert(0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1591|      0|   return 0;
 1592|    670|}
imgui_draw.cpp:_ZL7ttSHORTPh:
 1292|  3.90k|static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof:
 2666|      3|{
 2667|      3|   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
 2668|      3|   return (float) height / fheight;
 2669|      3|}
imgui_draw.cpp:_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_:
 2727|    669|{
 2728|    669|   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
 2729|    669|   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
  ------------------
  |  Branch (2729:8): [True: 27, False: 642]
  ------------------
 2730|       |      // e.g. space character
 2731|     27|      if (ix0) *ix0 = 0;
  ------------------
  |  Branch (2731:11): [True: 27, False: 0]
  ------------------
 2732|     27|      if (iy0) *iy0 = 0;
  ------------------
  |  Branch (2732:11): [True: 27, False: 0]
  ------------------
 2733|     27|      if (ix1) *ix1 = 0;
  ------------------
  |  Branch (2733:11): [True: 18, False: 9]
  ------------------
 2734|     27|      if (iy1) *iy1 = 0;
  ------------------
  |  Branch (2734:11): [True: 18, False: 9]
  ------------------
 2735|    642|   } else {
 2736|       |      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
 2737|    642|      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
  ------------------
  |  |  138|    642|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
  |  Branch (2737:11): [True: 642, False: 0]
  ------------------
 2738|    642|      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
  ------------------
  |  |  138|    642|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
  |  Branch (2738:11): [True: 642, False: 0]
  ------------------
 2739|    642|      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
  ------------------
  |  |  139|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  445|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2739:11): [True: 428, False: 214]
  ------------------
 2740|    642|      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
  ------------------
  |  |  139|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  445|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2740:11): [True: 428, False: 214]
  ------------------
 2741|    642|   }
 2742|    669|}
imgui_draw.cpp:_ZL17stbtt_GetGlyphBoxPK14stbtt_fontinfoiPiS2_S2_S2_:
 1631|    669|{
 1632|    669|   if (info->cff.size) {
  ------------------
  |  Branch (1632:8): [True: 0, False: 669]
  ------------------
 1633|      0|      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
 1634|    669|   } else {
 1635|    669|      int g = stbtt__GetGlyfOffset(info, glyph_index);
 1636|    669|      if (g < 0) return 0;
  ------------------
  |  Branch (1636:11): [True: 27, False: 642]
  ------------------
 1637|       |
 1638|    642|      if (x0) *x0 = ttSHORT(info->data + g + 2);
  ------------------
  |  Branch (1638:11): [True: 642, False: 0]
  ------------------
 1639|    642|      if (y0) *y0 = ttSHORT(info->data + g + 4);
  ------------------
  |  Branch (1639:11): [True: 642, False: 0]
  ------------------
 1640|    642|      if (x1) *x1 = ttSHORT(info->data + g + 6);
  ------------------
  |  Branch (1640:11): [True: 642, False: 0]
  ------------------
 1641|    642|      if (y1) *y1 = ttSHORT(info->data + g + 8);
  ------------------
  |  Branch (1641:11): [True: 642, False: 0]
  ------------------
 1642|    642|   }
 1643|    642|   return 1;
 1644|    669|}
imgui_draw.cpp:_ZL15stbtt_setvertexP12stbtt_vertexhiiii:
 1600|  15.8k|{
 1601|  15.8k|   v->type = type;
 1602|  15.8k|   v->x = (stbtt_int16) x;
 1603|  15.8k|   v->y = (stbtt_int16) y;
 1604|  15.8k|   v->cx = (stbtt_int16) cx;
 1605|  15.8k|   v->cy = (stbtt_int16) cy;
 1606|  15.8k|}
imgui_draw.cpp:_ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi:
 1609|    892|{
 1610|    892|   int g1,g2;
 1611|       |
 1612|    892|   STBTT_assert(!info->cff.size);
  ------------------
  |  |  133|    892|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|    892|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1613|       |
 1614|    892|   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
  ------------------
  |  Branch (1614:8): [True: 0, False: 892]
  ------------------
 1615|    892|   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format
  ------------------
  |  Branch (1615:8): [True: 0, False: 892]
  ------------------
 1616|       |
 1617|    892|   if (info->indexToLocFormat == 0) {
  ------------------
  |  Branch (1617:8): [True: 892, False: 0]
  ------------------
 1618|    892|      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
 1619|    892|      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
 1620|    892|   } else {
 1621|      0|      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
 1622|      0|      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
 1623|      0|   }
 1624|       |
 1625|    892|   return g1==g2 ? -1 : g1; // if length is 0, return -1
  ------------------
  |  Branch (1625:11): [True: 36, False: 856]
  ------------------
 1626|    892|}
imgui_draw.cpp:_ZL15stbtt_PackBeginP18stbtt_pack_contextPhiiiiPv:
 3966|      1|{
 3967|      1|   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
  ------------------
  |  |  131|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3968|      1|   int            num_nodes = pw - padding;
 3969|      1|   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);
  ------------------
  |  |  131|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3970|       |
 3971|      1|   if (context == NULL || nodes == NULL) {
  ------------------
  |  Branch (3971:8): [True: 0, False: 1]
  |  Branch (3971:27): [True: 0, False: 1]
  ------------------
 3972|      0|      if (context != NULL) STBTT_free(context, alloc_context);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3972:11): [True: 0, False: 0]
  ------------------
 3973|      0|      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3973:11): [True: 0, False: 0]
  ------------------
 3974|      0|      return 0;
 3975|      0|   }
 3976|       |
 3977|      1|   spc->user_allocator_context = alloc_context;
 3978|      1|   spc->width = pw;
 3979|      1|   spc->height = ph;
 3980|      1|   spc->pixels = pixels;
 3981|      1|   spc->pack_info = context;
 3982|      1|   spc->nodes = nodes;
 3983|      1|   spc->padding = padding;
 3984|      1|   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
  ------------------
  |  Branch (3984:27): [True: 0, False: 1]
  ------------------
 3985|      1|   spc->h_oversample = 1;
 3986|      1|   spc->v_oversample = 1;
 3987|      1|   spc->skip_missing = 0;
 3988|       |
 3989|      1|   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
 3990|       |
 3991|      1|   if (pixels)
  ------------------
  |  Branch (3991:8): [True: 0, False: 1]
  ------------------
 3992|      0|      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
  ------------------
  |  |  493|      0|   #define STBTT_memset       memset
  ------------------
 3993|       |
 3994|      1|   return 1;
 3995|      1|}
imgui_draw.cpp:_ZL35stbtt_PackFontRangesRenderIntoRectsP18stbtt_pack_contextPK14stbtt_fontinfoP16stbtt_pack_rangeiP10stbrp_rect:
 4217|      1|{
 4218|      1|   int i,j,k, missing_glyph = -1, return_value = 1;
 4219|       |
 4220|       |   // save current values
 4221|      1|   int old_h_over = spc->h_oversample;
 4222|      1|   int old_v_over = spc->v_oversample;
 4223|       |
 4224|      1|   k = 0;
 4225|      2|   for (i=0; i < num_ranges; ++i) {
  ------------------
  |  Branch (4225:14): [True: 1, False: 1]
  ------------------
 4226|      1|      float fh = ranges[i].font_size;
 4227|      1|      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
  ------------------
  |  Branch (4227:21): [True: 1, False: 0]
  ------------------
 4228|      1|      float recip_h,recip_v,sub_x,sub_y;
 4229|      1|      spc->h_oversample = ranges[i].h_oversample;
 4230|      1|      spc->v_oversample = ranges[i].v_oversample;
 4231|      1|      recip_h = 1.0f / spc->h_oversample;
 4232|      1|      recip_v = 1.0f / spc->v_oversample;
 4233|      1|      sub_x = stbtt__oversample_shift(spc->h_oversample);
 4234|      1|      sub_y = stbtt__oversample_shift(spc->v_oversample);
 4235|    224|      for (j=0; j < ranges[i].num_chars; ++j) {
  ------------------
  |  Branch (4235:17): [True: 223, False: 1]
  ------------------
 4236|    223|         stbrp_rect *r = &rects[k];
 4237|    223|         if (r->was_packed && r->w != 0 && r->h != 0) {
  ------------------
  |  Branch (4237:14): [True: 223, False: 0]
  |  Branch (4237:31): [True: 223, False: 0]
  |  Branch (4237:44): [True: 223, False: 0]
  ------------------
 4238|    223|            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
 4239|    223|            int advance, lsb, x0,y0,x1,y1;
 4240|    223|            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
  ------------------
  |  Branch (4240:29): [True: 0, False: 223]
  ------------------
 4241|    223|            int glyph = stbtt_FindGlyphIndex(info, codepoint);
 4242|    223|            stbrp_coord pad = (stbrp_coord) spc->padding;
 4243|       |
 4244|       |            // pad on left and top
 4245|    223|            r->x += pad;
 4246|    223|            r->y += pad;
 4247|    223|            r->w -= pad;
 4248|    223|            r->h -= pad;
 4249|    223|            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
 4250|    223|            stbtt_GetGlyphBitmapBox(info, glyph,
 4251|    223|                                    scale * spc->h_oversample,
 4252|    223|                                    scale * spc->v_oversample,
 4253|    223|                                    &x0,&y0,&x1,&y1);
 4254|    223|            stbtt_MakeGlyphBitmapSubpixel(info,
 4255|    223|                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4256|    223|                                          r->w - spc->h_oversample+1,
 4257|    223|                                          r->h - spc->v_oversample+1,
 4258|    223|                                          spc->stride_in_bytes,
 4259|    223|                                          scale * spc->h_oversample,
 4260|    223|                                          scale * spc->v_oversample,
 4261|    223|                                          0,0,
 4262|    223|                                          glyph);
 4263|       |
 4264|    223|            if (spc->h_oversample > 1)
  ------------------
  |  Branch (4264:17): [True: 0, False: 223]
  ------------------
 4265|      0|               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4266|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4267|      0|                                  spc->h_oversample);
 4268|       |
 4269|    223|            if (spc->v_oversample > 1)
  ------------------
  |  Branch (4269:17): [True: 0, False: 223]
  ------------------
 4270|      0|               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4271|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4272|      0|                                  spc->v_oversample);
 4273|       |
 4274|    223|            bc->x0       = (stbtt_int16)  r->x;
 4275|    223|            bc->y0       = (stbtt_int16)  r->y;
 4276|    223|            bc->x1       = (stbtt_int16) (r->x + r->w);
 4277|    223|            bc->y1       = (stbtt_int16) (r->y + r->h);
 4278|    223|            bc->xadvance =                scale * advance;
 4279|    223|            bc->xoff     =       (float)  x0 * recip_h + sub_x;
 4280|    223|            bc->yoff     =       (float)  y0 * recip_v + sub_y;
 4281|    223|            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
 4282|    223|            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
 4283|       |
 4284|    223|            if (glyph == 0)
  ------------------
  |  Branch (4284:17): [True: 0, False: 223]
  ------------------
 4285|      0|               missing_glyph = j;
 4286|    223|         } else if (spc->skip_missing) {
  ------------------
  |  Branch (4286:21): [True: 0, False: 0]
  ------------------
 4287|      0|            return_value = 0;
 4288|      0|         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
  ------------------
  |  Branch (4288:21): [True: 0, False: 0]
  |  Branch (4288:38): [True: 0, False: 0]
  |  Branch (4288:51): [True: 0, False: 0]
  |  Branch (4288:64): [True: 0, False: 0]
  ------------------
 4289|      0|            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
 4290|      0|         } else {
 4291|      0|            return_value = 0; // if any fail, report failure
 4292|      0|         }
 4293|       |
 4294|    223|         ++k;
 4295|    223|      }
 4296|      1|   }
 4297|       |
 4298|       |   // restore original values
 4299|      1|   spc->h_oversample = old_h_over;
 4300|      1|   spc->v_oversample = old_v_over;
 4301|       |
 4302|      1|   return return_value;
 4303|      1|}
imgui_draw.cpp:_ZL23stbtt__oversample_shifti:
 4145|      2|{
 4146|      2|   if (!oversample)
  ------------------
  |  Branch (4146:8): [True: 0, False: 2]
  ------------------
 4147|      0|      return 0.0f;
 4148|       |
 4149|       |   // The prefilter is a box filter of width "oversample",
 4150|       |   // which shifts phase by (oversample - 1)/2 pixels in
 4151|       |   // oversampled space. We want to shift in the opposite
 4152|       |   // direction to counter this.
 4153|      2|   return (float)-(oversample - 1) / (2.0f * (float)oversample);
 4154|      2|}
imgui_draw.cpp:_ZL22stbtt_GetGlyphHMetricsPK14stbtt_fontinfoiPiS2_:
 2311|    223|{
 2312|    223|   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
 2313|    223|   if (glyph_index < numOfLongHorMetrics) {
  ------------------
  |  Branch (2313:8): [True: 0, False: 223]
  ------------------
 2314|      0|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
  ------------------
  |  Branch (2314:11): [True: 0, False: 0]
  ------------------
 2315|      0|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
  ------------------
  |  Branch (2315:11): [True: 0, False: 0]
  ------------------
 2316|    223|   } else {
 2317|    223|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
  ------------------
  |  Branch (2317:11): [True: 223, False: 0]
  ------------------
 2318|    223|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
  ------------------
  |  Branch (2318:11): [True: 223, False: 0]
  ------------------
 2319|    223|   }
 2320|    223|}
imgui_draw.cpp:_ZL23stbtt_GetGlyphBitmapBoxPK14stbtt_fontinfoiffPiS2_S2_S2_:
 2745|    223|{
 2746|    223|   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
 2747|    223|}
imgui_draw.cpp:_ZL29stbtt_MakeGlyphBitmapSubpixelPK14stbtt_fontinfoPhiiiffffi:
 3767|    223|{
 3768|    223|   int ix0,iy0;
 3769|    223|   stbtt_vertex *vertices;
 3770|    223|   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
 3771|    223|   stbtt__bitmap gbm;
 3772|       |
 3773|    223|   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
 3774|    223|   gbm.pixels = output;
 3775|    223|   gbm.w = out_w;
 3776|    223|   gbm.h = out_h;
 3777|    223|   gbm.stride = out_stride;
 3778|       |
 3779|    223|   if (gbm.w && gbm.h)
  ------------------
  |  Branch (3779:8): [True: 214, False: 9]
  |  Branch (3779:17): [True: 214, False: 0]
  ------------------
 3780|    214|      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);
 3781|       |
 3782|    223|   STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|    223|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|    223|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3783|    223|}
imgui_draw.cpp:_ZL19stbtt_GetGlyphShapePK14stbtt_fontinfoiPP12stbtt_vertex:
 2303|    223|{
 2304|    223|   if (!info->cff.size)
  ------------------
  |  Branch (2304:8): [True: 223, False: 0]
  ------------------
 2305|    223|      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
 2306|      0|   else
 2307|      0|      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
 2308|    223|}
imgui_draw.cpp:_ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex:
 1680|    223|{
 1681|    223|   stbtt_int16 numberOfContours;
 1682|    223|   stbtt_uint8 *endPtsOfContours;
 1683|    223|   stbtt_uint8 *data = info->data;
 1684|    223|   stbtt_vertex *vertices=0;
 1685|    223|   int num_vertices=0;
 1686|    223|   int g = stbtt__GetGlyfOffset(info, glyph_index);
 1687|       |
 1688|    223|   *pvertices = NULL;
 1689|       |
 1690|    223|   if (g < 0) return 0;
  ------------------
  |  Branch (1690:8): [True: 9, False: 214]
  ------------------
 1691|       |
 1692|    214|   numberOfContours = ttSHORT(data + g);
 1693|       |
 1694|    214|   if (numberOfContours > 0) {
  ------------------
  |  Branch (1694:8): [True: 214, False: 0]
  ------------------
 1695|    214|      stbtt_uint8 flags=0,flagcount;
 1696|    214|      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
 1697|    214|      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
 1698|    214|      stbtt_uint8 *points;
 1699|    214|      endPtsOfContours = (data + g + 10);
 1700|    214|      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
 1701|    214|      points = data + g + 10 + numberOfContours * 2 + 2 + ins;
 1702|       |
 1703|    214|      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);
 1704|       |
 1705|    214|      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
 1706|    214|      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1707|    214|      if (vertices == 0)
  ------------------
  |  Branch (1707:11): [True: 0, False: 214]
  ------------------
 1708|      0|         return 0;
 1709|       |
 1710|    214|      next_move = 0;
 1711|    214|      flagcount=0;
 1712|       |
 1713|       |      // in first pass, we load uninterpreted data into the allocated array
 1714|       |      // above, shifted to the end of the array so we won't overwrite it when
 1715|       |      // we create our final data starting from the front
 1716|       |
 1717|    214|      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
 1718|       |
 1719|       |      // first load flags
 1720|       |
 1721|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1721:17): [True: 12.6k, False: 214]
  ------------------
 1722|  12.6k|         if (flagcount == 0) {
  ------------------
  |  Branch (1722:14): [True: 12.5k, False: 63]
  ------------------
 1723|  12.5k|            flags = *points++;
 1724|  12.5k|            if (flags & 8)
  ------------------
  |  Branch (1724:17): [True: 63, False: 12.5k]
  ------------------
 1725|     63|               flagcount = *points++;
 1726|  12.5k|         } else
 1727|     63|            --flagcount;
 1728|  12.6k|         vertices[off+i].type = flags;
 1729|  12.6k|      }
 1730|       |
 1731|       |      // now load x coordinates
 1732|    214|      x=0;
 1733|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1733:17): [True: 12.6k, False: 214]
  ------------------
 1734|  12.6k|         flags = vertices[off+i].type;
 1735|  12.6k|         if (flags & 2) {
  ------------------
  |  Branch (1735:14): [True: 3.76k, False: 8.87k]
  ------------------
 1736|  3.76k|            stbtt_int16 dx = *points++;
 1737|  3.76k|            x += (flags & 16) ? dx : -dx; // ???
  ------------------
  |  Branch (1737:18): [True: 3.41k, False: 350]
  ------------------
 1738|  8.87k|         } else {
 1739|  8.87k|            if (!(flags & 16)) {
  ------------------
  |  Branch (1739:17): [True: 1.56k, False: 7.30k]
  ------------------
 1740|  1.56k|               x = x + (stbtt_int16) (points[0]*256 + points[1]);
 1741|  1.56k|               points += 2;
 1742|  1.56k|            }
 1743|  8.87k|         }
 1744|  12.6k|         vertices[off+i].x = (stbtt_int16) x;
 1745|  12.6k|      }
 1746|       |
 1747|       |      // now load y coordinates
 1748|    214|      y=0;
 1749|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1749:17): [True: 12.6k, False: 214]
  ------------------
 1750|  12.6k|         flags = vertices[off+i].type;
 1751|  12.6k|         if (flags & 4) {
  ------------------
  |  Branch (1751:14): [True: 7.59k, False: 5.04k]
  ------------------
 1752|  7.59k|            stbtt_int16 dy = *points++;
 1753|  7.59k|            y += (flags & 32) ? dy : -dy; // ???
  ------------------
  |  Branch (1753:18): [True: 3.16k, False: 4.43k]
  ------------------
 1754|  7.59k|         } else {
 1755|  5.04k|            if (!(flags & 32)) {
  ------------------
  |  Branch (1755:17): [True: 273, False: 4.77k]
  ------------------
 1756|    273|               y = y + (stbtt_int16) (points[0]*256 + points[1]);
 1757|    273|               points += 2;
 1758|    273|            }
 1759|  5.04k|         }
 1760|  12.6k|         vertices[off+i].y = (stbtt_int16) y;
 1761|  12.6k|      }
 1762|       |
 1763|       |      // now convert them to our format
 1764|    214|      num_vertices=0;
 1765|    214|      sx = sy = cx = cy = scx = scy = 0;
 1766|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1766:17): [True: 12.6k, False: 214]
  ------------------
 1767|  12.6k|         flags = vertices[off+i].type;
 1768|  12.6k|         x     = (stbtt_int16) vertices[off+i].x;
 1769|  12.6k|         y     = (stbtt_int16) vertices[off+i].y;
 1770|       |
 1771|  12.6k|         if (next_move == i) {
  ------------------
  |  Branch (1771:14): [True: 3.16k, False: 9.48k]
  ------------------
 1772|  3.16k|            if (i != 0)
  ------------------
  |  Branch (1772:17): [True: 2.94k, False: 214]
  ------------------
 1773|  2.94k|               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1774|       |
 1775|       |            // now start the new one
 1776|  3.16k|            start_off = !(flags & 1);
 1777|  3.16k|            if (start_off) {
  ------------------
  |  Branch (1777:17): [True: 0, False: 3.16k]
  ------------------
 1778|       |               // if we start off with an off-curve point, then when we need to find a point on the curve
 1779|       |               // where we can start, and we need to save some state for when we wraparound.
 1780|      0|               scx = x;
 1781|      0|               scy = y;
 1782|      0|               if (!(vertices[off+i+1].type & 1)) {
  ------------------
  |  Branch (1782:20): [True: 0, False: 0]
  ------------------
 1783|       |                  // next point is also a curve point, so interpolate an on-point curve
 1784|      0|                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
 1785|      0|                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
 1786|      0|               } else {
 1787|       |                  // otherwise just use the next point as our start point
 1788|      0|                  sx = (stbtt_int32) vertices[off+i+1].x;
 1789|      0|                  sy = (stbtt_int32) vertices[off+i+1].y;
 1790|      0|                  ++i; // we're using point i+1 as the starting point, so skip it
 1791|      0|               }
 1792|  3.16k|            } else {
 1793|  3.16k|               sx = x;
 1794|  3.16k|               sy = y;
 1795|  3.16k|            }
 1796|  3.16k|            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
 1797|  3.16k|            was_off = 0;
 1798|  3.16k|            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
 1799|  3.16k|            ++j;
 1800|  9.48k|         } else {
 1801|  9.48k|            if (!(flags & 1)) { // if it's a curve
  ------------------
  |  Branch (1801:17): [True: 0, False: 9.48k]
  ------------------
 1802|      0|               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
  ------------------
  |  Branch (1802:20): [True: 0, False: 0]
  ------------------
 1803|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
 1804|      0|               cx = x;
 1805|      0|               cy = y;
 1806|      0|               was_off = 1;
 1807|  9.48k|            } else {
 1808|  9.48k|               if (was_off)
  ------------------
  |  Branch (1808:20): [True: 0, False: 9.48k]
  ------------------
 1809|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
 1810|  9.48k|               else
 1811|  9.48k|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
 1812|  9.48k|               was_off = 0;
 1813|  9.48k|            }
 1814|  9.48k|         }
 1815|  12.6k|      }
 1816|    214|      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1817|    214|   } else if (numberOfContours < 0) {
  ------------------
  |  Branch (1817:15): [True: 0, False: 0]
  ------------------
 1818|       |      // Compound shapes.
 1819|      0|      int more = 1;
 1820|      0|      stbtt_uint8 *comp = data + g + 10;
 1821|      0|      num_vertices = 0;
 1822|      0|      vertices = 0;
 1823|      0|      while (more) {
  ------------------
  |  Branch (1823:14): [True: 0, False: 0]
  ------------------
 1824|      0|         stbtt_uint16 flags, gidx;
 1825|      0|         int comp_num_verts = 0, i;
 1826|      0|         stbtt_vertex *comp_verts = 0, *tmp = 0;
 1827|      0|         float mtx[6] = {1,0,0,1,0,0}, m, n;
 1828|       |
 1829|      0|         flags = ttSHORT(comp); comp+=2;
 1830|      0|         gidx = ttSHORT(comp); comp+=2;
 1831|       |
 1832|      0|         if (flags & 2) { // XY values
  ------------------
  |  Branch (1832:14): [True: 0, False: 0]
  ------------------
 1833|      0|            if (flags & 1) { // shorts
  ------------------
  |  Branch (1833:17): [True: 0, False: 0]
  ------------------
 1834|      0|               mtx[4] = ttSHORT(comp); comp+=2;
 1835|      0|               mtx[5] = ttSHORT(comp); comp+=2;
 1836|      0|            } else {
 1837|      0|               mtx[4] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1838|      0|               mtx[5] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1839|      0|            }
 1840|      0|         }
 1841|      0|         else {
 1842|       |            // @TODO handle matching point
 1843|      0|            STBTT_assert(0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1844|      0|         }
 1845|      0|         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
  ------------------
  |  Branch (1845:14): [True: 0, False: 0]
  ------------------
 1846|      0|            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1847|      0|            mtx[1] = mtx[2] = 0;
 1848|      0|         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
  ------------------
  |  Branch (1848:21): [True: 0, False: 0]
  ------------------
 1849|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1850|      0|            mtx[1] = mtx[2] = 0;
 1851|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1852|      0|         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
  ------------------
  |  Branch (1852:21): [True: 0, False: 0]
  ------------------
 1853|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1854|      0|            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
 1855|      0|            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
 1856|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1857|      0|         }
 1858|       |
 1859|       |         // Find transformation scales.
 1860|      0|         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
  ------------------
  |  |  135|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  437|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1861|      0|         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);
  ------------------
  |  |  135|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  437|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1862|       |
 1863|       |         // Get indexed glyph.
 1864|      0|         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
 1865|      0|         if (comp_num_verts > 0) {
  ------------------
  |  Branch (1865:14): [True: 0, False: 0]
  ------------------
 1866|       |            // Transform vertices.
 1867|      0|            for (i = 0; i < comp_num_verts; ++i) {
  ------------------
  |  Branch (1867:25): [True: 0, False: 0]
  ------------------
 1868|      0|               stbtt_vertex* v = &comp_verts[i];
 1869|      0|               stbtt_vertex_type x,y;
  ------------------
  |  |  839|      0|   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
  ------------------
 1870|      0|               x=v->x; y=v->y;
 1871|      0|               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1872|      0|               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1873|      0|               x=v->cx; y=v->cy;
 1874|      0|               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1875|      0|               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1876|      0|            }
 1877|       |            // Append vertices.
 1878|      0|            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
  ------------------
  |  |  131|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1879|      0|            if (!tmp) {
  ------------------
  |  Branch (1879:17): [True: 0, False: 0]
  ------------------
 1880|      0|               if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1880:20): [True: 0, False: 0]
  ------------------
 1881|      0|               if (comp_verts) STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1881:20): [True: 0, False: 0]
  ------------------
 1882|      0|               return 0;
 1883|      0|            }
 1884|      0|            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
  |  Branch (1884:17): [True: 0, False: 0]
  |  Branch (1884:37): [True: 0, False: 0]
  ------------------
 1885|      0|            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
 1886|      0|            if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1886:17): [True: 0, False: 0]
  ------------------
 1887|      0|            vertices = tmp;
 1888|      0|            STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 1889|      0|            num_vertices += comp_num_verts;
 1890|      0|         }
 1891|       |         // More components ?
 1892|      0|         more = flags & (1<<5);
 1893|      0|      }
 1894|      0|   } else {
 1895|       |      // numberOfCounters == 0, do nothing
 1896|      0|   }
 1897|       |
 1898|    214|   *pvertices = vertices;
 1899|    214|   return num_vertices;
 1900|    214|}
imgui_draw.cpp:_ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii:
 1665|  3.16k|{
 1666|  3.16k|   if (start_off) {
  ------------------
  |  Branch (1666:8): [True: 0, False: 3.16k]
  ------------------
 1667|      0|      if (was_off)
  ------------------
  |  Branch (1667:11): [True: 0, False: 0]
  ------------------
 1668|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
 1669|      0|      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
 1670|  3.16k|   } else {
 1671|  3.16k|      if (was_off)
  ------------------
  |  Branch (1671:11): [True: 0, False: 3.16k]
  ------------------
 1672|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
 1673|  3.16k|      else
 1674|  3.16k|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
 1675|  3.16k|   }
 1676|  3.16k|   return num_vertices;
 1677|  3.16k|}
imgui_draw.cpp:_ZL15stbtt_RasterizeP13stbtt__bitmapfP12stbtt_vertexiffffiiiPv:
 3704|    214|{
 3705|    214|   float scale            = scale_x > scale_y ? scale_y : scale_x;
  ------------------
  |  Branch (3705:29): [True: 0, False: 214]
  ------------------
 3706|    214|   int winding_count      = 0;
 3707|    214|   int *winding_lengths   = NULL;
 3708|    214|   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
 3709|    214|   if (windings) {
  ------------------
  |  Branch (3709:8): [True: 214, False: 0]
  ------------------
 3710|    214|      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
 3711|    214|      STBTT_free(winding_lengths, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3712|    214|      STBTT_free(windings, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3713|    214|   }
 3714|    214|}
imgui_draw.cpp:_ZL19stbtt_FlattenCurvesP12stbtt_vertexifPPiS1_Pv:
 3627|    214|{
 3628|    214|   stbtt__point *points=0;
 3629|    214|   int num_points=0;
 3630|       |
 3631|    214|   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
 3632|    214|   int i,n=0,start=0, pass;
 3633|       |
 3634|       |   // count how many "moves" there are to get the contour count
 3635|  16.0k|   for (i=0; i < num_verts; ++i)
  ------------------
  |  Branch (3635:14): [True: 15.8k, False: 214]
  ------------------
 3636|  15.8k|      if (vertices[i].type == STBTT_vmove)
  ------------------
  |  Branch (3636:11): [True: 3.16k, False: 12.6k]
  ------------------
 3637|  3.16k|         ++n;
 3638|       |
 3639|    214|   *num_contours = n;
 3640|    214|   if (n == 0) return 0;
  ------------------
  |  Branch (3640:8): [True: 0, False: 214]
  ------------------
 3641|       |
 3642|    214|   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3643|       |
 3644|    214|   if (*contour_lengths == 0) {
  ------------------
  |  Branch (3644:8): [True: 0, False: 214]
  ------------------
 3645|      0|      *num_contours = 0;
 3646|      0|      return 0;
 3647|      0|   }
 3648|       |
 3649|       |   // make two passes through the points so we don't need to realloc
 3650|    642|   for (pass=0; pass < 2; ++pass) {
  ------------------
  |  Branch (3650:17): [True: 428, False: 214]
  ------------------
 3651|    428|      float x=0,y=0;
 3652|    428|      if (pass == 1) {
  ------------------
  |  Branch (3652:11): [True: 214, False: 214]
  ------------------
 3653|    214|         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3654|    214|         if (points == NULL) goto error;
  ------------------
  |  Branch (3654:14): [True: 0, False: 214]
  ------------------
 3655|    214|      }
 3656|    428|      num_points = 0;
 3657|    428|      n= -1;
 3658|  32.0k|      for (i=0; i < num_verts; ++i) {
  ------------------
  |  Branch (3658:17): [True: 31.6k, False: 428]
  ------------------
 3659|  31.6k|         switch (vertices[i].type) {
  ------------------
  |  Branch (3659:18): [True: 0, False: 31.6k]
  ------------------
 3660|  6.32k|            case STBTT_vmove:
  ------------------
  |  Branch (3660:13): [True: 6.32k, False: 25.2k]
  ------------------
 3661|       |               // start the next contour
 3662|  6.32k|               if (n >= 0)
  ------------------
  |  Branch (3662:20): [True: 5.89k, False: 428]
  ------------------
 3663|  5.89k|                  (*contour_lengths)[n] = num_points - start;
 3664|  6.32k|               ++n;
 3665|  6.32k|               start = num_points;
 3666|       |
 3667|  6.32k|               x = vertices[i].x, y = vertices[i].y;
 3668|  6.32k|               stbtt__add_point(points, num_points++, x,y);
 3669|  6.32k|               break;
 3670|  25.2k|            case STBTT_vline:
  ------------------
  |  Branch (3670:13): [True: 25.2k, False: 6.32k]
  ------------------
 3671|  25.2k|               x = vertices[i].x, y = vertices[i].y;
 3672|  25.2k|               stbtt__add_point(points, num_points++, x, y);
 3673|  25.2k|               break;
 3674|      0|            case STBTT_vcurve:
  ------------------
  |  Branch (3674:13): [True: 0, False: 31.6k]
  ------------------
 3675|      0|               stbtt__tesselate_curve(points, &num_points, x,y,
 3676|      0|                                        vertices[i].cx, vertices[i].cy,
 3677|      0|                                        vertices[i].x,  vertices[i].y,
 3678|      0|                                        objspace_flatness_squared, 0);
 3679|      0|               x = vertices[i].x, y = vertices[i].y;
 3680|      0|               break;
 3681|      0|            case STBTT_vcubic:
  ------------------
  |  Branch (3681:13): [True: 0, False: 31.6k]
  ------------------
 3682|      0|               stbtt__tesselate_cubic(points, &num_points, x,y,
 3683|      0|                                        vertices[i].cx, vertices[i].cy,
 3684|      0|                                        vertices[i].cx1, vertices[i].cy1,
 3685|      0|                                        vertices[i].x,  vertices[i].y,
 3686|      0|                                        objspace_flatness_squared, 0);
 3687|      0|               x = vertices[i].x, y = vertices[i].y;
 3688|      0|               break;
 3689|  31.6k|         }
 3690|  31.6k|      }
 3691|    428|      (*contour_lengths)[n] = num_points - start;
 3692|    428|   }
 3693|       |
 3694|    214|   return points;
 3695|      0|error:
 3696|      0|   STBTT_free(points, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3697|      0|   STBTT_free(*contour_lengths, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3698|      0|   *contour_lengths = 0;
 3699|      0|   *num_contours = 0;
 3700|      0|   return NULL;
 3701|    214|}
imgui_draw.cpp:_ZL16stbtt__add_pointP12stbtt__pointiff:
 3556|  31.6k|{
 3557|  31.6k|   if (!points) return; // during first pass, it's unallocated
  ------------------
  |  Branch (3557:8): [True: 15.8k, False: 15.8k]
  ------------------
 3558|  15.8k|   points[n].x = x;
 3559|  15.8k|   points[n].y = y;
 3560|  15.8k|}
imgui_draw.cpp:_ZL16stbtt__rasterizeP13stbtt__bitmapP12stbtt__pointPiiffffiiiPv:
 3499|    214|{
 3500|    214|   float y_scale_inv = invert ? -scale_y : scale_y;
  ------------------
  |  Branch (3500:24): [True: 214, False: 0]
  ------------------
 3501|    214|   stbtt__edge *e;
 3502|    214|   int n,i,j,k,m;
 3503|       |#if STBTT_RASTERIZER_VERSION == 1
 3504|       |   int vsubsample = result->h < 8 ? 15 : 5;
 3505|       |#elif STBTT_RASTERIZER_VERSION == 2
 3506|    214|   int vsubsample = 1;
 3507|       |#else
 3508|       |   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
 3509|       |#endif
 3510|       |   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
 3511|       |
 3512|       |   // now we have to blow out the windings into explicit edge lists
 3513|    214|   n = 0;
 3514|  3.37k|   for (i=0; i < windings; ++i)
  ------------------
  |  Branch (3514:14): [True: 3.16k, False: 214]
  ------------------
 3515|  3.16k|      n += wcount[i];
 3516|       |
 3517|    214|   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3518|    214|   if (e == 0) return;
  ------------------
  |  Branch (3518:8): [True: 0, False: 214]
  ------------------
 3519|    214|   n = 0;
 3520|       |
 3521|    214|   m=0;
 3522|  3.37k|   for (i=0; i < windings; ++i) {
  ------------------
  |  Branch (3522:14): [True: 3.16k, False: 214]
  ------------------
 3523|  3.16k|      stbtt__point *p = pts + m;
 3524|  3.16k|      m += wcount[i];
 3525|  3.16k|      j = wcount[i]-1;
 3526|  18.9k|      for (k=0; k < wcount[i]; j=k++) {
  ------------------
  |  Branch (3526:17): [True: 15.8k, False: 3.16k]
  ------------------
 3527|  15.8k|         int a=k,b=j;
 3528|       |         // skip the edge if horizontal
 3529|  15.8k|         if (p[j].y == p[k].y)
  ------------------
  |  Branch (3529:14): [True: 9.48k, False: 6.32k]
  ------------------
 3530|  9.48k|            continue;
 3531|       |         // add edge from j to k to the list
 3532|  6.32k|         e[n].invert = 0;
 3533|  6.32k|         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
  ------------------
  |  Branch (3533:14): [True: 6.32k, False: 0]
  |  Branch (3533:14): [True: 3.16k, False: 3.16k]
  ------------------
 3534|  3.16k|            e[n].invert = 1;
 3535|  3.16k|            a=j,b=k;
 3536|  3.16k|         }
 3537|  6.32k|         e[n].x0 = p[a].x * scale_x + shift_x;
 3538|  6.32k|         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
 3539|  6.32k|         e[n].x1 = p[b].x * scale_x + shift_x;
 3540|  6.32k|         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
 3541|  6.32k|         ++n;
 3542|  6.32k|      }
 3543|  3.16k|   }
 3544|       |
 3545|       |   // now sort the edges by their highest point (should snap to integer, and then by x)
 3546|       |   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
 3547|    214|   stbtt__sort_edges(e, n);
 3548|       |
 3549|       |   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
 3550|    214|   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);
 3551|       |
 3552|    214|   STBTT_free(e, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3553|    214|}
imgui_draw.cpp:_ZL17stbtt__sort_edgesP11stbtt__edgei:
 3488|    214|{
 3489|    214|   stbtt__sort_edges_quicksort(p, n);
 3490|    214|   stbtt__sort_edges_ins_sort(p, n);
 3491|    214|}
imgui_draw.cpp:_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei:
 3426|    862|{
 3427|       |   /* threshold for transitioning to insertion sort */
 3428|  1.51k|   while (n > 12) {
  ------------------
  |  Branch (3428:11): [True: 648, False: 862]
  ------------------
 3429|    648|      stbtt__edge t;
 3430|    648|      int c01,c12,c,m,i,j;
 3431|       |
 3432|       |      /* compute median of three */
 3433|    648|      m = n >> 1;
 3434|    648|      c01 = STBTT__COMPARE(&p[0],&p[m]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3435|    648|      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3436|       |      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
 3437|    648|      if (c01 != c12) {
  ------------------
  |  Branch (3437:11): [True: 249, False: 399]
  ------------------
 3438|       |         /* otherwise, we'll need to swap something else to middle */
 3439|    249|         int z;
 3440|    249|         c = STBTT__COMPARE(&p[0],&p[n-1]);
  ------------------
  |  | 3405|    249|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3441|       |         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
 3442|       |         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
 3443|    249|         z = (c == c12) ? 0 : n-1;
  ------------------
  |  Branch (3443:14): [True: 6, False: 243]
  ------------------
 3444|    249|         t = p[z];
 3445|    249|         p[z] = p[m];
 3446|    249|         p[m] = t;
 3447|    249|      }
 3448|       |      /* now p[m] is the median-of-three */
 3449|       |      /* swap it to the beginning so it won't move around */
 3450|    648|      t = p[0];
 3451|    648|      p[0] = p[m];
 3452|    648|      p[m] = t;
 3453|       |
 3454|       |      /* partition loop */
 3455|    648|      i=1;
 3456|    648|      j=n-1;
 3457|  1.98k|      for(;;) {
 3458|       |         /* handling of equality is crucial here */
 3459|       |         /* for sentinels & efficiency with duplicates */
 3460|  8.69k|         for (;;++i) {
 3461|  8.69k|            if (!STBTT__COMPARE(&p[i], &p[0])) break;
  ------------------
  |  | 3405|  8.69k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3461:17): [True: 1.98k, False: 6.71k]
  ------------------
 3462|  8.69k|         }
 3463|  5.67k|         for (;;--j) {
 3464|  5.67k|            if (!STBTT__COMPARE(&p[0], &p[j])) break;
  ------------------
  |  | 3405|  5.67k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3464:17): [True: 1.98k, False: 3.69k]
  ------------------
 3465|  5.67k|         }
 3466|       |         /* make sure we haven't crossed */
 3467|  1.98k|         if (i >= j) break;
  ------------------
  |  Branch (3467:14): [True: 648, False: 1.33k]
  ------------------
 3468|  1.33k|         t = p[i];
 3469|  1.33k|         p[i] = p[j];
 3470|  1.33k|         p[j] = t;
 3471|       |
 3472|  1.33k|         ++i;
 3473|  1.33k|         --j;
 3474|  1.33k|      }
 3475|       |      /* recurse on smaller side, iterate on larger */
 3476|    648|      if (j < (n-i)) {
  ------------------
  |  Branch (3476:11): [True: 199, False: 449]
  ------------------
 3477|    199|         stbtt__sort_edges_quicksort(p,j);
 3478|    199|         p = p+i;
 3479|    199|         n = n-i;
 3480|    449|      } else {
 3481|    449|         stbtt__sort_edges_quicksort(p+i, n-i);
 3482|    449|         n = j;
 3483|    449|      }
 3484|    648|   }
 3485|    862|}
imgui_draw.cpp:_ZL26stbtt__sort_edges_ins_sortP11stbtt__edgei:
 3408|    214|{
 3409|    214|   int i,j;
 3410|  6.32k|   for (i=1; i < n; ++i) {
  ------------------
  |  Branch (3410:14): [True: 6.10k, False: 214]
  ------------------
 3411|  6.10k|      stbtt__edge t = p[i], *a = &t;
 3412|  6.10k|      j = i;
 3413|  11.1k|      while (j > 0) {
  ------------------
  |  Branch (3413:14): [True: 10.9k, False: 177]
  ------------------
 3414|  10.9k|         stbtt__edge *b = &p[j-1];
 3415|  10.9k|         int c = STBTT__COMPARE(a,b);
  ------------------
  |  | 3405|  10.9k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3416|  10.9k|         if (!c) break;
  ------------------
  |  Branch (3416:14): [True: 5.93k, False: 5.04k]
  ------------------
 3417|  5.04k|         p[j] = p[j-1];
 3418|  5.04k|         --j;
 3419|  5.04k|      }
 3420|  6.10k|      if (i != j)
  ------------------
  |  Branch (3420:11): [True: 2.86k, False: 3.23k]
  ------------------
 3421|  2.86k|         p[j] = t;
 3422|  6.10k|   }
 3423|    214|}
imgui_draw.cpp:_ZL29stbtt__rasterize_sorted_edgesP13stbtt__bitmapP11stbtt__edgeiiiiPv:
 3306|    214|{
 3307|    214|   stbtt__hheap hh = { 0, 0, 0 };
 3308|    214|   stbtt__active_edge *active = NULL;
 3309|    214|   int y,j=0, i;
 3310|    214|   float scanline_data[129], *scanline, *scanline2;
 3311|       |
 3312|    214|   STBTT__NOTUSED(vsubsample);
  ------------------
  |  | 1130|    214|#define STBTT__NOTUSED(v)  (void)sizeof(v)
  ------------------
 3313|       |
 3314|    214|   if (result->w > 64)
  ------------------
  |  Branch (3314:8): [True: 0, False: 214]
  ------------------
 3315|      0|      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
  ------------------
  |  |  131|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3316|    214|   else
 3317|    214|      scanline = scanline_data;
 3318|       |
 3319|    214|   scanline2 = scanline + result->w;
 3320|       |
 3321|    214|   y = off_y;
 3322|    214|   e[n].y0 = (float) (off_y + result->h) + 1;
 3323|       |
 3324|  1.83k|   while (j < result->h) {
  ------------------
  |  Branch (3324:11): [True: 1.61k, False: 214]
  ------------------
 3325|       |      // find center of pixel for this scanline
 3326|  1.61k|      float scan_y_top    = y + 0.0f;
 3327|  1.61k|      float scan_y_bottom = y + 1.0f;
 3328|  1.61k|      stbtt__active_edge **step = &active;
 3329|       |
 3330|  1.61k|      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3331|  1.61k|      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3332|       |
 3333|       |      // update all active edges;
 3334|       |      // remove all active edges that terminate before the top of this scanline
 3335|  12.1k|      while (*step) {
  ------------------
  |  Branch (3335:14): [True: 10.5k, False: 1.61k]
  ------------------
 3336|  10.5k|         stbtt__active_edge * z = *step;
 3337|  10.5k|         if (z->ey <= scan_y_top) {
  ------------------
  |  Branch (3337:14): [True: 5.20k, False: 5.36k]
  ------------------
 3338|  5.20k|            *step = z->next; // delete from list
 3339|  5.20k|            STBTT_assert(z->direction);
  ------------------
  |  |  133|  5.20k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  5.20k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3340|  5.20k|            z->direction = 0;
 3341|  5.20k|            stbtt__hheap_free(&hh, z);
 3342|  5.36k|         } else {
 3343|  5.36k|            step = &((*step)->next); // advance through list
 3344|  5.36k|         }
 3345|  10.5k|      }
 3346|       |
 3347|       |      // insert all edges that start before the bottom of this scanline
 3348|  7.94k|      while (e->y0 <= scan_y_bottom) {
  ------------------
  |  Branch (3348:14): [True: 6.32k, False: 1.61k]
  ------------------
 3349|  6.32k|         if (e->y0 != e->y1) {
  ------------------
  |  Branch (3349:14): [True: 6.32k, False: 0]
  ------------------
 3350|  6.32k|            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
 3351|  6.32k|            if (z != NULL) {
  ------------------
  |  Branch (3351:17): [True: 6.32k, False: 0]
  ------------------
 3352|  6.32k|               if (j == 0 && off_y != 0) {
  ------------------
  |  Branch (3352:20): [True: 1.60k, False: 4.72k]
  |  Branch (3352:30): [True: 1.58k, False: 20]
  ------------------
 3353|  1.58k|                  if (z->ey < scan_y_top) {
  ------------------
  |  Branch (3353:23): [True: 0, False: 1.58k]
  ------------------
 3354|       |                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
 3355|      0|                     z->ey = scan_y_top;
 3356|      0|                  }
 3357|  1.58k|               }
 3358|  6.32k|               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
  ------------------
  |  |  133|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3359|       |               // insert at front
 3360|  6.32k|               z->next = active;
 3361|  6.32k|               active = z;
 3362|  6.32k|            }
 3363|  6.32k|         }
 3364|  6.32k|         ++e;
 3365|  6.32k|      }
 3366|       |
 3367|       |      // now process all active edges
 3368|  1.61k|      if (active)
  ------------------
  |  Branch (3368:11): [True: 1.61k, False: 5]
  ------------------
 3369|  1.61k|         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
 3370|       |
 3371|  1.61k|      {
 3372|  1.61k|         float sum = 0;
 3373|  9.77k|         for (i=0; i < result->w; ++i) {
  ------------------
  |  Branch (3373:20): [True: 8.15k, False: 1.61k]
  ------------------
 3374|  8.15k|            float k;
 3375|  8.15k|            int m;
 3376|  8.15k|            sum += scanline2[i];
 3377|  8.15k|            k = scanline[i] + sum;
 3378|  8.15k|            k = (float) STBTT_fabs(k)*255 + 0.5f;
  ------------------
  |  |  137|  8.15k|#define STBTT_fabs(x)       ImFabs(x)
  |  |  ------------------
  |  |  |  |  436|  8.15k|#define ImFabs(X)           fabsf(X)
  |  |  ------------------
  ------------------
 3379|  8.15k|            m = (int) k;
 3380|  8.15k|            if (m > 255) m = 255;
  ------------------
  |  Branch (3380:17): [True: 0, False: 8.15k]
  ------------------
 3381|  8.15k|            result->pixels[j*result->stride + i] = (unsigned char) m;
 3382|  8.15k|         }
 3383|  1.61k|      }
 3384|       |      // advance all the edges
 3385|  1.61k|      step = &active;
 3386|  13.3k|      while (*step) {
  ------------------
  |  Branch (3386:14): [True: 11.6k, False: 1.61k]
  ------------------
 3387|  11.6k|         stbtt__active_edge *z = *step;
 3388|  11.6k|         z->fx += z->fdx; // advance to position for current scanline
 3389|  11.6k|         step = &((*step)->next); // advance through list
 3390|  11.6k|      }
 3391|       |
 3392|  1.61k|      ++y;
 3393|  1.61k|      ++j;
 3394|  1.61k|   }
 3395|       |
 3396|    214|   stbtt__hheap_cleanup(&hh, userdata);
 3397|       |
 3398|    214|   if (scanline != scanline_data)
  ------------------
  |  Branch (3398:8): [True: 0, False: 214]
  ------------------
 3399|      0|      STBTT_free(scanline, userdata);
  ------------------
  |  |  132|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3400|    214|}
imgui_draw.cpp:_ZL17stbtt__hheap_freeP12stbtt__hheapPv:
 2797|  5.20k|{
 2798|  5.20k|   *(void **) p = hh->first_free;
 2799|  5.20k|   hh->first_free = p;
 2800|  5.20k|}
imgui_draw.cpp:_ZL17stbtt__new_activeP12stbtt__hheapP11stbtt__edgeifPv:
 2863|  6.32k|{
 2864|  6.32k|   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
 2865|  6.32k|   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
 2866|  6.32k|   STBTT_assert(z != NULL);
  ------------------
  |  |  133|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2867|       |   //STBTT_assert(e->y0 <= start_point);
 2868|  6.32k|   if (!z) return z;
  ------------------
  |  Branch (2868:8): [True: 0, False: 6.32k]
  ------------------
 2869|  6.32k|   z->fdx = dxdy;
 2870|  6.32k|   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
  ------------------
  |  Branch (2870:13): [True: 0, False: 6.32k]
  ------------------
 2871|  6.32k|   z->fx = e->x0 + dxdy * (start_point - e->y0);
 2872|  6.32k|   z->fx -= off_x;
 2873|  6.32k|   z->direction = e->invert ? 1.0f : -1.0f;
  ------------------
  |  Branch (2873:19): [True: 3.16k, False: 3.16k]
  ------------------
 2874|  6.32k|   z->sy = e->y0;
 2875|  6.32k|   z->ey = e->y1;
 2876|  6.32k|   z->next = 0;
 2877|  6.32k|   return z;
 2878|  6.32k|}
imgui_draw.cpp:_ZL18stbtt__hheap_allocP12stbtt__hheapmPv:
 2776|  6.32k|{
 2777|  6.32k|   if (hh->first_free) {
  ------------------
  |  Branch (2777:8): [True: 4.07k, False: 2.24k]
  ------------------
 2778|  4.07k|      void *p = hh->first_free;
 2779|  4.07k|      hh->first_free = * (void **) p;
 2780|  4.07k|      return p;
 2781|  4.07k|   } else {
 2782|  2.24k|      if (hh->num_remaining_in_head_chunk == 0) {
  ------------------
  |  Branch (2782:11): [True: 214, False: 2.03k]
  ------------------
 2783|    214|         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
  ------------------
  |  Branch (2783:23): [True: 0, False: 214]
  |  Branch (2783:42): [True: 214, False: 0]
  ------------------
 2784|    214|         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
  ------------------
  |  |  131|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 1820|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 2785|    214|         if (c == NULL)
  ------------------
  |  Branch (2785:14): [True: 0, False: 214]
  ------------------
 2786|      0|            return NULL;
 2787|    214|         c->next = hh->head;
 2788|    214|         hh->head = c;
 2789|    214|         hh->num_remaining_in_head_chunk = count;
 2790|    214|      }
 2791|  2.24k|      --hh->num_remaining_in_head_chunk;
 2792|  2.24k|      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
 2793|  2.24k|   }
 2794|  6.32k|}
imgui_draw.cpp:_ZL28stbtt__fill_active_edges_newPfS_iP18stbtt__active_edgef:
 3088|  1.61k|{
 3089|  1.61k|   float y_bottom = y_top+1;
 3090|       |
 3091|  13.2k|   while (e) {
  ------------------
  |  Branch (3091:11): [True: 11.6k, False: 1.61k]
  ------------------
 3092|       |      // brute force every pixel
 3093|       |
 3094|       |      // compute intersection points with top & bottom
 3095|  11.6k|      STBTT_assert(e->ey >= y_top);
  ------------------
  |  |  133|  11.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  11.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3096|       |
 3097|  11.6k|      if (e->fdx == 0) {
  ------------------
  |  Branch (3097:11): [True: 11.6k, False: 0]
  ------------------
 3098|  11.6k|         float x0 = e->fx;
 3099|  11.6k|         if (x0 < len) {
  ------------------
  |  Branch (3099:14): [True: 10.3k, False: 1.36k]
  ------------------
 3100|  10.3k|            if (x0 >= 0) {
  ------------------
  |  Branch (3100:17): [True: 10.3k, False: 0]
  ------------------
 3101|  10.3k|               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
 3102|  10.3k|               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
 3103|  10.3k|            } else {
 3104|      0|               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
 3105|      0|            }
 3106|  10.3k|         }
 3107|  11.6k|      } else {
 3108|      0|         float x0 = e->fx;
 3109|      0|         float dx = e->fdx;
 3110|      0|         float xb = x0 + dx;
 3111|      0|         float x_top, x_bottom;
 3112|      0|         float sy0,sy1;
 3113|      0|         float dy = e->fdy;
 3114|      0|         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3115|       |
 3116|       |         // compute endpoints of line segment clipped to this scanline (if the
 3117|       |         // line segment starts on this scanline. x0 is the intersection of the
 3118|       |         // line with y_top, but that may be off the line segment.
 3119|      0|         if (e->sy > y_top) {
  ------------------
  |  Branch (3119:14): [True: 0, False: 0]
  ------------------
 3120|      0|            x_top = x0 + dx * (e->sy - y_top);
 3121|      0|            sy0 = e->sy;
 3122|      0|         } else {
 3123|      0|            x_top = x0;
 3124|      0|            sy0 = y_top;
 3125|      0|         }
 3126|      0|         if (e->ey < y_bottom) {
  ------------------
  |  Branch (3126:14): [True: 0, False: 0]
  ------------------
 3127|      0|            x_bottom = x0 + dx * (e->ey - y_top);
 3128|      0|            sy1 = e->ey;
 3129|      0|         } else {
 3130|      0|            x_bottom = xb;
 3131|      0|            sy1 = y_bottom;
 3132|      0|         }
 3133|       |
 3134|      0|         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
  ------------------
  |  Branch (3134:14): [True: 0, False: 0]
  |  Branch (3134:28): [True: 0, False: 0]
  |  Branch (3134:45): [True: 0, False: 0]
  |  Branch (3134:60): [True: 0, False: 0]
  ------------------
 3135|       |            // from here on, we don't have to range check x values
 3136|       |
 3137|      0|            if ((int) x_top == (int) x_bottom) {
  ------------------
  |  Branch (3137:17): [True: 0, False: 0]
  ------------------
 3138|      0|               float height;
 3139|       |               // simple case, only spans one pixel
 3140|      0|               int x = (int) x_top;
 3141|      0|               height = (sy1 - sy0) * e->direction;
 3142|      0|               STBTT_assert(x >= 0 && x < len);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3143|      0|               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
 3144|      0|               scanline_fill[x] += height; // everything right of this pixel is filled
 3145|      0|            } else {
 3146|      0|               int x,x1,x2;
 3147|      0|               float y_crossing, y_final, step, sign, area;
 3148|       |               // covers 2+ pixels
 3149|      0|               if (x_top > x_bottom) {
  ------------------
  |  Branch (3149:20): [True: 0, False: 0]
  ------------------
 3150|       |                  // flip scanline vertically; signed area is the same
 3151|      0|                  float t;
 3152|      0|                  sy0 = y_bottom - (sy0 - y_top);
 3153|      0|                  sy1 = y_bottom - (sy1 - y_top);
 3154|      0|                  t = sy0, sy0 = sy1, sy1 = t;
 3155|      0|                  t = x_bottom, x_bottom = x_top, x_top = t;
 3156|      0|                  dx = -dx;
 3157|      0|                  dy = -dy;
 3158|      0|                  t = x0, x0 = xb, xb = t;
 3159|      0|               }
 3160|      0|               STBTT_assert(dy >= 0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3161|      0|               STBTT_assert(dx >= 0);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3162|       |
 3163|      0|               x1 = (int) x_top;
 3164|      0|               x2 = (int) x_bottom;
 3165|       |               // compute intersection with y axis at x1+1
 3166|      0|               y_crossing = y_top + dy * (x1+1 - x0);
 3167|       |
 3168|       |               // compute intersection with y axis at x2
 3169|      0|               y_final = y_top + dy * (x2 - x0);
 3170|       |
 3171|       |               //           x1    x_top                            x2    x_bottom
 3172|       |               //     y_top  +------|-----+------------+------------+--------|---+------------+
 3173|       |               //            |            |            |            |            |            |
 3174|       |               //            |            |            |            |            |            |
 3175|       |               //       sy0  |      Txxxxx|............|............|............|............|
 3176|       |               // y_crossing |            *xxxxx.......|............|............|............|
 3177|       |               //            |            |     xxxxx..|............|............|............|
 3178|       |               //            |            |     /-   xx*xxxx........|............|............|
 3179|       |               //            |            | dy <       |    xxxxxx..|............|............|
 3180|       |               //   y_final  |            |     \-     |          xx*xxx.........|............|
 3181|       |               //       sy1  |            |            |            |   xxxxxB...|............|
 3182|       |               //            |            |            |            |            |            |
 3183|       |               //            |            |            |            |            |            |
 3184|       |               //  y_bottom  +------------+------------+------------+------------+------------+
 3185|       |               //
 3186|       |               // goal is to measure the area covered by '.' in each pixel
 3187|       |
 3188|       |               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
 3189|       |               // @TODO: maybe test against sy1 rather than y_bottom?
 3190|      0|               if (y_crossing > y_bottom)
  ------------------
  |  Branch (3190:20): [True: 0, False: 0]
  ------------------
 3191|      0|                  y_crossing = y_bottom;
 3192|       |
 3193|      0|               sign = e->direction;
 3194|       |
 3195|       |               // area of the rectangle covered from sy0..y_crossing
 3196|      0|               area = sign * (y_crossing-sy0);
 3197|       |
 3198|       |               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
 3199|      0|               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);
 3200|       |
 3201|       |               // check if final y_crossing is blown up; no test case for this
 3202|      0|               if (y_final > y_bottom) {
  ------------------
  |  Branch (3202:20): [True: 0, False: 0]
  ------------------
 3203|      0|                  int denom = (x2 - (x1+1));
 3204|      0|                  y_final = y_bottom;
 3205|      0|                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
  ------------------
  |  Branch (3205:23): [True: 0, False: 0]
  ------------------
 3206|      0|                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
 3207|      0|                  }
 3208|      0|               }
 3209|       |
 3210|       |               // in second pixel, area covered by line segment found in first pixel
 3211|       |               // is always a rectangle 1 wide * the height of that line segment; this
 3212|       |               // is exactly what the variable 'area' stores. it also gets a contribution
 3213|       |               // from the line segment within it. the THIRD pixel will get the first
 3214|       |               // pixel's rectangle contribution, the second pixel's rectangle contribution,
 3215|       |               // and its own contribution. the 'own contribution' is the same in every pixel except
 3216|       |               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
 3217|       |               // the second pixel's contribution to the third pixel will be the
 3218|       |               // rectangle 1 wide times the height change in the second pixel, which is dy.
 3219|       |
 3220|      0|               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
 3221|       |               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
 3222|       |               // so the area advances by 'step' every time
 3223|       |
 3224|      0|               for (x = x1+1; x < x2; ++x) {
  ------------------
  |  Branch (3224:31): [True: 0, False: 0]
  ------------------
 3225|      0|                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
 3226|      0|                  area += step;
 3227|      0|               }
 3228|      0|               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3229|      0|               STBTT_assert(sy1 > y_final-0.01f);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3230|       |
 3231|       |               // area covered in the last pixel is the rectangle from all the pixels to the left,
 3232|       |               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
 3233|      0|               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);
 3234|       |
 3235|       |               // the rest of the line is filled based on the total height of the line segment in this pixel
 3236|      0|               scanline_fill[x2] += sign * (sy1-sy0);
 3237|      0|            }
 3238|      0|         } else {
 3239|       |            // if edge goes outside of box we're drawing, we require
 3240|       |            // clipping logic. since this does not match the intended use
 3241|       |            // of this library, we use a different, very slow brute
 3242|       |            // force implementation
 3243|       |            // note though that this does happen some of the time because
 3244|       |            // x_top and x_bottom can be extrapolated at the top & bottom of
 3245|       |            // the shape and actually lie outside the bounding box
 3246|      0|            int x;
 3247|      0|            for (x=0; x < len; ++x) {
  ------------------
  |  Branch (3247:23): [True: 0, False: 0]
  ------------------
 3248|       |               // cases:
 3249|       |               //
 3250|       |               // there can be up to two intersections with the pixel. any intersection
 3251|       |               // with left or right edges can be handled by splitting into two (or three)
 3252|       |               // regions. intersections with top & bottom do not necessitate case-wise logic.
 3253|       |               //
 3254|       |               // the old way of doing this found the intersections with the left & right edges,
 3255|       |               // then used some simple logic to produce up to three segments in sorted order
 3256|       |               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
 3257|       |               // across the x border, then the corresponding y position might not be distinct
 3258|       |               // from the other y segment, and it might ignored as an empty segment. to avoid
 3259|       |               // that, we need to explicitly produce segments based on x positions.
 3260|       |
 3261|       |               // rename variables to clearly-defined pairs
 3262|      0|               float y0 = y_top;
 3263|      0|               float x1 = (float) (x);
 3264|      0|               float x2 = (float) (x+1);
 3265|      0|               float x3 = xb;
 3266|      0|               float y3 = y_bottom;
 3267|       |
 3268|       |               // x = e->x + e->dx * (y-y_top)
 3269|       |               // (y-y_top) = (x - e->x) / e->dx
 3270|       |               // y = (x - e->x) / e->dx + y_top
 3271|      0|               float y1 = (x - x0) / dx + y_top;
 3272|      0|               float y2 = (x+1 - x0) / dx + y_top;
 3273|       |
 3274|      0|               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
  ------------------
  |  Branch (3274:20): [True: 0, False: 0]
  |  Branch (3274:31): [True: 0, False: 0]
  ------------------
 3275|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3276|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
 3277|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3278|      0|               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
  ------------------
  |  Branch (3278:27): [True: 0, False: 0]
  |  Branch (3278:38): [True: 0, False: 0]
  ------------------
 3279|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3280|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
 3281|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3282|      0|               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
  ------------------
  |  Branch (3282:27): [True: 0, False: 0]
  |  Branch (3282:38): [True: 0, False: 0]
  ------------------
 3283|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3284|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3285|      0|               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
  ------------------
  |  Branch (3285:27): [True: 0, False: 0]
  |  Branch (3285:38): [True: 0, False: 0]
  ------------------
 3286|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3287|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3288|      0|               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
  ------------------
  |  Branch (3288:27): [True: 0, False: 0]
  |  Branch (3288:38): [True: 0, False: 0]
  ------------------
 3289|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3290|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3291|      0|               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
  ------------------
  |  Branch (3291:27): [True: 0, False: 0]
  |  Branch (3291:38): [True: 0, False: 0]
  ------------------
 3292|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3293|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3294|      0|               } else {  // one segment
 3295|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
 3296|      0|               }
 3297|      0|            }
 3298|      0|         }
 3299|      0|      }
 3300|  11.6k|      e = e->next;
 3301|  11.6k|   }
 3302|  1.61k|}
imgui_draw.cpp:_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff:
 3034|  20.6k|{
 3035|  20.6k|   if (y0 == y1) return;
  ------------------
  |  Branch (3035:8): [True: 0, False: 20.6k]
  ------------------
 3036|  20.6k|   STBTT_assert(y0 < y1);
  ------------------
  |  |  133|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3037|  20.6k|   STBTT_assert(e->sy <= e->ey);
  ------------------
  |  |  133|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3038|  20.6k|   if (y0 > e->ey) return;
  ------------------
  |  Branch (3038:8): [True: 0, False: 20.6k]
  ------------------
 3039|  20.6k|   if (y1 < e->sy) return;
  ------------------
  |  Branch (3039:8): [True: 0, False: 20.6k]
  ------------------
 3040|  20.6k|   if (y0 < e->sy) {
  ------------------
  |  Branch (3040:8): [True: 9.44k, False: 11.1k]
  ------------------
 3041|  9.44k|      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
 3042|  9.44k|      y0 = e->sy;
 3043|  9.44k|   }
 3044|  20.6k|   if (y1 > e->ey) {
  ------------------
  |  Branch (3044:8): [True: 0, False: 20.6k]
  ------------------
 3045|      0|      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
 3046|      0|      y1 = e->ey;
 3047|      0|   }
 3048|       |
 3049|  20.6k|   if (x0 == x)
  ------------------
  |  Branch (3049:8): [True: 10.3k, False: 10.3k]
  ------------------
 3050|  10.3k|      STBTT_assert(x1 <= x+1);
  ------------------
  |  |  133|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3051|  10.3k|   else if (x0 == x+1)
  ------------------
  |  Branch (3051:13): [True: 0, False: 10.3k]
  ------------------
 3052|      0|      STBTT_assert(x1 >= x);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3053|  10.3k|   else if (x0 <= x)
  ------------------
  |  Branch (3053:13): [True: 10.3k, False: 0]
  ------------------
 3054|  10.3k|      STBTT_assert(x1 <= x);
  ------------------
  |  |  133|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3055|      0|   else if (x0 >= x+1)
  ------------------
  |  Branch (3055:13): [True: 0, False: 0]
  ------------------
 3056|      0|      STBTT_assert(x1 >= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3057|      0|   else
 3058|      0|      STBTT_assert(x1 >= x && x1 <= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3059|       |
 3060|  20.6k|   if (x0 <= x && x1 <= x)
  ------------------
  |  Branch (3060:8): [True: 20.6k, False: 0]
  |  Branch (3060:19): [True: 20.6k, False: 0]
  ------------------
 3061|  20.6k|      scanline[x] += e->direction * (y1-y0);
 3062|      0|   else if (x0 >= x+1 && x1 >= x+1)
  ------------------
  |  Branch (3062:13): [True: 0, False: 0]
  |  Branch (3062:26): [True: 0, False: 0]
  ------------------
 3063|      0|      ;
 3064|      0|   else {
 3065|      0|      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
  ------------------
  |  |  133|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (133:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3066|      0|      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
 3067|      0|   }
 3068|  20.6k|}
imgui_draw.cpp:_ZL20stbtt__hheap_cleanupP12stbtt__hheapPv:
 2803|    214|{
 2804|    214|   stbtt__hheap_chunk *c = hh->head;
 2805|    428|   while (c) {
  ------------------
  |  Branch (2805:11): [True: 214, False: 214]
  ------------------
 2806|    214|      stbtt__hheap_chunk *n = c->next;
 2807|    214|      STBTT_free(c, userdata);
  ------------------
  |  |  132|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 2808|    214|      c = n;
 2809|    214|   }
 2810|    214|}
imgui_draw.cpp:_ZL13stbtt_PackEndP18stbtt_pack_context:
 3998|      1|{
 3999|      1|   STBTT_free(spc->nodes    , spc->user_allocator_context);
  ------------------
  |  |  132|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4000|      1|   STBTT_free(spc->pack_info, spc->user_allocator_context);
  ------------------
  |  |  132|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 1821|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4001|      1|}
imgui_draw.cpp:_ZL21stbtt_GetFontVMetricsPK14stbtt_fontinfoPiS2_S2_:
 2640|      1|{
 2641|      1|   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
  ------------------
  |  Branch (2641:8): [True: 1, False: 0]
  ------------------
 2642|      1|   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
  ------------------
  |  Branch (2642:8): [True: 1, False: 0]
  ------------------
 2643|      1|   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
  ------------------
  |  Branch (2643:8): [True: 1, False: 0]
  ------------------
 2644|      1|}
imgui_draw.cpp:_ZL19stbtt_GetPackedQuadPK16stbtt_packedchariiiPfS2_P18stbtt_aligned_quadi:
 4372|    223|{
 4373|    223|   float ipw = 1.0f / pw, iph = 1.0f / ph;
 4374|    223|   const stbtt_packedchar *b = chardata + char_index;
 4375|       |
 4376|    223|   if (align_to_integer) {
  ------------------
  |  Branch (4376:8): [True: 0, False: 223]
  ------------------
 4377|      0|      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
  ------------------
  |  |  138|      0|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
 4378|      0|      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
  ------------------
  |  |  138|      0|#define STBTT_ifloor(x)     ((int)ImFloorSigned(x))
  ------------------
 4379|      0|      q->x0 = x;
 4380|      0|      q->y0 = y;
 4381|      0|      q->x1 = x + b->xoff2 - b->xoff;
 4382|      0|      q->y1 = y + b->yoff2 - b->yoff;
 4383|    223|   } else {
 4384|    223|      q->x0 = *xpos + b->xoff;
 4385|    223|      q->y0 = *ypos + b->yoff;
 4386|    223|      q->x1 = *xpos + b->xoff2;
 4387|    223|      q->y1 = *ypos + b->yoff2;
 4388|    223|   }
 4389|       |
 4390|    223|   q->s0 = b->x0 * ipw;
 4391|    223|   q->t0 = b->y0 * iph;
 4392|    223|   q->s1 = b->x1 * ipw;
 4393|    223|   q->t1 = b->y1 * iph;
 4394|       |
 4395|    223|   *xpos += b->xadvance;
 4396|    223|}

_Z9consume_tIN6dlxemu10CodeEditor11CoordinatesEEN3phi8optionalIT_EEPKhmRm:
  137|  17.3k|{
  138|  17.3k|    GET_T(phi::uint32_t, column);
  ------------------
  |  |   37|  17.3k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  17.3k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 17.3k]
  |  |  ------------------
  |  |   39|  17.3k|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|  17.3k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  139|  17.3k|    GET_T(phi::uint32_t, line);
  ------------------
  |  |   37|  17.3k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  17.3k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 3, False: 17.3k]
  |  |  ------------------
  |  |   39|  17.3k|    {                                                                                              \
  |  |   40|      3|        return {};                                                                                 \
  |  |   41|      3|    }                                                                                              \
  |  |   42|  17.3k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  140|       |
  141|  17.3k|    return dlxemu::CodeEditor::Coordinates{column, line};
  142|  17.3k|}
_Z14consume_stringPKhmRm:
  146|   133k|{
  147|       |    // Ensure we're not already past the available data
  148|   133k|    if (index >= size)
  ------------------
  |  Branch (148:9): [True: 110, False: 132k]
  ------------------
  149|    110|    {
  150|    110|        return false;
  151|    110|    }
  152|       |
  153|   132k|    const char* str_begin = reinterpret_cast<const char*>(data + index);
  154|   132k|    phi::size_t str_len   = 0u;
  155|       |
  156|   156k|    while (index < size && data[index] != '\0')
  ------------------
  |  Branch (156:12): [True: 155k, False: 55]
  |  Branch (156:28): [True: 23.0k, False: 132k]
  ------------------
  157|  23.0k|    {
  158|  23.0k|        ++index;
  159|  23.0k|        ++str_len;
  160|  23.0k|    }
  161|       |
  162|       |    // Reject too long strings
  163|   132k|    if (str_len > MaxStringLength)
  ------------------
  |  Branch (163:9): [True: 394, False: 132k]
  ------------------
  164|    394|    {
  165|    394|        return false;
  166|    394|    }
  167|       |
  168|   132k|    PHI_ASSERT(index <= size);
  169|       |    // Reject strings that are not null terminated
  170|   132k|    if (data[index - 1u] != '\0')
  ------------------
  |  Branch (170:9): [True: 2.63k, False: 129k]
  ------------------
  171|  2.63k|    {
  172|  2.63k|        return false;
  173|  2.63k|    }
  174|       |
  175|       |    // Move back to proper alignment
  176|   129k|    index += (sizeof(void*) - (index % sizeof(void*)));
  177|       |
  178|       |    // Assign string value to cache
  179|   129k|    cache.string = str_begin;
  180|       |
  181|   129k|    return true;
  182|   132k|}
_Z21consume_vector_stringPKhmRm:
  188|    278|{
  189|    278|    GET_T(phi::size_t, number_of_lines);
  ------------------
  |  |   37|    278|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    278|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 36, False: 242]
  |  |  ------------------
  |  |   39|    278|    {                                                                                              \
  |  |   40|     36|        return {};                                                                                 \
  |  |   41|     36|    }                                                                                              \
  |  |   42|    278|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  190|       |
  191|    242|    if (number_of_lines >= MaxVectorSize)
  ------------------
  |  Branch (191:9): [True: 19, False: 223]
  ------------------
  192|     19|    {
  193|     19|        return {};
  194|     19|    }
  195|       |
  196|    223|    std::vector<std::string>& res = cache.vector_string[number_of_lines];
  197|    921|    for (std::size_t i{0u}; i < number_of_lines; ++i)
  ------------------
  |  Branch (197:29): [True: 700, False: 221]
  ------------------
  198|    700|    {
  199|    700|        if (!consume_string(data, size, index))
  ------------------
  |  Branch (199:13): [True: 2, False: 698]
  ------------------
  200|      2|        {
  201|      2|            return {};
  202|      2|        }
  203|       |
  204|    698|        res[i] = cache.string;
  205|    698|    }
  206|       |
  207|    221|    return number_of_lines;
  208|    223|}
_Z13IsReservedKey8ImGuiKey:
  321|  8.00k|{
  322|  8.00k|    switch (key)
  323|  8.00k|    {
  324|  3.74k|        case ImGuiKey_ReservedForModCtrl:
  ------------------
  |  Branch (324:9): [True: 3.74k, False: 4.26k]
  ------------------
  325|  3.74k|        case ImGuiKey_ReservedForModShift:
  ------------------
  |  Branch (325:9): [True: 7, False: 7.99k]
  ------------------
  326|  4.21k|        case ImGuiKey_ReservedForModAlt:
  ------------------
  |  Branch (326:9): [True: 463, False: 7.54k]
  ------------------
  327|  4.27k|        case ImGuiKey_ReservedForModSuper:
  ------------------
  |  Branch (327:9): [True: 60, False: 7.94k]
  ------------------
  328|  4.27k|            return true;
  329|       |
  330|  3.73k|        default:
  ------------------
  |  Branch (330:9): [True: 3.73k, False: 4.27k]
  ------------------
  331|  3.73k|            return false;
  332|  8.00k|    }
  333|  8.00k|}
_Z10SetupImGuiv:
  336|      1|{
  337|      1|    IMGUI_CHECKVERSION();
  338|      1|    if (GImGui != nullptr)
  ------------------
  |  Branch (338:9): [True: 0, False: 1]
  ------------------
  339|      0|    {
  340|      0|        return true;
  341|      0|    }
  342|       |
  343|      1|    if (ImGui::CreateContext() == nullptr)
  ------------------
  |  Branch (343:9): [True: 0, False: 1]
  ------------------
  344|      0|    {
  345|      0|        FUZZ_LOG("Failed to create ImGuiContext");
  ------------------
  |  |   33|      0|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  346|      0|        return false;
  347|      0|    }
  348|       |
  349|       |    // Set config
  350|      1|    ImGuiIO& io = ImGui::GetIO();
  351|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
  352|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;  // Enable Gamepad Controls
  353|      1|    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;     // Enable Docking
  354|      1|    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; // Enable Multi-Viewport / Platform Windows
  355|       |
  356|       |    // Enforce valid display size
  357|      1|    io.DisplaySize.x = 1024.0f;
  358|      1|    io.DisplaySize.y = 768.0f;
  359|       |
  360|       |    // Enfore valid DeltaTime
  361|      1|    io.DeltaTime = 1.0f / 60.0f;
  362|       |
  363|       |    // Don't save any config
  364|      1|    io.IniFilename = nullptr;
  365|       |
  366|       |    // SetStyle
  367|      1|    ImGuiStyle& style = ImGui::GetStyle();
  368|      1|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (368:9): [True: 1, False: 0]
  ------------------
  369|      1|    {
  370|      1|        style.WindowRounding              = 0.0f;
  371|      1|        style.Colors[ImGuiCol_WindowBg].w = 1.0f;
  372|      1|    }
  373|       |
  374|       |    // Build atlas
  375|      1|    unsigned char* tex_pixels{nullptr};
  376|      1|    int            tex_w;
  377|      1|    int            tex_h;
  378|      1|    io.Fonts->GetTexDataAsRGBA32(&tex_pixels, &tex_w, &tex_h);
  379|       |
  380|      1|    return true;
  381|      1|}
_Z8EndImGuiv:
  384|  90.2k|{
  385|  90.2k|    ImGui::Render();
  386|       |
  387|  90.2k|    volatile ImDrawData* draw_data = ImGui::GetDrawData();
  388|  90.2k|    PHI_UNUSED_VARIABLE(draw_data);
  389|       |
  390|  90.2k|    ImGuiIO& io = ImGui::GetIO();
  391|       |    // Update and Render additional Platform Windows
  392|       |    // (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.
  393|  90.2k|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (393:9): [True: 0, False: 90.2k]
  ------------------
  394|      0|    {
  395|      0|        ImGui::UpdatePlatformWindows();
  396|      0|        ImGui::RenderPlatformWindowsDefault();
  397|      0|    }
  398|       |
  399|  90.2k|    ImGui::EndFrame();
  400|       |
  401|       |    // Ensure frame count doesn't overflow
  402|  90.2k|    GImGui->FrameCount %= 16384;
  403|  90.2k|}
LLVMFuzzerTestOneInput:
  407|  9.34k|{
  408|  9.34k|    static bool imgui_init = SetupImGui();
  409|  9.34k|    (void)imgui_init;
  410|       |
  411|       |    // Reset some ImGui states
  412|  9.34k|    ImGui::GetIO().ClearInputCharacters();
  413|  9.34k|    ImGui::GetIO().ClearInputKeys();
  414|  9.34k|    ImGui::GetIO().InputQueueSurrogate = 0;
  415|  9.34k|    GImGui->InputEventsQueue.resize(0u);
  416|  9.34k|    ImGui::FocusWindow(nullptr);
  417|       |
  418|  9.34k|    dlxemu::Emulator   emulator;
  419|  9.34k|    dlxemu::CodeEditor editor{&emulator};
  420|       |
  421|  9.34k|    editor.UpdatePalette();
  422|       |
  423|  9.34k|    FUZZ_LOG("Beginning execution");
  ------------------
  |  |   33|  9.34k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  424|       |
  425|  1.07M|    for (std::size_t index{0u}; index < size;)
  ------------------
  |  Branch (425:33): [True: 1.07M, False: 612]
  ------------------
  426|  1.07M|    {
  427|  1.07M|        GET_T(phi::uint32_t, function_index);
  ------------------
  |  |   37|  1.07M|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  1.07M|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 732, False: 1.07M]
  |  |  ------------------
  |  |   39|  1.07M|    {                                                                                              \
  |  |   40|    732|        return {};                                                                                 \
  |  |   41|    732|    }                                                                                              \
  |  |   42|  1.07M|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  428|       |
  429|  1.07M|        switch (function_index)
  ------------------
  |  Branch (429:17): [True: 669k, False: 406k]
  ------------------
  430|  1.07M|        {
  431|       |            // AddErrorMarker
  432|   127k|            case 0: {
  ------------------
  |  Branch (432:13): [True: 127k, False: 947k]
  ------------------
  433|   127k|                GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   37|   127k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|   127k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 185, False: 127k]
  |  |  ------------------
  |  |   39|   127k|    {                                                                                              \
  |  |   40|    185|        return {};                                                                                 \
  |  |   41|    185|    }                                                                                              \
  |  |   42|   127k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  434|       |
  435|   127k|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (435:21): [True: 3.11k, False: 124k]
  ------------------
  436|  3.11k|                {
  437|  3.11k|                    return 0;
  438|  3.11k|                }
  439|   124k|                std::string& message = cache.string;
  440|       |
  441|   124k|                FUZZ_LOG("AddErrorMarker({:s}, {:s})", print_int(line_number),
  ------------------
  |  |   33|   124k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  442|   124k|                         print_string(message));
  443|       |
  444|   124k|                editor.AddErrorMarker(line_number, message);
  445|   124k|                break;
  446|   127k|            }
  447|       |
  448|       |            // ClearErrorMarkers
  449|  3.65k|            case 1: {
  ------------------
  |  Branch (449:13): [True: 3.65k, False: 1.07M]
  ------------------
  450|  3.65k|                FUZZ_LOG("ClearErrorMarkers");
  ------------------
  |  |   33|  3.65k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  451|       |
  452|  3.65k|                editor.ClearErrorMarkers();
  453|  3.65k|                break;
  454|   127k|            }
  455|       |
  456|       |            // SetText
  457|  1.12k|            case 2: {
  ------------------
  |  Branch (457:13): [True: 1.12k, False: 1.07M]
  ------------------
  458|  1.12k|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (458:21): [True: 14, False: 1.10k]
  ------------------
  459|     14|                {
  460|     14|                    return 0;
  461|     14|                }
  462|  1.10k|                std::string& text = cache.string;
  463|       |
  464|  1.10k|                FUZZ_LOG("SetText({:s})", print_string(text));
  ------------------
  |  |   33|  1.10k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  465|       |
  466|  1.10k|                editor.SetText(text);
  467|  1.10k|                break;
  468|  1.12k|            }
  469|       |
  470|       |            // GetText
  471|    993|            case 3: {
  ------------------
  |  Branch (471:13): [True: 993, False: 1.07M]
  ------------------
  472|    993|                FUZZ_LOG("GetText()");
  ------------------
  |  |   33|    993|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  473|       |
  474|    993|                volatile std::string str = editor.GetText();
  475|    993|                PHI_UNUSED_VARIABLE(str);
  476|    993|                break;
  477|  1.12k|            }
  478|       |
  479|       |            // SetTextLines
  480|    278|            case 4: {
  ------------------
  |  Branch (480:13): [True: 278, False: 1.07M]
  ------------------
  481|    278|                auto lines_opt = consume_vector_string(data, size, index);
  482|    278|                if (!lines_opt)
  ------------------
  |  Branch (482:21): [True: 57, False: 221]
  ------------------
  483|     57|                {
  484|     57|                    return 0;
  485|     57|                }
  486|       |
  487|    221|                const std::vector<std::string>& lines = cache.vector_string[lines_opt.value()];
  488|       |
  489|    221|                FUZZ_LOG("SetTextLines({:s})", print_vector_string(lines));
  ------------------
  |  |   33|    221|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  490|    221|                editor.SetTextLines(lines);
  491|    221|                break;
  492|    278|            }
  493|       |
  494|       |            // GetTextLines
  495|    323|            case 5: {
  ------------------
  |  Branch (495:13): [True: 323, False: 1.07M]
  ------------------
  496|    323|                FUZZ_LOG("GetTextLines()");
  ------------------
  |  |   33|    323|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  497|       |
  498|    323|                volatile std::vector<std::string> lines = editor.GetTextLines();
  499|    323|                PHI_UNUSED_VARIABLE(lines);
  500|    323|                break;
  501|    278|            }
  502|       |
  503|       |            // GetSelectedText
  504|    235|            case 6: {
  ------------------
  |  Branch (504:13): [True: 235, False: 1.07M]
  ------------------
  505|    235|                FUZZ_LOG("GetSelectedText()");
  ------------------
  |  |   33|    235|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  506|       |
  507|    235|                volatile std::string line = editor.GetSelectedText();
  508|    235|                PHI_UNUSED_VARIABLE(line);
  509|    235|                break;
  510|    278|            }
  511|       |
  512|       |            // GetCurrentLineText
  513|    298|            case 7: {
  ------------------
  |  Branch (513:13): [True: 298, False: 1.07M]
  ------------------
  514|    298|                FUZZ_LOG("GetCurrentLineText()");
  ------------------
  |  |   33|    298|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  515|       |
  516|    298|                volatile std::string line = editor.GetCurrentLineText();
  517|    298|                PHI_UNUSED_VARIABLE(line);
  518|    298|                break;
  519|    278|            }
  520|       |
  521|       |            // SetReadOnly
  522|  1.97k|            case 8: {
  ------------------
  |  Branch (522:13): [True: 1.97k, False: 1.07M]
  ------------------
  523|  1.97k|                GET_T(bool, read_only);
  ------------------
  |  |   37|  1.97k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  1.97k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 1.97k]
  |  |  ------------------
  |  |   39|  1.97k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  1.97k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  524|       |
  525|  1.97k|                FUZZ_LOG("SetReadOnly({:s})", print_bool(read_only));
  ------------------
  |  |   33|  1.97k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  526|  1.97k|                editor.SetReadOnly(read_only);
  527|  1.97k|                break;
  528|  1.97k|            }
  529|       |
  530|       |            // GetCursorPosition
  531|    290|            case 9: {
  ------------------
  |  Branch (531:13): [True: 290, False: 1.07M]
  ------------------
  532|    290|                FUZZ_LOG("GetCursorPosition()");
  ------------------
  |  |   33|    290|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  533|       |
  534|    290|                volatile dlxemu::CodeEditor::Coordinates coords = editor.GetCursorPosition();
  535|    290|                PHI_UNUSED_VARIABLE(coords);
  536|    290|                break;
  537|  1.97k|            }
  538|       |
  539|       |            // SetCursorPosition
  540|  16.1k|            case 10: {
  ------------------
  |  Branch (540:13): [True: 16.1k, False: 1.05M]
  ------------------
  541|  16.1k|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   37|  16.1k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  16.1k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 4, False: 16.1k]
  |  |  ------------------
  |  |   39|  16.1k|    {                                                                                              \
  |  |   40|      4|        return {};                                                                                 \
  |  |   41|      4|    }                                                                                              \
  |  |   42|  16.1k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  542|       |
  543|  16.1k|                FUZZ_LOG("SetCursorPosition(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   33|  16.1k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  544|  16.1k|                         print_int(coords.m_Column));
  545|  16.1k|                editor.SetCursorPosition(coords);
  546|  16.1k|                break;
  547|  16.1k|            }
  548|       |
  549|       |            // SetShowWhitespaces
  550|      9|            case 11: {
  ------------------
  |  Branch (550:13): [True: 9, False: 1.07M]
  ------------------
  551|      9|                GET_T(bool, show_whitespaces);
  ------------------
  |  |   37|      9|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|      9|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 9]
  |  |  ------------------
  |  |   39|      9|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|      9|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  552|       |
  553|      9|                FUZZ_LOG("SetShowShitespaces({:s})", print_bool(show_whitespaces));
  ------------------
  |  |   33|      9|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  554|      9|                editor.SetShowWhitespaces(show_whitespaces);
  555|      9|                break;
  556|      9|            }
  557|       |
  558|       |            // SetTabSize
  559|  1.95k|            case 12: {
  ------------------
  |  Branch (559:13): [True: 1.95k, False: 1.07M]
  ------------------
  560|  1.95k|                GET_T(std::uint_fast8_t, tab_size);
  ------------------
  |  |   37|  1.95k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  1.95k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 1.95k]
  |  |  ------------------
  |  |   39|  1.95k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  1.95k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  561|       |
  562|  1.95k|                FUZZ_LOG("SetTabSize({:s})", print_int(tab_size));
  ------------------
  |  |   33|  1.95k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  563|  1.95k|                editor.SetTabSize(tab_size);
  564|  1.95k|                break;
  565|  1.95k|            }
  566|       |
  567|       |            // InsertText
  568|    476|            case 13: {
  ------------------
  |  Branch (568:13): [True: 476, False: 1.07M]
  ------------------
  569|    476|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (569:21): [True: 3, False: 473]
  ------------------
  570|      3|                {
  571|      3|                    return 0;
  572|      3|                }
  573|       |
  574|    473|                std::string& message = cache.string;
  575|       |
  576|    473|                FUZZ_LOG("InsertText({:s})", print_string(message));
  ------------------
  |  |   33|    473|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  577|    473|                editor.InsertText(message);
  578|    473|                break;
  579|    476|            }
  580|       |
  581|       |            // MoveUp
  582|    300|            case 14: {
  ------------------
  |  Branch (582:13): [True: 300, False: 1.07M]
  ------------------
  583|    300|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|    300|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    300|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 300]
  |  |  ------------------
  |  |   39|    300|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    300|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  584|    300|                GET_T(bool, select);
  ------------------
  |  |   37|    300|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    300|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 300]
  |  |  ------------------
  |  |   39|    300|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    300|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  585|       |
  586|    300|                FUZZ_LOG("MoveUp({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   33|    300|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  587|    300|                editor.MoveUp(amount, select);
  588|    300|                break;
  589|    300|            }
  590|       |
  591|       |            // MoveDown
  592|  2.12k|            case 15: {
  ------------------
  |  Branch (592:13): [True: 2.12k, False: 1.07M]
  ------------------
  593|  2.12k|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|  2.12k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.12k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 2.12k]
  |  |  ------------------
  |  |   39|  2.12k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  2.12k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  594|  2.12k|                GET_T(bool, select);
  ------------------
  |  |   37|  2.12k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.12k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 2.12k]
  |  |  ------------------
  |  |   39|  2.12k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  2.12k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  595|       |
  596|  2.12k|                FUZZ_LOG("MoveDown({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   33|  2.12k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  597|  2.12k|                editor.MoveDown(amount, select);
  598|  2.12k|                break;
  599|  2.12k|            }
  600|       |
  601|       |            // MoveLeft
  602|  5.23k|            case 16: {
  ------------------
  |  Branch (602:13): [True: 5.23k, False: 1.07M]
  ------------------
  603|  5.23k|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|  5.23k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  5.23k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 5.23k]
  |  |  ------------------
  |  |   39|  5.23k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  5.23k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  604|  5.23k|                GET_T(bool, select);
  ------------------
  |  |   37|  5.23k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  5.23k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 1, False: 5.23k]
  |  |  ------------------
  |  |   39|  5.23k|    {                                                                                              \
  |  |   40|      1|        return {};                                                                                 \
  |  |   41|      1|    }                                                                                              \
  |  |   42|  5.23k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  605|  5.23k|                GET_T(bool, word_mode);
  ------------------
  |  |   37|  5.23k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  5.23k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 4, False: 5.22k]
  |  |  ------------------
  |  |   39|  5.23k|    {                                                                                              \
  |  |   40|      4|        return {};                                                                                 \
  |  |   41|      4|    }                                                                                              \
  |  |   42|  5.23k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  606|       |
  607|  5.22k|                FUZZ_LOG("MoveLeft({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   33|  5.22k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  608|  5.22k|                         print_bool(word_mode));
  609|  5.22k|                editor.MoveLeft(amount, select, word_mode);
  610|  5.22k|                break;
  611|  5.23k|            }
  612|       |
  613|       |            // MoveRight
  614|    293|            case 17: {
  ------------------
  |  Branch (614:13): [True: 293, False: 1.07M]
  ------------------
  615|    293|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   37|    293|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    293|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 293]
  |  |  ------------------
  |  |   39|    293|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    293|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  616|    293|                GET_T(bool, select);
  ------------------
  |  |   37|    293|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    293|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 293]
  |  |  ------------------
  |  |   39|    293|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    293|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  617|    293|                GET_T(bool, word_mode);
  ------------------
  |  |   37|    293|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    293|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 293]
  |  |  ------------------
  |  |   39|    293|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    293|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  618|       |
  619|    293|                FUZZ_LOG("MoveRight({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   33|    293|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  620|    293|                         print_bool(word_mode));
  621|       |
  622|    293|                editor.MoveRight(amount, select, word_mode);
  623|    293|                break;
  624|    293|            }
  625|       |
  626|       |            // MoveTop
  627|    595|            case 18: {
  ------------------
  |  Branch (627:13): [True: 595, False: 1.07M]
  ------------------
  628|    595|                GET_T(bool, select);
  ------------------
  |  |   37|    595|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    595|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 595]
  |  |  ------------------
  |  |   39|    595|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    595|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  629|       |
  630|    595|                FUZZ_LOG("MoveTop({:s})", print_bool(select));
  ------------------
  |  |   33|    595|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  631|    595|                editor.MoveTop(select);
  632|    595|                break;
  633|    595|            }
  634|       |
  635|       |            // MoveBottom
  636|    150|            case 19: {
  ------------------
  |  Branch (636:13): [True: 150, False: 1.07M]
  ------------------
  637|    150|                GET_T(bool, select);
  ------------------
  |  |   37|    150|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    150|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 150]
  |  |  ------------------
  |  |   39|    150|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    150|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  638|       |
  639|    150|                FUZZ_LOG("MoveBottom({:s})", print_bool(select));
  ------------------
  |  |   33|    150|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  640|    150|                editor.MoveBottom(select);
  641|    150|                break;
  642|    150|            }
  643|       |
  644|       |            // MoveHome
  645|  3.39k|            case 20: {
  ------------------
  |  Branch (645:13): [True: 3.39k, False: 1.07M]
  ------------------
  646|  3.39k|                GET_T(bool, select);
  ------------------
  |  |   37|  3.39k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  3.39k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 3.39k]
  |  |  ------------------
  |  |   39|  3.39k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  3.39k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  647|       |
  648|  3.39k|                FUZZ_LOG("MoveHome({:s})", print_bool(select));
  ------------------
  |  |   33|  3.39k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  649|  3.39k|                editor.MoveHome(select);
  650|  3.39k|                break;
  651|  3.39k|            }
  652|       |
  653|       |            // MoveEnd
  654|    424|            case 21: {
  ------------------
  |  Branch (654:13): [True: 424, False: 1.07M]
  ------------------
  655|    424|                GET_T(bool, select);
  ------------------
  |  |   37|    424|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    424|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 424]
  |  |  ------------------
  |  |   39|    424|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    424|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  656|       |
  657|    424|                FUZZ_LOG("MoveEnd({:s})", print_bool(select));
  ------------------
  |  |   33|    424|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  658|    424|                editor.MoveEnd(select);
  659|    424|                break;
  660|    424|            }
  661|       |
  662|       |            // SetSelectionStart
  663|    209|            case 22: {
  ------------------
  |  Branch (663:13): [True: 209, False: 1.07M]
  ------------------
  664|    209|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   37|    209|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    209|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 209]
  |  |  ------------------
  |  |   39|    209|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    209|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  665|       |
  666|    209|                FUZZ_LOG("SetSelectionStart(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   33|    209|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  667|    209|                         print_int(coords.m_Column));
  668|    209|                editor.SetSelectionStart(coords);
  669|    209|                break;
  670|    209|            }
  671|       |
  672|       |            // SetSelectionEnd
  673|     48|            case 23: {
  ------------------
  |  Branch (673:13): [True: 48, False: 1.07M]
  ------------------
  674|     48|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   37|     48|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|     48|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 48]
  |  |  ------------------
  |  |   39|     48|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|     48|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  675|       |
  676|     48|                FUZZ_LOG("SetSelectionEnd(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   33|     48|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  677|     48|                         print_int(coords.m_Column));
  678|     48|                editor.SetSelectionEnd(coords);
  679|     48|                break;
  680|     48|            }
  681|       |
  682|       |            // SetSelection
  683|    436|            case 24: {
  ------------------
  |  Branch (683:13): [True: 436, False: 1.07M]
  ------------------
  684|    436|                GET_T(dlxemu::CodeEditor::Coordinates, coords_start);
  ------------------
  |  |   37|    436|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    436|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 436]
  |  |  ------------------
  |  |   39|    436|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    436|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  685|    436|                GET_T(dlxemu::CodeEditor::Coordinates, coords_end);
  ------------------
  |  |   37|    436|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    436|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 436]
  |  |  ------------------
  |  |   39|    436|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    436|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  686|    436|                GET_T_COND(dlxemu::CodeEditor::SelectionMode, selection_mode,
  ------------------
  |  |   45|    436|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|    436|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|    436|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 436]
  |  |  |  |  ------------------
  |  |  |  |   39|    436|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|    436|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|    872|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 436, False: 0]
  |  |  |  Branch (46:11): [True: 424, False: 12]
  |  |  ------------------
  |  |   47|    436|    {                                                                                              \
  |  |   48|     12|        return {};                                                                                 \
  |  |   49|     12|    }                                                                                              \
  |  |   50|    436|    (void)(0)
  ------------------
  687|    424|                           selection_mode >= dlxemu::CodeEditor::SelectionMode::Normal &&
  688|    424|                                   selection_mode <= dlxemu::CodeEditor::SelectionMode::Line);
  689|       |
  690|    424|                FUZZ_LOG("SetSelection(Coordinates({:s}, {:s}), Coordinates({:s}, "
  ------------------
  |  |   33|    424|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  691|    424|                         "{:s}), {:s})",
  692|    424|                         print_int(coords_start.m_Line), print_int(coords_start.m_Column),
  693|    424|                         print_int(coords_end.m_Line), print_int(coords_start.m_Column),
  694|    424|                         dlx::enum_name(selection_mode).data());
  695|    424|                editor.SetSelection(coords_start, coords_end, selection_mode);
  696|    424|                break;
  697|    436|            }
  698|       |
  699|       |            // SelectWordUnderCursor
  700|    827|            case 25: {
  ------------------
  |  Branch (700:13): [True: 827, False: 1.07M]
  ------------------
  701|    827|                FUZZ_LOG("SelectWordUnderCursor");
  ------------------
  |  |   33|    827|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  702|       |
  703|    827|                editor.SelectWordUnderCursor();
  704|    827|                break;
  705|    436|            }
  706|       |
  707|       |            // SelectAll
  708|    413|            case 26: {
  ------------------
  |  Branch (708:13): [True: 413, False: 1.07M]
  ------------------
  709|    413|                FUZZ_LOG("SelectAll");
  ------------------
  |  |   33|    413|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  710|       |
  711|    413|                editor.SelectAll();
  712|    413|                break;
  713|    436|            }
  714|       |
  715|       |            // Delete
  716|  2.63k|            case 27: {
  ------------------
  |  Branch (716:13): [True: 2.63k, False: 1.07M]
  ------------------
  717|  2.63k|                FUZZ_LOG("Delete");
  ------------------
  |  |   33|  2.63k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  718|       |
  719|  2.63k|                editor.Delete();
  720|  2.63k|                break;
  721|    436|            }
  722|       |
  723|       |            // Undo
  724|  1.89k|            case 28: {
  ------------------
  |  Branch (724:13): [True: 1.89k, False: 1.07M]
  ------------------
  725|  1.89k|                FUZZ_LOG("Undo()");
  ------------------
  |  |   33|  1.89k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  726|       |
  727|  1.89k|                editor.Undo();
  728|  1.89k|                break;
  729|    436|            }
  730|       |
  731|       |            // Redo
  732|    143|            case 29: {
  ------------------
  |  Branch (732:13): [True: 143, False: 1.07M]
  ------------------
  733|    143|                FUZZ_LOG("Redo()");
  ------------------
  |  |   33|    143|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  734|       |
  735|    143|                editor.Redo();
  736|    143|                break;
  737|    436|            }
  738|       |
  739|       |            // SetErrorMarkers
  740|  2.30k|            case 30: {
  ------------------
  |  Branch (740:13): [True: 2.30k, False: 1.07M]
  ------------------
  741|  4.60k|                GET_T_COND(phi::size_t, count, count <= MaxVectorSize);
  ------------------
  |  |   45|  2.30k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  2.30k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  2.30k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 2.30k]
  |  |  |  |  ------------------
  |  |  |  |   39|  2.30k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  2.30k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  2.30k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 7, False: 2.29k]
  |  |  ------------------
  |  |   47|  2.30k|    {                                                                                              \
  |  |   48|      7|        return {};                                                                                 \
  |  |   49|      7|    }                                                                                              \
  |  |   50|  2.30k|    (void)(0)
  ------------------
  742|       |
  743|  4.60k|                dlxemu::CodeEditor::ErrorMarkers markers;
  744|  5.31k|                for (std::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (744:41): [True: 3.01k, False: 2.29k]
  ------------------
  745|  3.01k|                {
  746|  3.01k|                    GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   37|  3.01k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  3.01k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 3.01k]
  |  |  ------------------
  |  |   39|  3.01k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  3.01k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  747|       |
  748|  3.01k|                    if (!consume_string(data, size, index))
  ------------------
  |  Branch (748:25): [True: 4, False: 3.01k]
  ------------------
  749|      4|                    {
  750|      4|                        return 0;
  751|      4|                    }
  752|  3.01k|                    std::string& message = cache.string;
  753|       |
  754|       |                    // Add to error markers
  755|  3.01k|                    markers[line_number] = message;
  756|  3.01k|                }
  757|       |
  758|  2.29k|                FUZZ_LOG("SetErrorMarkers({:s})", print_error_markers(markers));
  ------------------
  |  |   33|  2.29k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  759|       |
  760|  2.29k|                editor.SetErrorMarkers(markers);
  761|  2.29k|                break;
  762|  4.60k|            }
  763|       |
  764|       |            // SetBreakpoints
  765|  1.62k|            case 31: {
  ------------------
  |  Branch (765:13): [True: 1.62k, False: 1.07M]
  ------------------
  766|  3.22k|                GET_T_COND(phi::size_t, count, count <= MaxVectorSize);
  ------------------
  |  |   45|  1.62k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  1.62k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  1.62k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 1.62k]
  |  |  |  |  ------------------
  |  |  |  |   39|  1.62k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  1.62k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  1.62k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 19, False: 1.60k]
  |  |  ------------------
  |  |   47|  1.62k|    {                                                                                              \
  |  |   48|     19|        return {};                                                                                 \
  |  |   49|     19|    }                                                                                              \
  |  |   50|  1.62k|    (void)(0)
  ------------------
  767|       |
  768|  3.22k|                dlxemu::CodeEditor::Breakpoints breakpoints;
  769|  9.90k|                for (std::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (769:41): [True: 8.30k, False: 1.60k]
  ------------------
  770|  8.30k|                {
  771|  8.30k|                    GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   37|  8.30k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  8.30k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 2, False: 8.30k]
  |  |  ------------------
  |  |   39|  8.30k|    {                                                                                              \
  |  |   40|      2|        return {};                                                                                 \
  |  |   41|      2|    }                                                                                              \
  |  |   42|  8.30k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  772|       |
  773|  8.30k|                    breakpoints.insert(line_number);
  774|  8.30k|                }
  775|       |
  776|  1.60k|                FUZZ_LOG("SetBreakpoints({:s})", print_breakpoints(breakpoints));
  ------------------
  |  |   33|  1.60k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  777|       |
  778|  1.60k|                editor.SetBreakpoints(breakpoints);
  779|  1.60k|                break;
  780|  3.22k|            }
  781|       |
  782|       |            // Render
  783|  90.4k|            case 32: {
  ------------------
  |  Branch (783:13): [True: 90.4k, False: 984k]
  ------------------
  784|   180k|                GET_T_COND(float, x, x <= MaxSaneFloatValue && x >= 0.0f && !phi::is_nan(x));
  ------------------
  |  |   45|  90.4k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  90.4k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  90.4k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 49, False: 90.3k]
  |  |  |  |  ------------------
  |  |  |  |   39|  90.4k|    {                                                                                              \
  |  |  |  |   40|     49|        return {};                                                                                 \
  |  |  |  |   41|     49|    }                                                                                              \
  |  |  |  |   42|  90.4k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|   361k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 90.3k, False: 20]
  |  |  |  Branch (46:11): [True: 90.3k, False: 36]
  |  |  |  Branch (46:11): [True: 90.3k, False: 0]
  |  |  ------------------
  |  |   47|  90.3k|    {                                                                                              \
  |  |   48|     56|        return {};                                                                                 \
  |  |   49|     56|    }                                                                                              \
  |  |   50|  90.3k|    (void)(0)
  ------------------
  785|   180k|                GET_T_COND(float, y, y <= MaxSaneFloatValue && y >= 0.0f && !phi::is_nan(y));
  ------------------
  |  |   45|  90.3k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  90.3k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  90.3k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 5, False: 90.3k]
  |  |  |  |  ------------------
  |  |  |  |   39|  90.3k|    {                                                                                              \
  |  |  |  |   40|      5|        return {};                                                                                 \
  |  |  |  |   41|      5|    }                                                                                              \
  |  |  |  |   42|  90.3k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|   361k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 90.3k, False: 18]
  |  |  |  Branch (46:11): [True: 90.2k, False: 64]
  |  |  |  Branch (46:11): [True: 90.2k, False: 0]
  |  |  ------------------
  |  |   47|  90.3k|    {                                                                                              \
  |  |   48|     82|        return {};                                                                                 \
  |  |   49|     82|    }                                                                                              \
  |  |   50|  90.3k|    (void)(0)
  ------------------
  786|       |
  787|   180k|                ImVec2 size_vec(x, y);
  788|       |
  789|   180k|                GET_T(bool, border);
  ------------------
  |  |   37|  90.2k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  90.2k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 22, False: 90.2k]
  |  |  ------------------
  |  |   39|  90.2k|    {                                                                                              \
  |  |   40|     22|        return {};                                                                                 \
  |  |   41|     22|    }                                                                                              \
  |  |   42|  90.2k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  790|       |
  791|  90.2k|                FUZZ_LOG("Render(ImVec2({:f}, {:f}), {:s})", x, y, border ? "true" : "false");
  ------------------
  |  |   33|  90.2k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  792|       |
  793|  90.2k|                ImGui::NewFrame();
  794|  90.2k|                editor.Render(size_vec, border);
  795|  90.2k|                EndImGui();
  796|       |
  797|  90.2k|                break;
  798|   180k|            }
  799|       |
  800|       |            // EnterCharacter
  801|  32.0k|            case 33: {
  ------------------
  |  Branch (801:13): [True: 32.0k, False: 1.04M]
  ------------------
  802|  32.0k|                GET_T(ImWchar, character);
  ------------------
  |  |   37|  32.0k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  32.0k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 3, False: 32.0k]
  |  |  ------------------
  |  |   39|  32.0k|    {                                                                                              \
  |  |   40|      3|        return {};                                                                                 \
  |  |   41|      3|    }                                                                                              \
  |  |   42|  32.0k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  803|  32.0k|                GET_T(bool, shift);
  ------------------
  |  |   37|  32.0k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  32.0k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 5, False: 32.0k]
  |  |  ------------------
  |  |   39|  32.0k|    {                                                                                              \
  |  |   40|      5|        return {};                                                                                 \
  |  |   41|      5|    }                                                                                              \
  |  |   42|  32.0k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  804|       |
  805|  32.0k|                FUZZ_LOG("EnterCharacter({:s}, {:s})", print_char(character), print_bool(shift));
  ------------------
  |  |   33|  32.0k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  806|  32.0k|                editor.EnterCharacter(character, shift);
  807|  32.0k|                break;
  808|  32.0k|            }
  809|       |
  810|       |            // ClearText
  811|    359|            case 34: {
  ------------------
  |  Branch (811:13): [True: 359, False: 1.07M]
  ------------------
  812|    359|                FUZZ_LOG("ClearText()");
  ------------------
  |  |   33|    359|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  813|       |
  814|    359|                editor.ClearText();
  815|    359|                break;
  816|  32.0k|            }
  817|       |
  818|       |            // ClearSelection
  819|    817|            case 35: {
  ------------------
  |  Branch (819:13): [True: 817, False: 1.07M]
  ------------------
  820|    817|                FUZZ_LOG("ClearSelection");
  ------------------
  |  |   33|    817|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  821|       |
  822|    817|                editor.ClearSelection();
  823|    817|                break;
  824|  32.0k|            }
  825|       |
  826|       |            // Backspace
  827|  7.43k|            case 36: {
  ------------------
  |  Branch (827:13): [True: 7.43k, False: 1.06M]
  ------------------
  828|  7.43k|                FUZZ_LOG("Backspace");
  ------------------
  |  |   33|  7.43k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  829|       |
  830|  7.43k|                editor.Backspace();
  831|  7.43k|                break;
  832|  32.0k|            }
  833|       |
  834|       |            // ImGui::AddKeyEvent
  835|  2.88k|            case 37: {
  ------------------
  |  Branch (835:13): [True: 2.88k, False: 1.07M]
  ------------------
  836|  3.85k|                GET_T_COND(ImGuiKey, key,
  ------------------
  |  |   45|  2.88k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  2.88k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  2.88k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 5, False: 2.88k]
  |  |  |  |  ------------------
  |  |  |  |   39|  2.88k|    {                                                                                              \
  |  |  |  |   40|      5|        return {};                                                                                 \
  |  |  |  |   41|      5|    }                                                                                              \
  |  |  |  |   42|  2.88k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  11.5k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 1.91k, False: 970]
  |  |  |  Branch (46:11): [True: 2.88k, False: 1]
  |  |  |  Branch (46:11): [True: 2.88k, False: 0]
  |  |  |  Branch (46:11): [True: 970, False: 1.91k]
  |  |  ------------------
  |  |   47|  2.88k|    {                                                                                              \
  |  |   48|  1.91k|        return {};                                                                                 \
  |  |   49|  1.91k|    }                                                                                              \
  |  |   50|  2.88k|    (void)(0)
  ------------------
  837|  3.85k|                           ImGui::IsNamedKey(key) && !ImGui::IsAliasKey(key) &&
  838|  3.85k|                                   !IsReservedKey(key));
  839|  3.85k|                GET_T(bool, down);
  ------------------
  |  |   37|    970|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    970|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 970]
  |  |  ------------------
  |  |   39|    970|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    970|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  840|       |
  841|    970|                FUZZ_LOG("ImGui::GetIO().AddKeyEvent({}, {:s})", key, print_bool(down));
  ------------------
  |  |   33|    970|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  842|    970|                ImGui::GetIO().AddKeyEvent(key, down);
  843|       |
  844|    970|                break;
  845|  3.85k|            }
  846|       |
  847|       |            // ImGui::AddKeyAnalogEvent
  848|  5.12k|            case 38: {
  ------------------
  |  Branch (848:13): [True: 5.12k, False: 1.07M]
  ------------------
  849|  7.89k|                GET_T_COND(ImGuiKey, key,
  ------------------
  |  |   45|  5.12k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  5.12k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  5.12k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 5.12k]
  |  |  |  |  ------------------
  |  |  |  |   39|  5.12k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  5.12k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  20.5k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 2.36k, False: 2.76k]
  |  |  |  Branch (46:11): [True: 5.12k, False: 4]
  |  |  |  Branch (46:11): [True: 5.12k, False: 0]
  |  |  |  Branch (46:11): [True: 2.76k, False: 2.35k]
  |  |  ------------------
  |  |   47|  5.12k|    {                                                                                              \
  |  |   48|  2.36k|        return {};                                                                                 \
  |  |   49|  2.36k|    }                                                                                              \
  |  |   50|  5.12k|    (void)(0)
  ------------------
  850|  7.89k|                           ImGui::IsNamedKey(key) && !ImGui::IsAliasKey(key) &&
  851|  7.89k|                                   !IsReservedKey(key));
  852|  7.89k|                GET_T(bool, down);
  ------------------
  |  |   37|  2.76k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  2.76k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 2.76k]
  |  |  ------------------
  |  |   39|  2.76k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  2.76k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  853|  2.76k|                GET_T_COND(float, value, phi::abs(value) <= MaxSaneFloatValue);
  ------------------
  |  |   45|  2.76k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  2.76k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  2.76k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 2.76k]
  |  |  |  |  ------------------
  |  |  |  |   39|  2.76k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  2.76k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  2.76k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 0, False: 2.76k]
  |  |  ------------------
  |  |   47|  2.76k|    {                                                                                              \
  |  |   48|      0|        return {};                                                                                 \
  |  |   49|      0|    }                                                                                              \
  |  |   50|  2.76k|    (void)(0)
  ------------------
  854|       |
  855|  2.76k|                FUZZ_LOG("ImGui::GetIO().AddKeyAnalogEvent({}, {:s}, {:f})", key, print_bool(down),
  ------------------
  |  |   33|  2.76k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  856|  2.76k|                         value);
  857|  2.76k|                ImGui::GetIO().AddKeyAnalogEvent(key, down, value);
  858|       |
  859|  2.76k|                break;
  860|  2.76k|            }
  861|       |
  862|       |            // ImGui::AddMousePosEvent
  863|  9.31k|            case 39: {
  ------------------
  |  Branch (863:13): [True: 9.31k, False: 1.06M]
  ------------------
  864|  18.6k|                GET_T_COND(float, x, phi::abs(x) <= MaxSaneFloatValue);
  ------------------
  |  |   45|  9.31k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  9.31k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  9.31k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 9.31k]
  |  |  |  |  ------------------
  |  |  |  |   39|  9.31k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  9.31k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  9.31k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 6, False: 9.30k]
  |  |  ------------------
  |  |   47|  9.31k|    {                                                                                              \
  |  |   48|      6|        return {};                                                                                 \
  |  |   49|      6|    }                                                                                              \
  |  |   50|  9.31k|    (void)(0)
  ------------------
  865|  18.6k|                GET_T_COND(float, y, phi::abs(y) <= MaxSaneFloatValue);
  ------------------
  |  |   45|  9.30k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  9.30k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  9.30k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 9.30k]
  |  |  |  |  ------------------
  |  |  |  |   39|  9.30k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  9.30k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  9.30k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 3, False: 9.30k]
  |  |  ------------------
  |  |   47|  9.30k|    {                                                                                              \
  |  |   48|      3|        return {};                                                                                 \
  |  |   49|      3|    }                                                                                              \
  |  |   50|  9.30k|    (void)(0)
  ------------------
  866|       |
  867|  9.30k|                FUZZ_LOG("ImGui::GetIO().AddMousePosEvent({:f}, {:f})", x, y);
  ------------------
  |  |   33|  9.30k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  868|  9.30k|                ImGui::GetIO().AddMousePosEvent(x, y);
  869|       |
  870|  9.30k|                break;
  871|  9.30k|            }
  872|       |
  873|       |            // ImGui::AddMouseButtonEvent
  874|  23.6k|            case 40: {
  ------------------
  |  Branch (874:13): [True: 23.6k, False: 1.05M]
  ------------------
  875|  47.1k|                GET_T_COND(int, button, button >= 0 && button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   45|  23.6k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  23.6k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  23.6k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 23.6k]
  |  |  |  |  ------------------
  |  |  |  |   39|  23.6k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  23.6k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  47.2k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:11): [True: 23.6k, False: 4]
  |  |  |  Branch (46:11): [True: 23.5k, False: 52]
  |  |  ------------------
  |  |   47|  23.6k|    {                                                                                              \
  |  |   48|     56|        return {};                                                                                 \
  |  |   49|     56|    }                                                                                              \
  |  |   50|  23.6k|    (void)(0)
  ------------------
  876|  47.1k|                GET_T(bool, down);
  ------------------
  |  |   37|  23.5k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  23.5k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 23.5k]
  |  |  ------------------
  |  |   39|  23.5k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  23.5k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  877|       |
  878|  23.5k|                FUZZ_LOG("ImGui::GetIO().AddMouseButtonEvent({}, {:s})", button, print_bool(down));
  ------------------
  |  |   33|  23.5k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  879|  23.5k|                ImGui::GetIO().AddMouseButtonEvent(button, down);
  880|       |
  881|  23.5k|                break;
  882|  47.1k|            }
  883|       |
  884|       |            // ImGui::AddMouseWheelEvent
  885|  4.19k|            case 41: {
  ------------------
  |  Branch (885:13): [True: 4.19k, False: 1.07M]
  ------------------
  886|  8.38k|                GET_T_COND(float, wh_x, phi::abs(wh_x) <= MaxSaneFloatValue);
  ------------------
  |  |   45|  4.19k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  4.19k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  4.19k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 4.19k]
  |  |  |  |  ------------------
  |  |  |  |   39|  4.19k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  4.19k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  4.19k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 4, False: 4.18k]
  |  |  ------------------
  |  |   47|  4.19k|    {                                                                                              \
  |  |   48|      4|        return {};                                                                                 \
  |  |   49|      4|    }                                                                                              \
  |  |   50|  4.19k|    (void)(0)
  ------------------
  887|  8.38k|                GET_T_COND(float, wh_y, phi::abs(wh_y) <= MaxSaneFloatValue);
  ------------------
  |  |   45|  4.18k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   37|  4.18k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   38|  4.18k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (38:9): [True: 0, False: 4.18k]
  |  |  |  |  ------------------
  |  |  |  |   39|  4.18k|    {                                                                                              \
  |  |  |  |   40|      0|        return {};                                                                                 \
  |  |  |  |   41|      0|    }                                                                                              \
  |  |  |  |   42|  4.18k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   46|  4.18k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (46:9): [True: 2, False: 4.18k]
  |  |  ------------------
  |  |   47|  4.18k|    {                                                                                              \
  |  |   48|      2|        return {};                                                                                 \
  |  |   49|      2|    }                                                                                              \
  |  |   50|  4.18k|    (void)(0)
  ------------------
  888|       |
  889|  4.18k|                FUZZ_LOG("ImGui::GetIO().AddMouseWheelEvent({:f}, {:f})", wh_x, wh_y);
  ------------------
  |  |   33|  4.18k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  890|  4.18k|                ImGui::GetIO().AddMouseWheelEvent(wh_x, wh_y);
  891|       |
  892|  4.18k|                break;
  893|  4.18k|            }
  894|       |
  895|       |            // ImGui::AddFocusEvent
  896|  7.41k|            case 42: {
  ------------------
  |  Branch (896:13): [True: 7.41k, False: 1.06M]
  ------------------
  897|  7.41k|                GET_T(bool, focused);
  ------------------
  |  |   37|  7.41k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  7.41k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 7.41k]
  |  |  ------------------
  |  |   39|  7.41k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  7.41k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  898|       |
  899|  7.41k|                FUZZ_LOG("ImGui::GetIO().AddFocusEvent({:s})", print_bool(focused));
  ------------------
  |  |   33|  7.41k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  900|  7.41k|                ImGui::GetIO().AddFocusEvent(focused);
  901|       |
  902|  7.41k|                break;
  903|  7.41k|            }
  904|       |
  905|       |            // ImGui::AddInputCharacter
  906|  13.4k|            case 43: {
  ------------------
  |  Branch (906:13): [True: 13.4k, False: 1.06M]
  ------------------
  907|  13.4k|                GET_T(unsigned int, character);
  ------------------
  |  |   37|  13.4k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  13.4k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 13.4k]
  |  |  ------------------
  |  |   39|  13.4k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  13.4k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  908|       |
  909|  13.4k|                FUZZ_LOG("ImGui::GetIO().AddInputCharacter({})", character);
  ------------------
  |  |   33|  13.4k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  910|  13.4k|                ImGui::GetIO().AddInputCharacter(character);
  911|       |
  912|  13.4k|                break;
  913|  13.4k|            }
  914|       |
  915|       |            // ImGui::AddInputCharacterUTF16
  916|  1.68k|            case 44: {
  ------------------
  |  Branch (916:13): [True: 1.68k, False: 1.07M]
  ------------------
  917|  1.68k|                GET_T(ImWchar16, character);
  ------------------
  |  |   37|  1.68k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  1.68k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 1.68k]
  |  |  ------------------
  |  |   39|  1.68k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  1.68k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  918|       |
  919|  1.68k|                FUZZ_LOG("ImGui::GetIO().AddInputCharacterUTF16({})", character);
  ------------------
  |  |   33|  1.68k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  920|  1.68k|                ImGui::GetIO().AddInputCharacterUTF16(character);
  921|       |
  922|  1.68k|                break;
  923|  1.68k|            }
  924|       |
  925|       |            // ImGui::AddInputCharactersUTF8
  926|     72|            case 45: {
  ------------------
  |  Branch (926:13): [True: 72, False: 1.07M]
  ------------------
  927|     72|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (927:21): [True: 2, False: 70]
  ------------------
  928|      2|                {
  929|      2|                    return 0;
  930|      2|                }
  931|     70|                std::string& str = cache.string;
  932|       |
  933|     70|                FUZZ_LOG("ImGui::GetIO().AddInputCharactersUTF8({:s})", print_string(str));
  ------------------
  |  |   33|     70|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  934|     70|                ImGui::GetIO().AddInputCharactersUTF8(str.c_str());
  935|       |
  936|     70|                break;
  937|     72|            }
  938|       |
  939|       |            // Copy
  940|  7.62k|            case 46: {
  ------------------
  |  Branch (940:13): [True: 7.62k, False: 1.06M]
  ------------------
  941|  7.62k|                FUZZ_LOG("Copy()");
  ------------------
  |  |   33|  7.62k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  942|  7.62k|                editor.Copy();
  943|       |
  944|  7.62k|                break;
  945|     72|            }
  946|       |
  947|       |            // Cut
  948|     38|            case 47: {
  ------------------
  |  Branch (948:13): [True: 38, False: 1.07M]
  ------------------
  949|     38|                FUZZ_LOG("Cut()");
  ------------------
  |  |   33|     38|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  950|     38|                editor.Cut();
  951|       |
  952|     38|                break;
  953|     72|            }
  954|       |
  955|       |            // Paste
  956|  14.7k|            case 48: {
  ------------------
  |  Branch (956:13): [True: 14.7k, False: 1.06M]
  ------------------
  957|  14.7k|                FUZZ_LOG("Paste()");
  ------------------
  |  |   33|  14.7k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  958|  14.7k|                editor.Paste();
  959|       |
  960|  14.7k|                break;
  961|     72|            }
  962|       |
  963|       |            // SetOverwrite
  964|    453|            case 49: {
  ------------------
  |  Branch (964:13): [True: 453, False: 1.07M]
  ------------------
  965|    453|                GET_T(bool, overwrite);
  ------------------
  |  |   37|    453|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    453|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 453]
  |  |  ------------------
  |  |   39|    453|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    453|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  966|       |
  967|    453|                FUZZ_LOG("SetOverwrite({:s})", print_bool(overwrite));
  ------------------
  |  |   33|    453|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  968|    453|                editor.SetOverwrite(overwrite);
  969|       |
  970|    453|                break;
  971|    453|            }
  972|       |
  973|       |            // SetColorizerEnable
  974|    304|            case 50: {
  ------------------
  |  Branch (974:13): [True: 304, False: 1.07M]
  ------------------
  975|    304|                GET_T(bool, colorizer);
  ------------------
  |  |   37|    304|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    304|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 304]
  |  |  ------------------
  |  |   39|    304|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    304|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  976|       |
  977|    304|                FUZZ_LOG("SetColorizerEnable({:s})", print_bool(colorizer));
  ------------------
  |  |   33|    304|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  978|    304|                editor.SetColorizerEnable(colorizer);
  979|       |
  980|    304|                break;
  981|    304|            }
  982|       |
  983|       |            // RemoveBreakpoint
  984|    842|            case 51: {
  ------------------
  |  Branch (984:13): [True: 842, False: 1.07M]
  ------------------
  985|    842|                GET_T(phi::u32, line_number);
  ------------------
  |  |   37|    842|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|    842|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 842]
  |  |  ------------------
  |  |   39|    842|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|    842|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  986|       |
  987|    842|                FUZZ_LOG("RemoveBreakpoint({:s})", print_int(line_number));
  ------------------
  |  |   33|    842|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  988|    842|                editor.RemoveBreakpoint(line_number);
  989|       |
  990|    842|                break;
  991|    842|            }
  992|       |
  993|       |            // ToggleBreakpoint
  994|  4.66k|            case 52: {
  ------------------
  |  Branch (994:13): [True: 4.66k, False: 1.07M]
  ------------------
  995|  4.66k|                GET_T(phi::u32, line_number);
  ------------------
  |  |   37|  4.66k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   38|  4.66k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (38:9): [True: 0, False: 4.66k]
  |  |  ------------------
  |  |   39|  4.66k|    {                                                                                              \
  |  |   40|      0|        return {};                                                                                 \
  |  |   41|      0|    }                                                                                              \
  |  |   42|  4.66k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  996|       |
  997|  4.66k|                FUZZ_LOG("ToggleBreakpoint({:s})", print_int(line_number));
  ------------------
  |  |   33|  4.66k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  998|  4.66k|                editor.ToggleBreakpoint(line_number);
  999|       |
 1000|  4.66k|                break;
 1001|  4.66k|            }
 1002|  1.07M|        }
 1003|  1.07M|    }
 1004|       |
 1005|    612|    FUZZ_LOG("VerifyInternalState()");
  ------------------
  |  |   33|    612|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
 1006|    612|    editor.VerifyInternalState();
 1007|       |
 1008|    612|    FUZZ_LOG("Finished execution");
  ------------------
  |  |   33|    612|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
 1009|       |
 1010|    612|    return 0;
 1011|  9.34k|}
_ZN5Cache10InitializeEv:
   72|      2|    {
   73|      2|        Cache c;
   74|       |
   75|       |        // Resize vector args
   76|     18|        for (phi::usize i{0u}; i < MaxVectorSize; ++i)
  ------------------
  |  Branch (76:32): [True: 16, False: 2]
  ------------------
   77|     16|        {
   78|     16|            svec& vector = c.vector_string[i.unsafe()];
   79|     16|            vector.resize(i.unsafe());
   80|       |
   81|       |            // Reserve max size
   82|     16|            for (std::string& str : vector)
  ------------------
  |  Branch (82:35): [True: 56, False: 16]
  ------------------
   83|     56|            {
   84|     56|                str.reserve(MaxStringLength);
   85|     56|            }
   86|     16|        }
   87|       |
   88|      2|        c.string.reserve(MaxStringLength);
   89|       |
   90|      2|        return c;
   91|      2|    }
_Z9consume_tIjEN3phi8optionalIT_EEPKhmRm:
  111|  1.27M|{
  112|  1.27M|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 923, False: 1.27M]
  ------------------
  113|    923|    {
  114|    923|        return {};
  115|    923|    }
  116|       |
  117|  1.27M|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  1.27M|    const phi::size_t old_index = index;
  120|  1.27M|    index += aligned_size<T>();
  121|       |
  122|  1.27M|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  1.27M|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  1.27M|        return static_cast<bool>(value);
  126|  1.27M|    }
  127|  1.27M|    else
  128|  1.27M|    {
  129|  1.27M|        return *reinterpret_cast<const T*>(data + old_index);
  130|  1.27M|    }
  131|  1.27M|}
_Z10has_x_moremmm:
   98|  1.73M|{
   99|  1.73M|    return index + x < size;
  100|  1.73M|}
_Z12aligned_sizeIjEmv:
  104|  1.27M|{
  105|  1.27M|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  1.27M|}
_Z9consume_tImEN3phi8optionalIT_EEPKhmRm:
  111|  4.20k|{
  112|  4.20k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 36, False: 4.17k]
  ------------------
  113|     36|    {
  114|     36|        return {};
  115|     36|    }
  116|       |
  117|  4.17k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  4.17k|    const phi::size_t old_index = index;
  120|  4.17k|    index += aligned_size<T>();
  121|       |
  122|  4.17k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  4.17k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  4.17k|        return static_cast<bool>(value);
  126|  4.17k|    }
  127|  4.17k|    else
  128|  4.17k|    {
  129|  4.17k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  4.17k|    }
  131|  4.17k|}
_Z12aligned_sizeImEmv:
  104|  4.17k|{
  105|  4.17k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  4.17k|}
_Z9consume_tIbEN3phi8optionalIT_EEPKhmRm:
  111|   177k|{
  112|   177k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 32, False: 177k]
  ------------------
  113|     32|    {
  114|     32|        return {};
  115|     32|    }
  116|       |
  117|   177k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|   177k|    const phi::size_t old_index = index;
  120|   177k|    index += aligned_size<T>();
  121|       |
  122|   177k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|   177k|    {
  124|   177k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|   177k|        return static_cast<bool>(value);
  126|   177k|    }
  127|   177k|    else
  128|   177k|    {
  129|   177k|        return *reinterpret_cast<const T*>(data + old_index);
  130|   177k|    }
  131|   177k|}
_Z12aligned_sizeIbEmv:
  104|   177k|{
  105|   177k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|   177k|}
_Z9consume_tIhEN3phi8optionalIT_EEPKhmRm:
  111|  1.95k|{
  112|  1.95k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 0, False: 1.95k]
  ------------------
  113|      0|    {
  114|      0|        return {};
  115|      0|    }
  116|       |
  117|  1.95k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  1.95k|    const phi::size_t old_index = index;
  120|  1.95k|    index += aligned_size<T>();
  121|       |
  122|  1.95k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  1.95k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  1.95k|        return static_cast<bool>(value);
  126|  1.95k|    }
  127|  1.95k|    else
  128|  1.95k|    {
  129|  1.95k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  1.95k|    }
  131|  1.95k|}
_Z12aligned_sizeIhEmv:
  104|  1.95k|{
  105|  1.95k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  1.95k|}
_Z9consume_tIN6dlxemu10CodeEditor13SelectionModeEEN3phi8optionalIT_EEPKhmRm:
  111|    436|{
  112|    436|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 0, False: 436]
  ------------------
  113|      0|    {
  114|      0|        return {};
  115|      0|    }
  116|       |
  117|    436|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|    436|    const phi::size_t old_index = index;
  120|    436|    index += aligned_size<T>();
  121|       |
  122|    436|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|    436|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|    436|        return static_cast<bool>(value);
  126|    436|    }
  127|    436|    else
  128|    436|    {
  129|    436|        return *reinterpret_cast<const T*>(data + old_index);
  130|    436|    }
  131|    436|}
_Z12aligned_sizeIN6dlxemu10CodeEditor13SelectionModeEEmv:
  104|    436|{
  105|    436|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|    436|}
_Z9consume_tIfEN3phi8optionalIT_EEPKhmRm:
  111|   210k|{
  112|   210k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 54, False: 210k]
  ------------------
  113|     54|    {
  114|     54|        return {};
  115|     54|    }
  116|       |
  117|   210k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|   210k|    const phi::size_t old_index = index;
  120|   210k|    index += aligned_size<T>();
  121|       |
  122|   210k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|   210k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|   210k|        return static_cast<bool>(value);
  126|   210k|    }
  127|   210k|    else
  128|   210k|    {
  129|   210k|        return *reinterpret_cast<const T*>(data + old_index);
  130|   210k|    }
  131|   210k|}
_Z12aligned_sizeIfEmv:
  104|   210k|{
  105|   210k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|   210k|}
_Z9consume_tItEN3phi8optionalIT_EEPKhmRm:
  111|  33.7k|{
  112|  33.7k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 3, False: 33.7k]
  ------------------
  113|      3|    {
  114|      3|        return {};
  115|      3|    }
  116|       |
  117|  33.7k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  33.7k|    const phi::size_t old_index = index;
  120|  33.7k|    index += aligned_size<T>();
  121|       |
  122|  33.7k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  33.7k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  33.7k|        return static_cast<bool>(value);
  126|  33.7k|    }
  127|  33.7k|    else
  128|  33.7k|    {
  129|  33.7k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  33.7k|    }
  131|  33.7k|}
_Z12aligned_sizeItEmv:
  104|  33.7k|{
  105|  33.7k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  33.7k|}
_Z9consume_tI8ImGuiKeyEN3phi8optionalIT_EEPKhmRm:
  111|  8.01k|{
  112|  8.01k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 5, False: 8.00k]
  ------------------
  113|      5|    {
  114|      5|        return {};
  115|      5|    }
  116|       |
  117|  8.00k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  8.00k|    const phi::size_t old_index = index;
  120|  8.00k|    index += aligned_size<T>();
  121|       |
  122|  8.00k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  8.00k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  8.00k|        return static_cast<bool>(value);
  126|  8.00k|    }
  127|  8.00k|    else
  128|  8.00k|    {
  129|  8.00k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  8.00k|    }
  131|  8.00k|}
_Z12aligned_sizeI8ImGuiKeyEmv:
  104|  8.00k|{
  105|  8.00k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  8.00k|}
_Z9consume_tIiEN3phi8optionalIT_EEPKhmRm:
  111|  23.6k|{
  112|  23.6k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 0, False: 23.6k]
  ------------------
  113|      0|    {
  114|      0|        return {};
  115|      0|    }
  116|       |
  117|  23.6k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  23.6k|    const phi::size_t old_index = index;
  120|  23.6k|    index += aligned_size<T>();
  121|       |
  122|  23.6k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  23.6k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  23.6k|        return static_cast<bool>(value);
  126|  23.6k|    }
  127|  23.6k|    else
  128|  23.6k|    {
  129|  23.6k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  23.6k|    }
  131|  23.6k|}
_Z12aligned_sizeIiEmv:
  104|  23.6k|{
  105|  23.6k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  23.6k|}
_Z9consume_tIN3phi7integerIjEEENS0_8optionalIT_EEPKhmRm:
  111|  5.51k|{
  112|  5.51k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (112:9): [True: 0, False: 5.51k]
  ------------------
  113|      0|    {
  114|      0|        return {};
  115|      0|    }
  116|       |
  117|  5.51k|    PHI_ASSUME(index % sizeof(void*) == 0);
  118|       |
  119|  5.51k|    const phi::size_t old_index = index;
  120|  5.51k|    index += aligned_size<T>();
  121|       |
  122|  5.51k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (122:19): [Folded - Ignored]
  ------------------
  123|      0|    {
  124|  5.51k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  125|  5.51k|        return static_cast<bool>(value);
  126|  5.51k|    }
  127|  5.51k|    else
  128|  5.51k|    {
  129|  5.51k|        return *reinterpret_cast<const T*>(data + old_index);
  130|  5.51k|    }
  131|  5.51k|}
_Z12aligned_sizeIN3phi7integerIjEEEmv:
  104|  5.51k|{
  105|  5.51k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  106|  5.51k|}

