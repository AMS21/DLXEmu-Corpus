_ZN6dlxemu10CodeEditor10UndoRecordC2Ev:
  264|   130k|            UndoRecord() = default;

_ZN6dlxemu6WindowC2Ev:
   13|  9.87k|        Window() = default;

_ZN6dlxemu10CodeEditor11CoordinatesC2Ev:
  193|  1.40M|    {}
_ZN6dlxemu10CodeEditor11CoordinatesC2EN3phi7integerIjEES4_:
  198|  2.27M|    {}
_ZNK6dlxemu10CodeEditor11CoordinateseqERKS1_:
  201|   207k|    {
  202|   207k|        return (m_Line == other.m_Line) && (m_Column == other.m_Column);
  ------------------
  |  Branch (202:16): [True: 199k, False: 8.52k]
  |  Branch (202:44): [True: 196k, False: 2.99k]
  ------------------
  203|   207k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesneERKS1_:
  206|   187k|    {
  207|   187k|        return (m_Line != other.m_Line) || (m_Column != other.m_Column);
  ------------------
  |  Branch (207:16): [True: 32.7k, False: 154k]
  |  Branch (207:44): [True: 50.6k, False: 104k]
  ------------------
  208|   187k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesltERKS1_:
  211|  6.23k|    {
  212|  6.23k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (212:13): [True: 4.10k, False: 2.12k]
  ------------------
  213|  4.10k|        {
  214|  4.10k|            return m_Line < other.m_Line;
  215|  4.10k|        }
  216|       |
  217|  2.12k|        return m_Column < other.m_Column;
  218|  6.23k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgtERKS1_:
  221|   323k|    {
  222|   323k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (222:13): [True: 46.6k, False: 276k]
  ------------------
  223|  46.6k|        {
  224|  46.6k|            return m_Line > other.m_Line;
  225|  46.6k|        }
  226|       |
  227|   276k|        return m_Column > other.m_Column;
  228|   323k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesleERKS1_:
  231|   382k|    {
  232|   382k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (232:13): [True: 115k, False: 266k]
  ------------------
  233|   115k|        {
  234|   115k|            return m_Line < other.m_Line;
  235|   115k|        }
  236|       |
  237|   266k|        return m_Column <= other.m_Column;
  238|   382k|    }
_ZNK6dlxemu10CodeEditor11CoordinatesgeERKS1_:
  241|   283k|    {
  242|   283k|        if (m_Line != other.m_Line)
  ------------------
  |  Branch (242:13): [True: 6.08k, False: 277k]
  ------------------
  243|  6.08k|        {
  244|  6.08k|            return m_Line > other.m_Line;
  245|  6.08k|        }
  246|       |
  247|   277k|        return m_Column >= other.m_Column;
  248|   283k|    }
_ZN6dlxemu10CodeEditor5GlyphC2EhNS0_12PaletteIndexE:
  255|   227M|    {}
_ZN6dlxemu10CodeEditorC2EPNS_8EmulatorE:
  283|  19.7k|    {
  284|  19.7k|        Colorize();
  285|  19.7k|        m_Lines.emplace_back();
  286|  19.7k|    }
_ZN6dlxemu10CodeEditorD2Ev:
  289|  19.7k|    {
  290|  19.7k|        VerifyInternalState();
  291|  19.7k|    }
_ZN6dlxemu10CodeEditor15SetErrorMarkersERKNSt3__13mapIjNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS1_4lessIjEENS6_INS1_4pairIKjS8_EEEEEE:
  306|  1.18k|    {
  307|       |        // Reject if any markers are invalid
  308|  1.18k|        for (auto&& marker : markers)
  ------------------
  |  Branch (308:28): [True: 1.22k, False: 671]
  ------------------
  309|  1.22k|        {
  310|  1.22k|            const phi::u32 line_number = marker.first;
  311|       |
  312|  1.22k|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (312:17): [True: 240, False: 980]
  |  Branch (312:17): [True: 514, False: 706]
  |  Branch (312:38): [True: 274, False: 706]
  ------------------
  313|    514|            {
  314|    514|                return;
  315|    514|            }
  316|  1.22k|        }
  317|       |
  318|    671|        m_ErrorMarkers = markers;
  319|    671|    }
_ZN6dlxemu10CodeEditor14AddErrorMarkerEN3phi7integerIjEERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE:
  322|   155k|    {
  323|   155k|        if (line_number > m_Lines.size() || line_number == 0u)
  ------------------
  |  Branch (323:13): [True: 11.9k, False: 143k]
  |  Branch (323:13): [True: 19.7k, False: 136k]
  |  Branch (323:45): [True: 7.83k, False: 136k]
  ------------------
  324|  19.7k|        {
  325|  19.7k|            return;
  326|  19.7k|        }
  327|       |
  328|   136k|        if (m_ErrorMarkers.find(line_number.unsafe()) != m_ErrorMarkers.end())
  ------------------
  |  Branch (328:13): [True: 129k, False: 6.51k]
  ------------------
  329|   129k|        {
  330|   129k|            m_ErrorMarkers[line_number.unsafe()] += '\n' + message;
  331|   129k|        }
  332|  6.51k|        else
  333|  6.51k|        {
  334|  6.51k|            m_ErrorMarkers[line_number.unsafe()] = message;
  335|  6.51k|        }
  336|   136k|    }
_ZN6dlxemu10CodeEditor17ClearErrorMarkersEv:
  339|  7.61k|    {
  340|  7.61k|        m_ErrorMarkers.clear();
  341|  7.61k|    }
_ZN6dlxemu10CodeEditor14SetBreakpointsERKNSt3__113unordered_setIjNS1_4hashIjEENS1_8equal_toIjEENS1_9allocatorIjEEEE:
  354|  1.55k|    {
  355|       |        // Reject if any lines are invalid
  356|  1.55k|        for (phi::u32 line_number : markers)
  ------------------
  |  Branch (356:35): [True: 1.70k, False: 904]
  ------------------
  357|  1.70k|        {
  358|  1.70k|            if (line_number == 0u || line_number > m_Lines.size())
  ------------------
  |  Branch (358:17): [True: 88, False: 1.61k]
  |  Branch (358:17): [True: 652, False: 1.05k]
  |  Branch (358:38): [True: 564, False: 1.05k]
  ------------------
  359|    652|            {
  360|    652|                return;
  361|    652|            }
  362|  1.70k|        }
  363|       |
  364|    904|        m_Breakpoints = markers;
  365|    904|    }
_ZN6dlxemu10CodeEditor13AddBreakpointEN3phi7integerIjEE:
  368|  3.99k|    {
  369|  3.99k|        if (line_number > m_Lines.size() || line_number == 0u)
  ------------------
  |  Branch (369:13): [True: 1.43k, False: 2.56k]
  |  Branch (369:13): [True: 1.56k, False: 2.43k]
  |  Branch (369:45): [True: 130, False: 2.43k]
  ------------------
  370|  1.56k|        {
  371|  1.56k|            return false;
  372|  1.56k|        }
  373|       |
  374|  2.43k|        return m_Breakpoints.insert(line_number.unsafe()).second;
  375|  3.99k|    }
_ZN6dlxemu10CodeEditor16RemoveBreakpointEN3phi7integerIjEE:
  378|    917|    {
  379|    917|        auto iterator = m_Breakpoints.find(line_number.unsafe());
  380|       |
  381|    917|        if (iterator != m_Breakpoints.end())
  ------------------
  |  Branch (381:13): [True: 150, False: 767]
  ------------------
  382|    150|        {
  383|    150|            m_Breakpoints.erase(iterator);
  384|    150|            return true;
  385|    150|        }
  386|       |
  387|    767|        return false;
  388|    917|    }
_ZN6dlxemu10CodeEditor16ToggleBreakpointEN3phi7integerIjEE:
  391|  4.21k|    {
  392|  4.21k|        if (auto iterator = m_Breakpoints.find(line_number.unsafe());
  393|  4.21k|            iterator != m_Breakpoints.end())
  ------------------
  |  Branch (393:13): [True: 215, False: 3.99k]
  ------------------
  394|    215|        {
  395|    215|            m_Breakpoints.erase(iterator);
  396|    215|            return false;
  397|    215|        }
  398|       |
  399|  3.99k|        AddBreakpoint(line_number);
  400|  3.99k|        return true;
  401|  4.21k|    }
_ZN6dlxemu10CodeEditor16ClearBreakPointsEv:
  404|  2.24k|    {
  405|  2.24k|        m_Breakpoints.clear();
  406|  2.24k|    }
_ZN6dlxemu10CodeEditor6RenderERK6ImVec2N3phi7booleanE:
  419|  76.6k|    {
  420|       |        // Verify that ImGui is correctly initialized
  421|  76.6k|        PHI_ASSERT(GImGui && GImGui->Initialized, "ImGui was not initialized!");
  422|       |
  423|  76.6k|        m_CursorPositionChanged = false;
  424|       |
  425|  76.6k|        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::ColorConvertU32ToFloat4(GetPaletteForIndex(
  426|  76.6k|                                                        PaletteIndex::Background)));
  427|  76.6k|        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
  428|       |
  429|       |        // Assert size is properly sanitized
  430|  76.6k|        PHI_ASSERT(size.x >= 0.0f);
  431|  76.6k|        PHI_ASSERT(!(phi::is_nan(size.x) || phi::is_infinity(size.x)));
  432|       |
  433|  76.6k|        PHI_ASSERT(size.y >= 0.0f);
  434|  76.6k|        PHI_ASSERT(!(phi::is_nan(size.y) || phi::is_infinity(size.y)));
  435|       |
  436|  76.6k|        if (ImGui::Begin("Code Editor"))
  ------------------
  |  Branch (436:13): [True: 16.9k, False: 59.7k]
  ------------------
  437|  16.9k|        {
  438|  16.9k|            ImGui::BeginChild("Code Editor", size, border.unsafe(),
  439|  16.9k|                              ImGuiWindowFlags_HorizontalScrollbar |
  440|  16.9k|                                      ImGuiWindowFlags_AlwaysHorizontalScrollbar |
  441|  16.9k|                                      ImGuiWindowFlags_NoMove);
  442|       |
  443|       |            // Need to calculate char advance before any inputs which use the values
  444|  16.9k|            ComputeCharAdvance();
  445|       |
  446|  16.9k|            HandleKeyboardInputs();
  447|  16.9k|            ImGui::PushTabStop(true);
  448|       |
  449|  16.9k|            HandleMouseInputs();
  450|       |
  451|  16.9k|            if (m_TextChanged)
  ------------------
  |  Branch (451:17): [True: 3.55k, False: 13.3k]
  ------------------
  452|  3.55k|            {
  453|  3.55k|                m_FullText = GetText();
  454|       |
  455|  3.55k|                m_Emulator->ParseProgram(m_FullText);
  456|       |
  457|  3.55k|                ColorizeInternal();
  458|       |
  459|  3.55k|                ClearErrorMarkers();
  460|       |
  461|       |                // Add error markers
  462|  3.55k|                for (const dlx::ParseError& err : m_Emulator->m_DLXProgram.m_ParseErrors)
  ------------------
  |  Branch (462:49): [True: 134k, False: 3.55k]
  ------------------
  463|   134k|                {
  464|   134k|                    AddErrorMarker(static_cast<phi::uint32_t>(err.GetLineNumber()),
  465|   134k|                                   err.ConstructMessage());
  466|   134k|                }
  467|       |
  468|  3.55k|                m_TextChanged = false;
  469|  3.55k|            }
  470|       |
  471|  16.9k|            InternalRender();
  472|       |
  473|  16.9k|            ImGui::PopTabStop();
  474|       |
  475|  16.9k|            ImGui::EndChild();
  476|  16.9k|        }
  477|  76.6k|        ImGui::End();
  478|       |
  479|  76.6k|        ImGui::PopStyleVar();
  480|  76.6k|        ImGui::PopStyleColor();
  481|  76.6k|    }
_ZN6dlxemu10CodeEditor7SetTextERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  484|    946|    {
  485|    946|        m_Lines.clear();
  486|    946|        ResetState();
  487|    946|        m_Lines.emplace_back();
  488|       |
  489|    946|        for (const char character : text)
  ------------------
  |  Branch (489:35): [True: 0, False: 946]
  ------------------
  490|      0|        {
  491|      0|            if (character == '\r' ||
  ------------------
  |  Branch (491:17): [True: 0, False: 0]
  |  Branch (491:17): [True: 0, False: 0]
  ------------------
  492|      0|                (phi::is_control(character) && character != '\n' && character != '\t'))
  ------------------
  |  Branch (492:18): [True: 0, False: 0]
  |  Branch (492:48): [True: 0, False: 0]
  |  Branch (492:69): [True: 0, False: 0]
  ------------------
  493|      0|            {
  494|       |                // ignore the carriage return character and control characters
  495|      0|            }
  496|      0|            else if (character == '\n')
  ------------------
  |  Branch (496:22): [True: 0, False: 0]
  ------------------
  497|      0|            {
  498|      0|                m_Lines.emplace_back();
  499|      0|            }
  500|      0|            else
  501|      0|            {
  502|      0|                m_Lines.back().emplace_back(static_cast<Char>(character), PaletteIndex::Default);
  503|      0|            }
  504|      0|        }
  505|       |
  506|    946|        m_TextChanged = true;
  507|    946|        m_ScrollToTop = true;
  508|       |
  509|    946|        m_UndoBuffer.clear();
  510|    946|        m_UndoIndex = 0u;
  511|       |
  512|    946|        Colorize();
  513|    946|    }
_ZNK6dlxemu10CodeEditor7GetTextEv:
  516|   199k|    {
  517|   199k|        const phi::u32 max_line = GetMaxLineNumber();
  518|       |
  519|   199k|        return GetText(Coordinates(0u, 0u), Coordinates(max_line, GetLineMaxColumn(max_line)));
  520|   199k|    }
_ZN6dlxemu10CodeEditor9ClearTextEv:
  523|    466|    {
  524|    466|        PHI_ASSERT(!m_Lines.empty());
  525|       |
  526|    466|        if (IsReadOnly())
  ------------------
  |  Branch (526:13): [True: 130, False: 336]
  ------------------
  527|    130|        {
  528|    130|            return;
  529|    130|        }
  530|       |
  531|       |        // No text to clear
  532|    336|        if (m_Lines.size() == 1u && m_Lines[0u].empty())
  ------------------
  |  Branch (532:13): [True: 236, False: 100]
  |  Branch (532:37): [True: 94, False: 142]
  ------------------
  533|     94|        {
  534|     94|            return;
  535|     94|        }
  536|       |
  537|    242|        UndoRecord undo;
  538|    242|        undo.StoreBeforeState(this);
  539|       |
  540|    242|        undo.m_Removed      = GetText();
  541|    242|        undo.m_RemovedStart = Coordinates(0u, 0u);
  542|    242|        phi::u32 max_line   = GetMaxLineNumber();
  543|    242|        undo.m_RemovedEnd   = Coordinates(max_line, GetLineMaxColumn(max_line));
  544|       |
  545|    242|        m_Lines.clear();
  546|    242|        m_Lines.emplace_back();
  547|    242|        ResetState();
  548|       |
  549|    242|        undo.StoreAfterState(this);
  550|    242|        AddUndo(undo);
  551|    242|    }
_ZN6dlxemu10CodeEditor12SetTextLinesERKNSt3__16vectorINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS6_IS8_EEEE:
  554|  1.05k|    {
  555|  1.05k|        m_Lines.clear();
  556|  1.05k|        ResetState();
  557|       |
  558|  1.05k|        if (lines.empty())
  ------------------
  |  Branch (558:13): [True: 209, False: 844]
  ------------------
  559|    209|        {
  560|    209|            m_Lines.emplace_back();
  561|    209|        }
  562|    844|        else
  563|    844|        {
  564|    844|            m_Lines.resize(lines.size());
  565|       |
  566|    844|            phi::usize line_number{0u};
  567|  3.33k|            for (phi::usize index = 0u; index < lines.size(); ++index, ++line_number)
  ------------------
  |  Branch (567:41): [True: 2.49k, False: 844]
  ------------------
  568|  2.49k|            {
  569|  2.49k|                const std::string& line = lines[index.unsafe()];
  570|       |
  571|  2.49k|                m_Lines[line_number.unsafe()].reserve(line.size());
  572|  2.49k|                for (char character : line)
  ------------------
  |  Branch (572:37): [True: 0, False: 2.49k]
  ------------------
  573|      0|                {
  574|      0|                    if (character == '\n')
  ------------------
  |  Branch (574:25): [True: 0, False: 0]
  ------------------
  575|      0|                    {
  576|       |                        // Hang on an extra line at the end
  577|      0|                        m_Lines.emplace_back();
  578|       |
  579|       |                        // Increase line number
  580|      0|                        line_number += 1u;
  581|      0|                    }
  582|      0|                    else
  583|      0|                    {
  584|      0|                        m_Lines[line_number.unsafe()].emplace_back(static_cast<Char>(character),
  585|      0|                                                                   PaletteIndex::Default);
  586|      0|                    }
  587|      0|                }
  588|  2.49k|            }
  589|    844|        }
  590|       |
  591|  1.05k|        m_TextChanged = true;
  592|  1.05k|        m_ScrollToTop = true;
  593|       |
  594|  1.05k|        m_UndoBuffer.clear();
  595|  1.05k|        m_UndoIndex = 0u;
  596|       |
  597|  1.05k|        Colorize();
  598|  1.05k|    }
_ZNK6dlxemu10CodeEditor12GetTextLinesEv:
  601|    446|    {
  602|    446|        std::vector<std::string> result;
  603|       |
  604|    446|        result.reserve(m_Lines.size());
  605|       |
  606|    446|        for (const Line& line : m_Lines)
  ------------------
  |  Branch (606:31): [True: 3.63k, False: 446]
  ------------------
  607|  3.63k|        {
  608|  3.63k|            std::string text;
  609|       |
  610|  3.63k|            text.resize(line.size());
  611|       |
  612|  72.7k|            for (size_t i = 0; i < line.size(); ++i)
  ------------------
  |  Branch (612:32): [True: 69.0k, False: 3.63k]
  ------------------
  613|  69.0k|            {
  614|  69.0k|                text[i] = static_cast<char>(line[i].m_Char);
  615|  69.0k|            }
  616|       |
  617|  3.63k|            result.emplace_back(phi::move(text));
  618|  3.63k|        }
  619|       |
  620|    446|        return result;
  621|    446|    }
_ZNK6dlxemu10CodeEditor15GetSelectedTextEv:
  624|  6.36k|    {
  625|  6.36k|        return GetText(m_State.m_SelectionStart, m_State.m_SelectionEnd);
  626|  6.36k|    }
_ZNK6dlxemu10CodeEditor18GetCurrentLineTextEv:
  629|    188|    {
  630|    188|        const phi::u32 line_length = GetLineMaxColumn(m_State.m_CursorPosition.m_Line);
  631|       |
  632|    188|        return GetText(Coordinates(m_State.m_CursorPosition.m_Line, 0u),
  633|    188|                       Coordinates(m_State.m_CursorPosition.m_Line, line_length));
  634|    188|    }
_ZN6dlxemu10CodeEditor12SetOverwriteEN3phi7booleanE:
  642|    778|    {
  643|    778|        m_Overwrite = overwrite;
  644|    778|    }
_ZN6dlxemu10CodeEditor11SetReadOnlyEN3phi7booleanE:
  657|    362|    {
  658|    362|        m_ReadOnly = value;
  659|    362|    }
_ZNK6dlxemu10CodeEditor10IsReadOnlyEv:
  667|   130k|    {
  668|   130k|        return m_ReadOnly;
  669|   130k|    }
_ZN6dlxemu10CodeEditor18SetColorizerEnableEN3phi7booleanE:
  682|    321|    {
  683|    321|        m_ColorizerEnabled = value;
  684|    321|    }
_ZNK6dlxemu10CodeEditor17GetCursorPositionEv:
  697|   132k|    {
  698|   132k|        return GetActualCursorCoordinates();
  699|   132k|    }
_ZN6dlxemu10CodeEditor17SetCursorPositionERKNS0_11CoordinatesE:
  702|  79.2k|    {
  703|       |        // Sanitize
  704|  79.2k|        const Coordinates new_pos = SanitizeCoordinates(position);
  705|       |
  706|  79.2k|        if (m_State.m_CursorPosition != new_pos)
  ------------------
  |  Branch (706:13): [True: 52.1k, False: 27.0k]
  ------------------
  707|  52.1k|        {
  708|  52.1k|            m_State.m_CursorPosition = new_pos;
  709|  52.1k|            m_CursorPositionChanged  = true;
  710|  52.1k|            EnsureCursorVisible();
  711|  52.1k|        }
  712|  79.2k|    }
_ZN6dlxemu10CodeEditor18SetShowWhitespacesEN3phi7booleanE:
  715|    161|    {
  716|    161|        m_ShowWhitespaces = value;
  717|    161|    }
_ZN6dlxemu10CodeEditor10SetTabSizeEN3phi7integerIhEE:
  730|  1.33k|    {
  731|  1.33k|        new_tab_size = phi::clamp(new_tab_size, MinTabSize, MaxTabSize);
  732|       |
  733|  1.33k|        if (new_tab_size != m_TabSize)
  ------------------
  |  Branch (733:13): [True: 640, False: 691]
  ------------------
  734|    640|        {
  735|       |            // Save old character indexes
  736|    640|            const phi::u32 cursor_char_index          = GetCharacterIndex(m_State.m_CursorPosition);
  737|    640|            const phi::u32 selection_start_char_index = GetCharacterIndex(m_State.m_SelectionStart);
  738|    640|            const phi::u32 selection_end_char_index   = GetCharacterIndex(m_State.m_SelectionEnd);
  739|       |
  740|       |            // Update tab size
  741|    640|            m_TabSize = new_tab_size;
  742|       |
  743|       |            // Set new character indexes
  744|    640|            m_State.m_CursorPosition.m_Column =
  745|    640|                    GetCharacterColumn(m_State.m_CursorPosition.m_Line, cursor_char_index);
  746|    640|            m_State.m_SelectionStart.m_Column =
  747|    640|                    GetCharacterColumn(m_State.m_SelectionStart.m_Line, selection_start_char_index);
  748|    640|            m_State.m_SelectionEnd.m_Column =
  749|    640|                    GetCharacterColumn(m_State.m_SelectionEnd.m_Line, selection_end_char_index);
  750|    640|        }
  751|  1.33k|    }
_ZN6dlxemu10CodeEditor14EnterCharacterEtN3phi7booleanE:
  759|  29.9k|    {
  760|  29.9k|        if (!IsReadOnly() && character != '\0' && IsValidUTF8Sequence(character))
  ------------------
  |  Branch (760:13): [True: 29.7k, False: 207]
  |  Branch (760:13): [True: 28.9k, False: 1.00k]
  |  Branch (760:30): [True: 28.9k, False: 769]
  |  Branch (760:51): [True: 28.9k, False: 25]
  ------------------
  761|  28.9k|        {
  762|  28.9k|            EnterCharacterImpl(character, shift);
  763|  28.9k|        }
  764|  29.9k|    }
_ZN6dlxemu10CodeEditor9BackspaceEv:
  767|  16.7k|    {
  768|  16.7k|        if (!IsReadOnly())
  ------------------
  |  Branch (768:13): [True: 16.4k, False: 251]
  ------------------
  769|  16.4k|        {
  770|  16.4k|            BackspaceImpl();
  771|  16.4k|        }
  772|  16.7k|    }
_ZN6dlxemu10CodeEditor10InsertTextERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE:
  775|    634|    {
  776|    634|        InsertText(value.c_str());
  777|    634|    }
_ZN6dlxemu10CodeEditor10InsertTextEPKc:
  780|  18.6k|    {
  781|  18.6k|        if (value == nullptr || m_ReadOnly)
  ------------------
  |  Branch (781:13): [True: 0, False: 18.6k]
  |  Branch (781:33): [True: 116, False: 18.5k]
  ------------------
  782|    116|        {
  783|    116|            return;
  784|    116|        }
  785|       |
  786|  18.5k|        Coordinates       pos         = GetActualCursorCoordinates();
  787|  18.5k|        const Coordinates start       = HasSelection() ? m_State.m_SelectionStart : pos;
  ------------------
  |  Branch (787:41): [True: 328, False: 18.2k]
  ------------------
  788|  18.5k|        phi::u32          total_lines = pos.m_Line - start.m_Line;
  789|       |
  790|  18.5k|        total_lines += InsertTextAt(pos, value);
  791|       |
  792|  18.5k|        SetSelection(pos, pos);
  793|  18.5k|        SetCursorPosition(pos);
  794|       |
  795|  18.5k|        Colorize(start.m_Line, total_lines);
  796|  18.5k|    }
_ZN6dlxemu10CodeEditor6MoveUpEN3phi7integerIjEENS1_7booleanE:
  799|    416|    {
  800|    416|        if (amount == 0u)
  ------------------
  |  Branch (800:13): [True: 136, False: 280]
  ------------------
  801|    136|        {
  802|    136|            return;
  803|    136|        }
  804|       |
  805|    280|        const Coordinates old_pos = m_State.m_CursorPosition;
  806|       |
  807|       |        // Move cursor to the beginning of the first line
  808|    280|        if (amount > old_pos.m_Line)
  ------------------
  |  Branch (808:13): [True: 182, False: 98]
  ------------------
  809|    182|        {
  810|    182|            m_State.m_CursorPosition.m_Line   = 0u;
  811|    182|            m_State.m_CursorPosition.m_Column = 0u;
  812|    182|        }
  813|     98|        else
  814|     98|        {
  815|     98|            PHI_ASSERT(amount <= m_State.m_CursorPosition.m_Line);
  816|     98|            m_State.m_CursorPosition.m_Line -= amount;
  817|     98|        }
  818|       |
  819|    280|        FixSelectionAfterMove(select, old_pos);
  820|    280|    }
_ZN6dlxemu10CodeEditor8MoveDownEN3phi7integerIjEENS1_7booleanE:
  823|  2.32k|    {
  824|  2.32k|        if (amount == 0u)
  ------------------
  |  Branch (824:13): [True: 108, False: 2.21k]
  ------------------
  825|    108|        {
  826|    108|            return;
  827|    108|        }
  828|       |
  829|  2.21k|        const Coordinates old_pos  = m_State.m_CursorPosition;
  830|  2.21k|        const phi::u32    max_line = GetMaxLineNumber();
  831|       |
  832|  2.21k|        PHI_ASSERT(old_pos.m_Line <= max_line);
  833|       |
  834|       |        // Move cursor to the end of the line after we reached the bottom
  835|  2.21k|        if (amount > max_line - old_pos.m_Line)
  ------------------
  |  Branch (835:13): [True: 2.12k, False: 90]
  ------------------
  836|  2.12k|        {
  837|  2.12k|            m_State.m_CursorPosition.m_Line   = max_line;
  838|  2.12k|            m_State.m_CursorPosition.m_Column = GetLineMaxColumn(max_line);
  839|  2.12k|        }
  840|     90|        else
  841|     90|        {
  842|     90|            m_State.m_CursorPosition.m_Line += amount;
  843|     90|        }
  844|       |
  845|  2.21k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line <= max_line);
  846|       |
  847|  2.21k|        FixSelectionAfterMove(select, old_pos);
  848|  2.21k|    }
_ZN6dlxemu10CodeEditor8MoveLeftEN3phi7integerIjEENS1_7booleanES4_:
  851|  5.22k|    {
  852|  5.22k|        PHI_ASSERT(!m_Lines.empty());
  853|       |
  854|  5.22k|        if (amount == 0u)
  ------------------
  |  Branch (854:13): [True: 248, False: 4.97k]
  ------------------
  855|    248|        {
  856|    248|            return;
  857|    248|        }
  858|       |
  859|  4.97k|        const Coordinates old_pos = m_State.m_CursorPosition;
  860|  4.97k|        m_State.m_CursorPosition  = GetActualCursorCoordinates();
  861|  4.97k|        phi::u32 line             = m_State.m_CursorPosition.m_Line;
  862|  4.97k|        phi::u32 cindex           = GetCharacterIndex(m_State.m_CursorPosition);
  863|       |
  864|   646k|        while (amount > 0u)
  ------------------
  |  Branch (864:16): [True: 641k, False: 4.97k]
  ------------------
  865|   641k|        {
  866|   641k|            amount -= 1u;
  867|       |
  868|   641k|            if (cindex == 0u)
  ------------------
  |  Branch (868:17): [True: 545k, False: 95.8k]
  ------------------
  869|   545k|            {
  870|   545k|                if (line == 0u)
  ------------------
  |  Branch (870:21): [True: 4.77k, False: 540k]
  ------------------
  871|  4.77k|                {
  872|       |                    // We're already on the last line so we can't move further left
  873|  4.77k|                    amount = 0u;
  874|  4.77k|                }
  875|   540k|                else
  876|   540k|                {
  877|   540k|                    line -= 1u;
  878|   540k|                    cindex = static_cast<phi::uint32_t>(m_Lines[line.unsafe()].size());
  879|   540k|                }
  880|   545k|            }
  881|  95.8k|            else
  882|  95.8k|            {
  883|  95.8k|                --cindex;
  884|  95.8k|                if (cindex > 0u && m_Lines.size() > line)
  ------------------
  |  Branch (884:21): [True: 64.2k, False: 31.5k]
  |  Branch (884:21): [True: 64.2k, False: 31.5k]
  |  Branch (884:36): [True: 64.2k, False: 0]
  ------------------
  885|  64.2k|                {
  886|   101k|                    while (cindex > 0u &&
  ------------------
  |  Branch (886:28): [True: 97.2k, False: 4.17k]
  |  Branch (886:28): [True: 37.2k, False: 64.2k]
  ------------------
  887|   101k|                           IsUTFSequence(m_Lines[line.unsafe()][cindex.unsafe()].m_Char))
  ------------------
  |  Branch (887:28): [True: 37.2k, False: 60.0k]
  ------------------
  888|  37.2k|                    {
  889|  37.2k|                        --cindex;
  890|  37.2k|                    }
  891|  64.2k|                }
  892|  95.8k|            }
  893|       |
  894|   641k|            m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  895|   641k|            if (word_mode)
  ------------------
  |  Branch (895:17): [True: 613k, False: 28.2k]
  ------------------
  896|   613k|            {
  897|   613k|                m_State.m_CursorPosition = FindWordStart(m_State.m_CursorPosition);
  898|   613k|                cindex                   = GetCharacterIndex(m_State.m_CursorPosition);
  899|   613k|            }
  900|   641k|        }
  901|       |
  902|  4.97k|        m_State.m_CursorPosition = Coordinates(line, GetCharacterColumn(line, cindex));
  903|  4.97k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
  904|       |
  905|  4.97k|        FixSelectionAfterMove(select, old_pos);
  906|  4.97k|    }
_ZN6dlxemu10CodeEditor9MoveRightEN3phi7integerIjEENS1_7booleanES4_:
  910|    412|    {
  911|    412|        const Coordinates old_pos = m_State.m_CursorPosition;
  912|       |
  913|    412|        if (old_pos.m_Line >= m_Lines.size() || amount == 0u)
  ------------------
  |  Branch (913:13): [True: 0, False: 412]
  |  Branch (913:13): [True: 39, False: 373]
  |  Branch (913:49): [True: 39, False: 373]
  ------------------
  914|     39|        {
  915|     39|            return;
  916|     39|        }
  917|       |
  918|    373|        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
  919|  4.56k|        while (amount > 0u)
  ------------------
  |  Branch (919:16): [True: 4.43k, False: 126]
  ------------------
  920|  4.43k|        {
  921|  4.43k|            amount -= 1u;
  922|       |
  923|  4.43k|            const phi::u32 lindex = m_State.m_CursorPosition.m_Line;
  924|  4.43k|            PHI_ASSERT(lindex < m_Lines.size());
  925|  4.43k|            const Line& line = m_Lines[lindex.unsafe()];
  926|       |
  927|  4.43k|            if (cindex >= line.size())
  ------------------
  |  Branch (927:17): [True: 593, False: 3.84k]
  ------------------
  928|    593|            {
  929|    593|                if (m_State.m_CursorPosition.m_Line < GetMaxLineNumber())
  ------------------
  |  Branch (929:21): [True: 346, False: 247]
  ------------------
  930|    346|                {
  931|    346|                    m_State.m_CursorPosition.m_Line =
  932|    346|                            phi::clamp(m_State.m_CursorPosition.m_Line.unsafe() + 1u, 0u,
  933|    346|                                       GetMaxLineNumber().unsafe());
  934|    346|                    m_State.m_CursorPosition.m_Column = 0u;
  935|    346|                }
  936|    247|                else
  937|    247|                {
  938|    247|                    return;
  939|    247|                }
  940|    593|            }
  941|  3.84k|            else
  942|  3.84k|            {
  943|  3.84k|                PHI_ASSERT(cindex < line.size());
  944|  3.84k|                cindex += UTF8CharLength(line[cindex.unsafe()].m_Char);
  945|  3.84k|                m_State.m_CursorPosition = Coordinates(lindex, GetCharacterColumn(lindex, cindex));
  946|       |
  947|  3.84k|                if (word_mode)
  ------------------
  |  Branch (947:21): [True: 3.29k, False: 552]
  ------------------
  948|  3.29k|                {
  949|  3.29k|                    m_State.m_CursorPosition = FindNextWord(m_State.m_CursorPosition);
  950|  3.29k|                }
  951|  3.84k|            }
  952|  4.43k|        }
  953|       |
  954|    126|        FixSelectionAfterMove(select, old_pos);
  955|    126|    }
_ZN6dlxemu10CodeEditor7MoveTopEN3phi7booleanE:
  958|  1.02k|    {
  959|  1.02k|        const Coordinates old_pos = m_State.m_CursorPosition;
  960|  1.02k|        SetCursorPosition(Coordinates(0u, 0u));
  961|       |
  962|  1.02k|        if (select)
  ------------------
  |  Branch (962:13): [True: 345, False: 676]
  ------------------
  963|    345|        {
  964|    345|            m_InteractiveEnd   = old_pos;
  965|    345|            m_InteractiveStart = m_State.m_CursorPosition;
  966|    345|        }
  967|    676|        else
  968|    676|        {
  969|    676|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
  970|    676|        }
  971|       |
  972|  1.02k|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
  973|  1.02k|        EnsureCursorVisible();
  974|  1.02k|    }
_ZN6dlxemu10CodeEditor10MoveBottomEN3phi7booleanE:
  977|    575|    {
  978|    575|        const Coordinates old_pos = GetCursorPosition();
  979|       |
  980|    575|        const phi::u32 end_line = GetMaxLineNumber();
  981|    575|        Coordinates    new_pos  = Coordinates(end_line, GetLineMaxColumn(end_line));
  982|       |
  983|    575|        SetCursorPosition(new_pos);
  984|    575|        if (select)
  ------------------
  |  Branch (984:13): [True: 422, False: 153]
  ------------------
  985|    422|        {
  986|    422|            m_InteractiveStart = old_pos;
  987|    422|            m_InteractiveEnd   = new_pos;
  988|    422|        }
  989|    153|        else
  990|    153|        {
  991|    153|            m_InteractiveStart = m_InteractiveEnd = new_pos;
  992|    153|        }
  993|       |
  994|    575|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
  995|    575|        EnsureCursorVisible();
  996|    575|    }
_ZN6dlxemu10CodeEditor8MoveHomeEN3phi7booleanE:
  999|  3.37k|    {
 1000|  3.37k|        const Coordinates old_pos = m_State.m_CursorPosition;
 1001|  3.37k|        SetCursorPosition(Coordinates(m_State.m_CursorPosition.m_Line, 0u));
 1002|       |
 1003|  3.37k|        FixSelectionAfterMove(select, old_pos);
 1004|  3.37k|    }
_ZN6dlxemu10CodeEditor7MoveEndEN3phi7booleanE:
 1007|    542|    {
 1008|    542|        Coordinates old_pos = m_State.m_CursorPosition;
 1009|    542|        SetCursorPosition(
 1010|    542|                Coordinates(m_State.m_CursorPosition.m_Line, GetLineMaxColumn(old_pos.m_Line)));
 1011|       |
 1012|    542|        FixSelectionAfterMove(select, old_pos);
 1013|    542|    }
_ZN6dlxemu10CodeEditor17SetSelectionStartERKNS0_11CoordinatesE:
 1016|    279|    {
 1017|    279|        m_State.m_SelectionStart = SanitizeCoordinates(position);
 1018|    279|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1018:13): [True: 115, False: 164]
  ------------------
 1019|    115|        {
 1020|    115|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1021|    115|        }
 1022|    279|    }
_ZN6dlxemu10CodeEditor15SetSelectionEndERKNS0_11CoordinatesE:
 1025|    488|    {
 1026|    488|        m_State.m_SelectionEnd = SanitizeCoordinates(position);
 1027|    488|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1027:13): [True: 188, False: 300]
  ------------------
 1028|    188|        {
 1029|    188|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1030|    188|        }
 1031|    488|    }
_ZN6dlxemu10CodeEditor12SetSelectionERKNS0_11CoordinatesES3_NS0_13SelectionModeE:
 1037|  67.5k|    {
 1038|  67.5k|        const Coordinates old_sel_start = m_State.m_SelectionStart;
 1039|  67.5k|        const Coordinates old_sel_end   = m_State.m_SelectionEnd;
 1040|       |
 1041|  67.5k|        m_State.m_SelectionStart = SanitizeCoordinates(start);
 1042|  67.5k|        m_State.m_SelectionEnd   = SanitizeCoordinates(end);
 1043|  67.5k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (1043:13): [True: 855, False: 66.7k]
  ------------------
 1044|    855|        {
 1045|    855|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 1046|    855|        }
 1047|       |
 1048|  67.5k|        switch (mode)
 1049|  67.5k|        {
 1050|  67.3k|            case CodeEditor::SelectionMode::Normal:
  ------------------
  |  Branch (1050:13): [True: 67.3k, False: 235]
  ------------------
 1051|  67.3k|                break;
 1052|    215|            case CodeEditor::SelectionMode::Word: {
  ------------------
  |  Branch (1052:13): [True: 215, False: 67.3k]
  ------------------
 1053|    215|                m_State.m_SelectionStart = FindWordStart(m_State.m_SelectionStart);
 1054|    215|                if (!IsOnWordBoundary(m_State.m_SelectionEnd))
  ------------------
  |  Branch (1054:21): [True: 0, False: 215]
  ------------------
 1055|      0|                {
 1056|      0|                    m_State.m_SelectionEnd = FindWordEnd(FindWordStart(m_State.m_SelectionEnd));
 1057|      0|                }
 1058|    215|                break;
 1059|      0|            }
 1060|     20|            case CodeEditor::SelectionMode::Line: {
  ------------------
  |  Branch (1060:13): [True: 20, False: 67.5k]
  ------------------
 1061|     20|                const phi::u32 line_no   = m_State.m_SelectionEnd.m_Line;
 1062|     20|                m_State.m_SelectionStart = Coordinates(m_State.m_SelectionStart.m_Line, 0u);
 1063|     20|                m_State.m_SelectionEnd   = Coordinates(line_no, GetLineMaxColumn(line_no));
 1064|     20|                break;
 1065|      0|            }
 1066|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
 1067|      0|            default:
  ------------------
  |  Branch (1067:13): [True: 0, False: 67.5k]
  ------------------
 1068|      0|                PHI_ASSERT_NOT_REACHED();
 1069|  67.5k|#endif
 1070|  67.5k|        }
 1071|       |
 1072|  67.5k|        if (m_State.m_SelectionStart != old_sel_start || m_State.m_SelectionEnd != old_sel_end)
  ------------------
  |  Branch (1072:13): [True: 26.7k, False: 40.8k]
  |  Branch (1072:13): [True: 31.3k, False: 36.2k]
  |  Branch (1072:58): [True: 4.53k, False: 36.2k]
  ------------------
 1073|  31.3k|        {
 1074|  31.3k|            m_CursorPositionChanged = true;
 1075|  31.3k|        }
 1076|  67.5k|    }
_ZN6dlxemu10CodeEditor21SelectWordUnderCursorEv:
 1081|    962|    {
 1082|    962|        const Coordinates coords = GetCursorPosition();
 1083|    962|        SetSelection(FindWordStart(coords), FindWordEnd(coords));
 1084|    962|    }
_ZN6dlxemu10CodeEditor9SelectAllEv:
 1087|    727|    {
 1088|    727|        SetSelection(Coordinates(0u, 0u),
 1089|    727|                     Coordinates(static_cast<phi::uint32_t>(m_Lines.size()), 0u));
 1090|    727|    }
_ZN6dlxemu10CodeEditor14ClearSelectionEv:
 1093|  29.9k|    {
 1094|  29.9k|        SetSelection(Coordinates(0u, 0u), Coordinates(0u, 0u));
 1095|  29.9k|    }
_ZNK6dlxemu10CodeEditor12HasSelectionEv:
 1098|   111k|    {
 1099|   111k|        return m_State.m_SelectionEnd > m_State.m_SelectionStart;
 1100|   111k|    }
_ZNK6dlxemu10CodeEditor17GetSelectionStartEv:
 1103|   131k|    {
 1104|   131k|        return m_State.m_SelectionStart;
 1105|   131k|    }
_ZNK6dlxemu10CodeEditor15GetSelectionEndEv:
 1108|   131k|    {
 1109|   131k|        return m_State.m_SelectionEnd;
 1110|   131k|    }
_ZNK6dlxemu10CodeEditor4CopyEv:
 1113|  10.4k|    {
 1114|  10.4k|        if (HasSelection())
  ------------------
  |  Branch (1114:13): [True: 2.52k, False: 7.93k]
  ------------------
 1115|  2.52k|        {
 1116|  2.52k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1117|  2.52k|            m_FuzzingClipboardText = GetSelectedText();
 1118|       |#else
 1119|       |            ImGui::SetClipboardText(GetSelectedText().c_str());
 1120|       |#endif
 1121|  2.52k|        }
 1122|  7.93k|        else
 1123|  7.93k|        {
 1124|  7.93k|            PHI_ASSERT(!m_Lines.empty());
 1125|       |
 1126|  7.93k|            std::string str;
 1127|  7.93k|            const Line& line = m_Lines[GetActualCursorCoordinates().m_Line.unsafe()];
 1128|       |
 1129|  7.93k|            for (const Glyph& glyph : line)
  ------------------
  |  Branch (1129:37): [True: 100M, False: 7.93k]
  ------------------
 1130|   100M|            {
 1131|   100M|                str.push_back(static_cast<char>(glyph.m_Char));
 1132|   100M|            }
 1133|       |
 1134|  7.93k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1135|  7.93k|            m_FuzzingClipboardText = str;
 1136|       |#else
 1137|       |            ImGui::SetClipboardText(str.c_str());
 1138|       |#endif
 1139|  7.93k|        }
 1140|  10.4k|    }
_ZN6dlxemu10CodeEditor3CutEv:
 1143|    820|    {
 1144|    820|        if (IsReadOnly())
  ------------------
  |  Branch (1144:13): [True: 416, False: 404]
  ------------------
 1145|    416|        {
 1146|    416|            Copy();
 1147|    416|        }
 1148|    404|        else
 1149|    404|        {
 1150|    404|            if (HasSelection())
  ------------------
  |  Branch (1150:17): [True: 226, False: 178]
  ------------------
 1151|    226|            {
 1152|    226|                UndoRecord undo;
 1153|    226|                undo.StoreBeforeState(this);
 1154|    226|                undo.m_Removed      = GetSelectedText();
 1155|    226|                undo.m_RemovedStart = m_State.m_SelectionStart;
 1156|    226|                undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1157|       |
 1158|    226|                Copy();
 1159|    226|                DeleteSelection();
 1160|       |
 1161|    226|                undo.StoreAfterState(this);
 1162|    226|                AddUndo(undo);
 1163|    226|            }
 1164|    404|        }
 1165|    820|    }
_ZN6dlxemu10CodeEditor5PasteEv:
 1168|  19.4k|    {
 1169|  19.4k|        if (IsReadOnly())
  ------------------
  |  Branch (1169:13): [True: 133, False: 19.3k]
  ------------------
 1170|    133|        {
 1171|    133|            return;
 1172|    133|        }
 1173|       |
 1174|  19.3k|        const char* clip_text =
 1175|  19.3k|#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 1176|  19.3k|                m_FuzzingClipboardText.c_str();
 1177|       |#else
 1178|       |                ImGui::GetClipboardText();
 1179|       |#endif
 1180|  19.3k|        if (phi::string_length(clip_text) == 0u)
  ------------------
  |  Branch (1180:13): [True: 1.30k, False: 18.0k]
  ------------------
 1181|  1.30k|        {
 1182|  1.30k|            return;
 1183|  1.30k|        }
 1184|       |
 1185|  18.0k|        UndoRecord undo;
 1186|  18.0k|        undo.StoreBeforeState(this);
 1187|       |
 1188|  18.0k|        if (HasSelection())
  ------------------
  |  Branch (1188:13): [True: 2.23k, False: 15.7k]
  ------------------
 1189|  2.23k|        {
 1190|  2.23k|            undo.m_Removed      = GetSelectedText();
 1191|  2.23k|            undo.m_RemovedStart = m_State.m_SelectionStart;
 1192|  2.23k|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1193|  2.23k|            DeleteSelection();
 1194|  2.23k|        }
 1195|       |
 1196|  18.0k|        undo.m_Added      = clip_text;
 1197|  18.0k|        undo.m_AddedStart = GetActualCursorCoordinates();
 1198|       |
 1199|  18.0k|        InsertText(clip_text);
 1200|       |
 1201|  18.0k|        undo.m_AddedEnd = GetActualCursorCoordinates();
 1202|  18.0k|        undo.StoreAfterState(this);
 1203|       |
 1204|  18.0k|        AddUndo(undo);
 1205|  18.0k|    }
_ZN6dlxemu10CodeEditor6DeleteEv:
 1208|  2.12k|    {
 1209|  2.12k|        PHI_ASSERT(!m_Lines.empty());
 1210|       |
 1211|  2.12k|        if (m_ReadOnly)
  ------------------
  |  Branch (1211:13): [True: 125, False: 1.99k]
  ------------------
 1212|    125|        {
 1213|    125|            return;
 1214|    125|        }
 1215|       |
 1216|  1.99k|        UndoRecord undo;
 1217|  1.99k|        undo.StoreBeforeState(this);
 1218|       |
 1219|  1.99k|        if (HasSelection())
  ------------------
  |  Branch (1219:13): [True: 121, False: 1.87k]
  ------------------
 1220|    121|        {
 1221|    121|            undo.m_Removed      = GetSelectedText();
 1222|    121|            undo.m_RemovedStart = m_State.m_SelectionStart;
 1223|    121|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 1224|       |
 1225|    121|            DeleteSelection();
 1226|    121|        }
 1227|  1.87k|        else
 1228|  1.87k|        {
 1229|  1.87k|            const Coordinates pos = GetActualCursorCoordinates();
 1230|  1.87k|            PHI_ASSERT(pos.m_Line < m_Lines.size());
 1231|  1.87k|            PHI_ASSERT(pos.m_Column <= GetLineMaxColumn(pos.m_Line));
 1232|       |
 1233|  1.87k|            SetCursorPosition(pos);
 1234|  1.87k|            Line& line = m_Lines[pos.m_Line.unsafe()];
 1235|       |
 1236|  1.87k|            if (pos.m_Column == GetLineMaxColumn(pos.m_Line))
  ------------------
  |  Branch (1236:17): [True: 1.10k, False: 777]
  ------------------
 1237|  1.10k|            {
 1238|  1.10k|                if (pos.m_Line == GetMaxLineNumber())
  ------------------
  |  Branch (1238:21): [True: 526, False: 575]
  ------------------
 1239|    526|                {
 1240|    526|                    return;
 1241|    526|                }
 1242|       |
 1243|    575|                undo.m_Removed      = '\n';
 1244|    575|                undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 1245|    575|                Advance(undo.m_RemovedEnd);
 1246|       |
 1247|    575|                PHI_ASSERT(pos.m_Line + 1u < m_Lines.size());
 1248|    575|                const Line& next_line = m_Lines[pos.m_Line.unsafe() + 1];
 1249|    575|                line.insert(line.end(), next_line.begin(), next_line.end());
 1250|       |
 1251|    575|                PHI_ASSERT(pos.m_Line <= m_Lines.size());
 1252|    575|                RemoveLine(pos.m_Line + 1u);
 1253|    575|            }
 1254|    777|            else
 1255|    777|            {
 1256|       |                // Nothing todo when line is empty
 1257|    777|                if (line.empty())
  ------------------
  |  Branch (1257:21): [True: 0, False: 777]
  ------------------
 1258|      0|                {
 1259|      0|                    return;
 1260|      0|                }
 1261|       |
 1262|    777|                const phi::u32 cindex = GetCharacterIndex(pos);
 1263|    777|                PHI_ASSERT(cindex < line.size());
 1264|       |
 1265|    777|                const Coordinates current_cursor_pos = GetActualCursorCoordinates();
 1266|    777|                undo.m_RemovedStart                  = current_cursor_pos;
 1267|    777|                undo.m_RemovedEnd                    = current_cursor_pos;
 1268|    777|                undo.m_RemovedEnd.m_Column++;
 1269|    777|                undo.m_Removed = GetText(undo.m_RemovedStart, undo.m_RemovedEnd);
 1270|       |
 1271|    777|                phi::u8_fast length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1272|  2.63k|                while (length > 0u && cindex < line.size())
  ------------------
  |  Branch (1272:24): [True: 1.86k, False: 777]
  |  Branch (1272:24): [True: 1.86k, False: 777]
  |  Branch (1272:39): [True: 1.86k, False: 0]
  ------------------
 1273|  1.86k|                {
 1274|  1.86k|                    line.erase(line.begin() + cindex.unsafe());
 1275|  1.86k|                    length--;
 1276|  1.86k|                }
 1277|       |
 1278|       |                // Remove any kind of selection if we had any
 1279|    777|                ClearSelection();
 1280|    777|            }
 1281|       |
 1282|  1.35k|            m_TextChanged = true;
 1283|       |
 1284|  1.35k|            Colorize(pos.m_Line, 1);
 1285|  1.35k|        }
 1286|       |
 1287|  1.47k|        undo.StoreAfterState(this);
 1288|  1.47k|        AddUndo(undo);
 1289|  1.47k|    }
_ZNK6dlxemu10CodeEditor7CanUndoEv:
 1292|   197k|    {
 1293|   197k|        return !m_ReadOnly && m_UndoIndex != 0u;
  ------------------
  |  Branch (1293:16): [True: 196k, False: 66]
  |  Branch (1293:31): [True: 190k, False: 6.17k]
  ------------------
 1294|   197k|    }
_ZN6dlxemu10CodeEditor4UndoEN3phi7integerIjEE:
 1297|  66.2k|    {
 1298|   132k|        while (CanUndo() && steps > 0u)
  ------------------
  |  Branch (1298:16): [True: 125k, False: 6.23k]
  |  Branch (1298:16): [True: 66.0k, False: 66.2k]
  |  Branch (1298:29): [True: 66.0k, False: 59.9k]
  ------------------
 1299|  66.0k|        {
 1300|  66.0k|            m_UndoIndex -= 1u;
 1301|  66.0k|            m_UndoBuffer[m_UndoIndex.unsafe()].Undo(this);
 1302|  66.0k|            steps -= 1u;
 1303|  66.0k|        }
 1304|  66.2k|    }
_ZNK6dlxemu10CodeEditor7CanRedoEv:
 1307|   194k|    {
 1308|   194k|        return !m_ReadOnly && m_UndoIndex < m_UndoBuffer.size();
  ------------------
  |  Branch (1308:16): [True: 194k, False: 101]
  |  Branch (1308:31): [True: 129k, False: 65.0k]
  ------------------
 1309|   194k|    }
_ZN6dlxemu10CodeEditor4RedoEN3phi7integerIjEE:
 1312|  65.1k|    {
 1313|   130k|        while (CanRedo() && steps > 0u)
  ------------------
  |  Branch (1313:16): [True: 64.9k, False: 65.1k]
  |  Branch (1313:16): [True: 64.8k, False: 65.1k]
  |  Branch (1313:29): [True: 64.8k, False: 66]
  ------------------
 1314|  64.8k|        {
 1315|  64.8k|            m_UndoBuffer[m_UndoIndex.unsafe()].Redo(this);
 1316|  64.8k|            m_UndoIndex += 1u;
 1317|  64.8k|            steps -= 1u;
 1318|  64.8k|        }
 1319|  65.1k|    }
_ZN6dlxemu10CodeEditor13UpdatePaletteEv:
 1470|  9.87k|    {
 1471|  9.87k|        PHI_ASSERT(GImGui && GImGui->Initialized);
 1472|       |
 1473|       |        // Update palette with the current alpha from style
 1474|   148k|        for (phi::usize i = 0u; i < phi::to_underlying(PaletteIndex::Max); ++i)
  ------------------
  |  Branch (1474:33): [True: 138k, False: 9.87k]
  ------------------
 1475|   138k|        {
 1476|   138k|            ImVec4 color = ImGui::ColorConvertU32ToFloat4(m_PaletteBase[i]);
 1477|   138k|            color.w *= ImGui::GetStyle().Alpha;
 1478|   138k|            m_Palette[i] = ImGui::ColorConvertFloat4ToU32(color);
 1479|   138k|        }
 1480|  9.87k|    }
_ZNK6dlxemu10CodeEditor19VerifyInternalStateEv:
 1483|   283k|    {
 1484|       |        // Lines should never be empty
 1485|   283k|        PHI_ASSERT(!m_Lines.empty());
 1486|       |
 1487|       |        // Verify Selection is still in a valid state
 1488|   283k|        PHI_ASSERT(m_State.m_SelectionEnd >= m_State.m_SelectionStart);
 1489|   283k|        PHI_ASSERT(m_State.m_SelectionStart.m_Line < m_Lines.size());
 1490|   283k|        PHI_ASSERT(m_State.m_SelectionStart.m_Column >= 0u);
 1491|   283k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Line < m_Lines.size());
 1492|   283k|        PHI_ASSERT(m_State.m_SelectionEnd.m_Column >= 0u);
 1493|       |
 1494|       |        // Verify cursor position
 1495|   283k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line >= 0u);
 1496|   283k|        PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 1497|   283k|        PHI_ASSERT(m_State.m_CursorPosition.m_Column >= 0u);
 1498|       |
 1499|       |        // This should also always be true. But its implementation is way to slow when fuzzing
 1500|       |#if defined(DLXEMU_VERIFY_COLUMN)
 1501|       |        PHI_ASSERT(m_State.m_SelectionStart.m_Column <=
 1502|       |                   GetLineMaxColumn(m_State.m_SelectionStart.m_Line));
 1503|       |        PHI_ASSERT(m_State.m_SelectionEnd.m_Column <=
 1504|       |                   GetLineMaxColumn(m_State.m_SelectionEnd.m_Line));
 1505|       |#endif
 1506|       |
 1507|       |        // Verify that all breakpoints are on existing lines
 1508|   283k|        for (phi::u32 break_point : m_Breakpoints)
  ------------------
  |  Branch (1508:35): [True: 38.5k, False: 283k]
  ------------------
 1509|  38.5k|        {
 1510|  38.5k|            PHI_ASSERT(break_point != 0u);
 1511|  38.5k|            PHI_ASSERT(break_point <= m_Lines.size());
 1512|  38.5k|        }
 1513|       |
 1514|       |        // Verify that all error markers are on existing lines
 1515|   283k|        for (auto&& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (1515:34): [True: 45.3k, False: 283k]
  ------------------
 1516|  45.3k|        {
 1517|  45.3k|            const phi::u32 line_number = error_marker.first;
 1518|       |
 1519|  45.3k|            PHI_ASSERT(line_number != 0u);
 1520|  45.3k|            PHI_ASSERT(line_number <= m_Lines.size());
 1521|  45.3k|        }
 1522|   283k|    }
_ZN6dlxemu10CodeEditor14GetDarkPaletteEv:
 1525|  19.7k|    {
 1526|  19.7k|        constexpr const static Palette palette = {{
 1527|  19.7k|                0xff7f7f7f, // Default
 1528|  19.7k|                0xffd69c56, // OpCode
 1529|  19.7k|                0xff00ff00, // Register
 1530|  19.7k|                0xff7070e0, // IntegerLiteral
 1531|  19.7k|                0xff206020, // Comment
 1532|  19.7k|                0xff101010, // Background
 1533|  19.7k|                0xffe0e0e0, // Cursor
 1534|  19.7k|                0x80a06020, // Selection
 1535|  19.7k|                0x800020ff, // ErrorMarker
 1536|  19.7k|                0x40f08000, // Breakpoint
 1537|  19.7k|                0xff707000, // Line number
 1538|  19.7k|                0x40000000, // Current line fill
 1539|  19.7k|                0x40808080, // Current line fill (inactive)
 1540|  19.7k|                0x40a0a0a0, // Current line edge
 1541|  19.7k|        }};
 1542|       |
 1543|  19.7k|        return palette;
 1544|  19.7k|    }
_ZNK6dlxemu10CodeEditor11EditorStateeqERKS1_:
 1592|  64.7k|    {
 1593|  64.7k|        return other.m_CursorPosition == m_CursorPosition &&
  ------------------
  |  Branch (1593:16): [True: 64.7k, False: 0]
  ------------------
 1594|  64.7k|               other.m_SelectionStart == m_SelectionStart && other.m_SelectionEnd == m_SelectionEnd;
  ------------------
  |  Branch (1594:16): [True: 64.7k, False: 0]
  |  Branch (1594:62): [True: 64.7k, False: 0]
  ------------------
 1595|  64.7k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4UndoEPS0_:
 1605|  66.0k|    {
 1606|  66.0k|        PHI_ASSERT(editor != nullptr);
 1607|       |
 1608|  66.0k|        if (!m_Added.empty())
  ------------------
  |  Branch (1608:13): [True: 48.4k, False: 17.5k]
  ------------------
 1609|  48.4k|        {
 1610|  48.4k|            editor->DeleteRange(m_AddedStart, m_AddedEnd);
 1611|  48.4k|            editor->Colorize(m_AddedStart.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1612|  48.4k|        }
 1613|       |
 1614|  66.0k|        if (!m_Removed.empty())
  ------------------
  |  Branch (1614:13): [True: 22.9k, False: 43.0k]
  ------------------
 1615|  22.9k|        {
 1616|  22.9k|            Coordinates start = m_RemovedStart;
 1617|  22.9k|            editor->InsertTextAt(start, m_Removed.c_str());
 1618|  22.9k|            editor->Colorize(start.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1619|  22.9k|        }
 1620|       |
 1621|  66.0k|        ApplyBeforeState(editor);
 1622|  66.0k|        editor->EnsureCursorVisible();
 1623|  66.0k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord4RedoEPS0_:
 1626|  64.8k|    {
 1627|  64.8k|        PHI_ASSERT(editor != nullptr);
 1628|       |
 1629|  64.8k|        if (!m_Removed.empty())
  ------------------
  |  Branch (1629:13): [True: 22.7k, False: 42.1k]
  ------------------
 1630|  22.7k|        {
 1631|  22.7k|            editor->DeleteRange(m_RemovedStart, m_RemovedEnd);
 1632|  22.7k|            editor->Colorize(m_RemovedStart.m_Line, m_RemovedEnd.m_Line - m_RemovedStart.m_Line);
 1633|  22.7k|        }
 1634|       |
 1635|  64.8k|        if (!m_Added.empty())
  ------------------
  |  Branch (1635:13): [True: 47.4k, False: 17.4k]
  ------------------
 1636|  47.4k|        {
 1637|  47.4k|            Coordinates start = m_AddedStart;
 1638|  47.4k|            editor->InsertTextAt(start, m_Added.c_str());
 1639|  47.4k|            editor->Colorize(start.m_Line, m_AddedEnd.m_Line - m_AddedStart.m_Line);
 1640|  47.4k|        }
 1641|       |
 1642|  64.8k|        ApplyAfterState(editor);
 1643|  64.8k|        editor->EnsureCursorVisible();
 1644|  64.8k|    }
_ZN6dlxemu10CodeEditor10UndoRecord16StoreBeforeStateEPS0_:
 1647|  66.4k|    {
 1648|  66.4k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1649|  66.4k|        const Coordinates selection_start = editor->GetSelectionStart();
 1650|  66.4k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1651|       |
 1652|  66.4k|        m_Before.m_CursorPosition = {cursor_position.m_Line,
 1653|  66.4k|                                     editor->GetCharacterIndex(cursor_position)};
 1654|  66.4k|        m_Before.m_SelectionStart = {selection_start.m_Line,
 1655|  66.4k|                                     editor->GetCharacterIndex(selection_start)};
 1656|  66.4k|        m_Before.m_SelectionEnd = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1657|  66.4k|    }
_ZN6dlxemu10CodeEditor10UndoRecord15StoreAfterStateEPS0_:
 1660|  64.7k|    {
 1661|  64.7k|        const Coordinates cursor_position = editor->GetCursorPosition();
 1662|  64.7k|        const Coordinates selection_start = editor->GetSelectionStart();
 1663|  64.7k|        const Coordinates selection_end   = editor->GetSelectionEnd();
 1664|       |
 1665|  64.7k|        m_After.m_CursorPosition = {cursor_position.m_Line,
 1666|  64.7k|                                    editor->GetCharacterIndex(cursor_position)};
 1667|  64.7k|        m_After.m_SelectionStart = {selection_start.m_Line,
 1668|  64.7k|                                    editor->GetCharacterIndex(selection_start)};
 1669|  64.7k|        m_After.m_SelectionEnd   = {selection_end.m_Line, editor->GetCharacterIndex(selection_end)};
 1670|  64.7k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord16ApplyBeforeStateEPS0_:
 1673|  66.0k|    {
 1674|  66.0k|        Coordinates cursor_position = m_Before.m_CursorPosition;
 1675|  66.0k|        cursor_position.m_Column =
 1676|  66.0k|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1677|  66.0k|        Coordinates selection_start = m_Before.m_SelectionStart;
 1678|  66.0k|        selection_start.m_Column =
 1679|  66.0k|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1680|  66.0k|        Coordinates selection_end = m_Before.m_SelectionEnd;
 1681|  66.0k|        selection_end.m_Column =
 1682|  66.0k|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1683|       |
 1684|  66.0k|        editor->m_State.m_CursorPosition = cursor_position;
 1685|  66.0k|        editor->m_State.m_SelectionStart = selection_start;
 1686|  66.0k|        editor->m_State.m_SelectionEnd   = selection_end;
 1687|  66.0k|    }
_ZNK6dlxemu10CodeEditor10UndoRecord15ApplyAfterStateEPS0_:
 1690|  64.8k|    {
 1691|  64.8k|        Coordinates cursor_position = m_After.m_CursorPosition;
 1692|  64.8k|        cursor_position.m_Column =
 1693|  64.8k|                editor->GetCharacterColumn(cursor_position.m_Line, cursor_position.m_Column);
 1694|  64.8k|        Coordinates selection_start = m_After.m_SelectionStart;
 1695|  64.8k|        selection_start.m_Column =
 1696|  64.8k|                editor->GetCharacterColumn(selection_start.m_Line, selection_start.m_Column);
 1697|  64.8k|        Coordinates selection_end = m_After.m_SelectionEnd;
 1698|  64.8k|        selection_end.m_Column =
 1699|  64.8k|                editor->GetCharacterColumn(selection_end.m_Line, selection_end.m_Column);
 1700|       |
 1701|  64.8k|        editor->m_State.m_CursorPosition = cursor_position;
 1702|  64.8k|        editor->m_State.m_SelectionStart = selection_start;
 1703|  64.8k|        editor->m_State.m_SelectionEnd   = selection_end;
 1704|  64.8k|    }
_ZN6dlxemu10CodeEditor8ColorizeEN3phi7integerIjEENS2_IlEE:
 1709|   230k|    {
 1710|       |        // TODO: This is quite unreadable
 1711|   230k|        const phi::u32 to_line =
 1712|   230k|                count == -1 ? static_cast<phi::uint32_t>(m_Lines.size()) :
  ------------------
  |  Branch (1712:17): [True: 21.7k, False: 208k]
  ------------------
 1713|   230k|                              phi::min(static_cast<phi::uint32_t>(m_Lines.size()),
 1714|   208k|                                       from_line + static_cast<phi::uint32_t>(count.unsafe()));
 1715|       |
 1716|   230k|        m_ColorRangeMin = phi::min(m_ColorRangeMin, from_line);
 1717|   230k|        m_ColorRangeMax = phi::max(m_ColorRangeMax, to_line);
 1718|   230k|        m_ColorRangeMin = phi::max(0u, m_ColorRangeMin);
 1719|   230k|        m_ColorRangeMax = phi::max(m_ColorRangeMin, m_ColorRangeMax);
 1720|   230k|    }
_ZNK6dlxemu10CodeEditor23TextDistanceToLineStartERKNS0_11CoordinatesE:
 1723|  33.2k|    {
 1724|  33.2k|        PHI_ASSERT(from.m_Line < m_Lines.size());
 1725|       |
 1726|  33.2k|        const Line& line     = m_Lines[from.m_Line.unsafe()];
 1727|  33.2k|        float       distance = 0.0f;
 1728|  33.2k|        float       space_size =
 1729|  33.2k|                ImGui::GetFont()
 1730|  33.2k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 1731|  33.2k|                        .x;
 1732|  33.2k|        const phi::u32 col_index = GetCharacterIndex(from);
 1733|  1.32M|        for (phi::usize it{0u}; it < line.size() && it < col_index;)
  ------------------
  |  Branch (1733:33): [True: 1.29M, False: 32.1k]
  |  Branch (1733:33): [True: 1.29M, False: 33.2k]
  |  Branch (1733:53): [True: 1.29M, False: 1.16k]
  ------------------
 1734|  1.29M|        {
 1735|  1.29M|            if (line[it.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (1735:17): [True: 27.6k, False: 1.26M]
  ------------------
 1736|  27.6k|            {
 1737|  27.6k|                distance = (1.0f + std::floor((1.0f + distance) /
 1738|  27.6k|                                              (float(m_TabSize.unsafe()) * space_size))) *
 1739|  27.6k|                           (float(m_TabSize.unsafe()) * space_size);
 1740|  27.6k|                ++it;
 1741|  27.6k|            }
 1742|  1.26M|            else
 1743|  1.26M|            {
 1744|  1.26M|                phi::u8_fast        length = UTF8CharLength(line[it.unsafe()].m_Char);
 1745|  1.26M|                phi::array<char, 7> temp_c_string;
 1746|  1.26M|                phi::usize          index = 0u;
 1747|  2.93M|                for (; index < 6u && length > 0u && it < line.size(); ++index, ++it, --length)
  ------------------
  |  Branch (1747:24): [True: 2.93M, False: 0]
  |  Branch (1747:24): [True: 1.66M, False: 1.26M]
  |  Branch (1747:38): [True: 1.66M, False: 1.26M]
  |  Branch (1747:53): [True: 1.66M, False: 0]
  ------------------
 1748|  1.66M|                {
 1749|  1.66M|                    temp_c_string[index] = static_cast<char>(line[it.unsafe()].m_Char);
 1750|  1.66M|                }
 1751|       |
 1752|  1.26M|                temp_c_string[index] = '\0';
 1753|  1.26M|                distance += ImGui::GetFont()
 1754|  1.26M|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 1755|  1.26M|                                                    temp_c_string.data(), nullptr, nullptr)
 1756|  1.26M|                                    .x;
 1757|  1.26M|            }
 1758|  1.29M|        }
 1759|       |
 1760|  33.2k|        return distance;
 1761|  33.2k|    }
_ZN6dlxemu10CodeEditor19EnsureCursorVisibleEv:
 1764|   212k|    {
 1765|   212k|        m_ScrollToCursor = true;
 1766|   212k|    }
_ZN6dlxemu10CodeEditor14ScrollToCursorEv:
 1769|  4.52k|    {
 1770|  4.52k|        PHI_ASSERT(m_ScrollToCursor);
 1771|       |
 1772|  4.52k|        float scroll_x = ImGui::GetScrollX();
 1773|  4.52k|        float scroll_y = ImGui::GetScrollY();
 1774|       |
 1775|  4.52k|        float height = ImGui::GetWindowHeight();
 1776|  4.52k|        float width  = ImGui::GetWindowWidth();
 1777|       |
 1778|  4.52k|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 1779|  4.52k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 1780|  4.52k|        phi::u32 top = 1u + static_cast<phi::uint32_t>(std::ceil(scroll_y / m_CharAdvance.y));
 1781|  4.52k|        phi::u32 bottom =
 1782|  4.52k|                static_cast<phi::uint32_t>(std::ceil((scroll_y + height) / m_CharAdvance.y));
 1783|       |
 1784|  4.52k|        phi::u32 left = static_cast<phi::uint32_t>(std::ceil(scroll_x / m_CharAdvance.x));
 1785|  4.52k|        phi::u32 right =
 1786|  4.52k|                static_cast<phi::uint32_t>(std::ceil((scroll_x + width) / m_CharAdvance.x));
 1787|       |
 1788|  4.52k|        Coordinates pos = GetActualCursorCoordinates();
 1789|  4.52k|        float       len = TextDistanceToLineStart(pos);
 1790|       |
 1791|       |        // TODO: The 4 here seems like it could very well be a constant
 1792|       |
 1793|  4.52k|        if (pos.m_Line < top)
  ------------------
  |  Branch (1793:13): [True: 3.41k, False: 1.10k]
  ------------------
 1794|  3.41k|        {
 1795|  3.41k|            ImGui::SetScrollY(phi::max(0.0f, static_cast<float>(pos.m_Line.unsafe()) - 1.0f) *
 1796|  3.41k|                              m_CharAdvance.y);
 1797|  3.41k|        }
 1798|  4.52k|        if (pos.m_Line > bottom.unsafe() - 4u)
  ------------------
  |  Branch (1798:13): [True: 73, False: 4.44k]
  ------------------
 1799|     73|        {
 1800|     73|            ImGui::SetScrollY(phi::max(
 1801|     73|                    0.0f,
 1802|     73|                    static_cast<float>((pos.m_Line + 4u).unsafe()) * m_CharAdvance.y - height));
 1803|     73|        }
 1804|  4.52k|        if (len + m_TextStart < static_cast<float>((left + 4u).unsafe()))
  ------------------
  |  Branch (1804:13): [True: 247, False: 4.27k]
  ------------------
 1805|    247|        {
 1806|    247|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart - 4.0f));
 1807|    247|        }
 1808|  4.52k|        if (len + m_TextStart > static_cast<float>(right.unsafe()) - 4.0f)
  ------------------
  |  Branch (1808:13): [True: 4.28k, False: 232]
  ------------------
 1809|  4.28k|        {
 1810|  4.28k|            ImGui::SetScrollX(phi::max(0.0f, len + m_TextStart + 4.0f - width));
 1811|  4.28k|        }
 1812|  4.52k|    }
_ZNK6dlxemu10CodeEditor11GetPageSizeEv:
 1815|     61|    {
 1816|     61|        const float height = ImGui::GetWindowHeight() - 20.0f;
 1817|       |
 1818|     61|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 1819|     61|        const float page_size = std::floor(height / m_CharAdvance.y);
 1820|       |
 1821|     61|        return static_cast<phi::uint32_t>(phi::max(page_size, 5.0f));
 1822|     61|    }
_ZNK6dlxemu10CodeEditor7GetTextERKNS0_11CoordinatesES3_:
 1825|   208k|    {
 1826|   208k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1827|   208k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1828|   208k|        PHI_ASSERT(start <= end);
 1829|       |
 1830|   208k|        std::string result;
 1831|       |
 1832|   208k|        phi::u32   lstart = start.m_Line;
 1833|   208k|        phi::u32   lend   = end.m_Line;
 1834|   208k|        phi::u32   istart = GetCharacterIndex(start);
 1835|   208k|        phi::u32   iend   = phi::min(GetCharacterIndex(end),
 1836|   208k|                                     static_cast<phi::uint32_t>(m_Lines[end.m_Line.unsafe()].size()));
 1837|   208k|        phi::usize size   = 0u;
 1838|       |
 1839|  8.01M|        for (phi::u32 i = lstart; i <= lend; ++i)
  ------------------
  |  Branch (1839:35): [True: 7.80M, False: 208k]
  ------------------
 1840|  7.80M|        {
 1841|  7.80M|            PHI_ASSERT(i < m_Lines.size());
 1842|  7.80M|            size += m_Lines[i.unsafe()].size();
 1843|  7.80M|        }
 1844|       |
 1845|   208k|        result.reserve((size + size / 8u).unsafe());
 1846|       |
 1847|   713M|        while (istart < iend || lstart < lend)
  ------------------
  |  Branch (1847:16): [True: 702M, False: 10.6M]
  |  Branch (1847:16): [True: 712M, False: 208k]
  |  Branch (1847:33): [True: 10.4M, False: 208k]
  ------------------
 1848|   712M|        {
 1849|   712M|            PHI_ASSERT(lstart < m_Lines.size());
 1850|       |
 1851|   712M|            const Line& line = m_Lines[lstart.unsafe()];
 1852|   712M|            if (istart < line.size())
  ------------------
  |  Branch (1852:17): [True: 705M, False: 7.59M]
  ------------------
 1853|   705M|            {
 1854|   705M|                result += static_cast<char>(line[istart.unsafe()].m_Char);
 1855|   705M|                istart++;
 1856|   705M|            }
 1857|  7.59M|            else
 1858|  7.59M|            {
 1859|  7.59M|                istart = 0u;
 1860|  7.59M|                ++lstart;
 1861|       |
 1862|  7.59M|                if (lstart != m_Lines.size())
  ------------------
  |  Branch (1862:21): [True: 7.59M, False: 0]
  ------------------
 1863|  7.59M|                {
 1864|  7.59M|                    result += '\n';
 1865|  7.59M|                }
 1866|  7.59M|            }
 1867|   712M|        }
 1868|       |
 1869|   208k|        return result;
 1870|   208k|    }
_ZNK6dlxemu10CodeEditor26GetActualCursorCoordinatesEv:
 1873|   293k|    {
 1874|   293k|        return SanitizeCoordinates(m_State.m_CursorPosition);
 1875|   293k|    }
_ZNK6dlxemu10CodeEditor19SanitizeCoordinatesERKNS0_11CoordinatesE:
 1878|   553k|    {
 1879|   553k|        PHI_ASSERT(!m_Lines.empty());
 1880|       |
 1881|   553k|        phi::u32 line   = value.m_Line;
 1882|   553k|        phi::u32 column = value.m_Column;
 1883|       |
 1884|   553k|        if (line >= m_Lines.size())
  ------------------
  |  Branch (1884:13): [True: 17.5k, False: 535k]
  ------------------
 1885|  17.5k|        {
 1886|  17.5k|            line   = GetMaxLineNumber();
 1887|  17.5k|            column = GetLineMaxColumn(line);
 1888|       |
 1889|  17.5k|            PHI_ASSERT(line < m_Lines.size());
 1890|  17.5k|            PHI_ASSERT(column <= GetLineMaxColumn(line));
 1891|       |
 1892|  17.5k|            return {line, column};
 1893|  17.5k|        }
 1894|       |
 1895|       |        // Sanitize column
 1896|   535k|        const Line& current_line = m_Lines[line.unsafe()];
 1897|   535k|        phi::u32    new_column   = 0u;
 1898|   723M|        for (phi::u32 char_index{0u}; char_index < current_line.size();)
  ------------------
  |  Branch (1898:39): [True: 723M, False: 422k]
  ------------------
 1899|   723M|        {
 1900|   723M|            if (new_column >= column)
  ------------------
  |  Branch (1900:17): [True: 113k, False: 723M]
  ------------------
 1901|   113k|            {
 1902|   113k|                break;
 1903|   113k|            }
 1904|       |
 1905|   723M|            const char current_char = static_cast<char>(current_line[char_index.unsafe()].m_Char);
 1906|   723M|            if (current_char == '\t')
  ------------------
  |  Branch (1906:17): [True: 3.29M, False: 720M]
  ------------------
 1907|  3.29M|            {
 1908|  3.29M|                new_column += GetTabSizeAt(new_column);
 1909|  3.29M|            }
 1910|   720M|            else
 1911|   720M|            {
 1912|   720M|                ++new_column;
 1913|   720M|            }
 1914|       |
 1915|   723M|            char_index += UTF8CharLength(current_char);
 1916|   723M|        }
 1917|       |
 1918|   535k|        column = new_column;
 1919|       |
 1920|   535k|        PHI_ASSERT(line < m_Lines.size());
 1921|   535k|        PHI_ASSERT(column <= GetLineMaxColumn(line));
 1922|       |
 1923|   535k|        return {line, column};
 1924|   553k|    }
_ZNK6dlxemu10CodeEditor7AdvanceERNS0_11CoordinatesE:
 1927|  3.46k|    {
 1928|  3.46k|        if (coordinates.m_Line >= m_Lines.size())
  ------------------
  |  Branch (1928:13): [True: 0, False: 3.46k]
  ------------------
 1929|      0|        {
 1930|      0|            return;
 1931|      0|        }
 1932|       |
 1933|  3.46k|        const Line& line   = m_Lines[coordinates.m_Line.unsafe()];
 1934|  3.46k|        phi::u32    cindex = GetCharacterIndex(coordinates);
 1935|       |
 1936|  3.46k|        if (cindex + 1u < line.size())
  ------------------
  |  Branch (1936:13): [True: 0, False: 3.46k]
  ------------------
 1937|      0|        {
 1938|      0|            PHI_ASSERT(cindex < line.size());
 1939|      0|            phi::u8_fast delta = UTF8CharLength(line[cindex.unsafe()].m_Char);
 1940|      0|            cindex = phi::min(cindex + delta, static_cast<phi::uint32_t>(line.size() - 1u));
 1941|      0|        }
 1942|  3.46k|        else
 1943|  3.46k|        {
 1944|  3.46k|            ++coordinates.m_Line;
 1945|  3.46k|            cindex = 0u;
 1946|  3.46k|        }
 1947|  3.46k|        coordinates.m_Column = GetCharacterColumn(coordinates.m_Line, cindex);
 1948|  3.46k|    }
_ZN6dlxemu10CodeEditor11DeleteRangeERKNS0_11CoordinatesES3_:
 1951|  74.8k|    {
 1952|  74.8k|        PHI_ASSERT(end > start);
 1953|  74.8k|        PHI_ASSERT(!m_ReadOnly);
 1954|  74.8k|        PHI_ASSERT(start.m_Line < m_Lines.size());
 1955|  74.8k|        PHI_ASSERT(end.m_Line < m_Lines.size());
 1956|       |
 1957|  74.8k|        const phi::u32 start_index = GetCharacterIndex(start);
 1958|  74.8k|        const phi::u32 end_index   = GetCharacterIndex(end);
 1959|       |
 1960|  74.8k|        if (start.m_Line == end.m_Line)
  ------------------
  |  Branch (1960:13): [True: 47.7k, False: 27.0k]
  ------------------
 1961|  47.7k|        {
 1962|  47.7k|            Line&          line       = m_Lines[start.m_Line.unsafe()];
 1963|  47.7k|            const phi::u32 max_column = GetLineMaxColumn(start.m_Line);
 1964|       |
 1965|  47.7k|            if (end.m_Column >= max_column)
  ------------------
  |  Branch (1965:17): [True: 39.1k, False: 8.59k]
  ------------------
 1966|  39.1k|            {
 1967|  39.1k|                line.erase(line.begin() + start_index.unsafe(), line.end());
 1968|       |
 1969|       |                // Fix selection
 1970|  39.1k|                if (m_State.m_SelectionStart.m_Column > start_index)
  ------------------
  |  Branch (1970:21): [True: 9.35k, False: 29.8k]
  ------------------
 1971|  9.35k|                {
 1972|  9.35k|                    m_State.m_SelectionStart.m_Column = start_index;
 1973|  9.35k|                }
 1974|  39.1k|                if (m_State.m_SelectionEnd.m_Column > start_index)
  ------------------
  |  Branch (1974:21): [True: 10.9k, False: 28.2k]
  ------------------
 1975|  10.9k|                {
 1976|  10.9k|                    m_State.m_SelectionEnd.m_Column = start_index;
 1977|  10.9k|                }
 1978|  39.1k|            }
 1979|  8.59k|            else
 1980|  8.59k|            {
 1981|  8.59k|                const phi::u32 start_column = GetCharacterColumn(start.m_Line, start_index);
 1982|  8.59k|                const phi::u32 end_column   = GetCharacterColumn(end.m_Line, end_index);
 1983|       |
 1984|  8.59k|                line.erase(line.begin() + start_index.unsafe(), line.begin() + end_index.unsafe());
 1985|       |
 1986|       |                // Fix selection
 1987|  8.59k|                if (m_State.m_SelectionStart.m_Column > start_column)
  ------------------
  |  Branch (1987:21): [True: 3.14k, False: 5.44k]
  ------------------
 1988|  3.14k|                {
 1989|  3.14k|                    if (m_State.m_SelectionStart.m_Column <= end_column)
  ------------------
  |  Branch (1989:25): [True: 2.82k, False: 320]
  ------------------
 1990|  2.82k|                    {
 1991|  2.82k|                        m_State.m_SelectionStart.m_Column = start_column;
 1992|  2.82k|                    }
 1993|    320|                    else
 1994|    320|                    {
 1995|    320|                        m_State.m_SelectionStart.m_Column -= (end_column - start_column);
 1996|    320|                    }
 1997|  3.14k|                }
 1998|  8.59k|                if (m_State.m_SelectionEnd.m_Column > start_column)
  ------------------
  |  Branch (1998:21): [True: 3.37k, False: 5.21k]
  ------------------
 1999|  3.37k|                {
 2000|  3.37k|                    if (m_State.m_SelectionEnd.m_Column <= end_column)
  ------------------
  |  Branch (2000:25): [True: 3.04k, False: 333]
  ------------------
 2001|  3.04k|                    {
 2002|  3.04k|                        m_State.m_SelectionEnd.m_Column = start_column;
 2003|  3.04k|                    }
 2004|    333|                    else
 2005|    333|                    {
 2006|    333|                        m_State.m_SelectionEnd.m_Column -= (end_column - start_column);
 2007|    333|                    }
 2008|  3.37k|                }
 2009|  8.59k|            }
 2010|  47.7k|        }
 2011|  27.0k|        else
 2012|  27.0k|        {
 2013|  27.0k|            Line& first_line = m_Lines[start.m_Line.unsafe()];
 2014|  27.0k|            Line& last_line  = m_Lines[end.m_Line.unsafe()];
 2015|       |
 2016|  27.0k|            first_line.erase(first_line.begin() + start_index.unsafe(), first_line.end());
 2017|  27.0k|            last_line.erase(last_line.begin(), last_line.begin() + end_index.unsafe());
 2018|       |
 2019|  27.0k|            if (start.m_Line < end.m_Line)
  ------------------
  |  Branch (2019:17): [True: 27.0k, False: 0]
  ------------------
 2020|  27.0k|            {
 2021|  27.0k|                first_line.insert(first_line.end(), last_line.begin(), last_line.end());
 2022|  27.0k|                RemoveLine(start.m_Line + 1u, end.m_Line + 1u);
 2023|  27.0k|            }
 2024|  27.0k|        }
 2025|       |
 2026|  74.8k|        m_TextChanged = true;
 2027|  74.8k|    }
_ZN6dlxemu10CodeEditor12InsertTextAtERNS0_11CoordinatesEPKc:
 2030|  88.9k|    {
 2031|  88.9k|        PHI_ASSERT(!m_ReadOnly);
 2032|  88.9k|        PHI_ASSERT(where.m_Line < m_Lines.size());
 2033|       |
 2034|  88.9k|        phi::u32 cindex      = GetCharacterIndex(where);
 2035|  88.9k|        phi::u32 total_lines = 0u;
 2036|  84.2M|        while (*value != '\0')
  ------------------
  |  Branch (2036:16): [True: 84.1M, False: 88.9k]
  ------------------
 2037|  84.1M|        {
 2038|  84.1M|            PHI_ASSERT(!m_Lines.empty());
 2039|       |
 2040|  84.1M|            if (*value == '\n')
  ------------------
  |  Branch (2040:17): [True: 2.69M, False: 81.4M]
  ------------------
 2041|  2.69M|            {
 2042|  2.69M|                if (cindex < m_Lines[where.m_Line.unsafe()].size())
  ------------------
  |  Branch (2042:21): [True: 12.2k, False: 2.68M]
  ------------------
 2043|  12.2k|                {
 2044|  12.2k|                    Line& new_line = InsertLine(where.m_Line + 1u);
 2045|  12.2k|                    Line& line     = m_Lines[where.m_Line.unsafe()];
 2046|  12.2k|                    new_line.insert(new_line.begin(), line.begin() + cindex.unsafe(), line.end());
 2047|  12.2k|                    line.erase(line.begin() + cindex.unsafe(), line.end());
 2048|  12.2k|                }
 2049|  2.68M|                else
 2050|  2.68M|                {
 2051|  2.68M|                    InsertLine(where.m_Line + 1u);
 2052|  2.68M|                }
 2053|       |
 2054|  2.69M|                ++where.m_Line;
 2055|  2.69M|                where.m_Column = 0u;
 2056|  2.69M|                cindex         = 0u;
 2057|  2.69M|                ++total_lines;
 2058|  2.69M|                ++value;
 2059|  2.69M|            }
 2060|  81.4M|            else if (*value == '\t')
  ------------------
  |  Branch (2060:22): [True: 708k, False: 80.7M]
  ------------------
 2061|   708k|            {
 2062|   708k|                Line& line = m_Lines[where.m_Line.unsafe()];
 2063|       |
 2064|   708k|                line.insert(line.begin() + cindex.unsafe(),
 2065|   708k|                            Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2066|   708k|                cindex += 1u;
 2067|       |
 2068|   708k|                where.m_Column += GetTabSizeAt(where.m_Column);
 2069|   708k|            }
 2070|  80.7M|            else
 2071|  80.7M|            {
 2072|  80.7M|                Line& line = m_Lines[where.m_Line.unsafe()];
 2073|       |
 2074|   307M|                for (phi::u8_fast length = UTF8CharLength(*value); length > 0u && *value != '\0';
  ------------------
  |  Branch (2074:68): [True: 226M, False: 80.7M]
  |  Branch (2074:68): [True: 226M, False: 80.7M]
  |  Branch (2074:83): [True: 226M, False: 0]
  ------------------
 2075|   226M|                     ++cindex, --length)
 2076|   226M|                {
 2077|   226M|                    line.insert(line.begin() + cindex.unsafe(),
 2078|   226M|                                Glyph(static_cast<Char>(*value++), PaletteIndex::Default));
 2079|   226M|                }
 2080|       |
 2081|  80.7M|                ++where.m_Column;
 2082|  80.7M|            }
 2083|       |
 2084|  84.1M|            m_TextChanged = true;
 2085|  84.1M|        }
 2086|       |
 2087|  88.9k|        return total_lines;
 2088|  88.9k|    }
_ZN6dlxemu10CodeEditor7AddUndoERNS0_10UndoRecordE:
 2091|  64.7k|    {
 2092|  64.7k|        PHI_ASSERT(!m_ReadOnly);
 2093|       |
 2094|  64.7k|#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2095|  64.7k|        VerifyInternalState();
 2096|       |        // Reject empty undos
 2097|  64.7k|        PHI_ASSERT(!(value.m_Added.empty() && value.m_Removed.empty()));
 2098|       |        // Start and end are valid
 2099|  64.7k|        PHI_ASSERT(value.m_AddedStart <= value.m_AddedEnd);
 2100|  64.7k|        PHI_ASSERT(value.m_RemovedStart <= value.m_RemovedEnd);
 2101|  64.7k|#endif
 2102|       |
 2103|  64.7k|        m_UndoBuffer.resize((m_UndoIndex + 1u).unsafe());
 2104|  64.7k|        m_UndoBuffer.back() = value;
 2105|  64.7k|        ++m_UndoIndex;
 2106|       |
 2107|  64.7k|#if defined(DLXEMU_VERIFY_UNDO_REDO)
 2108|  64.7k|        VerifyInternalState();
 2109|       |
 2110|  64.7k|        PHI_ASSERT(CanUndo());
 2111|       |
 2112|  64.7k|        const std::string text_before          = GetText();
 2113|  64.7k|        EditorState       state_before         = m_State;
 2114|  64.7k|        state_before.m_CursorPosition.m_Column = GetCharacterIndex(state_before.m_CursorPosition);
 2115|  64.7k|        state_before.m_SelectionStart.m_Column = GetCharacterIndex(state_before.m_SelectionStart);
 2116|  64.7k|        state_before.m_SelectionEnd.m_Column   = GetCharacterIndex(state_before.m_SelectionEnd);
 2117|       |
 2118|       |        // Test the undo
 2119|  64.7k|        Undo();
 2120|  64.7k|        VerifyInternalState();
 2121|       |
 2122|  64.7k|        const std::string text_after_undo  = GetText();
 2123|  64.7k|        EditorState       state_after_undo = m_State;
 2124|  64.7k|        state_after_undo.m_CursorPosition.m_Column =
 2125|  64.7k|                GetCharacterIndex(state_after_undo.m_CursorPosition);
 2126|  64.7k|        state_after_undo.m_SelectionStart.m_Column =
 2127|  64.7k|                GetCharacterIndex(state_after_undo.m_SelectionStart);
 2128|  64.7k|        state_after_undo.m_SelectionEnd.m_Column =
 2129|  64.7k|                GetCharacterIndex(state_after_undo.m_SelectionEnd);
 2130|       |
 2131|  64.7k|        PHI_ASSERT(CanRedo());
 2132|       |
 2133|       |        // Test the redo
 2134|  64.7k|        Redo();
 2135|  64.7k|        VerifyInternalState();
 2136|       |
 2137|  64.7k|        const std::string text_after          = GetText();
 2138|  64.7k|        EditorState       state_after         = m_State;
 2139|  64.7k|        state_after.m_CursorPosition.m_Column = GetCharacterIndex(state_after.m_CursorPosition);
 2140|  64.7k|        state_after.m_SelectionStart.m_Column = GetCharacterIndex(state_after.m_SelectionStart);
 2141|  64.7k|        state_after.m_SelectionEnd.m_Column   = GetCharacterIndex(state_after.m_SelectionEnd);
 2142|       |
 2143|  64.7k|        PHI_ASSERT(text_before == text_after);
 2144|  64.7k|        PHI_ASSERT(state_before == state_after);
 2145|  64.7k|#endif
 2146|  64.7k|    }
_ZNK6dlxemu10CodeEditor22ScreenPosToCoordinatesERK6ImVec2:
 2150|  13.2k|    {
 2151|  13.2k|        const ImVec2 origin = ImGui::GetCursorScreenPos();
 2152|  13.2k|        const ImVec2 local(position.x - origin.x, position.y - origin.y);
 2153|       |
 2154|  13.2k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 2155|  13.2k|        const phi::u32 line_no =
 2156|  13.2k|                phi::max(0u, static_cast<phi::int32_t>(std::floor(local.y / m_CharAdvance.y)));
 2157|       |
 2158|  13.2k|        phi::u32 column_coord = 0u;
 2159|       |
 2160|  13.2k|        if (line_no >= 0u && line_no < m_Lines.size())
  ------------------
  |  Branch (2160:13): [True: 13.2k, False: 0]
  |  Branch (2160:13): [True: 133, False: 13.1k]
  |  Branch (2160:30): [True: 133, False: 13.1k]
  ------------------
 2161|    133|        {
 2162|    133|            const Line& line = m_Lines[line_no.unsafe()];
 2163|       |
 2164|    133|            phi::u32 column_index = 0u;
 2165|    133|            float    column_x     = 0.0f;
 2166|       |
 2167|    180|            while (column_index < line.size())
  ------------------
  |  Branch (2167:20): [True: 70, False: 110]
  ------------------
 2168|     70|            {
 2169|     70|                float column_width = 0.0f;
 2170|       |
 2171|     70|                if (line[column_index.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2171:21): [True: 2, False: 68]
  ------------------
 2172|      2|                {
 2173|      2|                    float space_size =
 2174|      2|                            ImGui::GetFont()
 2175|      2|                                    ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ")
 2176|      2|                                    .x;
 2177|      2|                    float old_x = column_x;
 2178|      2|                    float new_column_x =
 2179|      2|                            (1.0f + std::floor((1.0f + column_x) /
 2180|      2|                                               (float(m_TabSize.unsafe()) * space_size))) *
 2181|      2|                            (float(m_TabSize.unsafe()) * space_size);
 2182|      2|                    column_width = new_column_x - old_x;
 2183|       |
 2184|      2|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2184:25): [True: 1, False: 1]
  ------------------
 2185|      1|                    {
 2186|      1|                        break;
 2187|      1|                    }
 2188|       |
 2189|      1|                    column_x = new_column_x;
 2190|      1|                    column_coord =
 2191|      1|                            (column_coord.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2192|      1|                            m_TabSize.unsafe();
 2193|      1|                    column_index += 1u;
 2194|      1|                }
 2195|     68|                else
 2196|     68|                {
 2197|     68|                    phi::array<char, 7u> buffer;
 2198|     68|                    phi::usize           index = 0u;
 2199|       |
 2200|     68|                    for (phi::u8_fast length = UTF8CharLength(line[column_index.unsafe()].m_Char);
 2201|    179|                         index < 6u && length > 0u; ++index, ++column_index, --length)
  ------------------
  |  Branch (2201:26): [True: 179, False: 0]
  |  Branch (2201:26): [True: 111, False: 68]
  |  Branch (2201:40): [True: 111, False: 68]
  ------------------
 2202|    111|                    {
 2203|    111|                        buffer[index] = static_cast<char>(line[column_index.unsafe()].m_Char);
 2204|    111|                    }
 2205|       |
 2206|     68|                    buffer[index] = '\0';
 2207|     68|                    column_width  = ImGui::GetFont()
 2208|     68|                                           ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 2209|     68|                                                           buffer.data())
 2210|     68|                                           .x;
 2211|     68|                    if (m_TextStart + column_x + column_width * 0.5f > local.x)
  ------------------
  |  Branch (2211:25): [True: 22, False: 46]
  ------------------
 2212|     22|                    {
 2213|     22|                        break;
 2214|     22|                    }
 2215|     46|                    column_x += column_width;
 2216|     46|                    column_coord++;
 2217|     46|                }
 2218|     70|            }
 2219|    133|        }
 2220|       |
 2221|  13.2k|        return SanitizeCoordinates(Coordinates(line_no, column_coord));
 2222|  13.2k|    }
_ZNK6dlxemu10CodeEditor13FindWordStartERKNS0_11CoordinatesE:
 2225|   627k|    {
 2226|   627k|        if (from.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2226:13): [True: 0, False: 627k]
  ------------------
 2227|      0|        {
 2228|      0|            return from;
 2229|      0|        }
 2230|       |
 2231|   627k|        const Line& line   = m_Lines[from.m_Line.unsafe()];
 2232|   627k|        phi::u32    cindex = GetCharacterIndex(from);
 2233|       |
 2234|   627k|        if (cindex >= line.size())
  ------------------
  |  Branch (2234:13): [True: 548k, False: 78.7k]
  ------------------
 2235|   548k|        {
 2236|   548k|            return from;
 2237|   548k|        }
 2238|       |
 2239|   105k|        while (cindex > 0u && phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2239:16): [True: 70.8k, False: 34.3k]
  |  Branch (2239:16): [True: 26.4k, False: 78.7k]
  |  Branch (2239:31): [True: 26.4k, False: 44.3k]
  ------------------
 2240|  26.4k|        {
 2241|  26.4k|            --cindex;
 2242|  26.4k|        }
 2243|       |
 2244|  78.7k|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2245|  7.69M|        while (cindex > 0u)
  ------------------
  |  Branch (2245:16): [True: 7.63M, False: 62.9k]
  ------------------
 2246|  7.63M|        {
 2247|  7.63M|            Glyph glyph = line[cindex.unsafe()];
 2248|  7.63M|            if (!IsUTFSequence(glyph.m_Char))
  ------------------
  |  Branch (2248:17): [True: 3.18M, False: 4.44M]
  ------------------
 2249|  3.18M|            {
 2250|  3.18M|                if (glyph.m_Char <= 32 && phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2250:21): [True: 14.1k, False: 3.17M]
  |  Branch (2250:21): [True: 12.9k, False: 3.17M]
  |  Branch (2250:43): [True: 12.9k, False: 1.22k]
  ------------------
 2251|  12.9k|                {
 2252|  12.9k|                    cindex += 1u;
 2253|  12.9k|                    break;
 2254|  12.9k|                }
 2255|       |
 2256|  3.17M|                if (cstart != line[phi::size_t(cindex.unsafe() - 1u)].m_ColorIndex)
  ------------------
  |  Branch (2256:21): [True: 2.87k, False: 3.17M]
  ------------------
 2257|  2.87k|                {
 2258|  2.87k|                    break;
 2259|  2.87k|                }
 2260|  3.17M|            }
 2261|       |
 2262|  7.61M|            cindex -= 1u;
 2263|  7.61M|        }
 2264|       |
 2265|  78.7k|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2266|   627k|    }
_ZNK6dlxemu10CodeEditor11FindWordEndERKNS0_11CoordinatesE:
 2269|  14.2k|    {
 2270|  14.2k|        Coordinates at = from;
 2271|  14.2k|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2271:13): [True: 0, False: 14.2k]
  ------------------
 2272|      0|        {
 2273|      0|            return at;
 2274|      0|        }
 2275|       |
 2276|  14.2k|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2277|  14.2k|        phi::u32    cindex = GetCharacterIndex(at);
 2278|       |
 2279|  14.2k|        if (cindex >= line.size())
  ------------------
  |  Branch (2279:13): [True: 13.6k, False: 538]
  ------------------
 2280|  13.6k|        {
 2281|  13.6k|            return at;
 2282|  13.6k|        }
 2283|       |
 2284|    538|        const phi::boolean prevspace =
 2285|    538|                phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char));
 2286|    538|        const PaletteIndex cstart = line[cindex.unsafe()].m_ColorIndex;
 2287|  2.36k|        while (cindex < line.size())
  ------------------
  |  Branch (2287:16): [True: 2.17k, False: 188]
  ------------------
 2288|  2.17k|        {
 2289|  2.17k|            const Glyph glyph = line[cindex.unsafe()];
 2290|       |
 2291|  2.17k|            if (cstart != line[cindex.unsafe()].m_ColorIndex)
  ------------------
  |  Branch (2291:17): [True: 5, False: 2.16k]
  ------------------
 2292|      5|            {
 2293|      5|                break;
 2294|      5|            }
 2295|       |
 2296|  2.16k|            if (prevspace != phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2296:17): [True: 345, False: 1.82k]
  ------------------
 2297|    345|            {
 2298|    345|                if (phi::is_space(static_cast<char>(glyph.m_Char)))
  ------------------
  |  Branch (2298:21): [True: 245, False: 100]
  ------------------
 2299|    245|                {
 2300|    836|                    while (cindex < line.size() &&
  ------------------
  |  Branch (2300:28): [True: 703, False: 133]
  |  Branch (2300:28): [True: 591, False: 245]
  ------------------
 2301|    836|                           phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)))
  ------------------
  |  Branch (2301:28): [True: 591, False: 112]
  ------------------
 2302|    591|                    {
 2303|    591|                        cindex += 1u;
 2304|    591|                    }
 2305|    245|                }
 2306|    345|                break;
 2307|    345|            }
 2308|       |
 2309|  1.82k|            cindex += UTF8CharLength(glyph.m_Char);
 2310|  1.82k|        }
 2311|       |
 2312|    538|        return {from.m_Line, GetCharacterColumn(from.m_Line, cindex)};
 2313|  14.2k|    }
_ZNK6dlxemu10CodeEditor12FindNextWordERKNS0_11CoordinatesE:
 2316|  3.29k|    {
 2317|  3.29k|        Coordinates at = from;
 2318|  3.29k|        if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2318:13): [True: 0, False: 3.29k]
  ------------------
 2319|      0|        {
 2320|      0|            return at;
 2321|      0|        }
 2322|       |
 2323|       |        // skip to the next non-word character
 2324|  3.29k|        phi::u32     cindex  = GetCharacterIndex(from);
 2325|  3.29k|        phi::boolean is_word = false;
 2326|  3.29k|        phi::boolean skip    = false;
 2327|  3.29k|        if (cindex < m_Lines[at.m_Line.unsafe()].size())
  ------------------
  |  Branch (2327:13): [True: 3.08k, False: 209]
  ------------------
 2328|  3.08k|        {
 2329|  3.08k|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2330|  3.08k|            is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2331|  3.08k|            skip    = is_word;
 2332|  3.08k|        }
 2333|       |
 2334|   113k|        while (!is_word || skip)
  ------------------
  |  Branch (2334:16): [True: 100k, False: 13.8k]
  |  Branch (2334:16): [True: 113k, False: 0]
  |  Branch (2334:28): [True: 13.8k, False: 0]
  ------------------
 2335|   113k|        {
 2336|   113k|            if (at.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2336:17): [True: 1.18k, False: 112k]
  ------------------
 2337|  1.18k|            {
 2338|  1.18k|                const phi::u32 line_number = GetMaxLineNumber();
 2339|       |
 2340|  1.18k|                return {line_number, GetLineMaxColumn(line_number)};
 2341|  1.18k|            }
 2342|       |
 2343|   112k|            const Line& line = m_Lines[at.m_Line.unsafe()];
 2344|   112k|            if (cindex < line.size())
  ------------------
  |  Branch (2344:17): [True: 111k, False: 1.21k]
  ------------------
 2345|   111k|            {
 2346|   111k|                is_word = phi::is_alpha_numeric(static_cast<char>(line[cindex.unsafe()].m_Char));
 2347|       |
 2348|   111k|                if (is_word && !skip)
  ------------------
  |  Branch (2348:21): [True: 14.7k, False: 96.7k]
  |  Branch (2348:21): [True: 2.10k, False: 109k]
  |  Branch (2348:32): [True: 2.10k, False: 12.6k]
  ------------------
 2349|  2.10k|                {
 2350|  2.10k|                    return {at.m_Line, GetCharacterColumn(at.m_Line, cindex)};
 2351|  2.10k|                }
 2352|       |
 2353|   109k|                if (!is_word)
  ------------------
  |  Branch (2353:21): [True: 96.7k, False: 12.6k]
  ------------------
 2354|  96.7k|                {
 2355|  96.7k|                    skip = false;
 2356|  96.7k|                }
 2357|       |
 2358|   109k|                cindex++;
 2359|   109k|            }
 2360|  1.21k|            else
 2361|  1.21k|            {
 2362|  1.21k|                cindex = 0u;
 2363|  1.21k|                at.m_Line += 1u;
 2364|  1.21k|                skip    = false;
 2365|  1.21k|                is_word = false;
 2366|  1.21k|            }
 2367|   112k|        }
 2368|       |
 2369|      0|        return at;
 2370|  3.29k|    }
_ZNK6dlxemu10CodeEditor9GetWordAtERKNS0_11CoordinatesE:
 2379|  13.2k|    {
 2380|  13.2k|        PHI_ASSERT(coords.m_Line < m_Lines.size());
 2381|       |
 2382|  13.2k|        const Coordinates start = FindWordStart(coords);
 2383|  13.2k|        const Coordinates end   = FindWordEnd(coords);
 2384|       |
 2385|  13.2k|        const phi::u32 istart = GetCharacterIndex(start);
 2386|  13.2k|        const phi::u32 iend   = GetCharacterIndex(end);
 2387|       |
 2388|  13.2k|        std::string result;
 2389|       |
 2390|  13.4k|        for (phi::u32 iterator = istart; iterator < iend; ++iterator)
  ------------------
  |  Branch (2390:42): [True: 176, False: 13.2k]
  ------------------
 2391|    176|        {
 2392|    176|            const Line& line = m_Lines[coords.m_Line.unsafe()];
 2393|       |
 2394|    176|            PHI_ASSERT(iterator < line.size());
 2395|    176|            result.push_back(static_cast<char>(line[iterator.unsafe()].m_Char));
 2396|    176|        }
 2397|       |
 2398|  13.2k|        return result;
 2399|  13.2k|    }
_ZNK6dlxemu10CodeEditor17GetCharacterIndexERKNS0_11CoordinatesE:
 2402|  3.00M|    {
 2403|  3.00M|        PHI_ASSERT(coordinates.m_Line < m_Lines.size());
 2404|       |
 2405|  3.00M|        const Line& line  = m_Lines[coordinates.m_Line.unsafe()];
 2406|  3.00M|        phi::u32    index = 0u;
 2407|  1.91G|        for (phi::u32 column{0u}; index < line.size() && column < coordinates.m_Column;)
  ------------------
  |  Branch (2407:35): [True: 1.91G, False: 2.33M]
  |  Branch (2407:35): [True: 1.91G, False: 3.00M]
  |  Branch (2407:58): [True: 1.91G, False: 672k]
  ------------------
 2408|  1.91G|        {
 2409|  1.91G|            PHI_ASSERT(index < line.size());
 2410|  1.91G|            const Char character = line[index.unsafe()].m_Char;
 2411|       |
 2412|  1.91G|            if (character == '\t')
  ------------------
  |  Branch (2412:17): [True: 11.3M, False: 1.90G]
  ------------------
 2413|  11.3M|            {
 2414|  11.3M|                column = (column / m_TabSize) * m_TabSize + m_TabSize;
 2415|  11.3M|            }
 2416|  1.90G|            else
 2417|  1.90G|            {
 2418|  1.90G|                ++column;
 2419|  1.90G|            }
 2420|       |
 2421|  1.91G|            index += UTF8CharLength(character);
 2422|  1.91G|        }
 2423|       |
 2424|  3.00M|        return index;
 2425|  3.00M|    }
_ZNK6dlxemu10CodeEditor18GetCharacterColumnEN3phi7integerIjEES3_:
 2428|  1.17M|    {
 2429|  1.17M|        PHI_ASSERT(line_number < m_Lines.size());
 2430|       |
 2431|  1.17M|        const Line& line   = m_Lines[line_number.unsafe()];
 2432|  1.17M|        phi::u32    column = 0u;
 2433|  1.17M|        phi::u32    i      = 0u;
 2434|       |
 2435|   560M|        while (i < index && i < line.size())
  ------------------
  |  Branch (2435:16): [True: 559M, False: 1.17M]
  |  Branch (2435:16): [True: 559M, False: 1.17M]
  |  Branch (2435:29): [True: 559M, False: 18]
  ------------------
 2436|   559M|        {
 2437|   559M|            char character = static_cast<char>(line[static_cast<phi::size_t>(i.unsafe())].m_Char);
 2438|   559M|            i += UTF8CharLength(character);
 2439|   559M|            if (character == '\t')
  ------------------
  |  Branch (2439:17): [True: 4.64M, False: 554M]
  ------------------
 2440|  4.64M|            {
 2441|  4.64M|                column = (column.unsafe() / m_TabSize.unsafe()) * m_TabSize.unsafe() +
 2442|  4.64M|                         m_TabSize.unsafe();
 2443|  4.64M|            }
 2444|   554M|            else
 2445|   554M|            {
 2446|   554M|                column++;
 2447|   554M|            }
 2448|   559M|        }
 2449|       |
 2450|  1.17M|        return column;
 2451|  1.17M|    }
_ZNK6dlxemu10CodeEditor16GetLineMaxColumnEN3phi7integerIjEE:
 2472|   878k|    {
 2473|   878k|        if (line_number >= m_Lines.size())
  ------------------
  |  Branch (2473:13): [True: 0, False: 878k]
  ------------------
 2474|      0|        {
 2475|      0|            return 0u;
 2476|      0|        }
 2477|       |
 2478|   878k|        const Line& line = m_Lines[line_number.unsafe()];
 2479|   878k|        phi::u32    col  = 0u;
 2480|       |
 2481|  1.13G|        for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (2481:32): [True: 1.13G, False: 878k]
  ------------------
 2482|  1.13G|        {
 2483|  1.13G|            char character = static_cast<char>(line[i.unsafe()].m_Char);
 2484|  1.13G|            if (character == '\t')
  ------------------
  |  Branch (2484:17): [True: 7.94M, False: 1.12G]
  ------------------
 2485|  7.94M|            {
 2486|  7.94M|                col = (col / m_TabSize) * m_TabSize + m_TabSize;
 2487|  7.94M|            }
 2488|  1.12G|            else
 2489|  1.12G|            {
 2490|  1.12G|                col++;
 2491|  1.12G|            }
 2492|       |
 2493|  1.13G|            i += UTF8CharLength(character);
 2494|  1.13G|        }
 2495|       |
 2496|   878k|        return col;
 2497|   878k|    }
_ZNK6dlxemu10CodeEditor16GetMaxLineNumberEv:
 2500|   239k|    {
 2501|   239k|        PHI_ASSERT(!m_Lines.empty());
 2502|       |
 2503|   239k|        return static_cast<phi::uint32_t>(m_Lines.size() - 1u);
 2504|   239k|    }
_ZNK6dlxemu10CodeEditor16IsOnWordBoundaryERKNS0_11CoordinatesE:
 2507|    215|    {
 2508|    215|        if (at.m_Line >= m_Lines.size() || at.m_Column == 0u)
  ------------------
  |  Branch (2508:13): [True: 0, False: 215]
  |  Branch (2508:13): [True: 115, False: 100]
  |  Branch (2508:44): [True: 115, False: 100]
  ------------------
 2509|    115|        {
 2510|    115|            return true;
 2511|    115|        }
 2512|       |
 2513|    100|        PHI_ASSERT(at.m_Line < m_Lines.size());
 2514|    100|        const Line& line   = m_Lines[at.m_Line.unsafe()];
 2515|    100|        phi::u32    cindex = GetCharacterIndex(at);
 2516|    100|        if (cindex >= line.size())
  ------------------
  |  Branch (2516:13): [True: 100, False: 0]
  ------------------
 2517|    100|        {
 2518|    100|            return true;
 2519|    100|        }
 2520|       |
 2521|      0|        if (m_ColorizerEnabled)
  ------------------
  |  Branch (2521:13): [True: 0, False: 0]
  ------------------
 2522|      0|        {
 2523|      0|            return line[cindex.unsafe()].m_ColorIndex != line[cindex.unsafe() - 1u].m_ColorIndex;
 2524|      0|        }
 2525|       |
 2526|      0|        PHI_ASSERT(cindex < line.size());
 2527|      0|        return phi::is_space(static_cast<char>(line[cindex.unsafe()].m_Char)) !=
 2528|      0|               phi::is_space(static_cast<char>(line[(cindex - 1u).unsafe()].m_Char));
 2529|      0|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEES3_:
 2532|  27.0k|    {
 2533|  27.0k|        PHI_ASSERT(!m_ReadOnly);
 2534|  27.0k|        PHI_ASSERT(end >= start);
 2535|  27.0k|        PHI_ASSERT(m_Lines.size() > (end - start));
 2536|       |
 2537|       |        // Remove error markers
 2538|  27.0k|        ErrorMarkers etmp;
 2539|  27.0k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2539:33): [True: 6.99k, False: 27.0k]
  ------------------
 2540|  6.99k|        {
 2541|  6.99k|            if (marker.first >= start && marker.first <= end)
  ------------------
  |  Branch (2541:17): [True: 2.81k, False: 4.17k]
  |  Branch (2541:17): [True: 648, False: 6.34k]
  |  Branch (2541:42): [True: 648, False: 2.17k]
  ------------------
 2542|    648|            {
 2543|    648|                continue;
 2544|    648|            }
 2545|       |
 2546|  6.34k|            ErrorMarkers::value_type error_marker(
 2547|  6.34k|                    marker.first >= start ? phi::max(marker.first - (end - start + 1u), 1u) :
  ------------------
  |  Branch (2547:21): [True: 2.17k, False: 4.17k]
  ------------------
 2548|  6.34k|                                            marker.first,
 2549|  6.34k|                    marker.second);
 2550|       |
 2551|  6.34k|            etmp.insert(error_marker);
 2552|  6.34k|        }
 2553|  27.0k|        m_ErrorMarkers = phi::move(etmp);
 2554|       |
 2555|       |        // Remove breakpoints
 2556|  27.0k|        Breakpoints btmp;
 2557|  27.0k|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2557:37): [True: 8.85k, False: 27.0k]
  ------------------
 2558|  8.85k|        {
 2559|  8.85k|            if (line_number >= start && line_number <= end)
  ------------------
  |  Branch (2559:17): [True: 885, False: 7.96k]
  |  Branch (2559:17): [True: 228, False: 8.62k]
  |  Branch (2559:41): [True: 228, False: 657]
  ------------------
 2560|    228|            {
 2561|    228|                continue;
 2562|    228|            }
 2563|  8.62k|            btmp.insert(line_number >= start ?
  ------------------
  |  Branch (2563:25): [True: 657, False: 7.96k]
  ------------------
 2564|    657|                                phi::max(line_number - (end - start + 1u).unsafe(), 1u) :
 2565|  8.62k|                                line_number);
 2566|  8.62k|        }
 2567|  27.0k|        m_Breakpoints = phi::move(btmp);
 2568|       |
 2569|  27.0k|        m_Lines.erase(m_Lines.begin() + start.unsafe(), m_Lines.begin() + end.unsafe());
 2570|  27.0k|        PHI_ASSERT(!m_Lines.empty());
 2571|       |
 2572|       |        // Fix selection state
 2573|  27.0k|        if (m_State.m_SelectionStart.m_Line >= start)
  ------------------
  |  Branch (2573:13): [True: 7.63k, False: 19.4k]
  ------------------
 2574|  7.63k|        {
 2575|  7.63k|            if (m_State.m_SelectionStart.m_Line < end - start)
  ------------------
  |  Branch (2575:17): [True: 21, False: 7.61k]
  ------------------
 2576|     21|            {
 2577|     21|                m_State.m_SelectionStart.m_Line = 0u;
 2578|     21|            }
 2579|  7.61k|            else
 2580|  7.61k|            {
 2581|  7.61k|                m_State.m_SelectionStart.m_Line -= end - start;
 2582|  7.61k|            }
 2583|  7.63k|        }
 2584|  27.0k|        if (m_State.m_SelectionEnd.m_Line >= start)
  ------------------
  |  Branch (2584:13): [True: 14.1k, False: 12.8k]
  ------------------
 2585|  14.1k|        {
 2586|  14.1k|            if (m_State.m_SelectionEnd.m_Line < end - start)
  ------------------
  |  Branch (2586:17): [True: 21, False: 14.1k]
  ------------------
 2587|     21|            {
 2588|     21|                m_State.m_SelectionEnd.m_Line = 0u;
 2589|     21|            }
 2590|  14.1k|            else
 2591|  14.1k|            {
 2592|  14.1k|                m_State.m_SelectionEnd.m_Line -= end - start;
 2593|  14.1k|            }
 2594|  14.1k|        }
 2595|  27.0k|        if (m_State.m_SelectionStart > m_State.m_SelectionEnd)
  ------------------
  |  Branch (2595:13): [True: 38, False: 27.0k]
  ------------------
 2596|     38|        {
 2597|     38|            phi::swap(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 2598|     38|        }
 2599|       |
 2600|  27.0k|        m_TextChanged = true;
 2601|  27.0k|    }
_ZN6dlxemu10CodeEditor10RemoveLineEN3phi7integerIjEE:
 2604|  3.46k|    {
 2605|  3.46k|        PHI_ASSERT(!m_ReadOnly);
 2606|  3.46k|        PHI_ASSERT(m_Lines.size() > 1u);
 2607|       |
 2608|       |        // Clear error markers on that line
 2609|  3.46k|        ErrorMarkers etmp;
 2610|  3.46k|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2610:33): [True: 2.87k, False: 3.46k]
  ------------------
 2611|  2.87k|        {
 2612|  2.87k|            ErrorMarkers::value_type error_marker(
 2613|  2.87k|                    marker.first > index ? phi::max(marker.first - 1u, 1u) : marker.first,
  ------------------
  |  Branch (2613:21): [True: 701, False: 2.17k]
  ------------------
 2614|  2.87k|                    marker.second);
 2615|  2.87k|            if ((error_marker.first - 1u) == index)
  ------------------
  |  Branch (2615:17): [True: 44, False: 2.83k]
  ------------------
 2616|     44|            {
 2617|     44|                continue;
 2618|     44|            }
 2619|  2.83k|            etmp.insert(error_marker);
 2620|  2.83k|        }
 2621|  3.46k|        m_ErrorMarkers = phi::move(etmp);
 2622|       |
 2623|       |        // Remove breakpoints on that line
 2624|  3.46k|        Breakpoints btmp;
 2625|  3.46k|        for (const auto line_number : m_Breakpoints)
  ------------------
  |  Branch (2625:37): [True: 3.37k, False: 3.46k]
  ------------------
 2626|  3.37k|        {
 2627|  3.37k|            if (line_number == index)
  ------------------
  |  Branch (2627:17): [True: 47, False: 3.32k]
  ------------------
 2628|     47|            {
 2629|     47|                continue;
 2630|     47|            }
 2631|       |
 2632|  3.32k|            btmp.insert(line_number >= index ? phi::max(line_number - 1u, 1u) : line_number);
  ------------------
  |  Branch (2632:25): [True: 177, False: 3.15k]
  ------------------
 2633|  3.32k|        }
 2634|  3.46k|        m_Breakpoints = phi::move(btmp);
 2635|       |
 2636|       |        // Fix selection
 2637|  3.46k|        if (m_State.m_SelectionStart.m_Line >= index)
  ------------------
  |  Branch (2637:13): [True: 2.12k, False: 1.34k]
  ------------------
 2638|  2.12k|        {
 2639|  2.12k|            m_State.m_SelectionStart.m_Line--;
 2640|  2.12k|        }
 2641|  3.46k|        if (m_State.m_SelectionEnd.m_Line >= index)
  ------------------
  |  Branch (2641:13): [True: 2.12k, False: 1.34k]
  ------------------
 2642|  2.12k|        {
 2643|  2.12k|            m_State.m_SelectionEnd.m_Line--;
 2644|  2.12k|        }
 2645|       |
 2646|  3.46k|        m_Lines.erase(m_Lines.begin() + index.unsafe());
 2647|  3.46k|        PHI_ASSERT(!m_Lines.empty());
 2648|       |
 2649|  3.46k|        m_TextChanged = true;
 2650|  3.46k|    }
_ZN6dlxemu10CodeEditor10InsertLineEN3phi7integerIjEE:
 2653|  2.70M|    {
 2654|  2.70M|        PHI_ASSERT(!m_ReadOnly);
 2655|       |
 2656|  2.70M|        Line& result = *m_Lines.insert(m_Lines.begin() + index.unsafe(), Line());
 2657|       |
 2658|  2.70M|        ErrorMarkers etmp;
 2659|  2.70M|        for (const auto& marker : m_ErrorMarkers)
  ------------------
  |  Branch (2659:33): [True: 235k, False: 2.70M]
  ------------------
 2660|   235k|        {
 2661|   235k|            etmp.insert(ErrorMarkers::value_type(
 2662|   235k|                    marker.first >= index ? marker.first + 1u : marker.first, marker.second));
  ------------------
  |  Branch (2662:21): [True: 14.7k, False: 220k]
  ------------------
 2663|   235k|        }
 2664|  2.70M|        m_ErrorMarkers = phi::move(etmp);
 2665|       |
 2666|  2.70M|        Breakpoints btmp;
 2667|  2.70M|        for (const phi::u32 line_number : m_Breakpoints)
  ------------------
  |  Branch (2667:41): [True: 16.1k, False: 2.70M]
  ------------------
 2668|  16.1k|        {
 2669|  16.1k|            btmp.insert(line_number >= index ? line_number.unsafe() + 1u : line_number.unsafe());
  ------------------
  |  Branch (2669:25): [True: 1.95k, False: 14.1k]
  ------------------
 2670|  16.1k|        }
 2671|  2.70M|        m_Breakpoints = phi::move(btmp);
 2672|       |
 2673|  2.70M|        return result;
 2674|  2.70M|    }
_ZN6dlxemu10CodeEditor18EnterCharacterImplEtN3phi7booleanE:
 2677|  29.4k|    {
 2678|  29.4k|        PHI_ASSERT(!m_ReadOnly);
 2679|  29.4k|        PHI_ASSERT(IsValidUTF8Sequence(character));
 2680|  29.4k|        PHI_ASSERT(character != '\0');
 2681|       |
 2682|  29.4k|        UndoRecord undo;
 2683|  29.4k|        undo.StoreBeforeState(this);
 2684|       |
 2685|  29.4k|        phi::boolean removed_selection{false};
 2686|       |
 2687|  29.4k|        if (HasSelection())
  ------------------
  |  Branch (2687:13): [True: 1.99k, False: 27.4k]
  ------------------
 2688|  1.99k|        {
 2689|       |            // Do indenting
 2690|  1.99k|            if (character == '\t' &&
  ------------------
  |  Branch (2690:17): [True: 1.11k, False: 884]
  |  Branch (2690:17): [True: 1.07k, False: 917]
  ------------------
 2691|  1.99k|                (m_State.m_SelectionStart.m_Column == 0u ||
  ------------------
  |  Branch (2691:18): [True: 1.05k, False: 60]
  ------------------
 2692|  1.11k|                 m_State.m_SelectionStart.m_Line != m_State.m_SelectionEnd.m_Line))
  ------------------
  |  Branch (2692:18): [True: 27, False: 33]
  ------------------
 2693|  1.07k|            {
 2694|  1.07k|                Coordinates       start        = m_State.m_SelectionStart;
 2695|  1.07k|                Coordinates       end          = m_State.m_SelectionEnd;
 2696|  1.07k|                const Coordinates original_end = end;
 2697|       |
 2698|  1.07k|                PHI_ASSERT(start < end);
 2699|  1.07k|                start.m_Column = 0u;
 2700|       |                //          end.mColumn = end.mLine < mLines.size() ? mLines[end.mLine].size() : 0;
 2701|  1.07k|                if (end.m_Column == 0u && end.m_Line > 0u)
  ------------------
  |  Branch (2701:21): [True: 428, False: 649]
  |  Branch (2701:21): [True: 428, False: 649]
  |  Branch (2701:43): [True: 428, False: 0]
  ------------------
 2702|    428|                {
 2703|    428|                    --end.m_Line;
 2704|    428|                }
 2705|  1.07k|                if (end.m_Line >= m_Lines.size())
  ------------------
  |  Branch (2705:21): [True: 0, False: 1.07k]
  ------------------
 2706|      0|                {
 2707|      0|                    PHI_ASSERT(!m_Lines.empty());
 2708|      0|                    end.m_Line = GetMaxLineNumber();
 2709|      0|                }
 2710|  1.07k|                end.m_Column = GetLineMaxColumn(end.m_Line);
 2711|       |
 2712|       |                //if (end.mColumn >= GetLineMaxColumn(end.mLine))
 2713|       |                //  end.mColumn = GetLineMaxColumn(end.mLine) - 1;
 2714|       |
 2715|  1.07k|                undo.m_RemovedStart = start;
 2716|  1.07k|                undo.m_RemovedEnd   = end;
 2717|  1.07k|                undo.m_Removed      = GetText(start, end);
 2718|       |
 2719|  1.07k|                phi::boolean modified = false;
 2720|       |
 2721|  7.52k|                for (phi::u32 line_index = start.m_Line; line_index <= end.m_Line; ++line_index)
  ------------------
  |  Branch (2721:58): [True: 6.44k, False: 1.07k]
  ------------------
 2722|  6.44k|                {
 2723|  6.44k|                    PHI_ASSERT(line_index < m_Lines.size());
 2724|  6.44k|                    Line& line = m_Lines[line_index.unsafe()];
 2725|  6.44k|                    if (shift)
  ------------------
  |  Branch (2725:25): [True: 3.78k, False: 2.66k]
  ------------------
 2726|  3.78k|                    {
 2727|       |                        // Remove idention
 2728|  3.78k|                        if (line.empty())
  ------------------
  |  Branch (2728:29): [True: 468, False: 3.31k]
  ------------------
 2729|    468|                        {
 2730|       |                            // Skip already empty lines
 2731|    468|                            continue;
 2732|    468|                        }
 2733|       |
 2734|  3.31k|                        if (line.front().m_Char == '\t')
  ------------------
  |  Branch (2734:29): [True: 1.18k, False: 2.12k]
  ------------------
 2735|  1.18k|                        {
 2736|  1.18k|                            line.erase(line.begin());
 2737|  1.18k|                            modified = true;
 2738|  1.18k|                        }
 2739|  2.12k|                        else
 2740|  2.12k|                        {
 2741|  2.12k|                            for (phi::u32 j = 0u;
 2742|  5.29k|                                 j < m_TabSize && !line.empty() && line.front().m_Char == ' '; ++j)
  ------------------
  |  Branch (2742:34): [True: 4.82k, False: 472]
  |  Branch (2742:34): [True: 3.16k, False: 2.12k]
  |  Branch (2742:51): [True: 4.08k, False: 741]
  |  Branch (2742:68): [True: 3.16k, False: 915]
  ------------------
 2743|  3.16k|                            {
 2744|  3.16k|                                line.erase(line.begin());
 2745|  3.16k|                                modified = true;
 2746|  3.16k|                            }
 2747|  2.12k|                        }
 2748|  3.31k|                    }
 2749|  2.66k|                    else
 2750|  2.66k|                    {
 2751|  2.66k|                        PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
 2752|       |
 2753|       |                        // Add indention
 2754|  2.66k|                        line.insert(line.begin(), Glyph('\t', PaletteIndex::Background));
 2755|  2.66k|                        modified = true;
 2756|       |
 2757|  2.66k|                        PHI_GCC_SUPPRESS_WARNING_POP()
 2758|  2.66k|                    }
 2759|  6.44k|                }
 2760|       |
 2761|  1.07k|                if (modified)
  ------------------
  |  Branch (2761:21): [True: 951, False: 126]
  ------------------
 2762|    951|                {
 2763|    951|                    start = Coordinates(start.m_Line, GetCharacterColumn(start.m_Line, 0u));
 2764|    951|                    Coordinates range_end;
 2765|       |
 2766|    951|                    if (original_end.m_Column != 0u)
  ------------------
  |  Branch (2766:25): [True: 623, False: 328]
  ------------------
 2767|    623|                    {
 2768|    623|                        end          = Coordinates(end.m_Line, GetLineMaxColumn(end.m_Line));
 2769|    623|                        range_end    = end;
 2770|    623|                        undo.m_Added = GetText(start, end);
 2771|    623|                    }
 2772|    328|                    else
 2773|    328|                    {
 2774|    328|                        end       = Coordinates(original_end.m_Line, 0u);
 2775|    328|                        range_end = Coordinates(end.m_Line - 1u, GetLineMaxColumn(end.m_Line - 1u));
 2776|    328|                        undo.m_Added = GetText(start, range_end);
 2777|    328|                    }
 2778|       |
 2779|    951|                    undo.m_AddedStart        = start;
 2780|    951|                    undo.m_AddedEnd          = range_end;
 2781|    951|                    m_State.m_SelectionStart = start;
 2782|    951|                    m_State.m_SelectionEnd   = end;
 2783|       |
 2784|    951|                    undo.StoreAfterState(this);
 2785|    951|                    AddUndo(undo);
 2786|       |
 2787|    951|                    m_TextChanged = true;
 2788|       |
 2789|    951|                    EnsureCursorVisible();
 2790|    951|                }
 2791|       |
 2792|  1.07k|                return;
 2793|  1.07k|            } // c == '\t'
 2794|    917|            else
 2795|    917|            {
 2796|    917|                undo.m_Removed      = GetSelectedText();
 2797|    917|                undo.m_RemovedStart = m_State.m_SelectionStart;
 2798|    917|                undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2799|    917|                DeleteSelection();
 2800|       |
 2801|    917|                removed_selection = true;
 2802|    917|            }
 2803|  1.99k|        } // HasSelection
 2804|  28.3k|        {
 2805|       |            // Reset selection
 2806|  28.3k|            ClearSelection();
 2807|  28.3k|        }
 2808|       |
 2809|  28.3k|        const Coordinates coord = GetActualCursorCoordinates();
 2810|  28.3k|        undo.m_AddedStart       = coord;
 2811|       |
 2812|  28.3k|        PHI_ASSERT(!m_Lines.empty());
 2813|       |
 2814|  28.3k|        if (character == '\n')
  ------------------
  |  Branch (2814:13): [True: 11.4k, False: 16.9k]
  ------------------
 2815|  11.4k|        {
 2816|  11.4k|            InsertLine(coord.m_Line + 1u);
 2817|  11.4k|            undo.m_Added = static_cast<char>(character);
 2818|       |
 2819|  11.4k|            PHI_ASSERT(coord.m_Line < m_Lines.size() - 1u);
 2820|  11.4k|            Line& line     = m_Lines[coord.m_Line.unsafe()];
 2821|  11.4k|            Line& new_line = m_Lines[coord.m_Line.unsafe() + 1u];
 2822|       |
 2823|   528k|            for (phi::u32 it{0u}; it < line.size() && it < coord.m_Column &&
  ------------------
  |  Branch (2823:35): [True: 518k, False: 9.54k]
  |  Branch (2823:35): [True: 516k, False: 11.4k]
  |  Branch (2823:55): [True: 518k, False: 537]
  ------------------
 2824|   528k|                                  phi::is_blank(static_cast<char>(line[it.unsafe()].m_Char));
  ------------------
  |  Branch (2824:35): [True: 516k, False: 1.35k]
  ------------------
 2825|   516k|                 ++it)
 2826|   516k|            {
 2827|   516k|                new_line.push_back(line[it.unsafe()]);
 2828|   516k|                undo.m_Added += static_cast<char>(line[it.unsafe()].m_Char);
 2829|   516k|            }
 2830|       |
 2831|  11.4k|            const phi::usize whitespace_size = new_line.size();
 2832|  11.4k|            const phi::u32   cindex          = GetCharacterIndex(coord);
 2833|  11.4k|            new_line.insert(new_line.end(), line.begin() + cindex.unsafe(), line.end());
 2834|  11.4k|            line.erase(line.begin() + cindex.unsafe(),
 2835|  11.4k|                       line.begin() + static_cast<phi::int32_t>(line.size()));
 2836|       |
 2837|  11.4k|            SetCursorPosition(Coordinates(
 2838|  11.4k|                    coord.m_Line + 1u,
 2839|  11.4k|                    GetCharacterColumn(coord.m_Line.unsafe() + 1u,
 2840|  11.4k|                                       static_cast<phi::uint32_t>(whitespace_size.unsafe()))));
 2841|  11.4k|        }
 2842|  16.9k|        else
 2843|  16.9k|        {
 2844|  16.9k|            phi::array<char, 5u> buffer{};
 2845|  16.9k|            const phi::u8_fast   length = ImTextCharToUtf8(buffer, character);
 2846|       |
 2847|       |            // We require a valid ut8 sequence
 2848|  16.9k|            PHI_ASSERT(length > 0u);
 2849|       |
 2850|  16.9k|            Line&    line   = m_Lines[phi::narrow_cast<phi::size_t>(coord.m_Line)];
 2851|  16.9k|            phi::u32 cindex = GetCharacterIndex(coord);
 2852|       |
 2853|  16.9k|            if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (2853:17): [True: 1.66k, False: 15.2k]
  |  Branch (2853:17): [True: 1.21k, False: 15.7k]
  |  Branch (2853:32): [True: 1.21k, False: 449]
  ------------------
 2854|  1.21k|            {
 2855|  1.21k|                phi::u8_fast char_length = UTF8CharLength(line[cindex.unsafe()].m_Char);
 2856|       |
 2857|       |                // Only set the start if haven't removed something from deleting the selection beforehand
 2858|  1.21k|                if (removed_selection)
  ------------------
  |  Branch (2858:21): [True: 29, False: 1.18k]
  ------------------
 2859|     29|                {
 2860|     29|                    undo.m_RemovedEnd.m_Column += 1u;
 2861|     29|                }
 2862|  1.18k|                else
 2863|  1.18k|                {
 2864|  1.18k|                    undo.m_RemovedStart = m_State.m_CursorPosition;
 2865|  1.18k|                    undo.m_RemovedEnd   = Coordinates(
 2866|  1.18k|                            coord.m_Line, GetCharacterColumn(coord.m_Line, cindex + char_length));
 2867|  1.18k|                }
 2868|       |
 2869|  3.48k|                for (; char_length > 0u && cindex < line.size(); --char_length)
  ------------------
  |  Branch (2869:24): [True: 2.27k, False: 1.21k]
  |  Branch (2869:24): [True: 2.27k, False: 1.21k]
  |  Branch (2869:44): [True: 2.27k, False: 0]
  ------------------
 2870|  2.27k|                {
 2871|  2.27k|                    undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 2872|  2.27k|                    line.erase(line.begin() + cindex.unsafe());
 2873|  2.27k|                }
 2874|  1.21k|            }
 2875|       |
 2876|  46.6k|            for (char* pointer = buffer.data(); *pointer != '\0'; ++pointer, ++cindex)
  ------------------
  |  Branch (2876:49): [True: 29.6k, False: 16.9k]
  ------------------
 2877|  29.6k|            {
 2878|  29.6k|                line.insert(line.begin() + cindex.unsafe(),
 2879|  29.6k|                            Glyph(static_cast<phi::uint8_t>(*pointer), PaletteIndex::Default));
 2880|  29.6k|            }
 2881|  16.9k|            undo.m_Added = phi::string_view{buffer.data(), length.unsafe()};
 2882|       |
 2883|  16.9k|            SetCursorPosition(Coordinates(coord.m_Line, GetCharacterColumn(coord.m_Line, cindex)));
 2884|  16.9k|        }
 2885|       |
 2886|  28.3k|        m_TextChanged = true;
 2887|       |
 2888|  28.3k|        undo.m_AddedEnd = GetActualCursorCoordinates();
 2889|  28.3k|        undo.StoreAfterState(this);
 2890|       |
 2891|  28.3k|        AddUndo(undo);
 2892|       |
 2893|  28.3k|        Colorize(coord.m_Line, 1u);
 2894|  28.3k|    }
_ZN6dlxemu10CodeEditor13BackspaceImplEv:
 2897|  16.4k|    {
 2898|  16.4k|        PHI_ASSERT(!m_ReadOnly);
 2899|  16.4k|        PHI_ASSERT(!m_Lines.empty());
 2900|       |
 2901|  16.4k|        UndoRecord undo;
 2902|  16.4k|        undo.StoreBeforeState(this);
 2903|       |
 2904|  16.4k|        if (HasSelection())
  ------------------
  |  Branch (2904:13): [True: 126, False: 16.3k]
  ------------------
 2905|    126|        {
 2906|    126|            undo.m_Removed      = GetSelectedText();
 2907|    126|            undo.m_RemovedStart = m_State.m_SelectionStart;
 2908|    126|            undo.m_RemovedEnd   = m_State.m_SelectionEnd;
 2909|       |
 2910|    126|            DeleteSelection();
 2911|    126|        }
 2912|  16.3k|        else
 2913|  16.3k|        {
 2914|  16.3k|            Coordinates pos = GetActualCursorCoordinates();
 2915|  16.3k|            SetCursorPosition(pos);
 2916|       |
 2917|  16.3k|            if (m_State.m_CursorPosition.m_Column == 0u)
  ------------------
  |  Branch (2917:17): [True: 3.87k, False: 12.4k]
  ------------------
 2918|  3.87k|            {
 2919|  3.87k|                if (m_State.m_CursorPosition.m_Line == 0u)
  ------------------
  |  Branch (2919:21): [True: 983, False: 2.89k]
  ------------------
 2920|    983|                {
 2921|    983|                    return;
 2922|    983|                }
 2923|       |
 2924|  2.89k|                undo.m_Removed      = '\n';
 2925|  2.89k|                undo.m_RemovedStart = undo.m_RemovedEnd =
 2926|  2.89k|                        Coordinates(pos.m_Line - 1u, GetLineMaxColumn(pos.m_Line - 1u));
 2927|  2.89k|                Advance(undo.m_RemovedEnd);
 2928|       |
 2929|  2.89k|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2930|  2.89k|                Line& line      = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2931|  2.89k|                Line& prev_line = m_Lines[m_State.m_CursorPosition.m_Line.unsafe() - 1u];
 2932|       |
 2933|  2.89k|                const phi::u32 prev_size = GetLineMaxColumn(m_State.m_CursorPosition.m_Line - 1u);
 2934|  2.89k|                prev_line.insert(prev_line.end(), line.begin(), line.end());
 2935|       |
 2936|  2.89k|                ErrorMarkers etmp;
 2937|  2.89k|                for (auto& error_marker : m_ErrorMarkers)
  ------------------
  |  Branch (2937:41): [True: 2.17k, False: 2.89k]
  ------------------
 2938|  2.17k|                {
 2939|  2.17k|                    const phi::u32 error_marker_line = error_marker.first;
 2940|       |
 2941|  2.17k|                    etmp.insert(ErrorMarkers::value_type(
 2942|  2.17k|                            (error_marker_line - 1u) == m_State.m_CursorPosition.m_Line ?
  ------------------
  |  Branch (2942:29): [True: 28, False: 2.14k]
  ------------------
 2943|     28|                                    error_marker_line - 1u :
 2944|  2.17k|                                    error_marker_line,
 2945|  2.17k|                            error_marker.second));
 2946|  2.17k|                }
 2947|  2.89k|                m_ErrorMarkers = phi::move(etmp);
 2948|       |
 2949|  2.89k|                RemoveLine(m_State.m_CursorPosition.m_Line);
 2950|  2.89k|                --m_State.m_CursorPosition.m_Line;
 2951|  2.89k|                m_State.m_CursorPosition.m_Column = prev_size;
 2952|  2.89k|            }
 2953|  12.4k|            else
 2954|  12.4k|            {
 2955|  12.4k|                PHI_ASSERT(m_State.m_CursorPosition.m_Line < m_Lines.size());
 2956|  12.4k|                Line&    line   = m_Lines[m_State.m_CursorPosition.m_Line.unsafe()];
 2957|  12.4k|                phi::u32 cindex = GetCharacterIndex(pos) - 1u;
 2958|       |
 2959|  12.4k|                if (line[cindex.unsafe()].m_Char == '\t')
  ------------------
  |  Branch (2959:21): [True: 160, False: 12.3k]
  ------------------
 2960|    160|                {
 2961|    160|                    undo.m_RemovedStart.m_Line = GetActualCursorCoordinates().m_Line;
 2962|    160|                    undo.m_RemovedEnd          = GetActualCursorCoordinates();
 2963|    160|                    undo.m_Removed             = '\t';
 2964|       |
 2965|    160|                    line.erase(line.begin() + cindex.unsafe());
 2966|       |
 2967|       |                    // Move cursor back
 2968|    160|                    m_State.m_CursorPosition.m_Column = GetCharacterColumn(pos.m_Line, cindex);
 2969|    160|                    undo.m_RemovedStart.m_Column      = GetCharacterColumn(pos.m_Line, cindex);
 2970|    160|                }
 2971|  12.3k|                else
 2972|  12.3k|                {
 2973|  12.3k|                    phi::u32 cend = cindex + 1u;
 2974|  20.3k|                    while (cindex > 0u && IsUTFSequence(line[cindex.unsafe()].m_Char))
  ------------------
  |  Branch (2974:28): [True: 19.9k, False: 436]
  |  Branch (2974:28): [True: 8.05k, False: 12.3k]
  |  Branch (2974:43): [True: 8.05k, False: 11.8k]
  ------------------
 2975|  8.05k|                    {
 2976|  8.05k|                        --cindex;
 2977|  8.05k|                    }
 2978|       |
 2979|  12.3k|                    undo.m_RemovedStart = undo.m_RemovedEnd = GetActualCursorCoordinates();
 2980|  12.3k|                    --undo.m_RemovedStart.m_Column;
 2981|  12.3k|                    --m_State.m_CursorPosition.m_Column;
 2982|       |
 2983|  32.6k|                    for (; cindex < line.size() && cend > cindex; --cend)
  ------------------
  |  Branch (2983:28): [True: 20.7k, False: 11.9k]
  |  Branch (2983:28): [True: 20.3k, False: 12.3k]
  |  Branch (2983:52): [True: 20.3k, False: 375]
  ------------------
 2984|  20.3k|                    {
 2985|  20.3k|                        undo.m_Removed += static_cast<char>(line[cindex.unsafe()].m_Char);
 2986|  20.3k|                        line.erase(line.begin() + cindex.unsafe());
 2987|  20.3k|                    }
 2988|  12.3k|                }
 2989|  12.4k|            }
 2990|       |
 2991|  15.3k|            m_TextChanged = true;
 2992|       |
 2993|  15.3k|            EnsureCursorVisible();
 2994|  15.3k|            Colorize(m_State.m_CursorPosition.m_Line, 1);
 2995|  15.3k|        }
 2996|       |
 2997|       |        // Correct selection
 2998|  15.4k|        m_State.m_SelectionStart = SanitizeCoordinates(m_State.m_SelectionStart);
 2999|  15.4k|        m_State.m_SelectionEnd   = SanitizeCoordinates(m_State.m_SelectionEnd);
 3000|       |
 3001|  15.4k|        undo.StoreAfterState(this);
 3002|  15.4k|        AddUndo(undo);
 3003|  15.4k|    }
_ZN6dlxemu10CodeEditor15DeleteSelectionEv:
 3006|  3.62k|    {
 3007|  3.62k|        if (m_State.m_SelectionEnd == m_State.m_SelectionStart)
  ------------------
  |  Branch (3007:13): [True: 0, False: 3.62k]
  ------------------
 3008|      0|        {
 3009|      0|            return;
 3010|      0|        }
 3011|       |
 3012|  3.62k|        DeleteRange(m_State.m_SelectionStart, m_State.m_SelectionEnd);
 3013|       |
 3014|  3.62k|        SetSelection(m_State.m_SelectionStart, m_State.m_SelectionStart);
 3015|  3.62k|        SetCursorPosition(m_State.m_SelectionStart);
 3016|  3.62k|        Colorize(m_State.m_SelectionStart.m_Line, 1);
 3017|  3.62k|        m_TextChanged = true;
 3018|  3.62k|    }
_ZNK6dlxemu10CodeEditor13GetGlyphColorERKNS0_5GlyphE:
 3021|   362k|    {
 3022|   362k|        if (!m_ColorizerEnabled)
  ------------------
  |  Branch (3022:13): [True: 8.71k, False: 353k]
  ------------------
 3023|  8.71k|        {
 3024|  8.71k|            return GetPaletteForIndex(PaletteIndex::Default);
 3025|  8.71k|        }
 3026|       |
 3027|   353k|        return GetPaletteForIndex(glyph.m_ColorIndex);
 3028|   362k|    }
_ZN6dlxemu10CodeEditor20HandleKeyboardInputsEv:
 3031|  16.9k|    {
 3032|  16.9k|        if (!ImGui::IsWindowFocused())
  ------------------
  |  Branch (3032:13): [True: 10.5k, False: 6.42k]
  ------------------
 3033|  10.5k|        {
 3034|  10.5k|            return;
 3035|  10.5k|        }
 3036|       |
 3037|  6.42k|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3038|  6.42k|        const phi::boolean shift    = imgui_io.KeyShift;
 3039|  6.42k|        const phi::boolean ctrl =
 3040|  6.42k|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3040:17): [True: 0, False: 6.42k]
  ------------------
 3041|  6.42k|        const phi::boolean alt =
 3042|  6.42k|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3042:17): [True: 0, False: 6.42k]
  ------------------
 3043|       |
 3044|  6.42k|        if (ImGui::IsWindowHovered())
  ------------------
  |  Branch (3044:13): [True: 0, False: 6.42k]
  ------------------
 3045|      0|        {
 3046|      0|            ImGui::SetMouseCursor(ImGuiMouseCursor_TextInput);
 3047|      0|        }
 3048|       |        //ImGui::CaptureKeyboardFromApp(true);
 3049|       |
 3050|  6.42k|        imgui_io.WantCaptureKeyboard = true;
 3051|  6.42k|        imgui_io.WantTextInput       = true;
 3052|       |
 3053|  6.42k|        if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Z))
  ------------------
  |  Branch (3053:13): [True: 6.37k, False: 48]
  |  Branch (3053:13): [True: 0, False: 6.42k]
  |  Branch (3053:30): [True: 0, False: 6.37k]
  |  Branch (3053:38): [True: 0, False: 0]
  |  Branch (3053:48): [True: 0, False: 0]
  |  Branch (3053:56): [True: 0, False: 0]
  ------------------
 3054|      0|        {
 3055|      0|            Undo();
 3056|      0|        }
 3057|  6.42k|        else if (!IsReadOnly() && !ctrl && !shift && alt && ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3057:18): [True: 6.37k, False: 48]
  |  Branch (3057:18): [True: 0, False: 6.42k]
  |  Branch (3057:35): [True: 6.37k, False: 0]
  |  Branch (3057:44): [True: 6.37k, False: 0]
  |  Branch (3057:54): [True: 0, False: 6.37k]
  |  Branch (3057:61): [True: 0, False: 0]
  ------------------
 3058|      0|        {
 3059|      0|            Undo();
 3060|      0|        }
 3061|  6.42k|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Y))
  ------------------
  |  Branch (3061:18): [True: 6.37k, False: 48]
  |  Branch (3061:18): [True: 0, False: 6.42k]
  |  Branch (3061:35): [True: 0, False: 6.37k]
  |  Branch (3061:43): [True: 0, False: 0]
  |  Branch (3061:53): [True: 0, False: 0]
  |  Branch (3061:61): [True: 0, False: 0]
  ------------------
 3062|      0|        {
 3063|      0|            Redo();
 3064|      0|        }
 3065|  6.42k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_UpArrow))
  ------------------
  |  Branch (3065:18): [True: 6.42k, False: 0]
  |  Branch (3065:18): [True: 8, False: 6.41k]
  |  Branch (3065:27): [True: 6.42k, False: 0]
  |  Branch (3065:35): [True: 8, False: 6.41k]
  ------------------
 3066|      8|        {
 3067|      8|            MoveUp(1u, shift);
 3068|      8|        }
 3069|  6.41k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_DownArrow))
  ------------------
  |  Branch (3069:18): [True: 6.41k, False: 0]
  |  Branch (3069:18): [True: 63, False: 6.35k]
  |  Branch (3069:27): [True: 6.41k, False: 0]
  |  Branch (3069:35): [True: 63, False: 6.35k]
  ------------------
 3070|     63|        {
 3071|     63|            MoveDown(1u, shift);
 3072|     63|        }
 3073|  6.35k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_LeftArrow))
  ------------------
  |  Branch (3073:18): [True: 6.35k, False: 0]
  |  Branch (3073:18): [True: 25, False: 6.32k]
  |  Branch (3073:26): [True: 25, False: 6.32k]
  ------------------
 3074|     25|        {
 3075|     25|            MoveLeft(1u, shift, ctrl);
 3076|     25|        }
 3077|  6.32k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_RightArrow))
  ------------------
  |  Branch (3077:18): [True: 6.32k, False: 0]
  |  Branch (3077:18): [True: 27, False: 6.30k]
  |  Branch (3077:26): [True: 27, False: 6.30k]
  ------------------
 3078|     27|        {
 3079|     27|            MoveRight(1u, shift, ctrl);
 3080|     27|        }
 3081|  6.30k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageUp))
  ------------------
  |  Branch (3081:18): [True: 6.30k, False: 0]
  |  Branch (3081:18): [True: 5, False: 6.29k]
  |  Branch (3081:26): [True: 5, False: 6.29k]
  ------------------
 3082|      5|        {
 3083|      5|            const phi::u32 page_size = GetPageSize();
 3084|      5|            MoveUp(page_size - 4u, shift);
 3085|      5|        }
 3086|  6.29k|        else if (!alt && ImGui::IsKeyPressed(ImGuiKey_PageDown))
  ------------------
  |  Branch (3086:18): [True: 6.29k, False: 0]
  |  Branch (3086:18): [True: 56, False: 6.23k]
  |  Branch (3086:26): [True: 56, False: 6.23k]
  ------------------
 3087|     56|        {
 3088|     56|            const phi::u32 page_size = GetPageSize();
 3089|     56|            MoveDown(page_size - 4u, shift);
 3090|     56|        }
 3091|  6.23k|        else if (!alt && ctrl && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3091:18): [True: 6.23k, False: 0]
  |  Branch (3091:18): [True: 0, False: 6.23k]
  |  Branch (3091:26): [True: 0, False: 6.23k]
  |  Branch (3091:34): [True: 0, False: 0]
  ------------------
 3092|      0|        {
 3093|      0|            MoveTop(shift);
 3094|      0|        }
 3095|  6.23k|        else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3095:18): [True: 0, False: 6.23k]
  |  Branch (3095:18): [True: 0, False: 6.23k]
  |  Branch (3095:26): [True: 0, False: 0]
  |  Branch (3095:34): [True: 0, False: 0]
  ------------------
 3096|      0|        {
 3097|      0|            MoveBottom(shift);
 3098|      0|        }
 3099|  6.23k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Home))
  ------------------
  |  Branch (3099:18): [True: 6.23k, False: 0]
  |  Branch (3099:18): [True: 13, False: 6.22k]
  |  Branch (3099:27): [True: 6.23k, False: 0]
  |  Branch (3099:35): [True: 13, False: 6.22k]
  ------------------
 3100|     13|        {
 3101|     13|            MoveHome(shift);
 3102|     13|        }
 3103|  6.22k|        else if (!ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_End))
  ------------------
  |  Branch (3103:18): [True: 6.22k, False: 0]
  |  Branch (3103:18): [True: 11, False: 6.21k]
  |  Branch (3103:27): [True: 6.22k, False: 0]
  |  Branch (3103:35): [True: 11, False: 6.21k]
  ------------------
 3104|     11|        {
 3105|     11|            MoveEnd(shift);
 3106|     11|        }
 3107|  6.21k|        else if (!IsReadOnly() && !ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3107:18): [True: 6.17k, False: 45]
  |  Branch (3107:18): [True: 1, False: 6.21k]
  |  Branch (3107:35): [True: 6.17k, False: 0]
  |  Branch (3107:44): [True: 6.17k, False: 0]
  |  Branch (3107:54): [True: 6.17k, False: 0]
  |  Branch (3107:62): [True: 1, False: 6.16k]
  ------------------
 3108|      1|        {
 3109|      1|            Delete();
 3110|      1|        }
 3111|  6.21k|        else if (!IsReadOnly() && !ctrl && !shift && !alt &&
  ------------------
  |  Branch (3111:18): [True: 6.16k, False: 45]
  |  Branch (3111:18): [True: 0, False: 6.21k]
  |  Branch (3111:35): [True: 6.16k, False: 0]
  |  Branch (3111:44): [True: 6.16k, False: 0]
  |  Branch (3111:54): [True: 6.16k, False: 0]
  ------------------
 3112|  6.21k|                 ImGui::IsKeyPressed(ImGuiKey_Backspace))
  ------------------
  |  Branch (3112:18): [True: 0, False: 6.16k]
  ------------------
 3113|      0|        {
 3114|      0|            BackspaceImpl();
 3115|      0|        }
 3116|  6.21k|        else if (!ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3116:18): [True: 6.21k, False: 0]
  |  Branch (3116:18): [True: 17, False: 6.19k]
  |  Branch (3116:27): [True: 6.21k, False: 0]
  |  Branch (3116:37): [True: 6.21k, False: 0]
  |  Branch (3116:45): [True: 17, False: 6.19k]
  ------------------
 3117|     17|        {
 3118|     17|            m_Overwrite = !m_Overwrite;
 3119|     17|        }
 3120|  6.19k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3120:18): [True: 0, False: 6.19k]
  |  Branch (3120:18): [True: 0, False: 6.19k]
  |  Branch (3120:26): [True: 0, False: 0]
  |  Branch (3120:36): [True: 0, False: 0]
  |  Branch (3120:44): [True: 0, False: 0]
  ------------------
 3121|      0|        {
 3122|      0|            Copy();
 3123|      0|        }
 3124|  6.19k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_C))
  ------------------
  |  Branch (3124:18): [True: 0, False: 6.19k]
  |  Branch (3124:18): [True: 0, False: 6.19k]
  |  Branch (3124:26): [True: 0, False: 0]
  |  Branch (3124:36): [True: 0, False: 0]
  |  Branch (3124:44): [True: 0, False: 0]
  ------------------
 3125|      0|        {
 3126|      0|            Copy();
 3127|      0|        }
 3128|  6.19k|        else if (!IsReadOnly() && !ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Insert))
  ------------------
  |  Branch (3128:18): [True: 6.15k, False: 45]
  |  Branch (3128:18): [True: 0, False: 6.19k]
  |  Branch (3128:35): [True: 6.15k, False: 0]
  |  Branch (3128:44): [True: 0, False: 6.15k]
  |  Branch (3128:53): [True: 0, False: 0]
  |  Branch (3128:61): [True: 0, False: 0]
  ------------------
 3129|      0|        {
 3130|      0|            Paste();
 3131|      0|        }
 3132|  6.19k|        else if (!IsReadOnly() && ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_V))
  ------------------
  |  Branch (3132:18): [True: 6.15k, False: 45]
  |  Branch (3132:18): [True: 0, False: 6.19k]
  |  Branch (3132:35): [True: 0, False: 6.15k]
  |  Branch (3132:43): [True: 0, False: 0]
  |  Branch (3132:53): [True: 0, False: 0]
  |  Branch (3132:61): [True: 0, False: 0]
  ------------------
 3133|      0|        {
 3134|      0|            Paste();
 3135|      0|        }
 3136|  6.19k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_X))
  ------------------
  |  Branch (3136:18): [True: 0, False: 6.19k]
  |  Branch (3136:18): [True: 0, False: 6.19k]
  |  Branch (3136:26): [True: 0, False: 0]
  |  Branch (3136:36): [True: 0, False: 0]
  |  Branch (3136:44): [True: 0, False: 0]
  ------------------
 3137|      0|        {
 3138|      0|            Cut();
 3139|      0|        }
 3140|  6.19k|        else if (!ctrl && shift && !alt && ImGui::IsKeyPressed(ImGuiKey_Delete))
  ------------------
  |  Branch (3140:18): [True: 6.19k, False: 0]
  |  Branch (3140:18): [True: 0, False: 6.19k]
  |  Branch (3140:27): [True: 0, False: 6.19k]
  |  Branch (3140:36): [True: 0, False: 0]
  |  Branch (3140:44): [True: 0, False: 0]
  ------------------
 3141|      0|        {
 3142|      0|            Cut();
 3143|      0|        }
 3144|  6.19k|        else if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_A))
  ------------------
  |  Branch (3144:18): [True: 0, False: 6.19k]
  |  Branch (3144:18): [True: 0, False: 6.19k]
  |  Branch (3144:26): [True: 0, False: 0]
  |  Branch (3144:36): [True: 0, False: 0]
  |  Branch (3144:44): [True: 0, False: 0]
  ------------------
 3145|      0|        {
 3146|      0|            SelectAll();
 3147|      0|        }
 3148|  6.19k|        else if (!IsReadOnly() && !ctrl && !alt &&
  ------------------
  |  Branch (3148:18): [True: 6.15k, False: 45]
  |  Branch (3148:18): [True: 92, False: 6.10k]
  |  Branch (3148:35): [True: 6.15k, False: 0]
  |  Branch (3148:44): [True: 6.15k, False: 0]
  ------------------
 3149|  6.19k|                 (ImGui::IsKeyPressed(ImGuiKey_Enter) || ImGui::IsKeyPressed(ImGuiKey_KeypadEnter)))
  ------------------
  |  Branch (3149:19): [True: 92, False: 6.06k]
  |  Branch (3149:58): [True: 0, False: 6.06k]
  ------------------
 3150|     92|        {
 3151|     92|            EnterCharacterImpl('\n', shift);
 3152|     92|        }
 3153|  6.10k|        else if (!IsReadOnly() && !ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_Tab))
  ------------------
  |  Branch (3153:18): [True: 6.06k, False: 45]
  |  Branch (3153:18): [True: 43, False: 6.06k]
  |  Branch (3153:35): [True: 6.06k, False: 0]
  |  Branch (3153:44): [True: 6.06k, False: 0]
  |  Branch (3153:52): [True: 43, False: 6.01k]
  ------------------
 3154|     43|        {
 3155|     43|            EnterCharacterImpl('\t', shift);
 3156|     43|        }
 3157|       |
 3158|  6.42k|        if (!IsReadOnly() && !imgui_io.InputQueueCharacters.empty())
  ------------------
  |  Branch (3158:13): [True: 6.37k, False: 48]
  |  Branch (3158:13): [True: 214, False: 6.20k]
  |  Branch (3158:30): [True: 214, False: 6.16k]
  ------------------
 3159|    214|        {
 3160|    598|            for (phi::i32 i{0}; i < imgui_io.InputQueueCharacters.Size; ++i)
  ------------------
  |  Branch (3160:33): [True: 384, False: 214]
  ------------------
 3161|    384|            {
 3162|    384|                ImWchar input_char = imgui_io.InputQueueCharacters[i.unsafe()];
 3163|    384|                if (input_char != '\0' && IsValidUTF8Sequence(input_char))
  ------------------
  |  Branch (3163:21): [True: 384, False: 0]
  |  Branch (3163:21): [True: 383, False: 1]
  |  Branch (3163:43): [True: 383, False: 1]
  ------------------
 3164|    383|                {
 3165|    383|                    EnterCharacterImpl(input_char, shift);
 3166|    383|                }
 3167|    384|            }
 3168|       |
 3169|    214|            imgui_io.InputQueueCharacters.resize(0);
 3170|    214|        }
 3171|  6.42k|    }
_ZN6dlxemu10CodeEditor17HandleMouseInputsEv:
 3174|  16.9k|    {
 3175|       |        // Do nothing if our window is not hovered
 3176|  16.9k|        if (!ImGui::IsWindowHovered())
  ------------------
  |  Branch (3176:13): [True: 16.9k, False: 30]
  ------------------
 3177|  16.9k|        {
 3178|  16.9k|            return;
 3179|  16.9k|        }
 3180|       |
 3181|     30|        ImGuiIO&           imgui_io = ImGui::GetIO();
 3182|     30|        const phi::boolean shift    = imgui_io.KeyShift;
 3183|     30|        const phi::boolean ctrl =
 3184|     30|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeySuper : imgui_io.KeyCtrl;
  ------------------
  |  Branch (3184:17): [True: 0, False: 30]
  ------------------
 3185|     30|        const phi::boolean alt =
 3186|     30|                imgui_io.ConfigMacOSXBehaviors ? imgui_io.KeyCtrl : imgui_io.KeyAlt;
  ------------------
  |  Branch (3186:17): [True: 0, False: 30]
  ------------------
 3187|       |
 3188|     30|        if (shift || alt)
  ------------------
  |  Branch (3188:13): [True: 0, False: 30]
  |  Branch (3188:22): [True: 0, False: 30]
  ------------------
 3189|      0|        {
 3190|      0|            return;
 3191|      0|        }
 3192|       |
 3193|       |        // TODO: Maybe theres a smarter way here than suppressing the warning and comparing m_LastClick != -1.0f?
 3194|     30|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3195|       |
 3196|     30|        const phi::boolean click        = ImGui::IsMouseClicked(ImGuiMouseButton_Left);
 3197|     30|        const phi::boolean double_click = ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left);
 3198|     30|        const double       time         = ImGui::GetTime();
 3199|     30|        const phi::boolean triple_click =
 3200|     30|                click && !double_click &&
  ------------------
  |  Branch (3200:17): [True: 0, False: 30]
  |  Branch (3200:26): [True: 0, False: 0]
  ------------------
 3201|     30|                (m_LastClick != -1.0f &&
  ------------------
  |  Branch (3201:18): [True: 0, False: 0]
  ------------------
 3202|      0|                 (static_cast<float>(time) - m_LastClick) < imgui_io.MouseDoubleClickTime);
  ------------------
  |  Branch (3202:18): [True: 0, False: 0]
  ------------------
 3203|       |
 3204|     30|        PHI_CLANG_AND_GCC_SUPPRESS_WARNING_POP()
 3205|       |
 3206|       |        /*
 3207|       |            Left mouse button triple click
 3208|       |        */
 3209|       |
 3210|     30|        if (triple_click)
  ------------------
  |  Branch (3210:13): [True: 0, False: 30]
  ------------------
 3211|      0|        {
 3212|      0|            if (!ctrl)
  ------------------
  |  Branch (3212:17): [True: 0, False: 0]
  ------------------
 3213|      0|            {
 3214|      0|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3215|      0|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3216|      0|                m_SelectionMode = SelectionMode::Line;
 3217|      0|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3218|      0|            }
 3219|       |
 3220|      0|            m_LastClick = -1.0f;
 3221|      0|        }
 3222|       |
 3223|       |        /*
 3224|       |            Left mouse button double click
 3225|       |        */
 3226|       |
 3227|     30|        else if (double_click)
  ------------------
  |  Branch (3227:18): [True: 0, False: 30]
  ------------------
 3228|      0|        {
 3229|      0|            if (!ctrl)
  ------------------
  |  Branch (3229:17): [True: 0, False: 0]
  ------------------
 3230|      0|            {
 3231|      0|                m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3232|      0|                        ScreenPosToCoordinates(ImGui::GetMousePos());
 3233|      0|                if (m_SelectionMode == SelectionMode::Line)
  ------------------
  |  Branch (3233:21): [True: 0, False: 0]
  ------------------
 3234|      0|                {
 3235|      0|                    m_SelectionMode = SelectionMode::Normal;
 3236|      0|                }
 3237|      0|                else
 3238|      0|                {
 3239|      0|                    m_SelectionMode = SelectionMode::Word;
 3240|      0|                }
 3241|      0|                SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3242|      0|            }
 3243|       |
 3244|      0|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3245|      0|        }
 3246|       |
 3247|       |        /*
 3248|       |            Left mouse button click
 3249|       |        */
 3250|       |
 3251|     30|        else if (click)
  ------------------
  |  Branch (3251:18): [True: 0, False: 30]
  ------------------
 3252|      0|        {
 3253|      0|            m_State.m_CursorPosition = m_InteractiveStart = m_InteractiveEnd =
 3254|      0|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3255|      0|            if (ctrl)
  ------------------
  |  Branch (3255:17): [True: 0, False: 0]
  ------------------
 3256|      0|            {
 3257|      0|                m_SelectionMode = SelectionMode::Word;
 3258|      0|            }
 3259|      0|            else
 3260|      0|            {
 3261|      0|                m_SelectionMode = SelectionMode::Normal;
 3262|      0|            }
 3263|      0|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3264|       |
 3265|      0|            m_LastClick = static_cast<float>(ImGui::GetTime());
 3266|      0|        }
 3267|       |        // Mouse left button dragging (=> update selection)
 3268|     30|        else if (ImGui::IsMouseDragging(ImGuiMouseButton_Left) &&
  ------------------
  |  Branch (3268:18): [True: 2, False: 28]
  ------------------
 3269|     30|                 ImGui::IsMouseDown(ImGuiMouseButton_Left))
  ------------------
  |  Branch (3269:18): [True: 2, False: 0]
  ------------------
 3270|      2|        {
 3271|      2|            imgui_io.WantCaptureMouse = true;
 3272|      2|            m_State.m_CursorPosition  = m_InteractiveEnd =
 3273|      2|                    ScreenPosToCoordinates(ImGui::GetMousePos());
 3274|      2|            SetSelection(m_InteractiveStart, m_InteractiveEnd, m_SelectionMode);
 3275|      2|        }
 3276|     30|    }
_ZN6dlxemu10CodeEditor14InternalRenderEv:
 3280|  16.9k|    {
 3281|  16.9k|        PHI_ASSERT(m_LineBuffer.empty());
 3282|       |
 3283|  16.9k|        const ImVec2 content_size = ImGui::GetWindowContentRegionMax();
 3284|  16.9k|        ImDrawList*  draw_list    = ImGui::GetWindowDrawList();
 3285|  16.9k|        float        longest      = m_TextStart;
 3286|       |
 3287|  16.9k|        if (m_ScrollToTop)
  ------------------
  |  Branch (3287:13): [True: 47, False: 16.9k]
  ------------------
 3288|     47|        {
 3289|     47|            m_ScrollToTop = false;
 3290|     47|            ImGui::SetScrollY(0.f);
 3291|     47|        }
 3292|       |
 3293|  16.9k|        const ImVec2 cursor_screen_pos = ImGui::GetCursorScreenPos();
 3294|  16.9k|        const float  scroll_x          = ImGui::GetScrollX();
 3295|  16.9k|        const float  scroll_y          = ImGui::GetScrollY();
 3296|       |
 3297|  16.9k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3298|  16.9k|        phi::u32       line_no = static_cast<phi::uint32_t>(std::floor(scroll_y / m_CharAdvance.y));
 3299|  16.9k|        const phi::u32 global_line_max = static_cast<phi::uint32_t>(m_Lines.size());
 3300|       |
 3301|       |        // TODO: This is very unreadable
 3302|  16.9k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3303|  16.9k|        const phi::u32 line_max = static_cast<phi::uint32_t>(phi::clamp(
 3304|  16.9k|                GetMaxLineNumber().unsafe(), 0u,
 3305|  16.9k|                line_no.unsafe() + static_cast<phi::int32_t>(std::floor(
 3306|  16.9k|                                           (scroll_y + content_size.y) / m_CharAdvance.y))));
 3307|       |
 3308|       |        // Deduce m_TextStart by evaluating mLines size (global lineMax) plus two spaces as text width
 3309|  16.9k|        phi::array<char, 16u> buffer;
 3310|  16.9k|        snprintf(buffer.data(), buffer.size().unsafe(), " %u ", global_line_max.unsafe());
 3311|  16.9k|        m_TextStart = ImGui::GetFont()
 3312|  16.9k|                              ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3313|  16.9k|                                              nullptr, nullptr)
 3314|  16.9k|                              .x +
 3315|  16.9k|                      LeftMargin;
 3316|       |
 3317|  16.9k|        PHI_ASSERT(!m_Lines.empty());
 3318|  16.9k|        float space_size =
 3319|  16.9k|                ImGui::GetFont()
 3320|  16.9k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, " ", nullptr, nullptr)
 3321|  16.9k|                        .x;
 3322|       |
 3323|  38.9k|        while (line_no <= line_max)
  ------------------
  |  Branch (3323:16): [True: 21.9k, False: 16.9k]
  ------------------
 3324|  21.9k|        {
 3325|  21.9k|            const ImVec2 line_start_screen_pos = ImVec2(
 3326|  21.9k|                    cursor_screen_pos.x,
 3327|  21.9k|                    cursor_screen_pos.y + static_cast<float>(line_no.unsafe()) * m_CharAdvance.y);
 3328|  21.9k|            const ImVec2 text_screen_pos =
 3329|  21.9k|                    ImVec2(line_start_screen_pos.x + m_TextStart, line_start_screen_pos.y);
 3330|       |
 3331|  21.9k|            PHI_ASSERT(line_no < m_Lines.size());
 3332|  21.9k|            const Line& line = m_Lines[line_no.unsafe()];
 3333|       |
 3334|  21.9k|            longest               = phi::max(m_TextStart + TextDistanceToLineStart(Coordinates(
 3335|  21.9k|                                                     line_no, GetLineMaxColumn(line_no))),
 3336|  21.9k|                                             longest);
 3337|  21.9k|            phi::u32    column_no = 0u;
 3338|  21.9k|            Coordinates line_start_coord(line_no, 0u);
 3339|  21.9k|            Coordinates line_end_coord(line_no, GetLineMaxColumn(line_no));
 3340|       |
 3341|       |            // Draw selection for the current line
 3342|  21.9k|            float sstart = -1.0f;
 3343|  21.9k|            float ssend  = -1.0f;
 3344|       |
 3345|  21.9k|            PHI_ASSERT(m_State.m_SelectionStart <= m_State.m_SelectionEnd);
 3346|  21.9k|            if (m_State.m_SelectionStart <= line_end_coord)
  ------------------
  |  Branch (3346:17): [True: 19.3k, False: 2.63k]
  ------------------
 3347|  19.3k|            {
 3348|  19.3k|                sstart = m_State.m_SelectionStart > line_start_coord ?
  ------------------
  |  Branch (3348:26): [True: 1.63k, False: 17.7k]
  ------------------
 3349|  1.63k|                                 TextDistanceToLineStart(m_State.m_SelectionStart) :
 3350|  19.3k|                                 0.0f;
 3351|  19.3k|            }
 3352|       |
 3353|  21.9k|            if (m_State.m_SelectionEnd > line_start_coord)
  ------------------
  |  Branch (3353:17): [True: 5.15k, False: 16.8k]
  ------------------
 3354|  5.15k|            {
 3355|  5.15k|                ssend = TextDistanceToLineStart(m_State.m_SelectionEnd < line_end_coord ?
  ------------------
  |  Branch (3355:49): [True: 319, False: 4.83k]
  ------------------
 3356|    319|                                                        m_State.m_SelectionEnd :
 3357|  5.15k|                                                        line_end_coord);
 3358|  5.15k|            }
 3359|       |
 3360|  21.9k|            if (m_State.m_SelectionEnd.m_Line > line_no)
  ------------------
  |  Branch (3360:17): [True: 3.24k, False: 18.7k]
  ------------------
 3361|  3.24k|            {
 3362|  3.24k|                ssend += m_CharAdvance.x;
 3363|  3.24k|            }
 3364|       |
 3365|  21.9k|            PHI_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wfloat-equal")
 3366|       |
 3367|  21.9k|            if (sstart != -1.0f && ssend != -1.0f && sstart < ssend)
  ------------------
  |  Branch (3367:17): [True: 19.3k, False: 2.63k]
  |  Branch (3367:36): [True: 2.52k, False: 16.8k]
  |  Branch (3367:54): [True: 890, False: 1.63k]
  ------------------
 3368|    890|            {
 3369|    890|                const ImVec2 vstart(line_start_screen_pos.x + m_TextStart + sstart,
 3370|    890|                                    line_start_screen_pos.y);
 3371|    890|                const ImVec2 vend(line_start_screen_pos.x + m_TextStart + ssend,
 3372|    890|                                  line_start_screen_pos.y + m_CharAdvance.y);
 3373|       |
 3374|    890|                draw_list->AddRectFilled(vstart, vend, GetPaletteForIndex(PaletteIndex::Selection));
 3375|    890|            }
 3376|       |
 3377|  21.9k|            PHI_GCC_SUPPRESS_WARNING_POP()
 3378|       |
 3379|       |            // Draw breakpoints
 3380|  21.9k|            const ImVec2 start =
 3381|  21.9k|                    ImVec2(line_start_screen_pos.x + scroll_x, line_start_screen_pos.y);
 3382|       |
 3383|  21.9k|            if (m_Breakpoints.find(line_no.unsafe() + 1u) != m_Breakpoints.end())
  ------------------
  |  Branch (3383:17): [True: 543, False: 21.4k]
  ------------------
 3384|    543|            {
 3385|    543|                const ImVec2 end =
 3386|    543|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3387|    543|                               line_start_screen_pos.y + m_CharAdvance.y);
 3388|       |
 3389|    543|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::Breakpoint));
 3390|    543|            }
 3391|       |
 3392|       |            // Draw error markers
 3393|  21.9k|            auto error_it = m_ErrorMarkers.find(line_no.unsafe() + 1u);
 3394|  21.9k|            if (error_it != m_ErrorMarkers.end())
  ------------------
  |  Branch (3394:17): [True: 5.83k, False: 16.1k]
  ------------------
 3395|  5.83k|            {
 3396|  5.83k|                const ImVec2 end =
 3397|  5.83k|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3398|  5.83k|                               line_start_screen_pos.y + m_CharAdvance.y);
 3399|  5.83k|                draw_list->AddRectFilled(start, end, GetPaletteForIndex(PaletteIndex::ErrorMarker));
 3400|       |
 3401|  5.83k|                if (GImGui->HoveredWindow == ImGui::GetCurrentWindow() &&
  ------------------
  |  Branch (3401:21): [True: 2, False: 5.82k]
  ------------------
 3402|  5.83k|                    ImGui::IsMouseHoveringRect(line_start_screen_pos, end))
  ------------------
  |  Branch (3402:21): [True: 0, False: 2]
  ------------------
 3403|      0|                {
 3404|      0|                    ImGui::BeginTooltip();
 3405|      0|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.2f, 0.2f, 1.0f));
 3406|      0|                    ImGui::Text("Error at line %u:", error_it->first);
 3407|      0|                    ImGui::PopStyleColor();
 3408|      0|                    ImGui::Separator();
 3409|      0|                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.2f, 1.0f));
 3410|      0|                    ImGui::Text("%s", error_it->second.c_str());
 3411|      0|                    ImGui::PopStyleColor();
 3412|      0|                    ImGui::EndTooltip();
 3413|      0|                }
 3414|  5.83k|            }
 3415|       |
 3416|       |            // Highlight PC line
 3417|  21.9k|            const phi::u64 current_execution_line_number = m_Emulator->GetExecutingLineNumber();
 3418|  21.9k|            if (line_no + 1u == current_execution_line_number)
  ------------------
  |  Branch (3418:17): [True: 0, False: 21.9k]
  ------------------
 3419|      0|            {
 3420|      0|                const ImVec2 end =
 3421|      0|                        ImVec2(line_start_screen_pos.x + content_size.x + 2.0f * scroll_x,
 3422|      0|                               line_start_screen_pos.y + m_CharAdvance.y);
 3423|       |                // TODO: Don't hardcode color
 3424|      0|                draw_list->AddRectFilled(start, end, 0x40ffff00);
 3425|      0|            }
 3426|       |
 3427|       |            // Draw line number (right aligned)
 3428|  21.9k|            snprintf(buffer.data(), buffer.size().unsafe(), "%u  ", line_no.unsafe() + 1u);
 3429|       |
 3430|  21.9k|            const float line_no_width =
 3431|  21.9k|                    ImGui::GetFont()
 3432|  21.9k|                            ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, buffer.data(),
 3433|  21.9k|                                            nullptr, nullptr)
 3434|  21.9k|                            .x;
 3435|  21.9k|            draw_list->AddText(ImVec2(line_start_screen_pos.x + m_TextStart - line_no_width,
 3436|  21.9k|                                      line_start_screen_pos.y),
 3437|  21.9k|                               GetPaletteForIndex(PaletteIndex::LineNumber), buffer.data());
 3438|       |
 3439|  21.9k|            if (m_State.m_CursorPosition.m_Line == line_no)
  ------------------
  |  Branch (3439:17): [True: 16.1k, False: 5.83k]
  ------------------
 3440|  16.1k|            {
 3441|  16.1k|                const phi::boolean focused = ImGui::IsWindowFocused();
 3442|       |
 3443|       |                // Highlight the current line (where the cursor is)
 3444|  16.1k|                if (!HasSelection())
  ------------------
  |  Branch (3444:21): [True: 15.7k, False: 394]
  ------------------
 3445|  15.7k|                {
 3446|  15.7k|                    const ImVec2 end =
 3447|  15.7k|                            ImVec2(start.x + content_size.x + scroll_x, start.y + m_CharAdvance.y);
 3448|  15.7k|                    draw_list->AddRectFilled(
 3449|  15.7k|                            start, end,
 3450|  15.7k|                            GetPaletteForIndex(focused ? PaletteIndex::CurrentLineFill :
  ------------------
  |  Branch (3450:48): [True: 5.72k, False: 10.0k]
  ------------------
 3451|  15.7k|                                                         PaletteIndex::CurrentLineFillInactive));
 3452|  15.7k|                    draw_list->AddRect(start, end,
 3453|  15.7k|                                       GetPaletteForIndex(PaletteIndex::CurrentLineEdge), 1.0f);
 3454|  15.7k|                }
 3455|       |
 3456|       |                // Render the cursor
 3457|  16.1k|                if (focused)
  ------------------
  |  Branch (3457:21): [True: 5.96k, False: 10.1k]
  ------------------
 3458|  5.96k|                {
 3459|  5.96k|                    phi::uint64_t time_end = static_cast<phi::uint64_t>(
 3460|  5.96k|                            std::chrono::duration_cast<std::chrono::milliseconds>(
 3461|  5.96k|                                    std::chrono::system_clock::now().time_since_epoch())
 3462|  5.96k|                                    .count());
 3463|  5.96k|                    phi::uint64_t elapsed = time_end - m_StartTime;
 3464|  5.96k|                    if (elapsed > 400)
  ------------------
  |  Branch (3464:25): [True: 0, False: 5.96k]
  ------------------
 3465|      0|                    {
 3466|      0|                        float    width  = 1.0f;
 3467|      0|                        phi::u32 cindex = GetCharacterIndex(m_State.m_CursorPosition);
 3468|      0|                        float    cx     = TextDistanceToLineStart(m_State.m_CursorPosition);
 3469|       |
 3470|      0|                        if (m_Overwrite && cindex < line.size())
  ------------------
  |  Branch (3470:29): [True: 0, False: 0]
  |  Branch (3470:29): [True: 0, False: 0]
  |  Branch (3470:44): [True: 0, False: 0]
  ------------------
 3471|      0|                        {
 3472|      0|                            char character = static_cast<char>(line[cindex.unsafe()].m_Char);
 3473|      0|                            if (character == '\t')
  ------------------
  |  Branch (3473:33): [True: 0, False: 0]
  ------------------
 3474|      0|                            {
 3475|      0|                                float x = (1.0f +
 3476|      0|                                           std::floor((1.0f + cx) /
 3477|      0|                                                      (float(m_TabSize.unsafe()) * space_size))) *
 3478|      0|                                          (float(m_TabSize.unsafe()) * space_size);
 3479|      0|                                width = x - cx;
 3480|      0|                            }
 3481|      0|                            else
 3482|      0|                            {
 3483|      0|                                phi::array<char, 2u> buffer2;
 3484|      0|                                buffer2[0u] = static_cast<char>(line[cindex.unsafe()].m_Char);
 3485|      0|                                buffer2[1u] = '\0';
 3486|      0|                                width       = ImGui::GetFont()
 3487|      0|                                                ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX,
 3488|      0|                                                                -1.0f, buffer2.data())
 3489|      0|                                                .x;
 3490|      0|                            }
 3491|      0|                        }
 3492|      0|                        const ImVec2 cstart(text_screen_pos.x + cx, line_start_screen_pos.y);
 3493|      0|                        const ImVec2 cend(text_screen_pos.x + cx + width,
 3494|      0|                                          line_start_screen_pos.y + m_CharAdvance.y);
 3495|      0|                        draw_list->AddRectFilled(cstart, cend,
 3496|      0|                                                 GetPaletteForIndex(PaletteIndex::Cursor));
 3497|      0|                        if (elapsed > 800)
  ------------------
  |  Branch (3497:29): [True: 0, False: 0]
  ------------------
 3498|      0|                        {
 3499|      0|                            m_StartTime = time_end;
 3500|      0|                        }
 3501|      0|                    }
 3502|  5.96k|                }
 3503|  16.1k|            }
 3504|       |
 3505|       |            // Render colorized text
 3506|  21.9k|            ImU32  prev_color = line.empty() ? GetPaletteForIndex(PaletteIndex::Default) :
  ------------------
  |  Branch (3506:33): [True: 14.6k, False: 7.32k]
  ------------------
 3507|  21.9k|                                               GetGlyphColor(line[0]);
 3508|  21.9k|            ImVec2 buffer_offset;
 3509|       |
 3510|   376k|            for (phi::usize i{0u}; i < line.size();)
  ------------------
  |  Branch (3510:36): [True: 354k, False: 21.9k]
  ------------------
 3511|   354k|            {
 3512|   354k|                const CodeEditor::Glyph& glyph = line[i.unsafe()];
 3513|   354k|                const ImU32              color = GetGlyphColor(glyph);
 3514|       |
 3515|   354k|                if ((color != prev_color || glyph.m_Char == '\t' || glyph.m_Char == ' ') &&
  ------------------
  |  Branch (3515:22): [True: 59.2k, False: 295k]
  |  Branch (3515:45): [True: 6.49k, False: 289k]
  |  Branch (3515:69): [True: 3.98k, False: 285k]
  ------------------
 3516|   354k|                    !m_LineBuffer.empty())
  ------------------
  |  Branch (3516:21): [True: 59.0k, False: 10.7k]
  ------------------
 3517|  59.0k|                {
 3518|  59.0k|                    const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3519|  59.0k|                                            text_screen_pos.y + buffer_offset.y);
 3520|  59.0k|                    draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3521|  59.0k|                    const ImVec2 text_size =
 3522|  59.0k|                            ImGui::GetFont()->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f,
 3523|  59.0k|                                                            m_LineBuffer.c_str(), nullptr, nullptr);
 3524|  59.0k|                    buffer_offset.x += text_size.x;
 3525|  59.0k|                    m_LineBuffer.clear();
 3526|  59.0k|                }
 3527|   354k|                prev_color = color;
 3528|       |
 3529|   354k|                if (glyph.m_Char == '\t')
  ------------------
  |  Branch (3529:21): [True: 8.77k, False: 346k]
  ------------------
 3530|  8.77k|                {
 3531|  8.77k|                    const float old_x = buffer_offset.x;
 3532|  8.77k|                    buffer_offset.x =
 3533|  8.77k|                            (1.0f + std::floor((1.0f + buffer_offset.x) /
 3534|  8.77k|                                               (float(m_TabSize.unsafe()) * space_size))) *
 3535|  8.77k|                            (float(m_TabSize.unsafe()) * space_size);
 3536|  8.77k|                    ++i;
 3537|       |
 3538|  8.77k|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3538:25): [True: 4.20k, False: 4.56k]
  ------------------
 3539|  4.20k|                    {
 3540|  4.20k|                        const float font_size =
 3541|  4.20k|                                ImGui::GetFont()
 3542|  4.20k|                                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#",
 3543|  4.20k|                                                        nullptr, nullptr)
 3544|  4.20k|                                        .x;
 3545|       |
 3546|  4.20k|                        const float  s  = ImGui::GetFontSize();
 3547|  4.20k|                        const float  x1 = text_screen_pos.x + old_x + 1.0f;
 3548|  4.20k|                        const float  x2 = text_screen_pos.x + buffer_offset.x - 1.0f;
 3549|  4.20k|                        const float  y  = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3550|  4.20k|                        const ImVec2 p1(x1, y);
 3551|  4.20k|                        const ImVec2 p2(x2, y);
 3552|  4.20k|                        const ImVec2 p3(x2 - font_size * 0.2f, y - font_size * 0.2f);
 3553|  4.20k|                        const ImVec2 p4(x2 - font_size * 0.2f, y + font_size * 0.2f);
 3554|       |
 3555|  4.20k|                        PHI_MSVC_SUPPRESS_WARNING_WITH_PUSH(5264) // Unused const variable
 3556|       |
 3557|  4.20k|                        static constexpr const ImU32 whitespace_color{0x90909090};
 3558|       |
 3559|  4.20k|                        PHI_MSVC_SUPPRESS_WARNING_POP()
 3560|       |
 3561|  4.20k|                        draw_list->AddLine(p1, p2, whitespace_color);
 3562|  4.20k|                        draw_list->AddLine(p2, p3, whitespace_color);
 3563|  4.20k|                        draw_list->AddLine(p2, p4, whitespace_color);
 3564|  4.20k|                    }
 3565|  8.77k|                }
 3566|   346k|                else if (glyph.m_Char == ' ')
  ------------------
  |  Branch (3566:26): [True: 3.98k, False: 342k]
  ------------------
 3567|  3.98k|                {
 3568|  3.98k|                    if (m_ShowWhitespaces)
  ------------------
  |  Branch (3568:25): [True: 3.12k, False: 860]
  ------------------
 3569|  3.12k|                    {
 3570|  3.12k|                        const float s = ImGui::GetFontSize();
 3571|  3.12k|                        const float x = text_screen_pos.x + buffer_offset.x + space_size * 0.5f;
 3572|  3.12k|                        const float y = text_screen_pos.y + buffer_offset.y + s * 0.5f;
 3573|  3.12k|                        draw_list->AddCircleFilled(ImVec2(x, y), 1.5f, 0x80808080, 4);
 3574|  3.12k|                    }
 3575|  3.98k|                    buffer_offset.x += space_size;
 3576|  3.98k|                    i++;
 3577|  3.98k|                }
 3578|   342k|                else
 3579|   342k|                {
 3580|   792k|                    for (phi::u8_fast length = UTF8CharLength(glyph.m_Char); length > 0u;
  ------------------
  |  Branch (3580:78): [True: 450k, False: 342k]
  ------------------
 3581|   450k|                         ++i, --length)
 3582|   450k|                    {
 3583|   450k|                        m_LineBuffer.push_back(static_cast<char>(line[i.unsafe()].m_Char));
 3584|   450k|                    }
 3585|   342k|                }
 3586|   354k|                ++column_no;
 3587|   354k|            }
 3588|  21.9k|            if (!m_LineBuffer.empty())
  ------------------
  |  Branch (3588:17): [True: 5.17k, False: 16.8k]
  ------------------
 3589|  5.17k|            {
 3590|  5.17k|                const ImVec2 new_offset(text_screen_pos.x + buffer_offset.x,
 3591|  5.17k|                                        text_screen_pos.y + buffer_offset.y);
 3592|  5.17k|                draw_list->AddText(new_offset, prev_color, m_LineBuffer.c_str());
 3593|  5.17k|                m_LineBuffer.clear();
 3594|  5.17k|            }
 3595|       |
 3596|  21.9k|            ++line_no;
 3597|  21.9k|        }
 3598|       |
 3599|       |        // Draw a tooltip on known identifiers/preprocessor symbols
 3600|  16.9k|        if (ImGui::IsMousePosValid())
  ------------------
  |  Branch (3600:13): [True: 13.2k, False: 3.70k]
  ------------------
 3601|  13.2k|        {
 3602|  13.2k|            std::string id = GetWordAt(ScreenPosToCoordinates(ImGui::GetMousePos()));
 3603|  13.2k|            if (!id.empty())
  ------------------
  |  Branch (3603:17): [True: 23, False: 13.2k]
  ------------------
 3604|     23|            {
 3605|       |                /*
 3606|       |                    auto it = m_LanguageDefinition.mIdentifiers.find(id);
 3607|       |                    if (it != m_LanguageDefinition.mIdentifiers.end())
 3608|       |                    {
 3609|       |                        ImGui::BeginTooltip();
 3610|       |                        ImGui::TextUnformatted(it->second.m_Declaration.c_str());
 3611|       |                        ImGui::EndTooltip();
 3612|       |                    }
 3613|       |                    else
 3614|       |                    {
 3615|       |                        auto pi = m_LanguageDefinition.mPreprocIdentifiers.find(id);
 3616|       |                        if (pi != m_LanguageDefinition.mPreprocIdentifiers.end())
 3617|       |                        {
 3618|       |                            ImGui::BeginTooltip();
 3619|       |                            ImGui::TextUnformatted(pi->second.m_Declaration.c_str());
 3620|       |                            ImGui::EndTooltip();
 3621|       |                        }
 3622|       |                    }
 3623|       |                    */
 3624|     23|            }
 3625|  13.2k|        }
 3626|       |
 3627|  16.9k|        ImGui::Dummy(ImVec2((longest + 2), static_cast<float>(m_Lines.size()) * m_CharAdvance.y));
 3628|       |
 3629|  16.9k|        if (m_ScrollToCursor)
  ------------------
  |  Branch (3629:13): [True: 4.52k, False: 12.4k]
  ------------------
 3630|  4.52k|        {
 3631|  4.52k|            ScrollToCursor();
 3632|  4.52k|            ImGui::SetWindowFocus();
 3633|  4.52k|            m_ScrollToCursor = false;
 3634|  4.52k|        }
 3635|  16.9k|    }
_ZN6dlxemu10CodeEditor13ColorizeTokenERKN3dlx5TokenE:
 3638|   139k|    {
 3639|   139k|        PaletteIndex palette_index{PaletteIndex::Default};
 3640|       |
 3641|       |        // Determine palette color
 3642|   139k|        switch (token.GetType())
 3643|   139k|        {
 3644|    163|            case dlx::Token::Type::Comment:
  ------------------
  |  Branch (3644:13): [True: 163, False: 138k]
  ------------------
 3645|    163|                palette_index = PaletteIndex::Comment;
 3646|    163|                break;
 3647|     80|            case dlx::Token::Type::ImmediateInteger:
  ------------------
  |  Branch (3647:13): [True: 80, False: 139k]
  ------------------
 3648|  25.3k|            case dlx::Token::Type::IntegerLiteral:
  ------------------
  |  Branch (3648:13): [True: 25.2k, False: 113k]
  ------------------
 3649|  25.3k|                palette_index = PaletteIndex::IntegerLiteral;
 3650|  25.3k|                break;
 3651|  3.75k|            case dlx::Token::Type::OpCode:
  ------------------
  |  Branch (3651:13): [True: 3.75k, False: 135k]
  ------------------
 3652|  3.75k|                palette_index = PaletteIndex::OpCode;
 3653|  3.75k|                break;
 3654|     81|            case dlx::Token::Type::RegisterFloat:
  ------------------
  |  Branch (3654:13): [True: 81, False: 139k]
  ------------------
 3655|     82|            case dlx::Token::Type::RegisterInt:
  ------------------
  |  Branch (3655:13): [True: 1, False: 139k]
  ------------------
 3656|     82|            case dlx::Token::Type::RegisterStatus:
  ------------------
  |  Branch (3656:13): [True: 0, False: 139k]
  ------------------
 3657|     82|                palette_index = PaletteIndex::Register;
 3658|     82|                break;
 3659|  4.04k|            case dlx::Token::Type::NewLine:
  ------------------
  |  Branch (3659:13): [True: 4.04k, False: 135k]
  ------------------
 3660|  4.04k|                return;
 3661|   105k|            default:
  ------------------
  |  Branch (3661:13): [True: 105k, False: 33.3k]
  ------------------
 3662|   105k|                break;
 3663|   139k|        }
 3664|       |
 3665|   135k|        PHI_ASSERT(token.GetLineNumber() - 1u < m_Lines.size());
 3666|   135k|        Line& line = m_Lines[(token.GetLineNumber() - 1u).unsafe()];
 3667|       |
 3668|   135k|        for (phi::u64 index{token.GetColumn() - 1u};
 3669|   557k|             index < token.GetColumn() + token.GetLength() - 1u; ++index)
  ------------------
  |  Branch (3669:14): [True: 422k, False: 135k]
  ------------------
 3670|   422k|        {
 3671|   422k|            PHI_ASSERT(index < line.size());
 3672|   422k|            line[index.unsafe()].m_ColorIndex = palette_index;
 3673|   422k|        }
 3674|   135k|    }
_ZN6dlxemu10CodeEditor16ColorizeInternalEv:
 3677|  3.55k|    {
 3678|  3.55k|        const dlx::ParsedProgram& program = m_Emulator->GetProgram();
 3679|       |
 3680|  3.55k|        for (const dlx::Token& token : program.m_Tokens)
  ------------------
  |  Branch (3680:38): [True: 139k, False: 3.55k]
  ------------------
 3681|   139k|        {
 3682|   139k|            ColorizeToken(token);
 3683|   139k|        }
 3684|  3.55k|    }
_ZN6dlxemu10CodeEditor10ResetStateEv:
 3687|  2.24k|    {
 3688|  2.24k|        m_State.m_CursorPosition = Coordinates(0u, 0u);
 3689|  2.24k|        m_State.m_SelectionStart = Coordinates(0u, 0u);
 3690|  2.24k|        m_State.m_SelectionEnd   = Coordinates(0u, 0u);
 3691|       |
 3692|       |        // Clear breakpoints and markers
 3693|  2.24k|        ClearBreakPoints();
 3694|  2.24k|        ClearErrorMarkers();
 3695|  2.24k|    }
_ZN6dlxemu10CodeEditor21FixSelectionAfterMoveEN3phi7booleanENS0_11CoordinatesE:
 3698|  11.5k|    {
 3699|  11.5k|        if (select)
  ------------------
  |  Branch (3699:13): [True: 5.75k, False: 5.76k]
  ------------------
 3700|  5.75k|        {
 3701|  5.75k|            if (old_pos == m_InteractiveStart)
  ------------------
  |  Branch (3701:17): [True: 1.63k, False: 4.11k]
  ------------------
 3702|  1.63k|            {
 3703|  1.63k|                m_InteractiveStart = m_State.m_CursorPosition;
 3704|  1.63k|            }
 3705|  4.11k|            else if (old_pos == m_InteractiveEnd)
  ------------------
  |  Branch (3705:22): [True: 341, False: 3.77k]
  ------------------
 3706|    341|            {
 3707|    341|                m_InteractiveEnd = m_State.m_CursorPosition;
 3708|    341|            }
 3709|  3.77k|            else
 3710|  3.77k|            {
 3711|  3.77k|                m_InteractiveStart = m_State.m_CursorPosition;
 3712|  3.77k|                m_InteractiveEnd   = old_pos;
 3713|  3.77k|            }
 3714|  5.75k|        }
 3715|  5.76k|        else
 3716|  5.76k|        {
 3717|  5.76k|            m_InteractiveStart = m_InteractiveEnd = m_State.m_CursorPosition;
 3718|  5.76k|        }
 3719|       |
 3720|  11.5k|        SetSelection(m_InteractiveStart, m_InteractiveEnd);
 3721|  11.5k|        EnsureCursorVisible();
 3722|  11.5k|    }
_ZNK6dlxemu10CodeEditor12GetTabSizeAtEN3phi7integerIjEE:
 3725|  4.00M|    {
 3726|  4.00M|        return static_cast<phi::uint_fast8_t>(m_TabSize.unsafe() -
 3727|  4.00M|                                              (column.unsafe() % m_TabSize.unsafe()));
 3728|  4.00M|    }
_ZNK6dlxemu10CodeEditor18GetPaletteForIndexENS0_12PaletteIndexE:
 3731|   514k|    {
 3732|   514k|        PHI_ASSERT(index != PaletteIndex::Max);
 3733|       |
 3734|   514k|        const phi::size_t int_value = static_cast<phi::size_t>(index);
 3735|   514k|        PHI_ASSERT(int_value < m_Palette.size());
 3736|       |
 3737|   514k|        return m_Palette[int_value];
 3738|   514k|    }
_ZN6dlxemu10CodeEditor18ComputeCharAdvanceEv:
 3741|  16.9k|    {
 3742|       |        // Compute m_CharAdvance regarding to scaled font size (Ctrl + mouse wheel)
 3743|  16.9k|        const float font_size =
 3744|  16.9k|                ImGui::GetFont()
 3745|  16.9k|                        ->CalcTextSizeA(ImGui::GetFontSize(), FLT_MAX, -1.0f, "#", nullptr, nullptr)
 3746|  16.9k|                        .x;
 3747|  16.9k|        m_CharAdvance = ImVec2(font_size, ImGui::GetTextLineHeightWithSpacing() * m_LineSpacing);
 3748|       |
 3749|  16.9k|        PHI_ASSERT(m_CharAdvance.x != 0.0f);
 3750|  16.9k|        PHI_ASSERT(m_CharAdvance.y != 0.0f);
 3751|  16.9k|    }
CodeEditor.cpp:_ZL19IsValidUTF8SequenceN3phi7integerIjEE:
  183|  58.8k|{
  184|  58.8k|    return !(character >= 0xdc00u && character < 0xe000u);
  ------------------
  |  Branch (184:14): [True: 5.33k, False: 53.4k]
  |  Branch (184:38): [True: 26, False: 5.31k]
  ------------------
  185|  58.8k|}
CodeEditor.cpp:_ZL13IsUTFSequenceh:
   92|  7.74M|{
   93|  7.74M|    return IsUTFSequence(static_cast<char>(character));
   94|  7.74M|}
CodeEditor.cpp:_ZL13IsUTFSequencec:
   87|  7.74M|{
   88|  7.74M|    return (character & 0xC0) == 0x80;
   89|  7.74M|}
CodeEditor.cpp:_ZL14UTF8CharLengthh:
  131|  1.91G|{
  132|  1.91G|    return UTF8CharLength(static_cast<char>(character));
  133|  1.91G|}
CodeEditor.cpp:_ZL14UTF8CharLengthc:
  101|  4.41G|{
  102|  4.41G|    if ((character & 0xFE) == 0xFC)
  ------------------
  |  Branch (102:9): [True: 0, False: 4.41G]
  ------------------
  103|      0|    {
  104|      0|        return 6_u8;
  105|      0|    }
  106|       |
  107|  4.41G|    if ((character & 0xFC) == 0xF8)
  ------------------
  |  Branch (107:9): [True: 0, False: 4.41G]
  ------------------
  108|      0|    {
  109|      0|        return 5_u8;
  110|      0|    }
  111|       |
  112|  4.41G|    if ((character & 0xF8) == 0xF0)
  ------------------
  |  Branch (112:9): [True: 97.5M, False: 4.31G]
  ------------------
  113|  97.5M|    {
  114|  97.5M|        return 4_u8;
  115|  97.5M|    }
  116|       |
  117|  4.31G|    if ((character & 0xF0) == 0xE0)
  ------------------
  |  Branch (117:9): [True: 2.91G, False: 1.40G]
  ------------------
  118|  2.91G|    {
  119|  2.91G|        return 3_u8;
  120|  2.91G|    }
  121|       |
  122|  1.40G|    if ((character & 0xE0) == 0xC0)
  ------------------
  |  Branch (122:9): [True: 324M, False: 1.07G]
  ------------------
  123|   324M|    {
  124|   324M|        return 2_u8;
  125|   324M|    }
  126|       |
  127|  1.07G|    return 1_u8;
  128|  1.40G|}
CodeEditor.cpp:_ZL16ImTextCharToUtf8RN3phi5arrayIcLm5EEENS_7integerIjEE:
  138|  16.9k|{
  139|  16.9k|    if (character < 0x80u)
  ------------------
  |  Branch (139:9): [True: 10.2k, False: 6.72k]
  ------------------
  140|  10.2k|    {
  141|  10.2k|        buffer[0u] = static_cast<char>(character.unsafe());
  142|  10.2k|        buffer[1u] = '\0';
  143|  10.2k|        return 1_u8;
  144|  10.2k|    }
  145|  6.72k|    if (character < 0x800u)
  ------------------
  |  Branch (145:9): [True: 1.29k, False: 5.43k]
  ------------------
  146|  1.29k|    {
  147|  1.29k|        buffer[0u] = static_cast<char>(0xc0 + (character.unsafe() >> 6));
  148|  1.29k|        buffer[1u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  149|  1.29k|        buffer[2u] = '\0';
  150|       |
  151|  1.29k|        return 2_u8;
  152|  1.29k|    }
  153|  5.43k|    if (character >= 0xdc00u && character < 0xe000u)
  ------------------
  |  Branch (153:9): [True: 2.65k, False: 2.77k]
  |  Branch (153:9): [True: 0, False: 5.43k]
  |  Branch (153:33): [True: 0, False: 2.65k]
  ------------------
  154|      0|    {
  155|      0|        buffer[0u] = '\0';
  156|      0|        return 0_u8;
  157|      0|    }
  158|       |
  159|  5.43k|    if (character >= 0xd800u && character < 0xdc00u)
  ------------------
  |  Branch (159:9): [True: 3.24k, False: 2.18k]
  |  Branch (159:9): [True: 589, False: 4.84k]
  |  Branch (159:33): [True: 589, False: 2.65k]
  ------------------
  160|    589|    {
  161|    589|        buffer[0u] = static_cast<char>(0xf0 + (character.unsafe() >> 18));
  162|    589|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 12) & 0x3f));
  163|    589|        buffer[2u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  164|    589|        buffer[3u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  165|    589|        buffer[4u] = '\0';
  166|       |
  167|    589|        return 4_u8;
  168|    589|    }
  169|       |    //else if (character < 0x10000)
  170|  4.84k|    {
  171|  4.84k|        PHI_ASSERT(character.unsafe() < 0x10000);
  172|       |
  173|  4.84k|        buffer[0u] = static_cast<char>(0xe0 + (character.unsafe() >> 12));
  174|  4.84k|        buffer[1u] = static_cast<char>(0x80 + ((character.unsafe() >> 6) & 0x3f));
  175|  4.84k|        buffer[2u] = static_cast<char>(0x80 + (character.unsafe() & 0x3f));
  176|  4.84k|        buffer[3u] = '\0';
  177|       |
  178|  4.84k|        return 3_u8;
  179|  5.43k|    }
  180|  5.43k|}

_ZN6dlxemu8EmulatorC2Ev:
   46|  9.87k|    {}
_ZNK6dlxemu8Emulator10GetProgramEv:
  186|  3.55k|    {
  187|  3.55k|        return m_DLXProgram;
  188|  3.55k|    }
_ZN6dlxemu8Emulator12ParseProgramEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  191|  3.55k|    {
  192|  3.55k|        m_DLXProgram = dlx::Parser::Parse(source);
  193|       |
  194|  3.55k|        if (m_DLXProgram.m_ParseErrors.empty())
  ------------------
  |  Branch (194:13): [True: 668, False: 2.89k]
  ------------------
  195|    668|        {
  196|    668|            m_Processor.LoadProgram(m_DLXProgram);
  197|    668|        }
  198|  3.55k|    }
_ZNK6dlxemu8Emulator22GetExecutingLineNumberEv:
  230|  21.9k|    {
  231|  21.9k|        if (m_DLXProgram.IsValid() && !m_Processor.IsHalted() &&
  ------------------
  |  Branch (231:13): [True: 64, False: 21.9k]
  |  Branch (231:13): [True: 0, False: 21.9k]
  |  Branch (231:39): [True: 64, False: 0]
  ------------------
  232|  21.9k|            m_CurrentExecutionMode != ExecutionMode::None)
  ------------------
  |  Branch (232:13): [True: 0, False: 64]
  ------------------
  233|      0|        {
  234|      0|            PHI_ASSERT(m_Processor.GetProgramCounter() < m_DLXProgram.m_Instructions.size());
  235|       |
  236|      0|            const auto& current_instruction =
  237|      0|                    m_DLXProgram.m_Instructions.at(m_Processor.GetProgramCounter().unsafe());
  238|       |
  239|      0|            return current_instruction.GetSourceLine();
  240|      0|        }
  241|       |
  242|       |        // Not valid
  243|  21.9k|        return 0u;
  244|  21.9k|    }

_ZN6dlxemu12MemoryViewerC2EPNS_8EmulatorE:
   13|  9.87k|    {}

_ZN6dlxemu14RegisterViewerC2EPNS_8EmulatorE:
   19|  9.87k|    {}

_ZN6dlxemu6WindowD2Ev:
   41|  9.87k|    {
   42|  9.87k|        Shutdown();
   43|  9.87k|    }
_ZN6dlxemu6Window8ShutdownEv:
  113|  9.87k|    {
  114|  9.87k|        if (imgui_initialized)
  ------------------
  |  Branch (114:13): [True: 0, False: 9.87k]
  ------------------
  115|      0|        {
  116|      0|            ShutdownImGui();
  117|      0|        }
  118|       |
  119|  9.87k|        if (m_Window != nullptr)
  ------------------
  |  Branch (119:13): [True: 0, False: 9.87k]
  ------------------
  120|      0|        {
  121|      0|            glfwDestroyWindow(m_Window);
  122|      0|        }
  123|       |
  124|  9.87k|        if (glfw_initialized)
  ------------------
  |  Branch (124:13): [True: 0, False: 9.87k]
  ------------------
  125|      0|        {
  126|      0|            glfwTerminate();
  127|      0|        }
  128|  9.87k|    }

_ZNK3dlx15InstructionInfo15GetArgumentTypeEN3phi7integerIhEE:
  173|  1.81k|        {
  174|  1.81k|            PHI_ASSERT(index < 3u);
  175|       |
  176|  1.81k|            switch (index.unsafe())
  177|  1.81k|            {
  178|    815|                case 0:
  ------------------
  |  Branch (178:17): [True: 815, False: 1.00k]
  ------------------
  179|    815|                    return m_Arg1Type;
  180|       |
  181|    502|                case 1:
  ------------------
  |  Branch (181:17): [True: 502, False: 1.31k]
  ------------------
  182|    502|                    return m_Arg2Type;
  183|       |
  184|    502|                case 2:
  ------------------
  |  Branch (184:17): [True: 502, False: 1.31k]
  ------------------
  185|    502|                    return m_Arg3Type;
  186|       |
  187|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  188|      0|                default:
  ------------------
  |  Branch (188:17): [True: 0, False: 1.81k]
  ------------------
  189|      0|                    PHI_ASSERT_NOT_REACHED();
  190|      0|                    return m_Arg1Type;
  191|  1.81k|#endif
  192|  1.81k|            }
  193|  1.81k|        }
_ZNK3dlx15InstructionInfo28GetNumberOfRequiredArgumentsEv:
  199|    502|        {
  200|    502|            phi::u8 number_of_argument_required = static_cast<phi::uint8_t>(0u);
  201|       |
  202|       |            // Count the number of argument we need
  203|    502|            if (m_Arg1Type != ArgumentType::None)
  ------------------
  |  Branch (203:17): [True: 502, False: 0]
  ------------------
  204|    502|            {
  205|    502|                number_of_argument_required += static_cast<phi::uint8_t>(1u);
  206|    502|            }
  207|    502|            if (m_Arg2Type != ArgumentType::None)
  ------------------
  |  Branch (207:17): [True: 38, False: 464]
  ------------------
  208|     38|            {
  209|     38|                number_of_argument_required += static_cast<phi::uint8_t>(1u);
  210|     38|            }
  211|    502|            if (m_Arg3Type != ArgumentType::None)
  ------------------
  |  Branch (211:17): [True: 5, False: 497]
  ------------------
  212|      5|            {
  213|      5|                number_of_argument_required += static_cast<phi::uint8_t>(1u);
  214|      5|            }
  215|       |
  216|    502|            return number_of_argument_required;
  217|    502|        }
_ZNK3dlx15InstructionInfo11GetExecutorEv:
  225|    502|        {
  226|    502|            return m_Executor;
  227|    502|        }
_ZN3dlxanENS_12ArgumentTypeES0_:
   37|    256|    {
   38|    256|        using underlying_t = phi::underlying_type_t<ArgumentType>;
   39|       |
   40|    256|        return static_cast<ArgumentType>(static_cast<underlying_t>(lhs) &
   41|    256|                                         static_cast<underlying_t>(rhs));
   42|    256|    }
_ZN3dlx20ArgumentTypeIncludesENS_12ArgumentTypeES0_:
   54|    256|    {
   55|    256|        using underlying_t = std::underlying_type_t<ArgumentType>;
   56|       |
   57|    256|        return static_cast<underlying_t>(type & test) != 0;
   58|    256|    }
_ZN3dlx9enum_nameINS_12ArgumentTypeEEEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEET_:
   66|     18|    {
   67|     18|        switch (phi::to_underlying(value))
   68|     18|        {
   69|      0|#define DLX_ENUM_ARGUMENT_TYPE_IMPL(name, enum_value)                                              \
   70|      0|    case enum_value:                                                                               \
   71|      0|        return #name;
   72|       |
   73|      0|            DLX_ENUM_ARGUMENT_TYPE
  ------------------
  |  |   21|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(Unknown, 0)                                                        \
  |  |  ------------------
  |  |  |  |   70|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 0, False: 18]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|        return #name;
  |  |  ------------------
  |  |   22|      0|    DLX_ENUM_ARGUMENT_TYPE_IMPL(None, 1)                                                           \
  |  |  ------------------
  |  |  |  |   70|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 0, False: 18]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|        return #name;
  |  |  ------------------
  |  |   23|      1|    DLX_ENUM_ARGUMENT_TYPE_IMPL(IntRegister, 2)                                                    \
  |  |  ------------------
  |  |  |  |   70|      1|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 1, False: 17]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|        return #name;
  |  |  ------------------
  |  |   24|      1|    DLX_ENUM_ARGUMENT_TYPE_IMPL(FloatRegister, 4)                                                  \
  |  |  ------------------
  |  |  |  |   70|      1|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 1, False: 17]
  |  |  |  |  ------------------
  |  |  |  |   71|      1|        return #name;
  |  |  ------------------
  |  |   25|      1|    DLX_ENUM_ARGUMENT_TYPE_IMPL(ImmediateInteger, 8)                                               \
  |  |  ------------------
  |  |  |  |   70|      0|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 0, False: 18]
  |  |  |  |  ------------------
  |  |  |  |   71|      0|        return #name;
  |  |  ------------------
  |  |   26|      9|    DLX_ENUM_ARGUMENT_TYPE_IMPL(Label, 16)                                                         \
  |  |  ------------------
  |  |  |  |   70|      9|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 9, False: 9]
  |  |  |  |  ------------------
  |  |  |  |   71|      9|        return #name;
  |  |  ------------------
  |  |   27|      9|    DLX_ENUM_ARGUMENT_TYPE_IMPL(AddressDisplacement, 32)
  |  |  ------------------
  |  |  |  |   70|      7|    case enum_value:                                                                               \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (70:5): [True: 7, False: 11]
  |  |  |  |  ------------------
  |  |  |  |   71|      7|        return #name;
  |  |  ------------------
  ------------------
   74|       |
   75|      0|#undef DLX_ENUM_ARGUMENT_TYPE_IMPL
   76|       |
   77|       |            // Explicitly handle the combine cases
   78|      0|            case phi::to_underlying(ArgumentType::ImmediateInteger |
  ------------------
  |  Branch (78:13): [True: 0, False: 18]
  ------------------
   79|      0|                                    ArgumentType::AddressDisplacement):
   80|      0|                return "ImmediateInteger/AddressDisplacement";
   81|       |
   82|      0|            default:
  ------------------
  |  Branch (82:13): [True: 0, False: 18]
  ------------------
   83|      0|                PHI_ASSERT_NOT_REACHED();
   84|     18|        }
   85|     18|    }

_ZN3dlx11MemoryBlock10MemoryByteC2Ev:
   17|  9.87M|            {}

_ZN3dlx20IsReservedIdentifierEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   30|  21.2k|    {
   31|  21.2k|        if (StringToIntRegister(token) != IntRegisterID::None)
  ------------------
  |  Branch (31:13): [True: 2.60k, False: 18.5k]
  ------------------
   32|  2.60k|        {
   33|  2.60k|            return true;
   34|  2.60k|        }
   35|       |
   36|  18.5k|        if (StringToFloatRegister(token) != FloatRegisterID::None)
  ------------------
  |  Branch (36:13): [True: 80, False: 18.5k]
  ------------------
   37|     80|        {
   38|     80|            return true;
   39|     80|        }
   40|       |
   41|  18.5k|        if (StringToOpCode(token) != OpCode::NONE)
  ------------------
  |  Branch (41:13): [True: 691, False: 17.8k]
  ------------------
   42|    691|        {
   43|    691|            return true;
   44|    691|        }
   45|       |
   46|  17.8k|        if (IsFPSR(token))
  ------------------
  |  Branch (46:13): [True: 0, False: 17.8k]
  ------------------
   47|      0|        {
   48|      0|            return true;
   49|      0|        }
   50|       |
   51|  17.8k|        return false;
   52|  17.8k|    }
_ZN3dlx17IsValidIdentifierEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   55|  17.8k|    {
   56|  17.8k|        if (token.is_empty())
  ------------------
  |  Branch (56:13): [True: 0, False: 17.8k]
  ------------------
   57|      0|        {
   58|      0|            return false;
   59|      0|        }
   60|       |
   61|  17.8k|        const char first_char = token.at(0u);
   62|       |
   63|  17.8k|        if (token.length() == 1u)
  ------------------
  |  Branch (63:13): [True: 5.04k, False: 12.7k]
  ------------------
   64|  5.04k|        {
   65|  5.04k|            return phi::is_alpha(first_char);
   66|  5.04k|        }
   67|       |
   68|  12.7k|        phi::boolean just_under_scores = (first_char == '_');
   69|  12.7k|        if (!phi::is_alpha(first_char) && (first_char != '_'))
  ------------------
  |  Branch (69:13): [True: 3.27k, False: 9.50k]
  |  Branch (69:13): [True: 3.24k, False: 9.53k]
  |  Branch (69:43): [True: 3.24k, False: 33]
  ------------------
   70|  3.24k|        {
   71|  3.24k|            return false;
   72|  3.24k|        }
   73|       |
   74|  39.0k|        for (phi::size_t index{1u}; index < token.length(); ++index)
  ------------------
  |  Branch (74:37): [True: 32.8k, False: 6.17k]
  ------------------
   75|  32.8k|        {
   76|  32.8k|            const char c{token.at(index)};
   77|       |
   78|  32.8k|            if (phi::is_alpha_numeric(c))
  ------------------
  |  Branch (78:17): [True: 29.3k, False: 3.47k]
  ------------------
   79|  29.3k|            {
   80|  29.3k|                just_under_scores = false;
   81|  29.3k|            }
   82|  3.47k|            else if (c == '_')
  ------------------
  |  Branch (82:22): [True: 124, False: 3.35k]
  ------------------
   83|    124|            {
   84|    124|                continue;
   85|    124|            }
   86|  3.35k|            else
   87|  3.35k|            {
   88|  3.35k|                return false;
   89|  3.35k|            }
   90|  32.8k|        }
   91|       |
   92|  6.17k|        return !just_under_scores;
   93|  9.53k|    }
_ZN3dlx11ParseNumberEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   98|  79.5k|    {
   99|  79.5k|        if (token.is_empty())
  ------------------
  |  Branch (99:13): [True: 0, False: 79.5k]
  ------------------
  100|      0|        {
  101|      0|            return {};
  102|      0|        }
  103|       |
  104|  79.5k|        if (token.length() == 1u)
  ------------------
  |  Branch (104:13): [True: 23.9k, False: 55.6k]
  ------------------
  105|  23.9k|        {
  106|  23.9k|            if (phi::is_digit(token.at(0u)))
  ------------------
  |  Branch (106:17): [True: 18.4k, False: 5.50k]
  ------------------
  107|  18.4k|            {
  108|  18.4k|                return static_cast<phi::int16_t>(token.at(0u) - '0');
  109|  18.4k|            }
  110|       |
  111|  5.50k|            return {};
  112|  23.9k|        }
  113|       |
  114|       |        // Disallow trailing separators
  115|  55.6k|        if (token.at(token.length() - 1u) == '\'')
  ------------------
  |  Branch (115:13): [True: 4, False: 55.5k]
  ------------------
  116|      4|        {
  117|      4|            return {};
  118|      4|        }
  119|       |
  120|  55.5k|        phi::int32_t number{0};
  121|  55.5k|        phi::boolean is_negative{false};
  122|  55.5k|        phi::boolean starts_with_zero{false};
  123|  55.5k|        phi::boolean parsing_binary{false};
  124|  55.5k|        phi::boolean parsing_octal{false};
  125|  55.5k|        phi::boolean parsing_hexadecimal{false};
  126|  55.5k|        phi::boolean parsed_something{false};
  127|  55.5k|        phi::boolean parsed_separator{false};
  128|       |
  129|       |        // TODO: Move x'th character checks out of the for loop
  130|       |
  131|   110k|        for (phi::size_t index{0u}; index < token.length(); ++index)
  ------------------
  |  Branch (131:37): [True: 103k, False: 7.26k]
  ------------------
  132|   103k|        {
  133|   103k|            const char c{token.at(index)};
  134|       |
  135|       |            // First character
  136|   103k|            if (index == 0u)
  ------------------
  |  Branch (136:17): [True: 55.5k, False: 47.6k]
  ------------------
  137|  55.5k|            {
  138|  55.5k|                if (c == '+')
  ------------------
  |  Branch (138:21): [True: 1.91k, False: 53.6k]
  ------------------
  139|  1.91k|                {
  140|  1.91k|                    continue;
  141|  1.91k|                }
  142|       |
  143|  53.6k|                if (c == '-')
  ------------------
  |  Branch (143:21): [True: 324, False: 53.3k]
  ------------------
  144|    324|                {
  145|    324|                    is_negative = true;
  146|    324|                    continue;
  147|    324|                }
  148|       |
  149|  53.3k|                if (c == '0')
  ------------------
  |  Branch (149:21): [True: 5.55k, False: 47.8k]
  ------------------
  150|  5.55k|                {
  151|  5.55k|                    starts_with_zero = true;
  152|  5.55k|                    continue;
  153|  5.55k|                }
  154|       |
  155|  47.8k|                if (c == '\'')
  ------------------
  |  Branch (155:21): [True: 149, False: 47.6k]
  ------------------
  156|    149|                {
  157|    149|                    return {};
  158|    149|                }
  159|  47.8k|            }
  160|       |
  161|       |            // Second character
  162|  95.3k|            if (index == 1u)
  ------------------
  |  Branch (162:17): [True: 15.3k, False: 79.9k]
  ------------------
  163|  15.3k|            {
  164|  15.3k|                if (starts_with_zero)
  ------------------
  |  Branch (164:21): [True: 5.55k, False: 9.78k]
  ------------------
  165|  5.55k|                {
  166|       |                    // Binary
  167|  5.55k|                    if (c == 'b' || c == 'B')
  ------------------
  |  Branch (167:25): [True: 12, False: 5.54k]
  |  Branch (167:37): [True: 29, False: 5.51k]
  ------------------
  168|     41|                    {
  169|     41|                        parsing_binary = true;
  170|     41|                        continue;
  171|     41|                    }
  172|       |
  173|       |                    // Hexadecimal
  174|  5.51k|                    if (c == 'x' || c == 'X')
  ------------------
  |  Branch (174:25): [True: 0, False: 5.51k]
  |  Branch (174:37): [True: 4, False: 5.50k]
  ------------------
  175|      4|                    {
  176|      4|                        parsing_hexadecimal = true;
  177|      4|                        continue;
  178|      4|                    }
  179|       |
  180|       |                    // Octal
  181|  5.50k|                    parsing_octal = true;
  182|  5.50k|                }
  183|  15.3k|            }
  184|       |
  185|       |            // Handle separators
  186|  95.2k|            if (c == '\'')
  ------------------
  |  Branch (186:17): [True: 5, False: 95.2k]
  ------------------
  187|      5|            {
  188|      5|                if (parsed_separator)
  ------------------
  |  Branch (188:21): [True: 1, False: 4]
  ------------------
  189|      1|                {
  190|      1|                    return {};
  191|      1|                }
  192|       |
  193|      4|                parsed_separator = true;
  194|      4|                continue;
  195|      5|            }
  196|       |
  197|       |            // Check for over/underflow
  198|  95.2k|            if (is_negative && (-number < std::numeric_limits<phi::int16_t>::min()))
  ------------------
  |  Branch (198:17): [True: 324, False: 94.9k]
  |  Branch (198:32): [True: 0, False: 324]
  ------------------
  199|      0|            {
  200|       |                // Would underflow
  201|      0|                return {};
  202|      0|            }
  203|  95.2k|            if (!is_negative && (number > std::numeric_limits<phi::int16_t>::max()))
  ------------------
  |  Branch (203:17): [True: 94.9k, False: 324]
  |  Branch (203:17): [True: 3.63k, False: 91.6k]
  |  Branch (203:33): [True: 3.63k, False: 91.3k]
  ------------------
  204|  3.63k|            {
  205|       |                // Would overflow
  206|  3.63k|                return {};
  207|  3.63k|            }
  208|       |
  209|  91.6k|            parsed_separator = false;
  210|  91.6k|            parsed_something = true;
  211|       |
  212|  91.6k|            if (parsing_binary)
  ------------------
  |  Branch (212:17): [True: 61, False: 91.5k]
  ------------------
  213|     61|            {
  214|     61|                if (!phi::is_binary_digit(c))
  ------------------
  |  Branch (214:21): [True: 41, False: 20]
  ------------------
  215|     41|                {
  216|     41|                    return {};
  217|     41|                }
  218|       |
  219|     20|                number <<= 1;
  220|     20|                number |= (c - '0');
  221|     20|            }
  222|  91.5k|            else if (parsing_octal)
  ------------------
  |  Branch (222:22): [True: 26.9k, False: 64.5k]
  ------------------
  223|  26.9k|            {
  224|  26.9k|                if (!phi::is_octal_digit(c))
  ------------------
  |  Branch (224:21): [True: 1.96k, False: 25.0k]
  ------------------
  225|  1.96k|                {
  226|  1.96k|                    return {};
  227|  1.96k|                }
  228|       |
  229|  25.0k|                number <<= 3;
  230|  25.0k|                number |= (c - '0');
  231|  25.0k|            }
  232|  64.5k|            else if (parsing_hexadecimal)
  ------------------
  |  Branch (232:22): [True: 3, False: 64.5k]
  ------------------
  233|      3|            {
  234|      3|                if (!phi::is_hex_digit(c))
  ------------------
  |  Branch (234:21): [True: 3, False: 0]
  ------------------
  235|      3|                {
  236|      3|                    return {};
  237|      3|                }
  238|       |
  239|      0|                number <<= 4;
  240|      0|                number |= phi::hex_digit_value(c).unsafe();
  241|      0|            }
  242|  64.5k|            else
  243|  64.5k|            {
  244|  64.5k|                if (!phi::is_digit(c))
  ------------------
  |  Branch (244:21): [True: 41.0k, False: 23.5k]
  ------------------
  245|  41.0k|                {
  246|  41.0k|                    return {};
  247|  41.0k|                }
  248|       |
  249|       |                // Disallow leading zeros
  250|  23.5k|                if (number == 0 && c == '0')
  ------------------
  |  Branch (250:21): [True: 9.06k, False: 14.4k]
  |  Branch (250:36): [True: 1.48k, False: 7.57k]
  ------------------
  251|  1.48k|                {
  252|  1.48k|                    return {};
  253|  1.48k|                }
  254|       |
  255|  22.0k|                number *= 10;
  256|  22.0k|                number += (c - '0');
  257|  22.0k|            }
  258|  91.6k|        }
  259|       |
  260|  7.26k|        if (parsed_something)
  ------------------
  |  Branch (260:13): [True: 7.25k, False: 1]
  ------------------
  261|  7.25k|        {
  262|       |            // Check for over/underflow
  263|  7.25k|            if (is_negative && (-number < std::numeric_limits<phi::int16_t>::min()))
  ------------------
  |  Branch (263:17): [True: 34, False: 7.22k]
  |  Branch (263:32): [True: 0, False: 34]
  ------------------
  264|      0|            {
  265|       |                // Would underflow
  266|      0|                return {};
  267|      0|            }
  268|  7.25k|            if (!is_negative && (number > std::numeric_limits<phi::int16_t>::max()))
  ------------------
  |  Branch (268:17): [True: 7.22k, False: 34]
  |  Branch (268:17): [True: 405, False: 6.85k]
  |  Branch (268:33): [True: 405, False: 6.82k]
  ------------------
  269|    405|            {
  270|       |                // Would overflow
  271|    405|                return {};
  272|    405|            }
  273|       |
  274|  6.85k|            if (is_negative)
  ------------------
  |  Branch (274:17): [True: 34, False: 6.82k]
  ------------------
  275|     34|            {
  276|     34|                return static_cast<phi::int16_t>(-number);
  277|     34|            }
  278|       |
  279|  6.82k|            return static_cast<phi::int16_t>(number);
  280|  6.85k|        }
  281|       |
  282|      1|        return {};
  283|  7.26k|    }

_ZN3dlx9enum_nameINS_5Token4TypeEEEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEET_:
   85|   163k|    {
   86|   163k|        switch (value)
   87|   163k|        {
   88|      0|#define DLX_ENUM_TOKEN_TYPE_IMPL(name)                                                             \
   89|      0|    case Token::Type::name:                                                                        \
   90|      0|        return #name;
   91|       |
   92|      0|            DLX_ENUM_TOKEN_TYPE
  ------------------
  |  |   13|      0|    DLX_ENUM_TOKEN_TYPE_IMPL(Comment)                                                              \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 163k]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   14|     18|    DLX_ENUM_TOKEN_TYPE_IMPL(OpCode)                                                               \
  |  |  ------------------
  |  |  |  |   89|     18|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 18, False: 162k]
  |  |  |  |  ------------------
  |  |  |  |   90|     18|        return #name;
  |  |  ------------------
  |  |   15|    992|    DLX_ENUM_TOKEN_TYPE_IMPL(LabelIdentifier)                                                      \
  |  |  ------------------
  |  |  |  |   89|    992|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 992, False: 162k]
  |  |  |  |  ------------------
  |  |  |  |   90|    992|        return #name;
  |  |  ------------------
  |  |   16|    992|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterInt)                                                          \
  |  |  ------------------
  |  |  |  |   89|      1|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 1, False: 163k]
  |  |  |  |  ------------------
  |  |  |  |   90|      1|        return #name;
  |  |  ------------------
  |  |   17|     80|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterFloat)                                                        \
  |  |  ------------------
  |  |  |  |   89|     80|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 80, False: 162k]
  |  |  |  |  ------------------
  |  |  |  |   90|     80|        return #name;
  |  |  ------------------
  |  |   18|     80|    DLX_ENUM_TOKEN_TYPE_IMPL(RegisterStatus)                                                       \
  |  |  ------------------
  |  |  |  |   89|      0|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 0, False: 163k]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|        return #name;
  |  |  ------------------
  |  |   19|  6.22k|    DLX_ENUM_TOKEN_TYPE_IMPL(Comma)                                                                \
  |  |  ------------------
  |  |  |  |   89|  6.22k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 6.22k, False: 156k]
  |  |  |  |  ------------------
  |  |  |  |   90|  6.22k|        return #name;
  |  |  ------------------
  |  |   20|  6.22k|    DLX_ENUM_TOKEN_TYPE_IMPL(Colon)                                                                \
  |  |  ------------------
  |  |  |  |   89|  2.78k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 2.78k, False: 160k]
  |  |  |  |  ------------------
  |  |  |  |   90|  2.78k|        return #name;
  |  |  ------------------
  |  |   21|  30.6k|    DLX_ENUM_TOKEN_TYPE_IMPL(OpenBracket)                                                          \
  |  |  ------------------
  |  |  |  |   89|  30.6k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 30.6k, False: 132k]
  |  |  |  |  ------------------
  |  |  |  |   90|  30.6k|        return #name;
  |  |  ------------------
  |  |   22|  30.6k|    DLX_ENUM_TOKEN_TYPE_IMPL(ClosingBracket)                                                       \
  |  |  ------------------
  |  |  |  |   89|  15.4k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 15.4k, False: 147k]
  |  |  |  |  ------------------
  |  |  |  |   90|  15.4k|        return #name;
  |  |  ------------------
  |  |   23|  15.4k|    DLX_ENUM_TOKEN_TYPE_IMPL(NewLine)                                                              \
  |  |  ------------------
  |  |  |  |   89|  5.19k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 5.19k, False: 157k]
  |  |  |  |  ------------------
  |  |  |  |   90|  5.19k|        return #name;
  |  |  ------------------
  |  |   24|  5.19k|    DLX_ENUM_TOKEN_TYPE_IMPL(ImmediateInteger)                                                     \
  |  |  ------------------
  |  |  |  |   89|     80|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 80, False: 162k]
  |  |  |  |  ------------------
  |  |  |  |   90|     80|        return #name;
  |  |  ------------------
  |  |   25|  25.2k|    DLX_ENUM_TOKEN_TYPE_IMPL(IntegerLiteral)                                                       \
  |  |  ------------------
  |  |  |  |   89|  25.2k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 25.2k, False: 137k]
  |  |  |  |  ------------------
  |  |  |  |   90|  25.2k|        return #name;
  |  |  ------------------
  |  |   26|  76.3k|    DLX_ENUM_TOKEN_TYPE_IMPL(Unknown)
  |  |  ------------------
  |  |  |  |   89|  76.3k|    case Token::Type::name:                                                                        \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:5): [True: 76.3k, False: 86.6k]
  |  |  |  |  ------------------
  |  |  |  |   90|  76.3k|        return #name;
  |  |  ------------------
  ------------------
   93|       |
   94|      0|#undef DLX_ENUM_TOKEN_TYPE_IMPL
   95|       |
   96|      0|            default:
  ------------------
  |  Branch (96:13): [True: 0, False: 163k]
  ------------------
   97|      0|                PHI_ASSERT_NOT_REACHED();
   98|   163k|        }
   99|   163k|    }

Parser.cpp:_ZNK3dlx11TokenStream19find_first_token_ifIZNS_6Parser5ParseERS0_E3$_0EEPKNS_5TokenET_:
   58|  8.11k|        {
   59|       |#if defined(PHI_DEBUG)
   60|       |            PHI_ASSERT(m_Finalized);
   61|       |#endif
   62|       |
   63|  8.11k|            for (const Token& token : m_Tokens)
  ------------------
  |  Branch (63:37): [True: 26.3k, False: 0]
  ------------------
   64|  26.3k|            {
   65|  26.3k|                if (pred(token))
  ------------------
  |  Branch (65:21): [True: 8.11k, False: 18.2k]
  ------------------
   66|  8.11k|                {
   67|  8.11k|                    return &token;
   68|  8.11k|                }
   69|  26.3k|            }
   70|       |
   71|      0|            return nullptr;
   72|  8.11k|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5Token4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEERNS4_7integerImEESC_EEEvDpOT_:
   24|  6.83k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finalized);
   27|       |#endif
   28|       |
   29|  6.83k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|  6.83k|        }
_ZN3dlx11TokenStream12emplace_backIJNS_5TokenEEEEvDpOT_:
   24|  79.6k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finalized);
   27|       |#endif
   28|       |
   29|  79.6k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|  79.6k|        }
_ZN3dlx11TokenStream12emplace_backIJRNS_5Token4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEERNS5_7integerImEESD_EEEvDpOT_:
   24|  52.6k|        {
   25|       |#if defined(PHI_DEBUG)
   26|       |            PHI_ASSERT(!m_Finalized);
   27|       |#endif
   28|       |
   29|  52.6k|            m_Tokens.emplace_back(std::forward<ArgsT>(args)...);
   30|  52.6k|        }

_ZN3dlx11InstructionC2ERKNS_15InstructionInfoEN3phi7integerImEE:
   18|    502|    {}
_ZN3dlx11Instruction11SetArgumentEN3phi7integerIhEENS_19InstructionArgumentE:
   23|    152|    {
   24|    152|        PHI_ASSERT(argument_number < 3u);
   25|       |
   26|    152|        switch (argument_number.unsafe())
   27|    152|        {
   28|    152|            case 0u:
  ------------------
  |  Branch (28:13): [True: 152, False: 0]
  ------------------
   29|    152|                m_Arg1 = argument;
   30|    152|                break;
   31|      0|            case 1u:
  ------------------
  |  Branch (31:13): [True: 0, False: 152]
  ------------------
   32|      0|                m_Arg2 = argument;
   33|      0|                break;
   34|      0|            case 2u:
  ------------------
  |  Branch (34:13): [True: 0, False: 152]
  ------------------
   35|      0|                m_Arg3 = argument;
   36|      0|                break;
   37|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
   38|      0|            default:
  ------------------
  |  Branch (38:13): [True: 0, False: 152]
  ------------------
   39|      0|                PHI_ASSERT_NOT_REACHED();
   40|    152|#endif
   41|    152|        }
   42|    152|    }

_ZN3dlx19InstructionArgumentC2Ev:
   21|  1.65k|    {}
_ZN3dlx33ConstructInstructionArgumentLabelEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  200|    152|    {
  201|    152|        InstructionArgument arg;
  202|    152|        arg.m_Type           = ArgumentType::Label;
  203|    152|        arg.label.label_name = label_name;
  204|    152|        return arg;
  205|    152|    }

_ZN3dlx21LookUpInstructionInfoENS_6OpCodeE:
  449|    502|    {
  450|    502|        return instruction_table.at(static_cast<phi::size_t>(instruction));
  451|    502|    }

_ZN3dlx11IntRegisterC2Ev:
   12|   316k|    {}
_ZN3dlx11IntRegister11SetReadOnlyEN3phi7booleanE:
   40|  9.87k|    {
   41|  9.87k|        m_IsReadOnly = read_only;
   42|  9.87k|    }

_ZN3dlx11MemoryBlockC2EN3phi7integerImEES3_:
   12|  9.87k|    {
   13|  9.87k|        m_Values.resize(starting_size.unsafe());
   14|  9.87k|    }

_ZN3dlx14StringToOpCodeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   22|  72.6k|    {
   23|  72.6k|        switch (token.length().unsafe())
   24|  72.6k|        {
   25|       |            // 1 character OpCodes
   26|  11.2k|            case 1: {
  ------------------
  |  Branch (26:13): [True: 11.2k, False: 61.3k]
  ------------------
   27|  11.2k|                const char c1 = token[0u];
   28|       |
   29|  11.2k|                if (ice(c1, 'J'))
  ------------------
  |  Branch (29:21): [True: 4.21k, False: 7.02k]
  ------------------
   30|  4.21k|                {
   31|  4.21k|                    return OpCode::J;
   32|  4.21k|                }
   33|  7.02k|                break;
   34|  11.2k|            }
   35|       |
   36|       |            // 2 character OpCodes
   37|  22.9k|            case 2: {
  ------------------
  |  Branch (37:13): [True: 22.9k, False: 49.6k]
  ------------------
   38|  22.9k|                const char c1 = token[0u];
   39|  22.9k|                const char c2 = token[1u];
   40|       |
   41|  22.9k|                switch (c1)
  ------------------
  |  Branch (41:25): [True: 18.5k, False: 4.38k]
  ------------------
   42|  22.9k|                {
   43|    537|                    case 'J':
  ------------------
  |  Branch (43:21): [True: 537, False: 22.4k]
  ------------------
   44|  1.20k|                    case 'j':
  ------------------
  |  Branch (44:21): [True: 665, False: 22.3k]
  ------------------
   45|  1.20k|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (45:29): [True: 8, False: 1.19k]
  ------------------
   46|      8|                        {
   47|      8|                            return OpCode::JR;
   48|      8|                        }
   49|  1.19k|                        break;
   50|       |
   51|  1.19k|                    case 'L':
  ------------------
  |  Branch (51:21): [True: 214, False: 22.7k]
  ------------------
   52|  2.66k|                    case 'l':
  ------------------
  |  Branch (52:21): [True: 2.44k, False: 20.5k]
  ------------------
   53|  2.66k|                        switch (c2)
  ------------------
  |  Branch (53:33): [True: 2.65k, False: 8]
  ------------------
   54|  2.66k|                        {
   55|      7|                            case 'B':
  ------------------
  |  Branch (55:29): [True: 7, False: 2.65k]
  ------------------
   56|      7|                            case 'b':
  ------------------
  |  Branch (56:29): [True: 0, False: 2.66k]
  ------------------
   57|      7|                                return OpCode::LB;
   58|      0|                            case 'D':
  ------------------
  |  Branch (58:29): [True: 0, False: 2.66k]
  ------------------
   59|      0|                            case 'd':
  ------------------
  |  Branch (59:29): [True: 0, False: 2.66k]
  ------------------
   60|      0|                                return OpCode::LD;
   61|      0|                            case 'F':
  ------------------
  |  Branch (61:29): [True: 0, False: 2.66k]
  ------------------
   62|      0|                            case 'f':
  ------------------
  |  Branch (62:29): [True: 0, False: 2.66k]
  ------------------
   63|      0|                                return OpCode::LF;
   64|      0|                            case 'H':
  ------------------
  |  Branch (64:29): [True: 0, False: 2.66k]
  ------------------
   65|      1|                            case 'h':
  ------------------
  |  Branch (65:29): [True: 1, False: 2.66k]
  ------------------
   66|      1|                                return OpCode::LH;
   67|      0|                            case 'W':
  ------------------
  |  Branch (67:29): [True: 0, False: 2.66k]
  ------------------
   68|      0|                            case 'w':
  ------------------
  |  Branch (68:29): [True: 0, False: 2.66k]
  ------------------
   69|      0|                                return OpCode::LW;
   70|  2.66k|                        }
   71|  2.65k|                        break;
   72|  2.65k|                    case 'O':
  ------------------
  |  Branch (72:21): [True: 55, False: 22.9k]
  ------------------
   73|     99|                    case 'o':
  ------------------
  |  Branch (73:21): [True: 44, False: 22.9k]
  ------------------
   74|     99|                        if (ice(c2, 'R'))
  ------------------
  |  Branch (74:29): [True: 0, False: 99]
  ------------------
   75|      0|                        {
   76|      0|                            return OpCode::OR;
   77|      0|                        }
   78|     99|                        break;
   79|     99|                    case 'S':
  ------------------
  |  Branch (79:21): [True: 51, False: 22.9k]
  ------------------
   80|    420|                    case 's':
  ------------------
  |  Branch (80:21): [True: 369, False: 22.5k]
  ------------------
   81|    420|                        switch (c2)
  ------------------
  |  Branch (81:33): [True: 216, False: 204]
  ------------------
   82|    420|                        {
   83|    201|                            case 'B':
  ------------------
  |  Branch (83:29): [True: 201, False: 219]
  ------------------
   84|    201|                            case 'b':
  ------------------
  |  Branch (84:29): [True: 0, False: 420]
  ------------------
   85|    201|                                return OpCode::SB;
   86|      0|                            case 'D':
  ------------------
  |  Branch (86:29): [True: 0, False: 420]
  ------------------
   87|      0|                            case 'd':
  ------------------
  |  Branch (87:29): [True: 0, False: 420]
  ------------------
   88|      0|                                return OpCode::SD;
   89|      0|                            case 'F':
  ------------------
  |  Branch (89:29): [True: 0, False: 420]
  ------------------
   90|      3|                            case 'f':
  ------------------
  |  Branch (90:29): [True: 3, False: 417]
  ------------------
   91|      3|                                return OpCode::SF;
   92|      0|                            case 'H':
  ------------------
  |  Branch (92:29): [True: 0, False: 420]
  ------------------
   93|      0|                            case 'h':
  ------------------
  |  Branch (93:29): [True: 0, False: 420]
  ------------------
   94|      0|                                return OpCode::SH;
   95|      0|                            case 'w':
  ------------------
  |  Branch (95:29): [True: 0, False: 420]
  ------------------
   96|      0|                            case 'W':
  ------------------
  |  Branch (96:29): [True: 0, False: 420]
  ------------------
   97|      0|                                return OpCode::SW;
   98|    420|                        }
   99|    216|                        break;
  100|  22.9k|                }
  101|  22.7k|                break;
  102|  22.9k|            }
  103|       |
  104|       |            // 3 character OpCodes
  105|  22.7k|            case 3: {
  ------------------
  |  Branch (105:13): [True: 16.6k, False: 56.0k]
  ------------------
  106|  16.6k|                const char c1 = token[0u];
  107|  16.6k|                const char c2 = token[1u];
  108|  16.6k|                const char c3 = token[2u];
  109|       |
  110|  16.6k|                switch (c1)
  ------------------
  |  Branch (110:25): [True: 11.1k, False: 5.47k]
  ------------------
  111|  16.6k|                {
  112|    110|                    case 'A':
  ------------------
  |  Branch (112:21): [True: 110, False: 16.4k]
  ------------------
  113|    192|                    case 'a':
  ------------------
  |  Branch (113:21): [True: 82, False: 16.5k]
  ------------------
  114|    192|                        if (ice(c2, 'D') && ice(c3, 'D'))
  ------------------
  |  Branch (114:29): [True: 0, False: 192]
  |  Branch (114:29): [True: 0, False: 192]
  |  Branch (114:45): [True: 0, False: 0]
  ------------------
  115|      0|                        {
  116|      0|                            return OpCode::ADD;
  117|      0|                        }
  118|    192|                        else if (ice(c2, 'N') && ice(c3, 'D'))
  ------------------
  |  Branch (118:34): [True: 0, False: 192]
  |  Branch (118:34): [True: 0, False: 192]
  |  Branch (118:50): [True: 0, False: 0]
  ------------------
  119|      0|                        {
  120|      0|                            return OpCode::AND;
  121|      0|                        }
  122|    192|                        break;
  123|       |
  124|  2.21k|                    case 'D':
  ------------------
  |  Branch (124:21): [True: 2.21k, False: 14.3k]
  ------------------
  125|  2.21k|                    case 'd':
  ------------------
  |  Branch (125:21): [True: 1, False: 16.6k]
  ------------------
  126|  2.21k|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (126:29): [True: 0, False: 2.21k]
  |  Branch (126:29): [True: 0, False: 2.21k]
  |  Branch (126:45): [True: 0, False: 0]
  ------------------
  127|      0|                        {
  128|      0|                            return OpCode::DIV;
  129|      0|                        }
  130|  2.21k|                        break;
  131|       |
  132|  2.21k|                    case 'E':
  ------------------
  |  Branch (132:21): [True: 106, False: 16.4k]
  ------------------
  133|    396|                    case 'e':
  ------------------
  |  Branch (133:21): [True: 290, False: 16.3k]
  ------------------
  134|    396|                        if (ice(c2, 'Q'))
  ------------------
  |  Branch (134:29): [True: 92, False: 304]
  ------------------
  135|     92|                        {
  136|     92|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (136:33): [True: 0, False: 92]
  ------------------
  137|      0|                            {
  138|      0|                                return OpCode::EQD;
  139|      0|                            }
  140|     92|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (140:38): [True: 0, False: 92]
  ------------------
  141|      0|                            {
  142|      0|                                return OpCode::EQF;
  143|      0|                            }
  144|     92|                        }
  145|    396|                        break;
  146|       |
  147|    396|                    case 'G':
  ------------------
  |  Branch (147:21): [True: 16, False: 16.5k]
  ------------------
  148|     55|                    case 'g':
  ------------------
  |  Branch (148:21): [True: 39, False: 16.5k]
  ------------------
  149|     55|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (149:29): [True: 0, False: 55]
  ------------------
  150|      0|                        {
  151|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (151:33): [True: 0, False: 0]
  ------------------
  152|      0|                            {
  153|      0|                                return OpCode::GED;
  154|      0|                            }
  155|      0|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (155:38): [True: 0, False: 0]
  ------------------
  156|      0|                            {
  157|      0|                                return OpCode::GEF;
  158|      0|                            }
  159|      0|                        }
  160|     55|                        else if (ice(c2, 'T'))
  ------------------
  |  Branch (160:34): [True: 0, False: 55]
  ------------------
  161|      0|                        {
  162|      0|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (162:33): [True: 0, False: 0]
  ------------------
  163|      0|                            {
  164|      0|                                return OpCode::GTD;
  165|      0|                            }
  166|      0|                            if (ice(c3, 'F'))
  ------------------
  |  Branch (166:33): [True: 0, False: 0]
  ------------------
  167|      0|                            {
  168|      0|                                return OpCode::GTF;
  169|      0|                            }
  170|      0|                        }
  171|     55|                        break;
  172|       |
  173|    112|                    case 'J':
  ------------------
  |  Branch (173:21): [True: 112, False: 16.4k]
  ------------------
  174|    292|                    case 'j':
  ------------------
  |  Branch (174:21): [True: 180, False: 16.4k]
  ------------------
  175|    292|                        if (ice(c2, 'A') && ice(c3, 'L'))
  ------------------
  |  Branch (175:29): [True: 16, False: 276]
  |  Branch (175:29): [True: 3, False: 289]
  |  Branch (175:45): [True: 3, False: 13]
  ------------------
  176|      3|                        {
  177|      3|                            return OpCode::JAL;
  178|      3|                        }
  179|    289|                        break;
  180|       |
  181|    289|                    case 'L':
  ------------------
  |  Branch (181:21): [True: 177, False: 16.4k]
  ------------------
  182|  1.65k|                    case 'l':
  ------------------
  |  Branch (182:21): [True: 1.48k, False: 15.1k]
  ------------------
  183|  1.65k|                        switch (c2)
  ------------------
  |  Branch (183:33): [True: 1.09k, False: 561]
  ------------------
  184|  1.65k|                        {
  185|      1|                            case 'B':
  ------------------
  |  Branch (185:29): [True: 1, False: 1.65k]
  ------------------
  186|      1|                            case 'b':
  ------------------
  |  Branch (186:29): [True: 0, False: 1.65k]
  ------------------
  187|      1|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (187:37): [True: 0, False: 1]
  ------------------
  188|      0|                                {
  189|      0|                                    return OpCode::LBU;
  190|      0|                                }
  191|      1|                                break;
  192|       |
  193|      1|                            case 'E':
  ------------------
  |  Branch (193:29): [True: 0, False: 1.65k]
  ------------------
  194|      3|                            case 'e':
  ------------------
  |  Branch (194:29): [True: 3, False: 1.65k]
  ------------------
  195|      3|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (195:37): [True: 0, False: 3]
  ------------------
  196|      0|                                {
  197|      0|                                    return OpCode::LED;
  198|      0|                                }
  199|      3|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (199:42): [True: 0, False: 3]
  ------------------
  200|      0|                                {
  201|      0|                                    return OpCode::LEF;
  202|      0|                                }
  203|      3|                                break;
  204|       |
  205|      3|                            case 'H':
  ------------------
  |  Branch (205:29): [True: 0, False: 1.65k]
  ------------------
  206|      2|                            case 'h':
  ------------------
  |  Branch (206:29): [True: 2, False: 1.65k]
  ------------------
  207|      2|                                if (ice(c3, 'I'))
  ------------------
  |  Branch (207:37): [True: 0, False: 2]
  ------------------
  208|      0|                                {
  209|      0|                                    return OpCode::LHI;
  210|      0|                                }
  211|      2|                                else if (ice(c3, 'U'))
  ------------------
  |  Branch (211:42): [True: 0, False: 2]
  ------------------
  212|      0|                                {
  213|      0|                                    return OpCode::LHU;
  214|      0|                                }
  215|      2|                                break;
  216|       |
  217|    555|                            case 'T':
  ------------------
  |  Branch (217:29): [True: 555, False: 1.10k]
  ------------------
  218|    555|                            case 't':
  ------------------
  |  Branch (218:29): [True: 0, False: 1.65k]
  ------------------
  219|    555|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (219:37): [True: 0, False: 555]
  ------------------
  220|      0|                                {
  221|      0|                                    return OpCode::LTD;
  222|      0|                                }
  223|    555|                                else if (ice(c3, 'F'))
  ------------------
  |  Branch (223:42): [True: 0, False: 555]
  ------------------
  224|      0|                                {
  225|      0|                                    return OpCode::LTF;
  226|      0|                                }
  227|    555|                                break;
  228|       |
  229|    555|                            case 'W':
  ------------------
  |  Branch (229:29): [True: 0, False: 1.65k]
  ------------------
  230|      0|                            case 'w':
  ------------------
  |  Branch (230:29): [True: 0, False: 1.65k]
  ------------------
  231|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (231:37): [True: 0, False: 0]
  ------------------
  232|      0|                                {
  233|      0|                                    return OpCode::LWU;
  234|      0|                                }
  235|      0|                                break;
  236|  1.65k|                        }
  237|  1.65k|                        break;
  238|       |
  239|  1.65k|                    case 'N':
  ------------------
  |  Branch (239:21): [True: 271, False: 16.3k]
  ------------------
  240|    280|                    case 'n':
  ------------------
  |  Branch (240:21): [True: 9, False: 16.5k]
  ------------------
  241|    280|                        if (ice(c2, 'E'))
  ------------------
  |  Branch (241:29): [True: 133, False: 147]
  ------------------
  242|    133|                        {
  243|    133|                            if (ice(c3, 'D'))
  ------------------
  |  Branch (243:33): [True: 0, False: 133]
  ------------------
  244|      0|                            {
  245|      0|                                return OpCode::NED;
  246|      0|                            }
  247|    133|                            else if (ice(c3, 'F'))
  ------------------
  |  Branch (247:38): [True: 0, False: 133]
  ------------------
  248|      0|                            {
  249|      0|                                return OpCode::NEF;
  250|      0|                            }
  251|    133|                        }
  252|    147|                        else if (ice(c2, 'O') && ice(c3, 'P'))
  ------------------
  |  Branch (252:34): [True: 0, False: 147]
  |  Branch (252:34): [True: 0, False: 147]
  |  Branch (252:50): [True: 0, False: 0]
  ------------------
  253|      0|                        {
  254|      0|                            return OpCode::NOP;
  255|      0|                        }
  256|       |
  257|    280|                        break;
  258|       |
  259|    280|                    case 'O':
  ------------------
  |  Branch (259:21): [True: 129, False: 16.4k]
  ------------------
  260|    142|                    case 'o':
  ------------------
  |  Branch (260:21): [True: 13, False: 16.5k]
  ------------------
  261|    142|                        if (ice(c2, 'R') && ice(c3, 'I'))
  ------------------
  |  Branch (261:29): [True: 0, False: 142]
  |  Branch (261:29): [True: 0, False: 142]
  |  Branch (261:45): [True: 0, False: 0]
  ------------------
  262|      0|                        {
  263|      0|                            return OpCode::ORI;
  264|      0|                        }
  265|    142|                        break;
  266|       |
  267|    142|                    case 'S':
  ------------------
  |  Branch (267:21): [True: 59, False: 16.5k]
  ------------------
  268|    218|                    case 's':
  ------------------
  |  Branch (268:21): [True: 159, False: 16.4k]
  ------------------
  269|    218|                        switch (c2)
  ------------------
  |  Branch (269:33): [True: 183, False: 35]
  ------------------
  270|    218|                        {
  271|      4|                            case 'B':
  ------------------
  |  Branch (271:29): [True: 4, False: 214]
  ------------------
  272|      4|                            case 'b':
  ------------------
  |  Branch (272:29): [True: 0, False: 218]
  ------------------
  273|      4|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (273:37): [True: 0, False: 4]
  ------------------
  274|      0|                                {
  275|      0|                                    return OpCode::SBU;
  276|      0|                                }
  277|      4|                                break;
  278|       |
  279|      4|                            case 'E':
  ------------------
  |  Branch (279:29): [True: 0, False: 218]
  ------------------
  280|      2|                            case 'e':
  ------------------
  |  Branch (280:29): [True: 2, False: 216]
  ------------------
  281|      2|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (281:37): [True: 0, False: 2]
  ------------------
  282|      0|                                {
  283|      0|                                    return OpCode::SEQ;
  284|      0|                                }
  285|      2|                                break;
  286|       |
  287|      2|                            case 'G':
  ------------------
  |  Branch (287:29): [True: 2, False: 216]
  ------------------
  288|     23|                            case 'g':
  ------------------
  |  Branch (288:29): [True: 21, False: 197]
  ------------------
  289|     23|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (289:37): [True: 0, False: 23]
  ------------------
  290|      0|                                {
  291|      0|                                    return OpCode::SGE;
  292|      0|                                }
  293|     23|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (293:42): [True: 0, False: 23]
  ------------------
  294|      0|                                {
  295|      0|                                    return OpCode::SGT;
  296|      0|                                }
  297|     23|                                break;
  298|       |
  299|     23|                            case 'H':
  ------------------
  |  Branch (299:29): [True: 0, False: 218]
  ------------------
  300|      0|                            case 'h':
  ------------------
  |  Branch (300:29): [True: 0, False: 218]
  ------------------
  301|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (301:37): [True: 0, False: 0]
  ------------------
  302|      0|                                {
  303|      0|                                    return OpCode::SHU;
  304|      0|                                }
  305|      0|                                break;
  306|       |
  307|      0|                            case 'L':
  ------------------
  |  Branch (307:29): [True: 0, False: 218]
  ------------------
  308|      6|                            case 'l':
  ------------------
  |  Branch (308:29): [True: 6, False: 212]
  ------------------
  309|      6|                                switch (c3)
  ------------------
  |  Branch (309:41): [True: 1, False: 5]
  ------------------
  310|      6|                                {
  311|      0|                                    case 'A':
  ------------------
  |  Branch (311:37): [True: 0, False: 6]
  ------------------
  312|      2|                                    case 'a':
  ------------------
  |  Branch (312:37): [True: 2, False: 4]
  ------------------
  313|      2|                                        return OpCode::SLA;
  314|       |
  315|      0|                                    case 'E':
  ------------------
  |  Branch (315:37): [True: 0, False: 6]
  ------------------
  316|      2|                                    case 'e':
  ------------------
  |  Branch (316:37): [True: 2, False: 4]
  ------------------
  317|      2|                                        return OpCode::SLE;
  318|       |
  319|      0|                                    case 'L':
  ------------------
  |  Branch (319:37): [True: 0, False: 6]
  ------------------
  320|      1|                                    case 'l':
  ------------------
  |  Branch (320:37): [True: 1, False: 5]
  ------------------
  321|      1|                                        return OpCode::SLL;
  322|       |
  323|      0|                                    case 'T':
  ------------------
  |  Branch (323:37): [True: 0, False: 6]
  ------------------
  324|      0|                                    case 't':
  ------------------
  |  Branch (324:37): [True: 0, False: 6]
  ------------------
  325|      0|                                        return OpCode::SLT;
  326|      6|                                }
  327|      1|                                break;
  328|       |
  329|      1|                            case 'N':
  ------------------
  |  Branch (329:29): [True: 0, False: 218]
  ------------------
  330|      0|                            case 'n':
  ------------------
  |  Branch (330:29): [True: 0, False: 218]
  ------------------
  331|      0|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (331:37): [True: 0, False: 0]
  ------------------
  332|      0|                                {
  333|      0|                                    return OpCode::SNE;
  334|      0|                                }
  335|      0|                                break;
  336|       |
  337|      0|                            case 'R':
  ------------------
  |  Branch (337:29): [True: 0, False: 218]
  ------------------
  338|      0|                            case 'r':
  ------------------
  |  Branch (338:29): [True: 0, False: 218]
  ------------------
  339|      0|                                if (ice(c3, 'A'))
  ------------------
  |  Branch (339:37): [True: 0, False: 0]
  ------------------
  340|      0|                                {
  341|      0|                                    return OpCode::SRA;
  342|      0|                                }
  343|      0|                                else if (ice(c3, 'L'))
  ------------------
  |  Branch (343:42): [True: 0, False: 0]
  ------------------
  344|      0|                                {
  345|      0|                                    return OpCode::SRL;
  346|      0|                                }
  347|      0|                                break;
  348|       |
  349|      0|                            case 'U':
  ------------------
  |  Branch (349:29): [True: 0, False: 218]
  ------------------
  350|      0|                            case 'u':
  ------------------
  |  Branch (350:29): [True: 0, False: 218]
  ------------------
  351|      0|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (351:37): [True: 0, False: 0]
  ------------------
  352|      0|                                {
  353|      0|                                    return OpCode::SUB;
  354|      0|                                }
  355|      0|                                break;
  356|       |
  357|      0|                            case 'W':
  ------------------
  |  Branch (357:29): [True: 0, False: 218]
  ------------------
  358|      0|                            case 'w':
  ------------------
  |  Branch (358:29): [True: 0, False: 218]
  ------------------
  359|      0|                                if (ice(c3, 'U'))
  ------------------
  |  Branch (359:37): [True: 0, False: 0]
  ------------------
  360|      0|                                {
  361|      0|                                    return OpCode::SWU;
  362|      0|                                }
  363|      0|                                break;
  364|    218|                        }
  365|       |
  366|    232|                    case 'X':
  ------------------
  |  Branch (366:21): [True: 19, False: 16.5k]
  ------------------
  367|    241|                    case 'x':
  ------------------
  |  Branch (367:21): [True: 9, False: 16.5k]
  ------------------
  368|    241|                        if (ice(c2, 'O') && ice(c3, 'R'))
  ------------------
  |  Branch (368:29): [True: 0, False: 241]
  |  Branch (368:29): [True: 0, False: 241]
  |  Branch (368:45): [True: 0, False: 0]
  ------------------
  369|      0|                        {
  370|      0|                            return OpCode::XOR;
  371|      0|                        }
  372|    241|                        break;
  373|  16.6k|                }
  374|  16.5k|                break;
  375|  16.6k|            }
  376|       |
  377|       |            // 4 character OpCodes
  378|  16.5k|            case 4: {
  ------------------
  |  Branch (378:13): [True: 5.84k, False: 66.7k]
  ------------------
  379|  5.84k|                const char c1 = token[0u];
  380|  5.84k|                const char c2 = token[1u];
  381|  5.84k|                const char c3 = token[2u];
  382|  5.84k|                const char c4 = token[3u];
  383|       |
  384|  5.84k|                switch (c1)
  ------------------
  |  Branch (384:25): [True: 3.59k, False: 2.24k]
  ------------------
  385|  5.84k|                {
  386|    179|                    case 'A':
  ------------------
  |  Branch (386:21): [True: 179, False: 5.66k]
  ------------------
  387|    257|                    case 'a':
  ------------------
  |  Branch (387:21): [True: 78, False: 5.76k]
  ------------------
  388|    257|                        switch (c2)
  ------------------
  |  Branch (388:33): [True: 257, False: 0]
  ------------------
  389|    257|                        {
  390|      0|                            case 'D':
  ------------------
  |  Branch (390:29): [True: 0, False: 257]
  ------------------
  391|      0|                            case 'd':
  ------------------
  |  Branch (391:29): [True: 0, False: 257]
  ------------------
  392|      0|                                if (ice(c3, 'D'))
  ------------------
  |  Branch (392:37): [True: 0, False: 0]
  ------------------
  393|      0|                                {
  394|      0|                                    switch (c4)
  ------------------
  |  Branch (394:45): [True: 0, False: 0]
  ------------------
  395|      0|                                    {
  396|      0|                                        case 'D':
  ------------------
  |  Branch (396:41): [True: 0, False: 0]
  ------------------
  397|      0|                                        case 'd':
  ------------------
  |  Branch (397:41): [True: 0, False: 0]
  ------------------
  398|      0|                                            return OpCode::ADDD;
  399|       |
  400|      0|                                        case 'F':
  ------------------
  |  Branch (400:41): [True: 0, False: 0]
  ------------------
  401|      0|                                        case 'f':
  ------------------
  |  Branch (401:41): [True: 0, False: 0]
  ------------------
  402|      0|                                            return OpCode::ADDF;
  403|       |
  404|      0|                                        case 'I':
  ------------------
  |  Branch (404:41): [True: 0, False: 0]
  ------------------
  405|      0|                                        case 'i':
  ------------------
  |  Branch (405:41): [True: 0, False: 0]
  ------------------
  406|      0|                                            return OpCode::ADDI;
  407|       |
  408|      0|                                        case 'U':
  ------------------
  |  Branch (408:41): [True: 0, False: 0]
  ------------------
  409|      0|                                        case 'u':
  ------------------
  |  Branch (409:41): [True: 0, False: 0]
  ------------------
  410|      0|                                            return OpCode::ADDU;
  411|      0|                                    }
  412|      0|                                }
  413|      0|                                break;
  414|       |
  415|      0|                            case 'N':
  ------------------
  |  Branch (415:29): [True: 0, False: 257]
  ------------------
  416|      0|                            case 'n':
  ------------------
  |  Branch (416:29): [True: 0, False: 257]
  ------------------
  417|      0|                                if (ice(c3, 'D') && ice(c4, 'I'))
  ------------------
  |  Branch (417:37): [True: 0, False: 0]
  |  Branch (417:37): [True: 0, False: 0]
  |  Branch (417:53): [True: 0, False: 0]
  ------------------
  418|      0|                                {
  419|      0|                                    return OpCode::ANDI;
  420|      0|                                }
  421|       |
  422|      0|                                break;
  423|    257|                        }
  424|    257|                        break;
  425|       |
  426|    257|                    case 'B':
  ------------------
  |  Branch (426:21): [True: 240, False: 5.60k]
  ------------------
  427|    251|                    case 'b':
  ------------------
  |  Branch (427:21): [True: 11, False: 5.83k]
  ------------------
  428|    251|                        switch (c2)
  ------------------
  |  Branch (428:33): [True: 246, False: 5]
  ------------------
  429|    251|                        {
  430|      3|                            case 'E':
  ------------------
  |  Branch (430:29): [True: 3, False: 248]
  ------------------
  431|      3|                            case 'e':
  ------------------
  |  Branch (431:29): [True: 0, False: 251]
  ------------------
  432|      3|                                if (ice(c3, 'Q') && ice(c4, 'Z'))
  ------------------
  |  Branch (432:37): [True: 0, False: 3]
  |  Branch (432:37): [True: 0, False: 3]
  |  Branch (432:53): [True: 0, False: 0]
  ------------------
  433|      0|                                {
  434|      0|                                    return OpCode::BEQZ;
  435|      0|                                }
  436|      3|                                break;
  437|       |
  438|      3|                            case 'F':
  ------------------
  |  Branch (438:29): [True: 2, False: 249]
  ------------------
  439|      2|                            case 'f':
  ------------------
  |  Branch (439:29): [True: 0, False: 251]
  ------------------
  440|      2|                                if (ice(c3, 'P'))
  ------------------
  |  Branch (440:37): [True: 0, False: 2]
  ------------------
  441|      0|                                {
  442|      0|                                    if (ice(c4, 'F'))
  ------------------
  |  Branch (442:41): [True: 0, False: 0]
  ------------------
  443|      0|                                    {
  444|      0|                                        return OpCode::BFPF;
  445|      0|                                    }
  446|      0|                                    else if (ice(c4, 'T'))
  ------------------
  |  Branch (446:46): [True: 0, False: 0]
  ------------------
  447|      0|                                    {
  448|      0|                                        return OpCode::BFPT;
  449|      0|                                    }
  450|      0|                                }
  451|      2|                                break;
  452|       |
  453|      2|                            case 'N':
  ------------------
  |  Branch (453:29): [True: 0, False: 251]
  ------------------
  454|      0|                            case 'n':
  ------------------
  |  Branch (454:29): [True: 0, False: 251]
  ------------------
  455|      0|                                if (ice(c3, 'E') && ice(c4, 'Z'))
  ------------------
  |  Branch (455:37): [True: 0, False: 0]
  |  Branch (455:37): [True: 0, False: 0]
  |  Branch (455:53): [True: 0, False: 0]
  ------------------
  456|      0|                                {
  457|      0|                                    return OpCode::BNEZ;
  458|      0|                                }
  459|    251|                        }
  460|    251|                        break;
  461|       |
  462|    256|                    case 'D':
  ------------------
  |  Branch (462:21): [True: 256, False: 5.58k]
  ------------------
  463|    256|                    case 'd':
  ------------------
  |  Branch (463:21): [True: 0, False: 5.84k]
  ------------------
  464|    256|                        if (ice(c2, 'I') && ice(c3, 'V'))
  ------------------
  |  Branch (464:29): [True: 0, False: 256]
  |  Branch (464:29): [True: 0, False: 256]
  |  Branch (464:45): [True: 0, False: 0]
  ------------------
  465|      0|                        {
  466|      0|                            switch (c4)
  ------------------
  |  Branch (466:37): [True: 0, False: 0]
  ------------------
  467|      0|                            {
  468|      0|                                case 'D':
  ------------------
  |  Branch (468:33): [True: 0, False: 0]
  ------------------
  469|      0|                                case 'd':
  ------------------
  |  Branch (469:33): [True: 0, False: 0]
  ------------------
  470|      0|                                    return OpCode::DIVD;
  471|       |
  472|      0|                                case 'F':
  ------------------
  |  Branch (472:33): [True: 0, False: 0]
  ------------------
  473|      0|                                case 'f':
  ------------------
  |  Branch (473:33): [True: 0, False: 0]
  ------------------
  474|      0|                                    return OpCode::DIVF;
  475|       |
  476|      0|                                case 'I':
  ------------------
  |  Branch (476:33): [True: 0, False: 0]
  ------------------
  477|      0|                                case 'i':
  ------------------
  |  Branch (477:33): [True: 0, False: 0]
  ------------------
  478|      0|                                    return OpCode::DIVI;
  479|       |
  480|      0|                                case 'U':
  ------------------
  |  Branch (480:33): [True: 0, False: 0]
  ------------------
  481|      0|                                case 'u':
  ------------------
  |  Branch (481:33): [True: 0, False: 0]
  ------------------
  482|      0|                                    return OpCode::DIVU;
  483|      0|                            }
  484|      0|                        }
  485|    256|                        break;
  486|       |
  487|    300|                    case 'H':
  ------------------
  |  Branch (487:21): [True: 300, False: 5.54k]
  ------------------
  488|    306|                    case 'h':
  ------------------
  |  Branch (488:21): [True: 6, False: 5.83k]
  ------------------
  489|    306|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (489:29): [True: 2, False: 304]
  |  Branch (489:29): [True: 0, False: 306]
  |  Branch (489:45): [True: 0, False: 2]
  |  Branch (489:61): [True: 0, False: 0]
  ------------------
  490|      0|                        {
  491|      0|                            return OpCode::HALT;
  492|      0|                        }
  493|    306|                        break;
  494|       |
  495|    441|                    case 'J':
  ------------------
  |  Branch (495:21): [True: 441, False: 5.40k]
  ------------------
  496|    623|                    case 'j':
  ------------------
  |  Branch (496:21): [True: 182, False: 5.65k]
  ------------------
  497|    623|                        if (ice(c2, 'A') && ice(c3, 'L') && ice(c4, 'R'))
  ------------------
  |  Branch (497:29): [True: 100, False: 523]
  |  Branch (497:29): [True: 0, False: 623]
  |  Branch (497:45): [True: 23, False: 77]
  |  Branch (497:61): [True: 0, False: 23]
  ------------------
  498|      0|                        {
  499|      0|                            return OpCode::JALR;
  500|      0|                        }
  501|    623|                        break;
  502|       |
  503|    623|                    case 'M':
  ------------------
  |  Branch (503:21): [True: 1, False: 5.84k]
  ------------------
  504|     24|                    case 'm':
  ------------------
  |  Branch (504:21): [True: 23, False: 5.81k]
  ------------------
  505|     24|                        if (ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (505:29): [True: 0, False: 24]
  |  Branch (505:29): [True: 0, False: 24]
  |  Branch (505:45): [True: 0, False: 0]
  ------------------
  506|      0|                        {
  507|      0|                            if (ice(c4, 'D'))
  ------------------
  |  Branch (507:33): [True: 0, False: 0]
  ------------------
  508|      0|                            {
  509|      0|                                return OpCode::MOVD;
  510|      0|                            }
  511|      0|                            else if (ice(c4, 'F'))
  ------------------
  |  Branch (511:38): [True: 0, False: 0]
  ------------------
  512|      0|                            {
  513|      0|                                return OpCode::MOVF;
  514|      0|                            }
  515|      0|                        }
  516|     24|                        else if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (516:34): [True: 0, False: 24]
  |  Branch (516:34): [True: 0, False: 24]
  |  Branch (516:50): [True: 0, False: 0]
  |  Branch (516:66): [True: 0, False: 0]
  ------------------
  517|      0|                        {
  518|      0|                            return OpCode::MULT;
  519|      0|                        }
  520|     24|                        break;
  521|       |
  522|     24|                    case 'S':
  ------------------
  |  Branch (522:21): [True: 15, False: 5.82k]
  ------------------
  523|    480|                    case 's':
  ------------------
  |  Branch (523:21): [True: 465, False: 5.37k]
  ------------------
  524|    480|                        switch (c2)
  ------------------
  |  Branch (524:33): [True: 444, False: 36]
  ------------------
  525|    480|                        {
  526|      0|                            case 'E':
  ------------------
  |  Branch (526:29): [True: 0, False: 480]
  ------------------
  527|      2|                            case 'e':
  ------------------
  |  Branch (527:29): [True: 2, False: 478]
  ------------------
  528|      2|                                if (ice(c3, 'Q'))
  ------------------
  |  Branch (528:37): [True: 0, False: 2]
  ------------------
  529|      0|                                {
  530|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (530:41): [True: 0, False: 0]
  ------------------
  531|      0|                                    {
  532|      0|                                        return OpCode::SEQI;
  533|      0|                                    }
  534|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (534:46): [True: 0, False: 0]
  ------------------
  535|      0|                                    {
  536|      0|                                        return OpCode::SEQU;
  537|      0|                                    }
  538|      0|                                }
  539|      2|                                break;
  540|       |
  541|      2|                            case 'G':
  ------------------
  |  Branch (541:29): [True: 2, False: 478]
  ------------------
  542|     29|                            case 'g':
  ------------------
  |  Branch (542:29): [True: 27, False: 453]
  ------------------
  543|     29|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (543:37): [True: 0, False: 29]
  ------------------
  544|      0|                                {
  545|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (545:41): [True: 0, False: 0]
  ------------------
  546|      0|                                    {
  547|      0|                                        return OpCode::SGEI;
  548|      0|                                    }
  549|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (549:46): [True: 0, False: 0]
  ------------------
  550|      0|                                    {
  551|      0|                                        return OpCode::SGEU;
  552|      0|                                    }
  553|      0|                                }
  554|     29|                                else if (ice(c3, 'T'))
  ------------------
  |  Branch (554:42): [True: 0, False: 29]
  ------------------
  555|      0|                                {
  556|      0|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (556:41): [True: 0, False: 0]
  ------------------
  557|      0|                                    {
  558|      0|                                        return OpCode::SGTI;
  559|      0|                                    }
  560|      0|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (560:46): [True: 0, False: 0]
  ------------------
  561|      0|                                    {
  562|      0|                                        return OpCode::SGTU;
  563|      0|                                    }
  564|      0|                                }
  565|     29|                                break;
  566|       |
  567|     29|                            case 'L':
  ------------------
  |  Branch (567:29): [True: 0, False: 480]
  ------------------
  568|      5|                            case 'l':
  ------------------
  |  Branch (568:29): [True: 5, False: 475]
  ------------------
  569|      5|                                switch (c3)
  ------------------
  |  Branch (569:41): [True: 1, False: 4]
  ------------------
  570|      5|                                {
  571|      0|                                    case 'A':
  ------------------
  |  Branch (571:37): [True: 0, False: 5]
  ------------------
  572|      1|                                    case 'a':
  ------------------
  |  Branch (572:37): [True: 1, False: 4]
  ------------------
  573|      1|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (573:45): [True: 0, False: 1]
  ------------------
  574|      0|                                        {
  575|      0|                                            return OpCode::SLAI;
  576|      0|                                        }
  577|      1|                                        break;
  578|       |
  579|      1|                                    case 'E':
  ------------------
  |  Branch (579:37): [True: 0, False: 5]
  ------------------
  580|      1|                                    case 'e':
  ------------------
  |  Branch (580:37): [True: 1, False: 4]
  ------------------
  581|      1|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (581:45): [True: 0, False: 1]
  ------------------
  582|      0|                                        {
  583|      0|                                            return OpCode::SLEI;
  584|      0|                                        }
  585|      1|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (585:50): [True: 0, False: 1]
  ------------------
  586|      0|                                        {
  587|      0|                                            return OpCode::SLEU;
  588|      0|                                        }
  589|      1|                                        break;
  590|       |
  591|      1|                                    case 'L':
  ------------------
  |  Branch (591:37): [True: 0, False: 5]
  ------------------
  592|      2|                                    case 'l':
  ------------------
  |  Branch (592:37): [True: 2, False: 3]
  ------------------
  593|      2|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (593:45): [True: 0, False: 2]
  ------------------
  594|      0|                                        {
  595|      0|                                            return OpCode::SLLI;
  596|      0|                                        }
  597|      2|                                        break;
  598|       |
  599|      2|                                    case 'T':
  ------------------
  |  Branch (599:37): [True: 0, False: 5]
  ------------------
  600|      0|                                    case 't':
  ------------------
  |  Branch (600:37): [True: 0, False: 5]
  ------------------
  601|      0|                                        if (ice(c4, 'I'))
  ------------------
  |  Branch (601:45): [True: 0, False: 0]
  ------------------
  602|      0|                                        {
  603|      0|                                            return OpCode::SLTI;
  604|      0|                                        }
  605|      0|                                        else if (ice(c4, 'U'))
  ------------------
  |  Branch (605:50): [True: 0, False: 0]
  ------------------
  606|      0|                                        {
  607|      0|                                            return OpCode::SLTU;
  608|      0|                                        }
  609|      0|                                        break;
  610|      5|                                }
  611|       |
  612|      5|                            case 'N':
  ------------------
  |  Branch (612:29): [True: 0, False: 480]
  ------------------
  613|      5|                            case 'n':
  ------------------
  |  Branch (613:29): [True: 0, False: 480]
  ------------------
  614|      5|                                if (ice(c3, 'E'))
  ------------------
  |  Branch (614:37): [True: 1, False: 4]
  ------------------
  615|      1|                                {
  616|      1|                                    if (ice(c4, 'I'))
  ------------------
  |  Branch (616:41): [True: 0, False: 1]
  ------------------
  617|      0|                                    {
  618|      0|                                        return OpCode::SNEI;
  619|      0|                                    }
  620|      1|                                    else if (ice(c4, 'U'))
  ------------------
  |  Branch (620:46): [True: 0, False: 1]
  ------------------
  621|      0|                                    {
  622|      0|                                        return OpCode::SNEU;
  623|      0|                                    }
  624|      1|                                }
  625|      5|                                break;
  626|       |
  627|      5|                            case 'R':
  ------------------
  |  Branch (627:29): [True: 0, False: 480]
  ------------------
  628|      0|                            case 'r':
  ------------------
  |  Branch (628:29): [True: 0, False: 480]
  ------------------
  629|      0|                                if (ice(c3, 'A') && ice(c4, 'I'))
  ------------------
  |  Branch (629:37): [True: 0, False: 0]
  |  Branch (629:37): [True: 0, False: 0]
  |  Branch (629:53): [True: 0, False: 0]
  ------------------
  630|      0|                                {
  631|      0|                                    return OpCode::SRAI;
  632|      0|                                }
  633|      0|                                else if (ice(c3, 'L') && ice(c4, 'I'))
  ------------------
  |  Branch (633:42): [True: 0, False: 0]
  |  Branch (633:42): [True: 0, False: 0]
  |  Branch (633:58): [True: 0, False: 0]
  ------------------
  634|      0|                                {
  635|      0|                                    return OpCode::SRLI;
  636|      0|                                }
  637|      0|                                break;
  638|       |
  639|      0|                            case 'U':
  ------------------
  |  Branch (639:29): [True: 0, False: 480]
  ------------------
  640|      0|                            case 'u':
  ------------------
  |  Branch (640:29): [True: 0, False: 480]
  ------------------
  641|      0|                                if (ice(c3, 'B'))
  ------------------
  |  Branch (641:37): [True: 0, False: 0]
  ------------------
  642|      0|                                {
  643|      0|                                    switch (c4)
  ------------------
  |  Branch (643:45): [True: 0, False: 0]
  ------------------
  644|      0|                                    {
  645|      0|                                        case 'D':
  ------------------
  |  Branch (645:41): [True: 0, False: 0]
  ------------------
  646|      0|                                        case 'd':
  ------------------
  |  Branch (646:41): [True: 0, False: 0]
  ------------------
  647|      0|                                            return OpCode::SUBD;
  648|       |
  649|      0|                                        case 'F':
  ------------------
  |  Branch (649:41): [True: 0, False: 0]
  ------------------
  650|      0|                                        case 'f':
  ------------------
  |  Branch (650:41): [True: 0, False: 0]
  ------------------
  651|      0|                                            return OpCode::SUBF;
  652|       |
  653|      0|                                        case 'I':
  ------------------
  |  Branch (653:41): [True: 0, False: 0]
  ------------------
  654|      0|                                        case 'i':
  ------------------
  |  Branch (654:41): [True: 0, False: 0]
  ------------------
  655|      0|                                            return OpCode::SUBI;
  656|       |
  657|      0|                                        case 'U':
  ------------------
  |  Branch (657:41): [True: 0, False: 0]
  ------------------
  658|      0|                                        case 'u':
  ------------------
  |  Branch (658:41): [True: 0, False: 0]
  ------------------
  659|      0|                                            return OpCode::SUBU;
  660|      0|                                    }
  661|      0|                                }
  662|      0|                                break;
  663|    480|                        }
  664|    480|                        break;
  665|       |
  666|    480|                    case 'T':
  ------------------
  |  Branch (666:21): [True: 13, False: 5.82k]
  ------------------
  667|     23|                    case 't':
  ------------------
  |  Branch (667:21): [True: 10, False: 5.83k]
  ------------------
  668|     23|                        if (ice(c2, 'R') && ice(c3, 'A') && ice(c4, 'P'))
  ------------------
  |  Branch (668:29): [True: 2, False: 21]
  |  Branch (668:29): [True: 0, False: 23]
  |  Branch (668:45): [True: 0, False: 2]
  |  Branch (668:61): [True: 0, False: 0]
  ------------------
  669|      0|                        {
  670|      0|                            return OpCode::TRAP;
  671|      0|                        }
  672|     23|                        break;
  673|     23|                    case 'X':
  ------------------
  |  Branch (673:21): [True: 13, False: 5.82k]
  ------------------
  674|     27|                    case 'x':
  ------------------
  |  Branch (674:21): [True: 14, False: 5.82k]
  ------------------
  675|     27|                        if (ice(c2, 'O') && ice(c3, 'R') && ice(c4, 'I'))
  ------------------
  |  Branch (675:29): [True: 0, False: 27]
  |  Branch (675:29): [True: 0, False: 27]
  |  Branch (675:45): [True: 0, False: 0]
  |  Branch (675:61): [True: 0, False: 0]
  ------------------
  676|      0|                        {
  677|      0|                            return OpCode::XORI;
  678|      0|                        }
  679|     27|                        break;
  680|  5.84k|                }
  681|  5.84k|                break;
  682|  5.84k|            }
  683|       |
  684|       |            // 5 character OpCodes
  685|  5.84k|            case 5: {
  ------------------
  |  Branch (685:13): [True: 2.81k, False: 69.7k]
  ------------------
  686|  2.81k|                const char c1 = token[0u];
  687|  2.81k|                const char c2 = token[1u];
  688|  2.81k|                const char c3 = token[2u];
  689|  2.81k|                const char c4 = token[3u];
  690|  2.81k|                const char c5 = token[4u];
  691|       |
  692|  2.81k|                switch (c1)
  ------------------
  |  Branch (692:25): [True: 1.87k, False: 940]
  ------------------
  693|  2.81k|                {
  694|    117|                    case 'A':
  ------------------
  |  Branch (694:21): [True: 117, False: 2.69k]
  ------------------
  695|    256|                    case 'a':
  ------------------
  |  Branch (695:21): [True: 139, False: 2.67k]
  ------------------
  696|    256|                        if (ice(c2, 'D') && ice(c3, 'D') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (696:29): [True: 0, False: 256]
  |  Branch (696:29): [True: 0, False: 256]
  |  Branch (696:45): [True: 0, False: 0]
  |  Branch (696:61): [True: 0, False: 0]
  |  Branch (696:77): [True: 0, False: 0]
  ------------------
  697|      0|                        {
  698|      0|                            return OpCode::ADDUI;
  699|      0|                        }
  700|    256|                        break;
  701|       |
  702|    256|                    case 'D':
  ------------------
  |  Branch (702:21): [True: 205, False: 2.61k]
  ------------------
  703|    205|                    case 'd':
  ------------------
  |  Branch (703:21): [True: 0, False: 2.81k]
  ------------------
  704|    205|                        if (ice(c2, 'I') && ice(c3, 'V') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (704:29): [True: 0, False: 205]
  |  Branch (704:29): [True: 0, False: 205]
  |  Branch (704:45): [True: 0, False: 0]
  |  Branch (704:61): [True: 0, False: 0]
  |  Branch (704:77): [True: 0, False: 0]
  ------------------
  705|      0|                        {
  706|      0|                            return OpCode::DIVUI;
  707|      0|                        }
  708|    205|                        break;
  709|       |
  710|    205|                    case 'M':
  ------------------
  |  Branch (710:21): [True: 2, False: 2.81k]
  ------------------
  711|     50|                    case 'm':
  ------------------
  |  Branch (711:21): [True: 48, False: 2.76k]
  ------------------
  712|     50|                        if (ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T'))
  ------------------
  |  Branch (712:29): [True: 0, False: 50]
  |  Branch (712:29): [True: 0, False: 50]
  |  Branch (712:45): [True: 0, False: 0]
  |  Branch (712:61): [True: 0, False: 0]
  ------------------
  713|      0|                        {
  714|      0|                            switch (c5)
  ------------------
  |  Branch (714:37): [True: 0, False: 0]
  ------------------
  715|      0|                            {
  716|      0|                                case 'D':
  ------------------
  |  Branch (716:33): [True: 0, False: 0]
  ------------------
  717|      0|                                case 'd':
  ------------------
  |  Branch (717:33): [True: 0, False: 0]
  ------------------
  718|      0|                                    return OpCode::MULTD;
  719|       |
  720|      0|                                case 'F':
  ------------------
  |  Branch (720:33): [True: 0, False: 0]
  ------------------
  721|      0|                                case 'f':
  ------------------
  |  Branch (721:33): [True: 0, False: 0]
  ------------------
  722|      0|                                    return OpCode::MULTF;
  723|       |
  724|      0|                                case 'I':
  ------------------
  |  Branch (724:33): [True: 0, False: 0]
  ------------------
  725|      0|                                case 'i':
  ------------------
  |  Branch (725:33): [True: 0, False: 0]
  ------------------
  726|      0|                                    return OpCode::MULTI;
  727|       |
  728|      0|                                case 'U':
  ------------------
  |  Branch (728:33): [True: 0, False: 0]
  ------------------
  729|      0|                                case 'u':
  ------------------
  |  Branch (729:33): [True: 0, False: 0]
  ------------------
  730|      0|                                    return OpCode::MULTU;
  731|      0|                            }
  732|      0|                        }
  733|     50|                        break;
  734|       |
  735|     50|                    case 'S':
  ------------------
  |  Branch (735:21): [True: 7, False: 2.80k]
  ------------------
  736|    429|                    case 's':
  ------------------
  |  Branch (736:21): [True: 422, False: 2.39k]
  ------------------
  737|    429|                        switch (c2)
  ------------------
  |  Branch (737:33): [True: 404, False: 25]
  ------------------
  738|    429|                        {
  739|      0|                            case 'E':
  ------------------
  |  Branch (739:29): [True: 0, False: 429]
  ------------------
  740|      1|                            case 'e':
  ------------------
  |  Branch (740:29): [True: 1, False: 428]
  ------------------
  741|      1|                                if (ice(c3, 'Q') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (741:37): [True: 0, False: 1]
  |  Branch (741:37): [True: 0, False: 1]
  |  Branch (741:53): [True: 0, False: 0]
  |  Branch (741:69): [True: 0, False: 0]
  ------------------
  742|      0|                                {
  743|      0|                                    return OpCode::SEQUI;
  744|      0|                                }
  745|      1|                                break;
  746|       |
  747|      1|                            case 'G':
  ------------------
  |  Branch (747:29): [True: 1, False: 428]
  ------------------
  748|     22|                            case 'g':
  ------------------
  |  Branch (748:29): [True: 21, False: 408]
  ------------------
  749|     22|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (749:37): [True: 0, False: 22]
  |  Branch (749:37): [True: 0, False: 22]
  |  Branch (749:53): [True: 0, False: 0]
  |  Branch (749:69): [True: 0, False: 0]
  ------------------
  750|      0|                                {
  751|      0|                                    return OpCode::SGEUI;
  752|      0|                                }
  753|     22|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (753:42): [True: 0, False: 22]
  |  Branch (753:42): [True: 0, False: 22]
  |  Branch (753:58): [True: 0, False: 0]
  |  Branch (753:74): [True: 0, False: 0]
  ------------------
  754|      0|                                {
  755|      0|                                    return OpCode::SGTUI;
  756|      0|                                }
  757|     22|                                break;
  758|       |
  759|     22|                            case 'L':
  ------------------
  |  Branch (759:29): [True: 0, False: 429]
  ------------------
  760|      2|                            case 'l':
  ------------------
  |  Branch (760:29): [True: 2, False: 427]
  ------------------
  761|      2|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (761:37): [True: 1, False: 1]
  |  Branch (761:37): [True: 0, False: 2]
  |  Branch (761:53): [True: 0, False: 1]
  |  Branch (761:69): [True: 0, False: 0]
  ------------------
  762|      0|                                {
  763|      0|                                    return OpCode::SLEUI;
  764|      0|                                }
  765|      2|                                else if (ice(c3, 'T') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (765:42): [True: 0, False: 2]
  |  Branch (765:42): [True: 0, False: 2]
  |  Branch (765:58): [True: 0, False: 0]
  |  Branch (765:74): [True: 0, False: 0]
  ------------------
  766|      0|                                {
  767|      0|                                    return OpCode::SLTUI;
  768|      0|                                }
  769|      2|                                break;
  770|       |
  771|      2|                            case 'N':
  ------------------
  |  Branch (771:29): [True: 0, False: 429]
  ------------------
  772|      0|                            case 'n':
  ------------------
  |  Branch (772:29): [True: 0, False: 429]
  ------------------
  773|      0|                                if (ice(c3, 'E') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (773:37): [True: 0, False: 0]
  |  Branch (773:37): [True: 0, False: 0]
  |  Branch (773:53): [True: 0, False: 0]
  |  Branch (773:69): [True: 0, False: 0]
  ------------------
  774|      0|                                {
  775|      0|                                    return OpCode::SNEUI;
  776|      0|                                }
  777|      0|                                break;
  778|       |
  779|      0|                            case 'U':
  ------------------
  |  Branch (779:29): [True: 0, False: 429]
  ------------------
  780|      0|                            case 'u':
  ------------------
  |  Branch (780:29): [True: 0, False: 429]
  ------------------
  781|      0|                                if (ice(c3, 'B') && ice(c4, 'U') && ice(c5, 'I'))
  ------------------
  |  Branch (781:37): [True: 0, False: 0]
  |  Branch (781:37): [True: 0, False: 0]
  |  Branch (781:53): [True: 0, False: 0]
  |  Branch (781:69): [True: 0, False: 0]
  ------------------
  782|      0|                                {
  783|      0|                                    return OpCode::SUBUI;
  784|      0|                                }
  785|      0|                                break;
  786|    429|                        }
  787|       |
  788|    429|                        break;
  789|  2.81k|                }
  790|       |
  791|  2.81k|                break;
  792|  2.81k|            }
  793|       |
  794|       |            // 6 character OpCodes
  795|  2.81k|            case 6: {
  ------------------
  |  Branch (795:13): [True: 1.81k, False: 70.7k]
  ------------------
  796|  1.81k|                const char c1 = token[0u];
  797|  1.81k|                const char c2 = token[1u];
  798|  1.81k|                const char c3 = token[2u];
  799|  1.81k|                const char c4 = token[3u];
  800|  1.81k|                const char c5 = token[4u];
  801|  1.81k|                const char c6 = token[5u];
  802|       |
  803|  1.81k|                if (ice(c1, 'C') && ice(c2, 'V') && ice(c3, 'T'))
  ------------------
  |  Branch (803:21): [True: 99, False: 1.71k]
  |  Branch (803:21): [True: 0, False: 1.81k]
  |  Branch (803:37): [True: 0, False: 99]
  |  Branch (803:53): [True: 0, False: 0]
  ------------------
  804|      0|                {
  805|      0|                    switch (c4)
  ------------------
  |  Branch (805:29): [True: 0, False: 0]
  ------------------
  806|      0|                    {
  807|      0|                        case 'D':
  ------------------
  |  Branch (807:25): [True: 0, False: 0]
  ------------------
  808|      0|                        case 'd':
  ------------------
  |  Branch (808:25): [True: 0, False: 0]
  ------------------
  809|      0|                            if (c5 == '2')
  ------------------
  |  Branch (809:33): [True: 0, False: 0]
  ------------------
  810|      0|                            {
  811|      0|                                if (ice(c6, 'F'))
  ------------------
  |  Branch (811:37): [True: 0, False: 0]
  ------------------
  812|      0|                                {
  813|      0|                                    return OpCode::CVTD2F;
  814|      0|                                }
  815|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (815:42): [True: 0, False: 0]
  ------------------
  816|      0|                                {
  817|      0|                                    return OpCode::CVTD2I;
  818|      0|                                }
  819|      0|                            }
  820|      0|                            break;
  821|       |
  822|      0|                        case 'F':
  ------------------
  |  Branch (822:25): [True: 0, False: 0]
  ------------------
  823|      0|                        case 'f':
  ------------------
  |  Branch (823:25): [True: 0, False: 0]
  ------------------
  824|      0|                            if (c5 == '2')
  ------------------
  |  Branch (824:33): [True: 0, False: 0]
  ------------------
  825|      0|                            {
  826|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (826:37): [True: 0, False: 0]
  ------------------
  827|      0|                                {
  828|      0|                                    return OpCode::CVTF2D;
  829|      0|                                }
  830|      0|                                else if (ice(c6, 'I'))
  ------------------
  |  Branch (830:42): [True: 0, False: 0]
  ------------------
  831|      0|                                {
  832|      0|                                    return OpCode::CVTF2I;
  833|      0|                                }
  834|      0|                            }
  835|      0|                            break;
  836|       |
  837|      0|                        case 'I':
  ------------------
  |  Branch (837:25): [True: 0, False: 0]
  ------------------
  838|      0|                        case 'i':
  ------------------
  |  Branch (838:25): [True: 0, False: 0]
  ------------------
  839|      0|                            if (c5 == '2')
  ------------------
  |  Branch (839:33): [True: 0, False: 0]
  ------------------
  840|      0|                            {
  841|      0|                                if (ice(c6, 'D'))
  ------------------
  |  Branch (841:37): [True: 0, False: 0]
  ------------------
  842|      0|                                {
  843|      0|                                    return OpCode::CVTI2D;
  844|      0|                                }
  845|      0|                                else if (ice(c6, 'F'))
  ------------------
  |  Branch (845:42): [True: 0, False: 0]
  ------------------
  846|      0|                                {
  847|      0|                                    return OpCode::CVTI2F;
  848|      0|                                }
  849|      0|                            }
  850|      0|                    }
  851|      0|                }
  852|  1.81k|                else if (ice(c1, 'M') && ice(c2, 'U') && ice(c3, 'L') && ice(c4, 'T') &&
  ------------------
  |  Branch (852:26): [True: 36, False: 1.78k]
  |  Branch (852:26): [True: 0, False: 1.81k]
  |  Branch (852:42): [True: 0, False: 36]
  |  Branch (852:58): [True: 0, False: 0]
  |  Branch (852:74): [True: 0, False: 0]
  ------------------
  853|  1.81k|                         ice(c5, 'U') && ice(c6, 'I'))
  ------------------
  |  Branch (853:26): [True: 0, False: 0]
  |  Branch (853:42): [True: 0, False: 0]
  ------------------
  854|      0|                {
  855|      0|                    return OpCode::MULTUI;
  856|      0|                }
  857|  1.81k|                break;
  858|  1.81k|            }
  859|       |
  860|       |            // 7 character OpCodes
  861|  1.93k|            case 7: {
  ------------------
  |  Branch (861:13): [True: 1.93k, False: 70.6k]
  ------------------
  862|  1.93k|                const char c1 = token[0u];
  863|  1.93k|                const char c2 = token[1u];
  864|  1.93k|                const char c3 = token[2u];
  865|  1.93k|                const char c4 = token[3u];
  866|  1.93k|                const char c5 = token[4u];
  867|  1.93k|                const char c6 = token[5u];
  868|  1.93k|                const char c7 = token[6u];
  869|       |
  870|  1.93k|                if (ice(c1, 'M') && ice(c2, 'O') && ice(c3, 'V'))
  ------------------
  |  Branch (870:21): [True: 13, False: 1.92k]
  |  Branch (870:21): [True: 0, False: 1.93k]
  |  Branch (870:37): [True: 0, False: 13]
  |  Branch (870:53): [True: 0, False: 0]
  ------------------
  871|      0|                {
  872|      0|                    if (ice(c4, 'I') && c5 == '2' && ice(c6, 'F') && ice(c7, 'P'))
  ------------------
  |  Branch (872:25): [True: 0, False: 0]
  |  Branch (872:25): [True: 0, False: 0]
  |  Branch (872:41): [True: 0, False: 0]
  |  Branch (872:54): [True: 0, False: 0]
  |  Branch (872:70): [True: 0, False: 0]
  ------------------
  873|      0|                    {
  874|      0|                        return OpCode::MOVI2FP;
  875|      0|                    }
  876|      0|                    if (ice(c4, 'F') && ice(c5, 'P') && c6 == '2' && ice(c7, 'I'))
  ------------------
  |  Branch (876:25): [True: 0, False: 0]
  |  Branch (876:25): [True: 0, False: 0]
  |  Branch (876:41): [True: 0, False: 0]
  |  Branch (876:57): [True: 0, False: 0]
  |  Branch (876:70): [True: 0, False: 0]
  ------------------
  877|      0|                    {
  878|      0|                        return OpCode::MOVFP2I;
  879|      0|                    }
  880|      0|                }
  881|  1.93k|                break;
  882|  1.93k|            }
  883|       |
  884|  9.38k|            default: {
  ------------------
  |  Branch (884:13): [True: 9.38k, False: 63.2k]
  ------------------
  885|  9.38k|                break;
  886|  1.93k|            }
  887|  72.6k|        }
  888|       |
  889|       |        // None found
  890|  68.1k|        return OpCode::NONE;
  891|  72.6k|    }
_ZN3dlx3iceEcc:
   16|  26.1k|    {
   17|  26.1k|        constexpr const char diff = 'a' - 'A';
   18|  26.1k|        return (c == t) || (c == t + diff);
  ------------------
  |  Branch (18:16): [True: 4.11k, False: 22.0k]
  |  Branch (18:28): [True: 632, False: 21.4k]
  ------------------
   19|  26.1k|    }

_ZN3dlx10ParseErrorC2Ev:
   18|   134k|    {}
_ZNK3dlx10ParseError13GetLineNumberEv:
   26|   134k|    {
   27|   134k|        return m_LineNumber;
   28|   134k|    }
_ZNK3dlx10ParseError16ConstructMessageEv:
   41|   134k|    {
   42|   134k|        switch (m_Type)
   43|   134k|        {
   44|      9|            case Type::UnexpectedArgumentType: {
  ------------------
  |  Branch (44:13): [True: 9, False: 134k]
  ------------------
   45|      9|                const UnexpectedArgumentType& detail = GetUnexpectedArgumentType();
   46|       |
   47|      9|                return fmt::format("Expected {:s} but got {:s}",
   48|      9|                                   dlx::enum_name(detail.expected_type).data(),
   49|      9|                                   dlx::enum_name(detail.actual_type).data());
   50|      0|            }
   51|       |
   52|      0|            case Type::InvalidNumber: {
  ------------------
  |  Branch (52:13): [True: 0, False: 134k]
  ------------------
   53|      0|                const InvalidNumber& detail = GetInvalidNumber();
   54|       |
   55|      0|                return fmt::format("'{:s}' is not a valid number", detail.text.data());
   56|      0|            }
   57|       |
   58|      0|            case Type::TooFewArgumentsAddressDisplacement: {
  ------------------
  |  Branch (58:13): [True: 0, False: 134k]
  ------------------
   59|      0|                return fmt::format("Not enough arguments left to parse address displacement");
   60|      0|            }
   61|       |
   62|  81.5k|            case Type::UnexpectedToken: {
  ------------------
  |  Branch (62:13): [True: 81.5k, False: 52.6k]
  ------------------
   63|  81.5k|                const UnexpectedToken& detail = GetUnexpectedToken();
   64|       |
   65|  81.5k|                return fmt::format("Expected token of type {:s} but got {:s}",
   66|  81.5k|                                   dlx::enum_name(detail.expected_type).data(),
   67|  81.5k|                                   dlx::enum_name(detail.actual_type).data());
   68|      0|            }
   69|       |
   70|  3.37k|            case Type::ReservedIdentifier: {
  ------------------
  |  Branch (70:13): [True: 3.37k, False: 130k]
  ------------------
   71|  3.37k|                const ReservedIdentifier& detail = GetReserverIdentifier();
   72|       |
   73|  3.37k|                return fmt::format("'{:s}' is a reserved identifier", detail.identifier.data());
   74|      0|            }
   75|       |
   76|  36.9k|            case Type::InvalidLabelIdentifier: {
  ------------------
  |  Branch (76:13): [True: 36.9k, False: 97.1k]
  ------------------
   77|  36.9k|                const InvalidLabelIdentifier& detail = GetInvalidLabelIdentifier();
   78|       |
   79|  36.9k|                return fmt::format("'{:s}' is not a valid label identifier",
   80|  36.9k|                                   detail.identifier.data());
   81|      0|            }
   82|       |
   83|  8.11k|            case Type::LabelAlreadyDefined: {
  ------------------
  |  Branch (83:13): [True: 8.11k, False: 125k]
  ------------------
   84|  8.11k|                const LabelAlreadyDefined& detail = GetLabelAlreadyDefined();
   85|       |
   86|  8.11k|                return fmt::format("Label '{:s}' was already defined at {:d}:{:d}",
   87|  8.11k|                                   detail.label_name.data(), detail.at_line, detail.at_column);
   88|      0|            }
   89|       |
   90|  3.23k|            case Type::OneInstructionPerLine: {
  ------------------
  |  Branch (90:13): [True: 3.23k, False: 130k]
  ------------------
   91|  3.23k|                return fmt::format("You may only place one instruction per line");
   92|      0|            }
   93|       |
   94|    189|            case Type::TooFewArgument: {
  ------------------
  |  Branch (94:13): [True: 189, False: 133k]
  ------------------
   95|    189|                const TooFewArguments& detail = GetTooFewArguments();
   96|       |
   97|    189|                return fmt::format(
   98|    189|                        "Not enough arguments provided. Required {:d}, provided only {:d}",
   99|    189|                        detail.required, detail.provided);
  100|      0|            }
  101|       |
  102|    718|            case Type::EmptyLabel: {
  ------------------
  |  Branch (102:13): [True: 718, False: 133k]
  ------------------
  103|    718|                const EmptyLabel& detail = GetEmptyLabel();
  104|       |
  105|    718|                return fmt::format("Label '{:s}' does not have any instruction",
  106|    718|                                   detail.label_name.data());
  107|      0|            }
  108|       |
  109|     14|            case Type::TooManyComma: {
  ------------------
  |  Branch (109:13): [True: 14, False: 134k]
  ------------------
  110|     14|                return fmt::format("Only one comma is allowed");
  111|      0|            }
  112|       |
  113|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  114|      0|            default:
  ------------------
  |  Branch (114:13): [True: 0, False: 134k]
  ------------------
  115|      0|                PHI_ASSERT_NOT_REACHED();
  116|   134k|#endif
  117|   134k|        }
  118|   134k|    }
_ZNK3dlx10ParseError25GetUnexpectedArgumentTypeEv:
  124|      9|    {
  125|      9|        PHI_ASSERT(m_Type == Type::UnexpectedArgumentType);
  126|       |
  127|      9|        return unexpected_argument_type;
  128|      9|    }
_ZNK3dlx10ParseError18GetUnexpectedTokenEv:
  138|  81.5k|    {
  139|  81.5k|        PHI_ASSERT(m_Type == Type::UnexpectedToken);
  140|       |
  141|  81.5k|        return unexpected_token;
  142|  81.5k|    }
_ZNK3dlx10ParseError21GetReserverIdentifierEv:
  146|  3.37k|    {
  147|  3.37k|        PHI_ASSERT(m_Type == Type::ReservedIdentifier);
  148|       |
  149|  3.37k|        return reserved_identifier;
  150|  3.37k|    }
_ZNK3dlx10ParseError25GetInvalidLabelIdentifierEv:
  153|  36.9k|    {
  154|  36.9k|        PHI_ASSERT(m_Type == Type::InvalidLabelIdentifier);
  155|       |
  156|  36.9k|        return invalid_label_identifier;
  157|  36.9k|    }
_ZNK3dlx10ParseError22GetLabelAlreadyDefinedEv:
  160|  8.11k|    {
  161|  8.11k|        PHI_ASSERT(m_Type == Type::LabelAlreadyDefined);
  162|       |
  163|  8.11k|        return label_already_defined;
  164|  8.11k|    }
_ZNK3dlx10ParseError18GetTooFewArgumentsEv:
  167|    189|    {
  168|    189|        PHI_ASSERT(m_Type == Type::TooFewArgument);
  169|       |
  170|    189|        return too_few_arguments;
  171|    189|    }
_ZNK3dlx10ParseError13GetEmptyLabelEv:
  174|    718|    {
  175|    718|        PHI_ASSERT(m_Type == Type::EmptyLabel);
  176|       |
  177|    718|        return empty_label;
  178|    718|    }
_ZN3dlx41ConstructUnexpectedArgumentTypeParseErrorEmmNS_12ArgumentTypeES0_:
  186|      9|    {
  187|      9|        ParseError err;
  188|       |
  189|      9|        err.m_Type                                 = ParseError::Type::UnexpectedArgumentType;
  190|      9|        err.m_LineNumber                           = line_number;
  191|      9|        err.m_Column                               = column;
  192|      9|        err.unexpected_argument_type.expected_type = expected_type;
  193|      9|        err.unexpected_argument_type.actual_type   = actual_type;
  194|       |
  195|      9|        return err;
  196|      9|    }
_ZN3dlx41ConstructUnexpectedArgumentTypeParseErrorERKNS_5TokenENS_12ArgumentTypeES3_:
  201|      9|    {
  202|      9|        return ConstructUnexpectedArgumentTypeParseError(token.GetLineNumber().unsafe(),
  203|      9|                                                         token.GetColumn().unsafe(), expected_type,
  204|      9|                                                         actual_type);
  205|      9|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorEmmNS_5Token4TypeES1_:
  247|  81.5k|    {
  248|  81.5k|        ParseError err;
  249|       |
  250|  81.5k|        err.m_Type                         = ParseError::Type::UnexpectedToken;
  251|  81.5k|        err.m_LineNumber                   = line_number;
  252|  81.5k|        err.m_Column                       = column;
  253|  81.5k|        err.unexpected_token.expected_type = expected_type;
  254|  81.5k|        err.unexpected_token.actual_type   = actual_type;
  255|       |
  256|  81.5k|        return err;
  257|  81.5k|    }
_ZN3dlx34ConstructUnexpectedTokenParseErrorERKNS_5TokenENS0_4TypeE:
  261|  81.5k|    {
  262|  81.5k|        return ConstructUnexpectedTokenParseError(token.GetLineNumber().unsafe(),
  263|  81.5k|                                                  token.GetColumn().unsafe(), expected_type,
  264|  81.5k|                                                  token.GetType());
  265|  81.5k|    }
_ZN3dlx37ConstructReservedIdentifierParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  270|  3.37k|    {
  271|  3.37k|        ParseError err;
  272|       |
  273|  3.37k|        err.m_Type                         = ParseError::Type::ReservedIdentifier;
  274|  3.37k|        err.m_LineNumber                   = line_number;
  275|  3.37k|        err.m_Column                       = column;
  276|  3.37k|        err.reserved_identifier.identifier = identifier;
  277|       |
  278|  3.37k|        return err;
  279|  3.37k|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  290|  36.9k|    {
  291|  36.9k|        ParseError err;
  292|       |
  293|  36.9k|        err.m_Type                              = ParseError::Type::InvalidLabelIdentifier;
  294|  36.9k|        err.m_LineNumber                        = line_number;
  295|  36.9k|        err.m_Column                            = column;
  296|  36.9k|        err.invalid_label_identifier.identifier = identifier;
  297|       |
  298|  36.9k|        return err;
  299|  36.9k|    }
_ZN3dlx41ConstructInvalidLabelIdentifierParseErrorERKNS_5TokenE:
  302|  36.9k|    {
  303|  36.9k|        return ConstructInvalidLabelIdentifierParseError(
  304|  36.9k|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText());
  305|  36.9k|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEEmm:
  312|  8.11k|    {
  313|  8.11k|        ParseError err;
  314|       |
  315|  8.11k|        err.m_Type                           = ParseError::Type::LabelAlreadyDefined;
  316|  8.11k|        err.m_LineNumber                     = line_number;
  317|  8.11k|        err.m_Column                         = column;
  318|  8.11k|        err.label_already_defined.label_name = label_name;
  319|  8.11k|        err.label_already_defined.at_line    = at_line;
  320|  8.11k|        err.label_already_defined.at_column  = at_column;
  321|       |
  322|  8.11k|        return err;
  323|  8.11k|    }
_ZN3dlx38ConstructLabelAlreadyDefinedParseErrorERKNS_5TokenES2_:
  327|  8.11k|    {
  328|  8.11k|        return ConstructLabelAlreadyDefinedParseError(
  329|  8.11k|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(), token.GetText(),
  330|  8.11k|                first_definition.GetLineNumber().unsafe(), first_definition.GetColumn().unsafe());
  331|  8.11k|    }
_ZN3dlx40ConstructOneInstructionPerLineParseErrorEmm:
  335|  3.23k|    {
  336|  3.23k|        ParseError err;
  337|       |
  338|  3.23k|        err.m_Type       = ParseError::Type::OneInstructionPerLine;
  339|  3.23k|        err.m_LineNumber = line_number;
  340|  3.23k|        err.m_Column     = column;
  341|       |
  342|  3.23k|        return err;
  343|  3.23k|    }
_ZN3dlx40ConstructOneInstructionPerLineParseErrorERKNS_5TokenE:
  346|  3.23k|    {
  347|  3.23k|        return ConstructOneInstructionPerLineParseError(token.GetLineNumber().unsafe(),
  348|  3.23k|                                                        token.GetColumn().unsafe());
  349|  3.23k|    }
_ZN3dlx34ConstructTooFewArgumentsParseErrorEmmhh:
  354|    189|    {
  355|    189|        ParseError err;
  356|       |
  357|    189|        err.m_Type                     = ParseError::Type::TooFewArgument;
  358|    189|        err.m_LineNumber               = line_number;
  359|    189|        err.m_Column                   = column;
  360|    189|        err.too_few_arguments.required = required;
  361|    189|        err.too_few_arguments.provided = provided;
  362|       |
  363|    189|        return err;
  364|    189|    }
_ZN3dlx34ConstructTooFewArgumentsParseErrorERKNS_5TokenEhh:
  368|    189|    {
  369|    189|        return ConstructTooFewArgumentsParseError(token.GetLineNumber().unsafe(),
  370|    189|                                                  token.GetColumn().unsafe(), required, provided);
  371|    189|    }
_ZN3dlx29ConstructEmptyLabelParseErrorEmmN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  375|    718|    {
  376|    718|        ParseError err;
  377|       |
  378|    718|        err.m_Type                 = ParseError::Type::EmptyLabel;
  379|    718|        err.m_LineNumber           = line_number;
  380|    718|        err.m_Column               = column;
  381|    718|        err.empty_label.label_name = label_name;
  382|       |
  383|    718|        return err;
  384|    718|    }
_ZN3dlx29ConstructEmptyLabelParseErrorERKNS_5TokenE:
  387|    718|    {
  388|    718|        return ConstructEmptyLabelParseError(
  389|    718|                token.GetLineNumber().unsafe(), token.GetColumn().unsafe(),
  390|    718|                (token.GetText().back() == ':') ?
  ------------------
  |  Branch (390:17): [True: 443, False: 275]
  ------------------
  391|    443|                        token.GetText().substring_view(0u, token.GetText().length() - 1u) :
  392|    718|                        token.GetText());
  393|    718|    }
_ZN3dlx31ConstructTooManyCommaParseErrorEmm:
  397|     14|    {
  398|     14|        ParseError err;
  399|       |
  400|     14|        err.m_Type       = ParseError::Type::TooManyComma;
  401|     14|        err.m_LineNumber = line_number;
  402|     14|        err.m_Column     = column;
  403|       |
  404|     14|        return err;
  405|     14|    }
_ZN3dlx31ConstructTooManyCommaParseErrorERKNS_5TokenE:
  408|     14|    {
  409|     14|        return ConstructTooManyCommaParseError(token.GetLineNumber().unsafe(),
  410|     14|                                               token.GetColumn().unsafe());
  411|     14|    }

_ZN3dlx13ParsedProgram13AddParseErrorEONS_10ParseErrorE:
   16|   134k|    {
   17|   134k|        m_ParseErrors.emplace_back(phi::move(error));
   18|   134k|    }
_ZNK3dlx13ParsedProgram7IsValidEv:
   21|  21.9k|    {
   22|  21.9k|        return m_ParseErrors.empty() && !m_Instructions.empty();
  ------------------
  |  Branch (22:16): [True: 14.5k, False: 7.41k]
  |  Branch (22:41): [True: 64, False: 14.5k]
  ------------------
   23|  21.9k|    }

_ZN3dlx6Parser5ParseERNS_11TokenStreamE:
  179|  3.55k|    {
  180|  3.55k|        ParsedProgram program;
  181|       |
  182|  3.55k|        program.m_Tokens = tokens;
  183|       |
  184|  3.55k|        phi::boolean line_has_instruction{false};
  185|  3.55k|        phi::usize   label_count{0u};
  186|       |
  187|   141k|        while (tokens.has_more())
  ------------------
  |  Branch (187:16): [True: 138k, False: 3.55k]
  ------------------
  188|   138k|        {
  189|   138k|            const Token& current_token = tokens.consume();
  190|       |
  191|       |            //DLX_INFO("Parsing '{}'", current_token.DebugInfo());
  192|       |
  193|   138k|            switch (current_token.GetType())
  194|   138k|            {
  195|       |                // Ignore comments
  196|    163|                case Token::Type::Comment:
  ------------------
  |  Branch (196:17): [True: 163, False: 138k]
  ------------------
  197|       |                    //DLX_DEBUG("Ignoring comment");
  198|    163|                    break;
  199|       |
  200|  3.93k|                case Token::Type::NewLine:
  ------------------
  |  Branch (200:17): [True: 3.93k, False: 134k]
  ------------------
  201|       |                    //DLX_DEBUG("Ignoring newline");
  202|  3.93k|                    line_has_instruction = false;
  203|  3.93k|                    break;
  204|       |
  205|  50.0k|                case Token::Type::LabelIdentifier: {
  ------------------
  |  Branch (205:17): [True: 50.0k, False: 88.2k]
  ------------------
  206|  50.0k|                    if (line_has_instruction)
  ------------------
  |  Branch (206:25): [True: 992, False: 49.0k]
  ------------------
  207|    992|                    {
  208|    992|                        program.AddParseError(ConstructUnexpectedTokenParseError(
  209|    992|                                current_token, Token::Type::NewLine));
  210|    992|                        break;
  211|    992|                    }
  212|       |
  213|       |                    // Handle jump labels
  214|       |                    // Check if the last character of the identifier is a colon
  215|  49.0k|                    if (current_token.GetText().back() != ':')
  ------------------
  |  Branch (215:25): [True: 28.1k, False: 20.9k]
  ------------------
  216|  28.1k|                    {
  217|  28.1k|                        program.AddParseError(
  218|  28.1k|                                ConstructInvalidLabelIdentifierParseError(current_token));
  219|  28.1k|                        break;
  220|  28.1k|                    }
  221|       |
  222|  20.9k|                    phi::string_view label_name = current_token.GetText();
  223|  20.9k|                    label_name.remove_suffix(1u);
  224|       |
  225|  20.9k|                    if (IsReservedIdentifier(label_name))
  ------------------
  |  Branch (225:25): [True: 3.37k, False: 17.5k]
  ------------------
  226|  3.37k|                    {
  227|  3.37k|                        program.AddParseError(ConstructReservedIdentifierParseError(
  228|  3.37k|                                current_token.GetLineNumber().unsafe(),
  229|  3.37k|                                current_token.GetColumn().unsafe(), label_name));
  230|  3.37k|                        break;
  231|  3.37k|                    }
  232|       |
  233|  17.5k|                    if (!IsValidIdentifier(label_name))
  ------------------
  |  Branch (233:25): [True: 8.70k, False: 8.86k]
  ------------------
  234|  8.70k|                    {
  235|  8.70k|                        program.AddParseError(
  236|  8.70k|                                ConstructInvalidLabelIdentifierParseError(current_token));
  237|  8.70k|                        break;
  238|  8.70k|                    }
  239|       |
  240|       |                    // Check if label was already defined
  241|  8.86k|                    if (program.m_JumpData.find(label_name) != program.m_JumpData.end())
  ------------------
  |  Branch (241:25): [True: 8.11k, False: 747]
  ------------------
  242|  8.11k|                    {
  243|       |                        // Find first defintions of label
  244|  8.11k|                        const Token* first_label_definition =
  245|  8.11k|                                tokens.find_first_token_if([&](const Token& t) {
  246|  8.11k|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  247|  8.11k|                                    {
  248|  8.11k|                                        phi::string_view token_label_name = t.GetText();
  249|  8.11k|                                        token_label_name.remove_suffix(1u);
  250|       |
  251|  8.11k|                                        if (token_label_name == label_name)
  252|  8.11k|                                        {
  253|  8.11k|                                            return true;
  254|  8.11k|                                        }
  255|  8.11k|                                    }
  256|       |
  257|  8.11k|                                    return false;
  258|  8.11k|                                });
  259|       |
  260|  8.11k|                        PHI_ASSERT(first_label_definition);
  261|       |
  262|  8.11k|                        program.AddParseError(ConstructLabelAlreadyDefinedParseError(
  263|  8.11k|                                current_token, *first_label_definition));
  264|  8.11k|                        break;
  265|  8.11k|                    }
  266|       |
  267|    747|                    program.m_JumpData[label_name] =
  268|    747|                            static_cast<phi::uint32_t>(program.m_Instructions.size());
  269|    747|                    label_count += 1u;
  270|       |
  271|       |                    //DLX_INFO("Added jump label {} -> {}", label_name,
  272|       |                    //             program.m_Instructions.size());
  273|       |
  274|    747|                    break;
  275|  8.86k|                }
  276|       |
  277|  3.73k|                case Token::Type::OpCode: {
  ------------------
  |  Branch (277:17): [True: 3.73k, False: 134k]
  ------------------
  278|  3.73k|                    if (line_has_instruction)
  ------------------
  |  Branch (278:25): [True: 3.23k, False: 502]
  ------------------
  279|  3.23k|                    {
  280|  3.23k|                        program.AddParseError(
  281|  3.23k|                                ConstructOneInstructionPerLineParseError(current_token));
  282|  3.23k|                        break;
  283|  3.23k|                    }
  284|       |
  285|    502|                    label_count = 0u;
  286|       |
  287|       |                    // Handle normal instructions
  288|    502|                    PHI_ASSERT(current_token.HasHint());
  289|    502|                    OpCode opcode = static_cast<OpCode>(current_token.GetHint());
  290|       |
  291|       |                    //DLX_INFO("Instruction opcode: {}", dlx::enum_name(opcode));
  292|       |
  293|    502|                    const InstructionInfo& info = LookUpInstructionInfo(opcode);
  294|       |
  295|       |                    // Make sure we got no problems here
  296|    502|                    PHI_ASSERT(info.GetArgumentType(0_u8) != ArgumentType::Unknown);
  297|    502|                    PHI_ASSERT(info.GetArgumentType(1_u8) != ArgumentType::Unknown);
  298|    502|                    PHI_ASSERT(info.GetArgumentType(2_u8) != ArgumentType::Unknown);
  299|    502|                    PHI_ASSERT(info.GetExecutor());
  300|       |
  301|    502|                    const phi::u8 number_of_argument_required = info.GetNumberOfRequiredArguments();
  302|       |                    //DLX_INFO("Instruction requires {} arguments",
  303|       |                    //             number_of_argument_required.unsafe());
  304|       |
  305|       |                    // Create instruction
  306|    502|                    Instruction  instruction(info, current_token.GetLineNumber());
  307|    502|                    phi::boolean consumed_comma{false};
  308|       |
  309|       |                    // Parse arguments
  310|    968|                    for (phi::u8 argument_num{0_u8}; argument_num < number_of_argument_required;)
  ------------------
  |  Branch (310:54): [True: 816, False: 152]
  ------------------
  311|    816|                    {
  312|       |                        // Get next token
  313|    816|                        if (!tokens.has_more())
  ------------------
  |  Branch (313:29): [True: 74, False: 742]
  ------------------
  314|     74|                        {
  315|     74|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  316|     74|                                    current_token, number_of_argument_required.unsafe(),
  317|     74|                                    argument_num.unsafe()));
  318|     74|                            break;
  319|     74|                        }
  320|       |
  321|    742|                        const Token& token = tokens.consume();
  322|       |
  323|       |                        // Skip commas
  324|    742|                        if (token.GetType() == Token::Type::Comma)
  ------------------
  |  Branch (324:29): [True: 314, False: 428]
  ------------------
  325|    314|                        {
  326|    314|                            if (consumed_comma)
  ------------------
  |  Branch (326:33): [True: 14, False: 300]
  ------------------
  327|     14|                            {
  328|     14|                                program.AddParseError(ConstructTooManyCommaParseError(token));
  329|     14|                            }
  330|       |
  331|    314|                            consumed_comma = true;
  332|       |                            //DLX_DEBUG("Skipping comma");
  333|    314|                            continue;
  334|    314|                        }
  335|       |
  336|    428|                        if (token.GetType() == Token::Type::NewLine)
  ------------------
  |  Branch (336:29): [True: 115, False: 313]
  ------------------
  337|    115|                        {
  338|    115|                            program.AddParseError(ConstructTooFewArgumentsParseError(
  339|    115|                                    token, number_of_argument_required.unsafe(),
  340|    115|                                    argument_num.unsafe()));
  341|    115|                            break;
  342|    115|                        }
  343|       |
  344|    313|                        phi::optional<InstructionArgument> optional_parsed_argument =
  345|    313|                                parse_instruction_argument(
  346|    313|                                        token, info.GetArgumentType(argument_num), tokens, program);
  347|    313|                        if (!optional_parsed_argument.has_value())
  ------------------
  |  Branch (347:29): [True: 161, False: 152]
  ------------------
  348|    161|                        {
  349|       |                            // The parse_instruction_argument function should already have added a parse error with more detail
  350|    161|                            break;
  351|    161|                        }
  352|       |
  353|       |                        // Successfully parsed one argument
  354|    152|                        InstructionArgument parsed_argument = optional_parsed_argument.value();
  355|       |
  356|    152|                        instruction.SetArgument(argument_num, parsed_argument);
  357|    152|                        argument_num++;
  358|    152|                        consumed_comma = false;
  359|       |
  360|       |                        //DLX_INFO("Successfully parsed argument {}", argument_num.unsafe());
  361|    152|                    }
  362|       |
  363|       |                    //DLX_INFO("Successfully parsed instruction '{}'",
  364|       |                    //            instruction.DebugInfo());
  365|    502|                    program.m_Instructions.emplace_back(instruction);
  366|    502|                    line_has_instruction = true;
  367|    502|                    break;
  368|  3.73k|                }
  369|       |
  370|  80.4k|                default:
  ------------------
  |  Branch (370:17): [True: 80.4k, False: 57.9k]
  ------------------
  371|  80.4k|                    Token::Type expected_token_type = Token::Type::Unknown;
  372|  80.4k|                    if (line_has_instruction)
  ------------------
  |  Branch (372:25): [True: 4.20k, False: 76.2k]
  ------------------
  373|  4.20k|                    {
  374|  4.20k|                        expected_token_type = Token::Type::NewLine;
  375|  4.20k|                    }
  376|       |
  377|  80.4k|                    program.AddParseError(
  378|  80.4k|                            ConstructUnexpectedTokenParseError(current_token, expected_token_type));
  379|  80.4k|                    break;
  380|   138k|            }
  381|   138k|        }
  382|       |
  383|       |        // Check for empty labels
  384|  3.55k|        if (label_count > 0u)
  ------------------
  |  Branch (384:13): [True: 416, False: 3.14k]
  ------------------
  385|    416|        {
  386|  1.28k|            for (auto it = tokens.rbegin(); label_count > 0u; ++it)
  ------------------
  |  Branch (386:45): [True: 868, False: 416]
  ------------------
  387|    868|            {
  388|    868|                PHI_ASSERT(it != tokens.rend(), "Iterator should never reach the end");
  389|       |
  390|    868|                const Token& token = *it;
  391|    868|                if (token.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (391:21): [True: 718, False: 150]
  ------------------
  392|    718|                {
  393|    718|                    program.AddParseError(ConstructEmptyLabelParseError(token));
  394|    718|                    --label_count;
  395|    718|                }
  396|    868|            }
  397|    416|        }
  398|       |
  399|  3.55k|        return program;
  400|  3.55k|    }
_ZN3dlx6Parser5ParseEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  403|  3.55k|    {
  404|  3.55k|        TokenStream tokens = Tokenize(source);
  405|  3.55k|        return Parse(tokens);
  406|  3.55k|    }
Parser.cpp:_ZN3dlxL26parse_instruction_argumentERKNS_5TokenENS_12ArgumentTypeERNS_11TokenStreamERNS_13ParsedProgramE:
   31|    313|    {
   32|       |        // DLX_INFO("Parsing argument with token '{}' and expected type '{}'", token.DebugInfo(),
   33|       |        //              dlx::enum_name(expected_argument_type));
   34|       |
   35|    313|        switch (token.GetType())
   36|    313|        {
   37|      7|            case Token::Type::IntegerLiteral: {
  ------------------
  |  Branch (37:13): [True: 7, False: 306]
  ------------------
   38|      7|                if (!ArgumentTypeIncludes(expected_argument_type,
  ------------------
  |  Branch (38:21): [True: 7, False: 0]
  ------------------
   39|      7|                                          ArgumentType::AddressDisplacement))
   40|      7|                {
   41|      7|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
   42|      7|                            token, expected_argument_type, ArgumentType::AddressDisplacement));
   43|       |
   44|      7|                    return {};
   45|      7|                }
   46|       |
   47|       |                // Get address displacement
   48|      0|                PHI_ASSERT(token.HasHint());
   49|       |
   50|      0|                phi::int16_t value = static_cast<phi::int16_t>(token.GetHint());
   51|       |
   52|      0|                if (!tokens.has_x_more(3u))
  ------------------
  |  Branch (52:21): [True: 0, False: 0]
  ------------------
   53|      0|                {
   54|      0|                    program.AddParseError(
   55|      0|                            ConstructTooFewArgumentsAddressDisplacementParseError(token));
   56|      0|                    return {};
   57|      0|                }
   58|       |
   59|      0|                auto         it           = tokens.current_position();
   60|      0|                const Token& first_token  = tokens.consume();
   61|      0|                const Token& second_token = tokens.consume();
   62|      0|                const Token& third_token  = tokens.consume();
   63|       |
   64|      0|                if (first_token.GetType() != Token::Type::OpenBracket)
  ------------------
  |  Branch (64:21): [True: 0, False: 0]
  ------------------
   65|      0|                {
   66|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   67|      0|                            first_token, Token::Type::OpenBracket));
   68|      0|                    return {};
   69|      0|                }
   70|       |
   71|       |                // Second token is the register
   72|      0|                if (second_token.GetType() != Token::Type::RegisterInt)
  ------------------
  |  Branch (72:21): [True: 0, False: 0]
  ------------------
   73|      0|                {
   74|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   75|      0|                            second_token, Token::Type::RegisterInt));
   76|      0|                    return {};
   77|      0|                }
   78|       |
   79|      0|                if (third_token.GetType() != Token::Type::ClosingBracket)
  ------------------
  |  Branch (79:21): [True: 0, False: 0]
  ------------------
   80|      0|                {
   81|      0|                    program.AddParseError(ConstructUnexpectedTokenParseError(
   82|      0|                            third_token, Token::Type::ClosingBracket));
   83|      0|                    return {};
   84|      0|                }
   85|       |
   86|       |                // Consume the 3 tokens
   87|      0|                tokens.set_position(it + 3u);
   88|       |
   89|       |                //DLX_INFO("Parsed address displacement with '{}' displacement and Register '{}'",
   90|       |                //             value, dlx::enum_name(reg_id));
   91|       |
   92|      0|                return ConstructInstructionArgumentAddressDisplacement(
   93|      0|                        static_cast<IntRegisterID>(second_token.GetHint()), value);
   94|      0|            }
   95|      0|            case Token::Type::RegisterInt: {
  ------------------
  |  Branch (95:13): [True: 0, False: 313]
  ------------------
   96|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::IntRegister))
  ------------------
  |  Branch (96:21): [True: 0, False: 0]
  ------------------
   97|      0|                {
   98|      0|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
   99|      0|                            token, expected_argument_type, ArgumentType::IntRegister));
  100|      0|                    return {};
  101|      0|                }
  102|       |
  103|       |                //DLX_INFO("Parsed identifier as int register {}",
  104|       |                //             dlx::enum_name(reg_id));
  105|       |
  106|      0|                return ConstructInstructionArgumentRegisterInt(
  107|      0|                        static_cast<IntRegisterID>(token.GetHint()));
  108|      0|            }
  109|      1|            case Token::Type::RegisterFloat: {
  ------------------
  |  Branch (109:13): [True: 1, False: 312]
  ------------------
  110|      1|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::FloatRegister))
  ------------------
  |  Branch (110:21): [True: 1, False: 0]
  ------------------
  111|      1|                {
  112|      1|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  113|      1|                            token, expected_argument_type, ArgumentType::FloatRegister));
  114|      1|                    return {};
  115|      1|                }
  116|       |
  117|       |                //DLX_INFO("Parsed identifier as float register {}",
  118|       |                //             dlx::enum_name(float_reg_id));
  119|       |
  120|      0|                return ConstructInstructionArgumentRegisterFloat(
  121|      0|                        static_cast<FloatRegisterID>(token.GetHint()));
  122|      1|            }
  123|      0|            case Token::Type::RegisterStatus: {
  ------------------
  |  Branch (123:13): [True: 0, False: 313]
  ------------------
  124|      0|                program.AddParseError(ConstructReservedIdentifierParseError(token));
  125|       |
  126|      0|                return {};
  127|      1|            }
  128|    248|            case Token::Type::LabelIdentifier: {
  ------------------
  |  Branch (128:13): [True: 248, False: 65]
  ------------------
  129|       |                // Parse as Label
  130|    248|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::Label))
  ------------------
  |  Branch (130:21): [True: 1, False: 247]
  ------------------
  131|      1|                {
  132|      1|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  133|      1|                            token, expected_argument_type, ArgumentType::Label));
  134|      1|                    return {};
  135|      1|                }
  136|       |
  137|    247|                if (IsReservedIdentifier(token.GetText()))
  ------------------
  |  Branch (137:21): [True: 0, False: 247]
  ------------------
  138|      0|                {
  139|      0|                    program.AddParseError(ConstructReservedIdentifierParseError(token));
  140|      0|                    return {};
  141|      0|                }
  142|       |
  143|    247|                if (!IsValidIdentifier(token.GetText()))
  ------------------
  |  Branch (143:21): [True: 95, False: 152]
  ------------------
  144|     95|                {
  145|     95|                    program.AddParseError(ConstructInvalidLabelIdentifierParseError(token));
  146|     95|                    return {};
  147|     95|                }
  148|       |
  149|       |                //DLX_INFO("Parsed Label identifier as '{}'", token.GetText());
  150|       |
  151|    152|                return ConstructInstructionArgumentLabel(token.GetText());
  152|    247|            }
  153|      0|            case Token::Type::ImmediateInteger: {
  ------------------
  |  Branch (153:13): [True: 0, False: 313]
  ------------------
  154|      0|                if (!ArgumentTypeIncludes(expected_argument_type, ArgumentType::ImmediateInteger))
  ------------------
  |  Branch (154:21): [True: 0, False: 0]
  ------------------
  155|      0|                {
  156|      0|                    program.AddParseError(ConstructUnexpectedArgumentTypeParseError(
  157|      0|                            token, expected_argument_type, ArgumentType::ImmediateInteger));
  158|      0|                    return {};
  159|      0|                }
  160|       |
  161|      0|                if (token.HasHint())
  ------------------
  |  Branch (161:21): [True: 0, False: 0]
  ------------------
  162|      0|                {
  163|      0|                    return ConstructInstructionArgumentImmediateValue(
  164|      0|                            static_cast<phi::int16_t>(token.GetHint()));
  165|      0|                }
  166|       |
  167|      0|                program.AddParseError(ConstructInvalidNumberParseError(token));
  168|      0|                return {};
  169|      0|            }
  170|       |
  171|     57|            default:
  ------------------
  |  Branch (171:13): [True: 57, False: 256]
  ------------------
  172|     57|                program.AddParseError(
  173|     57|                        ConstructUnexpectedTokenParseError(token, Token::Type::Unknown));
  174|     57|                return {};
  175|    313|        }
  176|    313|    }
Parser.cpp:_ZZN3dlx6Parser5ParseERNS_11TokenStreamEENK3$_0clERKNS_5TokenE:
  245|  26.3k|                                tokens.find_first_token_if([&](const Token& t) {
  246|  26.3k|                                    if (t.GetType() == Token::Type::LabelIdentifier)
  ------------------
  |  Branch (246:41): [True: 19.2k, False: 7.14k]
  ------------------
  247|  19.2k|                                    {
  248|  19.2k|                                        phi::string_view token_label_name = t.GetText();
  249|  19.2k|                                        token_label_name.remove_suffix(1u);
  250|       |
  251|  19.2k|                                        if (token_label_name == label_name)
  ------------------
  |  Branch (251:45): [True: 8.11k, False: 11.1k]
  ------------------
  252|  8.11k|                                        {
  253|  8.11k|                                            return true;
  254|  8.11k|                                        }
  255|  19.2k|                                    }
  256|       |
  257|  18.2k|                                    return false;
  258|  26.3k|                                });

_ZN3dlx9ProcessorC2Ev:
   62|  9.87k|    {
   63|       |        // Mark R0 as ready only
   64|  9.87k|        m_IntRegisters[0].SetReadOnly(true);
   65|  9.87k|    }
_ZN3dlx9Processor11LoadProgramERNS_13ParsedProgramE:
  349|    668|    {
  350|    668|        if (!program.m_ParseErrors.empty())
  ------------------
  |  Branch (350:13): [True: 0, False: 668]
  ------------------
  351|      0|        {
  352|      0|            DLX_WARN("Trying to load program with parsing errors");
  ------------------
  |  |    8|      0|#define DLX_WARN(...)     PHI_EMPTY_MACRO()
  ------------------
  353|      0|            return false;
  354|      0|        }
  355|       |
  356|    668|        m_CurrentProgram = &program;
  357|       |
  358|    668|        m_ProgramCounter               = 0u;
  359|    668|        m_Halted                       = false;
  360|    668|        m_CurrentInstructionAccessType = RegisterAccessType::Ignored;
  361|    668|        m_LastRaisedException          = Exception::None;
  362|    668|        m_CurrentStepCount             = 0u;
  363|       |
  364|    668|        return true;
  365|    668|    }
_ZNK3dlx9Processor8IsHaltedEv:
  543|     64|    {
  544|     64|        return m_Halted;
  545|     64|    }

_ZN3dlx19StringToIntRegisterEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   10|  75.3k|    {
   11|  75.3k|        if (token.length() == 2u)
  ------------------
  |  Branch (11:13): [True: 24.9k, False: 50.3k]
  ------------------
   12|  24.9k|        {
   13|  24.9k|            const char first_char = token[0u];
   14|  24.9k|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (14:17): [True: 3.13k, False: 21.8k]
  |  Branch (14:38): [True: 82, False: 21.7k]
  ------------------
   15|  3.21k|            {
   16|  3.21k|                const char second_char = token[1u];
   17|  3.21k|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (17:21): [True: 3.05k, False: 165]
  |  Branch (17:43): [True: 1.90k, False: 1.15k]
  ------------------
   18|  1.90k|                {
   19|  1.90k|                    return static_cast<IntRegisterID>(second_char - '0');
   20|  1.90k|                }
   21|  3.21k|            }
   22|  24.9k|        }
   23|  50.3k|        else if (token.length() == 3u)
  ------------------
  |  Branch (23:18): [True: 17.3k, False: 33.0k]
  ------------------
   24|  17.3k|        {
   25|  17.3k|            const char first_char = token[0u];
   26|  17.3k|            if (first_char == 'R' || first_char == 'r')
  ------------------
  |  Branch (26:17): [True: 3.19k, False: 14.1k]
  |  Branch (26:38): [True: 34, False: 14.1k]
  ------------------
   27|  3.22k|            {
   28|  3.22k|                const char second_char = token[1u];
   29|  3.22k|                const char third_char  = token[2u];
   30|       |
   31|  3.22k|                switch (second_char)
   32|  3.22k|                {
   33|    132|                    case '1': {
  ------------------
  |  Branch (33:21): [True: 132, False: 3.09k]
  ------------------
   34|    132|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (34:29): [True: 86, False: 46]
  |  Branch (34:50): [True: 10, False: 76]
  ------------------
   35|     10|                        {
   36|     10|                            return static_cast<IntRegisterID>(third_char - '0' + 10);
   37|     10|                        }
   38|    122|                        break;
   39|    132|                    }
   40|  1.50k|                    case '2': {
  ------------------
  |  Branch (40:21): [True: 1.50k, False: 1.72k]
  ------------------
   41|  1.50k|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (41:29): [True: 1.23k, False: 270]
  |  Branch (41:50): [True: 681, False: 551]
  ------------------
   42|    681|                        {
   43|    681|                            return static_cast<IntRegisterID>(third_char - '0' + 20);
   44|    681|                        }
   45|    821|                        break;
   46|  1.50k|                    }
   47|    821|                    case '3': {
  ------------------
  |  Branch (47:21): [True: 110, False: 3.11k]
  ------------------
   48|    110|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (48:29): [True: 10, False: 100]
  |  Branch (48:50): [True: 7, False: 93]
  ------------------
   49|     17|                        {
   50|     17|                            return static_cast<IntRegisterID>(third_char - '0' + 30);
   51|     17|                        }
   52|     93|                        break;
   53|    110|                    }
   54|  1.48k|                    default: {
  ------------------
  |  Branch (54:21): [True: 1.48k, False: 1.74k]
  ------------------
   55|  1.48k|                        break;
   56|    110|                    }
   57|  3.22k|                }
   58|  3.22k|            }
   59|  17.3k|        }
   60|       |
   61|  72.7k|        return IntRegisterID::None;
   62|  75.3k|    }
_ZN3dlx21StringToFloatRegisterEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   65|  72.7k|    {
   66|  72.7k|        if (token.length() == 2u)
  ------------------
  |  Branch (66:13): [True: 23.0k, False: 49.6k]
  ------------------
   67|  23.0k|        {
   68|  23.0k|            const char first_char = token[0u];
   69|  23.0k|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (69:17): [True: 340, False: 22.7k]
  |  Branch (69:38): [True: 1, False: 22.7k]
  ------------------
   70|    341|            {
   71|    341|                const char second_char = token[1u];
   72|    341|                if (second_char >= '0' && second_char <= '9')
  ------------------
  |  Branch (72:21): [True: 333, False: 8]
  |  Branch (72:43): [True: 112, False: 221]
  ------------------
   73|    112|                {
   74|    112|                    return static_cast<FloatRegisterID>(second_char - '0');
   75|    112|                }
   76|    341|            }
   77|  23.0k|        }
   78|  49.6k|        else if (token.length() == 3u)
  ------------------
  |  Branch (78:18): [True: 16.6k, False: 33.0k]
  ------------------
   79|  16.6k|        {
   80|  16.6k|            const char first_char = token[0u];
   81|  16.6k|            if (first_char == 'F' || first_char == 'f')
  ------------------
  |  Branch (81:17): [True: 231, False: 16.4k]
  |  Branch (81:38): [True: 2, False: 16.4k]
  ------------------
   82|    233|            {
   83|    233|                const char second_char = token[1u];
   84|    233|                const char third_char  = token[2u];
   85|       |
   86|    233|                switch (second_char)
   87|    233|                {
   88|     30|                    case '1': {
  ------------------
  |  Branch (88:21): [True: 30, False: 203]
  ------------------
   89|     30|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (89:29): [True: 27, False: 3]
  |  Branch (89:50): [True: 15, False: 12]
  ------------------
   90|     15|                        {
   91|     15|                            return static_cast<FloatRegisterID>(third_char - '0' + 10);
   92|     15|                        }
   93|     15|                        break;
   94|     30|                    }
   95|     56|                    case '2': {
  ------------------
  |  Branch (95:21): [True: 56, False: 177]
  ------------------
   96|     56|                        if (third_char >= '0' && third_char <= '9')
  ------------------
  |  Branch (96:29): [True: 53, False: 3]
  |  Branch (96:50): [True: 29, False: 24]
  ------------------
   97|     29|                        {
   98|     29|                            return static_cast<FloatRegisterID>(third_char - '0' + 20);
   99|     29|                        }
  100|     27|                        break;
  101|     56|                    }
  102|     28|                    case '3': {
  ------------------
  |  Branch (102:21): [True: 28, False: 205]
  ------------------
  103|     28|                        if (third_char == '0' || third_char == '1')
  ------------------
  |  Branch (103:29): [True: 5, False: 23]
  |  Branch (103:50): [True: 0, False: 23]
  ------------------
  104|      5|                        {
  105|      5|                            return static_cast<FloatRegisterID>(third_char - '0' + 30);
  106|      5|                        }
  107|     23|                        break;
  108|     28|                    }
  109|    119|                    default: {
  ------------------
  |  Branch (109:21): [True: 119, False: 114]
  ------------------
  110|    119|                        break;
  111|     28|                    }
  112|    233|                }
  113|    233|            }
  114|  16.6k|        }
  115|       |
  116|  72.6k|        return FloatRegisterID::None;
  117|  72.7k|    }
_ZN3dlx6IsFPSREN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
  120|  71.9k|    {
  121|  71.9k|        if (token.length() == 4u)
  ------------------
  |  Branch (121:13): [True: 5.84k, False: 66.1k]
  ------------------
  122|  5.84k|        {
  123|  5.84k|            const char c1 = token[0u];
  124|  5.84k|            const char c2 = token[1u];
  125|  5.84k|            const char c3 = token[2u];
  126|  5.84k|            const char c4 = token[3u];
  127|       |
  128|  5.84k|            return (c1 == 'F' || c1 == 'f') && (c2 == 'P' || c2 == 'p') &&
  ------------------
  |  Branch (128:21): [True: 341, False: 5.50k]
  |  Branch (128:34): [True: 2, False: 5.49k]
  |  Branch (128:49): [True: 0, False: 343]
  |  Branch (128:62): [True: 0, False: 343]
  ------------------
  129|  5.84k|                   (c3 == 'S' || c3 == 's') && (c4 == 'R' || c4 == 'r');
  ------------------
  |  Branch (129:21): [True: 0, False: 0]
  |  Branch (129:34): [True: 0, False: 0]
  |  Branch (129:49): [True: 0, False: 0]
  |  Branch (129:62): [True: 0, False: 0]
  ------------------
  130|  5.84k|        }
  131|       |
  132|  66.1k|        return false;
  133|  71.9k|    }

_ZN3dlx5TokenC2ENS0_4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS2_7integerImEES9_:
   27|   110k|    {}
_ZN3dlx5TokenC2ENS0_4TypeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS2_7integerImEES9_j:
   37|  29.0k|    {}
_ZNK3dlx5Token7GetTypeEv:
   40|   387k|    {
   41|   387k|        return m_Type;
   42|   387k|    }
_ZNK3dlx5Token13GetLineNumberEv:
   50|   412k|    {
   51|   412k|        return m_LineNumber;
   52|   412k|    }
_ZNK3dlx5Token9GetColumnEv:
   55|   834k|    {
   56|   834k|        return m_Column;
   57|   834k|    }
_ZNK3dlx5Token9GetLengthEv:
   60|   557k|    {
   61|   557k|        return m_Text.length();
   62|   557k|    }
_ZNK3dlx5Token7GetTextEv:
   65|   136k|    {
   66|   136k|        return m_Text;
   67|   136k|    }
_ZNK3dlx5Token7HasHintEv:
   79|    502|    {
   80|    502|        return m_HasHint;
   81|    502|    }
_ZNK3dlx5Token7GetHintEv:
   84|    502|    {
   85|    502|        PHI_ASSERT(m_Type == Type::RegisterInt || m_Type == Type::RegisterFloat ||
   86|    502|                   m_Type == Type::IntegerLiteral || m_Type == Type::OpCode ||
   87|    502|                   m_Type == Type::ImmediateInteger);
   88|    502|        PHI_ASSERT(m_HasHint);
   89|       |
   90|    502|        return m_Hint;
   91|    502|    }

_ZN3dlx11TokenStream8finalizeEv:
   28|  3.55k|    {
   29|       |#if defined(PHI_DEBUG)
   30|       |        PHI_ASSERT(!m_Finalized);
   31|       |#endif
   32|       |
   33|  3.55k|        m_Iterator = 0u;
   34|       |#if defined(PHI_DEBUG)
   35|       |        m_Finalized = true;
   36|       |#endif
   37|  3.55k|    }
_ZNK3dlx11TokenStream8has_moreEv:
   54|   142k|    {
   55|   142k|        return m_Iterator < m_Tokens.size();
   56|   142k|    }
_ZNK3dlx11TokenStream11reached_endEv:
   59|   139k|    {
   60|   139k|        return m_Iterator >= m_Tokens.size();
   61|   139k|    }
_ZN3dlx11TokenStream7consumeEv:
   74|   139k|    {
   75|   139k|        PHI_ASSERT(!reached_end());
   76|       |#if defined(PHI_DEBUG)
   77|       |        PHI_ASSERT(m_Finalized);
   78|       |#endif
   79|       |
   80|   139k|        return m_Tokens.at(m_Iterator++.unsafe());
   81|   139k|    }
_ZNK3dlx11TokenStream5beginEv:
  168|  3.55k|    {
  169|       |#if defined(PHI_DEBUG)
  170|       |        //PHI_ASSERT(m_Finalized);
  171|       |#endif
  172|       |
  173|  3.55k|        return m_Tokens.begin();
  174|  3.55k|    }
_ZNK3dlx11TokenStream3endEv:
  186|  3.55k|    {
  187|       |#if defined(PHI_DEBUG)
  188|       |        //PHI_ASSERT(m_Finalized);
  189|       |#endif
  190|       |
  191|  3.55k|        return m_Tokens.end();
  192|  3.55k|    }
_ZNK3dlx11TokenStream6rbeginEv:
  204|    416|    {
  205|       |#if defined(PHI_DEBUG)
  206|       |        //PHI_ASSERT(m_Finalized);
  207|       |#endif
  208|       |
  209|    416|        return m_Tokens.rbegin();
  210|    416|    }
_ZNK3dlx11TokenStream4rendEv:
  213|    868|    {
  214|       |#if defined(PHI_DEBUG)
  215|       |        //PHI_ASSERT(m_Finalized);
  216|       |#endif
  217|       |
  218|    868|        return m_Tokens.rend();
  219|    868|    }

_ZN3dlx8TokenizeEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEE:
   68|  3.55k|    {
   69|  3.55k|        TokenStream tokens;
   70|       |
   71|  3.55k|        phi::string_view current_token;
   72|       |
   73|  3.55k|        phi::u64 current_line_number{1u};
   74|  3.55k|        phi::u64 current_column{1u};
   75|  3.55k|        phi::u64 token_begin{0u};
   76|       |
   77|  3.55k|        phi::boolean parsing_comment{false};
   78|       |
   79|   437k|        for (phi::usize i{0u}; i < source.length(); ++i)
  ------------------
  |  Branch (79:32): [True: 433k, False: 3.55k]
  ------------------
   80|   433k|        {
   81|   433k|            const char c{source.at(i)};
   82|       |
   83|   433k|            if (c == '\n')
  ------------------
  |  Branch (83:17): [True: 4.04k, False: 429k]
  ------------------
   84|  4.04k|            {
   85|  4.04k|                if (current_token.is_empty())
  ------------------
  |  Branch (85:21): [True: 2.83k, False: 1.20k]
  ------------------
   86|  2.83k|                {
   87|       |                    // Skip empty lines
   88|  2.83k|                    tokens.emplace_back(Token::Type::NewLine, source.substring_view(i, 1u),
   89|  2.83k|                                        current_line_number, current_column);
   90|       |
   91|  2.83k|                    parsing_comment = false;
   92|  2.83k|                    current_line_number += 1u;
   93|  2.83k|                    current_column = 1u;
   94|  2.83k|                    continue;
   95|  2.83k|                }
   96|       |
   97|       |                // Otherwise a new line separates tokens
   98|  1.20k|                tokens.emplace_back(ParseToken(
   99|  1.20k|                        source.substring_view(
  100|  1.20k|                                phi::narrow_cast<phi::string_view::size_type>(token_begin),
  101|  1.20k|                                current_token.length()),
  102|  1.20k|                        current_line_number, current_column - current_token.length()));
  103|       |
  104|  1.20k|                tokens.emplace_back(Token::Type::NewLine, source.substring_view(i, 1u),
  105|  1.20k|                                    current_line_number, current_column);
  106|       |
  107|  1.20k|                current_token   = phi::string_view{};
  108|  1.20k|                parsing_comment = false;
  109|  1.20k|                current_line_number += 1u;
  110|  1.20k|                current_column = 0u;
  111|  1.20k|            }
  112|       |            // Comments begin with an '/' or ';' and after that the entire line is treated as part of the comment
  113|   429k|            else if (c == '/' || c == ';')
  ------------------
  |  Branch (113:22): [True: 361, False: 429k]
  |  Branch (113:34): [True: 101, False: 429k]
  ------------------
  114|    462|            {
  115|    462|                if (current_token.is_empty())
  ------------------
  |  Branch (115:21): [True: 126, False: 336]
  ------------------
  116|    126|                {
  117|    126|                    token_begin = i;
  118|    126|                }
  119|    336|                else if (!parsing_comment)
  ------------------
  |  Branch (119:26): [True: 37, False: 299]
  ------------------
  120|     37|                {
  121|     37|                    tokens.emplace_back(ParseToken(
  122|     37|                            source.substring_view(
  123|     37|                                    phi::narrow_cast<phi::string_view::size_type>(token_begin),
  124|     37|                                    current_token.length()),
  125|     37|                            current_line_number, current_column - current_token.length()));
  126|     37|                    token_begin   = i;
  127|     37|                    current_token = phi::string_view{};
  128|     37|                }
  129|       |
  130|    462|                parsing_comment = true;
  131|    462|                current_token   = source.substring_view(
  132|    462|                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  133|    462|                        current_token.length() + 1u);
  134|    462|            }
  135|   429k|            else if (parsing_comment)
  ------------------
  |  Branch (135:22): [True: 1.39k, False: 427k]
  ------------------
  136|  1.39k|            {
  137|       |                // simply append the character
  138|  1.39k|                current_token = source.substring_view(
  139|  1.39k|                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  140|  1.39k|                        current_token.length() + 1u);
  141|  1.39k|            }
  142|   427k|            else
  143|   427k|            {
  144|       |                // Not parsing a comment
  145|   427k|                switch (c)
  146|   427k|                {
  147|  1.16k|                    case ' ':
  ------------------
  |  Branch (147:21): [True: 1.16k, False: 426k]
  ------------------
  148|  6.59k|                    case '\t':
  ------------------
  |  Branch (148:21): [True: 5.42k, False: 422k]
  ------------------
  149|  7.13k|                    case '\v':
  ------------------
  |  Branch (149:21): [True: 544, False: 427k]
  ------------------
  150|  7.13k|                        if (current_token.is_empty())
  ------------------
  |  Branch (150:29): [True: 2.52k, False: 4.61k]
  ------------------
  151|  2.52k|                        {
  152|  2.52k|                            current_column += 1u;
  153|       |                            // We haven't found any usable character for the current token so just skip the whitespace.
  154|  2.52k|                            continue;
  155|  2.52k|                        }
  156|       |
  157|       |                        // Otherwise a whitespace separates tokens
  158|  4.61k|                        tokens.emplace_back(ParseToken(
  159|  4.61k|                                source.substring_view(
  160|  4.61k|                                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  161|  4.61k|                                        current_token.length()),
  162|  4.61k|                                current_line_number, current_column - current_token.length()));
  163|  4.61k|                        current_token = phi::string_view{};
  164|  4.61k|                        break;
  165|  23.8k|                    case ':':
  ------------------
  |  Branch (165:21): [True: 23.8k, False: 404k]
  ------------------
  166|       |                        // Need to parse label names together with their colon
  167|  23.8k|                        if (!current_token.is_empty())
  ------------------
  |  Branch (167:29): [True: 21.0k, False: 2.78k]
  ------------------
  168|  21.0k|                        {
  169|  21.0k|                            current_token = source.substring_view(
  170|  21.0k|                                    phi::narrow_cast<phi::string_view::size_type>(token_begin),
  171|  21.0k|                                    current_token.length() + 1u);
  172|  21.0k|                            tokens.emplace_back(ParseToken(
  173|  21.0k|                                    source.substring_view(
  174|  21.0k|                                            phi::narrow_cast<phi::string_view::size_type>(
  175|  21.0k|                                                    token_begin),
  176|  21.0k|                                            current_token.length()),
  177|  21.0k|                                    current_line_number,
  178|  21.0k|                                    current_column + 1u - current_token.length()));
  179|       |
  180|  21.0k|                            current_token = phi::string_view{};
  181|  21.0k|                        }
  182|  2.78k|                        else
  183|  2.78k|                        {
  184|       |                            // Orphan colon
  185|  2.78k|                            token_begin = i;
  186|       |
  187|  2.78k|                            tokens.emplace_back(
  188|  2.78k|                                    Token::Type::Colon,
  189|  2.78k|                                    source.substring_view(
  190|  2.78k|                                            phi::narrow_cast<phi::string_view::size_type>(
  191|  2.78k|                                                    token_begin),
  192|  2.78k|                                            1u),
  193|  2.78k|                                    current_line_number, current_column);
  194|  2.78k|                        }
  195|  23.8k|                        break;
  196|  6.54k|                    case ',':
  ------------------
  |  Branch (196:21): [True: 6.54k, False: 421k]
  ------------------
  197|  37.1k|                    case '(':
  ------------------
  |  Branch (197:21): [True: 30.6k, False: 397k]
  ------------------
  198|  52.6k|                    case ')':
  ------------------
  |  Branch (198:21): [True: 15.4k, False: 412k]
  ------------------
  199|  52.6k|                        if (!current_token.is_empty())
  ------------------
  |  Branch (199:29): [True: 50.6k, False: 1.94k]
  ------------------
  200|  50.6k|                        {
  201|  50.6k|                            tokens.emplace_back(ParseToken(
  202|  50.6k|                                    source.substring_view(
  203|  50.6k|                                            phi::narrow_cast<phi::string_view::size_type>(
  204|  50.6k|                                                    token_begin),
  205|  50.6k|                                            current_token.length()),
  206|  50.6k|                                    current_line_number, current_column - current_token.length()));
  207|       |
  208|  50.6k|                            current_token = phi::string_view{};
  209|  50.6k|                        }
  210|       |
  211|  52.6k|                        Token::Type type;
  212|  52.6k|                        switch (c)
  213|  52.6k|                        {
  214|  6.54k|                            case ',':
  ------------------
  |  Branch (214:29): [True: 6.54k, False: 46.0k]
  ------------------
  215|  6.54k|                                type = Token::Type::Comma;
  216|  6.54k|                                break;
  217|  30.6k|                            case '(':
  ------------------
  |  Branch (217:29): [True: 30.6k, False: 21.9k]
  ------------------
  218|  30.6k|                                type = Token::Type::OpenBracket;
  219|  30.6k|                                break;
  220|  15.4k|                            case ')':
  ------------------
  |  Branch (220:29): [True: 15.4k, False: 37.1k]
  ------------------
  221|  15.4k|                                type = Token::Type::ClosingBracket;
  222|  15.4k|                                break;
  223|      0|#if !defined(DLXEMU_COVERAGE_BUILD)
  224|      0|                            default:
  ------------------
  |  Branch (224:29): [True: 0, False: 52.6k]
  ------------------
  225|      0|                                PHI_ASSERT_NOT_REACHED();
  226|      0|                                break;
  227|  52.6k|#endif
  228|  52.6k|                        }
  229|       |
  230|  52.6k|                        token_begin = i;
  231|       |
  232|  52.6k|                        tokens.emplace_back(
  233|  52.6k|                                type,
  234|  52.6k|                                source.substring_view(
  235|  52.6k|                                        phi::narrow_cast<phi::string_view::size_type>(token_begin),
  236|  52.6k|                                        1u),
  237|  52.6k|                                current_line_number, current_column);
  238|  52.6k|                        break;
  239|       |
  240|   344k|                    default:
  ------------------
  |  Branch (240:21): [True: 344k, False: 83.5k]
  ------------------
  241|   344k|                        if (current_token.is_empty())
  ------------------
  |  Branch (241:29): [True: 79.5k, False: 264k]
  ------------------
  242|  79.5k|                        {
  243|  79.5k|                            token_begin = i;
  244|  79.5k|                        }
  245|       |
  246|       |                        // simply append the character
  247|   344k|                        current_token = source.substring_view(
  248|   344k|                                phi::narrow_cast<phi::string_view::size_type>(token_begin),
  249|   344k|                                current_token.length() + 1u);
  250|   427k|                }
  251|   427k|            }
  252|       |
  253|   428k|            current_column += 1u;
  254|   428k|        }
  255|       |
  256|       |        // Checked the entire string. Parse whats left if anything
  257|  3.55k|        if (!current_token.is_empty())
  ------------------
  |  Branch (257:13): [True: 2.09k, False: 1.46k]
  ------------------
  258|  2.09k|        {
  259|  2.09k|            tokens.emplace_back(
  260|  2.09k|                    ParseToken(source.substring_view(
  261|  2.09k|                                       phi::narrow_cast<phi::string_view::size_type>(token_begin),
  262|  2.09k|                                       current_token.length()),
  263|  2.09k|                               current_line_number, current_column - current_token.length()));
  264|  2.09k|        }
  265|       |
  266|       |        // Finalize token stream
  267|  3.55k|        tokens.finalize();
  268|       |
  269|  3.55k|        return tokens;
  270|  3.55k|    }
Tokenize.cpp:_ZN3dlxL10ParseTokenEN3phi17basic_string_viewIcNSt3__111char_traitsIcEEEENS0_7integerImEES7_:
   16|  79.6k|    {
   17|  79.6k|        if (token.at(0u) == '#' && token.length() > 1u)
  ------------------
  |  Branch (17:13): [True: 120, False: 79.5k]
  |  Branch (17:13): [True: 80, False: 79.5k]
  |  Branch (17:36): [True: 80, False: 40]
  ------------------
   18|     80|        {
   19|     80|            auto number = ParseNumber(token.substring_view(1u));
   20|       |
   21|     80|            if (number)
  ------------------
  |  Branch (21:17): [True: 0, False: 80]
  ------------------
   22|      0|            {
   23|      0|                return {Token::Type::ImmediateInteger, token, line_number, column,
   24|      0|                        static_cast<phi::uint32_t>(number.value().unsafe())};
   25|      0|            }
   26|       |
   27|     80|            return {Token::Type::ImmediateInteger, token, line_number, column};
   28|     80|        }
   29|       |
   30|  79.5k|        if (token.at(0u) == '/' || token.at(0u) == ';')
  ------------------
  |  Branch (30:13): [True: 137, False: 79.4k]
  |  Branch (30:13): [True: 163, False: 79.4k]
  |  Branch (30:36): [True: 26, False: 79.4k]
  ------------------
   31|    163|        {
   32|    163|            return {Token::Type::Comment, token, line_number, column};
   33|    163|        }
   34|       |
   35|  79.4k|        if (phi::optional<phi::i16> number = ParseNumber(token); number.has_value())
  ------------------
  |  Branch (35:66): [True: 25.2k, False: 54.1k]
  ------------------
   36|  25.2k|        {
   37|  25.2k|            return {Token::Type::IntegerLiteral, token, line_number, column,
   38|  25.2k|                    static_cast<phi::uint32_t>(number->unsafe())};
   39|  25.2k|        }
   40|       |
   41|  54.1k|        if (IsFPSR(token))
  ------------------
  |  Branch (41:13): [True: 0, False: 54.1k]
  ------------------
   42|      0|        {
   43|      0|            return {Token::Type::RegisterStatus, token, line_number, column};
   44|      0|        }
   45|       |
   46|  54.1k|        if (IntRegisterID id = StringToIntRegister(token); id != IntRegisterID::None)
  ------------------
  |  Branch (46:60): [True: 1, False: 54.1k]
  ------------------
   47|      1|        {
   48|      1|            return {Token::Type::RegisterInt, token, line_number, column,
   49|      1|                    static_cast<phi::uint32_t>(id)};
   50|      1|        }
   51|       |
   52|  54.1k|        if (FloatRegisterID id = StringToFloatRegister(token); id != FloatRegisterID::None)
  ------------------
  |  Branch (52:64): [True: 81, False: 54.0k]
  ------------------
   53|     81|        {
   54|     81|            return {Token::Type::RegisterFloat, token, line_number, column,
   55|     81|                    static_cast<phi::uint32_t>(id)};
   56|     81|        }
   57|       |
   58|  54.0k|        if (OpCode opcode = StringToOpCode(token); opcode != OpCode::NONE)
  ------------------
  |  Branch (58:52): [True: 3.75k, False: 50.3k]
  ------------------
   59|  3.75k|        {
   60|  3.75k|            return {Token::Type::OpCode, token, line_number, column,
   61|  3.75k|                    static_cast<phi::uint32_t>(opcode)};
   62|  3.75k|        }
   63|       |
   64|  50.3k|        return {Token::Type::LabelIdentifier, token, line_number, column};
   65|  54.0k|    }

_ZN3fmt3v106detail6bufferIcE6appendIcEEvPKT_S7_:
  916|   501k|  template <typename U> void append(const U* begin, const U* end) {
  917|  1.00M|    while (begin != end) {
  ------------------
  |  Branch (917:12): [True: 501k, False: 501k]
  ------------------
  918|   501k|      auto count = to_unsigned(end - begin);
  919|   501k|      try_reserve(size_ + count);
  920|   501k|      auto free_cap = capacity_ - size_;
  921|   501k|      if (free_cap < count) count = free_cap;
  ------------------
  |  Branch (921:11): [True: 0, False: 501k]
  ------------------
  922|   501k|      if (std::is_same<T, U>::value) {
  ------------------
  |  Branch (922:11): [Folded - Ignored]
  ------------------
  923|   501k|        memcpy(ptr_ + size_, begin, count * sizeof(T));
  924|   501k|      } else {
  925|      0|        T* out = ptr_ + size_;
  926|      0|        for (size_t i = 0; i < count; ++i) out[i] = begin[i];
  ------------------
  |  Branch (926:28): [True: 0, False: 0]
  ------------------
  927|      0|      }
  928|   501k|      size_ += count;
  929|   501k|      begin += count;
  930|   501k|    }
  931|   501k|  }
_ZN3fmt3v106detail11to_unsignedIiEENSt3__113make_unsignedIT_E4typeES5_:
  432|   228k|FMT_CONSTEXPR auto to_unsigned(Int value) -> make_unsigned_t<Int> {
  433|   228k|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  402|   457k|    fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (402:33): [Folded - Ignored]
  |  |  |  Branch (402:33): [True: 228k, False: 0]
  |  |  ------------------
  ------------------
  434|   228k|  return static_cast<make_unsigned_t<Int>>(value);
  435|   228k|}
_ZN3fmt3v106detail13ignore_unusedIJbA15_cEEEvDpRKT_:
  372|  1.53M|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt3v1014basic_appenderIcEC2ERNS0_6detail6bufferIcEE:
 1162|   134k|  FMT_CONSTEXPR basic_appender(detail::buffer<T>& buf) : buffer_(&buf) {}
_ZNK3fmt3v1017basic_string_viewIcE4sizeEv:
  545|   753k|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt3v106detail13ignore_unusedIJbA1_cEEEvDpRKT_:
  372|   228k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt3v106detail6bufferIcE4sizeEv:
  883|   720k|  constexpr auto size() const noexcept -> size_t { return size_; }
_ZN3fmt3v106detail13ignore_unusedIJbEEEvDpRKT_:
  372|  42.0k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZNK3fmt3v106detail6bufferIcE8capacityEv:
  886|  65.3k|  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
_ZN3fmt3v106detail6bufferIcEC2EPFvRS3_mEPcmm:
  858|   134k|      : ptr_(p), size_(sz), capacity_(cap), grow_(grow) {}
_ZN3fmt3v106detail6bufferIcE3setEPcm:
  864|   176k|  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
  865|   176k|    ptr_ = buf_data;
  866|   176k|    capacity_ = buf_capacity;
  867|   176k|  }
_ZN3fmt3v106detail6bufferIcE4dataEv:
  889|   176k|  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
_ZN3fmt3v1013get_containerENS0_14basic_appenderIcEE:
 1150|  1.00M|  friend auto get_container(basic_appender app) -> detail::buffer<T>& {
 1151|  1.00M|    return *app.buffer_;
 1152|  1.00M|  }
_ZN3fmt3v106detail4copyIcPKcEENS0_14basic_appenderIcEET0_S7_S6_:
 1193|   485k|auto copy(InputIt begin, InputIt end, appender out) -> appender {
 1194|   485k|  get_container(out).append(begin, end);
 1195|   485k|  return out;
 1196|   485k|}
_ZNK3fmt3v1017basic_string_viewIcE5beginEv:
  547|   273k|  constexpr auto begin() const noexcept -> iterator { return data_; }
_ZNK3fmt3v1017basic_string_viewIcE3endEv:
  548|   273k|  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
_ZN3fmt3v1017basic_string_viewIcEC2EPKc:
  531|   212k|                  : detail::length(s)) {}
_ZN3fmt3v106detail10locale_refC2Ev:
 1569|   346k|  constexpr locale_ref() : locale_(nullptr) {}
_ZNK3fmt3v1019basic_format_stringIcJEEcvNS0_17basic_string_viewIcEEEv:
 2876|  3.24k|  FMT_ALWAYS_INLINE operator basic_string_view<Char>() const { return str_; }
_ZN3fmt3v1016make_format_argsINS0_7contextEJELm0ELm0ELy0ELi0EEENS0_6detail16format_arg_storeIT_XT1_ELm0EXT3_EEEDpRT0_:
 2001|  3.24k|    -> detail::format_arg_store<Context, NUM_ARGS, 0, DESC> {
 2002|  3.24k|  return {{detail::make_arg<NUM_ARGS <= detail::max_packed_args, Context>(
 2003|  3.24k|      args)...}};
 2004|  3.24k|}
_ZN3fmt3v106detail5valueINS0_7contextEEC2Ev:
 1336|   232k|  constexpr FMT_ALWAYS_INLINE value() : no_value() {}
_ZN3fmt3v109monostateC2Ev:
  347|   232k|  constexpr monostate() {}
_ZN3fmt3v1017basic_format_argsINS0_7contextEEC2ILm0ELm0ELy0ELi0EEERKNS0_6detail16format_arg_storeIS2_XT_EXT0_EXT1_EEE:
 1869|  3.24k|      : desc_(DESC), values_(store.args + (NUM_NAMED_ARGS != 0 ? 1 : 0)) {}
_ZNK3fmt3v1017basic_string_viewIcE4dataEv:
  542|   346k|  constexpr auto data() const noexcept -> const Char* { return data_; }
_ZN3fmt3v1017basic_string_viewIcEC2EPKcm:
  520|   273k|      : data_(s), size_(count) {}
_ZN3fmt3v106detail11to_unsignedIlEENSt3__113make_unsignedIT_E4typeES5_:
  432|  1.30M|FMT_CONSTEXPR auto to_unsigned(Int value) -> make_unsigned_t<Int> {
  433|  1.30M|  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
  ------------------
  |  |  402|  2.61M|    fmt::detail::ignore_unused((condition), (message))
  |  |  ------------------
  |  |  |  Branch (402:33): [Folded - Ignored]
  |  |  |  Branch (402:33): [True: 1.30M, False: 0]
  |  |  ------------------
  ------------------
  434|  1.30M|  return static_cast<make_unsigned_t<Int>>(value);
  435|  1.30M|}
_ZN3fmt3v106detail6bufferIcE11try_reserveEm:
  906|  1.00M|  FMT_CONSTEXPR void try_reserve(size_t new_capacity) {
  907|  1.00M|    if (new_capacity > capacity_) grow_(*this, new_capacity);
  ------------------
  |  Branch (907:9): [True: 42.0k, False: 961k]
  ------------------
  908|  1.00M|  }
_ZNK3fmt3v1017basic_format_argsINS0_7contextEE3getEi:
 1888|   228k|  FMT_CONSTEXPR auto get(int id) const -> format_arg {
 1889|   228k|    format_arg arg;
 1890|   228k|    if (!is_packed()) {
  ------------------
  |  Branch (1890:9): [True: 0, False: 228k]
  ------------------
 1891|      0|      if (id < max_size()) arg = args_[id];
  ------------------
  |  Branch (1891:11): [True: 0, False: 0]
  ------------------
 1892|      0|      return arg;
 1893|      0|    }
 1894|   228k|    if (static_cast<unsigned>(id) >= detail::max_packed_args) return arg;
  ------------------
  |  Branch (1894:9): [True: 0, False: 228k]
  ------------------
 1895|   228k|    arg.type_ = type(id);
 1896|   228k|    if (arg.type_ == detail::type::none_type) return arg;
  ------------------
  |  Branch (1896:9): [True: 0, False: 228k]
  ------------------
 1897|   228k|    arg.value_ = values_[id];
 1898|   228k|    return arg;
 1899|   228k|  }
_ZN3fmt3v1016basic_format_argINS0_7contextEEC2Ev:
 1744|   228k|  constexpr basic_format_arg() : type_(detail::type::none_type) {}
_ZNK3fmt3v1017basic_format_argsINS0_7contextEE9is_packedEv:
 1847|   228k|  constexpr auto is_packed() const -> bool {
 1848|   228k|    return (desc_ & detail::is_unpacked_bit) == 0;
 1849|   228k|  }
_ZNK3fmt3v1017basic_format_argsINS0_7contextEE4typeEi:
 1854|   228k|  FMT_CONSTEXPR auto type(int index) const -> detail::type {
 1855|   228k|    int shift = index * detail::packed_arg_bits;
 1856|   228k|    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
 1857|   228k|    return static_cast<detail::type>((desc_ >> shift) & mask);
 1858|   228k|  }
_ZNK3fmt3v1016basic_format_argINS0_7contextEEcvbEv:
 1746|   228k|  constexpr explicit operator bool() const noexcept {
 1747|   228k|    return type_ != detail::type::none_type;
 1748|   228k|  }
_ZN3fmt3v106detail13ignore_unusedIJbA20_cEEEvDpRKT_:
  372|  16.6k|template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
_ZN3fmt3v106detail4copyIcPcEENS0_14basic_appenderIcEET0_S6_S5_:
 1193|  16.6k|auto copy(InputIt begin, InputIt end, appender out) -> appender {
 1194|  16.6k|  get_container(out).append(begin, end);
 1195|  16.6k|  return out;
 1196|  16.6k|}
_ZNK3fmt3v106detail6fill_t4sizeEv:
 2093|   212k|  constexpr auto size() const -> size_t { return size_; }
_ZN3fmt3v1012format_specsC2Ev:
 2155|   228k|        localized(false) {}
_ZN3fmt3v1026basic_format_parse_contextIcEC2ENS0_17basic_string_viewIcEEi:
  755|   134k|      : format_str_(format_str), next_arg_id_(next_arg_id) {}
_ZN3fmt3v107contextC2ENS0_14basic_appenderIcEENS0_17basic_format_argsIS1_EENS0_6detail10locale_refE:
 1945|   134k|      : out_(out), args_(ctx_args), loc_(loc) {}
_ZN3fmt3v107context3outEv:
 1958|   501k|  FMT_CONSTEXPR auto out() -> iterator { return out_; }
_ZN3fmt3v106detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_:
 2587|   134k|                                       Handler&& handler) {
 2588|   134k|  auto begin = format_str.data();
 2589|   134k|  auto end = begin + format_str.size();
 2590|   134k|  if (end - begin < 32) {
  ------------------
  |  Branch (2590:7): [True: 3.40k, False: 130k]
  ------------------
 2591|       |    // Use a simple loop instead of memchr for small strings.
 2592|  3.40k|    const Char* p = begin;
 2593|  98.5k|    while (p != end) {
  ------------------
  |  Branch (2593:12): [True: 95.1k, False: 3.40k]
  ------------------
 2594|  95.1k|      auto c = *p++;
 2595|  95.1k|      if (c == '{') {
  ------------------
  |  Branch (2595:11): [True: 3.39k, False: 91.7k]
  ------------------
 2596|  3.39k|        handler.on_text(begin, p - 1);
 2597|  3.39k|        begin = p = parse_replacement_field(p - 1, end, handler);
 2598|  91.7k|      } else if (c == '}') {
  ------------------
  |  Branch (2598:18): [True: 0, False: 91.7k]
  ------------------
 2599|      0|        if (p == end || *p != '}')
  ------------------
  |  Branch (2599:13): [True: 0, False: 0]
  |  Branch (2599:25): [True: 0, False: 0]
  ------------------
 2600|      0|          return handler.on_error("unmatched '}' in format string");
 2601|      0|        handler.on_text(begin, p);
 2602|      0|        begin = ++p;
 2603|      0|      }
 2604|  95.1k|    }
 2605|  3.40k|    handler.on_text(begin, end);
 2606|  3.40k|    return;
 2607|  3.40k|  }
 2608|   130k|  struct writer {
 2609|   130k|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2610|   130k|      if (from == to) return;
 2611|   130k|      for (;;) {
 2612|   130k|        const Char* p = nullptr;
 2613|   130k|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
 2614|   130k|          return handler_.on_text(from, to);
 2615|   130k|        ++p;
 2616|   130k|        if (p == to || *p != '}')
 2617|   130k|          return handler_.on_error("unmatched '}' in format string");
 2618|   130k|        handler_.on_text(from, p);
 2619|   130k|        from = p + 1;
 2620|   130k|      }
 2621|   130k|    }
 2622|   130k|    Handler& handler_;
 2623|   130k|  } write = {handler};
 2624|   356k|  while (begin != end) {
  ------------------
  |  Branch (2624:10): [True: 266k, False: 89.8k]
  ------------------
 2625|       |    // Doing two passes with memchr (one for '{' and another for '}') is up to
 2626|       |    // 2.5x faster than the naive one-pass implementation on big format strings.
 2627|   266k|    const Char* p = begin;
 2628|   266k|    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
  ------------------
  |  Branch (2628:9): [True: 266k, False: 0]
  |  Branch (2628:26): [True: 40.8k, False: 225k]
  ------------------
 2629|  40.8k|      return write(begin, end);
 2630|   225k|    write(begin, p);
 2631|   225k|    begin = parse_replacement_field(p, end, handler);
 2632|   225k|  }
 2633|   130k|}
_ZN3fmt3v107context10advance_toENS0_14basic_appenderIcEE:
 1961|   501k|  void advance_to(iterator) {}
_ZN3fmt3v106detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_:
 2550|   228k|                                           Handler&& handler) -> const Char* {
 2551|   228k|  struct id_adapter {
 2552|   228k|    Handler& handler;
 2553|   228k|    int arg_id;
 2554|       |
 2555|   228k|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
 2556|   228k|    FMT_CONSTEXPR void on_index(int id) { arg_id = handler.on_arg_id(id); }
 2557|   228k|    FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
 2558|   228k|      arg_id = handler.on_arg_id(id);
 2559|   228k|    }
 2560|   228k|  };
 2561|       |
 2562|   228k|  ++begin;
 2563|   228k|  if (begin == end) return handler.on_error("invalid format string"), end;
  ------------------
  |  Branch (2563:7): [True: 0, False: 228k]
  ------------------
 2564|   228k|  if (*begin == '}') {
  ------------------
  |  Branch (2564:7): [True: 0, False: 228k]
  ------------------
 2565|      0|    handler.on_replacement_field(handler.on_arg_id(), begin);
 2566|   228k|  } else if (*begin == '{') {
  ------------------
  |  Branch (2566:14): [True: 0, False: 228k]
  ------------------
 2567|      0|    handler.on_text(begin, begin + 1);
 2568|   228k|  } else {
 2569|   228k|    auto adapter = id_adapter{handler, 0};
 2570|   228k|    begin = parse_arg_id(begin, end, adapter);
 2571|   228k|    Char c = begin != end ? *begin : Char();
  ------------------
  |  Branch (2571:14): [True: 228k, False: 0]
  ------------------
 2572|   228k|    if (c == '}') {
  ------------------
  |  Branch (2572:9): [True: 0, False: 228k]
  ------------------
 2573|      0|      handler.on_replacement_field(adapter.arg_id, begin);
 2574|   228k|    } else if (c == ':') {
  ------------------
  |  Branch (2574:16): [True: 228k, False: 0]
  ------------------
 2575|   228k|      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
 2576|   228k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (2576:11): [True: 0, False: 228k]
  |  Branch (2576:27): [True: 0, False: 228k]
  ------------------
 2577|      0|        return handler.on_error("unknown format specifier"), end;
 2578|   228k|    } else {
 2579|      0|      return handler.on_error("missing '}' in format string"), end;
 2580|      0|    }
 2581|   228k|  }
 2582|   228k|  return begin + 1;
 2583|   228k|}
_ZNK3fmt3v107context3argEi:
 1950|   228k|  FMT_CONSTEXPR auto arg(int id) const -> format_arg { return args_.get(id); }
_ZN3fmt3v107context6localeEv:
 1963|   228k|  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
_ZN3fmt3v1026basic_format_parse_contextIcE11next_arg_idEv:
  773|   228k|  FMT_CONSTEXPR auto next_arg_id() -> int {
  774|   228k|    if (next_arg_id_ < 0) {
  ------------------
  |  Branch (774:9): [True: 0, False: 228k]
  ------------------
  775|      0|      report_error("cannot switch from manual to automatic argument indexing");
  776|      0|      return 0;
  777|      0|    }
  778|   228k|    int id = next_arg_id_++;
  779|   228k|    do_check_arg_id(id);
  780|   228k|    return id;
  781|   228k|  }
_ZN3fmt3v1026basic_format_parse_contextIcE15do_check_arg_idEi:
 1105|   228k|FMT_CONSTEXPR void basic_format_parse_context<Char>::do_check_arg_id(int id) {
 1106|       |  // Argument id is only checked at compile-time during parsing because
 1107|       |  // formatting has its own validation.
 1108|   228k|  if (detail::is_constant_evaluated() &&
  ------------------
  |  Branch (1108:7): [Folded - Ignored]
  ------------------
 1109|   228k|      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   37|      0|#  define FMT_GCC_VERSION 0
  ------------------
                    (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
  ------------------
  |  |   37|      0|#  define FMT_GCC_VERSION 0
  ------------------
  |  Branch (1109:8): [Folded - Ignored]
  |  Branch (1109:28): [Folded - Ignored]
  ------------------
 1110|      0|    using context = detail::compile_parse_context<Char>;
 1111|      0|    if (id >= static_cast<context*>(this)->num_args())
  ------------------
  |  Branch (1111:9): [True: 0, False: 0]
  ------------------
 1112|      0|      report_error("argument not found");
 1113|      0|  }
 1114|   228k|}
_ZN3fmt3v106detail12parse_arg_idIcRZNS1_23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS6_EENS1_12vformat_argsIS6_E4typeENS1_10locale_refEE14format_handlerEEPKS6_SI_SI_OT0_E10id_adapterEESI_SI_SI_SK_:
 2297|   228k|                                Handler&& handler) -> const Char* {
 2298|   228k|  FMT_ASSERT(begin != end, "");
  ------------------
  |  |  402|   228k|    fmt::detail::ignore_unused((condition), (message))
  ------------------
 2299|   228k|  Char c = *begin;
 2300|   228k|  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
  ------------------
  |  Branch (2300:7): [True: 228k, False: 0]
  |  Branch (2300:19): [True: 0, False: 228k]
  ------------------
 2301|   228k|  handler.on_auto();
 2302|   228k|  return begin;
 2303|   228k|}
_ZZN3fmt3v106detail23parse_replacement_fieldIcRZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEPKS5_SH_SH_OT0_EN10id_adapter7on_autoEv:
 2555|   228k|    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
_ZN3fmt3v1016basic_format_argINS0_7contextEE13format_customEPKcRNS0_26basic_format_parse_contextIcEERS2_:
 1804|   228k|                     Context& ctx) -> bool {
 1805|   228k|    if (type_ != detail::type::custom_type) return false;
  ------------------
  |  Branch (1805:9): [True: 228k, False: 0]
  ------------------
 1806|      0|    parse_ctx.advance_to(parse_begin);
 1807|      0|    value_.custom.format(value_.custom.value, parse_ctx, ctx);
 1808|      0|    return true;
 1809|   228k|  }
_ZN3fmt3v106detail7arg_refIcEC2Ev:
 2164|   457k|  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
_ZN3fmt3v106detail7arg_refIcE5valueC2Ei:
 2179|   457k|    FMT_CONSTEXPR value(int idx = 0) : index(idx) {}
_ZN3fmt3v106detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeE:
 2368|   228k|                                      type arg_type) -> const Char* {
 2369|   228k|  auto c = '\0';
 2370|   228k|  if (end - begin > 1) {
  ------------------
  |  Branch (2370:7): [True: 228k, False: 0]
  ------------------
 2371|   228k|    auto next = to_ascii(begin[1]);
 2372|   228k|    c = parse_align(next) == align::none ? to_ascii(*begin) : '\0';
  ------------------
  |  Branch (2372:9): [True: 228k, False: 0]
  ------------------
 2373|   228k|  } else {
 2374|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2374:9): [True: 0, False: 0]
  ------------------
 2375|      0|    c = to_ascii(*begin);
 2376|      0|  }
 2377|       |
 2378|   228k|  struct {
 2379|   228k|    state current_state = state::start;
 2380|   228k|    FMT_CONSTEXPR void operator()(state s, bool valid = true) {
 2381|   228k|      if (current_state >= s || !valid)
 2382|   228k|        report_error("invalid format specifier");
 2383|   228k|      current_state = s;
 2384|   228k|    }
 2385|   228k|  } enter_state;
 2386|       |
 2387|   228k|  using pres = presentation_type;
 2388|   228k|  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
 2389|   228k|  struct {
 2390|   228k|    const Char*& begin;
 2391|   228k|    dynamic_format_specs<Char>& specs;
 2392|   228k|    type arg_type;
 2393|       |
 2394|   228k|    FMT_CONSTEXPR auto operator()(pres pres_type, int set) -> const Char* {
 2395|   228k|      if (!in(arg_type, set)) {
 2396|   228k|        if (arg_type == type::none_type) return begin;
 2397|   228k|        report_error("invalid format specifier");
 2398|   228k|      }
 2399|   228k|      specs.type = pres_type;
 2400|   228k|      return begin + 1;
 2401|   228k|    }
 2402|   228k|  } parse_presentation_type{begin, specs, arg_type};
 2403|       |
 2404|   228k|  for (;;) {
 2405|   228k|    switch (c) {
 2406|      0|    case '<':
  ------------------
  |  Branch (2406:5): [True: 0, False: 228k]
  ------------------
 2407|      0|    case '>':
  ------------------
  |  Branch (2407:5): [True: 0, False: 228k]
  ------------------
 2408|      0|    case '^':
  ------------------
  |  Branch (2408:5): [True: 0, False: 228k]
  ------------------
 2409|      0|      enter_state(state::align);
 2410|      0|      specs.align = parse_align(c);
 2411|      0|      ++begin;
 2412|      0|      break;
 2413|      0|    case '+':
  ------------------
  |  Branch (2413:5): [True: 0, False: 228k]
  ------------------
 2414|      0|    case '-':
  ------------------
  |  Branch (2414:5): [True: 0, False: 228k]
  ------------------
 2415|      0|    case ' ':
  ------------------
  |  Branch (2415:5): [True: 0, False: 228k]
  ------------------
 2416|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2416:11): [True: 0, False: 0]
  ------------------
 2417|      0|      enter_state(state::sign, in(arg_type, sint_set | float_set));
 2418|      0|      switch (c) {
  ------------------
  |  Branch (2418:15): [True: 0, False: 0]
  ------------------
 2419|      0|      case '+':
  ------------------
  |  Branch (2419:7): [True: 0, False: 0]
  ------------------
 2420|      0|        specs.sign = sign::plus;
 2421|      0|        break;
 2422|      0|      case '-':
  ------------------
  |  Branch (2422:7): [True: 0, False: 0]
  ------------------
 2423|      0|        specs.sign = sign::minus;
 2424|      0|        break;
 2425|      0|      case ' ':
  ------------------
  |  Branch (2425:7): [True: 0, False: 0]
  ------------------
 2426|      0|        specs.sign = sign::space;
 2427|      0|        break;
 2428|      0|      }
 2429|      0|      ++begin;
 2430|      0|      break;
 2431|      0|    case '#':
  ------------------
  |  Branch (2431:5): [True: 0, False: 228k]
  ------------------
 2432|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2432:11): [True: 0, False: 0]
  ------------------
 2433|      0|      enter_state(state::hash, is_arithmetic_type(arg_type));
 2434|      0|      specs.alt = true;
 2435|      0|      ++begin;
 2436|      0|      break;
 2437|      0|    case '0':
  ------------------
  |  Branch (2437:5): [True: 0, False: 228k]
  ------------------
 2438|      0|      enter_state(state::zero);
 2439|      0|      if (!is_arithmetic_type(arg_type)) {
  ------------------
  |  Branch (2439:11): [True: 0, False: 0]
  ------------------
 2440|      0|        if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2440:13): [True: 0, False: 0]
  ------------------
 2441|      0|        report_error("format specifier requires numeric argument");
 2442|      0|      }
 2443|      0|      if (specs.align == align::none) {
  ------------------
  |  Branch (2443:11): [True: 0, False: 0]
  ------------------
 2444|       |        // Ignore 0 if align is specified for compatibility with std::format.
 2445|      0|        specs.align = align::numeric;
 2446|      0|        specs.fill = '0';
 2447|      0|      }
 2448|      0|      ++begin;
 2449|      0|      break;
 2450|      0|    case '1':
  ------------------
  |  Branch (2450:5): [True: 0, False: 228k]
  ------------------
 2451|      0|    case '2':
  ------------------
  |  Branch (2451:5): [True: 0, False: 228k]
  ------------------
 2452|      0|    case '3':
  ------------------
  |  Branch (2452:5): [True: 0, False: 228k]
  ------------------
 2453|      0|    case '4':
  ------------------
  |  Branch (2453:5): [True: 0, False: 228k]
  ------------------
 2454|      0|    case '5':
  ------------------
  |  Branch (2454:5): [True: 0, False: 228k]
  ------------------
 2455|      0|    case '6':
  ------------------
  |  Branch (2455:5): [True: 0, False: 228k]
  ------------------
 2456|      0|    case '7':
  ------------------
  |  Branch (2456:5): [True: 0, False: 228k]
  ------------------
 2457|      0|    case '8':
  ------------------
  |  Branch (2457:5): [True: 0, False: 228k]
  ------------------
 2458|      0|    case '9':
  ------------------
  |  Branch (2458:5): [True: 0, False: 228k]
  ------------------
 2459|      0|    case '{':
  ------------------
  |  Branch (2459:5): [True: 0, False: 228k]
  ------------------
 2460|      0|      enter_state(state::width);
 2461|      0|      begin = parse_dynamic_spec(begin, end, specs.width, specs.width_ref, ctx);
 2462|      0|      break;
 2463|      0|    case '.':
  ------------------
  |  Branch (2463:5): [True: 0, False: 228k]
  ------------------
 2464|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2464:11): [True: 0, False: 0]
  ------------------
 2465|      0|      enter_state(state::precision,
 2466|      0|                  in(arg_type, float_set | string_set | cstring_set));
 2467|      0|      begin = parse_precision(begin, end, specs.precision, specs.precision_ref,
 2468|      0|                              ctx);
 2469|      0|      break;
 2470|      0|    case 'L':
  ------------------
  |  Branch (2470:5): [True: 0, False: 228k]
  ------------------
 2471|      0|      if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2471:11): [True: 0, False: 0]
  ------------------
 2472|      0|      enter_state(state::locale, is_arithmetic_type(arg_type));
 2473|      0|      specs.localized = true;
 2474|      0|      ++begin;
 2475|      0|      break;
 2476|  16.6k|    case 'd':
  ------------------
  |  Branch (2476:5): [True: 16.6k, False: 212k]
  ------------------
 2477|  16.6k|      return parse_presentation_type(pres::dec, integral_set);
 2478|      0|    case 'X':
  ------------------
  |  Branch (2478:5): [True: 0, False: 228k]
  ------------------
 2479|      0|      specs.upper = true;
 2480|      0|      FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2481|      0|    case 'x':
  ------------------
  |  Branch (2481:5): [True: 0, False: 228k]
  ------------------
 2482|      0|      return parse_presentation_type(pres::hex, integral_set);
 2483|      0|    case 'o':
  ------------------
  |  Branch (2483:5): [True: 0, False: 228k]
  ------------------
 2484|      0|      return parse_presentation_type(pres::oct, integral_set);
 2485|      0|    case 'B':
  ------------------
  |  Branch (2485:5): [True: 0, False: 228k]
  ------------------
 2486|      0|      specs.upper = true;
 2487|      0|      FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2488|      0|    case 'b':
  ------------------
  |  Branch (2488:5): [True: 0, False: 228k]
  ------------------
 2489|      0|      return parse_presentation_type(pres::bin, integral_set);
 2490|      0|    case 'E':
  ------------------
  |  Branch (2490:5): [True: 0, False: 228k]
  ------------------
 2491|      0|      specs.upper = true;
 2492|      0|      FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2493|      0|    case 'e':
  ------------------
  |  Branch (2493:5): [True: 0, False: 228k]
  ------------------
 2494|      0|      return parse_presentation_type(pres::exp, float_set);
 2495|      0|    case 'F':
  ------------------
  |  Branch (2495:5): [True: 0, False: 228k]
  ------------------
 2496|      0|      specs.upper = true;
 2497|      0|      FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2498|      0|    case 'f':
  ------------------
  |  Branch (2498:5): [True: 0, False: 228k]
  ------------------
 2499|      0|      return parse_presentation_type(pres::fixed, float_set);
 2500|      0|    case 'G':
  ------------------
  |  Branch (2500:5): [True: 0, False: 228k]
  ------------------
 2501|      0|      specs.upper = true;
 2502|      0|      FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2503|      0|    case 'g':
  ------------------
  |  Branch (2503:5): [True: 0, False: 228k]
  ------------------
 2504|      0|      return parse_presentation_type(pres::general, float_set);
 2505|      0|    case 'A':
  ------------------
  |  Branch (2505:5): [True: 0, False: 228k]
  ------------------
 2506|      0|      specs.upper = true;
 2507|      0|      FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2508|      0|    case 'a':
  ------------------
  |  Branch (2508:5): [True: 0, False: 228k]
  ------------------
 2509|      0|      return parse_presentation_type(pres::hexfloat, float_set);
 2510|      0|    case 'c':
  ------------------
  |  Branch (2510:5): [True: 0, False: 228k]
  ------------------
 2511|      0|      if (arg_type == type::bool_type) report_error("invalid format specifier");
  ------------------
  |  Branch (2511:11): [True: 0, False: 0]
  ------------------
 2512|      0|      return parse_presentation_type(pres::chr, integral_set);
 2513|   212k|    case 's':
  ------------------
  |  Branch (2513:5): [True: 212k, False: 16.6k]
  ------------------
 2514|   212k|      return parse_presentation_type(pres::string,
 2515|   212k|                                     bool_set | string_set | cstring_set);
 2516|      0|    case 'p':
  ------------------
  |  Branch (2516:5): [True: 0, False: 228k]
  ------------------
 2517|      0|      return parse_presentation_type(pres::pointer, pointer_set | cstring_set);
 2518|      0|    case '?':
  ------------------
  |  Branch (2518:5): [True: 0, False: 228k]
  ------------------
 2519|      0|      return parse_presentation_type(pres::debug,
 2520|      0|                                     char_set | string_set | cstring_set);
 2521|      0|    case '}':
  ------------------
  |  Branch (2521:5): [True: 0, False: 228k]
  ------------------
 2522|      0|      return begin;
 2523|      0|    default: {
  ------------------
  |  Branch (2523:5): [True: 0, False: 228k]
  ------------------
 2524|      0|      if (*begin == '}') return begin;
  ------------------
  |  Branch (2524:11): [True: 0, False: 0]
  ------------------
 2525|       |      // Parse fill and alignment.
 2526|      0|      auto fill_end = begin + code_point_length(begin);
 2527|      0|      if (end - fill_end <= 0) {
  ------------------
  |  Branch (2527:11): [True: 0, False: 0]
  ------------------
 2528|      0|        report_error("invalid format specifier");
 2529|      0|        return begin;
 2530|      0|      }
 2531|      0|      if (*begin == '{') {
  ------------------
  |  Branch (2531:11): [True: 0, False: 0]
  ------------------
 2532|      0|        report_error("invalid fill character '{'");
 2533|      0|        return begin;
 2534|      0|      }
 2535|      0|      auto align = parse_align(to_ascii(*fill_end));
 2536|      0|      enter_state(state::align, align != align::none);
 2537|      0|      specs.fill =
 2538|      0|          basic_string_view<Char>(begin, to_unsigned(fill_end - begin));
 2539|      0|      specs.align = align;
 2540|      0|      begin = fill_end + 1;
 2541|      0|    }
 2542|   228k|    }
 2543|      0|    if (begin == end) return begin;
  ------------------
  |  Branch (2543:9): [True: 0, False: 0]
  ------------------
 2544|      0|    c = to_ascii(*begin);
 2545|      0|  }
 2546|   228k|}
_ZN3fmt3v106detail8to_asciiIcLi0EEEcT_:
 2197|   457k|constexpr auto to_ascii(Char c) -> char {
 2198|   457k|  return c <= 0xff ? static_cast<char>(c) : '\0';
  ------------------
  |  Branch (2198:10): [True: 457k, False: 0]
  ------------------
 2199|   457k|}
_ZN3fmt3v106detail11parse_alignEc:
 2251|   228k|FMT_CONSTEXPR inline auto parse_align(char c) -> align_t {
 2252|   228k|  switch (c) {
  ------------------
  |  Branch (2252:11): [True: 228k, False: 0]
  ------------------
 2253|      0|  case '<':
  ------------------
  |  Branch (2253:3): [True: 0, False: 228k]
  ------------------
 2254|      0|    return align::left;
 2255|      0|  case '>':
  ------------------
  |  Branch (2255:3): [True: 0, False: 228k]
  ------------------
 2256|      0|    return align::right;
 2257|      0|  case '^':
  ------------------
  |  Branch (2257:3): [True: 0, False: 228k]
  ------------------
 2258|      0|    return align::center;
 2259|   228k|  }
 2260|   228k|  return align::none;
 2261|   228k|}
_ZN3fmt3v106detail2inENS1_4typeEi:
  701|   228k|constexpr auto in(type t, int set) -> bool {
  702|   228k|  return ((set >> static_cast<int>(t)) & 1) != 0;
  703|   228k|}
_ZZN3fmt3v106detail18parse_format_specsIcEEPKT_S5_S5_RNS1_20dynamic_format_specsIS3_EERNS0_26basic_format_parse_contextIS3_EENS1_4typeEENUt0_clENS0_17presentation_typeEi:
 2394|   228k|    FMT_CONSTEXPR auto operator()(pres pres_type, int set) -> const Char* {
 2395|   228k|      if (!in(arg_type, set)) {
  ------------------
  |  Branch (2395:11): [True: 0, False: 228k]
  ------------------
 2396|      0|        if (arg_type == type::none_type) return begin;
  ------------------
  |  Branch (2396:13): [True: 0, False: 0]
  ------------------
 2397|      0|        report_error("invalid format specifier");
 2398|      0|      }
 2399|   228k|      specs.type = pres_type;
 2400|   228k|      return begin + 1;
 2401|   228k|    }
_ZNK3fmt3v1016basic_format_argINS0_7contextEE4typeEv:
 1750|   228k|  auto type() const -> detail::type { return type_; }
_ZN3fmt3v1016basic_format_argINS0_7contextEE5visitINS0_6detail13arg_formatterIcEEEEDTclfp_Li0EEEOT_:
 1763|   228k|  FMT_CONSTEXPR auto visit(Visitor&& vis) -> decltype(vis(0)) {
 1764|   228k|    switch (type_) {
  ------------------
  |  Branch (1764:13): [True: 0, False: 228k]
  ------------------
 1765|      0|    case detail::type::none_type:
  ------------------
  |  Branch (1765:5): [True: 0, False: 228k]
  ------------------
 1766|      0|      break;
 1767|      0|    case detail::type::int_type:
  ------------------
  |  Branch (1767:5): [True: 0, False: 228k]
  ------------------
 1768|      0|      return vis(value_.int_value);
 1769|    378|    case detail::type::uint_type:
  ------------------
  |  Branch (1769:5): [True: 378, False: 228k]
  ------------------
 1770|    378|      return vis(value_.uint_value);
 1771|      0|    case detail::type::long_long_type:
  ------------------
  |  Branch (1771:5): [True: 0, False: 228k]
  ------------------
 1772|      0|      return vis(value_.long_long_value);
 1773|  16.2k|    case detail::type::ulong_long_type:
  ------------------
  |  Branch (1773:5): [True: 16.2k, False: 212k]
  ------------------
 1774|  16.2k|      return vis(value_.ulong_long_value);
 1775|      0|    case detail::type::int128_type:
  ------------------
  |  Branch (1775:5): [True: 0, False: 228k]
  ------------------
 1776|      0|      return vis(detail::convert_for_visit(value_.int128_value));
 1777|      0|    case detail::type::uint128_type:
  ------------------
  |  Branch (1777:5): [True: 0, False: 228k]
  ------------------
 1778|      0|      return vis(detail::convert_for_visit(value_.uint128_value));
 1779|      0|    case detail::type::bool_type:
  ------------------
  |  Branch (1779:5): [True: 0, False: 228k]
  ------------------
 1780|      0|      return vis(value_.bool_value);
 1781|      0|    case detail::type::char_type:
  ------------------
  |  Branch (1781:5): [True: 0, False: 228k]
  ------------------
 1782|      0|      return vis(value_.char_value);
 1783|      0|    case detail::type::float_type:
  ------------------
  |  Branch (1783:5): [True: 0, False: 228k]
  ------------------
 1784|      0|      return vis(value_.float_value);
 1785|      0|    case detail::type::double_type:
  ------------------
  |  Branch (1785:5): [True: 0, False: 228k]
  ------------------
 1786|      0|      return vis(value_.double_value);
 1787|      0|    case detail::type::long_double_type:
  ------------------
  |  Branch (1787:5): [True: 0, False: 228k]
  ------------------
 1788|      0|      return vis(value_.long_double_value);
 1789|   212k|    case detail::type::cstring_type:
  ------------------
  |  Branch (1789:5): [True: 212k, False: 16.6k]
  ------------------
 1790|   212k|      return vis(value_.string.data);
 1791|      0|    case detail::type::string_type:
  ------------------
  |  Branch (1791:5): [True: 0, False: 228k]
  ------------------
 1792|      0|      using sv = basic_string_view<typename Context::char_type>;
 1793|      0|      return vis(sv(value_.string.data, value_.string.size));
 1794|      0|    case detail::type::pointer_type:
  ------------------
  |  Branch (1794:5): [True: 0, False: 228k]
  ------------------
 1795|      0|      return vis(value_.pointer);
 1796|      0|    case detail::type::custom_type:
  ------------------
  |  Branch (1796:5): [True: 0, False: 228k]
  ------------------
 1797|      0|      return vis(typename basic_format_arg<Context>::handle(value_.custom));
 1798|   228k|    }
 1799|      0|    return vis(monostate());
 1800|   228k|  }
_ZN3fmt3v106detail5valueINS0_7contextEEC2Ej:
 1338|    378|  constexpr FMT_ALWAYS_INLINE value(unsigned val) : uint_value(val) {}
_ZN3fmt3v106detail5valueINS0_7contextEEC2Ey:
 1341|  16.2k|      : ulong_long_value(val) {}
_ZN3fmt3v106detail10arg_mapperINS0_7contextEE3mapEh:
 1425|    378|  FMT_MAP_API auto map(unsigned char val) -> unsigned { return val; }
_ZN3fmt3v106detail4findILb0EcPKcEEbT1_S5_T0_RS5_:
 2220|   532k|                              const char*& out) -> bool {
 2221|   532k|  out =
 2222|   532k|      static_cast<const char*>(memchr(first, value, to_unsigned(last - first)));
 2223|   532k|  return out != nullptr;
 2224|   532k|}
_ZZN3fmt3v106detail19parse_format_stringILb0EcZNS1_10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS5_EENS1_12vformat_argsIS5_E4typeENS1_10locale_refEE14format_handlerEEvNS8_IT0_EEOT1_EN6writerclEPKcSL_:
 2609|   266k|    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
 2610|   266k|      if (from == to) return;
  ------------------
  |  Branch (2610:11): [True: 0, False: 266k]
  ------------------
 2611|   266k|      for (;;) {
 2612|   266k|        const Char* p = nullptr;
 2613|   266k|        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
  ------------------
  |  Branch (2613:13): [True: 266k, False: 0]
  ------------------
 2614|   266k|          return handler_.on_text(from, to);
 2615|      0|        ++p;
 2616|      0|        if (p == to || *p != '}')
  ------------------
  |  Branch (2616:13): [True: 0, False: 0]
  |  Branch (2616:24): [True: 0, False: 0]
  ------------------
 2617|      0|          return handler_.on_error("unmatched '}' in format string");
 2618|      0|        handler_.on_text(from, p);
 2619|      0|        from = p + 1;
 2620|      0|      }
 2621|   266k|    }
_ZN3fmt3v106detail10arg_mapperINS0_7contextEE3mapEPKc:
 1462|   212k|  FMT_MAP_API auto map(const char_type* val) -> const char_type* { return val; }
_ZN3fmt3v106detail5valueINS0_7contextEEC2EPKc:
 1349|   212k|  FMT_CONSTEXPR FMT_ALWAYS_INLINE value(const char_type* val) {
 1350|   212k|    string.data = val;
 1351|   212k|    if (is_constant_evaluated()) string.size = {};
  ------------------
  |  Branch (1351:9): [Folded - Ignored]
  ------------------
 1352|   212k|  }
_ZNK3fmt3v106detail6bufferIcE4dataEv:
  890|   134k|  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }

_ZN3fmt3v107vformatENS0_17basic_string_viewIcEENS0_17basic_format_argsINS0_7contextEEE:
 1431|   134k|FMT_FUNC auto vformat(string_view fmt, format_args args) -> std::string {
 1432|       |  // Don't optimize the "{}" case to keep the binary size small and because it
 1433|       |  // can be better optimized in fmt::format anyway.
 1434|   134k|  auto buffer = memory_buffer();
 1435|   134k|  detail::vformat_to(buffer, fmt, args);
 1436|   134k|  return to_string(buffer);
 1437|   134k|}

_ZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refE:
 4213|   134k|                typename vformat_args<Char>::type args, locale_ref loc) {
 4214|   134k|  auto out = basic_appender<Char>(buf);
 4215|   134k|  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
  ------------------
  |  Branch (4215:7): [True: 0, False: 134k]
  |  Branch (4215:26): [True: 0, False: 0]
  ------------------
 4216|      0|    auto arg = args.get(0);
 4217|      0|    if (!arg) report_error("argument not found");
  ------------------
  |  Branch (4217:9): [True: 0, False: 0]
  ------------------
 4218|      0|    arg.visit(default_arg_formatter<Char>{out, args, loc});
 4219|      0|    return;
 4220|      0|  }
 4221|       |
 4222|   134k|  struct format_handler {
 4223|   134k|    basic_format_parse_context<Char> parse_context;
 4224|   134k|    buffered_context<Char> context;
 4225|       |
 4226|   134k|    format_handler(basic_appender<Char> p_out, basic_string_view<Char> str,
 4227|   134k|                   basic_format_args<buffered_context<Char>> p_args,
 4228|   134k|                   locale_ref p_loc)
 4229|   134k|        : parse_context(str), context(p_out, p_args, p_loc) {}
 4230|       |
 4231|   134k|    void on_text(const Char* begin, const Char* end) {
 4232|   134k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4233|   134k|      context.advance_to(write<Char>(context.out(), text));
 4234|   134k|    }
 4235|       |
 4236|   134k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4237|   134k|      return parse_context.next_arg_id();
 4238|   134k|    }
 4239|   134k|    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
 4240|   134k|      parse_context.check_arg_id(id);
 4241|   134k|      return id;
 4242|   134k|    }
 4243|   134k|    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
 4244|   134k|      parse_context.check_arg_id(id);
 4245|   134k|      int arg_id = context.arg_id(id);
 4246|   134k|      if (arg_id < 0) report_error("argument not found");
 4247|   134k|      return arg_id;
 4248|   134k|    }
 4249|       |
 4250|   134k|    FMT_INLINE void on_replacement_field(int id, const Char*) {
 4251|   134k|      auto arg = get_arg(context, id);
 4252|   134k|      context.advance_to(arg.visit(default_arg_formatter<Char>{
 4253|   134k|          context.out(), context.args(), context.locale()}));
 4254|   134k|    }
 4255|       |
 4256|   134k|    auto on_format_specs(int id, const Char* begin, const Char* end)
 4257|   134k|        -> const Char* {
 4258|   134k|      auto arg = get_arg(context, id);
 4259|       |      // Not using a visitor for custom types gives better codegen.
 4260|   134k|      if (arg.format_custom(begin, parse_context, context))
 4261|   134k|        return parse_context.begin();
 4262|   134k|      auto specs = detail::dynamic_format_specs<Char>();
 4263|   134k|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4264|   134k|      detail::handle_dynamic_spec<detail::width_checker>(
 4265|   134k|          specs.width, specs.width_ref, context);
 4266|   134k|      detail::handle_dynamic_spec<detail::precision_checker>(
 4267|   134k|          specs.precision, specs.precision_ref, context);
 4268|   134k|      if (begin == end || *begin != '}')
 4269|   134k|        report_error("missing '}' in format string");
 4270|   134k|      context.advance_to(arg.visit(
 4271|   134k|          arg_formatter<Char>{context.out(), specs, context.locale()}));
 4272|   134k|      return begin;
 4273|   134k|    }
 4274|       |
 4275|   134k|    FMT_NORETURN void on_error(const char* message) { report_error(message); }
 4276|   134k|  };
 4277|   134k|  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
 4278|   134k|}
_ZN3fmt3v106detail12count_digitsEj:
 1218|    756|FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
 1219|    756|#ifdef FMT_BUILTIN_CLZ
 1220|    756|  if (!is_constant_evaluated()) {
  ------------------
  |  Branch (1220:7): [Folded - Ignored]
  ------------------
 1221|    756|    return do_count_digits(n);
 1222|    756|  }
 1223|      0|#endif
 1224|      0|  return count_digits_fallback(n);
 1225|    756|}
_ZN3fmt3v106detail15do_count_digitsEj:
 1195|    756|FMT_INLINE auto do_count_digits(uint32_t n) -> int {
 1196|       |// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
 1197|       |// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
 1199|    756|  static constexpr uint64_t table[] = {
 1200|    756|      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1201|    756|      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1202|    756|      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1203|    756|      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1204|    756|      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1205|    756|      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1206|    756|      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1207|    756|      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1208|    756|      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1209|    756|      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1210|       |      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
                    FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
  ------------------
  |  | 1198|    756|#  define FMT_INC(T) (((sizeof(#T) - 1ull) << 32) - T)
  ------------------
 1211|    756|  };
 1212|    756|  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
  ------------------
  |  |  166|    756|#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
  ------------------
 1213|    756|  return static_cast<int>((n + inc) >> 32);
 1214|    756|}
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEEC2ERKS4_:
  870|   134k|      : detail::buffer<T>(grow), alloc_(alloc) {
  871|   134k|    this->set(store_, SIZE);
  872|   134k|    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
  ------------------
  |  Branch (872:9): [Folded - Ignored]
  ------------------
  873|   134k|  }
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEE4growERNS0_6detail6bufferIcEEm:
  840|  42.0k|  static FMT_CONSTEXPR20 void grow(detail::buffer<T>& buf, size_t size) {
  841|  42.0k|    detail::abort_fuzzing_if(size > 5000);
  842|  42.0k|    auto& self = static_cast<basic_memory_buffer&>(buf);
  843|  42.0k|    const size_t max_size =
  844|  42.0k|        std::allocator_traits<Allocator>::max_size(self.alloc_);
  845|  42.0k|    size_t old_capacity = buf.capacity();
  846|  42.0k|    size_t new_capacity = old_capacity + old_capacity / 2;
  847|  42.0k|    if (size > new_capacity)
  ------------------
  |  Branch (847:9): [True: 18.3k, False: 23.7k]
  ------------------
  848|  18.3k|      new_capacity = size;
  849|  23.7k|    else if (new_capacity > max_size)
  ------------------
  |  Branch (849:14): [True: 0, False: 23.7k]
  ------------------
  850|      0|      new_capacity = size > max_size ? size : max_size;
  ------------------
  |  Branch (850:22): [True: 0, False: 0]
  ------------------
  851|  42.0k|    T* old_data = buf.data();
  852|  42.0k|    T* new_data = self.alloc_.allocate(new_capacity);
  853|       |    // Suppress a bogus -Wstringop-overflow in gcc 13.1 (#3481).
  854|  42.0k|    detail::assume(buf.size() <= new_capacity);
  855|       |    // The following code doesn't throw, so the raw pointer above doesn't leak.
  856|  42.0k|    memcpy(new_data, old_data, buf.size() * sizeof(T));
  857|  42.0k|    self.set(new_data, new_capacity);
  858|       |    // deallocate must not throw according to the standard, but even if it does,
  859|       |    // the buffer already uses the new storage and will deallocate it in
  860|       |    // destructor.
  861|  42.0k|    if (old_data != self.store_) self.alloc_.deallocate(old_data, old_capacity);
  ------------------
  |  Branch (861:9): [True: 18.8k, False: 23.2k]
  ------------------
  862|  42.0k|  }
_ZN3fmt3v106detail16abort_fuzzing_ifEb:
  273|  42.0k|FMT_CONSTEXPR inline void abort_fuzzing_if(bool condition) {
  274|  42.0k|  ignore_unused(condition);
  275|       |#ifdef FMT_FUZZ
  276|       |  if (condition) throw std::runtime_error("fuzzing limit reached");
  277|       |#endif
  278|  42.0k|}
_ZN3fmt3v106detail6assumeEb:
  486|   176k|FMT_INLINE void assume(bool condition) {
  487|   176k|  (void)condition;
  488|   176k|#if FMT_HAS_BUILTIN(__builtin_assume) && !FMT_ICC_VERSION
  489|   176k|  __builtin_assume(condition);
  490|       |#elif FMT_GCC_VERSION
  491|       |  if (!condition) __builtin_unreachable();
  492|       |#endif
  493|   176k|}
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEED2Ev:
  874|   134k|  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
_ZN3fmt3v1019basic_memory_bufferIcLm500ENSt3__19allocatorIcEEE10deallocateEv:
  835|   134k|  FMT_CONSTEXPR20 void deallocate() {
  836|   134k|    T* data = this->data();
  837|   134k|    if (data != store_) alloc_.deallocate(data, this->capacity());
  ------------------
  |  Branch (837:9): [True: 23.2k, False: 110k]
  ------------------
  838|   134k|  }
_ZN3fmt3v106detail5writeIcNS0_14basic_appenderIcEEEET0_S5_NS0_17basic_string_viewIT_EE:
 3631|   273k|    -> OutputIt {
 3632|   273k|  auto it = reserve(out, value.size());
 3633|   273k|  it = copy_noinline<Char>(value.begin(), value.end(), it);
 3634|   273k|  return base_iterator(out, it);
 3635|   273k|}
_ZN3fmt3v106detail7reserveIcEENS0_14basic_appenderIT_EES5_m:
  527|   501k|inline auto reserve(basic_appender<T> it, size_t n) -> basic_appender<T> {
  528|   501k|  buffer<T>& buf = get_container(it);
  529|   501k|  buf.try_reserve(buf.size() + n);
  530|   501k|  return it;
  531|   501k|}
_ZN3fmt3v106detail13copy_noinlineIcPKcNS0_14basic_appenderIcEEEET1_T0_S8_S7_:
  587|   273k|                                              OutputIt out) -> OutputIt {
  588|   273k|  return copy<OutChar>(begin, end, out);
  589|   273k|}
_ZN3fmt3v106detail13base_iteratorINS0_14basic_appenderIcEEEET_S5_S5_:
  564|   501k|constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
  565|   501k|  return it;
  566|   501k|}
_ZN3fmt3v106detail14format_decimalIcjEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1288|    378|    -> format_decimal_result<Char*> {
 1289|    378|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  402|    378|    fmt::detail::ignore_unused((condition), (message))
  ------------------
 1290|    378|  out += size;
 1291|    378|  Char* end = out;
 1292|    378|  while (value >= 100) {
  ------------------
  |  Branch (1292:10): [True: 0, False: 378]
  ------------------
 1293|       |    // Integer division is slow so do it for a group of two digits instead
 1294|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1295|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1296|      0|    out -= 2;
 1297|      0|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1298|      0|    value /= 100;
 1299|      0|  }
 1300|    378|  if (value < 10) {
  ------------------
  |  Branch (1300:7): [True: 378, False: 0]
  ------------------
 1301|    378|    *--out = static_cast<Char>('0' + value);
 1302|    378|    return {out, end};
 1303|    378|  }
 1304|      0|  out -= 2;
 1305|      0|  copy2(out, digits2(static_cast<size_t>(value)));
 1306|      0|  return {out, end};
 1307|    378|}
_ZN3fmt3v106detail5copy2IcEEvPT_PKc:
 1269|    860|FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
 1270|    860|  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
  ------------------
  |  Branch (1270:7): [Folded - Ignored]
  |  Branch (1270:35): [Folded - Ignored]
  ------------------
 1271|    860|    memcpy(dst, src, 2);
 1272|    860|    return;
 1273|    860|  }
 1274|      0|  *dst++ = static_cast<Char>(*src++);
 1275|      0|  *dst = static_cast<Char>(*src);
 1276|      0|}
_ZN3fmt3v106detail7digits2Em:
 1108|    860|constexpr auto digits2(size_t value) -> const char* {
 1109|       |  // GCC generates slightly better code when value is pointer-size.
 1110|    860|  return &"0001020304050607080910111213141516171819"
 1111|    860|         "2021222324252627282930313233343536373839"
 1112|    860|         "4041424344454647484950515253545556575859"
 1113|    860|         "6061626364656667686970717273747576777879"
 1114|    860|         "8081828384858687888990919293949596979899"[value * 2];
 1115|    860|}
_ZN3fmt3v106detail14format_decimalIcjNS0_14basic_appenderIcEELi0EEENS1_21format_decimal_resultIT1_EES6_T0_i:
 1312|    378|    -> format_decimal_result<Iterator> {
 1313|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1314|    378|  Char buffer[digits10<UInt>() + 1] = {};
 1315|    378|  auto end = format_decimal(buffer, value, size).end;
 1316|    378|  return {out, detail::copy_noinline<Char>(buffer, end, out)};
 1317|    378|}
_ZN3fmt3v106detail13copy_noinlineIcPcNS0_14basic_appenderIcEEEET1_T0_S7_S6_:
  587|  16.6k|                                              OutputIt out) -> OutputIt {
  588|  16.6k|  return copy<OutChar>(begin, end, out);
  589|  16.6k|}
_ZN3fmt3v106detail11is_negativeIjLi0EEEbT_:
 1080|    378|constexpr auto is_negative(T) -> bool {
 1081|    378|  return false;
 1082|    378|}
_ZN3fmt3v106detail12count_digitsEm:
 1168|  32.4k|FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
 1169|  32.4k|#ifdef FMT_BUILTIN_CLZLL
 1170|  32.4k|  if (!is_constant_evaluated()) return do_count_digits(n);
  ------------------
  |  Branch (1170:7): [Folded - Ignored]
  ------------------
 1171|      0|#endif
 1172|      0|  return count_digits_fallback(n);
 1173|  32.4k|}
_ZN3fmt3v106detail15do_count_digitsEm:
 1148|  32.4k|inline auto do_count_digits(uint64_t n) -> int {
 1149|       |  // This has comparable performance to the version by Kendall Willets
 1150|       |  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
 1151|       |  // but uses smaller tables.
 1152|       |  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
 1153|  32.4k|  static constexpr uint8_t bsr2log10[] = {
 1154|  32.4k|      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
 1155|  32.4k|      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
 1156|  32.4k|      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
 1157|  32.4k|      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
 1158|  32.4k|  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
  ------------------
  |  |  169|  32.4k|#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
  ------------------
 1159|  32.4k|  static constexpr const uint64_t zero_or_powers_of_10[] = {
 1160|  32.4k|      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1103|  32.4k|  factor * 10, (factor) * 100, (factor) * 1000, (factor) * 10000, \
  |  | 1104|  32.4k|      (factor) * 100000, (factor) * 1000000, (factor) * 10000000, \
  |  | 1105|  32.4k|      (factor) * 100000000, (factor) * 1000000000
  ------------------
                    0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
  ------------------
  |  | 1103|  32.4k|  factor * 10, (factor) * 100, (factor) * 1000, (factor) * 10000, \
  |  | 1104|  32.4k|      (factor) * 100000, (factor) * 1000000, (factor) * 10000000, \
  |  | 1105|  32.4k|      (factor) * 100000000, (factor) * 1000000000
  ------------------
 1161|  32.4k|      10000000000000000000ULL};
 1162|  32.4k|  return t - (n < zero_or_powers_of_10[t]);
 1163|  32.4k|}
_ZN3fmt3v106detail14format_decimalIcmEENS1_21format_decimal_resultIPT_EES5_T0_i:
 1288|  16.2k|    -> format_decimal_result<Char*> {
 1289|  16.2k|  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
  ------------------
  |  |  402|  16.2k|    fmt::detail::ignore_unused((condition), (message))
  ------------------
 1290|  16.2k|  out += size;
 1291|  16.2k|  Char* end = out;
 1292|  16.3k|  while (value >= 100) {
  ------------------
  |  Branch (1292:10): [True: 80, False: 16.2k]
  ------------------
 1293|       |    // Integer division is slow so do it for a group of two digits instead
 1294|       |    // of for every digit. The idea comes from the talk by Alexandrescu
 1295|       |    // "Three Optimization Tips for C++". See speed-test for a comparison.
 1296|     80|    out -= 2;
 1297|     80|    copy2(out, digits2(static_cast<size_t>(value % 100)));
 1298|     80|    value /= 100;
 1299|     80|  }
 1300|  16.2k|  if (value < 10) {
  ------------------
  |  Branch (1300:7): [True: 15.4k, False: 780]
  ------------------
 1301|  15.4k|    *--out = static_cast<Char>('0' + value);
 1302|  15.4k|    return {out, end};
 1303|  15.4k|  }
 1304|    780|  out -= 2;
 1305|    780|  copy2(out, digits2(static_cast<size_t>(value)));
 1306|    780|  return {out, end};
 1307|  16.2k|}
_ZN3fmt3v106detail14format_decimalIcmNS0_14basic_appenderIcEELi0EEENS1_21format_decimal_resultIT1_EES6_T0_i:
 1312|  16.2k|    -> format_decimal_result<Iterator> {
 1313|       |  // Buffer is large enough to hold all digits (digits10 + 1).
 1314|  16.2k|  Char buffer[digits10<UInt>() + 1] = {};
 1315|  16.2k|  auto end = format_decimal(buffer, value, size).end;
 1316|  16.2k|  return {out, detail::copy_noinline<Char>(buffer, end, out)};
 1317|  16.2k|}
_ZN3fmt3v106detail11is_negativeIyLi0EEEbT_:
 1080|  16.2k|constexpr auto is_negative(T) -> bool {
 1081|  16.2k|  return false;
 1082|  16.2k|}
_ZN3fmt3v106detail18write_int_noinlineIcNS0_14basic_appenderIcEEjEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refE:
 2202|    378|                                                   locale_ref loc) -> OutputIt {
 2203|    378|  return write_int<Char>(out, arg, specs, loc);
 2204|    378|}
_ZN3fmt3v106detail9write_intIcNS0_14basic_appenderIcEEjEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refE:
 2149|    378|    -> OutputIt {
 2150|    378|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2151|    378|  auto abs_value = arg.abs_value;
 2152|    378|  auto prefix = arg.prefix;
 2153|    378|  switch (specs.type) {
 2154|      0|  default:
  ------------------
  |  Branch (2154:3): [True: 0, False: 378]
  ------------------
 2155|      0|    FMT_ASSERT(false, "");
  ------------------
  |  |  402|      0|    fmt::detail::ignore_unused((condition), (message))
  ------------------
 2156|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2157|      0|  case presentation_type::none:
  ------------------
  |  Branch (2157:3): [True: 0, False: 378]
  ------------------
 2158|    378|  case presentation_type::dec: {
  ------------------
  |  Branch (2158:3): [True: 378, False: 0]
  ------------------
 2159|    378|    int num_digits = count_digits(abs_value);
 2160|    378|    return write_int<Char>(
 2161|    378|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2162|    378|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2163|    378|        });
 2164|      0|  }
 2165|      0|  case presentation_type::hex: {
  ------------------
  |  Branch (2165:3): [True: 0, False: 378]
  ------------------
 2166|      0|    if (specs.alt)
  ------------------
  |  Branch (2166:9): [True: 0, False: 0]
  ------------------
 2167|      0|      prefix_append(prefix, unsigned(specs.upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2167:38): [True: 0, False: 0]
  ------------------
 2168|      0|    int num_digits = count_digits<4>(abs_value);
 2169|      0|    return write_int<Char>(
 2170|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2171|      0|          return format_uint<4, Char>(it, abs_value, num_digits, specs.upper);
 2172|      0|        });
 2173|      0|  }
 2174|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2174:3): [True: 0, False: 378]
  ------------------
 2175|      0|    int num_digits = count_digits<3>(abs_value);
 2176|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2177|       |    // is not greater than the number of digits.
 2178|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2178:9): [True: 0, False: 0]
  |  Branch (2178:22): [True: 0, False: 0]
  |  Branch (2178:55): [True: 0, False: 0]
  ------------------
 2179|      0|      prefix_append(prefix, '0');
 2180|      0|    return write_int<Char>(
 2181|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2182|      0|          return format_uint<3, Char>(it, abs_value, num_digits);
 2183|      0|        });
 2184|      0|  }
 2185|      0|  case presentation_type::bin: {
  ------------------
  |  Branch (2185:3): [True: 0, False: 378]
  ------------------
 2186|      0|    if (specs.alt)
  ------------------
  |  Branch (2186:9): [True: 0, False: 0]
  ------------------
 2187|      0|      prefix_append(prefix, unsigned(specs.upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2187:38): [True: 0, False: 0]
  ------------------
 2188|      0|    int num_digits = count_digits<1>(abs_value);
 2189|      0|    return write_int<Char>(
 2190|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2191|      0|          return format_uint<1, Char>(it, abs_value, num_digits);
 2192|      0|        });
 2193|      0|  }
 2194|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2194:3): [True: 0, False: 378]
  ------------------
 2195|      0|    return write_char<Char>(out, static_cast<Char>(abs_value), specs);
 2196|    378|  }
 2197|    378|}
_ZN3fmt3v106detail9write_intIcNS0_14basic_appenderIcEEZNS1_9write_intIcS4_jEET0_S6_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refEEUlS4_E_EES6_S6_ijSC_S8_:
 1955|    378|                                        W write_digits) -> OutputIt {
 1956|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1957|    378|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1957:7): [True: 378, False: 0]
  ------------------
 1958|    378|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1959|    378|    if (prefix != 0) {
  ------------------
  |  Branch (1959:9): [True: 0, False: 378]
  ------------------
 1960|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1960:44): [True: 0, False: 0]
  ------------------
 1961|      0|        *it++ = static_cast<Char>(p & 0xff);
 1962|      0|    }
 1963|    378|    return base_iterator(out, write_digits(it));
 1964|    378|  }
 1965|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1966|      0|  return write_padded<Char, align::right>(
 1967|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1968|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1969|      0|          *it++ = static_cast<Char>(p & 0xff);
 1970|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1971|      0|        return write_digits(it);
 1972|      0|      });
 1973|    378|}
_ZZN3fmt3v106detail9write_intIcNS0_14basic_appenderIcEEjEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refEENKUlS4_E_clES4_:
 2161|    378|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2162|    378|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2163|    378|        });
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler7on_textEPKcSF_:
 4231|   273k|    void on_text(const Char* begin, const Char* end) {
 4232|   273k|      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
 4233|   273k|      context.advance_to(write<Char>(context.out(), text));
 4234|   273k|    }
_ZN3fmt3v106detail7get_argINS0_7contextEiEEDTcldtfp_3argfp0_EERT_T0_:
 3788|   228k|FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) -> decltype(ctx.arg(id)) {
 3789|   228k|  auto arg = ctx.arg(id);
 3790|   228k|  if (!arg) report_error("argument not found");
  ------------------
  |  Branch (3790:7): [True: 0, False: 228k]
  ------------------
 3791|   228k|  return arg;
 3792|   228k|}
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler9on_arg_idEv:
 4236|   228k|    FMT_CONSTEXPR auto on_arg_id() -> int {
 4237|   228k|      return parse_context.next_arg_id();
 4238|   228k|    }
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handler15on_format_specsEiPKcSF_:
 4257|   228k|        -> const Char* {
 4258|   228k|      auto arg = get_arg(context, id);
 4259|       |      // Not using a visitor for custom types gives better codegen.
 4260|   228k|      if (arg.format_custom(begin, parse_context, context))
  ------------------
  |  Branch (4260:11): [True: 0, False: 228k]
  ------------------
 4261|      0|        return parse_context.begin();
 4262|   228k|      auto specs = detail::dynamic_format_specs<Char>();
 4263|   228k|      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
 4264|   228k|      detail::handle_dynamic_spec<detail::width_checker>(
 4265|   228k|          specs.width, specs.width_ref, context);
 4266|   228k|      detail::handle_dynamic_spec<detail::precision_checker>(
 4267|   228k|          specs.precision, specs.precision_ref, context);
 4268|   228k|      if (begin == end || *begin != '}')
  ------------------
  |  Branch (4268:11): [True: 0, False: 228k]
  |  Branch (4268:27): [True: 0, False: 228k]
  ------------------
 4269|      0|        report_error("missing '}' in format string");
 4270|   228k|      context.advance_to(arg.visit(
 4271|   228k|          arg_formatter<Char>{context.out(), specs, context.locale()}));
 4272|   228k|      return begin;
 4273|   228k|    }
_ZN3fmt3v106detail19handle_dynamic_specINS1_13width_checkerENS0_7contextEEEvRiNS1_7arg_refINT0_9char_typeEEERS7_:
 3797|   228k|                                       Context& ctx) {
 3798|   228k|  switch (ref.kind) {
  ------------------
  |  Branch (3798:11): [True: 0, False: 228k]
  ------------------
 3799|   228k|  case arg_id_kind::none:
  ------------------
  |  Branch (3799:3): [True: 228k, False: 0]
  ------------------
 3800|   228k|    break;
 3801|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (3801:3): [True: 0, False: 228k]
  ------------------
 3802|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index));
 3803|      0|    break;
 3804|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (3804:3): [True: 0, False: 228k]
  ------------------
 3805|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name));
 3806|      0|    break;
 3807|   228k|  }
 3808|   228k|}
_ZN3fmt3v106detail19handle_dynamic_specINS1_17precision_checkerENS0_7contextEEEvRiNS1_7arg_refINT0_9char_typeEEERS7_:
 3797|   228k|                                       Context& ctx) {
 3798|   228k|  switch (ref.kind) {
  ------------------
  |  Branch (3798:11): [True: 0, False: 228k]
  ------------------
 3799|   228k|  case arg_id_kind::none:
  ------------------
  |  Branch (3799:3): [True: 228k, False: 0]
  ------------------
 3800|   228k|    break;
 3801|      0|  case arg_id_kind::index:
  ------------------
  |  Branch (3801:3): [True: 0, False: 228k]
  ------------------
 3802|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index));
 3803|      0|    break;
 3804|      0|  case arg_id_kind::name:
  ------------------
  |  Branch (3804:3): [True: 0, False: 228k]
  ------------------
 3805|      0|    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name));
 3806|      0|    break;
 3807|   228k|  }
 3808|   228k|}
_ZN3fmt3v106detail13arg_formatterIcEclIjEENS0_14basic_appenderIcEET_:
 3742|    378|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3743|    378|    return detail::write<Char>(out, value, specs, locale);
 3744|    378|  }
_ZN3fmt3v106detail5writeIcjLi0EEENS0_14basic_appenderIT_EES5_T0_RKNS0_12format_specsENS1_10locale_refE:
 2211|    378|    -> basic_appender<Char> {
 2212|    378|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2212:7): [True: 0, False: 378]
  |  Branch (2212:26): [True: 0, False: 0]
  ------------------
 2213|    378|  return write_int_noinline<Char>(out, make_write_int_arg(value, specs.sign),
 2214|    378|                                  specs, loc);
 2215|    378|}
_ZN3fmt3v106detail18make_write_int_argIjEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2111|    378|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2112|    378|  auto prefix = 0u;
 2113|    378|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2114|    378|  if (is_negative(value)) {
  ------------------
  |  Branch (2114:7): [True: 0, False: 378]
  ------------------
 2115|      0|    prefix = 0x01000000 | '-';
 2116|      0|    abs_value = 0 - abs_value;
 2117|    378|  } else {
 2118|    378|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2119|    378|                                            0x1000000u | ' '};
 2120|    378|    prefix = prefixes[sign];
 2121|    378|  }
 2122|    378|  return {abs_value, prefix};
 2123|    378|}
_ZN3fmt3v106detail18write_int_noinlineIcNS0_14basic_appenderIcEEmEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refE:
 2202|  16.2k|                                                   locale_ref loc) -> OutputIt {
 2203|  16.2k|  return write_int<Char>(out, arg, specs, loc);
 2204|  16.2k|}
_ZN3fmt3v106detail9write_intIcNS0_14basic_appenderIcEEmEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refE:
 2149|  16.2k|    -> OutputIt {
 2150|  16.2k|  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
 2151|  16.2k|  auto abs_value = arg.abs_value;
 2152|  16.2k|  auto prefix = arg.prefix;
 2153|  16.2k|  switch (specs.type) {
 2154|      0|  default:
  ------------------
  |  Branch (2154:3): [True: 0, False: 16.2k]
  ------------------
 2155|      0|    FMT_ASSERT(false, "");
  ------------------
  |  |  402|      0|    fmt::detail::ignore_unused((condition), (message))
  ------------------
 2156|      0|    FMT_FALLTHROUGH;
  ------------------
  |  |  183|      0|#  define FMT_FALLTHROUGH [[fallthrough]]
  ------------------
 2157|      0|  case presentation_type::none:
  ------------------
  |  Branch (2157:3): [True: 0, False: 16.2k]
  ------------------
 2158|  16.2k|  case presentation_type::dec: {
  ------------------
  |  Branch (2158:3): [True: 16.2k, False: 0]
  ------------------
 2159|  16.2k|    int num_digits = count_digits(abs_value);
 2160|  16.2k|    return write_int<Char>(
 2161|  16.2k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2162|  16.2k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2163|  16.2k|        });
 2164|      0|  }
 2165|      0|  case presentation_type::hex: {
  ------------------
  |  Branch (2165:3): [True: 0, False: 16.2k]
  ------------------
 2166|      0|    if (specs.alt)
  ------------------
  |  Branch (2166:9): [True: 0, False: 0]
  ------------------
 2167|      0|      prefix_append(prefix, unsigned(specs.upper ? 'X' : 'x') << 8 | '0');
  ------------------
  |  Branch (2167:38): [True: 0, False: 0]
  ------------------
 2168|      0|    int num_digits = count_digits<4>(abs_value);
 2169|      0|    return write_int<Char>(
 2170|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2171|      0|          return format_uint<4, Char>(it, abs_value, num_digits, specs.upper);
 2172|      0|        });
 2173|      0|  }
 2174|      0|  case presentation_type::oct: {
  ------------------
  |  Branch (2174:3): [True: 0, False: 16.2k]
  ------------------
 2175|      0|    int num_digits = count_digits<3>(abs_value);
 2176|       |    // Octal prefix '0' is counted as a digit, so only add it if precision
 2177|       |    // is not greater than the number of digits.
 2178|      0|    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
  ------------------
  |  Branch (2178:9): [True: 0, False: 0]
  |  Branch (2178:22): [True: 0, False: 0]
  |  Branch (2178:55): [True: 0, False: 0]
  ------------------
 2179|      0|      prefix_append(prefix, '0');
 2180|      0|    return write_int<Char>(
 2181|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2182|      0|          return format_uint<3, Char>(it, abs_value, num_digits);
 2183|      0|        });
 2184|      0|  }
 2185|      0|  case presentation_type::bin: {
  ------------------
  |  Branch (2185:3): [True: 0, False: 16.2k]
  ------------------
 2186|      0|    if (specs.alt)
  ------------------
  |  Branch (2186:9): [True: 0, False: 0]
  ------------------
 2187|      0|      prefix_append(prefix, unsigned(specs.upper ? 'B' : 'b') << 8 | '0');
  ------------------
  |  Branch (2187:38): [True: 0, False: 0]
  ------------------
 2188|      0|    int num_digits = count_digits<1>(abs_value);
 2189|      0|    return write_int<Char>(
 2190|      0|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2191|      0|          return format_uint<1, Char>(it, abs_value, num_digits);
 2192|      0|        });
 2193|      0|  }
 2194|      0|  case presentation_type::chr:
  ------------------
  |  Branch (2194:3): [True: 0, False: 16.2k]
  ------------------
 2195|      0|    return write_char<Char>(out, static_cast<Char>(abs_value), specs);
 2196|  16.2k|  }
 2197|  16.2k|}
_ZN3fmt3v106detail9write_intIcNS0_14basic_appenderIcEEZNS1_9write_intIcS4_mEET0_S6_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refEEUlS4_E_EES6_S6_ijSC_S8_:
 1955|  16.2k|                                        W write_digits) -> OutputIt {
 1956|       |  // Slightly faster check for specs.width == 0 && specs.precision == -1.
 1957|  16.2k|  if ((specs.width | (specs.precision + 1)) == 0) {
  ------------------
  |  Branch (1957:7): [True: 16.2k, False: 0]
  ------------------
 1958|  16.2k|    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
 1959|  16.2k|    if (prefix != 0) {
  ------------------
  |  Branch (1959:9): [True: 0, False: 16.2k]
  ------------------
 1960|      0|      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
  ------------------
  |  Branch (1960:44): [True: 0, False: 0]
  ------------------
 1961|      0|        *it++ = static_cast<Char>(p & 0xff);
 1962|      0|    }
 1963|  16.2k|    return base_iterator(out, write_digits(it));
 1964|  16.2k|  }
 1965|      0|  auto data = write_int_data<Char>(num_digits, prefix, specs);
 1966|      0|  return write_padded<Char, align::right>(
 1967|      0|      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
 1968|      0|        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
 1969|      0|          *it++ = static_cast<Char>(p & 0xff);
 1970|      0|        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
 1971|      0|        return write_digits(it);
 1972|      0|      });
 1973|  16.2k|}
_ZZN3fmt3v106detail9write_intIcNS0_14basic_appenderIcEEmEET0_S5_NS1_13write_int_argIT1_EERKNS0_12format_specsENS1_10locale_refEENKUlS4_E_clES4_:
 2161|  16.2k|        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
 2162|  16.2k|          return format_decimal<Char>(it, abs_value, num_digits).end;
 2163|  16.2k|        });
_ZN3fmt3v106detail13arg_formatterIcEclIyEENS0_14basic_appenderIcEET_:
 3742|  16.2k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3743|  16.2k|    return detail::write<Char>(out, value, specs, locale);
 3744|  16.2k|  }
_ZN3fmt3v106detail5writeIcyLi0EEENS0_14basic_appenderIT_EES5_T0_RKNS0_12format_specsENS1_10locale_refE:
 2211|  16.2k|    -> basic_appender<Char> {
 2212|  16.2k|  if (specs.localized && write_loc(out, value, specs, loc)) return out;
  ------------------
  |  Branch (2212:7): [True: 0, False: 16.2k]
  |  Branch (2212:26): [True: 0, False: 0]
  ------------------
 2213|  16.2k|  return write_int_noinline<Char>(out, make_write_int_arg(value, specs.sign),
 2214|  16.2k|                                  specs, loc);
 2215|  16.2k|}
_ZN3fmt3v106detail18make_write_int_argIyEENS1_13write_int_argINSt3__111conditionalIXaalecl8num_bitsIT_EELi32EntLi0EEjNS5_IXlecl8num_bitsIS6_EELi64EEmoE4typeEE4typeEEES6_NS0_4sign4typeE:
 2111|  16.2k|    -> write_int_arg<uint32_or_64_or_128_t<T>> {
 2112|  16.2k|  auto prefix = 0u;
 2113|  16.2k|  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
 2114|  16.2k|  if (is_negative(value)) {
  ------------------
  |  Branch (2114:7): [True: 0, False: 16.2k]
  ------------------
 2115|      0|    prefix = 0x01000000 | '-';
 2116|      0|    abs_value = 0 - abs_value;
 2117|  16.2k|  } else {
 2118|  16.2k|    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
 2119|  16.2k|                                            0x1000000u | ' '};
 2120|  16.2k|    prefix = prefixes[sign];
 2121|  16.2k|  }
 2122|  16.2k|  return {abs_value, prefix};
 2123|  16.2k|}
_ZN3fmt3v106detail13arg_formatterIcEclIPKcEENS0_14basic_appenderIcEET_:
 3742|   212k|  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
 3743|   212k|    return detail::write<Char>(out, value, specs, locale);
 3744|   212k|  }
_ZN3fmt3v106detail5writeIcNS0_14basic_appenderIcEEEET0_S5_PKT_RKNS0_12format_specsENS1_10locale_refE:
 2302|   212k|                         locale_ref) -> OutputIt {
 2303|   212k|  if (specs.type == presentation_type::pointer)
  ------------------
  |  Branch (2303:7): [True: 0, False: 212k]
  ------------------
 2304|      0|    return write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
 2305|   212k|  if (!s) report_error("string pointer is null");
  ------------------
  |  Branch (2305:7): [True: 0, False: 212k]
  ------------------
 2306|   212k|  return write<Char>(out, basic_string_view<Char>(s), specs, {});
 2307|   212k|}
_ZN3fmt3v106detail5writeIcNS0_14basic_appenderIcEEEET0_S5_NS0_17basic_string_viewINS0_13type_identityIT_E4typeEEERKNS0_12format_specsENS1_10locale_refE:
 2297|   212k|                         const format_specs& specs, locale_ref) -> OutputIt {
 2298|   212k|  return write<Char>(out, s, specs);
 2299|   212k|}
_ZN3fmt3v106detail5writeIcNS0_14basic_appenderIcEEEET0_S5_NS0_17basic_string_viewIT_EERKNS0_12format_specsE:
 2272|   212k|                         const format_specs& specs) -> OutputIt {
 2273|   212k|  auto data = s.data();
 2274|   212k|  auto size = s.size();
 2275|   212k|  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
  ------------------
  |  Branch (2275:7): [True: 0, False: 212k]
  |  Branch (2275:31): [True: 0, False: 0]
  ------------------
 2276|      0|    size = code_point_index(s, to_unsigned(specs.precision));
 2277|   212k|  bool is_debug = specs.type == presentation_type::debug;
 2278|   212k|  size_t width = 0;
 2279|       |
 2280|   212k|  if (is_debug) size = write_escaped_string(counting_iterator{}, s).count();
  ------------------
  |  Branch (2280:7): [True: 0, False: 212k]
  ------------------
 2281|       |
 2282|   212k|  if (specs.width != 0) {
  ------------------
  |  Branch (2282:7): [True: 0, False: 212k]
  ------------------
 2283|      0|    if (is_debug)
  ------------------
  |  Branch (2283:9): [True: 0, False: 0]
  ------------------
 2284|      0|      width = size;
 2285|      0|    else
 2286|      0|      width = compute_width(basic_string_view<Char>(data, size));
 2287|      0|  }
 2288|   212k|  return write_padded<Char>(out, specs, size, width,
 2289|   212k|                            [=](reserve_iterator<OutputIt> it) {
 2290|   212k|                              if (is_debug) return write_escaped_string(it, s);
 2291|   212k|                              return copy<Char>(data, data + size, it);
 2292|   212k|                            });
 2293|   212k|}
_ZN3fmt3v106detail12write_paddedIcLNS0_5align4typeE1ENS0_14basic_appenderIcEEZNS1_5writeIcS6_EET0_S8_NS0_17basic_string_viewIT_EERKNS0_12format_specsEEUlS6_E_EET1_SG_SE_mmOT2_:
 1710|   212k|                                size_t size, size_t width, F&& f) -> OutputIt {
 1711|   212k|  static_assert(align == align::left || align == align::right, "");
 1712|   212k|  unsigned spec_width = to_unsigned(specs.width);
 1713|   212k|  size_t padding = spec_width > width ? spec_width - width : 0;
  ------------------
  |  Branch (1713:20): [True: 0, False: 212k]
  ------------------
 1714|       |  // Shifts are encoded as string literals because static constexpr is not
 1715|       |  // supported in constexpr functions.
 1716|   212k|  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
  ------------------
  |  Branch (1716:18): [Folded - Ignored]
  ------------------
 1717|   212k|  size_t left_padding = padding >> shifts[specs.align];
 1718|   212k|  size_t right_padding = padding - left_padding;
 1719|   212k|  auto it = reserve(out, size + padding * specs.fill.size());
 1720|   212k|  if (left_padding != 0) it = fill<Char>(it, left_padding, specs.fill);
  ------------------
  |  Branch (1720:7): [True: 0, False: 212k]
  ------------------
 1721|   212k|  it = f(it);
 1722|   212k|  if (right_padding != 0) it = fill<Char>(it, right_padding, specs.fill);
  ------------------
  |  Branch (1722:7): [True: 0, False: 212k]
  ------------------
 1723|   212k|  return base_iterator(out, it);
 1724|   212k|}
_ZZN3fmt3v106detail5writeIcNS0_14basic_appenderIcEEEET0_S5_NS0_17basic_string_viewIT_EERKNS0_12format_specsEENKUlS4_E_clES4_:
 2289|   212k|                            [=](reserve_iterator<OutputIt> it) {
 2290|   212k|                              if (is_debug) return write_escaped_string(it, s);
  ------------------
  |  Branch (2290:35): [True: 0, False: 212k]
  ------------------
 2291|   212k|                              return copy<Char>(data, data + size, it);
 2292|   212k|                            });
_ZZN3fmt3v106detail10vformat_toIcEEvRNS1_6bufferIT_EENS0_17basic_string_viewIS4_EENS1_12vformat_argsIS4_E4typeENS1_10locale_refEEN14format_handlerC2ENS0_14basic_appenderIcEENS7_IcEENS0_17basic_format_argsINS0_7contextEEESC_:
 4229|   134k|        : parse_context(str), context(p_out, p_args, p_loc) {}
_ZN3fmt3v109to_stringIcLm500EEENSt3__112basic_stringIT_NS2_11char_traitsIS4_EENS2_9allocatorIS4_EEEERKNS0_19basic_memory_bufferIS4_XT0_ES8_EE:
 4195|   134k|    -> std::basic_string<Char> {
 4196|   134k|  auto size = buf.size();
 4197|   134k|  detail::assume(size < std::basic_string<Char>().max_size());
 4198|   134k|  return std::basic_string<Char>(buf.data(), size);
 4199|   134k|}

_ZN10ImGuiStyleC2Ev:
 1255|      1|{
 1256|      1|    Alpha                       = 1.0f;             // Global alpha applies to everything in Dear ImGui.
 1257|      1|    DisabledAlpha               = 0.60f;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
 1258|      1|    WindowPadding               = ImVec2(8,8);      // Padding within a window
 1259|      1|    WindowRounding              = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
 1260|      1|    WindowBorderSize            = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1261|      1|    WindowMinSize               = ImVec2(32,32);    // Minimum window size
 1262|      1|    WindowTitleAlign            = ImVec2(0.0f,0.5f);// Alignment for title bar text
 1263|      1|    WindowMenuButtonPosition    = ImGuiDir_Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
 1264|      1|    ChildRounding               = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
 1265|      1|    ChildBorderSize             = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1266|      1|    PopupRounding               = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
 1267|      1|    PopupBorderSize             = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
 1268|      1|    FramePadding                = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
 1269|      1|    FrameRounding               = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
 1270|      1|    FrameBorderSize             = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
 1271|      1|    ItemSpacing                 = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
 1272|      1|    ItemInnerSpacing            = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
 1273|      1|    CellPadding                 = ImVec2(4,2);      // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
 1274|      1|    TouchExtraPadding           = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
 1275|      1|    IndentSpacing               = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
 1276|      1|    ColumnsMinSpacing           = 6.0f;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
 1277|      1|    ScrollbarSize               = 14.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
 1278|      1|    ScrollbarRounding           = 9.0f;             // Radius of grab corners rounding for scrollbar
 1279|      1|    GrabMinSize                 = 12.0f;            // Minimum width/height of a grab box for slider/scrollbar
 1280|      1|    GrabRounding                = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
 1281|      1|    LogSliderDeadzone           = 4.0f;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
 1282|      1|    TabRounding                 = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
 1283|      1|    TabBorderSize               = 0.0f;             // Thickness of border around tabs.
 1284|      1|    TabMinWidthForCloseButton   = 0.0f;             // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
 1285|      1|    TabBarBorderSize            = 1.0f;             // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
 1286|      1|    TableAngledHeadersAngle     = 35.0f * (IM_PI / 180.0f); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
  ------------------
  |  |  275|      1|#define IM_PI                           3.14159265358979323846f
  ------------------
 1287|      1|    TableAngledHeadersTextAlign = ImVec2(0.5f,0.0f);// Alignment of angled headers within the cell
 1288|      1|    ColorButtonPosition         = ImGuiDir_Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
 1289|      1|    ButtonTextAlign             = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
 1290|      1|    SelectableTextAlign         = ImVec2(0.0f,0.0f);// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
 1291|      1|    SeparatorTextBorderSize     = 3.0f;             // Thickkness of border in SeparatorText()
 1292|      1|    SeparatorTextAlign          = ImVec2(0.0f,0.5f);// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
 1293|      1|    SeparatorTextPadding        = ImVec2(20.0f,3.f);// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
 1294|      1|    DisplayWindowPadding        = ImVec2(19,19);    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
 1295|      1|    DisplaySafeAreaPadding      = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
 1296|      1|    DockingSeparatorSize        = 2.0f;             // Thickness of resizing border between docked windows
 1297|      1|    MouseCursorScale            = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
 1298|      1|    AntiAliasedLines            = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
 1299|      1|    AntiAliasedLinesUseTex      = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
 1300|      1|    AntiAliasedFill             = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
 1301|      1|    CurveTessellationTol        = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
 1302|      1|    CircleTessellationMaxError  = 0.30f;            // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
 1303|       |
 1304|       |    // Behaviors
 1305|      1|    HoverStationaryDelay        = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
 1306|      1|    HoverDelayShort             = 0.15f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
 1307|      1|    HoverDelayNormal            = 0.40f;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
 1308|      1|    HoverFlagsForTooltipMouse   = ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_AllowWhenDisabled;    // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
 1309|      1|    HoverFlagsForTooltipNav     = ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_AllowWhenDisabled;  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
 1310|       |
 1311|       |    // Default theme
 1312|      1|    ImGui::StyleColorsDark(this);
 1313|      1|}
_ZN7ImGuiIOC2Ev:
 1347|      1|{
 1348|       |    // Most fields are initialized with zero
 1349|      1|    memset(this, 0, sizeof(*this));
 1350|      1|    IM_STATIC_ASSERT(IM_ARRAYSIZE(ImGuiIO::MouseDown) == ImGuiMouseButton_COUNT && IM_ARRAYSIZE(ImGuiIO::MouseClicked) == ImGuiMouseButton_COUNT);
  ------------------
  |  |  257|      1|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
 1351|       |
 1352|       |    // Settings
 1353|      1|    ConfigFlags = ImGuiConfigFlags_None;
 1354|      1|    BackendFlags = ImGuiBackendFlags_None;
 1355|      1|    DisplaySize = ImVec2(-1.0f, -1.0f);
 1356|      1|    DeltaTime = 1.0f / 60.0f;
 1357|      1|    IniSavingRate = 5.0f;
 1358|      1|    IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
 1359|      1|    LogFilename = "imgui_log.txt";
 1360|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1361|       |    for (int i = 0; i < ImGuiKey_COUNT; i++)
 1362|       |        KeyMap[i] = -1;
 1363|       |#endif
 1364|      1|    UserData = NULL;
 1365|       |
 1366|      1|    Fonts = NULL;
 1367|      1|    FontGlobalScale = 1.0f;
 1368|      1|    FontDefault = NULL;
 1369|      1|    FontAllowUserScaling = false;
 1370|      1|    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
 1371|       |
 1372|       |    // Docking options (when ImGuiConfigFlags_DockingEnable is set)
 1373|      1|    ConfigDockingNoSplit = false;
 1374|      1|    ConfigDockingWithShift = false;
 1375|      1|    ConfigDockingAlwaysTabBar = false;
 1376|      1|    ConfigDockingTransparentPayload = false;
 1377|       |
 1378|       |    // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
 1379|      1|    ConfigViewportsNoAutoMerge = false;
 1380|      1|    ConfigViewportsNoTaskBarIcon = false;
 1381|      1|    ConfigViewportsNoDecoration = true;
 1382|      1|    ConfigViewportsNoDefaultParent = false;
 1383|       |
 1384|       |    // Miscellaneous options
 1385|      1|    MouseDrawCursor = false;
 1386|       |#ifdef __APPLE__
 1387|       |    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
 1388|       |#else
 1389|      1|    ConfigMacOSXBehaviors = false;
 1390|      1|#endif
 1391|      1|    ConfigInputTrickleEventQueue = true;
 1392|      1|    ConfigInputTextCursorBlink = true;
 1393|      1|    ConfigInputTextEnterKeepActive = false;
 1394|      1|    ConfigDragClickToInputText = false;
 1395|      1|    ConfigWindowsResizeFromEdges = true;
 1396|      1|    ConfigWindowsMoveFromTitleBarOnly = false;
 1397|      1|    ConfigMemoryCompactTimer = 60.0f;
 1398|      1|    ConfigDebugBeginReturnValueOnce = false;
 1399|      1|    ConfigDebugBeginReturnValueLoop = false;
 1400|       |
 1401|       |    // Inputs Behaviors
 1402|      1|    MouseDoubleClickTime = 0.30f;
 1403|      1|    MouseDoubleClickMaxDist = 6.0f;
 1404|      1|    MouseDragThreshold = 6.0f;
 1405|      1|    KeyRepeatDelay = 0.275f;
 1406|      1|    KeyRepeatRate = 0.050f;
 1407|       |
 1408|       |    // Platform Functions
 1409|       |    // Note: Initialize() will setup default clipboard/ime handlers.
 1410|      1|    BackendPlatformName = BackendRendererName = NULL;
 1411|      1|    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
 1412|      1|    PlatformLocaleDecimalPoint = '.';
 1413|       |
 1414|       |    // Input (NB: we already have memset zero the entire structure!)
 1415|      1|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1416|      1|    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
 1417|      1|    MouseSource = ImGuiMouseSource_Mouse;
 1418|      6|    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
  ------------------
  |  |   93|      6|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1418:21): [True: 5, False: 1]
  ------------------
 1419|    155|    for (int i = 0; i < IM_ARRAYSIZE(KeysData); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
  ------------------
  |  |   93|    155|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1419:21): [True: 154, False: 1]
  ------------------
 1420|      1|    AppAcceptingEvents = true;
 1421|      1|    BackendUsingLegacyKeyArrays = (ImS8)-1;
 1422|      1|    BackendUsingLegacyNavInputArray = true; // assume using legacy array until proven wrong
 1423|      1|}
_ZN7ImGuiIO17AddInputCharacterEj:
 1430|  6.49k|{
 1431|  6.49k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  6.49k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1432|  6.49k|    ImGuiContext& g = *Ctx;
 1433|  6.49k|    if (c == 0 || !AppAcceptingEvents)
  ------------------
  |  Branch (1433:9): [True: 1.61k, False: 4.88k]
  |  Branch (1433:19): [True: 0, False: 4.88k]
  ------------------
 1434|  1.61k|        return;
 1435|       |
 1436|  4.88k|    ImGuiInputEvent e;
 1437|  4.88k|    e.Type = ImGuiInputEventType_Text;
 1438|  4.88k|    e.Source = ImGuiInputSource_Keyboard;
 1439|  4.88k|    e.EventId = g.InputEventsNextEventId++;
 1440|  4.88k|    e.Text.Char = c;
 1441|  4.88k|    g.InputEventsQueue.push_back(e);
 1442|  4.88k|}
_ZN7ImGuiIO22AddInputCharacterUTF16Et:
 1447|  1.80k|{
 1448|  1.80k|    if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
  ------------------
  |  Branch (1448:10): [True: 253, False: 1.55k]
  |  Branch (1448:20): [True: 162, False: 91]
  |  Branch (1448:49): [True: 0, False: 1.64k]
  ------------------
 1449|    162|        return;
 1450|       |
 1451|  1.64k|    if ((c & 0xFC00) == 0xD800) // High surrogate, must save
  ------------------
  |  Branch (1451:9): [True: 647, False: 1.00k]
  ------------------
 1452|    647|    {
 1453|    647|        if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1453:13): [True: 199, False: 448]
  ------------------
 1454|    199|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2538|    199|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1455|    647|        InputQueueSurrogate = c;
 1456|    647|        return;
 1457|    647|    }
 1458|       |
 1459|  1.00k|    ImWchar cp = c;
 1460|  1.00k|    if (InputQueueSurrogate != 0)
  ------------------
  |  Branch (1460:9): [True: 430, False: 570]
  ------------------
 1461|    430|    {
 1462|    430|        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
  ------------------
  |  Branch (1462:13): [True: 378, False: 52]
  ------------------
 1463|    378|        {
 1464|    378|            AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2538|    378|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1465|    378|        }
 1466|     52|        else
 1467|     52|        {
 1468|     52|#if IM_UNICODE_CODEPOINT_MAX == 0xFFFF
 1469|     52|            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
  ------------------
  |  | 2538|     52|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 1470|       |#else
 1471|       |            cp = (ImWchar)(((InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
 1472|       |#endif
 1473|     52|        }
 1474|       |
 1475|    430|        InputQueueSurrogate = 0;
 1476|    430|    }
 1477|  1.00k|    AddInputCharacter((unsigned)cp);
 1478|  1.00k|}
_ZN7ImGuiIO22AddInputCharactersUTF8EPKc:
 1481|     65|{
 1482|     65|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1482:9): [True: 0, False: 65]
  ------------------
 1483|      0|        return;
 1484|     65|    while (*utf8_chars != 0)
  ------------------
  |  Branch (1484:12): [True: 0, False: 65]
  ------------------
 1485|      0|    {
 1486|      0|        unsigned int c = 0;
 1487|      0|        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
 1488|      0|        AddInputCharacter(c);
 1489|      0|    }
 1490|     65|}
_ZN7ImGuiIO14ClearInputKeysEv:
 1502|  12.4k|{
 1503|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1504|       |    memset(KeysDown, 0, sizeof(KeysDown));
 1505|       |#endif
 1506|  1.93M|    for (int n = 0; n < IM_ARRAYSIZE(KeysData); n++)
  ------------------
  |  |   93|  1.93M|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1506:21): [True: 1.92M, False: 12.4k]
  ------------------
 1507|  1.92M|    {
 1508|  1.92M|        if (ImGui::IsMouseKey((ImGuiKey)(n + ImGuiKey_KeysData_OFFSET)))
  ------------------
  |  Branch (1508:13): [True: 87.4k, False: 1.83M]
  ------------------
 1509|  87.4k|            continue;
 1510|  1.83M|        KeysData[n].Down             = false;
 1511|  1.83M|        KeysData[n].DownDuration     = -1.0f;
 1512|  1.83M|        KeysData[n].DownDurationPrev = -1.0f;
 1513|  1.83M|    }
 1514|  12.4k|    KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
 1515|  12.4k|    KeyMods = ImGuiMod_None;
 1516|  12.4k|    InputQueueCharacters.resize(0); // Behavior of old ClearInputCharacters().
 1517|  12.4k|}
_ZN7ImGuiIO15ClearInputMouseEv:
 1520|  2.61k|{
 1521|  20.8k|    for (ImGuiKey key = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  | 1365|  2.61k|#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)
  ------------------
                  for (ImGuiKey key = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  | 1366|  20.8k|#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)
  ------------------
  |  Branch (1521:47): [True: 18.2k, False: 2.61k]
  ------------------
 1522|  18.2k|    {
 1523|  18.2k|        ImGuiKeyData* key_data = &KeysData[key - ImGuiKey_KeysData_OFFSET];
 1524|  18.2k|        key_data->Down = false;
 1525|  18.2k|        key_data->DownDuration = -1.0f;
 1526|  18.2k|        key_data->DownDurationPrev = -1.0f;
 1527|  18.2k|    }
 1528|  2.61k|    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
 1529|  15.6k|    for (int n = 0; n < IM_ARRAYSIZE(MouseDown); n++)
  ------------------
  |  |   93|  15.6k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1529:21): [True: 13.0k, False: 2.61k]
  ------------------
 1530|  13.0k|    {
 1531|  13.0k|        MouseDown[n] = false;
 1532|  13.0k|        MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
 1533|  13.0k|    }
 1534|  2.61k|    MouseWheel = MouseWheelH = 0.0f;
 1535|  2.61k|}
_ZN7ImGuiIO17AddKeyAnalogEventE8ImGuiKeybf:
 1570|  8.82k|{
 1571|       |    //if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
 1572|  8.82k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  8.82k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1573|  8.82k|    if (key == ImGuiKey_None || !AppAcceptingEvents)
  ------------------
  |  Branch (1573:9): [True: 0, False: 8.82k]
  |  Branch (1573:33): [True: 0, False: 8.82k]
  ------------------
 1574|      0|        return;
 1575|  8.82k|    ImGuiContext& g = *Ctx;
 1576|  8.82k|    IM_ASSERT(ImGui::IsNamedKeyOrMod(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
  ------------------
  |  |   23|  8.82k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1577|  8.82k|    IM_ASSERT(ImGui::IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.
  ------------------
  |  |   23|  8.82k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1578|       |
 1579|       |    // MacOS: swap Cmd(Super) and Ctrl
 1580|  8.82k|    if (g.IO.ConfigMacOSXBehaviors)
  ------------------
  |  Branch (1580:9): [True: 0, False: 8.82k]
  ------------------
 1581|      0|    {
 1582|      0|        if (key == ImGuiMod_Super)          { key = ImGuiMod_Ctrl; }
  ------------------
  |  Branch (1582:13): [True: 0, False: 0]
  ------------------
 1583|      0|        else if (key == ImGuiMod_Ctrl)      { key = ImGuiMod_Super; }
  ------------------
  |  Branch (1583:18): [True: 0, False: 0]
  ------------------
 1584|      0|        else if (key == ImGuiKey_LeftSuper) { key = ImGuiKey_LeftCtrl; }
  ------------------
  |  Branch (1584:18): [True: 0, False: 0]
  ------------------
 1585|      0|        else if (key == ImGuiKey_RightSuper){ key = ImGuiKey_RightCtrl; }
  ------------------
  |  Branch (1585:18): [True: 0, False: 0]
  ------------------
 1586|      0|        else if (key == ImGuiKey_LeftCtrl)  { key = ImGuiKey_LeftSuper; }
  ------------------
  |  Branch (1586:18): [True: 0, False: 0]
  ------------------
 1587|      0|        else if (key == ImGuiKey_RightCtrl) { key = ImGuiKey_RightSuper; }
  ------------------
  |  Branch (1587:18): [True: 0, False: 0]
  ------------------
 1588|      0|    }
 1589|       |
 1590|       |    // Verify that backend isn't mixing up using new io.AddKeyEvent() api and old io.KeysDown[] + io.KeyMap[] data.
 1591|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 1592|       |    IM_ASSERT((BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1593|       |    if (BackendUsingLegacyKeyArrays == -1)
 1594|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 1595|       |            IM_ASSERT(KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 1596|       |    BackendUsingLegacyKeyArrays = 0;
 1597|       |#endif
 1598|  8.82k|    if (ImGui::IsGamepadKey(key))
  ------------------
  |  Branch (1598:9): [True: 119, False: 8.70k]
  ------------------
 1599|    119|        BackendUsingLegacyNavInputArray = false;
 1600|       |
 1601|       |    // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
 1602|  8.82k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)key);
 1603|  8.82k|    const ImGuiKeyData* key_data = ImGui::GetKeyData(&g, key);
 1604|  8.82k|    const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
  ------------------
  |  Branch (1604:34): [True: 2.03k, False: 6.78k]
  ------------------
 1605|  8.82k|    const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
  ------------------
  |  Branch (1605:37): [True: 2.03k, False: 6.78k]
  ------------------
 1606|  8.82k|    if (latest_key_down == down && latest_key_analog == analog_value)
  ------------------
  |  Branch (1606:9): [True: 2.21k, False: 6.61k]
  |  Branch (1606:36): [True: 1.23k, False: 978]
  ------------------
 1607|  1.23k|        return;
 1608|       |
 1609|       |    // Add event
 1610|  7.59k|    ImGuiInputEvent e;
 1611|  7.59k|    e.Type = ImGuiInputEventType_Key;
 1612|  7.59k|    e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
  ------------------
  |  Branch (1612:16): [True: 119, False: 7.47k]
  ------------------
 1613|  7.59k|    e.EventId = g.InputEventsNextEventId++;
 1614|  7.59k|    e.Key.Key = key;
 1615|  7.59k|    e.Key.Down = down;
 1616|  7.59k|    e.Key.AnalogValue = analog_value;
 1617|  7.59k|    g.InputEventsQueue.push_back(e);
 1618|  7.59k|}
_ZN7ImGuiIO11AddKeyEventE8ImGuiKeyb:
 1621|  1.13k|{
 1622|  1.13k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1622:9): [True: 0, False: 1.13k]
  ------------------
 1623|      0|        return;
 1624|  1.13k|    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
  ------------------
  |  Branch (1624:34): [True: 588, False: 544]
  ------------------
 1625|  1.13k|}
_ZN7ImGuiIO16AddMousePosEventEff:
 1660|  5.16k|{
 1661|  5.16k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  5.16k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1662|  5.16k|    ImGuiContext& g = *Ctx;
 1663|  5.16k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1663:9): [True: 0, False: 5.16k]
  ------------------
 1664|      0|        return;
 1665|       |
 1666|       |    // Apply same flooring as UpdateMouseInputs()
 1667|  5.16k|    ImVec2 pos((x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y);
  ------------------
  |  Branch (1667:16): [True: 5.16k, False: 0]
  |  Branch (1667:49): [True: 5.16k, False: 0]
  ------------------
 1668|       |
 1669|       |    // Filter duplicate
 1670|  5.16k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MousePos);
 1671|  5.16k|    const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
  ------------------
  |  Branch (1671:31): [True: 1.78k, False: 3.37k]
  ------------------
 1672|  5.16k|    if (latest_pos.x == pos.x && latest_pos.y == pos.y)
  ------------------
  |  Branch (1672:9): [True: 1.99k, False: 3.16k]
  |  Branch (1672:34): [True: 1.13k, False: 867]
  ------------------
 1673|  1.13k|        return;
 1674|       |
 1675|  4.03k|    ImGuiInputEvent e;
 1676|  4.03k|    e.Type = ImGuiInputEventType_MousePos;
 1677|  4.03k|    e.Source = ImGuiInputSource_Mouse;
 1678|  4.03k|    e.EventId = g.InputEventsNextEventId++;
 1679|  4.03k|    e.MousePos.PosX = pos.x;
 1680|  4.03k|    e.MousePos.PosY = pos.y;
 1681|  4.03k|    e.MousePos.MouseSource = g.InputEventsNextMouseSource;
 1682|  4.03k|    g.InputEventsQueue.push_back(e);
 1683|  4.03k|}
_ZN7ImGuiIO19AddMouseButtonEventEib:
 1686|  12.5k|{
 1687|  12.5k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  12.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1688|  12.5k|    ImGuiContext& g = *Ctx;
 1689|  12.5k|    IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  12.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1690|  12.5k|    if (!AppAcceptingEvents)
  ------------------
  |  Branch (1690:9): [True: 0, False: 12.5k]
  ------------------
 1691|      0|        return;
 1692|       |
 1693|       |    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click: handle held button.
 1694|  12.5k|    if (ConfigMacOSXBehaviors && mouse_button == 0 && MouseCtrlLeftAsRightClick)
  ------------------
  |  Branch (1694:9): [True: 0, False: 12.5k]
  |  Branch (1694:34): [True: 0, False: 0]
  |  Branch (1694:55): [True: 0, False: 0]
  ------------------
 1695|      0|    {
 1696|       |        // Order of both statements matterns: this event will still release mouse button 1
 1697|      0|        mouse_button = 1;
 1698|      0|        if (!down)
  ------------------
  |  Branch (1698:13): [True: 0, False: 0]
  ------------------
 1699|      0|            MouseCtrlLeftAsRightClick = false;
 1700|      0|    }
 1701|       |
 1702|       |    // Filter duplicate
 1703|  12.5k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_MouseButton, (int)mouse_button);
 1704|  12.5k|    const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
  ------------------
  |  Branch (1704:37): [True: 4.71k, False: 7.88k]
  ------------------
 1705|  12.5k|    if (latest_button_down == down)
  ------------------
  |  Branch (1705:9): [True: 4.59k, False: 8.00k]
  ------------------
 1706|  4.59k|        return;
 1707|       |
 1708|       |    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click.
 1709|       |    // - Note that this is actual physical Ctrl which is ImGuiMod_Super for us.
 1710|       |    // - At this point we want from !down to down, so this is handling the initial press.
 1711|  8.00k|    if (ConfigMacOSXBehaviors && mouse_button == 0 && down)
  ------------------
  |  Branch (1711:9): [True: 0, False: 8.00k]
  |  Branch (1711:34): [True: 0, False: 0]
  |  Branch (1711:55): [True: 0, False: 0]
  ------------------
 1712|      0|    {
 1713|      0|        const ImGuiInputEvent* latest_super_event = FindLatestInputEvent(&g, ImGuiInputEventType_Key, (int)ImGuiMod_Super);
 1714|      0|        if (latest_super_event ? latest_super_event->Key.Down : g.IO.KeySuper)
  ------------------
  |  Branch (1714:13): [True: 0, False: 0]
  |  Branch (1714:13): [True: 0, False: 0]
  ------------------
 1715|      0|        {
 1716|      0|            IMGUI_DEBUG_LOG_IO("[io] Super+Left Click aliased into Right Click\n");
  ------------------
  |  |  251|      0|#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)          IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (251:50): [True: 0, False: 0]
  |  |  |  Branch (251:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1717|      0|            MouseCtrlLeftAsRightClick = true;
 1718|      0|            AddMouseButtonEvent(1, true); // This is just quicker to write that passing through, as we need to filter duplicate again.
 1719|      0|            return;
 1720|      0|        }
 1721|      0|    }
 1722|       |
 1723|  8.00k|    ImGuiInputEvent e;
 1724|  8.00k|    e.Type = ImGuiInputEventType_MouseButton;
 1725|  8.00k|    e.Source = ImGuiInputSource_Mouse;
 1726|  8.00k|    e.EventId = g.InputEventsNextEventId++;
 1727|  8.00k|    e.MouseButton.Button = mouse_button;
 1728|  8.00k|    e.MouseButton.Down = down;
 1729|  8.00k|    e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
 1730|  8.00k|    g.InputEventsQueue.push_back(e);
 1731|  8.00k|}
_ZN7ImGuiIO18AddMouseWheelEventEff:
 1735|  3.50k|{
 1736|  3.50k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  3.50k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1737|  3.50k|    ImGuiContext& g = *Ctx;
 1738|       |
 1739|       |    // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
 1740|  3.50k|    if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
  ------------------
  |  Branch (1740:9): [True: 0, False: 3.50k]
  |  Branch (1740:33): [True: 2.13k, False: 1.36k]
  |  Branch (1740:52): [True: 311, False: 1.82k]
  ------------------
 1741|    311|        return;
 1742|       |
 1743|  3.18k|    ImGuiInputEvent e;
 1744|  3.18k|    e.Type = ImGuiInputEventType_MouseWheel;
 1745|  3.18k|    e.Source = ImGuiInputSource_Mouse;
 1746|  3.18k|    e.EventId = g.InputEventsNextEventId++;
 1747|  3.18k|    e.MouseWheel.WheelX = wheel_x;
 1748|  3.18k|    e.MouseWheel.WheelY = wheel_y;
 1749|  3.18k|    e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
 1750|  3.18k|    g.InputEventsQueue.push_back(e);
 1751|  3.18k|}
_ZN7ImGuiIO13AddFocusEventEb:
 1784|  3.51k|{
 1785|  3.51k|    IM_ASSERT(Ctx != NULL);
  ------------------
  |  |   23|  3.51k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1786|  3.51k|    ImGuiContext& g = *Ctx;
 1787|       |
 1788|       |    // Filter duplicate
 1789|  3.51k|    const ImGuiInputEvent* latest_event = FindLatestInputEvent(&g, ImGuiInputEventType_Focus);
 1790|  3.51k|    const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
  ------------------
  |  Branch (1790:33): [True: 449, False: 3.06k]
  ------------------
 1791|  3.51k|    if (latest_focused == focused || (ConfigDebugIgnoreFocusLoss && !focused))
  ------------------
  |  Branch (1791:9): [True: 640, False: 2.87k]
  |  Branch (1791:39): [True: 0, False: 2.87k]
  |  Branch (1791:69): [True: 0, False: 0]
  ------------------
 1792|    640|        return;
 1793|       |
 1794|  2.87k|    ImGuiInputEvent e;
 1795|  2.87k|    e.Type = ImGuiInputEventType_Focus;
 1796|  2.87k|    e.EventId = g.InputEventsNextEventId++;
 1797|  2.87k|    e.AppFocused.Focused = focused;
 1798|  2.87k|    g.InputEventsQueue.push_back(e);
 1799|  2.87k|}
_Z9ImStrncpyPcPKcm:
 1941|    158|{
 1942|    158|    if (count < 1)
  ------------------
  |  Branch (1942:9): [True: 0, False: 158]
  ------------------
 1943|      0|        return;
 1944|    158|    if (count > 1)
  ------------------
  |  Branch (1944:9): [True: 158, False: 0]
  ------------------
 1945|    158|        strncpy(dst, src, count - 1);
 1946|    158|    dst[count - 1] = 0;
 1947|    158|}
_Z8ImStrdupPKc:
 1950|      3|{
 1951|      3|    size_t len = strlen(str);
 1952|      3|    void* buf = IM_ALLOC(len + 1);
  ------------------
  |  | 2051|      3|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 1953|      3|    return (char*)memcpy(buf, (const void*)str, len + 1);
 1954|      3|}
_Z14ImFormatStringPcmPKcz:
 2068|      1|{
 2069|      1|    va_list args;
 2070|      1|    va_start(args, fmt);
 2071|       |#ifdef IMGUI_USE_STB_SPRINTF
 2072|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 2073|       |#else
 2074|      1|    int w = vsnprintf(buf, buf_size, fmt, args);
 2075|      1|#endif
 2076|      1|    va_end(args);
 2077|      1|    if (buf == NULL)
  ------------------
  |  Branch (2077:9): [True: 0, False: 1]
  ------------------
 2078|      0|        return w;
 2079|      1|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (2079:9): [True: 0, False: 1]
  |  Branch (2079:20): [True: 0, False: 1]
  ------------------
 2080|      0|        w = (int)buf_size - 1;
 2081|      1|    buf[w] = 0;
 2082|      1|    return w;
 2083|      1|}
_Z15ImFormatStringVPcmPKcP13__va_list_tag:
 2086|  16.9k|{
 2087|       |#ifdef IMGUI_USE_STB_SPRINTF
 2088|       |    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
 2089|       |#else
 2090|  16.9k|    int w = vsnprintf(buf, buf_size, fmt, args);
 2091|  16.9k|#endif
 2092|  16.9k|    if (buf == NULL)
  ------------------
  |  Branch (2092:9): [True: 0, False: 16.9k]
  ------------------
 2093|      0|        return w;
 2094|  16.9k|    if (w == -1 || w >= (int)buf_size)
  ------------------
  |  Branch (2094:9): [True: 0, False: 16.9k]
  |  Branch (2094:20): [True: 0, False: 16.9k]
  ------------------
 2095|      0|        w = (int)buf_size - 1;
 2096|  16.9k|    buf[w] = 0;
 2097|  16.9k|    return w;
 2098|  16.9k|}
_Z26ImFormatStringToTempBufferPPKcS1_S0_z:
 2102|  16.9k|{
 2103|  16.9k|    va_list args;
 2104|  16.9k|    va_start(args, fmt);
 2105|  16.9k|    ImFormatStringToTempBufferV(out_buf, out_buf_end, fmt, args);
 2106|  16.9k|    va_end(args);
 2107|  16.9k|}
_Z27ImFormatStringToTempBufferVPPKcS1_S0_P13__va_list_tag:
 2110|  16.9k|{
 2111|  16.9k|    ImGuiContext& g = *GImGui;
 2112|  16.9k|    if (fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0)
  ------------------
  |  Branch (2112:9): [True: 16.9k, False: 0]
  |  Branch (2112:26): [True: 16.9k, False: 0]
  |  Branch (2112:43): [True: 0, False: 16.9k]
  ------------------
 2113|      0|    {
 2114|      0|        const char* buf = va_arg(args, const char*); // Skip formatting when using "%s"
 2115|      0|        if (buf == NULL)
  ------------------
  |  Branch (2115:13): [True: 0, False: 0]
  ------------------
 2116|      0|            buf = "(null)";
 2117|      0|        *out_buf = buf;
 2118|      0|        if (out_buf_end) { *out_buf_end = buf + strlen(buf); }
  ------------------
  |  Branch (2118:13): [True: 0, False: 0]
  ------------------
 2119|      0|    }
 2120|  16.9k|    else if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 's' && fmt[4] == 0)
  ------------------
  |  Branch (2120:14): [True: 16.9k, False: 0]
  |  Branch (2120:31): [True: 0, False: 16.9k]
  |  Branch (2120:48): [True: 0, False: 0]
  |  Branch (2120:65): [True: 0, False: 0]
  |  Branch (2120:82): [True: 0, False: 0]
  ------------------
 2121|      0|    {
 2122|      0|        int buf_len = va_arg(args, int); // Skip formatting when using "%.*s"
 2123|      0|        const char* buf = va_arg(args, const char*);
 2124|      0|        if (buf == NULL)
  ------------------
  |  Branch (2124:13): [True: 0, False: 0]
  ------------------
 2125|      0|        {
 2126|      0|            buf = "(null)";
 2127|      0|            buf_len = ImMin(buf_len, 6);
 2128|      0|        }
 2129|      0|        *out_buf = buf;
 2130|      0|        *out_buf_end = buf + buf_len; // Disallow not passing 'out_buf_end' here. User is expected to use it.
 2131|      0|    }
 2132|  16.9k|    else
 2133|  16.9k|    {
 2134|  16.9k|        int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
 2135|  16.9k|        *out_buf = g.TempBuffer.Data;
 2136|  16.9k|        if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }
  ------------------
  |  Branch (2136:13): [True: 0, False: 16.9k]
  ------------------
 2137|  16.9k|    }
 2138|  16.9k|}
_Z10ImHashDataPKvmj:
 2167|   101k|{
 2168|   101k|    ImU32 crc = ~seed;
 2169|   101k|    const unsigned char* data = (const unsigned char*)data_p;
 2170|   101k|    const ImU32* crc32_lut = GCrc32LookupTable;
 2171|   508k|    while (data_size-- != 0)
  ------------------
  |  Branch (2171:12): [True: 406k, False: 101k]
  ------------------
 2172|   406k|        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
 2173|   101k|    return ~crc;
 2174|   101k|}
_Z9ImHashStrPKcmj:
 2183|   485k|{
 2184|   485k|    seed = ~seed;
 2185|   485k|    ImU32 crc = seed;
 2186|   485k|    const unsigned char* data = (const unsigned char*)data_p;
 2187|   485k|    const ImU32* crc32_lut = GCrc32LookupTable;
 2188|   485k|    if (data_size != 0)
  ------------------
  |  Branch (2188:9): [True: 0, False: 485k]
  ------------------
 2189|      0|    {
 2190|      0|        while (data_size-- != 0)
  ------------------
  |  Branch (2190:16): [True: 0, False: 0]
  ------------------
 2191|      0|        {
 2192|      0|            unsigned char c = *data++;
 2193|      0|            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (2193:17): [True: 0, False: 0]
  |  Branch (2193:29): [True: 0, False: 0]
  |  Branch (2193:47): [True: 0, False: 0]
  |  Branch (2193:65): [True: 0, False: 0]
  ------------------
 2194|      0|                crc = seed;
 2195|      0|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 2196|      0|        }
 2197|      0|    }
 2198|   485k|    else
 2199|   485k|    {
 2200|  6.63M|        while (unsigned char c = *data++)
  ------------------
  |  Branch (2200:30): [True: 6.15M, False: 485k]
  ------------------
 2201|  6.15M|        {
 2202|  6.15M|            if (c == '#' && data[0] == '#' && data[1] == '#')
  ------------------
  |  Branch (2202:17): [True: 622k, False: 5.52M]
  |  Branch (2202:29): [True: 247k, False: 375k]
  |  Branch (2202:47): [True: 76.6k, False: 170k]
  ------------------
 2203|  76.6k|                crc = seed;
 2204|  6.15M|            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
 2205|  6.15M|        }
 2206|   485k|    }
 2207|   485k|    return ~crc;
 2208|   485k|}
_Z18ImTextCharFromUtf8PjPKcS1_:
 2300|   244k|{
 2301|   244k|    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
 2302|   244k|    static const int masks[]  = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
 2303|   244k|    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
 2304|   244k|    static const int shiftc[] = { 0, 18, 12, 6, 0 };
 2305|   244k|    static const int shifte[] = { 0, 6, 4, 2, 0 };
 2306|   244k|    int len = lengths[*(const unsigned char*)in_text >> 3];
 2307|   244k|    int wanted = len + (len ? 0 : 1);
  ------------------
  |  Branch (2307:25): [True: 244k, False: 0]
  ------------------
 2308|       |
 2309|   244k|    if (in_text_end == NULL)
  ------------------
  |  Branch (2309:9): [True: 0, False: 244k]
  ------------------
 2310|      0|        in_text_end = in_text + wanted; // Max length, nulls will be taken into account.
 2311|       |
 2312|       |    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
 2313|       |    // so it is fast even with excessive branching.
 2314|   244k|    unsigned char s[4];
 2315|   244k|    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
  ------------------
  |  Branch (2315:12): [True: 244k, False: 0]
  ------------------
 2316|   244k|    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
  ------------------
  |  Branch (2316:12): [True: 244k, False: 0]
  ------------------
 2317|   244k|    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
  ------------------
  |  Branch (2317:12): [True: 193k, False: 50.5k]
  ------------------
 2318|   244k|    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;
  ------------------
  |  Branch (2318:12): [True: 33.7k, False: 210k]
  ------------------
 2319|       |
 2320|       |    // Assume a four-byte character and load four bytes. Unused bits are shifted out.
 2321|   244k|    *out_char  = (uint32_t)(s[0] & masks[len]) << 18;
 2322|   244k|    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
 2323|   244k|    *out_char |= (uint32_t)(s[2] & 0x3f) <<  6;
 2324|   244k|    *out_char |= (uint32_t)(s[3] & 0x3f) <<  0;
 2325|   244k|    *out_char >>= shiftc[len];
 2326|       |
 2327|       |    // Accumulate the various error conditions.
 2328|   244k|    int e = 0;
 2329|   244k|    e  = (*out_char < mins[len]) << 6; // non-canonical encoding
 2330|   244k|    e |= ((*out_char >> 11) == 0x1b) << 7;  // surrogate half?
 2331|   244k|    e |= (*out_char > IM_UNICODE_CODEPOINT_MAX) << 8;  // out of range?
  ------------------
  |  | 2542|   244k|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
 2332|   244k|    e |= (s[1] & 0xc0) >> 2;
 2333|   244k|    e |= (s[2] & 0xc0) >> 4;
 2334|   244k|    e |= (s[3]       ) >> 6;
 2335|   244k|    e ^= 0x2a; // top two bits of each tail byte correct?
 2336|   244k|    e >>= shifte[len];
 2337|       |
 2338|   244k|    if (e)
  ------------------
  |  Branch (2338:9): [True: 11.4k, False: 232k]
  ------------------
 2339|  11.4k|    {
 2340|       |        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
 2341|       |        // One byte is consumed in case of invalid first byte of in_text.
 2342|       |        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
 2343|       |        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
 2344|  11.4k|        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
 2345|  11.4k|        *out_char = IM_UNICODE_CODEPOINT_INVALID;
  ------------------
  |  | 2538|  11.4k|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 2346|  11.4k|    }
 2347|       |
 2348|   244k|    return wanted;
 2349|   244k|}
_ZN5ImGui23ColorConvertU32ToFloat4Ej:
 2510|   214k|{
 2511|   214k|    float s = 1.0f / 255.0f;
 2512|   214k|    return ImVec4(
 2513|   214k|        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2746|   214k|#define IM_COL32_R_SHIFT    0
  ------------------
 2514|   214k|        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2747|   214k|#define IM_COL32_G_SHIFT    8
  ------------------
 2515|   214k|        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
  ------------------
  |  | 2748|   214k|#define IM_COL32_B_SHIFT    16
  ------------------
 2516|   214k|        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
  ------------------
  |  | 2749|   214k|#define IM_COL32_A_SHIFT    24
  ------------------
 2517|   214k|}
_ZN5ImGui23ColorConvertFloat4ToU32ERK6ImVec4:
 2520|  1.13M|{
 2521|  1.13M|    ImU32 out;
 2522|  1.13M|    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  |  286|  1.13M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
  ------------------
  |  | 2746|  1.13M|#define IM_COL32_R_SHIFT    0
  ------------------
 2523|  1.13M|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  |  286|  1.13M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
  ------------------
  |  | 2747|  1.13M|#define IM_COL32_G_SHIFT    8
  ------------------
 2524|  1.13M|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  |  286|  1.13M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
  ------------------
  |  | 2748|  1.13M|#define IM_COL32_B_SHIFT    16
  ------------------
 2525|  1.13M|    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  |  286|  1.13M|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                  out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
  ------------------
  |  | 2749|  1.13M|#define IM_COL32_A_SHIFT    24
  ------------------
 2526|  1.13M|    return out;
 2527|  1.13M|}
_Z12ImLowerBoundP16ImGuiStoragePairS0_j:
 2587|   170k|{
 2588|   170k|    ImGuiStoragePair* in_p = in_begin;
 2589|   511k|    for (size_t count = (size_t)(in_end - in_p); count > 0; )
  ------------------
  |  Branch (2589:50): [True: 340k, False: 170k]
  ------------------
 2590|   340k|    {
 2591|   340k|        size_t count2 = count >> 1;
 2592|   340k|        ImGuiStoragePair* mid = in_p + count2;
 2593|   340k|        if (mid->key < key)
  ------------------
  |  Branch (2593:13): [True: 93.6k, False: 247k]
  ------------------
 2594|  93.6k|        {
 2595|  93.6k|            in_p = ++mid;
 2596|  93.6k|            count -= count2 + 1;
 2597|  93.6k|        }
 2598|   247k|        else
 2599|   247k|        {
 2600|   247k|            count = count2;
 2601|   247k|        }
 2602|   340k|    }
 2603|   170k|    return in_p;
 2604|   170k|}
_ZNK12ImGuiStorage10GetVoidPtrEj:
 2642|   170k|{
 2643|   170k|    ImGuiStoragePair* it = ImLowerBound(const_cast<ImGuiStoragePair*>(Data.Data), const_cast<ImGuiStoragePair*>(Data.Data + Data.Size), key);
 2644|   170k|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2644:9): [True: 1, False: 170k]
  |  Branch (2644:29): [True: 2, False: 170k]
  ------------------
 2645|      3|        return NULL;
 2646|   170k|    return it->val_p;
 2647|   170k|}
_ZN12ImGuiStorage10SetVoidPtrEjPv:
 2704|      3|{
 2705|      3|    ImGuiStoragePair* it = ImLowerBound(Data.Data, Data.Data + Data.Size, key);
 2706|      3|    if (it == Data.end() || it->key != key)
  ------------------
  |  Branch (2706:9): [True: 1, False: 2]
  |  Branch (2706:29): [True: 2, False: 0]
  ------------------
 2707|      3|        Data.insert(it, ImGuiStoragePair(key, val));
 2708|      0|    else
 2709|      0|        it->val_p = val;
 2710|      3|}
_ZN5ImGui8GetStyleEv:
 3191|   138k|{
 3192|   138k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|   138k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3193|   138k|    return GImGui->Style;
 3194|   138k|}
_ZN5ImGui11GetColorU32Eif:
 3197|   995k|{
 3198|   995k|    ImGuiStyle& style = GImGui->Style;
 3199|   995k|    ImVec4 c = style.Colors[idx];
 3200|   995k|    c.w *= style.Alpha * alpha_mul;
 3201|   995k|    return ColorConvertFloat4ToU32(c);
 3202|   995k|}
_ZN5ImGui14PushStyleColorEiRK6ImVec4:
 3242|  76.6k|{
 3243|  76.6k|    ImGuiContext& g = *GImGui;
 3244|  76.6k|    ImGuiColorMod backup;
 3245|  76.6k|    backup.Col = idx;
 3246|  76.6k|    backup.BackupValue = g.Style.Colors[idx];
 3247|  76.6k|    g.ColorStack.push_back(backup);
 3248|  76.6k|    if (g.DebugFlashStyleColorIdx != idx)
  ------------------
  |  Branch (3248:9): [True: 76.6k, False: 0]
  ------------------
 3249|  76.6k|        g.Style.Colors[idx] = col;
 3250|  76.6k|}
_ZN5ImGui13PopStyleColorEi:
 3253|  76.6k|{
 3254|  76.6k|    ImGuiContext& g = *GImGui;
 3255|  76.6k|    if (g.ColorStack.Size < count)
  ------------------
  |  Branch (3255:9): [True: 0, False: 76.6k]
  ------------------
 3256|      0|    {
 3257|      0|        IM_ASSERT_USER_ERROR(g.ColorStack.Size > count, "Calling PopStyleColor() too many times!");
  ------------------
  |  |  271|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3258|      0|        count = g.ColorStack.Size;
 3259|      0|    }
 3260|   153k|    while (count > 0)
  ------------------
  |  Branch (3260:12): [True: 76.6k, False: 76.6k]
  ------------------
 3261|  76.6k|    {
 3262|  76.6k|        ImGuiColorMod& backup = g.ColorStack.back();
 3263|  76.6k|        g.Style.Colors[backup.Col] = backup.BackupValue;
 3264|  76.6k|        g.ColorStack.pop_back();
 3265|  76.6k|        count--;
 3266|  76.6k|    }
 3267|  76.6k|}
_ZN5ImGui15GetStyleVarInfoEi:
 3312|   153k|{
 3313|   153k|    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
  ------------------
  |  |   23|   153k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3314|   153k|    IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
  ------------------
  |  |  257|   153k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
 3315|   153k|    return &GStyleVarInfo[idx];
 3316|   153k|}
_ZN5ImGui12PushStyleVarEiRK6ImVec2:
 3333|  76.6k|{
 3334|  76.6k|    ImGuiContext& g = *GImGui;
 3335|  76.6k|    const ImGuiDataVarInfo* var_info = GetStyleVarInfo(idx);
 3336|  76.6k|    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
  ------------------
  |  Branch (3336:9): [True: 76.6k, False: 0]
  |  Branch (3336:50): [True: 76.6k, False: 0]
  ------------------
 3337|  76.6k|    {
 3338|  76.6k|        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
 3339|  76.6k|        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
 3340|  76.6k|        *pvar = val;
 3341|  76.6k|        return;
 3342|  76.6k|    }
 3343|      0|    IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!");
  ------------------
  |  |  271|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3344|      0|}
_ZN5ImGui11PopStyleVarEi:
 3347|  76.6k|{
 3348|  76.6k|    ImGuiContext& g = *GImGui;
 3349|  76.6k|    if (g.StyleVarStack.Size < count)
  ------------------
  |  Branch (3349:9): [True: 0, False: 76.6k]
  ------------------
 3350|      0|    {
 3351|      0|        IM_ASSERT_USER_ERROR(g.StyleVarStack.Size > count, "Calling PopStyleVar() too many times!");
  ------------------
  |  |  271|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 3352|      0|        count = g.StyleVarStack.Size;
 3353|      0|    }
 3354|   153k|    while (count > 0)
  ------------------
  |  Branch (3354:12): [True: 76.6k, False: 76.6k]
  ------------------
 3355|  76.6k|    {
 3356|       |        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
 3357|  76.6k|        ImGuiStyleMod& backup = g.StyleVarStack.back();
 3358|  76.6k|        const ImGuiDataVarInfo* info = GetStyleVarInfo(backup.VarIdx);
 3359|  76.6k|        void* data = info->GetVarPtr(&g.Style);
 3360|  76.6k|        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
  ------------------
  |  Branch (3360:13): [True: 76.6k, False: 0]
  |  Branch (3360:50): [True: 0, False: 76.6k]
  ------------------
 3361|  76.6k|        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
  ------------------
  |  Branch (3361:18): [True: 76.6k, False: 0]
  |  Branch (3361:55): [True: 76.6k, False: 0]
  ------------------
 3362|  76.6k|        g.StyleVarStack.pop_back();
 3363|  76.6k|        count--;
 3364|  76.6k|    }
 3365|  76.6k|}
_ZN5ImGui19FindRenderedTextEndEPKcS1_:
 3443|   306k|{
 3444|   306k|    const char* text_display_end = text;
 3445|   306k|    if (!text_end)
  ------------------
  |  Branch (3445:9): [True: 306k, False: 0]
  ------------------
 3446|   306k|        text_end = (const char*)-1;
 3447|       |
 3448|  2.76M|    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
  ------------------
  |  Branch (3448:12): [True: 2.76M, False: 0]
  |  Branch (3448:43): [True: 2.60M, False: 153k]
  |  Branch (3448:73): [True: 2.45M, False: 153k]
  |  Branch (3448:103): [True: 0, False: 153k]
  ------------------
 3449|  2.45M|        text_display_end++;
 3450|   306k|    return text_display_end;
 3451|   306k|}
_ZN5ImGui19RenderTextClippedExEP10ImDrawListRK6ImVec2S4_PKcS6_PS3_S4_PK6ImRect:
 3503|   153k|{
 3504|       |    // Perform CPU side clipping for single clipped element to avoid using scissor state
 3505|   153k|    ImVec2 pos = pos_min;
 3506|   153k|    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);
  ------------------
  |  Branch (3506:30): [True: 153k, False: 0]
  ------------------
 3507|       |
 3508|   153k|    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
  ------------------
  |  Branch (3508:30): [True: 153k, False: 0]
  ------------------
 3509|   153k|    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
  ------------------
  |  Branch (3509:30): [True: 153k, False: 0]
  ------------------
 3510|   153k|    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
  ------------------
  |  Branch (3510:26): [True: 76.6k, False: 76.6k]
  |  Branch (3510:66): [True: 0, False: 76.6k]
  ------------------
 3511|   153k|    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
  ------------------
  |  Branch (3511:9): [True: 153k, False: 0]
  ------------------
 3512|   153k|        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);
  ------------------
  |  Branch (3512:26): [True: 0, False: 153k]
  |  Branch (3512:51): [True: 0, False: 153k]
  ------------------
 3513|       |
 3514|       |    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
 3515|   153k|    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
  ------------------
  |  Branch (3515:9): [True: 0, False: 153k]
  ------------------
 3516|   153k|    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);
  ------------------
  |  Branch (3516:9): [True: 153k, False: 0]
  ------------------
 3517|       |
 3518|       |    // Render
 3519|   153k|    if (need_clipping)
  ------------------
  |  Branch (3519:9): [True: 76.6k, False: 76.6k]
  ------------------
 3520|  76.6k|    {
 3521|  76.6k|        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
 3522|  76.6k|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
 3523|  76.6k|    }
 3524|  76.6k|    else
 3525|  76.6k|    {
 3526|  76.6k|        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
 3527|  76.6k|    }
 3528|   153k|}
_ZN5ImGui17RenderTextClippedERK6ImVec2S2_PKcS4_PS1_S2_PK6ImRect:
 3531|   153k|{
 3532|       |    // Hide anything after a '##' string
 3533|   153k|    const char* text_display_end = FindRenderedTextEnd(text, text_end);
 3534|   153k|    const int text_len = (int)(text_display_end - text);
 3535|   153k|    if (text_len == 0)
  ------------------
  |  Branch (3535:9): [True: 0, False: 153k]
  ------------------
 3536|      0|        return;
 3537|       |
 3538|   153k|    ImGuiContext& g = *GImGui;
 3539|   153k|    ImGuiWindow* window = g.CurrentWindow;
 3540|   153k|    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
 3541|   153k|    if (g.LogEnabled)
  ------------------
  |  Branch (3541:9): [True: 0, False: 153k]
  ------------------
 3542|      0|        LogRenderedText(&pos_min, text, text_display_end);
 3543|   153k|}
_ZN5ImGui11RenderFrameE6ImVec2S0_jbf:
 3606|  59.7k|{
 3607|  59.7k|    ImGuiContext& g = *GImGui;
 3608|  59.7k|    ImGuiWindow* window = g.CurrentWindow;
 3609|  59.7k|    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
 3610|  59.7k|    const float border_size = g.Style.FrameBorderSize;
 3611|  59.7k|    if (border && border_size > 0.0f)
  ------------------
  |  Branch (3611:9): [True: 59.7k, False: 0]
  |  Branch (3611:19): [True: 59.7k, False: 0]
  ------------------
 3612|  59.7k|    {
 3613|  59.7k|        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
 3614|  59.7k|        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
 3615|  59.7k|    }
 3616|  59.7k|}
_ZN5ImGui18RenderNavHighlightERK6ImRectji:
 3631|  24.4k|{
 3632|  24.4k|    ImGuiContext& g = *GImGui;
 3633|  24.4k|    if (id != g.NavId)
  ------------------
  |  Branch (3633:9): [True: 15.3k, False: 9.07k]
  ------------------
 3634|  15.3k|        return;
 3635|  9.07k|    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
  ------------------
  |  Branch (3635:9): [True: 190, False: 8.88k]
  |  Branch (3635:34): [True: 190, False: 0]
  ------------------
 3636|    190|        return;
 3637|  8.88k|    ImGuiWindow* window = g.CurrentWindow;
 3638|  8.88k|    if (window->DC.NavHideHighlightOneFrame)
  ------------------
  |  Branch (3638:9): [True: 0, False: 8.88k]
  ------------------
 3639|      0|        return;
 3640|       |
 3641|  8.88k|    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
  ------------------
  |  Branch (3641:22): [True: 0, False: 8.88k]
  ------------------
 3642|  8.88k|    ImRect display_rect = bb;
 3643|  8.88k|    display_rect.ClipWith(window->ClipRect);
 3644|  8.88k|    const float thickness = 2.0f;
 3645|  8.88k|    if (flags & ImGuiNavHighlightFlags_Compact)
  ------------------
  |  Branch (3645:9): [True: 8.52k, False: 360]
  ------------------
 3646|  8.52k|    {
 3647|  8.52k|        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, thickness);
 3648|  8.52k|    }
 3649|    360|    else
 3650|    360|    {
 3651|    360|        const float distance = 3.0f + thickness * 0.5f;
 3652|    360|        display_rect.Expand(ImVec2(distance, distance));
 3653|    360|        bool fully_visible = window->ClipRect.Contains(display_rect);
 3654|    360|        if (!fully_visible)
  ------------------
  |  Branch (3654:13): [True: 5, False: 355]
  ------------------
 3655|      5|            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
 3656|    360|        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, thickness);
 3657|    360|        if (!fully_visible)
  ------------------
  |  Branch (3657:13): [True: 5, False: 355]
  ------------------
 3658|      5|            window->DrawList->PopClipRect();
 3659|    360|    }
 3660|  8.88k|}
_ZN5ImGui17GetCurrentContextEv:
 3695|      1|{
 3696|      1|    return GImGui;
 3697|      1|}
_ZN5ImGui17SetCurrentContextEP12ImGuiContext:
 3700|      1|{
 3701|       |#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
 3702|       |    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
 3703|       |#else
 3704|      1|    GImGui = ctx;
 3705|      1|#endif
 3706|      1|}
_ZN5ImGui13CreateContextEP11ImFontAtlas:
 3724|      1|{
 3725|      1|    ImGuiContext* prev_ctx = GetCurrentContext();
 3726|      1|    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
  ------------------
  |  | 2054|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3727|      1|    SetCurrentContext(ctx);
 3728|      1|    Initialize();
 3729|      1|    if (prev_ctx != NULL)
  ------------------
  |  Branch (3729:9): [True: 0, False: 1]
  ------------------
 3730|      0|        SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
 3731|      1|    return ctx;
 3732|      1|}
_ZN5ImGui10InitializeEv:
 3762|      1|{
 3763|      1|    ImGuiContext& g = *GImGui;
 3764|      1|    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3765|       |
 3766|       |    // Add .ini handle for ImGuiWindow and ImGuiTable types
 3767|      1|    {
 3768|      1|        ImGuiSettingsHandler ini_handler;
 3769|      1|        ini_handler.TypeName = "Window";
 3770|      1|        ini_handler.TypeHash = ImHashStr("Window");
 3771|      1|        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
 3772|      1|        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
 3773|      1|        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
 3774|      1|        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
 3775|      1|        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
 3776|      1|        AddSettingsHandler(&ini_handler);
 3777|      1|    }
 3778|      1|    TableSettingsAddSettingsHandler();
 3779|       |
 3780|       |    // Setup default localization table
 3781|      1|    LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS));
  ------------------
  |  |   93|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3782|       |
 3783|       |    // Setup default platform clipboard/IME handlers.
 3784|      1|    g.IO.GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;    // Platform dependent default implementations
 3785|      1|    g.IO.SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
 3786|      1|    g.IO.ClipboardUserData = (void*)&g;                          // Default implementation use the ImGuiContext as user data (ideally those would be arguments to the function)
 3787|      1|    g.IO.SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;
 3788|       |
 3789|       |    // Create default viewport
 3790|      1|    ImGuiViewportP* viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 2054|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 3791|      1|    viewport->ID = IMGUI_VIEWPORT_DEFAULT_ID;
 3792|      1|    viewport->Idx = 0;
 3793|      1|    viewport->PlatformWindowCreated = true;
 3794|      1|    viewport->Flags = ImGuiViewportFlags_OwnedByApp;
 3795|      1|    g.Viewports.push_back(viewport);
 3796|      1|    g.TempBuffer.resize(1024 * 3 + 1, 0);
 3797|      1|    g.ViewportCreatedCount++;
 3798|      1|    g.PlatformIO.Viewports.push_back(g.Viewports[0]);
 3799|       |
 3800|       |    // Build KeysMayBeCharInput[] lookup table (1 bool per named key)
 3801|    155|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (3801:50): [True: 154, False: 1]
  ------------------
 3802|    154|        if ((key >= ImGuiKey_0 && key <= ImGuiKey_9) || (key >= ImGuiKey_A && key <= ImGuiKey_Z) || (key >= ImGuiKey_Keypad0 && key <= ImGuiKey_Keypad9)
  ------------------
  |  Branch (3802:14): [True: 130, False: 24]
  |  Branch (3802:35): [True: 10, False: 120]
  |  Branch (3802:58): [True: 120, False: 24]
  |  Branch (3802:79): [True: 26, False: 94]
  |  Branch (3802:102): [True: 54, False: 64]
  |  Branch (3802:129): [True: 10, False: 44]
  ------------------
 3803|    154|            || key == ImGuiKey_Tab || key == ImGuiKey_Space || key == ImGuiKey_Apostrophe || key == ImGuiKey_Comma || key == ImGuiKey_Minus || key == ImGuiKey_Period
  ------------------
  |  Branch (3803:16): [True: 1, False: 107]
  |  Branch (3803:39): [True: 1, False: 106]
  |  Branch (3803:64): [True: 1, False: 105]
  |  Branch (3803:94): [True: 1, False: 104]
  |  Branch (3803:119): [True: 1, False: 103]
  |  Branch (3803:144): [True: 1, False: 102]
  ------------------
 3804|    154|            || key == ImGuiKey_Slash || key == ImGuiKey_Semicolon || key == ImGuiKey_Equal || key == ImGuiKey_LeftBracket || key == ImGuiKey_RightBracket || key == ImGuiKey_GraveAccent
  ------------------
  |  Branch (3804:16): [True: 1, False: 101]
  |  Branch (3804:41): [True: 1, False: 100]
  |  Branch (3804:70): [True: 1, False: 99]
  |  Branch (3804:95): [True: 1, False: 98]
  |  Branch (3804:126): [True: 1, False: 97]
  |  Branch (3804:158): [True: 1, False: 96]
  ------------------
 3805|    154|            || key == ImGuiKey_KeypadDecimal || key == ImGuiKey_KeypadDivide || key == ImGuiKey_KeypadMultiply || key == ImGuiKey_KeypadSubtract || key == ImGuiKey_KeypadAdd || key == ImGuiKey_KeypadEqual)
  ------------------
  |  Branch (3805:16): [True: 1, False: 95]
  |  Branch (3805:49): [True: 1, False: 94]
  |  Branch (3805:81): [True: 1, False: 93]
  |  Branch (3805:115): [True: 1, False: 92]
  |  Branch (3805:149): [True: 1, False: 91]
  |  Branch (3805:178): [True: 1, False: 90]
  ------------------
 3806|     64|            g.KeysMayBeCharInput.SetBit(key);
 3807|       |
 3808|      1|#ifdef IMGUI_HAS_DOCK
 3809|       |    // Initialize Docking
 3810|      1|    DockContextInitialize(&g);
 3811|      1|#endif
 3812|       |
 3813|      1|    g.Initialized = true;
 3814|      1|}
_ZN5ImGui16CallContextHooksEP12ImGuiContext20ImGuiContextHookType:
 3928|   460k|{
 3929|   460k|    ImGuiContext& g = *ctx;
 3930|   460k|    for (ImGuiContextHook& hook : g.Hooks)
  ------------------
  |  Branch (3930:33): [True: 0, False: 460k]
  ------------------
 3931|      0|        if (hook.Type == hook_type)
  ------------------
  |  Branch (3931:13): [True: 0, False: 0]
  ------------------
 3932|      0|            hook.Callback(&g, &hook);
 3933|   460k|}
_ZN11ImGuiWindowC2EP12ImGuiContextPKc:
 3942|      3|{
 3943|      3|    memset(this, 0, sizeof(*this));
 3944|      3|    Ctx = ctx;
 3945|      3|    Name = ImStrdup(name);
 3946|      3|    NameBufLen = (int)strlen(name) + 1;
 3947|      3|    ID = ImHashStr(name);
 3948|      3|    IDStack.push_back(ID);
 3949|      3|    ViewportAllowPlatformMonitorExtend = -1;
 3950|      3|    ViewportPos = ImVec2(FLT_MAX, FLT_MAX);
 3951|      3|    MoveId = GetID("#MOVE");
 3952|      3|    TabId = GetID("#TAB");
 3953|      3|    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 3954|      3|    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
 3955|      3|    AutoFitFramesX = AutoFitFramesY = -1;
 3956|      3|    AutoPosLastDirection = ImGuiDir_None;
 3957|      3|    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = SetWindowDockAllowFlags = 0;
 3958|      3|    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);
 3959|      3|    LastFrameActive = -1;
 3960|      3|    LastFrameJustFocused = -1;
 3961|      3|    LastTimeActive = -1.0f;
 3962|      3|    FontWindowScale = FontDpiScale = 1.0f;
 3963|      3|    SettingsOffset = -1;
 3964|      3|    DockOrder = -1;
 3965|      3|    DrawList = &DrawListInst;
 3966|      3|    DrawList->_Data = &Ctx->DrawListSharedData;
 3967|      3|    DrawList->_OwnerName = Name;
 3968|      3|    NavPreferredScoringPosRel[0] = NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX);
 3969|      3|    IM_PLACEMENT_NEW(&WindowClass) ImGuiWindowClass();
  ------------------
  |  | 2053|      6|#define IM_PLACEMENT_NEW(_PTR)              new(ImNewWrapper(), _PTR)
  ------------------
 3970|      3|}
_ZN5ImGui31GcCompactTransientWindowBuffersEP11ImGuiWindow:
 4004|      2|{
 4005|      2|    window->MemoryCompacted = true;
 4006|      2|    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
 4007|      2|    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
 4008|      2|    window->IDStack.clear();
 4009|      2|    window->DrawList->_ClearFreeMemory();
 4010|      2|    window->DC.ChildWindows.clear();
 4011|      2|    window->DC.ItemWidthStack.clear();
 4012|      2|    window->DC.TextWrapPosStack.clear();
 4013|      2|}
_ZN5ImGui29GcAwakeTransientWindowBuffersEP11ImGuiWindow:
 4016|      1|{
 4017|       |    // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
 4018|       |    // The other buffers tends to amortize much faster.
 4019|      1|    window->MemoryCompacted = false;
 4020|      1|    window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
 4021|      1|    window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
 4022|      1|    window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
 4023|      1|}
_ZN5ImGui11SetActiveIDEjP11ImGuiWindow:
 4026|    220|{
 4027|    220|    ImGuiContext& g = *GImGui;
 4028|       |
 4029|       |    // Clear previous active id
 4030|    220|    if (g.ActiveId != 0)
  ------------------
  |  Branch (4030:9): [True: 53, False: 167]
  ------------------
 4031|     53|    {
 4032|       |        // While most behaved code would make an effort to not steal active id during window move/drag operations,
 4033|       |        // we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
 4034|       |        // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
 4035|     53|        if (g.MovingWindow != NULL && g.ActiveId == g.MovingWindow->MoveId)
  ------------------
  |  Branch (4035:13): [True: 0, False: 53]
  |  Branch (4035:39): [True: 0, False: 0]
  ------------------
 4036|      0|        {
 4037|      0|            IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n");
  ------------------
  |  |  245|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (245:50): [True: 0, False: 0]
  |  |  |  Branch (245:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4038|      0|            g.MovingWindow = NULL;
 4039|      0|        }
 4040|       |
 4041|       |        // This could be written in a more general way (e.g associate a hook to ActiveId),
 4042|       |        // but since this is currently quite an exception we'll leave it as is.
 4043|       |        // One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveId()
 4044|     53|        if (g.InputTextState.ID == g.ActiveId)
  ------------------
  |  Branch (4044:13): [True: 0, False: 53]
  ------------------
 4045|      0|            InputTextDeactivateHook(g.ActiveId);
 4046|     53|    }
 4047|       |
 4048|       |    // Set active id
 4049|    220|    g.ActiveIdIsJustActivated = (g.ActiveId != id);
 4050|    220|    if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (4050:9): [True: 106, False: 114]
  ------------------
 4051|    106|    {
 4052|    106|        IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : "");
  ------------------
  |  |  245|    106|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (245:50): [True: 0, False: 106]
  |  |  |  Branch (245:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4053|    106|        g.ActiveIdTimer = 0.0f;
 4054|    106|        g.ActiveIdHasBeenPressedBefore = false;
 4055|    106|        g.ActiveIdHasBeenEditedBefore = false;
 4056|    106|        g.ActiveIdMouseButton = -1;
 4057|    106|        if (id != 0)
  ------------------
  |  Branch (4057:13): [True: 53, False: 53]
  ------------------
 4058|     53|        {
 4059|     53|            g.LastActiveId = id;
 4060|     53|            g.LastActiveIdTimer = 0.0f;
 4061|     53|        }
 4062|    106|    }
 4063|    220|    g.ActiveId = id;
 4064|    220|    g.ActiveIdAllowOverlap = false;
 4065|    220|    g.ActiveIdNoClearOnFocusLoss = false;
 4066|    220|    g.ActiveIdWindow = window;
 4067|    220|    g.ActiveIdHasBeenEditedThisFrame = false;
 4068|    220|    g.ActiveIdFromShortcut = false;
 4069|    220|    if (id)
  ------------------
  |  Branch (4069:9): [True: 53, False: 167]
  ------------------
 4070|     53|    {
 4071|     53|        g.ActiveIdIsAlive = id;
 4072|     53|        g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource_Mouse;
  ------------------
  |  Branch (4072:29): [True: 1, False: 52]
  |  Branch (4072:54): [True: 0, False: 52]
  ------------------
 4073|     53|        IM_ASSERT(g.ActiveIdSource != ImGuiInputSource_None);
  ------------------
  |  |   23|     53|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4074|     53|    }
 4075|       |
 4076|       |    // Clear declaration of inputs claimed by the widget
 4077|       |    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
 4078|    220|    g.ActiveIdUsingNavDirMask = 0x00;
 4079|    220|    g.ActiveIdUsingAllKeyboardKeys = false;
 4080|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4081|       |    g.ActiveIdUsingNavInputMask = 0x00;
 4082|       |#endif
 4083|    220|}
_ZN5ImGui13ClearActiveIDEv:
 4086|    167|{
 4087|    167|    SetActiveID(0, NULL); // g.ActiveId = 0;
 4088|    167|}
_ZN5ImGui12SetHoveredIDEj:
 4091|    134|{
 4092|    134|    ImGuiContext& g = *GImGui;
 4093|    134|    g.HoveredId = id;
 4094|    134|    g.HoveredIdAllowOverlap = false;
 4095|    134|    if (id != 0 && g.HoveredIdPreviousFrame != id)
  ------------------
  |  Branch (4095:9): [True: 134, False: 0]
  |  Branch (4095:20): [True: 14, False: 120]
  ------------------
 4096|     14|        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
 4097|    134|}
_ZN5ImGui24IsWindowContentHoverableEP11ImGuiWindowi:
 4127|    164|{
 4128|       |    // An active popup disable hovering on other windows (apart from its own children)
 4129|       |    // FIXME-OPT: This could be cached/stored within the window.
 4130|    164|    ImGuiContext& g = *GImGui;
 4131|    164|    if (g.NavWindow)
  ------------------
  |  Branch (4131:9): [True: 5, False: 159]
  ------------------
 4132|      5|        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindowDockTree)
  ------------------
  |  Branch (4132:26): [True: 5, False: 0]
  ------------------
 4133|      5|            if (focused_root_window->WasActive && focused_root_window != window->RootWindowDockTree)
  ------------------
  |  Branch (4133:17): [True: 5, False: 0]
  |  Branch (4133:51): [True: 0, False: 5]
  ------------------
 4134|      0|            {
 4135|       |                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
 4136|       |                // NB: The 'else' is important because Modal windows are also Popups.
 4137|      0|                bool want_inhibit = false;
 4138|      0|                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (4138:21): [True: 0, False: 0]
  ------------------
 4139|      0|                    want_inhibit = true;
 4140|      0|                else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
  ------------------
  |  Branch (4140:26): [True: 0, False: 0]
  |  Branch (4140:83): [True: 0, False: 0]
  ------------------
 4141|      0|                    want_inhibit = true;
 4142|       |
 4143|       |                // Inhibit hover unless the window is within the stack of our modal/popup
 4144|      0|                if (want_inhibit)
  ------------------
  |  Branch (4144:21): [True: 0, False: 0]
  ------------------
 4145|      0|                    if (!IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))
  ------------------
  |  Branch (4145:25): [True: 0, False: 0]
  ------------------
 4146|      0|                        return false;
 4147|      0|            }
 4148|       |
 4149|       |    // Filter by viewport
 4150|    164|    if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (4150:9): [True: 0, False: 164]
  ------------------
 4151|      0|        if (g.MovingWindow == NULL || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree)
  ------------------
  |  Branch (4151:13): [True: 0, False: 0]
  |  Branch (4151:39): [True: 0, False: 0]
  ------------------
 4152|      0|            return false;
 4153|       |
 4154|    164|    return true;
 4155|    164|}
_ZN5ImGui13ItemHoverableERK6ImRectji:
 4275|   262k|{
 4276|   262k|    ImGuiContext& g = *GImGui;
 4277|   262k|    ImGuiWindow* window = g.CurrentWindow;
 4278|   262k|    if (g.HoveredWindow != window)
  ------------------
  |  Branch (4278:9): [True: 259k, False: 3.65k]
  ------------------
 4279|   259k|        return false;
 4280|  3.65k|    if (!IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (4280:9): [True: 3.50k, False: 144]
  ------------------
 4281|  3.50k|        return false;
 4282|       |
 4283|    144|    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
  ------------------
  |  Branch (4283:9): [True: 0, False: 144]
  |  Branch (4283:29): [True: 0, False: 0]
  |  Branch (4283:50): [True: 0, False: 0]
  ------------------
 4284|      0|        return false;
 4285|    144|    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (4285:9): [True: 11, False: 133]
  |  Branch (4285:28): [True: 10, False: 1]
  |  Branch (4285:48): [True: 10, False: 0]
  ------------------
 4286|     10|        if (!g.ActiveIdFromShortcut)
  ------------------
  |  Branch (4286:13): [True: 10, False: 0]
  ------------------
 4287|     10|            return false;
 4288|       |
 4289|       |    // Done with rectangle culling so we can perform heavier checks now.
 4290|    134|    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
  ------------------
  |  Branch (4290:9): [True: 134, False: 0]
  |  Branch (4290:66): [True: 0, False: 134]
  ------------------
 4291|      0|    {
 4292|      0|        g.HoveredIdIsDisabled = true;
 4293|      0|        return false;
 4294|      0|    }
 4295|       |
 4296|       |    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
 4297|       |    // hover test in widgets code. We could also decide to split this function is two.
 4298|    134|    if (id != 0)
  ------------------
  |  Branch (4298:9): [True: 134, False: 0]
  ------------------
 4299|    134|    {
 4300|       |        // Drag source doesn't report as hovered
 4301|    134|        if (g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
  ------------------
  |  Branch (4301:13): [True: 0, False: 134]
  |  Branch (4301:33): [True: 0, False: 0]
  |  Branch (4301:69): [True: 0, False: 0]
  ------------------
 4302|      0|            return false;
 4303|       |
 4304|    134|        SetHoveredID(id);
 4305|       |
 4306|       |        // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
 4307|       |        // This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
 4308|    134|        if (item_flags & ImGuiItemFlags_AllowOverlap)
  ------------------
  |  Branch (4308:13): [True: 0, False: 134]
  ------------------
 4309|      0|        {
 4310|      0|            g.HoveredIdAllowOverlap = true;
 4311|      0|            if (g.HoveredIdPreviousFrame != id)
  ------------------
  |  Branch (4311:17): [True: 0, False: 0]
  ------------------
 4312|      0|                return false;
 4313|      0|        }
 4314|       |
 4315|       |        // Display shortcut (only works with mouse)
 4316|       |        // (ImGuiItemStatusFlags_HasShortcut in LastItemData denotes we want a tooltip)
 4317|    134|        if (id == g.LastItemData.ID && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut))
  ------------------
  |  Branch (4317:13): [True: 134, False: 0]
  |  Branch (4317:40): [True: 0, False: 134]
  ------------------
 4318|      0|            if (IsItemHovered(ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal))
  ------------------
  |  Branch (4318:17): [True: 0, False: 0]
  ------------------
 4319|      0|                SetTooltip("%s", GetKeyChordName(g.LastItemData.Shortcut));
 4320|    134|    }
 4321|       |
 4322|       |    // When disabled we'll return false but still set HoveredId
 4323|    134|    if (item_flags & ImGuiItemFlags_Disabled)
  ------------------
  |  Branch (4323:9): [True: 0, False: 134]
  ------------------
 4324|      0|    {
 4325|       |        // Release active id if turning disabled
 4326|      0|        if (g.ActiveId == id && id != 0)
  ------------------
  |  Branch (4326:13): [True: 0, False: 0]
  |  Branch (4326:33): [True: 0, False: 0]
  ------------------
 4327|      0|            ClearActiveID();
 4328|      0|        g.HoveredIdIsDisabled = true;
 4329|      0|        return false;
 4330|      0|    }
 4331|       |
 4332|    134|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 4333|    134|    if (id != 0)
  ------------------
  |  Branch (4333:9): [True: 134, False: 0]
  ------------------
 4334|    134|    {
 4335|       |        // [DEBUG] Item Picker tool!
 4336|       |        // We perform the check here because reaching is path is rare (1~ time a frame),
 4337|       |        // making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
 4338|       |        // items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
 4339|    134|        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
  ------------------
  |  Branch (4339:13): [True: 0, False: 134]
  |  Branch (4339:40): [True: 0, False: 0]
  ------------------
 4340|      0|            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
  ------------------
  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 4341|    134|        if (g.DebugItemPickerBreakId == id)
  ------------------
  |  Branch (4341:13): [True: 0, False: 134]
  ------------------
 4342|      0|            IM_DEBUG_BREAK();
  ------------------
  |  |  316|      0|#define IM_DEBUG_BREAK()    __builtin_debugtrap()
  ------------------
 4343|    134|    }
 4344|    134|#endif
 4345|       |
 4346|    134|    if (g.NavDisableMouseHover)
  ------------------
  |  Branch (4346:9): [True: 0, False: 134]
  ------------------
 4347|      0|        return false;
 4348|       |
 4349|    134|    return true;
 4350|    134|}
_ZN5ImGui15SetLastItemDataEjiiRK6ImRect:
 4368|   170k|{
 4369|   170k|    ImGuiContext& g = *GImGui;
 4370|   170k|    g.LastItemData.ID = item_id;
 4371|   170k|    g.LastItemData.InFlags = in_flags;
 4372|   170k|    g.LastItemData.StatusFlags = item_flags;
 4373|   170k|    g.LastItemData.Rect = g.LastItemData.NavRect = item_rect;
 4374|   170k|}
_ZN5ImGui8MemAllocEm:
 4402|  1.22k|{
 4403|  1.22k|    void* ptr = (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
 4404|  1.22k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 4405|  1.22k|    if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4405:23): [True: 1.22k, False: 2]
  ------------------
 4406|  1.22k|        DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, size);
 4407|  1.22k|#endif
 4408|  1.22k|    return ptr;
 4409|  1.22k|}
_ZN5ImGui7MemFreeEPv:
 4413|  1.18k|{
 4414|  1.18k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 4415|  1.18k|    if (ptr != NULL)
  ------------------
  |  Branch (4415:9): [True: 1.17k, False: 9]
  ------------------
 4416|  1.17k|        if (ImGuiContext* ctx = GImGui)
  ------------------
  |  Branch (4416:27): [True: 1.17k, False: 0]
  ------------------
 4417|  1.17k|            DebugAllocHook(&ctx->DebugAllocInfo, ctx->FrameCount, ptr, (size_t)-1);
 4418|  1.18k|#endif
 4419|  1.18k|    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
 4420|  1.18k|}
_ZN5ImGui14DebugAllocHookEP19ImGuiDebugAllocInfoiPvm:
 4424|  2.39k|{
 4425|  2.39k|    ImGuiDebugAllocEntry* entry = &info->LastEntriesBuf[info->LastEntriesIdx];
 4426|  2.39k|    IM_UNUSED(ptr);
  ------------------
  |  |   94|  2.39k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 4427|  2.39k|    if (entry->FrameCount != frame_count)
  ------------------
  |  Branch (4427:9): [True: 37, False: 2.36k]
  ------------------
 4428|     37|    {
 4429|     37|        info->LastEntriesIdx = (info->LastEntriesIdx + 1) % IM_ARRAYSIZE(info->LastEntriesBuf);
  ------------------
  |  |   93|     37|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4430|     37|        entry = &info->LastEntriesBuf[info->LastEntriesIdx];
 4431|     37|        entry->FrameCount = frame_count;
 4432|     37|        entry->AllocCount = entry->FreeCount = 0;
 4433|     37|    }
 4434|  2.39k|    if (size != (size_t)-1)
  ------------------
  |  Branch (4434:9): [True: 1.22k, False: 1.17k]
  ------------------
 4435|  1.22k|    {
 4436|  1.22k|        entry->AllocCount++;
 4437|  1.22k|        info->TotalAllocCount++;
 4438|       |        //printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, size, ptr);
 4439|  1.22k|    }
 4440|  1.17k|    else
 4441|  1.17k|    {
 4442|  1.17k|        entry->FreeCount++;
 4443|  1.17k|        info->TotalFreeCount++;
 4444|       |        //printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
 4445|  1.17k|    }
 4446|  2.39k|}
_ZN5ImGui5GetIOEv:
 4467|   219k|{
 4468|   219k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|   219k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4469|   219k|    return GImGui->IO;
 4470|   219k|}
_ZN5ImGui11GetDrawDataEv:
 4480|  76.6k|{
 4481|  76.6k|    ImGuiContext& g = *GImGui;
 4482|  76.6k|    ImGuiViewportP* viewport = g.Viewports[0];
 4483|  76.6k|    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : NULL;
  ------------------
  |  Branch (4483:12): [True: 76.6k, False: 0]
  ------------------
 4484|  76.6k|}
_ZN5ImGui7GetTimeEv:
 4487|     30|{
 4488|     30|    return GImGui->Time;
 4489|     30|}
_ZN5ImGui22StartMouseMovingWindowEP11ImGuiWindow:
 4540|     32|{
 4541|       |    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
 4542|       |    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
 4543|       |    // This is because we want ActiveId to be set even when the window is not permitted to move.
 4544|     32|    ImGuiContext& g = *GImGui;
 4545|     32|    FocusWindow(window);
 4546|     32|    SetActiveID(window->MoveId, window);
 4547|     32|    g.NavDisableHighlight = true;
 4548|     32|    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindowDockTree->Pos;
 4549|     32|    g.ActiveIdNoClearOnFocusLoss = true;
 4550|     32|    SetActiveIdUsingAllKeyboardKeys();
 4551|       |
 4552|     32|    bool can_move_window = true;
 4553|     32|    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4553:9): [True: 0, False: 32]
  |  Branch (4553:54): [True: 0, False: 32]
  ------------------
 4554|      0|        can_move_window = false;
 4555|     32|    if (ImGuiDockNode* node = window->DockNodeAsHost)
  ------------------
  |  Branch (4555:24): [True: 0, False: 32]
  ------------------
 4556|      0|        if (node->VisibleWindow && (node->VisibleWindow->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (4556:13): [True: 0, False: 0]
  |  Branch (4556:36): [True: 0, False: 0]
  ------------------
 4557|      0|            can_move_window = false;
 4558|     32|    if (can_move_window)
  ------------------
  |  Branch (4558:9): [True: 32, False: 0]
  ------------------
 4559|     32|        g.MovingWindow = window;
 4560|     32|}
_ZN5ImGui31UpdateMouseMovingWindowNewFrameEv:
 4591|  76.6k|{
 4592|  76.6k|    ImGuiContext& g = *GImGui;
 4593|  76.6k|    if (g.MovingWindow != NULL)
  ------------------
  |  Branch (4593:9): [True: 562, False: 76.1k]
  ------------------
 4594|    562|    {
 4595|       |        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
 4596|       |        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
 4597|    562|        KeepAliveID(g.ActiveId);
 4598|    562|        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindowDockTree);
  ------------------
  |  |   23|    562|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4599|    562|        ImGuiWindow* moving_window = g.MovingWindow->RootWindowDockTree;
 4600|       |
 4601|       |        // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
 4602|    562|        const bool window_disappared = (!moving_window->WasActive && !moving_window->Active);
  ------------------
  |  Branch (4602:41): [True: 0, False: 562]
  |  Branch (4602:70): [True: 0, False: 0]
  ------------------
 4603|    562|        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared)
  ------------------
  |  Branch (4603:13): [True: 530, False: 32]
  |  Branch (4603:34): [True: 530, False: 0]
  |  Branch (4603:69): [True: 530, False: 0]
  ------------------
 4604|    530|        {
 4605|    530|            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
 4606|    530|            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
  ------------------
  |  Branch (4606:17): [True: 255, False: 275]
  |  Branch (4606:50): [True: 5, False: 270]
  ------------------
 4607|    260|            {
 4608|    260|                SetWindowPos(moving_window, pos, ImGuiCond_Always);
 4609|    260|                if (moving_window->Viewport && moving_window->ViewportOwned) // Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
  ------------------
  |  Branch (4609:21): [True: 260, False: 0]
  |  Branch (4609:48): [True: 0, False: 260]
  ------------------
 4610|      0|                {
 4611|      0|                    moving_window->Viewport->Pos = pos;
 4612|      0|                    moving_window->Viewport->UpdateWorkRect();
 4613|      0|                }
 4614|    260|            }
 4615|    530|            FocusWindow(g.MovingWindow);
 4616|    530|        }
 4617|     32|        else
 4618|     32|        {
 4619|     32|            if (!window_disappared)
  ------------------
  |  Branch (4619:17): [True: 32, False: 0]
  ------------------
 4620|     32|            {
 4621|       |                // Try to merge the window back into the main viewport.
 4622|       |                // This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
 4623|     32|                if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (4623:21): [True: 0, False: 32]
  ------------------
 4624|      0|                    UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport);
 4625|       |
 4626|       |                // Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
 4627|     32|                if (moving_window->Viewport && !IsDragDropPayloadBeingAccepted())
  ------------------
  |  Branch (4627:21): [True: 32, False: 0]
  |  Branch (4627:48): [True: 32, False: 0]
  ------------------
 4628|     32|                    g.MouseViewport = moving_window->Viewport;
 4629|       |
 4630|       |                // Clear the NoInput window flag set by the Viewport system
 4631|     32|                if (moving_window->Viewport)
  ------------------
  |  Branch (4631:21): [True: 32, False: 0]
  ------------------
 4632|     32|                    moving_window->Viewport->Flags &= ~ImGuiViewportFlags_NoInputs;
 4633|     32|            }
 4634|       |
 4635|     32|            g.MovingWindow = NULL;
 4636|     32|            ClearActiveID();
 4637|     32|        }
 4638|    562|    }
 4639|  76.1k|    else
 4640|  76.1k|    {
 4641|       |        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
 4642|  76.1k|        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
  ------------------
  |  Branch (4642:13): [True: 5, False: 76.1k]
  |  Branch (4642:33): [True: 0, False: 5]
  ------------------
 4643|      0|        {
 4644|      0|            KeepAliveID(g.ActiveId);
 4645|      0|            if (!g.IO.MouseDown[0])
  ------------------
  |  Branch (4645:17): [True: 0, False: 0]
  ------------------
 4646|      0|                ClearActiveID();
 4647|      0|        }
 4648|  76.1k|    }
 4649|  76.6k|}
_ZN5ImGui31UpdateMouseMovingWindowEndFrameEv:
 4654|  76.6k|{
 4655|  76.6k|    ImGuiContext& g = *GImGui;
 4656|  76.6k|    if (g.ActiveId != 0 || g.HoveredId != 0)
  ------------------
  |  Branch (4656:9): [True: 552, False: 76.1k]
  |  Branch (4656:28): [True: 130, False: 76.0k]
  ------------------
 4657|    682|        return;
 4658|       |
 4659|       |    // Unless we just made a window/popup appear
 4660|  76.0k|    if (g.NavWindow && g.NavWindow->Appearing)
  ------------------
  |  Branch (4660:9): [True: 9.92k, False: 66.0k]
  |  Branch (4660:24): [True: 2, False: 9.92k]
  ------------------
 4661|      2|        return;
 4662|       |
 4663|       |    // Click on empty space to focus window and start moving
 4664|       |    // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
 4665|  76.0k|    if (g.IO.MouseClicked[0])
  ------------------
  |  Branch (4665:9): [True: 2.79k, False: 73.2k]
  ------------------
 4666|  2.79k|    {
 4667|       |        // Handle the edge case of a popup being closed while clicking in its empty space.
 4668|       |        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
 4669|  2.79k|        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;
  ------------------
  |  Branch (4669:36): [True: 32, False: 2.76k]
  ------------------
 4670|  2.79k|        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);
  ------------------
  |  Branch (4670:38): [True: 32, False: 2.76k]
  |  Branch (4670:53): [True: 0, False: 32]
  |  Branch (4670:102): [True: 0, False: 0]
  ------------------
 4671|       |
 4672|  2.79k|        if (root_window != NULL && !is_closed_popup)
  ------------------
  |  Branch (4672:13): [True: 32, False: 2.76k]
  |  Branch (4672:36): [True: 32, False: 0]
  ------------------
 4673|     32|        {
 4674|     32|            StartMouseMovingWindow(g.HoveredWindow); //-V595
 4675|       |
 4676|       |            // Cancel moving if clicked outside of title bar
 4677|     32|            if (g.IO.ConfigWindowsMoveFromTitleBarOnly)
  ------------------
  |  Branch (4677:17): [True: 0, False: 32]
  ------------------
 4678|      0|                if (!(root_window->Flags & ImGuiWindowFlags_NoTitleBar) || root_window->DockIsActive)
  ------------------
  |  Branch (4678:21): [True: 0, False: 0]
  |  Branch (4678:76): [True: 0, False: 0]
  ------------------
 4679|      0|                    if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
  ------------------
  |  Branch (4679:25): [True: 0, False: 0]
  ------------------
 4680|      0|                        g.MovingWindow = NULL;
 4681|       |
 4682|       |            // Cancel moving if clicked over an item which was disabled or inhibited by popups (note that we know HoveredId == 0 already)
 4683|     32|            if (g.HoveredIdIsDisabled)
  ------------------
  |  Branch (4683:17): [True: 0, False: 32]
  ------------------
 4684|      0|                g.MovingWindow = NULL;
 4685|     32|        }
 4686|  2.76k|        else if (root_window == NULL && g.NavWindow != NULL)
  ------------------
  |  Branch (4686:18): [True: 2.76k, False: 0]
  |  Branch (4686:41): [True: 78, False: 2.68k]
  ------------------
 4687|     78|        {
 4688|       |            // Clicking on void disable focus
 4689|     78|            FocusWindow(NULL, ImGuiFocusRequestFlags_UnlessBelowModal);
 4690|     78|        }
 4691|  2.79k|    }
 4692|       |
 4693|       |    // With right mouse button we close popups without changing focus based on where the mouse is aimed
 4694|       |    // Instead, focus will be restored to the window under the bottom-most closed popup.
 4695|       |    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
 4696|  76.0k|    if (g.IO.MouseClicked[1])
  ------------------
  |  Branch (4696:9): [True: 328, False: 75.6k]
  ------------------
 4697|    328|    {
 4698|       |        // Find the top-most window between HoveredWindow and the top-most Modal Window.
 4699|       |        // This is where we can trim the popup stack.
 4700|    328|        ImGuiWindow* modal = GetTopMostPopupModal();
 4701|    328|        bool hovered_window_above_modal = g.HoveredWindow && (modal == NULL || IsWindowAbove(g.HoveredWindow, modal));
  ------------------
  |  Branch (4701:43): [True: 4, False: 324]
  |  Branch (4701:63): [True: 4, False: 0]
  |  Branch (4701:80): [True: 0, False: 0]
  ------------------
 4702|    328|        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
  ------------------
  |  Branch (4702:31): [True: 4, False: 324]
  ------------------
 4703|    328|    }
 4704|  76.0k|}
_ZN5ImGui34UpdateHoveredWindowAndCaptureFlagsEv:
 4736|  76.6k|{
 4737|  76.6k|    ImGuiContext& g = *GImGui;
 4738|  76.6k|    ImGuiIO& io = g.IO;
 4739|       |
 4740|       |    // FIXME-DPI: This storage was added on 2021/03/31 for test engine, but if we want to multiply WINDOWS_HOVER_PADDING
 4741|       |    // by DpiScale, we need to make this window-agnostic anyhow, maybe need storing inside ImGuiWindow.
 4742|  76.6k|    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));
 4743|       |
 4744|       |    // Find the window hovered by mouse:
 4745|       |    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
 4746|       |    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
 4747|       |    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
 4748|  76.6k|    bool clear_hovered_windows = false;
 4749|  76.6k|    FindHoveredWindowEx(g.IO.MousePos, false, &g.HoveredWindow, &g.HoveredWindowUnderMovingWindow);
 4750|  76.6k|    IM_ASSERT(g.HoveredWindow == NULL || g.HoveredWindow == g.MovingWindow || g.HoveredWindow->Viewport == g.MouseViewport);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4751|  76.6k|    g.HoveredWindowBeforeClear = g.HoveredWindow;
 4752|       |
 4753|       |    // Modal windows prevents mouse from hovering behind them.
 4754|  76.6k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
 4755|  76.6k|    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window)) // FIXME-MERGE: RootWindowDockTree ?
  ------------------
  |  Branch (4755:9): [True: 0, False: 76.6k]
  |  Branch (4755:25): [True: 0, False: 0]
  |  Branch (4755:44): [True: 0, False: 0]
  ------------------
 4756|      0|        clear_hovered_windows = true;
 4757|       |
 4758|       |    // Disabled mouse hovering (we don't currently clear MousePos, we could)
 4759|  76.6k|    if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
  ------------------
  |  Branch (4759:9): [True: 0, False: 76.6k]
  ------------------
 4760|      0|        clear_hovered_windows = true;
 4761|       |
 4762|       |    // We track click ownership. When clicked outside of a window the click is owned by the application and
 4763|       |    // won't report hovering nor request capture even while dragging over our windows afterward.
 4764|  76.6k|    const bool has_open_popup = (g.OpenPopupStack.Size > 0);
 4765|  76.6k|    const bool has_open_modal = (modal_window != NULL);
 4766|  76.6k|    int mouse_earliest_down = -1;
 4767|  76.6k|    bool mouse_any_down = false;
 4768|   460k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   93|   460k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (4768:21): [True: 383k, False: 76.6k]
  ------------------
 4769|   383k|    {
 4770|   383k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (4770:13): [True: 3.88k, False: 379k]
  ------------------
 4771|  3.88k|        {
 4772|  3.88k|            io.MouseDownOwned[i] = (g.HoveredWindow != NULL) || has_open_popup;
  ------------------
  |  Branch (4772:36): [True: 305, False: 3.58k]
  |  Branch (4772:65): [True: 0, False: 3.58k]
  ------------------
 4773|  3.88k|            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != NULL) || has_open_modal;
  ------------------
  |  Branch (4773:52): [True: 305, False: 3.58k]
  |  Branch (4773:81): [True: 0, False: 3.58k]
  ------------------
 4774|  3.88k|        }
 4775|   383k|        mouse_any_down |= io.MouseDown[i];
 4776|   383k|        if (io.MouseDown[i])
  ------------------
  |  Branch (4776:13): [True: 119k, False: 263k]
  ------------------
 4777|   119k|            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
  ------------------
  |  Branch (4777:17): [True: 60.2k, False: 59.4k]
  |  Branch (4777:46): [True: 38.4k, False: 20.9k]
  ------------------
 4778|  98.7k|                mouse_earliest_down = i;
 4779|   383k|    }
 4780|  76.6k|    const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
  ------------------
  |  Branch (4780:30): [True: 16.4k, False: 60.2k]
  |  Branch (4780:61): [True: 1.98k, False: 58.2k]
  ------------------
 4781|  76.6k|    const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];
  ------------------
  |  Branch (4781:49): [True: 16.4k, False: 60.2k]
  |  Branch (4781:80): [True: 1.98k, False: 58.2k]
  ------------------
 4782|       |
 4783|       |    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
 4784|       |    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
 4785|  76.6k|    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
  ------------------
  |  Branch (4785:48): [True: 160, False: 76.5k]
  |  Branch (4785:68): [True: 0, False: 160]
  ------------------
 4786|  76.6k|    if (!mouse_avail && !mouse_dragging_extern_payload)
  ------------------
  |  Branch (4786:9): [True: 58.2k, False: 18.4k]
  |  Branch (4786:25): [True: 58.2k, False: 0]
  ------------------
 4787|  58.2k|        clear_hovered_windows = true;
 4788|       |
 4789|  76.6k|    if (clear_hovered_windows)
  ------------------
  |  Branch (4789:9): [True: 58.2k, False: 18.4k]
  ------------------
 4790|  58.2k|        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = NULL;
 4791|       |
 4792|       |    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
 4793|       |    // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
 4794|  76.6k|    if (g.WantCaptureMouseNextFrame != -1)
  ------------------
  |  Branch (4794:9): [True: 0, False: 76.6k]
  ------------------
 4795|      0|    {
 4796|      0|        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
 4797|      0|    }
 4798|  76.6k|    else
 4799|  76.6k|    {
 4800|  76.6k|        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_popup;
  ------------------
  |  Branch (4800:32): [True: 18.4k, False: 58.2k]
  |  Branch (4800:48): [True: 955, False: 17.4k]
  |  Branch (4800:75): [True: 1.20k, False: 16.2k]
  |  Branch (4800:95): [True: 0, False: 74.5k]
  ------------------
 4801|  76.6k|        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != NULL || mouse_any_down)) || has_open_modal;
  ------------------
  |  Branch (4801:48): [True: 18.4k, False: 58.2k]
  |  Branch (4801:83): [True: 955, False: 17.4k]
  |  Branch (4801:110): [True: 1.20k, False: 16.2k]
  |  Branch (4801:130): [True: 0, False: 74.5k]
  ------------------
 4802|  76.6k|    }
 4803|       |
 4804|       |    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
 4805|  76.6k|    io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
  ------------------
  |  Branch (4805:30): [True: 567, False: 76.1k]
  |  Branch (4805:51): [True: 0, False: 76.1k]
  ------------------
 4806|  76.6k|    if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
  ------------------
  |  Branch (4806:9): [True: 7.51k, False: 69.1k]
  |  Branch (4806:25): [True: 7.51k, False: 0]
  |  Branch (4806:82): [True: 7.51k, False: 0]
  ------------------
 4807|  7.51k|        io.WantCaptureKeyboard = true;
 4808|  76.6k|    if (g.WantCaptureKeyboardNextFrame != -1) // Manual override
  ------------------
  |  Branch (4808:9): [True: 0, False: 76.6k]
  ------------------
 4809|      0|        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
 4810|       |
 4811|       |    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
 4812|  76.6k|    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
  ------------------
  |  Branch (4812:24): [True: 0, False: 76.6k]
  ------------------
 4813|  76.6k|}
_ZN5ImGui8NewFrameEv:
 4837|  76.6k|{
 4838|  76.6k|    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4839|  76.6k|    ImGuiContext& g = *GImGui;
 4840|       |
 4841|       |    // Remove pending delete hooks before frame start.
 4842|       |    // This deferred removal avoid issues of removal while iterating the hook vector
 4843|  76.6k|    for (int n = g.Hooks.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (4843:36): [True: 0, False: 76.6k]
  ------------------
 4844|      0|        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
  ------------------
  |  Branch (4844:13): [True: 0, False: 0]
  ------------------
 4845|      0|            g.Hooks.erase(&g.Hooks[n]);
 4846|       |
 4847|  76.6k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);
 4848|       |
 4849|       |    // Check and assert for various common IO and Configuration mistakes
 4850|  76.6k|    g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
 4851|  76.6k|    ErrorCheckNewFrameSanityChecks();
 4852|  76.6k|    g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;
 4853|       |
 4854|       |    // Load settings on first frame, save settings when modified (after a delay)
 4855|  76.6k|    UpdateSettings();
 4856|       |
 4857|  76.6k|    g.Time += g.IO.DeltaTime;
 4858|  76.6k|    g.WithinFrameScope = true;
 4859|  76.6k|    g.FrameCount += 1;
 4860|  76.6k|    g.TooltipOverrideCount = 0;
 4861|  76.6k|    g.WindowsActiveCount = 0;
 4862|  76.6k|    g.MenusIdSubmittedThisFrame.resize(0);
 4863|       |
 4864|       |    // Calculate frame-rate for the user, as a purely luxurious feature
 4865|  76.6k|    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
 4866|  76.6k|    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
 4867|  76.6k|    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
  ------------------
  |  |   93|  76.6k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4868|  76.6k|    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame));
  ------------------
  |  |   93|  76.6k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 4869|  76.6k|    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : FLT_MAX;
  ------------------
  |  Branch (4869:22): [True: 76.6k, False: 0]
  ------------------
 4870|       |
 4871|       |    // Process input queue (trickle as many events as possible), turn events into writes to IO structure
 4872|  76.6k|    g.InputEventsTrail.resize(0);
 4873|  76.6k|    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);
 4874|       |
 4875|       |    // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
 4876|  76.6k|    UpdateViewportsNewFrame();
 4877|       |
 4878|       |    // Setup current font and draw list shared data
 4879|       |    // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
 4880|  76.6k|    g.IO.Fonts->Locked = true;
 4881|  76.6k|    SetupDrawListSharedData();
 4882|  76.6k|    SetCurrentFont(GetDefaultFont());
 4883|  76.6k|    IM_ASSERT(g.Font->IsLoaded());
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4884|       |
 4885|       |    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
 4886|  76.6k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (4886:35): [True: 76.6k, False: 76.6k]
  ------------------
 4887|  76.6k|    {
 4888|  76.6k|        viewport->DrawData = NULL;
 4889|  76.6k|        viewport->DrawDataP.Valid = false;
 4890|  76.6k|    }
 4891|       |
 4892|       |    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
 4893|  76.6k|    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
  ------------------
  |  Branch (4893:9): [True: 160, False: 76.5k]
  |  Branch (4893:29): [True: 158, False: 2]
  ------------------
 4894|    158|        KeepAliveID(g.DragDropPayload.SourceId);
 4895|       |
 4896|       |    // Update HoveredId data
 4897|  76.6k|    if (!g.HoveredIdPreviousFrame)
  ------------------
  |  Branch (4897:9): [True: 76.5k, False: 134]
  ------------------
 4898|  76.5k|        g.HoveredIdTimer = 0.0f;
 4899|  76.6k|    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
  ------------------
  |  Branch (4899:9): [True: 76.5k, False: 134]
  |  Branch (4899:39): [True: 120, False: 14]
  |  Branch (4899:54): [True: 0, False: 120]
  ------------------
 4900|  76.5k|        g.HoveredIdNotActiveTimer = 0.0f;
 4901|  76.6k|    if (g.HoveredId)
  ------------------
  |  Branch (4901:9): [True: 134, False: 76.5k]
  ------------------
 4902|    134|        g.HoveredIdTimer += g.IO.DeltaTime;
 4903|  76.6k|    if (g.HoveredId && g.ActiveId != g.HoveredId)
  ------------------
  |  Branch (4903:9): [True: 134, False: 76.5k]
  |  Branch (4903:24): [True: 133, False: 1]
  ------------------
 4904|    133|        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
 4905|  76.6k|    g.HoveredIdPreviousFrame = g.HoveredId;
 4906|  76.6k|    g.HoveredId = 0;
 4907|  76.6k|    g.HoveredIdAllowOverlap = false;
 4908|  76.6k|    g.HoveredIdIsDisabled = false;
 4909|       |
 4910|       |    // Clear ActiveID if the item is not alive anymore.
 4911|       |    // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
 4912|       |    // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
 4913|  76.6k|    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
  ------------------
  |  Branch (4913:9): [True: 568, False: 76.1k]
  |  Branch (4913:28): [True: 0, False: 568]
  |  Branch (4913:63): [True: 0, False: 0]
  ------------------
 4914|      0|    {
 4915|      0|        IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
  ------------------
  |  |  245|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (245:50): [True: 0, False: 0]
  |  |  |  Branch (245:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4916|      0|        ClearActiveID();
 4917|      0|    }
 4918|       |
 4919|       |    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
 4920|  76.6k|    if (g.ActiveId)
  ------------------
  |  Branch (4920:9): [True: 568, False: 76.1k]
  ------------------
 4921|    568|        g.ActiveIdTimer += g.IO.DeltaTime;
 4922|  76.6k|    g.LastActiveIdTimer += g.IO.DeltaTime;
 4923|  76.6k|    g.ActiveIdPreviousFrame = g.ActiveId;
 4924|  76.6k|    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
 4925|  76.6k|    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
 4926|  76.6k|    g.ActiveIdIsAlive = 0;
 4927|  76.6k|    g.ActiveIdHasBeenEditedThisFrame = false;
 4928|  76.6k|    g.ActiveIdPreviousFrameIsAlive = false;
 4929|  76.6k|    g.ActiveIdIsJustActivated = false;
 4930|  76.6k|    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
  ------------------
  |  Branch (4930:9): [True: 0, False: 76.6k]
  |  Branch (4930:31): [True: 0, False: 0]
  ------------------
 4931|      0|        g.TempInputId = 0;
 4932|  76.6k|    if (g.ActiveId == 0)
  ------------------
  |  Branch (4932:9): [True: 76.1k, False: 568]
  ------------------
 4933|  76.1k|    {
 4934|  76.1k|        g.ActiveIdUsingNavDirMask = 0x00;
 4935|  76.1k|        g.ActiveIdUsingAllKeyboardKeys = false;
 4936|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4937|       |        g.ActiveIdUsingNavInputMask = 0x00;
 4938|       |#endif
 4939|  76.1k|    }
 4940|       |
 4941|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 4942|       |    if (g.ActiveId == 0)
 4943|       |        g.ActiveIdUsingNavInputMask = 0;
 4944|       |    else if (g.ActiveIdUsingNavInputMask != 0)
 4945|       |    {
 4946|       |        // If your custom widget code used:                 { g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel); }
 4947|       |        // Since IMGUI_VERSION_NUM >= 18804 it should be:   { SetKeyOwner(ImGuiKey_Escape, g.ActiveId); SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId); }
 4948|       |        if (g.ActiveIdUsingNavInputMask & (1 << ImGuiNavInput_Cancel))
 4949|       |            SetKeyOwner(ImGuiKey_Escape, g.ActiveId);
 4950|       |        if (g.ActiveIdUsingNavInputMask & ~(1 << ImGuiNavInput_Cancel))
 4951|       |            IM_ASSERT(0); // Other values unsupported
 4952|       |    }
 4953|       |#endif
 4954|       |
 4955|       |    // Record when we have been stationary as this state is preserved while over same item.
 4956|       |    // FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
 4957|       |    // To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
 4958|  76.6k|    if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
  ------------------
  |  Branch (4958:9): [True: 0, False: 76.6k]
  |  Branch (4958:36): [True: 0, False: 0]
  ------------------
 4959|      0|        g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
 4960|  76.6k|    else if (g.HoverItemDelayId == 0)
  ------------------
  |  Branch (4960:14): [True: 76.6k, False: 0]
  ------------------
 4961|  76.6k|        g.HoverItemUnlockedStationaryId = 0;
 4962|  76.6k|    if (g.HoveredWindow != NULL && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay)
  ------------------
  |  Branch (4962:9): [True: 955, False: 75.7k]
  |  Branch (4962:36): [True: 743, False: 212]
  ------------------
 4963|    743|        g.HoverWindowUnlockedStationaryId = g.HoveredWindow->ID;
 4964|  75.9k|    else if (g.HoveredWindow == NULL)
  ------------------
  |  Branch (4964:14): [True: 75.7k, False: 212]
  ------------------
 4965|  75.7k|        g.HoverWindowUnlockedStationaryId = 0;
 4966|       |
 4967|       |    // Update hover delay for IsItemHovered() with delays and tooltips
 4968|  76.6k|    g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
 4969|  76.6k|    if (g.HoverItemDelayId != 0)
  ------------------
  |  Branch (4969:9): [True: 0, False: 76.6k]
  ------------------
 4970|      0|    {
 4971|      0|        g.HoverItemDelayTimer += g.IO.DeltaTime;
 4972|      0|        g.HoverItemDelayClearTimer = 0.0f;
 4973|      0|        g.HoverItemDelayId = 0;
 4974|      0|    }
 4975|  76.6k|    else if (g.HoverItemDelayTimer > 0.0f)
  ------------------
  |  Branch (4975:14): [True: 0, False: 76.6k]
  ------------------
 4976|      0|    {
 4977|       |        // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
 4978|       |        // We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
 4979|      0|        g.HoverItemDelayClearTimer += g.IO.DeltaTime;
 4980|      0|        if (g.HoverItemDelayClearTimer >= ImMax(0.25f, g.IO.DeltaTime * 2.0f)) // ~7 frames at 30 Hz + allow for low framerate
  ------------------
  |  Branch (4980:13): [True: 0, False: 0]
  ------------------
 4981|      0|            g.HoverItemDelayTimer = g.HoverItemDelayClearTimer = 0.0f; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
 4982|      0|    }
 4983|       |
 4984|       |    // Drag and drop
 4985|  76.6k|    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
 4986|  76.6k|    g.DragDropAcceptIdCurr = 0;
 4987|  76.6k|    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
 4988|  76.6k|    g.DragDropWithinSource = false;
 4989|  76.6k|    g.DragDropWithinTarget = false;
 4990|  76.6k|    g.DragDropHoldJustPressedId = 0;
 4991|       |
 4992|       |    // Close popups on focus lost (currently wip/opt-in)
 4993|       |    //if (g.IO.AppFocusLost)
 4994|       |    //    ClosePopupsExceptModals();
 4995|       |
 4996|       |    // Update keyboard input state
 4997|  76.6k|    UpdateKeyboardInputs();
 4998|       |
 4999|       |    //IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
 5000|       |    //IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
 5001|       |    //IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
 5002|       |    //IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));
 5003|       |
 5004|       |    // Update gamepad/keyboard navigation
 5005|  76.6k|    NavUpdate();
 5006|       |
 5007|       |    // Update mouse input state
 5008|  76.6k|    UpdateMouseInputs();
 5009|       |
 5010|       |    // Undocking
 5011|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
 5012|  76.6k|    DockContextNewFrameUpdateUndocking(&g);
 5013|       |
 5014|       |    // Find hovered window
 5015|       |    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
 5016|  76.6k|    UpdateHoveredWindowAndCaptureFlags();
 5017|       |
 5018|       |    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
 5019|  76.6k|    UpdateMouseMovingWindowNewFrame();
 5020|       |
 5021|       |    // Background darkening/whitening
 5022|  76.6k|    if (GetTopMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
  ------------------
  |  Branch (5022:9): [True: 0, False: 76.6k]
  |  Branch (5022:44): [True: 0, False: 76.6k]
  |  Branch (5022:76): [True: 0, False: 0]
  ------------------
 5023|      0|        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
 5024|  76.6k|    else
 5025|  76.6k|        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);
 5026|       |
 5027|  76.6k|    g.MouseCursor = ImGuiMouseCursor_Arrow;
 5028|  76.6k|    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
 5029|       |
 5030|       |    // Platform IME data: reset for the frame
 5031|  76.6k|    g.PlatformImeDataPrev = g.PlatformImeData;
 5032|  76.6k|    g.PlatformImeData.WantVisible = false;
 5033|       |
 5034|       |    // Mouse wheel scrolling, scale
 5035|  76.6k|    UpdateMouseWheel();
 5036|       |
 5037|       |    // Mark all windows as not visible and compact unused memory.
 5038|  76.6k|    IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5039|  76.6k|    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? FLT_MAX : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
  ------------------
  |  Branch (5039:46): [True: 0, False: 76.6k]
  |  Branch (5039:64): [True: 0, False: 76.6k]
  ------------------
 5040|  76.6k|    for (ImGuiWindow* window : g.Windows)
  ------------------
  |  Branch (5040:30): [True: 230k, False: 76.6k]
  ------------------
 5041|   230k|    {
 5042|   230k|        window->WasActive = window->Active;
 5043|   230k|        window->Active = false;
 5044|   230k|        window->WriteAccessed = false;
 5045|   230k|        window->BeginCountPreviousFrame = window->BeginCount;
 5046|   230k|        window->BeginCount = 0;
 5047|       |
 5048|       |        // Garbage collect transient buffers of recently unused windows
 5049|   230k|        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (5049:13): [True: 136k, False: 93.6k]
  |  Branch (5049:35): [True: 83.8k, False: 52.5k]
  |  Branch (5049:63): [True: 2, False: 83.8k]
  ------------------
 5050|      2|            GcCompactTransientWindowBuffers(window);
 5051|   230k|    }
 5052|       |
 5053|       |    // Garbage collect transient buffers of recently unused tables
 5054|  76.6k|    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
  ------------------
  |  Branch (5054:21): [True: 0, False: 76.6k]
  ------------------
 5055|      0|        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
  ------------------
  |  Branch (5055:13): [True: 0, False: 0]
  |  Branch (5055:50): [True: 0, False: 0]
  ------------------
 5056|      0|            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
 5057|  76.6k|    for (ImGuiTableTempData& table_temp_data : g.TablesTempData)
  ------------------
  |  Branch (5057:46): [True: 0, False: 76.6k]
  ------------------
 5058|      0|        if (table_temp_data.LastTimeActive >= 0.0f && table_temp_data.LastTimeActive < memory_compact_start_time)
  ------------------
  |  Branch (5058:13): [True: 0, False: 0]
  |  Branch (5058:55): [True: 0, False: 0]
  ------------------
 5059|      0|            TableGcCompactTransientBuffers(&table_temp_data);
 5060|  76.6k|    if (g.GcCompactAll)
  ------------------
  |  Branch (5060:9): [True: 0, False: 76.6k]
  ------------------
 5061|      0|        GcCompactTransientMiscBuffers();
 5062|  76.6k|    g.GcCompactAll = false;
 5063|       |
 5064|       |    // Closing the focused window restore focus to the first active root window in descending z-order
 5065|  76.6k|    if (g.NavWindow && !g.NavWindow->WasActive)
  ------------------
  |  Branch (5065:9): [True: 7.56k, False: 69.1k]
  |  Branch (5065:24): [True: 0, False: 7.56k]
  ------------------
 5066|      0|        FocusTopMostWindowUnderOne(NULL, NULL, NULL, ImGuiFocusRequestFlags_RestoreFocusedChild);
 5067|       |
 5068|       |    // No window should be open at the beginning of the frame.
 5069|       |    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
 5070|  76.6k|    g.CurrentWindowStack.resize(0);
 5071|  76.6k|    g.BeginPopupStack.resize(0);
 5072|  76.6k|    g.ItemFlagsStack.resize(0);
 5073|  76.6k|    g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
 5074|  76.6k|    g.GroupStack.resize(0);
 5075|       |
 5076|       |    // Docking
 5077|  76.6k|    DockContextNewFrameUpdateDocking(&g);
 5078|       |
 5079|       |    // [DEBUG] Update debug features
 5080|  76.6k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 5081|  76.6k|    UpdateDebugToolItemPicker();
 5082|  76.6k|    UpdateDebugToolStackQueries();
 5083|  76.6k|    UpdateDebugToolFlashStyleColor();
 5084|  76.6k|    if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
  ------------------
  |  Branch (5084:9): [True: 0, False: 76.6k]
  |  Branch (5084:36): [True: 0, False: 0]
  ------------------
 5085|      0|    {
 5086|      0|        g.DebugLocateId = 0;
 5087|      0|        g.DebugBreakInLocateId = false;
 5088|      0|    }
 5089|  76.6k|    if (g.DebugLogAutoDisableFrames > 0 && --g.DebugLogAutoDisableFrames == 0)
  ------------------
  |  Branch (5089:9): [True: 0, False: 76.6k]
  |  Branch (5089:44): [True: 0, False: 0]
  ------------------
 5090|      0|    {
 5091|      0|        DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n");
 5092|      0|        g.DebugLogFlags &= ~g.DebugLogAutoDisableFlags;
 5093|      0|        g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
 5094|      0|    }
 5095|  76.6k|#endif
 5096|       |
 5097|       |    // Create implicit/fallback window - which we will only render it if the user has added something to it.
 5098|       |    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
 5099|       |    // This fallback is particularly important as it prevents ImGui:: calls from crashing.
 5100|  76.6k|    g.WithinFrameScopeWithImplicitWindow = true;
 5101|  76.6k|    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
 5102|  76.6k|    Begin("Debug##Default");
 5103|  76.6k|    IM_ASSERT(g.CurrentWindow->IsFallbackWindow == true);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5104|       |
 5105|       |    // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
 5106|       |    // allowing to validate correct Begin/End behavior in user code.
 5107|  76.6k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 5108|  76.6k|    if (g.IO.ConfigDebugBeginReturnValueLoop)
  ------------------
  |  Branch (5108:9): [True: 0, False: 76.6k]
  ------------------
 5109|      0|        g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);
  ------------------
  |  Branch (5109:44): [True: 0, False: 0]
  |  Branch (5109:129): [True: 0, False: 0]
  ------------------
 5110|  76.6k|    else
 5111|  76.6k|        g.DebugBeginReturnValueCullDepth = -1;
 5112|  76.6k|#endif
 5113|       |
 5114|  76.6k|    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
 5115|  76.6k|}
_ZN5ImGui12PushClipRectERK6ImVec2S2_b:
 5222|   340k|{
 5223|   340k|    ImGuiWindow* window = GetCurrentWindow();
 5224|   340k|    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
 5225|   340k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 5226|   340k|}
_ZN5ImGui11PopClipRectEv:
 5229|   170k|{
 5230|   170k|    ImGuiWindow* window = GetCurrentWindow();
 5231|   170k|    window->DrawList->PopClipRect();
 5232|   170k|    window->ClipRect = window->DrawList->_ClipRectStack.back();
 5233|   170k|}
_ZN5ImGui8EndFrameEv:
 5360|   153k|{
 5361|   153k|    ImGuiContext& g = *GImGui;
 5362|   153k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|   153k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5363|       |
 5364|       |    // Don't process EndFrame() multiple times.
 5365|   153k|    if (g.FrameCountEnded == g.FrameCount)
  ------------------
  |  Branch (5365:9): [True: 76.6k, False: 76.6k]
  ------------------
 5366|  76.6k|        return;
 5367|  76.6k|    IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5368|       |
 5369|  76.6k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);
 5370|       |
 5371|  76.6k|    ErrorCheckEndFrameSanityChecks();
 5372|       |
 5373|       |    // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
 5374|  76.6k|    ImGuiPlatformImeData* ime_data = &g.PlatformImeData;
 5375|  76.6k|    if (g.IO.SetPlatformImeDataFn && memcmp(ime_data, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
  ------------------
  |  Branch (5375:9): [True: 76.6k, False: 0]
  |  Branch (5375:38): [True: 0, False: 76.6k]
  ------------------
 5376|      0|    {
 5377|      0|        ImGuiViewport* viewport = FindViewportByID(g.PlatformImeViewport);
 5378|      0|        IMGUI_DEBUG_LOG_IO("[io] Calling io.SetPlatformImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data->WantVisible, ime_data->InputPos.x, ime_data->InputPos.y);
  ------------------
  |  |  251|      0|#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)          IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (251:50): [True: 0, False: 0]
  |  |  |  Branch (251:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5379|      0|        if (viewport == NULL)
  ------------------
  |  Branch (5379:13): [True: 0, False: 0]
  ------------------
 5380|      0|            viewport = GetMainViewport();
 5381|      0|        g.IO.SetPlatformImeDataFn(viewport, ime_data);
 5382|      0|    }
 5383|       |
 5384|       |    // Hide implicit/fallback "Debug" window if it hasn't been used
 5385|  76.6k|    g.WithinFrameScopeWithImplicitWindow = false;
 5386|  76.6k|    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
  ------------------
  |  Branch (5386:9): [True: 76.6k, False: 0]
  |  Branch (5386:28): [True: 76.6k, False: 0]
  ------------------
 5387|  76.6k|        g.CurrentWindow->Active = false;
 5388|  76.6k|    End();
 5389|       |
 5390|       |    // Update navigation: CTRL+Tab, wrap-around requests
 5391|  76.6k|    NavEndFrame();
 5392|       |
 5393|       |    // Update docking
 5394|  76.6k|    DockContextEndFrame(&g);
 5395|       |
 5396|  76.6k|    SetCurrentViewport(NULL, NULL);
 5397|       |
 5398|       |    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
 5399|  76.6k|    if (g.DragDropActive)
  ------------------
  |  Branch (5399:9): [True: 162, False: 76.5k]
  ------------------
 5400|    162|    {
 5401|    162|        bool is_delivered = g.DragDropPayload.Delivery;
 5402|    162|        bool is_elapsed = (g.DragDropSourceFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_PayloadAutoExpire) || g.DragDropMouseButton == -1 || !IsMouseDown(g.DragDropMouseButton));
  ------------------
  |  Branch (5402:27): [True: 2, False: 160]
  |  Branch (5402:79): [True: 2, False: 0]
  |  Branch (5402:145): [True: 0, False: 0]
  |  Branch (5402:176): [True: 0, False: 0]
  ------------------
 5403|    162|        if (is_delivered || is_elapsed)
  ------------------
  |  Branch (5403:13): [True: 0, False: 162]
  |  Branch (5403:29): [True: 2, False: 160]
  ------------------
 5404|      2|            ClearDragDrop();
 5405|    162|    }
 5406|       |
 5407|       |    // Drag and Drop: Fallback for missing source tooltip. This is not ideal but better than nothing.
 5408|       |    // If you want to handle source item disappearing: instead of submitting your description tooltip
 5409|       |    // in the BeginDragDropSource() block of the dragged item, you can submit them from a safe single spot
 5410|       |    // (e.g. end of your item loop, or before EndFrame) by reading payload data.
 5411|       |    // In the typical case, the contents of drag tooltip should be possible to infer solely from payload data.
 5412|  76.6k|    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (5412:9): [True: 160, False: 76.5k]
  |  Branch (5412:29): [True: 2, False: 158]
  |  Branch (5412:74): [True: 0, False: 2]
  ------------------
 5413|      0|    {
 5414|      0|        g.DragDropWithinSource = true;
 5415|      0|        SetTooltip("...");
 5416|      0|        g.DragDropWithinSource = false;
 5417|      0|    }
 5418|       |
 5419|       |    // End frame
 5420|  76.6k|    g.WithinFrameScope = false;
 5421|  76.6k|    g.FrameCountEnded = g.FrameCount;
 5422|       |
 5423|       |    // Initiate moving window + handle left-click and right-click focus
 5424|  76.6k|    UpdateMouseMovingWindowEndFrame();
 5425|       |
 5426|       |    // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
 5427|  76.6k|    UpdateViewportsEndFrame();
 5428|       |
 5429|       |    // Sort the window list so that all child windows are after their parent
 5430|       |    // We cannot do that on FocusWindow() because children may not exist yet
 5431|  76.6k|    g.WindowsTempSortBuffer.resize(0);
 5432|  76.6k|    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
 5433|  76.6k|    for (ImGuiWindow* window : g.Windows)
  ------------------
  |  Branch (5433:30): [True: 230k, False: 76.6k]
  ------------------
 5434|   230k|    {
 5435|   230k|        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
  ------------------
  |  Branch (5435:13): [True: 93.6k, False: 136k]
  |  Branch (5435:31): [True: 16.9k, False: 76.6k]
  ------------------
 5436|  16.9k|            continue;
 5437|   213k|        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
 5438|   213k|    }
 5439|       |
 5440|       |    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
 5441|  76.6k|    IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5442|  76.6k|    g.Windows.swap(g.WindowsTempSortBuffer);
 5443|  76.6k|    g.IO.MetricsActiveWindows = g.WindowsActiveCount;
 5444|       |
 5445|       |    // Unlock font atlas
 5446|  76.6k|    g.IO.Fonts->Locked = false;
 5447|       |
 5448|       |    // Clear Input data for next frame
 5449|  76.6k|    g.IO.MousePosPrev = g.IO.MousePos;
 5450|  76.6k|    g.IO.AppFocusLost = false;
 5451|  76.6k|    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
 5452|  76.6k|    g.IO.InputQueueCharacters.resize(0);
 5453|       |
 5454|  76.6k|    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
 5455|  76.6k|}
_ZN5ImGui6RenderEv:
 5461|  76.6k|{
 5462|  76.6k|    ImGuiContext& g = *GImGui;
 5463|  76.6k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5464|       |
 5465|  76.6k|    if (g.FrameCountEnded != g.FrameCount)
  ------------------
  |  Branch (5465:9): [True: 76.6k, False: 0]
  ------------------
 5466|  76.6k|        EndFrame();
 5467|  76.6k|    if (g.FrameCountRendered == g.FrameCount)
  ------------------
  |  Branch (5467:9): [True: 0, False: 76.6k]
  ------------------
 5468|      0|        return;
 5469|  76.6k|    g.FrameCountRendered = g.FrameCount;
 5470|       |
 5471|  76.6k|    g.IO.MetricsRenderWindows = 0;
 5472|  76.6k|    CallContextHooks(&g, ImGuiContextHookType_RenderPre);
 5473|       |
 5474|       |    // Add background ImDrawList (for each active viewport)
 5475|  76.6k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (5475:35): [True: 76.6k, False: 76.6k]
  ------------------
 5476|  76.6k|    {
 5477|  76.6k|        InitViewportDrawData(viewport);
 5478|  76.6k|        if (viewport->BgFgDrawLists[0] != NULL)
  ------------------
  |  Branch (5478:13): [True: 0, False: 76.6k]
  ------------------
 5479|      0|            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
 5480|  76.6k|    }
 5481|       |
 5482|       |    // Draw modal/window whitening backgrounds
 5483|  76.6k|    RenderDimmedBackgrounds();
 5484|       |
 5485|       |    // Add ImDrawList to render
 5486|  76.6k|    ImGuiWindow* windows_to_render_top_most[2];
 5487|  76.6k|    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindowDockTree : NULL;
  ------------------
  |  Branch (5487:38): [True: 0, False: 76.6k]
  |  Branch (5487:62): [True: 0, False: 0]
  ------------------
 5488|  76.6k|    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : NULL);
  ------------------
  |  Branch (5488:38): [True: 0, False: 76.6k]
  ------------------
 5489|  76.6k|    for (ImGuiWindow* window : g.Windows)
  ------------------
  |  Branch (5489:30): [True: 230k, False: 76.6k]
  ------------------
 5490|   230k|    {
 5491|   230k|        IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
 5492|   230k|        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
  ------------------
  |  Branch (5492:13): [True: 93.6k, False: 136k]
  |  Branch (5492:49): [True: 76.6k, False: 16.9k]
  |  Branch (5492:104): [True: 76.6k, False: 0]
  |  Branch (5492:147): [True: 76.6k, False: 0]
  ------------------
 5493|  76.6k|            AddRootWindowToDrawData(window);
 5494|   230k|    }
 5495|   230k|    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); n++)
  ------------------
  |  |   93|   230k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5495:21): [True: 153k, False: 76.6k]
  ------------------
 5496|   153k|        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) // NavWindowingTarget is always temporarily displayed as the top-most window
  ------------------
  |  Branch (5496:13): [True: 0, False: 153k]
  |  Branch (5496:46): [True: 0, False: 0]
  ------------------
 5497|      0|            AddRootWindowToDrawData(windows_to_render_top_most[n]);
 5498|       |
 5499|       |    // Draw software mouse cursor if requested by io.MouseDrawCursor flag
 5500|  76.6k|    if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None)
  ------------------
  |  Branch (5500:9): [True: 0, False: 76.6k]
  |  Branch (5500:33): [True: 0, False: 0]
  ------------------
 5501|      0|        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2754|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2755|      0|#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
  |  |  ------------------
  |  |  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
  ------------------
  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 5502|       |
 5503|       |    // Setup ImDrawData structures for end-user
 5504|  76.6k|    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
 5505|  76.6k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (5505:35): [True: 76.6k, False: 76.6k]
  ------------------
 5506|  76.6k|    {
 5507|  76.6k|        FlattenDrawDataIntoSingleLayer(&viewport->DrawDataBuilder);
 5508|       |
 5509|       |        // Add foreground ImDrawList (for each active viewport)
 5510|  76.6k|        if (viewport->BgFgDrawLists[1] != NULL)
  ------------------
  |  Branch (5510:13): [True: 0, False: 76.6k]
  ------------------
 5511|      0|            AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
 5512|       |
 5513|       |        // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
 5514|  76.6k|        ImDrawData* draw_data = &viewport->DrawDataP;
 5515|  76.6k|        IM_ASSERT(draw_data->CmdLists.Size == draw_data->CmdListsCount);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5516|  76.6k|        for (ImDrawList* draw_list : draw_data->CmdLists)
  ------------------
  |  Branch (5516:36): [True: 92.8k, False: 76.6k]
  ------------------
 5517|  92.8k|            draw_list->_PopUnusedDrawCmd();
 5518|       |
 5519|  76.6k|        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
 5520|  76.6k|        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
 5521|  76.6k|    }
 5522|       |
 5523|  76.6k|    CallContextHooks(&g, ImGuiContextHookType_RenderPost);
 5524|  76.6k|}
_ZN5ImGui12CalcTextSizeEPKcS1_bf:
 5529|   153k|{
 5530|   153k|    ImGuiContext& g = *GImGui;
 5531|       |
 5532|   153k|    const char* text_display_end;
 5533|   153k|    if (hide_text_after_double_hash)
  ------------------
  |  Branch (5533:9): [True: 153k, False: 0]
  ------------------
 5534|   153k|        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
 5535|      0|    else
 5536|      0|        text_display_end = text_end;
 5537|       |
 5538|   153k|    ImFont* font = g.Font;
 5539|   153k|    const float font_size = g.FontSize;
 5540|   153k|    if (text == text_display_end)
  ------------------
  |  Branch (5540:9): [True: 0, False: 153k]
  ------------------
 5541|      0|        return ImVec2(0.0f, font_size);
 5542|   153k|    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);
 5543|       |
 5544|       |    // Round
 5545|       |    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
 5546|       |    // FIXME: Investigate using ceilf or e.g.
 5547|       |    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
 5548|       |    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
 5549|   153k|    text_size.x = IM_TRUNC(text_size.x + 0.99999f);
  ------------------
  |  |  287|   153k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 5550|       |
 5551|   153k|    return text_size;
 5552|   153k|}
_ZN5ImGui19FindHoveredWindowExERK6ImVec2bPP11ImGuiWindowS5_:
 5561|  76.6k|{
 5562|  76.6k|    ImGuiContext& g = *GImGui;
 5563|  76.6k|    ImGuiWindow* hovered_window = NULL;
 5564|  76.6k|    ImGuiWindow* hovered_window_under_moving_window = NULL;
 5565|       |
 5566|       |    // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
 5567|  76.6k|    ImGuiViewportP* backup_moving_window_viewport = NULL;
 5568|  76.6k|    if (find_first_and_in_any_viewport == false && g.MovingWindow)
  ------------------
  |  Branch (5568:9): [True: 76.6k, False: 0]
  |  Branch (5568:52): [True: 562, False: 76.1k]
  ------------------
 5569|    562|    {
 5570|    562|        backup_moving_window_viewport = g.MovingWindow->Viewport;
 5571|    562|        g.MovingWindow->Viewport = g.MouseViewport;
 5572|    562|        if (!(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (5572:13): [True: 562, False: 0]
  ------------------
 5573|    562|            hovered_window = g.MovingWindow;
 5574|    562|    }
 5575|       |
 5576|  76.6k|    ImVec2 padding_regular = g.Style.TouchExtraPadding;
 5577|  76.6k|    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
  ------------------
  |  Branch (5577:33): [True: 76.6k, False: 0]
  ------------------
 5578|   299k|    for (int i = g.Windows.Size - 1; i >= 0; i--)
  ------------------
  |  Branch (5578:38): [True: 226k, False: 73.2k]
  ------------------
 5579|   226k|    {
 5580|   226k|        ImGuiWindow* window = g.Windows[i];
 5581|   226k|        IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5582|   226k|        if (!window->Active || window->Hidden)
  ------------------
  |  Branch (5582:13): [True: 133k, False: 93.6k]
  |  Branch (5582:32): [True: 13, False: 93.5k]
  ------------------
 5583|   133k|            continue;
 5584|  93.5k|        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
  ------------------
  |  Branch (5584:13): [True: 0, False: 93.5k]
  ------------------
 5585|      0|            continue;
 5586|  93.5k|        IM_ASSERT(window->Viewport);
  ------------------
  |  |   23|  93.5k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5587|  93.5k|        if (window->Viewport != g.MouseViewport)
  ------------------
  |  Branch (5587:13): [True: 0, False: 93.5k]
  ------------------
 5588|      0|            continue;
 5589|       |
 5590|       |        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
 5591|  93.5k|        ImVec2 hit_padding = (window->Flags & (ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;
  ------------------
  |  Branch (5591:30): [True: 16.9k, False: 76.6k]
  ------------------
 5592|  93.5k|        if (!window->OuterRectClipped.ContainsWithPad(pos, hit_padding))
  ------------------
  |  Branch (5592:13): [True: 89.8k, False: 3.75k]
  ------------------
 5593|  89.8k|            continue;
 5594|       |
 5595|       |        // Support for one rectangular hole in any given window
 5596|       |        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
 5597|  3.75k|        if (window->HitTestHoleSize.x != 0)
  ------------------
  |  Branch (5597:13): [True: 0, False: 3.75k]
  ------------------
 5598|      0|        {
 5599|      0|            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
 5600|      0|            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
 5601|      0|            if (ImRect(hole_pos, hole_pos + hole_size).Contains(pos))
  ------------------
  |  Branch (5601:17): [True: 0, False: 0]
  ------------------
 5602|      0|                continue;
 5603|      0|        }
 5604|       |
 5605|  3.75k|        if (find_first_and_in_any_viewport)
  ------------------
  |  Branch (5605:13): [True: 0, False: 3.75k]
  ------------------
 5606|      0|        {
 5607|      0|            hovered_window = window;
 5608|      0|            break;
 5609|      0|        }
 5610|  3.75k|        else
 5611|  3.75k|        {
 5612|  3.75k|            if (hovered_window == NULL)
  ------------------
  |  Branch (5612:17): [True: 3.40k, False: 352]
  ------------------
 5613|  3.40k|                hovered_window = window;
 5614|  3.75k|            IM_MSVC_WARNING_SUPPRESS(28182); // [Static Analyzer] Dereferencing NULL pointer.
 5615|  3.75k|            if (hovered_window_under_moving_window == NULL && (!g.MovingWindow || window->RootWindowDockTree != g.MovingWindow->RootWindowDockTree))
  ------------------
  |  Branch (5615:17): [True: 3.75k, False: 0]
  |  Branch (5615:64): [True: 3.40k, False: 352]
  |  Branch (5615:83): [True: 0, False: 352]
  ------------------
 5616|  3.40k|                hovered_window_under_moving_window = window;
 5617|  3.75k|            if (hovered_window && hovered_window_under_moving_window)
  ------------------
  |  Branch (5617:17): [True: 3.75k, False: 0]
  |  Branch (5617:35): [True: 3.40k, False: 352]
  ------------------
 5618|  3.40k|                break;
 5619|  3.75k|        }
 5620|  3.75k|    }
 5621|       |
 5622|  76.6k|    *out_hovered_window = hovered_window;
 5623|  76.6k|    if (out_hovered_window_under_moving_window != NULL)
  ------------------
  |  Branch (5623:9): [True: 76.6k, False: 0]
  ------------------
 5624|  76.6k|        *out_hovered_window_under_moving_window = hovered_window_under_moving_window;
 5625|  76.6k|    if (find_first_and_in_any_viewport == false && g.MovingWindow)
  ------------------
  |  Branch (5625:9): [True: 76.6k, False: 0]
  |  Branch (5625:52): [True: 562, False: 76.1k]
  ------------------
 5626|    562|        g.MovingWindow->Viewport = backup_moving_window_viewport;
 5627|  76.6k|}
_ZN5ImGui12IsItemActiveEv:
 5630|   153k|{
 5631|   153k|    ImGuiContext& g = *GImGui;
 5632|   153k|    if (g.ActiveId)
  ------------------
  |  Branch (5632:9): [True: 1.07k, False: 152k]
  ------------------
 5633|  1.07k|        return g.ActiveId == g.LastItemData.ID;
 5634|   152k|    return false;
 5635|   153k|}
_ZN5ImGui31SetActiveIdUsingAllKeyboardKeysEv:
 5753|    239|{
 5754|    239|    ImGuiContext& g = *GImGui;
 5755|    239|    IM_ASSERT(g.ActiveId != 0);
  ------------------
  |  |   23|    239|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5756|    239|    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
 5757|    239|    g.ActiveIdUsingAllKeyboardKeys = true;
 5758|    239|    NavMoveRequestCancel();
 5759|    239|}
_ZN5ImGui10BeginChildEPKcRK6ImVec2ii:
 5788|  16.9k|{
 5789|  16.9k|    ImGuiID id = GetCurrentWindow()->GetID(str_id);
 5790|  16.9k|    return BeginChildEx(str_id, id, size_arg, child_flags, window_flags);
 5791|  16.9k|}
_ZN5ImGui12BeginChildExEPKcjRK6ImVec2ii:
 5799|  16.9k|{
 5800|  16.9k|    ImGuiContext& g = *GImGui;
 5801|  16.9k|    ImGuiWindow* parent_window = g.CurrentWindow;
 5802|  16.9k|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5803|       |
 5804|       |    // Sanity check as it is likely that some user will accidentally pass ImGuiWindowFlags into the ImGuiChildFlags argument.
 5805|  16.9k|    const ImGuiChildFlags ImGuiChildFlags_SupportedMask_ = ImGuiChildFlags_Border | ImGuiChildFlags_AlwaysUseWindowPadding | ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY | ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize | ImGuiChildFlags_FrameStyle | ImGuiChildFlags_NavFlattened;
 5806|  16.9k|    IM_UNUSED(ImGuiChildFlags_SupportedMask_);
  ------------------
  |  |   94|  16.9k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
 5807|  16.9k|    IM_ASSERT((child_flags & ~ImGuiChildFlags_SupportedMask_) == 0 && "Illegal ImGuiChildFlags value. Did you pass ImGuiWindowFlags values instead of ImGuiChildFlags?");
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5808|  16.9k|    IM_ASSERT((window_flags & ImGuiWindowFlags_AlwaysAutoResize) == 0 && "Cannot specify ImGuiWindowFlags_AlwaysAutoResize for BeginChild(). Use ImGuiChildFlags_AlwaysAutoResize!");
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5809|  16.9k|    if (child_flags & ImGuiChildFlags_AlwaysAutoResize)
  ------------------
  |  Branch (5809:9): [True: 0, False: 16.9k]
  ------------------
 5810|      0|    {
 5811|      0|        IM_ASSERT((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0 && "Cannot use ImGuiChildFlags_ResizeX or ImGuiChildFlags_ResizeY with ImGuiChildFlags_AlwaysAutoResize!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5812|      0|        IM_ASSERT((child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY)) != 0 && "Must use ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY with ImGuiChildFlags_AlwaysAutoResize!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5813|      0|    }
 5814|       |#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
 5815|       |    if (window_flags & ImGuiWindowFlags_AlwaysUseWindowPadding)
 5816|       |        child_flags |= ImGuiChildFlags_AlwaysUseWindowPadding;
 5817|       |    if (window_flags & ImGuiWindowFlags_NavFlattened)
 5818|       |        child_flags |= ImGuiChildFlags_NavFlattened;
 5819|       |#endif
 5820|  16.9k|    if (child_flags & ImGuiChildFlags_AutoResizeX)
  ------------------
  |  Branch (5820:9): [True: 0, False: 16.9k]
  ------------------
 5821|      0|        child_flags &= ~ImGuiChildFlags_ResizeX;
 5822|  16.9k|    if (child_flags & ImGuiChildFlags_AutoResizeY)
  ------------------
  |  Branch (5822:9): [True: 0, False: 16.9k]
  ------------------
 5823|      0|        child_flags &= ~ImGuiChildFlags_ResizeY;
 5824|       |
 5825|       |    // Set window flags
 5826|  16.9k|    window_flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking;
 5827|  16.9k|    window_flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove); // Inherit the NoMove flag
 5828|  16.9k|    if (child_flags & (ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_AlwaysAutoResize))
  ------------------
  |  Branch (5828:9): [True: 0, False: 16.9k]
  ------------------
 5829|      0|        window_flags |= ImGuiWindowFlags_AlwaysAutoResize;
 5830|  16.9k|    if ((child_flags & (ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY)) == 0)
  ------------------
  |  Branch (5830:9): [True: 16.9k, False: 0]
  ------------------
 5831|  16.9k|        window_flags |= ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;
 5832|       |
 5833|       |    // Special framed style
 5834|  16.9k|    if (child_flags & ImGuiChildFlags_FrameStyle)
  ------------------
  |  Branch (5834:9): [True: 0, False: 16.9k]
  ------------------
 5835|      0|    {
 5836|      0|        PushStyleColor(ImGuiCol_ChildBg, g.Style.Colors[ImGuiCol_FrameBg]);
 5837|      0|        PushStyleVar(ImGuiStyleVar_ChildRounding, g.Style.FrameRounding);
 5838|      0|        PushStyleVar(ImGuiStyleVar_ChildBorderSize, g.Style.FrameBorderSize);
 5839|      0|        PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.FramePadding);
 5840|      0|        child_flags |= ImGuiChildFlags_Border | ImGuiChildFlags_AlwaysUseWindowPadding;
 5841|      0|        window_flags |= ImGuiWindowFlags_NoMove;
 5842|      0|    }
 5843|       |
 5844|       |    // Forward child flags
 5845|  16.9k|    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasChildFlags;
 5846|  16.9k|    g.NextWindowData.ChildFlags = child_flags;
 5847|       |
 5848|       |    // Forward size
 5849|       |    // Important: Begin() has special processing to switch condition to ImGuiCond_FirstUseEver for a given axis when ImGuiChildFlags_ResizeXXX is set.
 5850|       |    // (the alternative would to store conditional flags per axis, which is possible but more code)
 5851|  16.9k|    const ImVec2 size_avail = GetContentRegionAvail();
 5852|  16.9k|    const ImVec2 size_default((child_flags & ImGuiChildFlags_AutoResizeX) ? 0.0f : size_avail.x, (child_flags & ImGuiChildFlags_AutoResizeY) ? 0.0f : size_avail.y);
  ------------------
  |  Branch (5852:31): [True: 0, False: 16.9k]
  |  Branch (5852:98): [True: 0, False: 16.9k]
  ------------------
 5853|  16.9k|    const ImVec2 size = CalcItemSize(size_arg, size_default.x, size_default.y);
 5854|  16.9k|    SetNextWindowSize(size);
 5855|       |
 5856|       |    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
 5857|       |    // FIXME: 2023/11/14: commented out shorted version. We had an issue with multiple ### in child window path names, which the trailing hash helped workaround.
 5858|       |    // e.g. "ParentName###ParentIdentifier/ChildName###ChildIdentifier" would get hashed incorrectly by ImHashStr(), trailing _%08X somehow fixes it.
 5859|  16.9k|    const char* temp_window_name;
 5860|       |    /*if (name && parent_window->IDStack.back() == parent_window->ID)
 5861|       |        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s", parent_window->Name, name); // May omit ID if in root of ID stack
 5862|       |    else*/
 5863|  16.9k|    if (name)
  ------------------
  |  Branch (5863:9): [True: 16.9k, False: 0]
  ------------------
 5864|  16.9k|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s_%08X", parent_window->Name, name, id);
 5865|      0|    else
 5866|      0|        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%08X", parent_window->Name, id);
 5867|       |
 5868|       |    // Set style
 5869|  16.9k|    const float backup_border_size = g.Style.ChildBorderSize;
 5870|  16.9k|    if ((child_flags & ImGuiChildFlags_Border) == 0)
  ------------------
  |  Branch (5870:9): [True: 7.83k, False: 9.10k]
  ------------------
 5871|  7.83k|        g.Style.ChildBorderSize = 0.0f;
 5872|       |
 5873|       |    // Begin into window
 5874|  16.9k|    const bool ret = Begin(temp_window_name, NULL, window_flags);
 5875|       |
 5876|       |    // Restore style
 5877|  16.9k|    g.Style.ChildBorderSize = backup_border_size;
 5878|  16.9k|    if (child_flags & ImGuiChildFlags_FrameStyle)
  ------------------
  |  Branch (5878:9): [True: 0, False: 16.9k]
  ------------------
 5879|      0|    {
 5880|      0|        PopStyleVar(3);
 5881|      0|        PopStyleColor();
 5882|      0|    }
 5883|       |
 5884|  16.9k|    ImGuiWindow* child_window = g.CurrentWindow;
 5885|  16.9k|    child_window->ChildId = id;
 5886|       |
 5887|       |    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
 5888|       |    // While this is not really documented/defined, it seems that the expected thing to do.
 5889|  16.9k|    if (child_window->BeginCount == 1)
  ------------------
  |  Branch (5889:9): [True: 16.9k, False: 0]
  ------------------
 5890|  16.9k|        parent_window->DC.CursorPos = child_window->Pos;
 5891|       |
 5892|       |    // Process navigation-in immediately so NavInit can run on first frame
 5893|       |    // Can enter a child if (A) it has navigable items or (B) it can be scrolled.
 5894|  16.9k|    const ImGuiID temp_id_for_activation = ImHashStr("##Child", 0, id);
 5895|  16.9k|    if (g.ActiveId == temp_id_for_activation)
  ------------------
  |  Branch (5895:9): [True: 4, False: 16.9k]
  ------------------
 5896|      4|        ClearActiveID();
 5897|  16.9k|    if (g.NavActivateId == id && !(child_flags & ImGuiChildFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY))
  ------------------
  |  Branch (5897:9): [True: 17, False: 16.9k]
  |  Branch (5897:34): [True: 17, False: 0]
  |  Branch (5897:84): [True: 0, False: 17]
  |  Branch (5897:129): [True: 17, False: 0]
  ------------------
 5898|     17|    {
 5899|     17|        FocusWindow(child_window);
 5900|     17|        NavInitWindow(child_window, false);
 5901|     17|        SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
 5902|     17|        g.ActiveIdSource = g.NavInputSource;
 5903|     17|    }
 5904|  16.9k|    return ret;
 5905|  16.9k|}
_ZN5ImGui8EndChildEv:
 5908|  16.9k|{
 5909|  16.9k|    ImGuiContext& g = *GImGui;
 5910|  16.9k|    ImGuiWindow* child_window = g.CurrentWindow;
 5911|       |
 5912|  16.9k|    IM_ASSERT(g.WithinEndChild == false);
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5913|  16.9k|    IM_ASSERT(child_window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() calls
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5914|       |
 5915|  16.9k|    g.WithinEndChild = true;
 5916|  16.9k|    ImVec2 child_size = child_window->Size;
 5917|  16.9k|    End();
 5918|  16.9k|    if (child_window->BeginCount == 1)
  ------------------
  |  Branch (5918:9): [True: 16.9k, False: 0]
  ------------------
 5919|  16.9k|    {
 5920|  16.9k|        ImGuiWindow* parent_window = g.CurrentWindow;
 5921|  16.9k|        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + child_size);
 5922|  16.9k|        ItemSize(child_size);
 5923|  16.9k|        const bool nav_flattened = (child_window->ChildFlags & ImGuiChildFlags_NavFlattened) != 0;
 5924|  16.9k|        if ((child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavWindowHasScrollY) && !nav_flattened)
  ------------------
  |  Branch (5924:14): [True: 0, False: 16.9k]
  |  Branch (5924:59): [True: 15.7k, False: 1.20k]
  |  Branch (5924:100): [True: 15.7k, False: 0]
  ------------------
 5925|  15.7k|        {
 5926|  15.7k|            ItemAdd(bb, child_window->ChildId);
 5927|  15.7k|            RenderNavHighlight(bb, child_window->ChildId);
 5928|       |
 5929|       |            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
 5930|  15.7k|            if (child_window->DC.NavLayersActiveMask == 0 && child_window == g.NavWindow)
  ------------------
  |  Branch (5930:17): [True: 15.7k, False: 0]
  |  Branch (5930:62): [True: 8.71k, False: 7.02k]
  ------------------
 5931|  8.71k|                RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_Compact);
 5932|  15.7k|        }
 5933|  1.20k|        else
 5934|  1.20k|        {
 5935|       |            // Not navigable into
 5936|       |            // - This is a bit of a fringe use case, mostly useful for undecorated, non-scrolling contents childs, or empty childs.
 5937|       |            // - We could later decide to not apply this path if ImGuiChildFlags_FrameStyle or ImGuiChildFlags_Borders is set.
 5938|  1.20k|            ItemAdd(bb, child_window->ChildId, NULL, ImGuiItemFlags_NoNav);
 5939|       |
 5940|       |            // But when flattened we directly reach items, adjust active layer mask accordingly
 5941|  1.20k|            if (nav_flattened)
  ------------------
  |  Branch (5941:17): [True: 0, False: 1.20k]
  ------------------
 5942|      0|                parent_window->DC.NavLayersActiveMaskNext |= child_window->DC.NavLayersActiveMaskNext;
 5943|  1.20k|        }
 5944|  16.9k|        if (g.HoveredWindow == child_window)
  ------------------
  |  Branch (5944:13): [True: 30, False: 16.9k]
  ------------------
 5945|     30|            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
 5946|  16.9k|    }
 5947|  16.9k|    g.WithinEndChild = false;
 5948|  16.9k|    g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
 5949|  16.9k|}
_ZN5ImGui14FindWindowByIDEj:
 5960|   170k|{
 5961|   170k|    ImGuiContext& g = *GImGui;
 5962|   170k|    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
 5963|   170k|}
_ZN5ImGui16FindWindowByNameEPKc:
 5966|   170k|{
 5967|   170k|    ImGuiID id = ImHashStr(name);
 5968|   170k|    return FindWindowByID(id);
 5969|   170k|}
_ZN5ImGui30UpdateWindowParentAndRootLinksEP11ImGuiWindowiS1_:
 6810|   170k|{
 6811|   170k|    window->ParentWindow = parent_window;
 6812|   170k|    window->RootWindow = window->RootWindowPopupTree = window->RootWindowDockTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
 6813|   170k|    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (6813:9): [True: 16.9k, False: 153k]
  |  Branch (6813:26): [True: 16.9k, False: 0]
  |  Branch (6813:68): [True: 16.9k, False: 0]
  ------------------
 6814|  16.9k|    {
 6815|  16.9k|        window->RootWindowDockTree = parent_window->RootWindowDockTree;
 6816|  16.9k|        if (!window->DockIsActive && !(parent_window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6816:13): [True: 16.9k, False: 0]
  |  Branch (6816:38): [True: 16.9k, False: 0]
  ------------------
 6817|  16.9k|            window->RootWindow = parent_window->RootWindow;
 6818|  16.9k|    }
 6819|   170k|    if (parent_window && (flags & ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (6819:9): [True: 16.9k, False: 153k]
  |  Branch (6819:26): [True: 0, False: 16.9k]
  ------------------
 6820|      0|        window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
 6821|   170k|    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) // FIXME: simply use _NoTitleBar ?
  ------------------
  |  Branch (6821:9): [True: 16.9k, False: 153k]
  |  Branch (6821:26): [True: 16.9k, False: 0]
  |  Branch (6821:63): [True: 16.9k, False: 0]
  ------------------
 6822|  16.9k|        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
 6823|   170k|    while (window->RootWindowForNav->ChildFlags & ImGuiChildFlags_NavFlattened)
  ------------------
  |  Branch (6823:12): [True: 0, False: 170k]
  ------------------
 6824|      0|    {
 6825|      0|        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6826|      0|        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
 6827|      0|    }
 6828|   170k|}
_ZN5ImGui23UpdateWindowSkipRefreshEP11ImGuiWindow:
 6833|   170k|{
 6834|   170k|    ImGuiContext& g = *GImGui;
 6835|   170k|    window->SkipRefresh = false;
 6836|   170k|    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasRefreshPolicy) == 0)
  ------------------
  |  Branch (6836:9): [True: 170k, False: 0]
  ------------------
 6837|   170k|        return;
 6838|      0|    if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_TryToAvoidRefresh)
  ------------------
  |  Branch (6838:9): [True: 0, False: 0]
  ------------------
 6839|      0|    {
 6840|       |        // FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
 6841|      0|        if (window->Appearing) // If currently appearing
  ------------------
  |  Branch (6841:13): [True: 0, False: 0]
  ------------------
 6842|      0|            return;
 6843|      0|        if (window->Hidden) // If was hidden (previous frame)
  ------------------
  |  Branch (6843:13): [True: 0, False: 0]
  ------------------
 6844|      0|            return;
 6845|      0|        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow && window->RootWindow == g.HoveredWindow->RootWindow)
  ------------------
  |  Branch (6845:13): [True: 0, False: 0]
  |  Branch (6845:92): [True: 0, False: 0]
  |  Branch (6845:111): [True: 0, False: 0]
  ------------------
 6846|      0|            return;
 6847|      0|        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow && window->RootWindow == g.NavWindow->RootWindow)
  ------------------
  |  Branch (6847:13): [True: 0, False: 0]
  |  Branch (6847:92): [True: 0, False: 0]
  |  Branch (6847:107): [True: 0, False: 0]
  ------------------
 6848|      0|            return;
 6849|      0|        window->DrawList = NULL;
 6850|      0|        window->SkipRefresh = true;
 6851|      0|    }
 6852|      0|}
_ZN5ImGui17FindBlockingModalEP11ImGuiWindow:
 6868|     80|{
 6869|     80|    ImGuiContext& g = *GImGui;
 6870|     80|    if (g.OpenPopupStack.Size <= 0)
  ------------------
  |  Branch (6870:9): [True: 80, False: 0]
  ------------------
 6871|     80|        return NULL;
 6872|       |
 6873|       |    // Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
 6874|      0|    for (ImGuiPopupData& popup_data : g.OpenPopupStack)
  ------------------
  |  Branch (6874:37): [True: 0, False: 0]
  ------------------
 6875|      0|    {
 6876|      0|        ImGuiWindow* popup_window = popup_data.Window;
 6877|      0|        if (popup_window == NULL || !(popup_window->Flags & ImGuiWindowFlags_Modal))
  ------------------
  |  Branch (6877:13): [True: 0, False: 0]
  |  Branch (6877:37): [True: 0, False: 0]
  ------------------
 6878|      0|            continue;
 6879|      0|        if (!popup_window->Active && !popup_window->WasActive)      // Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
  ------------------
  |  Branch (6879:13): [True: 0, False: 0]
  |  Branch (6879:38): [True: 0, False: 0]
  ------------------
 6880|      0|            continue;
 6881|      0|        if (window == NULL)                                         // FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
  ------------------
  |  Branch (6881:13): [True: 0, False: 0]
  ------------------
 6882|      0|            return popup_window;
 6883|      0|        if (IsWindowWithinBeginStackOf(window, popup_window))       // Window may be over modal
  ------------------
  |  Branch (6883:13): [True: 0, False: 0]
  ------------------
 6884|      0|            continue;
 6885|      0|        return popup_window;                                        // Place window right below first block modal
 6886|      0|    }
 6887|      0|    return NULL;
 6888|      0|}
_ZN5ImGui5BeginEPKcPbi:
 6898|   170k|{
 6899|   170k|    ImGuiContext& g = *GImGui;
 6900|   170k|    const ImGuiStyle& style = g.Style;
 6901|   170k|    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6902|   170k|    IM_ASSERT(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6903|   170k|    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6904|       |
 6905|       |    // Find or create
 6906|   170k|    ImGuiWindow* window = FindWindowByName(name);
 6907|   170k|    const bool window_just_created = (window == NULL);
 6908|   170k|    if (window_just_created)
  ------------------
  |  Branch (6908:9): [True: 3, False: 170k]
  ------------------
 6909|      3|        window = CreateNewWindow(name, flags);
 6910|       |
 6911|       |    // [DEBUG] Debug break requested by user
 6912|   170k|    if (g.DebugBreakInWindow == window->ID)
  ------------------
  |  Branch (6912:9): [True: 0, False: 170k]
  ------------------
 6913|      0|        IM_DEBUG_BREAK();
  ------------------
  |  |  316|      0|#define IM_DEBUG_BREAK()    __builtin_debugtrap()
  ------------------
 6914|       |
 6915|       |    // Automatically disable manual moving/resizing when NoInputs is set
 6916|   170k|    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
  ------------------
  |  Branch (6916:9): [True: 0, False: 170k]
  ------------------
 6917|      0|        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
 6918|       |
 6919|   170k|    const int current_frame = g.FrameCount;
 6920|   170k|    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
 6921|   170k|    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);
  ------------------
  |  Branch (6921:33): [True: 76.6k, False: 93.6k]
  |  Branch (6921:67): [True: 76.6k, False: 0]
  ------------------
 6922|       |
 6923|       |    // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
 6924|   170k|    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
 6925|   170k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (6925:9): [True: 0, False: 170k]
  ------------------
 6926|      0|    {
 6927|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 6928|      0|        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
 6929|      0|        window_just_activated_by_user |= (window != popup_ref.Window);
 6930|      0|    }
 6931|       |
 6932|       |    // Update Flags, LastFrameActive, BeginOrderXXX fields
 6933|   170k|    const bool window_was_appearing = window->Appearing;
 6934|   170k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6934:9): [True: 170k, False: 0]
  ------------------
 6935|   170k|    {
 6936|   170k|        UpdateWindowInFocusOrderList(window, window_just_created, flags);
 6937|   170k|        window->Appearing = window_just_activated_by_user;
 6938|   170k|        if (window->Appearing)
  ------------------
  |  Branch (6938:13): [True: 4, False: 170k]
  ------------------
 6939|      4|            SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6940|   170k|        window->FlagsPreviousFrame = window->Flags;
 6941|   170k|        window->Flags = (ImGuiWindowFlags)flags;
 6942|   170k|        window->ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : 0;
  ------------------
  |  Branch (6942:30): [True: 16.9k, False: 153k]
  ------------------
 6943|   170k|        window->LastFrameActive = current_frame;
 6944|   170k|        window->LastTimeActive = (float)g.Time;
 6945|   170k|        window->BeginOrderWithinParent = 0;
 6946|   170k|        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
 6947|   170k|    }
 6948|      0|    else
 6949|      0|    {
 6950|      0|        flags = window->Flags;
 6951|      0|    }
 6952|       |
 6953|       |    // Docking
 6954|       |    // (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
 6955|   170k|    IM_ASSERT(window->DockNode == NULL || window->DockNodeAsHost == NULL); // Cannot be both
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6956|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasDock)
  ------------------
  |  Branch (6956:9): [True: 0, False: 170k]
  ------------------
 6957|      0|        SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
 6958|   170k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (6958:9): [True: 170k, False: 0]
  ------------------
 6959|   170k|    {
 6960|   170k|        bool has_dock_node = (window->DockId != 0 || window->DockNode != NULL);
  ------------------
  |  Branch (6960:31): [True: 0, False: 170k]
  |  Branch (6960:54): [True: 0, False: 170k]
  ------------------
 6961|   170k|        bool new_auto_dock_node = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
  ------------------
  |  Branch (6961:35): [True: 170k, False: 0]
  |  Branch (6961:53): [True: 0, False: 170k]
  ------------------
 6962|   170k|        bool dock_node_was_visible = window->DockNodeIsVisible;
 6963|   170k|        bool dock_tab_was_visible = window->DockTabIsVisible;
 6964|   170k|        if (has_dock_node || new_auto_dock_node)
  ------------------
  |  Branch (6964:13): [True: 0, False: 170k]
  |  Branch (6964:30): [True: 0, False: 170k]
  ------------------
 6965|      0|        {
 6966|      0|            BeginDocked(window, p_open);
 6967|      0|            flags = window->Flags;
 6968|      0|            if (window->DockIsActive)
  ------------------
  |  Branch (6968:17): [True: 0, False: 0]
  ------------------
 6969|      0|            {
 6970|      0|                IM_ASSERT(window->DockNode != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6971|      0|                g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
 6972|      0|            }
 6973|       |
 6974|       |            // Amend the Appearing flag
 6975|      0|            if (window->DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window->Appearing && !window_was_appearing)
  ------------------
  |  Branch (6975:17): [True: 0, False: 0]
  |  Branch (6975:45): [True: 0, False: 0]
  |  Branch (6975:70): [True: 0, False: 0]
  |  Branch (6975:95): [True: 0, False: 0]
  |  Branch (6975:117): [True: 0, False: 0]
  ------------------
 6976|      0|            {
 6977|      0|                window->Appearing = true;
 6978|      0|                SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);
 6979|      0|            }
 6980|      0|        }
 6981|   170k|        else
 6982|   170k|        {
 6983|   170k|            window->DockIsActive = window->DockNodeIsVisible = window->DockTabIsVisible = false;
 6984|   170k|        }
 6985|   170k|    }
 6986|       |
 6987|       |    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
 6988|   170k|    ImGuiWindow* parent_window_in_stack = (window->DockIsActive && window->DockNode->HostWindow) ? window->DockNode->HostWindow : g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back().Window;
  ------------------
  |  Branch (6988:44): [True: 0, False: 170k]
  |  Branch (6988:68): [True: 0, False: 0]
  |  Branch (6988:131): [True: 76.6k, False: 93.6k]
  ------------------
 6989|   170k|    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
  ------------------
  |  Branch (6989:34): [True: 170k, False: 0]
  |  Branch (6989:62): [True: 16.9k, False: 153k]
  ------------------
 6990|   170k|    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6991|       |
 6992|       |    // We allow window memory to be compacted so recreate the base stack when needed.
 6993|   170k|    if (window->IDStack.Size == 0)
  ------------------
  |  Branch (6993:9): [True: 1, False: 170k]
  ------------------
 6994|      1|        window->IDStack.push_back(window->ID);
 6995|       |
 6996|       |    // Add to stack
 6997|   170k|    g.CurrentWindow = window;
 6998|   170k|    ImGuiWindowStackData window_stack_data;
 6999|   170k|    window_stack_data.Window = window;
 7000|   170k|    window_stack_data.ParentLastItemDataBackup = g.LastItemData;
 7001|   170k|    window_stack_data.StackSizesOnBegin.SetToContextState(&g);
 7002|   170k|    window_stack_data.DisabledOverrideReenable = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
 7003|   170k|    g.CurrentWindowStack.push_back(window_stack_data);
 7004|   170k|    if (flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (7004:9): [True: 0, False: 170k]
  ------------------
 7005|      0|        g.BeginMenuDepth++;
 7006|       |
 7007|       |    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
 7008|   170k|    if (first_begin_of_the_frame)
  ------------------
  |  Branch (7008:9): [True: 170k, False: 0]
  ------------------
 7009|   170k|    {
 7010|   170k|        UpdateWindowParentAndRootLinks(window, flags, parent_window);
 7011|   170k|        window->ParentWindowInBeginStack = parent_window_in_stack;
 7012|       |
 7013|       |        // Focus route
 7014|       |        // There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
 7015|       |        // Use for e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
 7016|   170k|        window->ParentWindowForFocusRoute = (window->RootWindow != window) ? parent_window_in_stack : NULL;
  ------------------
  |  Branch (7016:45): [True: 16.9k, False: 153k]
  ------------------
 7017|   170k|        if (window->ParentWindowForFocusRoute == NULL && window->DockNode != NULL)
  ------------------
  |  Branch (7017:13): [True: 153k, False: 16.9k]
  |  Branch (7017:58): [True: 0, False: 153k]
  ------------------
 7018|      0|            if (window->DockNode->MergedFlags & ImGuiDockNodeFlags_DockedWindowsInFocusRoute)
  ------------------
  |  Branch (7018:17): [True: 0, False: 0]
  ------------------
 7019|      0|                window->ParentWindowForFocusRoute = window->DockNode->HostWindow;
 7020|       |
 7021|       |        // Override with SetNextWindowClass() field or direct call to SetWindowParentWindowForFocusRoute()
 7022|   170k|        if (window->WindowClass.FocusRouteParentWindowId != 0)
  ------------------
  |  Branch (7022:13): [True: 0, False: 170k]
  ------------------
 7023|      0|        {
 7024|      0|            window->ParentWindowForFocusRoute = FindWindowByID(window->WindowClass.FocusRouteParentWindowId);
 7025|      0|            IM_ASSERT(window->ParentWindowForFocusRoute != 0); // Invalid value for FocusRouteParentWindowId.
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7026|      0|        }
 7027|   170k|    }
 7028|       |
 7029|       |    // Add to focus scope stack
 7030|   170k|    PushFocusScope((window->ChildFlags & ImGuiChildFlags_NavFlattened) ? g.CurrentFocusScopeId : window->ID);
  ------------------
  |  Branch (7030:20): [True: 0, False: 170k]
  ------------------
 7031|   170k|    window->NavRootFocusScopeId = g.CurrentFocusScopeId;
 7032|       |
 7033|       |    // Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]
 7034|   170k|    if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (7034:9): [True: 0, False: 170k]
  ------------------
 7035|      0|    {
 7036|      0|        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
 7037|      0|        popup_ref.Window = window;
 7038|      0|        popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
 7039|      0|        g.BeginPopupStack.push_back(popup_ref);
 7040|      0|        window->PopupId = popup_ref.PopupId;
 7041|      0|    }
 7042|       |
 7043|       |    // Process SetNextWindow***() calls
 7044|       |    // (FIXME: Consider splitting the HasXXX flags into X/Y components
 7045|   170k|    bool window_pos_set_by_api = false;
 7046|   170k|    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
 7047|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
  ------------------
  |  Branch (7047:9): [True: 0, False: 170k]
  ------------------
 7048|      0|    {
 7049|      0|        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
 7050|      0|        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
  ------------------
  |  Branch (7050:13): [True: 0, False: 0]
  |  Branch (7050:38): [True: 0, False: 0]
  ------------------
 7051|      0|        {
 7052|       |            // May be processed on the next frame if this is our first frame and we are measuring size
 7053|       |            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
 7054|      0|            window->SetWindowPosVal = g.NextWindowData.PosVal;
 7055|      0|            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
 7056|      0|            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 7057|      0|        }
 7058|      0|        else
 7059|      0|        {
 7060|      0|            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
 7061|      0|        }
 7062|      0|    }
 7063|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
  ------------------
  |  Branch (7063:9): [True: 93.6k, False: 76.6k]
  ------------------
 7064|  93.6k|    {
 7065|  93.6k|        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
  ------------------
  |  Branch (7065:36): [True: 16.9k, False: 76.6k]
  |  Branch (7065:106): [True: 16.9k, False: 0]
  ------------------
 7066|  93.6k|        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
  ------------------
  |  Branch (7066:36): [True: 16.9k, False: 76.6k]
  |  Branch (7066:106): [True: 16.9k, False: 1]
  ------------------
 7067|  93.6k|        if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0) // Axis-specific conditions for BeginChild()
  ------------------
  |  Branch (7067:13): [True: 0, False: 93.6k]
  |  Branch (7067:63): [True: 0, False: 0]
  ------------------
 7068|      0|            g.NextWindowData.SizeVal.x = window->SizeFull.x;
 7069|  93.6k|        if ((window->ChildFlags & ImGuiChildFlags_ResizeY) && (window->SetWindowSizeAllowFlags & ImGuiCond_FirstUseEver) == 0)
  ------------------
  |  Branch (7069:13): [True: 0, False: 93.6k]
  |  Branch (7069:63): [True: 0, False: 0]
  ------------------
 7070|      0|            g.NextWindowData.SizeVal.y = window->SizeFull.y;
 7071|  93.6k|        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
 7072|  93.6k|    }
 7073|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
  ------------------
  |  Branch (7073:9): [True: 0, False: 170k]
  ------------------
 7074|      0|    {
 7075|      0|        if (g.NextWindowData.ScrollVal.x >= 0.0f)
  ------------------
  |  Branch (7075:13): [True: 0, False: 0]
  ------------------
 7076|      0|        {
 7077|      0|            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
 7078|      0|            window->ScrollTargetCenterRatio.x = 0.0f;
 7079|      0|        }
 7080|      0|        if (g.NextWindowData.ScrollVal.y >= 0.0f)
  ------------------
  |  Branch (7080:13): [True: 0, False: 0]
  ------------------
 7081|      0|        {
 7082|      0|            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
 7083|      0|            window->ScrollTargetCenterRatio.y = 0.0f;
 7084|      0|        }
 7085|      0|    }
 7086|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
  ------------------
  |  Branch (7086:9): [True: 0, False: 170k]
  ------------------
 7087|      0|        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
 7088|   170k|    else if (first_begin_of_the_frame)
  ------------------
  |  Branch (7088:14): [True: 170k, False: 0]
  ------------------
 7089|   170k|        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
 7090|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasWindowClass)
  ------------------
  |  Branch (7090:9): [True: 0, False: 170k]
  ------------------
 7091|      0|        window->WindowClass = g.NextWindowData.WindowClass;
 7092|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
  ------------------
  |  Branch (7092:9): [True: 0, False: 170k]
  ------------------
 7093|      0|        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
 7094|   170k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
  ------------------
  |  Branch (7094:9): [True: 0, False: 170k]
  ------------------
 7095|      0|        FocusWindow(window);
 7096|   170k|    if (window->Appearing)
  ------------------
  |  Branch (7096:9): [True: 4, False: 170k]
  ------------------
 7097|      4|        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);
 7098|       |
 7099|       |    // [EXPERIMENTAL] Skip Refresh mode
 7100|   170k|    UpdateWindowSkipRefresh(window);
 7101|       |
 7102|       |    // Nested root windows (typically tooltips) override disabled state
 7103|   170k|    if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)
  ------------------
  |  Branch (7103:9): [True: 0, False: 170k]
  |  Branch (7103:55): [True: 0, False: 0]
  ------------------
 7104|      0|        BeginDisabledOverrideReenable();
 7105|       |
 7106|       |    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
 7107|   170k|    g.CurrentWindow = NULL;
 7108|       |
 7109|       |    // When reusing window again multiple times a frame, just append content (don't need to setup again)
 7110|   170k|    if (first_begin_of_the_frame && !window->SkipRefresh)
  ------------------
  |  Branch (7110:9): [True: 170k, False: 0]
  |  Branch (7110:37): [True: 170k, False: 0]
  ------------------
 7111|   170k|    {
 7112|       |        // Initialize
 7113|   170k|        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
  ------------------
  |  Branch (7113:46): [True: 16.9k, False: 153k]
  |  Branch (7113:88): [True: 0, False: 16.9k]
  ------------------
 7114|   170k|        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
 7115|   170k|        window->Active = true;
 7116|   170k|        window->HasCloseButton = (p_open != NULL);
 7117|   170k|        window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
 7118|   170k|        window->IDStack.resize(1);
 7119|   170k|        window->DrawList->_ResetForNewFrame();
 7120|   170k|        window->DC.CurrentTableIdx = -1;
 7121|   170k|        if (flags & ImGuiWindowFlags_DockNodeHost)
  ------------------
  |  Branch (7121:13): [True: 0, False: 170k]
  ------------------
 7122|      0|        {
 7123|      0|            window->DrawList->ChannelsSplit(2);
 7124|      0|            window->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
  ------------------
  |  | 1747|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 7125|      0|        }
 7126|       |
 7127|       |        // Restore buffer capacity when woken from a compacted state, to avoid
 7128|   170k|        if (window->MemoryCompacted)
  ------------------
  |  Branch (7128:13): [True: 1, False: 170k]
  ------------------
 7129|      1|            GcAwakeTransientWindowBuffers(window);
 7130|       |
 7131|       |        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
 7132|       |        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
 7133|   170k|        bool window_title_visible_elsewhere = false;
 7134|   170k|        if ((window->Viewport && window->Viewport->Window == window) || (window->DockIsActive))
  ------------------
  |  Branch (7134:14): [True: 170k, False: 3]
  |  Branch (7134:34): [True: 0, False: 170k]
  |  Branch (7134:73): [True: 0, False: 170k]
  ------------------
 7135|      0|            window_title_visible_elsewhere = true;
 7136|   170k|        else if (g.NavWindowingListWindow != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
  ------------------
  |  Branch (7136:18): [True: 0, False: 170k]
  |  Branch (7136:54): [True: 0, False: 0]
  ------------------
 7137|      0|            window_title_visible_elsewhere = true;
 7138|   170k|        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
  ------------------
  |  Branch (7138:13): [True: 0, False: 170k]
  |  Branch (7138:47): [True: 0, False: 0]
  |  Branch (7138:71): [True: 0, False: 0]
  ------------------
 7139|      0|        {
 7140|      0|            size_t buf_len = (size_t)window->NameBufLen;
 7141|      0|            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
 7142|      0|            window->NameBufLen = (int)buf_len;
 7143|      0|        }
 7144|       |
 7145|       |        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS
 7146|       |
 7147|       |        // Update contents size from last frame for auto-fitting (or use explicit size)
 7148|   170k|        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
 7149|       |
 7150|       |        // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
 7151|       |        // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
 7152|       |        // it has a single usage before this code block and may be set below before it is finally checked.
 7153|   170k|        if (window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (7153:13): [True: 11, False: 170k]
  ------------------
 7154|     11|            window->HiddenFramesCanSkipItems--;
 7155|   170k|        if (window->HiddenFramesCannotSkipItems > 0)
  ------------------
  |  Branch (7155:13): [True: 2, False: 170k]
  ------------------
 7156|      2|            window->HiddenFramesCannotSkipItems--;
 7157|   170k|        if (window->HiddenFramesForRenderOnly > 0)
  ------------------
  |  Branch (7157:13): [True: 0, False: 170k]
  ------------------
 7158|      0|            window->HiddenFramesForRenderOnly--;
 7159|       |
 7160|       |        // Hide new windows for one frame until they calculate their size
 7161|   170k|        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
  ------------------
  |  Branch (7161:13): [True: 3, False: 170k]
  |  Branch (7161:37): [True: 1, False: 2]
  |  Branch (7161:66): [True: 1, False: 1]
  ------------------
 7162|      2|            window->HiddenFramesCannotSkipItems = 1;
 7163|       |
 7164|       |        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
 7165|       |        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
 7166|   170k|        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
  ------------------
  |  Branch (7166:13): [True: 4, False: 170k]
  |  Branch (7166:46): [True: 0, False: 4]
  ------------------
 7167|      0|        {
 7168|      0|            window->HiddenFramesCannotSkipItems = 1;
 7169|      0|            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
  ------------------
  |  Branch (7169:17): [True: 0, False: 0]
  ------------------
 7170|      0|            {
 7171|      0|                if (!window_size_x_set_by_api)
  ------------------
  |  Branch (7171:21): [True: 0, False: 0]
  ------------------
 7172|      0|                    window->Size.x = window->SizeFull.x = 0.f;
 7173|      0|                if (!window_size_y_set_by_api)
  ------------------
  |  Branch (7173:21): [True: 0, False: 0]
  ------------------
 7174|      0|                    window->Size.y = window->SizeFull.y = 0.f;
 7175|      0|                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
 7176|      0|            }
 7177|      0|        }
 7178|       |
 7179|       |        // SELECT VIEWPORT
 7180|       |        // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.
 7181|       |
 7182|   170k|        WindowSelectViewport(window);
 7183|   170k|        SetCurrentViewport(window, window->Viewport);
 7184|   170k|        window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (7184:32): [True: 0, False: 170k]
  ------------------
 7185|   170k|        SetCurrentWindow(window);
 7186|   170k|        flags = window->Flags;
 7187|       |
 7188|       |        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
 7189|       |        // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.
 7190|       |
 7191|   170k|        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (7191:13): [True: 170k, False: 0]
  |  Branch (7191:38): [True: 16.9k, False: 153k]
  ------------------
 7192|  16.9k|            window->WindowBorderSize = style.ChildBorderSize;
 7193|   153k|        else
 7194|   153k|            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
  ------------------
  |  Branch (7194:41): [True: 0, False: 153k]
  |  Branch (7194:106): [True: 0, False: 0]
  ------------------
 7195|   170k|        window->WindowPadding = style.WindowPadding;
 7196|   170k|        if (!window->DockIsActive && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !(window->ChildFlags & ImGuiChildFlags_AlwaysUseWindowPadding) && window->WindowBorderSize == 0.0f)
  ------------------
  |  Branch (7196:13): [True: 170k, False: 0]
  |  Branch (7196:38): [True: 16.9k, False: 153k]
  |  Branch (7196:80): [True: 16.9k, False: 0]
  |  Branch (7196:117): [True: 16.9k, False: 0]
  |  Branch (7196:183): [True: 7.83k, False: 9.10k]
  ------------------
 7197|  7.83k|            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
  ------------------
  |  Branch (7197:50): [True: 0, False: 7.83k]
  ------------------
 7198|       |
 7199|       |        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
 7200|   170k|        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
 7201|   170k|        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
 7202|   170k|        window->TitleBarHeight = (flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : g.FontSize + g.Style.FramePadding.y * 2.0f;
  ------------------
  |  Branch (7202:34): [True: 16.9k, False: 153k]
  ------------------
 7203|   170k|        window->MenuBarHeight = (flags & ImGuiWindowFlags_MenuBar) ? window->DC.MenuBarOffset.y + g.FontSize + g.Style.FramePadding.y * 2.0f : 0.0f;
  ------------------
  |  Branch (7203:33): [True: 0, False: 170k]
  ------------------
 7204|       |
 7205|       |        // Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
 7206|       |        // Those flags will be altered further down in the function depending on more conditions.
 7207|   170k|        bool use_current_size_for_scrollbar_x = window_just_created;
 7208|   170k|        bool use_current_size_for_scrollbar_y = window_just_created;
 7209|   170k|        if (window_size_x_set_by_api && window->ContentSizeExplicit.x != 0.0f)
  ------------------
  |  Branch (7209:13): [True: 16.9k, False: 153k]
  |  Branch (7209:41): [True: 0, False: 16.9k]
  ------------------
 7210|      0|            use_current_size_for_scrollbar_x = true;
 7211|   170k|        if (window_size_y_set_by_api && window->ContentSizeExplicit.y != 0.0f) // #7252
  ------------------
  |  Branch (7211:13): [True: 16.9k, False: 153k]
  |  Branch (7211:41): [True: 0, False: 16.9k]
  ------------------
 7212|      0|            use_current_size_for_scrollbar_y = true;
 7213|       |
 7214|       |        // Collapse window by double-clicking on title bar
 7215|       |        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
 7216|   170k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse) && !window->DockIsActive)
  ------------------
  |  Branch (7216:13): [True: 153k, False: 16.9k]
  |  Branch (7216:55): [True: 153k, False: 0]
  |  Branch (7216:97): [True: 153k, False: 0]
  ------------------
 7217|   153k|        {
 7218|       |            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
 7219|   153k|            ImRect title_bar_rect = window->TitleBarRect();
 7220|   153k|            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max))
  ------------------
  |  Branch (7220:17): [True: 925, False: 152k]
  |  Branch (7220:46): [True: 925, False: 0]
  |  Branch (7220:66): [True: 829, False: 96]
  |  Branch (7220:99): [True: 384, False: 445]
  ------------------
 7221|    384|                if (g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey_MouseLeft) == ImGuiKeyOwner_NoOwner)
  ------------------
  |  | 1434|      2|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (7221:21): [True: 2, False: 382]
  |  Branch (7221:55): [True: 2, False: 0]
  ------------------
 7222|      2|                    window->WantCollapseToggle = true;
 7223|   153k|            if (window->WantCollapseToggle)
  ------------------
  |  Branch (7223:17): [True: 3, False: 153k]
  ------------------
 7224|      3|            {
 7225|      3|                window->Collapsed = !window->Collapsed;
 7226|      3|                if (!window->Collapsed)
  ------------------
  |  Branch (7226:21): [True: 1, False: 2]
  ------------------
 7227|      1|                    use_current_size_for_scrollbar_y = true;
 7228|      3|                MarkIniSettingsDirty(window);
 7229|      3|            }
 7230|   153k|        }
 7231|  16.9k|        else
 7232|  16.9k|        {
 7233|  16.9k|            window->Collapsed = false;
 7234|  16.9k|        }
 7235|   170k|        window->WantCollapseToggle = false;
 7236|       |
 7237|       |        // SIZE
 7238|       |
 7239|       |        // Outer Decoration Sizes
 7240|       |        // (we need to clear ScrollbarSize immediately as CalcWindowAutoFitSize() needs it and can be called from other locations).
 7241|   170k|        const ImVec2 scrollbar_sizes_from_last_frame = window->ScrollbarSizes;
 7242|   170k|        window->DecoOuterSizeX1 = 0.0f;
 7243|   170k|        window->DecoOuterSizeX2 = 0.0f;
 7244|   170k|        window->DecoOuterSizeY1 = window->TitleBarHeight + window->MenuBarHeight;
 7245|   170k|        window->DecoOuterSizeY2 = 0.0f;
 7246|   170k|        window->ScrollbarSizes = ImVec2(0.0f, 0.0f);
 7247|       |
 7248|       |        // Calculate auto-fit size, handle automatic resize
 7249|   170k|        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
 7250|   170k|        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
  ------------------
  |  Branch (7250:13): [True: 0, False: 170k]
  |  Branch (7250:60): [True: 0, False: 0]
  ------------------
 7251|      0|        {
 7252|       |            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
 7253|      0|            if (!window_size_x_set_by_api)
  ------------------
  |  Branch (7253:17): [True: 0, False: 0]
  ------------------
 7254|      0|            {
 7255|      0|                window->SizeFull.x = size_auto_fit.x;
 7256|      0|                use_current_size_for_scrollbar_x = true;
 7257|      0|            }
 7258|      0|            if (!window_size_y_set_by_api)
  ------------------
  |  Branch (7258:17): [True: 0, False: 0]
  ------------------
 7259|      0|            {
 7260|      0|                window->SizeFull.y = size_auto_fit.y;
 7261|      0|                use_current_size_for_scrollbar_y = true;
 7262|      0|            }
 7263|      0|        }
 7264|   170k|        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (7264:18): [True: 2, False: 170k]
  |  Branch (7264:48): [True: 2, False: 170k]
  ------------------
 7265|      4|        {
 7266|       |            // Auto-fit may only grow window during the first few frames
 7267|       |            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
 7268|      4|            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
  ------------------
  |  Branch (7268:17): [True: 2, False: 2]
  |  Branch (7268:46): [True: 2, False: 0]
  ------------------
 7269|      2|            {
 7270|      2|                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
  ------------------
  |  Branch (7270:38): [True: 2, False: 0]
  ------------------
 7271|      2|                use_current_size_for_scrollbar_x = true;
 7272|      2|            }
 7273|      4|            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
  ------------------
  |  Branch (7273:17): [True: 3, False: 1]
  |  Branch (7273:46): [True: 3, False: 0]
  ------------------
 7274|      3|            {
 7275|      3|                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
  ------------------
  |  Branch (7275:38): [True: 2, False: 1]
  ------------------
 7276|      3|                use_current_size_for_scrollbar_y = true;
 7277|      3|            }
 7278|      4|            if (!window->Collapsed)
  ------------------
  |  Branch (7278:17): [True: 4, False: 0]
  ------------------
 7279|      4|                MarkIniSettingsDirty(window);
 7280|      4|        }
 7281|       |
 7282|       |        // Apply minimum/maximum window size constraints and final size
 7283|   170k|        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
 7284|   170k|        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;
  ------------------
  |  Branch (7284:24): [True: 59.7k, False: 110k]
  |  Branch (7284:45): [True: 59.7k, False: 0]
  ------------------
 7285|       |
 7286|       |        // POSITION
 7287|       |
 7288|       |        // Popup latch its initial position, will position itself when it appears next frame
 7289|   170k|        if (window_just_activated_by_user)
  ------------------
  |  Branch (7289:13): [True: 4, False: 170k]
  ------------------
 7290|      4|        {
 7291|      4|            window->AutoPosLastDirection = ImGuiDir_None;
 7292|      4|            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api) // FIXME: BeginPopup() could use SetNextWindowPos()
  ------------------
  |  Branch (7292:17): [True: 0, False: 4]
  |  Branch (7292:58): [True: 0, False: 0]
  |  Branch (7292:95): [True: 0, False: 0]
  ------------------
 7293|      0|                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
 7294|      4|        }
 7295|       |
 7296|       |        // Position child window
 7297|   170k|        if (flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (7297:13): [True: 16.9k, False: 153k]
  ------------------
 7298|  16.9k|        {
 7299|  16.9k|            IM_ASSERT(parent_window && parent_window->Active);
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7300|  16.9k|            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
 7301|  16.9k|            parent_window->DC.ChildWindows.push_back(window);
 7302|  16.9k|            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (7302:17): [True: 16.9k, False: 0]
  |  Branch (7302:54): [True: 16.9k, False: 0]
  |  Branch (7302:80): [True: 16.9k, False: 0]
  ------------------
 7303|  16.9k|                window->Pos = parent_window->DC.CursorPos;
 7304|  16.9k|        }
 7305|       |
 7306|   170k|        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
  ------------------
  |  Branch (7306:45): [True: 0, False: 170k]
  |  Branch (7306:85): [True: 0, False: 0]
  ------------------
 7307|   170k|        if (window_pos_with_pivot)
  ------------------
  |  Branch (7307:13): [True: 0, False: 170k]
  ------------------
 7308|      0|            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
 7309|   170k|        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
  ------------------
  |  Branch (7309:18): [True: 0, False: 170k]
  ------------------
 7310|      0|            window->Pos = FindBestWindowPosForPopup(window);
 7311|   170k|        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
  ------------------
  |  Branch (7311:18): [True: 0, False: 170k]
  |  Branch (7311:59): [True: 0, False: 0]
  |  Branch (7311:85): [True: 0, False: 0]
  ------------------
 7312|      0|            window->Pos = FindBestWindowPosForPopup(window);
 7313|   170k|        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
  ------------------
  |  Branch (7313:18): [True: 0, False: 170k]
  |  Branch (7313:61): [True: 0, False: 0]
  |  Branch (7313:87): [True: 0, False: 0]
  ------------------
 7314|      0|            window->Pos = FindBestWindowPosForPopup(window);
 7315|       |
 7316|       |        // Late create viewport if we don't fit within our current host viewport.
 7317|   170k|        if (window->ViewportAllowPlatformMonitorExtend >= 0 && !window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_IsMinimized))
  ------------------
  |  Branch (7317:13): [True: 0, False: 170k]
  |  Branch (7317:64): [True: 0, False: 0]
  |  Branch (7317:90): [True: 0, False: 0]
  ------------------
 7318|      0|            if (!window->Viewport->GetMainRect().Contains(window->Rect()))
  ------------------
  |  Branch (7318:17): [True: 0, False: 0]
  ------------------
 7319|      0|            {
 7320|       |                // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
 7321|       |                //ImGuiViewport* old_viewport = window->Viewport;
 7322|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
 7323|       |
 7324|       |                // FIXME-DPI
 7325|       |                //IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
 7326|      0|                SetCurrentViewport(window, window->Viewport);
 7327|      0|                window->FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleFonts) ? window->Viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (7327:40): [True: 0, False: 0]
  ------------------
 7328|      0|                SetCurrentWindow(window);
 7329|      0|            }
 7330|       |
 7331|   170k|        if (window->ViewportOwned)
  ------------------
  |  Branch (7331:13): [True: 0, False: 170k]
  ------------------
 7332|      0|            WindowSyncOwnedViewport(window, parent_window_in_stack);
 7333|       |
 7334|       |        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
 7335|       |        // When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
 7336|   170k|        ImRect viewport_rect(window->Viewport->GetMainRect());
 7337|   170k|        ImRect viewport_work_rect(window->Viewport->GetWorkRect());
 7338|   170k|        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
 7339|   170k|        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);
 7340|       |
 7341|       |        // Clamp position/size so window stays visible within its viewport or monitor
 7342|       |        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
 7343|       |        // FIXME: Similar to code in GetWindowAllowedExtentRect()
 7344|   170k|        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (7344:13): [True: 170k, False: 0]
  |  Branch (7344:39): [True: 153k, False: 16.9k]
  ------------------
 7345|   153k|        {
 7346|   153k|            if (!window->ViewportOwned && viewport_rect.GetWidth() > 0 && viewport_rect.GetHeight() > 0.0f)
  ------------------
  |  Branch (7346:17): [True: 153k, False: 0]
  |  Branch (7346:43): [True: 153k, False: 0]
  |  Branch (7346:75): [True: 153k, False: 0]
  ------------------
 7347|   153k|            {
 7348|   153k|                ClampWindowPos(window, visibility_rect);
 7349|   153k|            }
 7350|      0|            else if (window->ViewportOwned && g.PlatformIO.Monitors.Size > 0)
  ------------------
  |  Branch (7350:22): [True: 0, False: 0]
  |  Branch (7350:47): [True: 0, False: 0]
  ------------------
 7351|      0|            {
 7352|      0|                if (g.MovingWindow != NULL && window->RootWindowDockTree == g.MovingWindow->RootWindowDockTree)
  ------------------
  |  Branch (7352:21): [True: 0, False: 0]
  |  Branch (7352:47): [True: 0, False: 0]
  ------------------
 7353|      0|                {
 7354|       |                    // While moving windows we allow them to straddle monitors (#7299, #3071)
 7355|      0|                    visibility_rect = g.PlatformMonitorsFullWorkRect;
 7356|      0|                }
 7357|      0|                else
 7358|      0|                {
 7359|       |                    // When not moving ensure visible in its monitor
 7360|       |                    // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
 7361|      0|                    const ImGuiPlatformMonitor* monitor = GetViewportPlatformMonitor(window->Viewport);
 7362|      0|                    visibility_rect = ImRect(monitor->WorkPos, monitor->WorkPos + monitor->WorkSize);
 7363|      0|                }
 7364|      0|                visibility_rect.Expand(-visibility_padding);
 7365|      0|                ClampWindowPos(window, visibility_rect);
 7366|      0|            }
 7367|   153k|        }
 7368|   170k|        window->Pos = ImTrunc(window->Pos);
 7369|       |
 7370|       |        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
 7371|       |        // Large values tend to lead to variety of artifacts and are not recommended.
 7372|   170k|        if (window->ViewportOwned || window->DockIsActive)
  ------------------
  |  Branch (7372:13): [True: 0, False: 170k]
  |  Branch (7372:38): [True: 0, False: 170k]
  ------------------
 7373|      0|            window->WindowRounding = 0.0f;
 7374|   170k|        else
 7375|   170k|            window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
  ------------------
  |  Branch (7375:38): [True: 16.9k, False: 153k]
  |  Branch (7375:102): [True: 0, False: 153k]
  |  Branch (7375:138): [True: 0, False: 0]
  ------------------
 7376|       |
 7377|       |        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
 7378|       |        //if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
 7379|       |        //    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);
 7380|       |
 7381|       |        // Apply window focus (new and reactivated windows are moved to front)
 7382|   170k|        bool want_focus = false;
 7383|   170k|        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
  ------------------
  |  Branch (7383:13): [True: 4, False: 170k]
  |  Branch (7383:46): [True: 4, False: 0]
  ------------------
 7384|      4|        {
 7385|      4|            if (flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (7385:17): [True: 0, False: 4]
  ------------------
 7386|      0|                want_focus = true;
 7387|      4|            else if ((window->DockIsActive || (flags & ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_Tooltip))
  ------------------
  |  Branch (7387:23): [True: 0, False: 4]
  |  Branch (7387:47): [True: 2, False: 2]
  |  Branch (7387:95): [True: 2, False: 0]
  ------------------
 7388|      2|                want_focus = true;
 7389|      4|        }
 7390|       |
 7391|       |        // [Test Engine] Register whole window in the item system (before submitting further decorations)
 7392|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 7393|       |        if (g.TestEngineHookItems)
 7394|       |        {
 7395|       |            IM_ASSERT(window->IDStack.Size == 1);
 7396|       |            window->IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
 7397|       |            IMGUI_TEST_ENGINE_ITEM_ADD(window->ID, window->Rect(), NULL);
 7398|       |            IMGUI_TEST_ENGINE_ITEM_INFO(window->ID, window->Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
 7399|       |            window->IDStack.Size = 1;
 7400|       |        }
 7401|       |#endif
 7402|       |
 7403|       |        // Decide if we are going to handle borders and resize grips
 7404|   170k|        const bool handle_borders_and_resize_grips = (window->DockNodeAsHost || !window->DockIsActive);
  ------------------
  |  Branch (7404:55): [True: 0, False: 170k]
  |  Branch (7404:81): [True: 170k, False: 0]
  ------------------
 7405|       |
 7406|       |        // Handle manual resize: Resize Grips, Borders, Gamepad
 7407|   170k|        int border_hovered = -1, border_held = -1;
 7408|   170k|        ImU32 resize_grip_col[4] = {};
 7409|   170k|        const int resize_grip_count = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
  ------------------
  |  Branch (7409:40): [True: 16.9k, False: 153k]
  |  Branch (7409:82): [True: 16.9k, False: 0]
  |  Branch (7409:123): [True: 153k, False: 0]
  ------------------
 7410|   170k|        const float resize_grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  287|   170k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 7411|   170k|        if (handle_borders_and_resize_grips && !window->Collapsed)
  ------------------
  |  Branch (7411:13): [True: 170k, False: 0]
  |  Branch (7411:48): [True: 110k, False: 59.7k]
  ------------------
 7412|   110k|            if (int auto_fit_mask = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
  ------------------
  |  Branch (7412:21): [True: 0, False: 110k]
  ------------------
 7413|      0|            {
 7414|      0|                if (auto_fit_mask & (1 << ImGuiAxis_X))
  ------------------
  |  Branch (7414:21): [True: 0, False: 0]
  ------------------
 7415|      0|                    use_current_size_for_scrollbar_x = true;
 7416|      0|                if (auto_fit_mask & (1 << ImGuiAxis_Y))
  ------------------
  |  Branch (7416:21): [True: 0, False: 0]
  ------------------
 7417|      0|                    use_current_size_for_scrollbar_y = true;
 7418|      0|            }
 7419|   170k|        window->ResizeBorderHovered = (signed char)border_hovered;
 7420|   170k|        window->ResizeBorderHeld = (signed char)border_held;
 7421|       |
 7422|       |        // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
 7423|   170k|        if (window->ViewportOwned)
  ------------------
  |  Branch (7423:13): [True: 0, False: 170k]
  ------------------
 7424|      0|        {
 7425|      0|            if (!window->Viewport->PlatformRequestMove)
  ------------------
  |  Branch (7425:17): [True: 0, False: 0]
  ------------------
 7426|      0|                window->Viewport->Pos = window->Pos;
 7427|      0|            if (!window->Viewport->PlatformRequestResize)
  ------------------
  |  Branch (7427:17): [True: 0, False: 0]
  ------------------
 7428|      0|                window->Viewport->Size = window->Size;
 7429|      0|            window->Viewport->UpdateWorkRect();
 7430|      0|            viewport_rect = window->Viewport->GetMainRect();
 7431|      0|        }
 7432|       |
 7433|       |        // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
 7434|   170k|        window->ViewportPos = window->Viewport->Pos;
 7435|       |
 7436|       |        // SCROLLBAR VISIBILITY
 7437|       |
 7438|       |        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
 7439|   170k|        if (!window->Collapsed)
  ------------------
  |  Branch (7439:13): [True: 110k, False: 59.7k]
  ------------------
 7440|   110k|        {
 7441|       |            // When reading the current size we need to read it after size constraints have been applied.
 7442|       |            // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
 7443|       |            // And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
 7444|   110k|            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2));
 7445|   110k|            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + scrollbar_sizes_from_last_frame;
 7446|   110k|            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
  ------------------
  |  Branch (7446:50): [True: 3, False: 110k]
  ------------------
 7447|   110k|            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
  ------------------
  |  Branch (7447:43): [True: 4, False: 110k]
  ------------------
 7448|   110k|            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
  ------------------
  |  Branch (7448:43): [True: 5, False: 110k]
  ------------------
 7449|       |            //bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
 7450|   110k|            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
  ------------------
  |  Branch (7450:34): [True: 0, False: 110k]
  |  Branch (7450:89): [True: 15.9k, False: 94.6k]
  |  Branch (7450:148): [True: 15.9k, False: 0]
  ------------------
 7451|   110k|            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
  ------------------
  |  Branch (7451:34): [True: 16.9k, False: 93.6k]
  |  Branch (7451:91): [True: 1.65k, False: 91.9k]
  |  Branch (7451:149): [True: 1.55k, False: 92.0k]
  |  Branch (7451:202): [True: 1.65k, False: 0]
  |  Branch (7451:245): [True: 0, False: 1.65k]
  ------------------
 7452|   110k|            if (window->ScrollbarX && !window->ScrollbarY)
  ------------------
  |  Branch (7452:17): [True: 16.9k, False: 93.6k]
  |  Branch (7452:39): [True: 2.58k, False: 14.3k]
  ------------------
 7453|  2.58k|                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
  ------------------
  |  Branch (7453:38): [True: 1.75k, False: 827]
  |  Branch (7453:119): [True: 1.75k, False: 0]
  ------------------
 7454|   110k|            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
  ------------------
  |  Branch (7454:45): [True: 17.6k, False: 92.9k]
  |  Branch (7454:94): [True: 16.9k, False: 93.6k]
  ------------------
 7455|       |
 7456|       |            // Amend the partially filled window->DecorationXXX values.
 7457|   110k|            window->DecoOuterSizeX2 += window->ScrollbarSizes.x;
 7458|   110k|            window->DecoOuterSizeY2 += window->ScrollbarSizes.y;
 7459|   110k|        }
 7460|       |
 7461|       |        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
 7462|       |        // Update various regions. Variables they depend on should be set above in this function.
 7463|       |        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.
 7464|       |
 7465|       |        // Outer rectangle
 7466|       |        // Not affected by window border size. Used by:
 7467|       |        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
 7468|       |        // - Begin() initial clipping rect for drawing window background and borders.
 7469|       |        // - Begin() clipping whole child
 7470|   170k|        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
  ------------------
  |  Branch (7470:35): [True: 16.9k, False: 153k]
  |  Branch (7470:77): [True: 16.9k, False: 0]
  |  Branch (7470:114): [True: 16.9k, False: 0]
  ------------------
 7471|   170k|        const ImRect outer_rect = window->Rect();
 7472|   170k|        const ImRect title_bar_rect = window->TitleBarRect();
 7473|   170k|        window->OuterRectClipped = outer_rect;
 7474|   170k|        if (window->DockIsActive)
  ------------------
  |  Branch (7474:13): [True: 0, False: 170k]
  ------------------
 7475|      0|            window->OuterRectClipped.Min.y += window->TitleBarHeight;
 7476|   170k|        window->OuterRectClipped.ClipWith(host_rect);
 7477|       |
 7478|       |        // Inner rectangle
 7479|       |        // Not affected by window border size. Used by:
 7480|       |        // - InnerClipRect
 7481|       |        // - ScrollToRectEx()
 7482|       |        // - NavUpdatePageUpPageDown()
 7483|       |        // - Scrollbar()
 7484|   170k|        window->InnerRect.Min.x = window->Pos.x + window->DecoOuterSizeX1;
 7485|   170k|        window->InnerRect.Min.y = window->Pos.y + window->DecoOuterSizeY1;
 7486|   170k|        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->DecoOuterSizeX2;
 7487|   170k|        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->DecoOuterSizeY2;
 7488|       |
 7489|       |        // Inner clipping rectangle.
 7490|       |        // - Extend a outside of normal work region up to borders.
 7491|       |        // - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
 7492|       |        // - It also makes clipped items be more noticeable.
 7493|       |        // - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
 7494|       |        // - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
 7495|       |        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
 7496|       |        // Affected by window/frame border size. Used by:
 7497|       |        // - Begin() initial clip rect
 7498|   170k|        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
  ------------------
  |  Branch (7498:35): [True: 0, False: 170k]
  |  Branch (7498:73): [True: 153k, False: 16.9k]
  ------------------
 7499|   170k|        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + window->WindowBorderSize);
 7500|   170k|        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
 7501|   170k|        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - window->WindowBorderSize);
 7502|   170k|        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
 7503|   170k|        window->InnerClipRect.ClipWithFull(host_rect);
 7504|       |
 7505|       |        // Default item width. Make it proportional to window size if window manually resizes
 7506|   170k|        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
  ------------------
  |  Branch (7506:13): [True: 170k, False: 0]
  |  Branch (7506:38): [True: 170k, False: 0]
  |  Branch (7506:77): [True: 170k, False: 0]
  ------------------
 7507|   170k|            window->ItemWidthDefault = ImTrunc(window->Size.x * 0.65f);
 7508|      0|        else
 7509|      0|            window->ItemWidthDefault = ImTrunc(g.FontSize * 16.0f);
 7510|       |
 7511|       |        // SCROLLING
 7512|       |
 7513|       |        // Lock down maximum scrolling
 7514|       |        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
 7515|       |        // for right/bottom aligned items without creating a scrollbar.
 7516|   170k|        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
 7517|   170k|        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());
 7518|       |
 7519|       |        // Apply scrolling
 7520|   170k|        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
 7521|   170k|        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
 7522|   170k|        window->DecoInnerSizeX1 = window->DecoInnerSizeY1 = 0.0f;
 7523|       |
 7524|       |        // DRAWING
 7525|       |
 7526|       |        // Setup draw list and outer clipping rectangle
 7527|   170k|        IM_ASSERT(window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0);
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7528|   170k|        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
 7529|   170k|        PushClipRect(host_rect.Min, host_rect.Max, false);
 7530|       |
 7531|       |        // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
 7532|       |        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
 7533|       |        // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
 7534|   170k|        const bool is_undocked_or_docked_visible = !window->DockIsActive || window->DockTabIsVisible;
  ------------------
  |  Branch (7534:52): [True: 170k, False: 0]
  |  Branch (7534:77): [True: 0, False: 0]
  ------------------
 7535|   170k|        if (is_undocked_or_docked_visible)
  ------------------
  |  Branch (7535:13): [True: 170k, False: 0]
  ------------------
 7536|   170k|        {
 7537|   170k|            bool render_decorations_in_parent = false;
 7538|   170k|            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
  ------------------
  |  Branch (7538:17): [True: 16.9k, False: 153k]
  |  Branch (7538:59): [True: 16.9k, False: 0]
  |  Branch (7538:96): [True: 16.9k, False: 0]
  ------------------
 7539|  16.9k|            {
 7540|       |                // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
 7541|       |                // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
 7542|  16.9k|                ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : NULL;
  ------------------
  |  Branch (7542:47): [True: 0, False: 16.9k]
  ------------------
 7543|  16.9k|                bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
  ------------------
  |  Branch (7543:51): [True: 0, False: 16.9k]
  ------------------
 7544|  16.9k|                bool parent_is_empty = (parent_window->DrawList->VtxBuffer.Size == 0);
 7545|  16.9k|                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && !parent_is_empty && !previous_child_overlapping)
  ------------------
  |  Branch (7545:21): [True: 16.9k, False: 0]
  |  Branch (7545:74): [True: 16.9k, False: 0]
  |  Branch (7545:94): [True: 16.9k, False: 0]
  ------------------
 7546|  16.9k|                    render_decorations_in_parent = true;
 7547|  16.9k|            }
 7548|   170k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (7548:17): [True: 16.9k, False: 153k]
  ------------------
 7549|  16.9k|                window->DrawList = parent_window->DrawList;
 7550|       |
 7551|       |            // Handle title bar, scrollbar, resize grips and resize borders
 7552|   170k|            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
  ------------------
  |  Branch (7552:54): [True: 0, False: 170k]
  ------------------
 7553|   170k|            const bool title_bar_is_highlight = want_focus || (window_to_highlight && (window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight || (window->DockNode && window->DockNode == window_to_highlight->DockNode)));
  ------------------
  |  Branch (7553:49): [True: 2, False: 170k]
  |  Branch (7553:64): [True: 22.3k, False: 148k]
  |  Branch (7553:88): [True: 14.7k, False: 7.56k]
  |  Branch (7553:186): [True: 0, False: 7.56k]
  |  Branch (7553:206): [True: 0, False: 0]
  ------------------
 7554|   170k|            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);
 7555|       |
 7556|   170k|            if (render_decorations_in_parent)
  ------------------
  |  Branch (7556:17): [True: 16.9k, False: 153k]
  ------------------
 7557|  16.9k|                window->DrawList = &window->DrawListInst;
 7558|   170k|        }
 7559|       |
 7560|       |        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)
 7561|       |
 7562|       |        // Work rectangle.
 7563|       |        // Affected by window padding and border size. Used by:
 7564|       |        // - Columns() for right-most edge
 7565|       |        // - TreeNode(), CollapsingHeader() for right-most edge
 7566|       |        // - BeginTabBar() for right-most edge
 7567|   170k|        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
  ------------------
  |  Branch (7567:40): [True: 170k, False: 0]
  |  Branch (7567:83): [True: 16.9k, False: 153k]
  ------------------
 7568|   170k|        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
 7569|   170k|        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (7569:41): [True: 0, False: 170k]
  |  Branch (7569:119): [True: 16.9k, False: 153k]
  ------------------
 7570|   170k|        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (7570:41): [True: 0, False: 170k]
  |  Branch (7570:119): [True: 170k, False: 0]
  ------------------
 7571|   170k|        window->WorkRect.Min.x = ImTrunc(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
 7572|   170k|        window->WorkRect.Min.y = ImTrunc(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
 7573|   170k|        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
 7574|   170k|        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
 7575|   170k|        window->ParentWorkRect = window->WorkRect;
 7576|       |
 7577|       |        // [LEGACY] Content Region
 7578|       |        // FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
 7579|       |        // Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
 7580|       |        // Used by:
 7581|       |        // - Mouse wheel scrolling + many other things
 7582|   170k|        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x + window->DecoOuterSizeX1;
 7583|   170k|        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->DecoOuterSizeY1;
 7584|   170k|        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - (window->DecoOuterSizeX1 + window->DecoOuterSizeX2)));
  ------------------
  |  Branch (7584:78): [True: 0, False: 170k]
  ------------------
 7585|   170k|        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - (window->DecoOuterSizeY1 + window->DecoOuterSizeY2)));
  ------------------
  |  Branch (7585:78): [True: 0, False: 170k]
  ------------------
 7586|       |
 7587|       |        // Setup drawing context
 7588|       |        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
 7589|   170k|        window->DC.Indent.x = window->DecoOuterSizeX1 + window->WindowPadding.x - window->Scroll.x;
 7590|   170k|        window->DC.GroupOffset.x = 0.0f;
 7591|   170k|        window->DC.ColumnsOffset.x = 0.0f;
 7592|       |
 7593|       |        // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
 7594|       |        // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
 7595|   170k|        double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DecoOuterSizeX1 + window->DC.ColumnsOffset.x;
 7596|   170k|        double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + window->DecoOuterSizeY1;
 7597|   170k|        window->DC.CursorStartPos  = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
 7598|   170k|        window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
 7599|   170k|        window->DC.CursorPos = window->DC.CursorStartPos;
 7600|   170k|        window->DC.CursorPosPrevLine = window->DC.CursorPos;
 7601|   170k|        window->DC.CursorMaxPos = window->DC.CursorStartPos;
 7602|   170k|        window->DC.IdealMaxPos = window->DC.CursorStartPos;
 7603|   170k|        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
 7604|   170k|        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
 7605|   170k|        window->DC.IsSameLine = window->DC.IsSetPos = false;
 7606|       |
 7607|   170k|        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 7608|   170k|        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
 7609|   170k|        window->DC.NavLayersActiveMaskNext = 0x00;
 7610|   170k|        window->DC.NavIsScrollPushableX = true;
 7611|   170k|        window->DC.NavHideHighlightOneFrame = false;
 7612|   170k|        window->DC.NavWindowHasScrollY = (window->ScrollMax.y > 0.0f);
 7613|       |
 7614|   170k|        window->DC.MenuBarAppending = false;
 7615|   170k|        window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
 7616|   170k|        window->DC.TreeDepth = 0;
 7617|   170k|        window->DC.TreeJumpToParentOnPopMask = 0x00;
 7618|   170k|        window->DC.ChildWindows.resize(0);
 7619|   170k|        window->DC.StateStorage = &window->StateStorage;
 7620|   170k|        window->DC.CurrentColumns = NULL;
 7621|   170k|        window->DC.LayoutType = ImGuiLayoutType_Vertical;
 7622|   170k|        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
  ------------------
  |  Branch (7622:39): [True: 16.9k, False: 153k]
  ------------------
 7623|       |
 7624|   170k|        window->DC.ItemWidth = window->ItemWidthDefault;
 7625|   170k|        window->DC.TextWrapPos = -1.0f; // disabled
 7626|   170k|        window->DC.ItemWidthStack.resize(0);
 7627|   170k|        window->DC.TextWrapPosStack.resize(0);
 7628|   170k|        if (flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (7628:13): [True: 0, False: 170k]
  ------------------
 7629|      0|            window->DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_ModalWindowDimBg));
 7630|       |
 7631|   170k|        if (window->AutoFitFramesX > 0)
  ------------------
  |  Branch (7631:13): [True: 2, False: 170k]
  ------------------
 7632|      2|            window->AutoFitFramesX--;
 7633|   170k|        if (window->AutoFitFramesY > 0)
  ------------------
  |  Branch (7633:13): [True: 4, False: 170k]
  ------------------
 7634|      4|            window->AutoFitFramesY--;
 7635|       |
 7636|       |        // Clear SetNextWindowXXX data (can aim to move this higher in the function)
 7637|   170k|        g.NextWindowData.ClearFlags();
 7638|       |
 7639|       |        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
 7640|       |        // We ImGuiFocusRequestFlags_UnlessBelowModal to:
 7641|       |        // - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
 7642|       |        // - Position window behind the modal that is not a begin-parent of this window.
 7643|   170k|        if (want_focus)
  ------------------
  |  Branch (7643:13): [True: 2, False: 170k]
  ------------------
 7644|      2|            FocusWindow(window, ImGuiFocusRequestFlags_UnlessBelowModal);
 7645|   170k|        if (want_focus && window == g.NavWindow)
  ------------------
  |  Branch (7645:13): [True: 2, False: 170k]
  |  Branch (7645:27): [True: 2, False: 0]
  ------------------
 7646|      2|            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
 7647|       |
 7648|       |        // Close requested by platform window (apply to all windows in this viewport)
 7649|   170k|        if (p_open != NULL && window->Viewport->PlatformRequestClose && window->Viewport != GetMainViewport())
  ------------------
  |  Branch (7649:13): [True: 0, False: 170k]
  |  Branch (7649:31): [True: 0, False: 0]
  |  Branch (7649:73): [True: 0, False: 0]
  ------------------
 7650|      0|        {
 7651|      0|            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' closed by PlatformRequestClose\n", window->Name);
  ------------------
  |  |  254|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (254:50): [True: 0, False: 0]
  |  |  |  Branch (254:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7652|      0|            *p_open = false;
 7653|      0|            g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
 7654|      0|        }
 7655|       |
 7656|       |        // Title bar
 7657|   170k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (7657:13): [True: 153k, False: 16.9k]
  |  Branch (7657:55): [True: 153k, False: 0]
  ------------------
 7658|   153k|            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);
 7659|       |
 7660|       |        // Clear hit test shape every frame
 7661|   170k|        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
 7662|       |
 7663|       |        // Pressing CTRL+C while holding on a window copy its content to the clipboard
 7664|       |        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
 7665|       |        // Maybe we can support CTRL+C on every element?
 7666|       |        /*
 7667|       |        //if (g.NavWindow == window && g.ActiveId == 0)
 7668|       |        if (g.ActiveId == window->MoveId)
 7669|       |            if (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_C))
 7670|       |                LogToClipboard();
 7671|       |        */
 7672|       |
 7673|   170k|        if (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable)
  ------------------
  |  Branch (7673:13): [True: 170k, False: 0]
  ------------------
 7674|   170k|        {
 7675|       |            // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
 7676|       |            // We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
 7677|   170k|            if (g.MovingWindow == window && (window->RootWindowDockTree->Flags & ImGuiWindowFlags_NoDocking) == 0)
  ------------------
  |  Branch (7677:17): [True: 530, False: 169k]
  |  Branch (7677:45): [True: 530, False: 0]
  ------------------
 7678|    530|                BeginDockableDragDropSource(window);
 7679|       |
 7680|       |            // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
 7681|   170k|            if (g.DragDropActive && !(flags & ImGuiWindowFlags_NoDocking))
  ------------------
  |  Branch (7681:17): [True: 484, False: 169k]
  |  Branch (7681:37): [True: 322, False: 162]
  ------------------
 7682|    322|                if (g.MovingWindow == NULL || g.MovingWindow->RootWindowDockTree != window)
  ------------------
  |  Branch (7682:21): [True: 8, False: 314]
  |  Branch (7682:47): [True: 156, False: 158]
  ------------------
 7683|    164|                    if ((window == window->RootWindowDockTree) && !(window->Flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (7683:25): [True: 164, False: 0]
  |  Branch (7683:67): [True: 164, False: 0]
  ------------------
 7684|    164|                        BeginDockableDragDropTarget(window);
 7685|   170k|        }
 7686|       |
 7687|       |        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
 7688|       |        // This is useful to allow creating context menus on title bar only, etc.
 7689|   170k|        SetLastItemDataForWindow(window, title_bar_rect);
 7690|       |
 7691|       |        // [DEBUG]
 7692|   170k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 7693|   170k|        if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
  ------------------
  |  Branch (7693:13): [True: 0, False: 170k]
  |  Branch (7693:38): [True: 0, False: 0]
  |  Branch (7693:71): [True: 0, False: 0]
  ------------------
 7694|      0|            DebugLocateItemResolveWithLastItem();
 7695|   170k|#endif
 7696|       |
 7697|       |        // [Test Engine] Register title bar / tab with MoveId.
 7698|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
 7699|       |        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))
 7700|       |            IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);
 7701|       |#endif
 7702|   170k|    }
 7703|      0|    else
 7704|      0|    {
 7705|       |        // Skip refresh always mark active
 7706|      0|        if (window->SkipRefresh)
  ------------------
  |  Branch (7706:13): [True: 0, False: 0]
  ------------------
 7707|      0|            window->Active = true;
 7708|       |
 7709|       |        // Append
 7710|      0|        SetCurrentViewport(window, window->Viewport);
 7711|      0|        SetCurrentWindow(window);
 7712|      0|        g.NextWindowData.ClearFlags();
 7713|      0|        SetLastItemDataForWindow(window, window->TitleBarRect());
 7714|      0|    }
 7715|       |
 7716|   170k|    if (!(flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)
  ------------------
  |  Branch (7716:9): [True: 170k, False: 0]
  |  Branch (7716:53): [True: 170k, False: 0]
  ------------------
 7717|   170k|        PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);
 7718|       |
 7719|       |    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
 7720|   170k|    window->WriteAccessed = false;
 7721|   170k|    window->BeginCount++;
 7722|       |
 7723|       |    // Update visibility
 7724|   170k|    if (first_begin_of_the_frame && !window->SkipRefresh)
  ------------------
  |  Branch (7724:9): [True: 170k, False: 0]
  |  Branch (7724:37): [True: 170k, False: 0]
  ------------------
 7725|   170k|    {
 7726|       |        // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
 7727|       |        // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
 7728|       |        // This is analogous to regular windows being hidden from one frame.
 7729|       |        // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
 7730|   170k|        if (window->DockIsActive && !window->DockTabIsVisible)
  ------------------
  |  Branch (7730:13): [True: 0, False: 170k]
  |  Branch (7730:37): [True: 0, False: 0]
  ------------------
 7731|      0|        {
 7732|      0|            if (window->LastFrameJustFocused == g.FrameCount)
  ------------------
  |  Branch (7732:17): [True: 0, False: 0]
  ------------------
 7733|      0|                window->HiddenFramesCannotSkipItems = 1;
 7734|      0|            else
 7735|      0|                window->HiddenFramesCanSkipItems = 1;
 7736|      0|        }
 7737|       |
 7738|   170k|        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (7738:13): [True: 16.9k, False: 153k]
  |  Branch (7738:55): [True: 16.9k, False: 0]
  ------------------
 7739|  16.9k|        {
 7740|       |            // Child window can be out of sight and have "negative" clip windows.
 7741|       |            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
 7742|  16.9k|            IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0 || window->DockIsActive);
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7743|  16.9k|            const bool nav_request = (window->ChildFlags & ImGuiChildFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
  ------------------
  |  Branch (7743:38): [True: 0, False: 16.9k]
  |  Branch (7743:94): [True: 0, False: 0]
  |  Branch (7743:113): [True: 0, False: 0]
  |  Branch (7743:128): [True: 0, False: 0]
  ------------------
 7744|  16.9k|            if (!g.LogEnabled && !nav_request)
  ------------------
  |  Branch (7744:17): [True: 16.9k, False: 0]
  |  Branch (7744:34): [True: 16.9k, False: 0]
  ------------------
 7745|  16.9k|                if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
  ------------------
  |  Branch (7745:21): [True: 11, False: 16.9k]
  |  Branch (7745:89): [True: 0, False: 16.9k]
  ------------------
 7746|     11|                {
 7747|     11|                    if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (7747:25): [True: 0, False: 11]
  |  Branch (7747:55): [True: 0, False: 11]
  ------------------
 7748|      0|                        window->HiddenFramesCannotSkipItems = 1;
 7749|     11|                    else
 7750|     11|                        window->HiddenFramesCanSkipItems = 1;
 7751|     11|                }
 7752|       |
 7753|       |            // Hide along with parent or if parent is collapsed
 7754|  16.9k|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
  ------------------
  |  Branch (7754:17): [True: 16.9k, False: 0]
  |  Branch (7754:35): [True: 0, False: 16.9k]
  |  Branch (7754:63): [True: 0, False: 16.9k]
  ------------------
 7755|      0|                window->HiddenFramesCanSkipItems = 1;
 7756|  16.9k|            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
  ------------------
  |  Branch (7756:17): [True: 16.9k, False: 0]
  |  Branch (7756:35): [True: 0, False: 16.9k]
  |  Branch (7756:63): [True: 1, False: 16.9k]
  ------------------
 7757|      1|                window->HiddenFramesCannotSkipItems = 1;
 7758|  16.9k|        }
 7759|       |
 7760|       |        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
 7761|   170k|        if (style.Alpha <= 0.0f)
  ------------------
  |  Branch (7761:13): [True: 0, False: 170k]
  ------------------
 7762|      0|            window->HiddenFramesCanSkipItems = 1;
 7763|       |
 7764|       |        // Update the Hidden flag
 7765|   170k|        bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
  ------------------
  |  Branch (7765:31): [True: 11, False: 170k]
  |  Branch (7765:73): [True: 2, False: 170k]
  ------------------
 7766|   170k|        window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);
  ------------------
  |  Branch (7766:26): [True: 13, False: 170k]
  |  Branch (7766:44): [True: 0, False: 170k]
  ------------------
 7767|       |
 7768|       |        // Disable inputs for requested number of frames
 7769|   170k|        if (window->DisableInputsFrames > 0)
  ------------------
  |  Branch (7769:13): [True: 0, False: 170k]
  ------------------
 7770|      0|        {
 7771|      0|            window->DisableInputsFrames--;
 7772|      0|            window->Flags |= ImGuiWindowFlags_NoInputs;
 7773|      0|        }
 7774|       |
 7775|       |        // Update the SkipItems flag, used to early out of all items functions (no layout required)
 7776|   170k|        bool skip_items = false;
 7777|   170k|        if (window->Collapsed || !window->Active || hidden_regular)
  ------------------
  |  Branch (7777:13): [True: 59.7k, False: 110k]
  |  Branch (7777:34): [True: 0, False: 110k]
  |  Branch (7777:53): [True: 13, False: 110k]
  ------------------
 7778|  59.7k|            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
  ------------------
  |  Branch (7778:17): [True: 59.7k, False: 1]
  |  Branch (7778:48): [True: 59.7k, False: 1]
  |  Branch (7778:79): [True: 59.7k, False: 0]
  ------------------
 7779|  59.7k|                skip_items = true;
 7780|   170k|        window->SkipItems = skip_items;
 7781|       |
 7782|       |        // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
 7783|   170k|        if (window->SkipItems)
  ------------------
  |  Branch (7783:13): [True: 59.7k, False: 110k]
  ------------------
 7784|  59.7k|            window->DC.NavLayersActiveMaskNext = window->DC.NavLayersActiveMask;
 7785|       |
 7786|       |        // Sanity check: there are two spots which can set Appearing = true
 7787|       |        // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
 7788|       |        // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
 7789|   170k|        if (window->SkipItems && !window->Appearing)
  ------------------
  |  Branch (7789:13): [True: 59.7k, False: 110k]
  |  Branch (7789:34): [True: 59.7k, False: 0]
  ------------------
 7790|   170k|            IM_ASSERT(window->Appearing == false); // Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7791|   170k|    }
 7792|      0|    else if (first_begin_of_the_frame)
  ------------------
  |  Branch (7792:14): [True: 0, False: 0]
  ------------------
 7793|      0|    {
 7794|       |        // Skip refresh mode
 7795|      0|        window->SkipItems = true;
 7796|      0|    }
 7797|       |
 7798|       |    // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
 7799|       |    // (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
 7800|   170k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 7801|   170k|    if (!window->IsFallbackWindow)
  ------------------
  |  Branch (7801:9): [True: 93.6k, False: 76.6k]
  ------------------
 7802|  93.6k|        if ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size))
  ------------------
  |  Branch (7802:14): [True: 0, False: 93.6k]
  |  Branch (7802:54): [True: 0, False: 0]
  |  Branch (7802:79): [True: 0, False: 93.6k]
  |  Branch (7802:119): [True: 0, False: 0]
  ------------------
 7803|      0|        {
 7804|      0|            if (window->AutoFitFramesX > 0) { window->AutoFitFramesX++; }
  ------------------
  |  Branch (7804:17): [True: 0, False: 0]
  ------------------
 7805|      0|            if (window->AutoFitFramesY > 0) { window->AutoFitFramesY++; }
  ------------------
  |  Branch (7805:17): [True: 0, False: 0]
  ------------------
 7806|      0|            return false;
 7807|      0|        }
 7808|   170k|#endif
 7809|       |
 7810|   170k|    return !window->SkipItems;
 7811|   170k|}
_ZN5ImGui3EndEv:
 7823|   170k|{
 7824|   170k|    ImGuiContext& g = *GImGui;
 7825|   170k|    ImGuiWindow* window = g.CurrentWindow;
 7826|       |
 7827|       |    // Error checking: verify that user hasn't called End() too many times!
 7828|   170k|    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
  ------------------
  |  Branch (7828:9): [True: 76.6k, False: 93.6k]
  |  Branch (7828:43): [True: 0, False: 76.6k]
  ------------------
 7829|      0|    {
 7830|      0|        IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!");
  ------------------
  |  |  271|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7831|      0|        return;
 7832|      0|    }
 7833|   170k|    ImGuiWindowStackData& window_stack_data = g.CurrentWindowStack.back();
 7834|       |
 7835|       |    // Error checking: verify that user doesn't directly call End() on a child window.
 7836|   170k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->DockIsActive)
  ------------------
  |  Branch (7836:9): [True: 16.9k, False: 153k]
  |  Branch (7836:59): [True: 16.9k, False: 0]
  |  Branch (7836:111): [True: 16.9k, False: 0]
  ------------------
 7837|   170k|        IM_ASSERT_USER_ERROR(g.WithinEndChild, "Must call EndChild() and not End()!");
  ------------------
  |  |  271|   170k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 7838|       |
 7839|       |    // Close anything that is open
 7840|   170k|    if (window->DC.CurrentColumns)
  ------------------
  |  Branch (7840:9): [True: 0, False: 170k]
  ------------------
 7841|      0|        EndColumns();
 7842|   170k|    if (!(window->Flags & ImGuiWindowFlags_DockNodeHost) && !window->SkipRefresh)   // Pop inner window clip rectangle
  ------------------
  |  Branch (7842:9): [True: 170k, False: 0]
  |  Branch (7842:61): [True: 170k, False: 0]
  ------------------
 7843|   170k|        PopClipRect();
 7844|   170k|    PopFocusScope();
 7845|   170k|    if (window_stack_data.DisabledOverrideReenable && window->RootWindow == window)
  ------------------
  |  Branch (7845:9): [True: 0, False: 170k]
  |  Branch (7845:55): [True: 0, False: 0]
  ------------------
 7846|      0|        EndDisabledOverrideReenable();
 7847|       |
 7848|   170k|    if (window->SkipRefresh)
  ------------------
  |  Branch (7848:9): [True: 0, False: 170k]
  ------------------
 7849|      0|    {
 7850|      0|        IM_ASSERT(window->DrawList == NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7851|      0|        window->DrawList = &window->DrawListInst;
 7852|      0|    }
 7853|       |
 7854|       |    // Stop logging
 7855|   170k|    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
  ------------------
  |  Branch (7855:9): [True: 153k, False: 16.9k]
  ------------------
 7856|   153k|        LogFinish();
 7857|       |
 7858|   170k|    if (window->DC.IsSetPos)
  ------------------
  |  Branch (7858:9): [True: 0, False: 170k]
  ------------------
 7859|      0|        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
 7860|       |
 7861|       |    // Docking: report contents sizes to parent to allow for auto-resize
 7862|   170k|    if (window->DockNode && window->DockTabIsVisible)
  ------------------
  |  Branch (7862:9): [True: 0, False: 170k]
  |  Branch (7862:29): [True: 0, False: 0]
  ------------------
 7863|      0|        if (ImGuiWindow* host_window = window->DockNode->HostWindow)         // FIXME-DOCK
  ------------------
  |  Branch (7863:26): [True: 0, False: 0]
  ------------------
 7864|      0|            host_window->DC.CursorMaxPos = window->DC.CursorMaxPos + window->WindowPadding - host_window->WindowPadding;
 7865|       |
 7866|       |    // Pop from window stack
 7867|   170k|    g.LastItemData = window_stack_data.ParentLastItemDataBackup;
 7868|   170k|    if (window->Flags & ImGuiWindowFlags_ChildMenu)
  ------------------
  |  Branch (7868:9): [True: 0, False: 170k]
  ------------------
 7869|      0|        g.BeginMenuDepth--;
 7870|   170k|    if (window->Flags & ImGuiWindowFlags_Popup)
  ------------------
  |  Branch (7870:9): [True: 0, False: 170k]
  ------------------
 7871|      0|        g.BeginPopupStack.pop_back();
 7872|   170k|    window_stack_data.StackSizesOnBegin.CompareWithContextState(&g);
 7873|   170k|    g.CurrentWindowStack.pop_back();
 7874|   170k|    SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? NULL : g.CurrentWindowStack.back().Window);
  ------------------
  |  Branch (7874:22): [True: 76.6k, False: 93.6k]
  ------------------
 7875|   170k|    if (g.CurrentWindow)
  ------------------
  |  Branch (7875:9): [True: 93.6k, False: 76.6k]
  ------------------
 7876|  93.6k|        SetCurrentViewport(g.CurrentWindow, g.CurrentWindow->Viewport);
 7877|   170k|}
_ZN5ImGui23BringWindowToFocusFrontEP11ImGuiWindow:
 7880|  5.32k|{
 7881|  5.32k|    ImGuiContext& g = *GImGui;
 7882|  5.32k|    IM_ASSERT(window == window->RootWindow);
  ------------------
  |  |   23|  5.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7883|       |
 7884|  5.32k|    const int cur_order = window->FocusOrder;
 7885|  5.32k|    IM_ASSERT(g.WindowsFocusOrder[cur_order] == window);
  ------------------
  |  |   23|  5.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7886|  5.32k|    if (g.WindowsFocusOrder.back() == window)
  ------------------
  |  Branch (7886:9): [True: 5.32k, False: 0]
  ------------------
 7887|  5.32k|        return;
 7888|       |
 7889|      0|    const int new_order = g.WindowsFocusOrder.Size - 1;
 7890|      0|    for (int n = cur_order; n < new_order; n++)
  ------------------
  |  Branch (7890:29): [True: 0, False: 0]
  ------------------
 7891|      0|    {
 7892|      0|        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
 7893|      0|        g.WindowsFocusOrder[n]->FocusOrder--;
 7894|      0|        IM_ASSERT(g.WindowsFocusOrder[n]->FocusOrder == n);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7895|      0|    }
 7896|      0|    g.WindowsFocusOrder[new_order] = window;
 7897|      0|    window->FocusOrder = (short)new_order;
 7898|      0|}
_ZN5ImGui25BringWindowToDisplayFrontEP11ImGuiWindow:
 7901|  5.32k|{
 7902|  5.32k|    ImGuiContext& g = *GImGui;
 7903|  5.32k|    ImGuiWindow* current_front_window = g.Windows.back();
 7904|  5.32k|    if (current_front_window == window || current_front_window->RootWindowDockTree == window) // Cheap early out (could be better)
  ------------------
  |  Branch (7904:9): [True: 2, False: 5.31k]
  |  Branch (7904:43): [True: 5.31k, False: 0]
  ------------------
 7905|  5.32k|        return;
 7906|      0|    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the top-most window
  ------------------
  |  Branch (7906:38): [True: 0, False: 0]
  ------------------
 7907|      0|        if (g.Windows[i] == window)
  ------------------
  |  Branch (7907:13): [True: 0, False: 0]
  ------------------
 7908|      0|        {
 7909|      0|            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
 7910|      0|            g.Windows[g.Windows.Size - 1] = window;
 7911|      0|            break;
 7912|      0|        }
 7913|      0|}
_ZN5ImGui11FocusWindowEP11ImGuiWindowi:
 7959|  15.2k|{
 7960|  15.2k|    ImGuiContext& g = *GImGui;
 7961|       |
 7962|       |    // Modal check?
 7963|  15.2k|    if ((flags & ImGuiFocusRequestFlags_UnlessBelowModal) && (g.NavWindow != window)) // Early out in common case.
  ------------------
  |  Branch (7963:9): [True: 80, False: 15.1k]
  |  Branch (7963:62): [True: 80, False: 0]
  ------------------
 7964|     80|        if (ImGuiWindow* blocking_modal = FindBlockingModal(window))
  ------------------
  |  Branch (7964:26): [True: 0, False: 80]
  ------------------
 7965|      0|        {
 7966|       |            // This block would typically be reached in two situations:
 7967|       |            // - API call to FocusWindow() with a window under a modal and ImGuiFocusRequestFlags_UnlessBelowModal flag.
 7968|       |            // - User clicking on void or anything behind a modal while a modal is open (window == NULL)
 7969|      0|            IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window->Name : "<NULL>", blocking_modal->Name);
  ------------------
  |  |  246|      0|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 0]
  |  |  |  Branch (246:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7970|      0|            if (window && window == window->RootWindow && (window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
  ------------------
  |  Branch (7970:17): [True: 0, False: 0]
  |  Branch (7970:27): [True: 0, False: 0]
  |  Branch (7970:59): [True: 0, False: 0]
  ------------------
 7971|      0|                BringWindowToDisplayBehind(window, blocking_modal); // Still bring right under modal. (FIXME: Could move in focus list too?)
 7972|      0|            ClosePopupsOverWindow(GetTopMostPopupModal(), false); // Note how we need to use GetTopMostPopupModal() aad NOT blocking_modal, to handle nested modals
 7973|      0|            return;
 7974|      0|        }
 7975|       |
 7976|       |    // Find last focused child (if any) and focus it instead.
 7977|  15.2k|    if ((flags & ImGuiFocusRequestFlags_RestoreFocusedChild) && window != NULL)
  ------------------
  |  Branch (7977:9): [True: 0, False: 15.2k]
  |  Branch (7977:65): [True: 0, False: 0]
  ------------------
 7978|      0|        window = NavRestoreLastChildNavWindow(window);
 7979|       |
 7980|       |    // Apply focus
 7981|  15.2k|    if (g.NavWindow != window)
  ------------------
  |  Branch (7981:9): [True: 6.33k, False: 8.94k]
  ------------------
 7982|  6.33k|    {
 7983|  6.33k|        SetNavWindow(window);
 7984|  6.33k|        if (window && g.NavDisableMouseHover)
  ------------------
  |  Branch (7984:13): [True: 3.33k, False: 3.00k]
  |  Branch (7984:23): [True: 662, False: 2.67k]
  ------------------
 7985|    662|            g.NavMousePosDirty = true;
 7986|  6.33k|        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
  ------------------
  |  Branch (7986:19): [True: 3.33k, False: 3.00k]
  ------------------
 7987|  6.33k|        g.NavLayer = ImGuiNavLayer_Main;
 7988|  6.33k|        SetNavFocusScope(window ? window->NavRootFocusScopeId : 0);
  ------------------
  |  Branch (7988:26): [True: 3.33k, False: 3.00k]
  ------------------
 7989|  6.33k|        g.NavIdIsAlive = false;
 7990|  6.33k|        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1736|  6.33k|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
 7991|       |
 7992|       |        // Close popups if any
 7993|  6.33k|        ClosePopupsOverWindow(window, false);
 7994|  6.33k|    }
 7995|       |
 7996|       |    // Move the root window to the top of the pile
 7997|  15.2k|    IM_ASSERT(window == NULL || window->RootWindowDockTree != NULL);
  ------------------
  |  |   23|  15.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 7998|  15.2k|    ImGuiWindow* focus_front_window = window ? window->RootWindow : NULL;
  ------------------
  |  Branch (7998:39): [True: 5.32k, False: 9.95k]
  ------------------
 7999|  15.2k|    ImGuiWindow* display_front_window = window ? window->RootWindowDockTree : NULL;
  ------------------
  |  Branch (7999:41): [True: 5.32k, False: 9.95k]
  ------------------
 8000|  15.2k|    ImGuiDockNode* dock_node = window ? window->DockNode : NULL;
  ------------------
  |  Branch (8000:32): [True: 5.32k, False: 9.95k]
  ------------------
 8001|  15.2k|    bool active_id_window_is_dock_node_host = (g.ActiveIdWindow && dock_node && dock_node->HostWindow == g.ActiveIdWindow);
  ------------------
  |  Branch (8001:48): [True: 752, False: 14.5k]
  |  Branch (8001:68): [True: 0, False: 752]
  |  Branch (8001:81): [True: 0, False: 0]
  ------------------
 8002|       |
 8003|       |    // Steal active widgets. Some of the cases it triggers includes:
 8004|       |    // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
 8005|       |    // - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
 8006|       |    // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
 8007|  15.2k|    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
  ------------------
  |  Branch (8007:9): [True: 752, False: 14.5k]
  |  Branch (8007:28): [True: 752, False: 0]
  |  Branch (8007:48): [True: 159, False: 593]
  ------------------
 8008|    159|        if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)
  ------------------
  |  Branch (8008:13): [True: 16, False: 143]
  |  Branch (8008:46): [True: 16, False: 0]
  ------------------
 8009|     16|            ClearActiveID();
 8010|       |
 8011|       |    // Passing NULL allow to disable keyboard focus
 8012|  15.2k|    if (!window)
  ------------------
  |  Branch (8012:9): [True: 9.95k, False: 5.32k]
  ------------------
 8013|  9.95k|        return;
 8014|  5.32k|    window->LastFrameJustFocused = g.FrameCount;
 8015|       |
 8016|       |    // Select in dock node
 8017|       |    // For #2304 we avoid applying focus immediately before the tabbar is visible.
 8018|       |    //if (dock_node && dock_node->TabBar)
 8019|       |    //    dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;
 8020|       |
 8021|       |    // Bring to front
 8022|  5.32k|    BringWindowToFocusFront(focus_front_window);
 8023|  5.32k|    if (((window->Flags | focus_front_window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
  ------------------
  |  Branch (8023:9): [True: 5.32k, False: 0]
  ------------------
 8024|  5.32k|        BringWindowToDisplayFront(display_front_window);
 8025|  5.32k|}
_ZN5ImGui14SetCurrentFontEP6ImFont:
 8066|  76.6k|{
 8067|  76.6k|    ImGuiContext& g = *GImGui;
 8068|  76.6k|    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8069|  76.6k|    IM_ASSERT(font->Scale > 0.0f);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8070|  76.6k|    g.Font = font;
 8071|  76.6k|    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
 8072|  76.6k|    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;
  ------------------
  |  Branch (8072:18): [True: 0, False: 76.6k]
  ------------------
 8073|       |
 8074|  76.6k|    ImFontAtlas* atlas = g.Font->ContainerAtlas;
 8075|  76.6k|    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
 8076|  76.6k|    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
 8077|  76.6k|    g.DrawListSharedData.Font = g.Font;
 8078|  76.6k|    g.DrawListSharedData.FontSize = g.FontSize;
 8079|  76.6k|}
_ZN5ImGui12PushItemFlagEib:
 8100|  16.9k|{
 8101|  16.9k|    ImGuiContext& g = *GImGui;
 8102|  16.9k|    ImGuiItemFlags item_flags = g.CurrentItemFlags;
 8103|  16.9k|    IM_ASSERT(item_flags == g.ItemFlagsStack.back());
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8104|  16.9k|    if (enabled)
  ------------------
  |  Branch (8104:9): [True: 0, False: 16.9k]
  ------------------
 8105|      0|        item_flags |= option;
 8106|  16.9k|    else
 8107|  16.9k|        item_flags &= ~option;
 8108|  16.9k|    g.CurrentItemFlags = item_flags;
 8109|  16.9k|    g.ItemFlagsStack.push_back(item_flags);
 8110|  16.9k|}
_ZN5ImGui11PopItemFlagEv:
 8113|  16.9k|{
 8114|  16.9k|    ImGuiContext& g = *GImGui;
 8115|  16.9k|    IM_ASSERT(g.ItemFlagsStack.Size > 1); // Too many calls to PopItemFlag() - we always leave a 0 at the bottom of the stack.
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8116|  16.9k|    g.ItemFlagsStack.pop_back();
 8117|  16.9k|    g.CurrentItemFlags = g.ItemFlagsStack.back();
 8118|  16.9k|}
_ZN5ImGui11PushTabStopEb:
 8178|  16.9k|{
 8179|  16.9k|    PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop);
 8180|  16.9k|}
_ZN5ImGui10PopTabStopEv:
 8183|  16.9k|{
 8184|  16.9k|    PopItemFlag();
 8185|  16.9k|}
_ZN5ImGui15IsWindowHoveredEi:
 8280|  23.3k|{
 8281|  23.3k|    IM_ASSERT((flags & ~ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == 0 && "Invalid flags for IsWindowHovered()!");
  ------------------
  |  |   23|  23.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8282|       |
 8283|  23.3k|    ImGuiContext& g = *GImGui;
 8284|  23.3k|    ImGuiWindow* ref_window = g.HoveredWindow;
 8285|  23.3k|    ImGuiWindow* cur_window = g.CurrentWindow;
 8286|  23.3k|    if (ref_window == NULL)
  ------------------
  |  Branch (8286:9): [True: 22.8k, False: 479]
  ------------------
 8287|  22.8k|        return false;
 8288|       |
 8289|    479|    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
  ------------------
  |  Branch (8289:9): [True: 479, False: 0]
  ------------------
 8290|    479|    {
 8291|    479|        IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|    479|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8292|    479|        const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
 8293|    479|        const bool dock_hierarchy = (flags & ImGuiHoveredFlags_DockHierarchy) != 0;
 8294|    479|        if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (8294:13): [True: 0, False: 479]
  ------------------
 8295|      0|            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 8296|       |
 8297|    479|        bool result;
 8298|    479|        if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (8298:13): [True: 0, False: 479]
  ------------------
 8299|      0|            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 8300|    479|        else
 8301|    479|            result = (ref_window == cur_window);
 8302|    479|        if (!result)
  ------------------
  |  Branch (8302:13): [True: 449, False: 30]
  ------------------
 8303|    449|            return false;
 8304|    479|    }
 8305|       |
 8306|     30|    if (!IsWindowContentHoverable(ref_window, flags))
  ------------------
  |  Branch (8306:9): [True: 0, False: 30]
  ------------------
 8307|      0|        return false;
 8308|     30|    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (8308:9): [True: 30, False: 0]
  ------------------
 8309|     30|        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)
  ------------------
  |  Branch (8309:13): [True: 0, False: 30]
  |  Branch (8309:32): [True: 0, False: 0]
  |  Branch (8309:59): [True: 0, False: 0]
  ------------------
 8310|      0|            return false;
 8311|       |
 8312|       |    // When changing hovered window we requires a bit of stationary delay before activating hover timer.
 8313|       |    // FIXME: We don't support delay other than stationary one for now, other delay would need a way
 8314|       |    // to fulfill the possibility that multiple IsWindowHovered() with varying flag could return true
 8315|       |    // for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
 8316|       |    // We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
 8317|     30|    if (flags & ImGuiHoveredFlags_ForTooltip)
  ------------------
  |  Branch (8317:9): [True: 0, False: 30]
  ------------------
 8318|      0|        flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
 8319|     30|    if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverWindowUnlockedStationaryId != ref_window->ID)
  ------------------
  |  Branch (8319:9): [True: 0, False: 30]
  |  Branch (8319:56): [True: 0, False: 0]
  ------------------
 8320|      0|        return false;
 8321|       |
 8322|     30|    return true;
 8323|     30|}
_ZN5ImGui15IsWindowFocusedEi:
 8326|  33.1k|{
 8327|  33.1k|    ImGuiContext& g = *GImGui;
 8328|  33.1k|    ImGuiWindow* ref_window = g.NavWindow;
 8329|  33.1k|    ImGuiWindow* cur_window = g.CurrentWindow;
 8330|       |
 8331|  33.1k|    if (ref_window == NULL)
  ------------------
  |  Branch (8331:9): [True: 19.1k, False: 13.9k]
  ------------------
 8332|  19.1k|        return false;
 8333|  13.9k|    if (flags & ImGuiFocusedFlags_AnyWindow)
  ------------------
  |  Branch (8333:9): [True: 0, False: 13.9k]
  ------------------
 8334|      0|        return true;
 8335|       |
 8336|  13.9k|    IM_ASSERT(cur_window); // Not inside a Begin()/End()
  ------------------
  |  |   23|  13.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8337|  13.9k|    const bool popup_hierarchy = (flags & ImGuiFocusedFlags_NoPopupHierarchy) == 0;
 8338|  13.9k|    const bool dock_hierarchy = (flags & ImGuiFocusedFlags_DockHierarchy) != 0;
 8339|  13.9k|    if (flags & ImGuiHoveredFlags_RootWindow)
  ------------------
  |  Branch (8339:9): [True: 0, False: 13.9k]
  ------------------
 8340|      0|        cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
 8341|       |
 8342|  13.9k|    if (flags & ImGuiHoveredFlags_ChildWindows)
  ------------------
  |  Branch (8342:9): [True: 0, False: 13.9k]
  ------------------
 8343|      0|        return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
 8344|  13.9k|    else
 8345|  13.9k|        return (ref_window == cur_window);
 8346|  13.9k|}
_ZN5ImGui14GetWindowWidthEv:
 8369|  4.52k|{
 8370|  4.52k|    ImGuiWindow* window = GImGui->CurrentWindow;
 8371|  4.52k|    return window->Size.x;
 8372|  4.52k|}
_ZN5ImGui15GetWindowHeightEv:
 8375|  4.58k|{
 8376|  4.58k|    ImGuiWindow* window = GImGui->CurrentWindow;
 8377|  4.58k|    return window->Size.y;
 8378|  4.58k|}
_ZN5ImGui12SetWindowPosEP11ImGuiWindowRK6ImVec2i:
 8388|    260|{
 8389|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 8390|    260|    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
  ------------------
  |  Branch (8390:9): [True: 260, False: 0]
  |  Branch (8390:17): [True: 0, False: 260]
  ------------------
 8391|      0|        return;
 8392|       |
 8393|    260|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|    260|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8394|    260|    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 8395|    260|    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);
 8396|       |
 8397|       |    // Set
 8398|    260|    const ImVec2 old_pos = window->Pos;
 8399|    260|    window->Pos = ImTrunc(pos);
 8400|    260|    ImVec2 offset = window->Pos - old_pos;
 8401|    260|    if (offset.x == 0.0f && offset.y == 0.0f)
  ------------------
  |  Branch (8401:9): [True: 5, False: 255]
  |  Branch (8401:29): [True: 0, False: 5]
  ------------------
 8402|      0|        return;
 8403|    260|    MarkIniSettingsDirty(window);
 8404|       |    // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
 8405|    260|    window->DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
 8406|    260|    window->DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
 8407|    260|    window->DC.IdealMaxPos += offset;
 8408|    260|    window->DC.CursorStartPos += offset;
 8409|    260|}
_ZN5ImGui13SetWindowSizeEP11ImGuiWindowRK6ImVec2i:
 8430|  93.6k|{
 8431|       |    // Test condition (NB: bit 0 is always true) and clear flags for next time
 8432|  93.6k|    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
  ------------------
  |  Branch (8432:9): [True: 93.6k, False: 0]
  |  Branch (8432:17): [True: 76.6k, False: 16.9k]
  ------------------
 8433|  76.6k|        return;
 8434|       |
 8435|  16.9k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8436|  16.9k|    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
 8437|       |
 8438|       |    // Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
 8439|  16.9k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
  ------------------
  |  Branch (8439:9): [True: 1, False: 16.9k]
  |  Branch (8439:64): [True: 2, False: 16.9k]
  |  Branch (8439:85): [True: 0, False: 16.9k]
  ------------------
 8440|      3|        window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (8440:34): [True: 0, False: 3]
  ------------------
 8441|  16.9k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || window->Appearing || (window->ChildFlags & ImGuiChildFlags_AlwaysAutoResize) != 0)
  ------------------
  |  Branch (8441:9): [True: 1, False: 16.9k]
  |  Branch (8441:64): [True: 2, False: 16.9k]
  |  Branch (8441:85): [True: 0, False: 16.9k]
  ------------------
 8442|      3|        window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
  ------------------
  |  Branch (8442:34): [True: 1, False: 2]
  ------------------
 8443|       |
 8444|       |    // Set
 8445|  16.9k|    ImVec2 old_size = window->SizeFull;
 8446|  16.9k|    if (size.x <= 0.0f)
  ------------------
  |  Branch (8446:9): [True: 0, False: 16.9k]
  ------------------
 8447|      0|        window->AutoFitOnlyGrows = false;
 8448|  16.9k|    else
 8449|  16.9k|        window->SizeFull.x = IM_TRUNC(size.x);
  ------------------
  |  |  287|  16.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 8450|  16.9k|    if (size.y <= 0.0f)
  ------------------
  |  Branch (8450:9): [True: 1, False: 16.9k]
  ------------------
 8451|      1|        window->AutoFitOnlyGrows = false;
 8452|  16.9k|    else
 8453|  16.9k|        window->SizeFull.y = IM_TRUNC(size.y);
  ------------------
  |  |  287|  16.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 8454|  16.9k|    if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
  ------------------
  |  Branch (8454:9): [True: 15.3k, False: 1.61k]
  |  Branch (8454:45): [True: 1.52k, False: 92]
  ------------------
 8455|  16.8k|        MarkIniSettingsDirty(window);
 8456|  16.9k|}
_ZN5ImGui14SetWindowFocusEv:
 8517|  4.52k|{
 8518|  4.52k|    FocusWindow(GImGui->CurrentWindow);
 8519|  4.52k|}
_ZN5ImGui17SetNextWindowSizeERK6ImVec2i:
 8546|  93.6k|{
 8547|  93.6k|    ImGuiContext& g = *GImGui;
 8548|  93.6k|    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
  ------------------
  |  |   23|  93.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8549|  93.6k|    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
 8550|  93.6k|    g.NextWindowData.SizeVal = size;
 8551|  93.6k|    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
  ------------------
  |  Branch (8551:33): [True: 76.6k, False: 16.9k]
  ------------------
 8552|  93.6k|}
_ZN5ImGui17GetWindowDrawListEv:
 8637|  16.9k|{
 8638|  16.9k|    ImGuiWindow* window = GetCurrentWindow();
 8639|  16.9k|    return window->DrawList;
 8640|  16.9k|}
_ZN5ImGui7GetFontEv:
 8656|  1.43M|{
 8657|  1.43M|    return GImGui->Font;
 8658|  1.43M|}
_ZN5ImGui11GetFontSizeEv:
 8661|  1.44M|{
 8662|  1.44M|    return GImGui->FontSize;
 8663|  1.44M|}
_ZN5ImGui14PushFocusScopeEj:
 8680|   170k|{
 8681|   170k|    ImGuiContext& g = *GImGui;
 8682|   170k|    ImGuiFocusScopeData data;
 8683|   170k|    data.ID = id;
 8684|   170k|    data.WindowID = g.CurrentWindow->ID;
 8685|   170k|    g.FocusScopeStack.push_back(data);
 8686|   170k|    g.CurrentFocusScopeId = id;
 8687|   170k|}
_ZN5ImGui13PopFocusScopeEv:
 8690|   170k|{
 8691|   170k|    ImGuiContext& g = *GImGui;
 8692|   170k|    if (g.FocusScopeStack.Size == 0)
  ------------------
  |  Branch (8692:9): [True: 0, False: 170k]
  ------------------
 8693|      0|    {
 8694|      0|        IM_ASSERT_USER_ERROR(g.FocusScopeStack.Size > 0, "Calling PopFocusScope() too many times!");
  ------------------
  |  |  271|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 8695|      0|        return;
 8696|      0|    }
 8697|   170k|    g.FocusScopeStack.pop_back();
 8698|   170k|    g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back().ID : 0;
  ------------------
  |  Branch (8698:29): [True: 93.6k, False: 76.6k]
  ------------------
 8699|   170k|}
_ZN5ImGui16SetNavFocusScopeEj:
 8702|  7.09k|{
 8703|  7.09k|    ImGuiContext& g = *GImGui;
 8704|  7.09k|    g.NavFocusScopeId = focus_scope_id;
 8705|  7.09k|    g.NavFocusRoute.resize(0); // Invalidate
 8706|  7.09k|    if (focus_scope_id == 0)
  ------------------
  |  Branch (8706:9): [True: 3.17k, False: 3.91k]
  ------------------
 8707|  3.17k|        return;
 8708|  3.91k|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|  3.91k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8709|       |
 8710|       |    // Store current path (in reverse order)
 8711|  3.91k|    if (focus_scope_id == g.CurrentFocusScopeId)
  ------------------
  |  Branch (8711:9): [True: 3.44k, False: 471]
  ------------------
 8712|  3.44k|    {
 8713|       |        // Top of focus stack contains local focus scopes inside current window
 8714|  6.89k|        for (int n = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow->ID; n--)
  ------------------
  |  Branch (8714:50): [True: 6.89k, False: 2]
  |  Branch (8714:60): [True: 3.44k, False: 3.44k]
  ------------------
 8715|  3.44k|            g.NavFocusRoute.push_back(g.FocusScopeStack.Data[n]);
 8716|  3.44k|    }
 8717|    471|    else if (focus_scope_id == g.NavWindow->NavRootFocusScopeId)
  ------------------
  |  Branch (8717:14): [True: 467, False: 4]
  ------------------
 8718|    467|        g.NavFocusRoute.push_back({ focus_scope_id, g.NavWindow->ID });
 8719|      4|    else
 8720|      4|        return;
 8721|       |
 8722|       |    // Then follow on manually set ParentWindowForFocusRoute field (#6798)
 8723|  6.95k|    for (ImGuiWindow* window = g.NavWindow->ParentWindowForFocusRoute; window != NULL; window = window->ParentWindowForFocusRoute)
  ------------------
  |  Branch (8723:72): [True: 3.03k, False: 3.91k]
  ------------------
 8724|  3.03k|        g.NavFocusRoute.push_back({ window->NavRootFocusScopeId, window->ID });
 8725|  3.91k|    IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
  ------------------
  |  |   23|  3.91k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8726|  3.91k|}
_ZN11ImGuiWindow5GetIDEPKcS1_:
 8838|   221k|{
 8839|   221k|    ImGuiID seed = IDStack.back();
 8840|   221k|    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
  ------------------
  |  Branch (8840:33): [True: 0, False: 221k]
  ------------------
 8841|   221k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 8842|   221k|    ImGuiContext& g = *Ctx;
 8843|   221k|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (8843:9): [True: 0, False: 221k]
  ------------------
 8844|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
 8845|   221k|#endif
 8846|   221k|    return id;
 8847|   221k|}
_ZN11ImGuiWindow5GetIDEi:
 8862|   101k|{
 8863|   101k|    ImGuiID seed = IDStack.back();
 8864|   101k|    ImGuiID id = ImHashData(&n, sizeof(n), seed);
 8865|   101k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
 8866|   101k|    ImGuiContext& g = *Ctx;
 8867|   101k|    if (g.DebugHookIdInfo == id)
  ------------------
  |  Branch (8867:9): [True: 0, False: 101k]
  ------------------
 8868|      0|        ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, NULL);
 8869|   101k|#endif
 8870|   101k|    return id;
 8871|   101k|}
_ZN5ImGui6PushIDEPKc:
 8883|  16.9k|{
 8884|  16.9k|    ImGuiContext& g = *GImGui;
 8885|  16.9k|    ImGuiWindow* window = g.CurrentWindow;
 8886|  16.9k|    ImGuiID id = window->GetID(str_id);
 8887|  16.9k|    window->IDStack.push_back(id);
 8888|  16.9k|}
_ZN5ImGui5PopIDEv:
 8952|  16.9k|{
 8953|  16.9k|    ImGuiWindow* window = GImGui->CurrentWindow;
 8954|  16.9k|    IM_ASSERT(window->IDStack.Size > 1); // Too many PopID(), or could be popping in a wrong/different window?
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 8955|  16.9k|    window->IDStack.pop_back();
 8956|  16.9k|}
_ZN5ImGui13FixupKeyChordEi:
 9056|   306k|{
 9057|       |    // Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
 9058|   306k|    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
 9059|   306k|    if (IsModKey(key))
  ------------------
  |  Branch (9059:9): [True: 0, False: 306k]
  ------------------
 9060|      0|        key_chord |= GetModForModKey(key);
 9061|   306k|    return key_chord;
 9062|   306k|}
_ZN5ImGui10GetKeyDataEP12ImGuiContext8ImGuiKey:
 9065|  2.09M|{
 9066|  2.09M|    ImGuiContext& g = *ctx;
 9067|       |
 9068|       |    // Special storage location for mods
 9069|  2.09M|    if (key & ImGuiMod_Mask_)
  ------------------
  |  Branch (9069:9): [True: 613k, False: 1.48M]
  ------------------
 9070|   613k|        key = ConvertSingleModFlagToKey(key);
 9071|       |
 9072|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9073|       |    IM_ASSERT(key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_NamedKey_END);
 9074|       |    if (IsLegacyKey(key) && g.IO.KeyMap[key] != -1)
 9075|       |        key = (ImGuiKey)g.IO.KeyMap[key];  // Remap native->imgui or imgui->native
 9076|       |#else
 9077|  2.09M|    IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
  ------------------
  |  |   23|  2.09M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9078|  2.09M|#endif
 9079|  2.09M|    return &g.IO.KeysData[key - ImGuiKey_KeysData_OFFSET];
 9080|  2.09M|}
_ZN5ImGui25CalcTypematicRepeatAmountEffff:
 9171|  1.06k|{
 9172|  1.06k|    if (t1 == 0.0f)
  ------------------
  |  Branch (9172:9): [True: 0, False: 1.06k]
  ------------------
 9173|      0|        return 1;
 9174|  1.06k|    if (t0 >= t1)
  ------------------
  |  Branch (9174:9): [True: 0, False: 1.06k]
  ------------------
 9175|      0|        return 0;
 9176|  1.06k|    if (repeat_rate <= 0.0f)
  ------------------
  |  Branch (9176:9): [True: 0, False: 1.06k]
  ------------------
 9177|      0|        return (t0 < repeat_delay) && (t1 >= repeat_delay);
  ------------------
  |  Branch (9177:16): [True: 0, False: 0]
  |  Branch (9177:39): [True: 0, False: 0]
  ------------------
 9178|  1.06k|    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (9178:26): [True: 215, False: 847]
  ------------------
 9179|  1.06k|    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
  ------------------
  |  Branch (9179:26): [True: 0, False: 1.06k]
  ------------------
 9180|  1.06k|    const int count = count_t1 - count_t0;
 9181|  1.06k|    return count;
 9182|  1.06k|}
_ZN5ImGui22GetTypematicRepeatRateEiPfS0_:
 9185|  6.13k|{
 9186|  6.13k|    ImGuiContext& g = *GImGui;
 9187|  6.13k|    switch (flags & ImGuiInputFlags_RepeatRateMask_)
 9188|  6.13k|    {
 9189|  1.49k|    case ImGuiInputFlags_RepeatRateNavMove:             *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.80f; return;
  ------------------
  |  Branch (9189:5): [True: 1.49k, False: 4.64k]
  ------------------
 9190|      0|    case ImGuiInputFlags_RepeatRateNavTweak:            *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.30f; return;
  ------------------
  |  Branch (9190:5): [True: 0, False: 6.13k]
  ------------------
 9191|  4.64k|    case ImGuiInputFlags_RepeatRateDefault: default:    *repeat_delay = g.IO.KeyRepeatDelay * 1.00f; *repeat_rate = g.IO.KeyRepeatRate * 1.00f; return;
  ------------------
  |  Branch (9191:5): [True: 0, False: 6.13k]
  |  Branch (9191:45): [True: 4.64k, False: 1.49k]
  ------------------
 9192|  6.13k|    }
 9193|  6.13k|}
_ZN5ImGui19GetKeyPressedAmountE8ImGuiKeyff:
 9198|  1.06k|{
 9199|  1.06k|    ImGuiContext& g = *GImGui;
 9200|  1.06k|    const ImGuiKeyData* key_data = GetKeyData(key);
 9201|  1.06k|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (9201:9): [True: 0, False: 1.06k]
  ------------------
 9202|      0|        return 0;
 9203|  1.06k|    const float t = key_data->DownDuration;
 9204|  1.06k|    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
 9205|  1.06k|}
_ZN5ImGui18SetShortcutRoutingEiij:
 9376|   153k|{
 9377|   153k|    ImGuiContext& g = *GImGui;
 9378|   153k|    if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0)
  ------------------
  |  Branch (9378:9): [True: 0, False: 153k]
  ------------------
 9379|      0|        flags |= ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
 9380|   153k|    else
 9381|   153k|        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteTypeMask_)); // Check that only 1 routing flag is used
  ------------------
  |  |   23|   153k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9382|   153k|    IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_NoOwner);
  ------------------
  |  |   23|   153k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9383|   153k|    if (flags & (ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused))
  ------------------
  |  Branch (9383:9): [True: 0, False: 153k]
  ------------------
 9384|   153k|        IM_ASSERT(flags & ImGuiInputFlags_RouteGlobal);
  ------------------
  |  |   23|   153k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9385|       |
 9386|       |    // Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
 9387|   153k|    key_chord = FixupKeyChord(key_chord);
 9388|       |
 9389|       |    // [DEBUG] Debug break requested by user
 9390|   153k|    if (g.DebugBreakInShortcutRouting == key_chord)
  ------------------
  |  Branch (9390:9): [True: 0, False: 153k]
  ------------------
 9391|      0|        IM_DEBUG_BREAK();
  ------------------
  |  |  316|      0|#define IM_DEBUG_BREAK()    __builtin_debugtrap()
  ------------------
 9392|       |
 9393|   153k|    if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
  ------------------
  |  Branch (9393:9): [True: 0, False: 153k]
  ------------------
 9394|      0|        if (g.NavWindow == NULL)
  ------------------
  |  Branch (9394:13): [True: 0, False: 0]
  ------------------
 9395|      0|            return false;
 9396|       |
 9397|       |    // Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
 9398|   153k|    if (flags & ImGuiInputFlags_RouteAlways)
  ------------------
  |  Branch (9398:9): [True: 153k, False: 0]
  ------------------
 9399|   153k|    {
 9400|   153k|        IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> always, no register\n", GetKeyChordName(key_chord), flags, owner_id);
  ------------------
  |  |  252|   153k|#define IMGUI_DEBUG_LOG_INPUTROUTING(...) do{if (g.DebugLogFlags & ImGuiDebugLogFlags_EventInputRouting)IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (252:50): [True: 0, False: 153k]
  |  |  |  Branch (252:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 9401|   153k|        return true;
 9402|   153k|    }
 9403|       |
 9404|       |    // Specific culling when there's an active item.
 9405|      0|    if (g.ActiveId != 0 && g.ActiveId != owner_id)
  ------------------
  |  Branch (9405:9): [True: 0, False: 0]
  |  Branch (9405:28): [True: 0, False: 0]
  ------------------
 9406|      0|    {
 9407|      0|        if (flags & ImGuiInputFlags_RouteActive)
  ------------------
  |  Branch (9407:13): [True: 0, False: 0]
  ------------------
 9408|      0|            return false;
 9409|       |
 9410|       |        // Cull shortcuts with no modifiers when it could generate a character.
 9411|       |        // e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.
 9412|       |        // but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
 9413|       |        // TL;DR: lettered shortcut with no mods or with only Alt mod will not trigger while an item reading text input is active.
 9414|       |        // (We cannot filter based on io.InputQueueCharacters[] contents because of trickling and key<>chars submission order are undefined)
 9415|      0|        if (g.IO.WantTextInput && IsKeyChordPotentiallyCharInput(key_chord))
  ------------------
  |  Branch (9415:13): [True: 0, False: 0]
  |  Branch (9415:35): [True: 0, False: 0]
  ------------------
 9416|      0|        {
 9417|      0|            IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> filtered as potential char input\n", GetKeyChordName(key_chord), flags, owner_id);
  ------------------
  |  |  252|      0|#define IMGUI_DEBUG_LOG_INPUTROUTING(...) do{if (g.DebugLogFlags & ImGuiDebugLogFlags_EventInputRouting)IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (252:50): [True: 0, False: 0]
  |  |  |  Branch (252:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 9418|      0|            return false;
 9419|      0|        }
 9420|       |
 9421|       |        // ActiveIdUsingAllKeyboardKeys trumps all for ActiveId
 9422|      0|        if ((flags & ImGuiInputFlags_RouteOverActive) == 0 && g.ActiveIdUsingAllKeyboardKeys)
  ------------------
  |  Branch (9422:13): [True: 0, False: 0]
  |  Branch (9422:63): [True: 0, False: 0]
  ------------------
 9423|      0|        {
 9424|      0|            ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
 9425|      0|            if (key == ImGuiKey_None)
  ------------------
  |  Branch (9425:17): [True: 0, False: 0]
  ------------------
 9426|      0|                key = ConvertSingleModFlagToKey((ImGuiKey)(key_chord & ImGuiMod_Mask_));
 9427|      0|            if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1361|      0|#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
  ------------------
                          if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1362|      0|#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
  ------------------
  |  Branch (9427:17): [True: 0, False: 0]
  |  Branch (9427:51): [True: 0, False: 0]
  ------------------
 9428|      0|                return false;
 9429|      0|        }
 9430|      0|    }
 9431|       |
 9432|       |    // Where do we evaluate route for?
 9433|      0|    ImGuiID focus_scope_id = g.CurrentFocusScopeId;
 9434|      0|    if (flags & ImGuiInputFlags_RouteFromRootWindow)
  ------------------
  |  Branch (9434:9): [True: 0, False: 0]
  ------------------
 9435|      0|        focus_scope_id = g.CurrentWindow->RootWindow->ID; // See PushFocusScope() call in Begin()
 9436|       |
 9437|      0|    const int score = CalcRoutingScore(focus_scope_id, owner_id, flags);
 9438|      0|    IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> score %d\n", GetKeyChordName(key_chord), flags, owner_id, score);
  ------------------
  |  |  252|      0|#define IMGUI_DEBUG_LOG_INPUTROUTING(...) do{if (g.DebugLogFlags & ImGuiDebugLogFlags_EventInputRouting)IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (252:50): [True: 0, False: 0]
  |  |  |  Branch (252:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 9439|      0|    if (score == 255)
  ------------------
  |  Branch (9439:9): [True: 0, False: 0]
  ------------------
 9440|      0|        return false;
 9441|       |
 9442|       |    // Submit routing for NEXT frame (assuming score is sufficient)
 9443|       |    // FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
 9444|      0|    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);
 9445|       |    //const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
 9446|      0|    if (score < routing_data->RoutingNextScore)
  ------------------
  |  Branch (9446:9): [True: 0, False: 0]
  ------------------
 9447|      0|    {
 9448|      0|        routing_data->RoutingNext = owner_id;
 9449|      0|        routing_data->RoutingNextScore = (ImU8)score;
 9450|      0|    }
 9451|       |
 9452|       |    // Return routing state for CURRENT frame
 9453|      0|    if (routing_data->RoutingCurr == owner_id)
  ------------------
  |  Branch (9453:9): [True: 0, False: 0]
  ------------------
 9454|      0|        IMGUI_DEBUG_LOG_INPUTROUTING("--> granting current route\n");
  ------------------
  |  |  252|      0|#define IMGUI_DEBUG_LOG_INPUTROUTING(...) do{if (g.DebugLogFlags & ImGuiDebugLogFlags_EventInputRouting)IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (252:50): [True: 0, False: 0]
  |  |  |  Branch (252:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 9455|      0|    return routing_data->RoutingCurr == owner_id;
 9456|      0|}
_ZN5ImGui9IsKeyDownE8ImGuiKey:
 9471|  1.15M|{
 9472|  1.15M|    return IsKeyDown(key, ImGuiKeyOwner_Any);
  ------------------
  |  | 1433|  1.15M|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
 9473|  1.15M|}
_ZN5ImGui9IsKeyDownE8ImGuiKeyj:
 9476|  1.16M|{
 9477|  1.16M|    const ImGuiKeyData* key_data = GetKeyData(key);
 9478|  1.16M|    if (!key_data->Down)
  ------------------
  |  Branch (9478:9): [True: 1.11M, False: 52.0k]
  ------------------
 9479|  1.11M|        return false;
 9480|  52.0k|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (9480:9): [True: 119, False: 51.9k]
  ------------------
 9481|    119|        return false;
 9482|  51.9k|    return true;
 9483|  52.0k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyb:
 9486|  88.0k|{
 9487|  88.0k|    return IsKeyPressed(key, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
  ------------------
  |  | 1433|  88.0k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9487:30): [True: 88.0k, False: 0]
  ------------------
 9488|  88.0k|}
_ZN5ImGui12IsKeyPressedE8ImGuiKeyij:
 9492|   369k|{
 9493|   369k|    const ImGuiKeyData* key_data = GetKeyData(key);
 9494|   369k|    if (!key_data->Down) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (9494:9): [True: 356k, False: 13.0k]
  ------------------
 9495|   356k|        return false;
 9496|  13.0k|    const float t = key_data->DownDuration;
 9497|  13.0k|    if (t < 0.0f)
  ------------------
  |  Branch (9497:9): [True: 0, False: 13.0k]
  ------------------
 9498|      0|        return false;
 9499|  13.0k|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|  13.0k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9500|  13.0k|    if (flags & (ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_)) // Setting any _RepeatXXX option enables _Repeat
  ------------------
  |  Branch (9500:9): [True: 1.57k, False: 11.4k]
  ------------------
 9501|  1.57k|        flags |= ImGuiInputFlags_Repeat;
 9502|       |
 9503|  13.0k|    bool pressed = (t == 0.0f);
 9504|  13.0k|    if (!pressed && (flags & ImGuiInputFlags_Repeat) != 0)
  ------------------
  |  Branch (9504:9): [True: 10.6k, False: 2.39k]
  |  Branch (9504:21): [True: 6.13k, False: 4.53k]
  ------------------
 9505|  6.13k|    {
 9506|  6.13k|        float repeat_delay, repeat_rate;
 9507|  6.13k|        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
 9508|  6.13k|        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
  ------------------
  |  Branch (9508:19): [True: 1.06k, False: 5.07k]
  |  Branch (9508:41): [True: 448, False: 614]
  ------------------
 9509|  6.13k|        if (pressed && (flags & ImGuiInputFlags_RepeatUntilMask_))
  ------------------
  |  Branch (9509:13): [True: 448, False: 5.69k]
  |  Branch (9509:24): [True: 0, False: 448]
  ------------------
 9510|      0|        {
 9511|       |            // Slightly bias 'key_pressed_time' as DownDuration is an accumulation of DeltaTime which we compare to an absolute time value.
 9512|       |            // Ideally we'd replace DownDuration with KeyPressedTime but it would break user's code.
 9513|      0|            ImGuiContext& g = *GImGui;
 9514|      0|            double key_pressed_time = g.Time - t + 0.00001f;
 9515|      0|            if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChange) && (g.LastKeyModsChangeTime > key_pressed_time))
  ------------------
  |  Branch (9515:17): [True: 0, False: 0]
  |  Branch (9515:71): [True: 0, False: 0]
  ------------------
 9516|      0|                pressed = false;
 9517|      0|            if ((flags & ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone) && (g.LastKeyModsChangeFromNoneTime > key_pressed_time))
  ------------------
  |  Branch (9517:17): [True: 0, False: 0]
  |  Branch (9517:79): [True: 0, False: 0]
  ------------------
 9518|      0|                pressed = false;
 9519|      0|            if ((flags & ImGuiInputFlags_RepeatUntilOtherKeyPress) && (g.LastKeyboardKeyPressTime > key_pressed_time))
  ------------------
  |  Branch (9519:17): [True: 0, False: 0]
  |  Branch (9519:71): [True: 0, False: 0]
  ------------------
 9520|      0|                pressed = false;
 9521|      0|        }
 9522|  6.13k|    }
 9523|  13.0k|    if (!pressed)
  ------------------
  |  Branch (9523:9): [True: 10.2k, False: 2.84k]
  ------------------
 9524|  10.2k|        return false;
 9525|  2.84k|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (9525:9): [True: 69, False: 2.77k]
  ------------------
 9526|     69|        return false;
 9527|  2.77k|    return true;
 9528|  2.84k|}
_ZN5ImGui13IsKeyReleasedE8ImGuiKey:
 9531|  2.50k|{
 9532|  2.50k|    return IsKeyReleased(key, ImGuiKeyOwner_Any);
  ------------------
  |  | 1433|  2.50k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
 9533|  2.50k|}
_ZN5ImGui13IsKeyReleasedE8ImGuiKeyj:
 9536|  2.50k|{
 9537|  2.50k|    const ImGuiKeyData* key_data = GetKeyData(key);
 9538|  2.50k|    if (key_data->DownDurationPrev < 0.0f || key_data->Down)
  ------------------
  |  Branch (9538:9): [True: 870, False: 1.63k]
  |  Branch (9538:46): [True: 1.02k, False: 611]
  ------------------
 9539|  1.89k|        return false;
 9540|    611|    if (!TestKeyOwner(key, owner_id))
  ------------------
  |  Branch (9540:9): [True: 0, False: 611]
  ------------------
 9541|      0|        return false;
 9542|    611|    return true;
 9543|    611|}
_ZN5ImGui11IsMouseDownEi:
 9546|      2|{
 9547|      2|    ImGuiContext& g = *GImGui;
 9548|      2|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9549|      2|    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // should be same as IsKeyDown(MouseButtonToKey(button), ImGuiKeyOwner_Any), but this allows legacy code hijacking the io.Mousedown[] array.
  ------------------
  |  | 1433|      2|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9549:12): [True: 2, False: 0]
  |  Branch (9549:38): [True: 2, False: 0]
  ------------------
 9550|      2|}
_ZN5ImGui11IsMouseDownEij:
 9553|      4|{
 9554|      4|    ImGuiContext& g = *GImGui;
 9555|      4|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|      4|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9556|      4|    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
  ------------------
  |  Branch (9556:12): [True: 4, False: 0]
  |  Branch (9556:38): [True: 4, False: 0]
  ------------------
 9557|      4|}
_ZN5ImGui14IsMouseClickedEib:
 9560|     30|{
 9561|     30|    return IsMouseClicked(button, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
  ------------------
  |  | 1433|     30|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9561:35): [True: 0, False: 30]
  ------------------
 9562|     30|}
_ZN5ImGui14IsMouseClickedEiij:
 9565|    164|{
 9566|    164|    ImGuiContext& g = *GImGui;
 9567|    164|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    164|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9568|    164|    if (!g.IO.MouseDown[button]) // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
  ------------------
  |  Branch (9568:9): [True: 99, False: 65]
  ------------------
 9569|     99|        return false;
 9570|     65|    const float t = g.IO.MouseDownDuration[button];
 9571|     65|    if (t < 0.0f)
  ------------------
  |  Branch (9571:9): [True: 0, False: 65]
  ------------------
 9572|      0|        return false;
 9573|     65|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByIsMouseClicked) == 0); // Passing flags not supported by this function! // FIXME: Could support RepeatRate and RepeatUntil flags here.
  ------------------
  |  |   23|     65|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9574|       |
 9575|     65|    const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
 9576|     65|    const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
  ------------------
  |  Branch (9576:26): [True: 3, False: 62]
  |  Branch (9576:42): [True: 0, False: 62]
  |  Branch (9576:52): [True: 0, False: 0]
  |  Branch (9576:79): [True: 0, False: 0]
  ------------------
 9577|     65|    if (!pressed)
  ------------------
  |  Branch (9577:9): [True: 62, False: 3]
  ------------------
 9578|     62|        return false;
 9579|       |
 9580|      3|    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
  ------------------
  |  Branch (9580:9): [True: 0, False: 3]
  ------------------
 9581|      0|        return false;
 9582|       |
 9583|      3|    return true;
 9584|      3|}
_ZN5ImGui15IsMouseReleasedEij:
 9594|    134|{
 9595|    134|    ImGuiContext& g = *GImGui;
 9596|    134|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    134|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9597|    134|    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
  ------------------
  |  Branch (9597:12): [True: 1, False: 133]
  |  Branch (9597:42): [True: 1, False: 0]
  ------------------
 9598|    134|}
_ZN5ImGui20IsMouseDoubleClickedEi:
 9601|     30|{
 9602|     30|    ImGuiContext& g = *GImGui;
 9603|     30|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|     30|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9604|     30|    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any);
  ------------------
  |  | 1433|      0|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (9604:12): [True: 0, False: 30]
  |  Branch (9604:51): [True: 0, False: 0]
  ------------------
 9605|     30|}
_ZN5ImGui19IsMouseHoveringRectERK6ImVec2S2_b:
 9625|   456k|{
 9626|   456k|    ImGuiContext& g = *GImGui;
 9627|       |
 9628|       |    // Clip
 9629|   456k|    ImRect rect_clipped(r_min, r_max);
 9630|   456k|    if (clip)
  ------------------
  |  Branch (9630:9): [True: 285k, False: 170k]
  ------------------
 9631|   285k|        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);
 9632|       |
 9633|       |    // Hit testing, expanded for touch input
 9634|   456k|    if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))
  ------------------
  |  Branch (9634:9): [True: 450k, False: 5.60k]
  ------------------
 9635|   450k|        return false;
 9636|  5.60k|    if (!g.MouseViewport->GetMainRect().Overlaps(rect_clipped))
  ------------------
  |  Branch (9636:9): [True: 0, False: 5.60k]
  ------------------
 9637|      0|        return false;
 9638|  5.60k|    return true;
 9639|  5.60k|}
_ZN5ImGui24IsMouseDragPastThresholdEif:
 9644|    216|{
 9645|    216|    ImGuiContext& g = *GImGui;
 9646|    216|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    216|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9647|    216|    if (lock_threshold < 0.0f)
  ------------------
  |  Branch (9647:9): [True: 216, False: 0]
  ------------------
 9648|    216|        lock_threshold = g.IO.MouseDragThreshold;
 9649|    216|    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
 9650|    216|}
_ZN5ImGui15IsMouseDraggingEif:
 9653|    238|{
 9654|    238|    ImGuiContext& g = *GImGui;
 9655|    238|    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
  ------------------
  |  |   23|    238|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9656|    238|    if (!g.IO.MouseDown[button])
  ------------------
  |  Branch (9656:9): [True: 22, False: 216]
  ------------------
 9657|     22|        return false;
 9658|    216|    return IsMouseDragPastThreshold(button, lock_threshold);
 9659|    238|}
_ZN5ImGui11GetMousePosEv:
 9662|  13.2k|{
 9663|  13.2k|    ImGuiContext& g = *GImGui;
 9664|  13.2k|    return g.IO.MousePos;
 9665|  13.2k|}
_ZN5ImGui15IsMousePosValidEPK6ImVec2:
 9689|   348k|{
 9690|       |    // The assert is only to silence a false-positive in XCode Static Analysis.
 9691|       |    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
 9692|   348k|    IM_ASSERT(GImGui != NULL);
  ------------------
  |  |   23|   348k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9693|   348k|    const float MOUSE_INVALID = -256000.0f;
 9694|   348k|    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
  ------------------
  |  Branch (9694:16): [True: 331k, False: 16.9k]
  ------------------
 9695|   348k|    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
  ------------------
  |  Branch (9695:12): [True: 293k, False: 55.4k]
  |  Branch (9695:36): [True: 293k, False: 0]
  ------------------
 9696|   348k|}
_ZN5ImGui17UpdateInputEventsEb:
10170|  76.6k|{
10171|  76.6k|    ImGuiContext& g = *GImGui;
10172|  76.6k|    ImGuiIO& io = g.IO;
10173|       |
10174|       |    // Only trickle chars<>key when working with InputText()
10175|       |    // FIXME: InputText() could parse event trail?
10176|       |    // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
10177|  76.6k|    const bool trickle_interleaved_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);
  ------------------
  |  Branch (10177:53): [True: 76.6k, False: 0]
  |  Branch (10177:76): [True: 0, False: 76.6k]
  ------------------
10178|       |
10179|  76.6k|    bool mouse_moved = false, mouse_wheeled = false, key_changed = false, text_inputted = false;
10180|  76.6k|    int  mouse_button_changed = 0x00;
10181|  76.6k|    ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;
10182|       |
10183|  76.6k|    int event_n = 0;
10184|   102k|    for (; event_n < g.InputEventsQueue.Size; event_n++)
  ------------------
  |  Branch (10184:12): [True: 35.8k, False: 66.9k]
  ------------------
10185|  35.8k|    {
10186|  35.8k|        ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
10187|  35.8k|        if (e->Type == ImGuiInputEventType_MousePos)
  ------------------
  |  Branch (10187:13): [True: 4.96k, False: 30.9k]
  ------------------
10188|  4.96k|        {
10189|  4.96k|            if (g.IO.WantSetMousePos)
  ------------------
  |  Branch (10189:17): [True: 0, False: 4.96k]
  ------------------
10190|      0|                continue;
10191|       |            // Trickling Rule: Stop processing queued events if we already handled a mouse button change
10192|  4.96k|            ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
10193|  4.96k|            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
  ------------------
  |  Branch (10193:17): [True: 4.96k, False: 0]
  |  Branch (10193:41): [True: 586, False: 4.37k]
  |  Branch (10193:70): [True: 698, False: 3.67k]
  |  Branch (10193:87): [True: 147, False: 3.53k]
  |  Branch (10193:102): [True: 0, False: 3.53k]
  ------------------
10194|  1.43k|                break;
10195|  3.53k|            io.MousePos = event_pos;
10196|  3.53k|            io.MouseSource = e->MousePos.MouseSource;
10197|  3.53k|            mouse_moved = true;
10198|  3.53k|        }
10199|  30.9k|        else if (e->Type == ImGuiInputEventType_MouseButton)
  ------------------
  |  Branch (10199:18): [True: 10.8k, False: 20.0k]
  ------------------
10200|  10.8k|        {
10201|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
10202|  10.8k|            const ImGuiMouseButton button = e->MouseButton.Button;
10203|  10.8k|            IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   23|  10.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10204|  10.8k|            if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
  ------------------
  |  Branch (10204:17): [True: 10.8k, False: 0]
  |  Branch (10204:41): [True: 2.85k, False: 8.04k]
  |  Branch (10204:83): [True: 934, False: 7.10k]
  ------------------
10205|  3.79k|                break;
10206|  7.10k|            if (trickle_fast_inputs && e->MouseButton.MouseSource == ImGuiMouseSource_TouchScreen && mouse_moved) // #2702: TouchScreen have no initial hover.
  ------------------
  |  Branch (10206:17): [True: 7.10k, False: 0]
  |  Branch (10206:40): [True: 0, False: 7.10k]
  |  Branch (10206:102): [True: 0, False: 0]
  ------------------
10207|      0|                break;
10208|  7.10k|            io.MouseDown[button] = e->MouseButton.Down;
10209|  7.10k|            io.MouseSource = e->MouseButton.MouseSource;
10210|  7.10k|            mouse_button_changed |= (1 << button);
10211|  7.10k|        }
10212|  20.0k|        else if (e->Type == ImGuiInputEventType_MouseWheel)
  ------------------
  |  Branch (10212:18): [True: 4.78k, False: 15.2k]
  ------------------
10213|  4.78k|        {
10214|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the event
10215|  4.78k|            if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
  ------------------
  |  Branch (10215:17): [True: 4.78k, False: 0]
  |  Branch (10215:41): [True: 1.53k, False: 3.24k]
  |  Branch (10215:56): [True: 580, False: 2.66k]
  ------------------
10216|  2.11k|                break;
10217|  2.66k|            io.MouseWheelH += e->MouseWheel.WheelX;
10218|  2.66k|            io.MouseWheel += e->MouseWheel.WheelY;
10219|  2.66k|            io.MouseSource = e->MouseWheel.MouseSource;
10220|  2.66k|            mouse_wheeled = true;
10221|  2.66k|        }
10222|  15.2k|        else if (e->Type == ImGuiInputEventType_MouseViewport)
  ------------------
  |  Branch (10222:18): [True: 0, False: 15.2k]
  ------------------
10223|      0|        {
10224|      0|            io.MouseHoveredViewport = e->MouseViewport.HoveredViewportID;
10225|      0|        }
10226|  15.2k|        else if (e->Type == ImGuiInputEventType_Key)
  ------------------
  |  Branch (10226:18): [True: 8.57k, False: 6.67k]
  ------------------
10227|  8.57k|        {
10228|       |            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
10229|  8.57k|            if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
  ------------------
  |  Branch (10229:17): [True: 0, False: 8.57k]
  ------------------
10230|      0|                continue;
10231|  8.57k|            ImGuiKey key = e->Key.Key;
10232|  8.57k|            IM_ASSERT(key != ImGuiKey_None);
  ------------------
  |  |   23|  8.57k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10233|  8.57k|            ImGuiKeyData* key_data = GetKeyData(key);
10234|  8.57k|            const int key_data_index = (int)(key_data - g.IO.KeysData);
10235|  8.57k|            if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || text_inputted || mouse_button_changed != 0))
  ------------------
  |  Branch (10235:17): [True: 8.57k, False: 0]
  |  Branch (10235:40): [True: 7.71k, False: 860]
  |  Branch (10235:74): [True: 1.48k, False: 6.23k]
  |  Branch (10235:118): [True: 0, False: 6.23k]
  |  Branch (10235:135): [True: 47, False: 6.18k]
  ------------------
10236|  1.53k|                break;
10237|  7.04k|            key_data->Down = e->Key.Down;
10238|  7.04k|            key_data->AnalogValue = e->Key.AnalogValue;
10239|  7.04k|            key_changed = true;
10240|  7.04k|            key_changed_mask.SetBit(key_data_index);
10241|       |
10242|       |            // Allow legacy code using io.KeysDown[GetKeyIndex()] with new backends
10243|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
10244|       |            io.KeysDown[key_data_index] = key_data->Down;
10245|       |            if (io.KeyMap[key_data_index] != -1)
10246|       |                io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;
10247|       |#endif
10248|  7.04k|        }
10249|  6.67k|        else if (e->Type == ImGuiInputEventType_Text)
  ------------------
  |  Branch (10249:18): [True: 4.01k, False: 2.65k]
  ------------------
10250|  4.01k|        {
10251|  4.01k|            if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
  ------------------
  |  Branch (10251:17): [True: 0, False: 4.01k]
  ------------------
10252|      0|                continue;
10253|       |            // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
10254|  4.01k|            if (trickle_fast_inputs && ((key_changed && trickle_interleaved_keys_and_text) || mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
  ------------------
  |  Branch (10254:17): [True: 4.01k, False: 0]
  |  Branch (10254:42): [True: 138, False: 3.87k]
  |  Branch (10254:57): [True: 0, False: 138]
  |  Branch (10254:95): [True: 280, False: 3.73k]
  |  Branch (10254:124): [True: 405, False: 3.33k]
  |  Branch (10254:139): [True: 159, False: 3.17k]
  ------------------
10255|    844|                break;
10256|  3.17k|            unsigned int c = e->Text.Char;
10257|  3.17k|            io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2542|  3.17k|#define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
  ------------------
                          io.InputQueueCharacters.push_back(c <= IM_UNICODE_CODEPOINT_MAX ? (ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
  ------------------
  |  | 2538|  5.22k|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
  |  Branch (10257:47): [True: 1.12k, False: 2.04k]
  ------------------
10258|  3.17k|            if (trickle_interleaved_keys_and_text)
  ------------------
  |  Branch (10258:17): [True: 0, False: 3.17k]
  ------------------
10259|      0|                text_inputted = true;
10260|  3.17k|        }
10261|  2.65k|        else if (e->Type == ImGuiInputEventType_Focus)
  ------------------
  |  Branch (10261:18): [True: 2.65k, False: 0]
  ------------------
10262|  2.65k|        {
10263|       |            // We intentionally overwrite this and process in NewFrame(), in order to give a chance
10264|       |            // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
10265|  2.65k|            const bool focus_lost = !e->AppFocused.Focused;
10266|  2.65k|            io.AppFocusLost = focus_lost;
10267|  2.65k|        }
10268|      0|        else
10269|      0|        {
10270|      0|            IM_ASSERT(0 && "Unknown event!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10271|      0|        }
10272|  35.8k|    }
10273|       |
10274|       |    // Record trail (for domain-specific applications wanting to access a precise trail)
10275|       |    //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
10276|   102k|    for (int n = 0; n < event_n; n++)
  ------------------
  |  Branch (10276:21): [True: 26.1k, False: 76.6k]
  ------------------
10277|  26.1k|        g.InputEventsTrail.push_back(g.InputEventsQueue[n]);
10278|       |
10279|       |    // [DEBUG]
10280|  76.6k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
10281|  76.6k|    if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
  ------------------
  |  Branch (10281:9): [True: 21.3k, False: 55.3k]
  |  Branch (10281:25): [True: 0, False: 21.3k]
  ------------------
10282|      0|        for (int n = 0; n < g.InputEventsQueue.Size; n++)
  ------------------
  |  Branch (10282:25): [True: 0, False: 0]
  ------------------
10283|      0|            DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
  ------------------
  |  Branch (10283:34): [True: 0, False: 0]
  ------------------
10284|  76.6k|#endif
10285|       |
10286|       |    // Remaining events will be processed on the next frame
10287|  76.6k|    if (event_n == g.InputEventsQueue.Size)
  ------------------
  |  Branch (10287:9): [True: 66.9k, False: 9.71k]
  ------------------
10288|  66.9k|        g.InputEventsQueue.resize(0);
10289|  9.71k|    else
10290|  9.71k|        g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
10291|       |
10292|       |    // Clear buttons state when focus is lost
10293|       |    // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
10294|       |    // - we clear in EndFrame() and not now in order allow application/user code polling this flag
10295|       |    //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
10296|  76.6k|    if (g.IO.AppFocusLost)
  ------------------
  |  Branch (10296:9): [True: 2.61k, False: 74.0k]
  ------------------
10297|  2.61k|    {
10298|  2.61k|        g.IO.ClearInputKeys();
10299|  2.61k|        g.IO.ClearInputMouse();
10300|  2.61k|    }
10301|  76.6k|}
_ZN5ImGui11GetKeyOwnerE8ImGuiKey:
10304|      2|{
10305|      2|    if (!IsNamedKeyOrMod(key))
  ------------------
  |  Branch (10305:9): [True: 0, False: 2]
  ------------------
10306|      0|        return ImGuiKeyOwner_NoOwner;
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
10307|       |
10308|      2|    ImGuiContext& g = *GImGui;
10309|      2|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
10310|      2|    ImGuiID owner_id = owner_data->OwnerCurr;
10311|       |
10312|      2|    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
  ------------------
  |  | 1433|      0|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (10312:9): [True: 0, False: 2]
  |  Branch (10312:43): [True: 0, False: 0]
  |  Branch (10312:69): [True: 0, False: 0]
  ------------------
10313|      0|        if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1361|      0|#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
  ------------------
                      if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1362|      0|#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
  ------------------
  |  Branch (10313:13): [True: 0, False: 0]
  |  Branch (10313:47): [True: 0, False: 0]
  ------------------
10314|      0|            return ImGuiKeyOwner_NoOwner;
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
10315|       |
10316|      2|    return owner_id;
10317|      2|}
_ZN5ImGui12TestKeyOwnerE8ImGuiKeyj:
10324|   213k|{
10325|   213k|    if (!IsNamedKeyOrMod(key))
  ------------------
  |  Branch (10325:9): [True: 0, False: 213k]
  ------------------
10326|      0|        return true;
10327|       |
10328|   213k|    ImGuiContext& g = *GImGui;
10329|   213k|    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any)
  ------------------
  |  | 1433|  1.38k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (10329:9): [True: 1.38k, False: 212k]
  |  Branch (10329:43): [True: 1.38k, False: 0]
  |  Branch (10329:69): [True: 1.24k, False: 135]
  ------------------
10330|  1.24k|        if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1361|  2.49k|#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
  ------------------
                      if (key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END)
  ------------------
  |  | 1362|  1.24k|#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
  ------------------
  |  Branch (10330:13): [True: 1.24k, False: 0]
  |  Branch (10330:47): [True: 188, False: 1.06k]
  ------------------
10331|    188|            return false;
10332|       |
10333|   213k|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
10334|   213k|    if (owner_id == ImGuiKeyOwner_Any)
  ------------------
  |  | 1433|   213k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (10334:9): [True: 51.7k, False: 161k]
  ------------------
10335|  51.7k|        return (owner_data->LockThisFrame == false);
10336|       |
10337|       |    // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
10338|       |    // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
10339|       |    // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
10340|   161k|    if (owner_data->OwnerCurr != owner_id)
  ------------------
  |  Branch (10340:9): [True: 3, False: 161k]
  ------------------
10341|      3|    {
10342|      3|        if (owner_data->LockThisFrame)
  ------------------
  |  Branch (10342:13): [True: 0, False: 3]
  ------------------
10343|      0|            return false;
10344|      3|        if (owner_data->OwnerCurr != ImGuiKeyOwner_NoOwner)
  ------------------
  |  | 1434|      3|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (10344:13): [True: 0, False: 3]
  ------------------
10345|      0|            return false;
10346|      3|    }
10347|       |
10348|   161k|    return true;
10349|   161k|}
_ZN5ImGui11SetKeyOwnerE8ImGuiKeyji:
10357|      3|{
10358|      3|    ImGuiContext& g = *GImGui;
10359|      3|    IM_ASSERT(IsNamedKeyOrMod(key) && (owner_id != ImGuiKeyOwner_Any || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10360|      3|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10361|       |    //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X, flags=%08X)\n", GetKeyName(key), owner_id, flags);
10362|       |
10363|      3|    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
10364|      3|    owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;
10365|       |
10366|       |    // We cannot lock by default as it would likely break lots of legacy code.
10367|       |    // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
10368|      3|    owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
10369|      3|    owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);
  ------------------
  |  Branch (10369:33): [True: 0, False: 3]
  |  Branch (10369:81): [True: 0, False: 3]
  ------------------
10370|      3|}
_ZN5ImGui17IsKeyChordPressedEiij:
10411|   153k|{
10412|   153k|    ImGuiContext& g = *GImGui;
10413|   153k|    key_chord = FixupKeyChord(key_chord);
10414|   153k|    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
10415|   153k|    if (g.IO.KeyMods != mods)
  ------------------
  |  Branch (10415:9): [True: 153k, False: 0]
  ------------------
10416|   153k|        return false;
10417|       |
10418|       |    // Special storage location for mods
10419|      0|    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
10420|      0|    if (key == ImGuiKey_None)
  ------------------
  |  Branch (10420:9): [True: 0, False: 0]
  ------------------
10421|      0|        key = ConvertSingleModFlagToKey(mods);
10422|      0|    if (!IsKeyPressed(key, (flags & ImGuiInputFlags_RepeatMask_), owner_id))
  ------------------
  |  Branch (10422:9): [True: 0, False: 0]
  ------------------
10423|      0|        return false;
10424|      0|    return true;
10425|      0|}
_ZN5ImGui8ShortcutEiij:
10466|   153k|{
10467|   153k|    ImGuiContext& g = *GImGui;
10468|       |    //IMGUI_DEBUG_LOG("Shortcut(%s, flags=%X, owner_id=0x%08X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), flags, owner_id);
10469|       |
10470|       |    // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
10471|   153k|    if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0)
  ------------------
  |  Branch (10471:9): [True: 0, False: 153k]
  ------------------
10472|      0|        flags |= ImGuiInputFlags_RouteFocused;
10473|       |
10474|       |    // Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
10475|       |    // Effectively makes Shortcut() always input-owner aware.
10476|   153k|    if (owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_NoOwner)
  ------------------
  |  | 1433|   306k|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
                  if (owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_NoOwner)
  ------------------
  |  | 1434|   153k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (10476:9): [True: 0, False: 153k]
  |  Branch (10476:42): [True: 0, False: 153k]
  ------------------
10477|      0|        owner_id = GetRoutingIdFromOwnerId(owner_id);
10478|       |
10479|   153k|    if (g.CurrentItemFlags & ImGuiItemFlags_Disabled)
  ------------------
  |  Branch (10479:9): [True: 0, False: 153k]
  ------------------
10480|      0|        return false;
10481|       |
10482|       |    // Submit route
10483|   153k|    if (!SetShortcutRouting(key_chord, flags, owner_id))
  ------------------
  |  Branch (10483:9): [True: 0, False: 153k]
  ------------------
10484|      0|        return false;
10485|       |
10486|       |    // Default repeat behavior for Shortcut()
10487|       |    // So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
10488|   153k|    if ((flags & ImGuiInputFlags_Repeat) != 0 && (flags & ImGuiInputFlags_RepeatUntilMask_) == 0)
  ------------------
  |  Branch (10488:9): [True: 153k, False: 0]
  |  Branch (10488:50): [True: 153k, False: 0]
  ------------------
10489|   153k|        flags |= ImGuiInputFlags_RepeatUntilKeyModsChange;
10490|       |
10491|   153k|    if (!IsKeyChordPressed(key_chord, flags, owner_id))
  ------------------
  |  Branch (10491:9): [True: 153k, False: 0]
  ------------------
10492|   153k|        return false;
10493|       |
10494|       |    // Claim mods during the press
10495|      0|    SetKeyOwnersForKeyChord(key_chord & ImGuiMod_Mask_, owner_id);
10496|       |
10497|      0|    IM_ASSERT((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10498|      0|    return true;
10499|   153k|}
_ZN5ImGui30DebugCheckVersionAndDataLayoutEPKcmmmmmm:
10517|      1|{
10518|      1|    bool error = false;
10519|      1|    if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   30|      1|#define IMGUI_VERSION       "1.90.9 WIP"
  ------------------
                  if (strcmp(version, IMGUI_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10519:9): [True: 0, False: 1]
  ------------------
10520|      1|    if (sz_io    != sizeof(ImGuiIO))    { error = true; IM_ASSERT(sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10520:9): [True: 0, False: 1]
  ------------------
10521|      1|    if (sz_style != sizeof(ImGuiStyle)) { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10521:9): [True: 0, False: 1]
  ------------------
10522|      1|    if (sz_vec2  != sizeof(ImVec2))     { error = true; IM_ASSERT(sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10522:9): [True: 0, False: 1]
  ------------------
10523|      1|    if (sz_vec4  != sizeof(ImVec4))     { error = true; IM_ASSERT(sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10523:9): [True: 0, False: 1]
  ------------------
10524|      1|    if (sz_vert  != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10524:9): [True: 0, False: 1]
  ------------------
10525|      1|    if (sz_idx   != sizeof(ImDrawIdx))  { error = true; IM_ASSERT(sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!"); }
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10525:9): [True: 0, False: 1]
  ------------------
10526|      1|    return !error;
10527|      1|}
_ZN15ImGuiStackSizes17SetToContextStateEP12ImGuiContext:
10784|   170k|{
10785|   170k|    ImGuiContext& g = *ctx;
10786|   170k|    ImGuiWindow* window = g.CurrentWindow;
10787|   170k|    SizeOfIDStack = (short)window->IDStack.Size;
10788|   170k|    SizeOfColorStack = (short)g.ColorStack.Size;
10789|   170k|    SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
10790|   170k|    SizeOfFontStack = (short)g.FontStack.Size;
10791|   170k|    SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
10792|   170k|    SizeOfGroupStack = (short)g.GroupStack.Size;
10793|   170k|    SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
10794|   170k|    SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
10795|   170k|    SizeOfDisabledStack = (short)g.DisabledStackSize;
10796|   170k|}
_ZN15ImGuiStackSizes23CompareWithContextStateEP12ImGuiContext:
10800|   170k|{
10801|   170k|    ImGuiContext& g = *ctx;
10802|   170k|    ImGuiWindow* window = g.CurrentWindow;
10803|   170k|    IM_UNUSED(window);
  ------------------
  |  |   94|   170k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
10804|       |
10805|       |    // Window stacks
10806|       |    // NOT checking: DC.ItemWidth, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
10807|   170k|    IM_ASSERT(SizeOfIDStack         == window->IDStack.Size     && "PushID/PopID or TreeNode/TreePop Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10808|       |
10809|       |    // Global stacks
10810|       |    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
10811|   170k|    IM_ASSERT(SizeOfGroupStack      == g.GroupStack.Size        && "BeginGroup/EndGroup Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10812|   170k|    IM_ASSERT(SizeOfBeginPopupStack == g.BeginPopupStack.Size   && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10813|   170k|    IM_ASSERT(SizeOfDisabledStack   == g.DisabledStackSize      && "BeginDisabled/EndDisabled Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10814|   170k|    IM_ASSERT(SizeOfItemFlagsStack  >= g.ItemFlagsStack.Size    && "PushItemFlag/PopItemFlag Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10815|   170k|    IM_ASSERT(SizeOfColorStack      >= g.ColorStack.Size        && "PushStyleColor/PopStyleColor Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10816|   170k|    IM_ASSERT(SizeOfStyleVarStack   >= g.StyleVarStack.Size     && "PushStyleVar/PopStyleVar Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10817|   170k|    IM_ASSERT(SizeOfFontStack       >= g.FontStack.Size         && "PushFont/PopFont Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10818|   170k|    IM_ASSERT(SizeOfFocusScopeStack == g.FocusScopeStack.Size   && "PushFocusScope/PopFocusScope Mismatch!");
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10819|   170k|}
_ZN5ImGui11KeepAliveIDEj:
10830|   280k|{
10831|   280k|    ImGuiContext& g = *GImGui;
10832|   280k|    if (g.ActiveId == id)
  ------------------
  |  Branch (10832:9): [True: 721, False: 279k]
  ------------------
10833|    721|        g.ActiveIdIsAlive = id;
10834|   280k|    if (g.ActiveIdPreviousFrame == id)
  ------------------
  |  Branch (10834:9): [True: 722, False: 279k]
  ------------------
10835|    722|        g.ActiveIdPreviousFrameIsAlive = true;
10836|   280k|}
_ZN5ImGui7ItemAddERK6ImRectjPS1_i:
10844|   296k|{
10845|   296k|    ImGuiContext& g = *GImGui;
10846|   296k|    ImGuiWindow* window = g.CurrentWindow;
10847|       |
10848|       |    // Set item data
10849|       |    // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
10850|   296k|    g.LastItemData.ID = id;
10851|   296k|    g.LastItemData.Rect = bb;
10852|   296k|    g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
  ------------------
  |  Branch (10852:30): [True: 0, False: 296k]
  ------------------
10853|   296k|    g.LastItemData.InFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
10854|   296k|    g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
10855|       |    // Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.
10856|       |
10857|   296k|    if (id != 0)
  ------------------
  |  Branch (10857:9): [True: 279k, False: 16.9k]
  ------------------
10858|   279k|    {
10859|   279k|        KeepAliveID(id);
10860|       |
10861|       |        // Directional navigation processing
10862|       |        // Runs prior to clipping early-out
10863|       |        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
10864|       |        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
10865|       |        //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
10866|       |        //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
10867|       |        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
10868|       |        //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
10869|       |        // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
10870|       |        // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
10871|   279k|        if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
  ------------------
  |  Branch (10871:13): [True: 169k, False: 110k]
  ------------------
10872|   169k|        {
10873|       |            // FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
10874|   169k|            window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
10875|   169k|            if (g.NavId == id || g.NavAnyRequest)
  ------------------
  |  Branch (10875:17): [True: 762, False: 168k]
  |  Branch (10875:34): [True: 1.55k, False: 166k]
  ------------------
10876|  2.31k|                if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
  ------------------
  |  Branch (10876:21): [True: 664, False: 1.65k]
  ------------------
10877|    664|                    if (window == g.NavWindow || ((window->ChildFlags | g.NavWindow->ChildFlags) & ImGuiChildFlags_NavFlattened))
  ------------------
  |  Branch (10877:25): [True: 664, False: 0]
  |  Branch (10877:50): [True: 0, False: 0]
  ------------------
10878|    664|                        NavProcessItem();
10879|   169k|        }
10880|       |
10881|   279k|        if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasShortcut)
  ------------------
  |  Branch (10881:13): [True: 0, False: 279k]
  ------------------
10882|      0|            ItemHandleShortcut(id);
10883|   279k|    }
10884|       |
10885|       |    // Lightweight clear of SetNextItemXXX data.
10886|   296k|    g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
10887|   296k|    g.NextItemData.ItemFlags = ImGuiItemFlags_None;
10888|       |
10889|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
10890|       |    if (id != 0)
10891|       |        IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
10892|       |#endif
10893|       |
10894|       |    // Clipping test
10895|       |    // (this is an inline copy of IsClippedEx() so we can reuse the is_rect_visible value, otherwise we'd do 'if (IsClippedEx(bb, id)) return false')
10896|       |    // g.NavActivateId is not necessarily == g.NavId, in the case of remote activation (e.g. shortcuts)
10897|   296k|    const bool is_rect_visible = bb.Overlaps(window->ClipRect);
10898|   296k|    if (!is_rect_visible)
  ------------------
  |  Branch (10898:9): [True: 15.4k, False: 281k]
  ------------------
10899|  15.4k|        if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId))
  ------------------
  |  Branch (10899:13): [True: 14.6k, False: 753]
  |  Branch (10899:25): [True: 753, False: 0]
  |  Branch (10899:45): [True: 753, False: 0]
  |  Branch (10899:78): [True: 753, False: 0]
  |  Branch (10899:95): [True: 753, False: 0]
  ------------------
10900|  15.4k|            if (!g.ItemUnclipByLog)
  ------------------
  |  Branch (10900:17): [True: 15.4k, False: 0]
  ------------------
10901|  15.4k|                return false;
10902|       |
10903|       |    // [DEBUG]
10904|   281k|#ifndef IMGUI_DISABLE_DEBUG_TOOLS
10905|   281k|    if (id != 0)
  ------------------
  |  Branch (10905:9): [True: 278k, False: 2.26k]
  ------------------
10906|   278k|    {
10907|   278k|        if (id == g.DebugLocateId)
  ------------------
  |  Branch (10907:13): [True: 0, False: 278k]
  ------------------
10908|      0|            DebugLocateItemResolveWithLastItem();
10909|       |
10910|       |        // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
10911|       |        // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
10912|       |        // READ THE FAQ: https://dearimgui.com/faq
10913|   278k|        IM_ASSERT(id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
  ------------------
  |  |   23|   278k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10914|   278k|    }
10915|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
10916|       |    //if ((g.LastItemData.InFlags & ImGuiItemFlags_NoNav) == 0)
10917|       |    //    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
10918|   281k|#endif
10919|       |
10920|       |    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
10921|   281k|    if (is_rect_visible)
  ------------------
  |  Branch (10921:9): [True: 281k, False: 0]
  ------------------
10922|   281k|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
10923|   281k|    if (IsMouseHoveringRect(bb.Min, bb.Max))
  ------------------
  |  Branch (10923:9): [True: 2.01k, False: 279k]
  ------------------
10924|  2.01k|        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
10925|   281k|    return true;
10926|   296k|}
_ZN5ImGui8ItemSizeERK6ImVec2f:
10966|  33.8k|{
10967|  33.8k|    ImGuiContext& g = *GImGui;
10968|  33.8k|    ImGuiWindow* window = g.CurrentWindow;
10969|  33.8k|    if (window->SkipItems)
  ------------------
  |  Branch (10969:9): [True: 0, False: 33.8k]
  ------------------
10970|      0|        return;
10971|       |
10972|       |    // We increase the height in this function to accommodate for baseline offset.
10973|       |    // In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
10974|       |    // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
10975|  33.8k|    const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;
  ------------------
  |  Branch (10975:46): [True: 0, False: 33.8k]
  ------------------
10976|       |
10977|  33.8k|    const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
  ------------------
  |  Branch (10977:27): [True: 0, False: 33.8k]
  ------------------
10978|  33.8k|    const float line_height = ImMax(window->DC.CurrLineSize.y, /*ImMax(*/window->DC.CursorPos.y - line_y1/*, 0.0f)*/ + size.y + offset_to_match_baseline_y);
10979|       |
10980|       |    // Always align ourselves on pixel boundaries
10981|       |    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
10982|  33.8k|    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
10983|  33.8k|    window->DC.CursorPosPrevLine.y = line_y1;
10984|  33.8k|    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);    // Next line
  ------------------
  |  |  287|  33.8k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
10985|  33.8k|    window->DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
  ------------------
  |  |  287|  33.8k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
10986|  33.8k|    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
10987|  33.8k|    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
10988|       |    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]
10989|       |
10990|  33.8k|    window->DC.PrevLineSize.y = line_height;
10991|  33.8k|    window->DC.CurrLineSize.y = 0.0f;
10992|  33.8k|    window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
10993|  33.8k|    window->DC.CurrLineTextBaseOffset = 0.0f;
10994|  33.8k|    window->DC.IsSameLine = window->DC.IsSetPos = false;
10995|       |
10996|       |    // Horizontal layout mode
10997|  33.8k|    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
  ------------------
  |  Branch (10997:9): [True: 0, False: 33.8k]
  ------------------
10998|      0|        SameLine();
10999|  33.8k|}
_ZN5ImGui18GetCursorScreenPosEv:
11034|  30.1k|{
11035|  30.1k|    ImGuiWindow* window = GetCurrentWindowRead();
11036|  30.1k|    return window->DC.CursorPos;
11037|  30.1k|}
_ZN5ImGui12CalcItemSizeE6ImVec2ff:
11182|  16.9k|{
11183|  16.9k|    ImGuiContext& g = *GImGui;
11184|  16.9k|    ImGuiWindow* window = g.CurrentWindow;
11185|       |
11186|  16.9k|    ImVec2 region_max;
11187|  16.9k|    if (size.x < 0.0f || size.y < 0.0f)
  ------------------
  |  Branch (11187:9): [True: 0, False: 16.9k]
  |  Branch (11187:26): [True: 0, False: 16.9k]
  ------------------
11188|      0|        region_max = GetContentRegionMaxAbs();
11189|       |
11190|  16.9k|    if (size.x == 0.0f)
  ------------------
  |  Branch (11190:9): [True: 4.15k, False: 12.7k]
  ------------------
11191|  4.15k|        size.x = default_w;
11192|  12.7k|    else if (size.x < 0.0f)
  ------------------
  |  Branch (11192:14): [True: 0, False: 12.7k]
  ------------------
11193|      0|        size.x = ImMax(4.0f, region_max.x - window->DC.CursorPos.x + size.x);
11194|       |
11195|  16.9k|    if (size.y == 0.0f)
  ------------------
  |  Branch (11195:9): [True: 2.17k, False: 14.7k]
  ------------------
11196|  2.17k|        size.y = default_h;
11197|  14.7k|    else if (size.y < 0.0f)
  ------------------
  |  Branch (11197:14): [True: 0, False: 14.7k]
  ------------------
11198|      0|        size.y = ImMax(4.0f, region_max.y - window->DC.CursorPos.y + size.y);
11199|       |
11200|  16.9k|    return size;
11201|  16.9k|}
_ZN5ImGui28GetTextLineHeightWithSpacingEv:
11210|  16.9k|{
11211|  16.9k|    ImGuiContext& g = *GImGui;
11212|  16.9k|    return g.FontSize + g.Style.ItemSpacing.y;
11213|  16.9k|}
_ZN5ImGui14GetFrameHeightEv:
11216|    531|{
11217|    531|    ImGuiContext& g = *GImGui;
11218|    531|    return g.FontSize + g.Style.FramePadding.y * 2.0f;
11219|    531|}
_ZN5ImGui22GetContentRegionMaxAbsEv:
11240|  16.9k|{
11241|  16.9k|    ImGuiContext& g = *GImGui;
11242|  16.9k|    ImGuiWindow* window = g.CurrentWindow;
11243|  16.9k|    ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;
  ------------------
  |  Branch (11243:18): [True: 0, False: 16.9k]
  |  Branch (11243:47): [True: 0, False: 16.9k]
  ------------------
11244|  16.9k|    return mx;
11245|  16.9k|}
_ZN5ImGui21GetContentRegionAvailEv:
11248|  16.9k|{
11249|  16.9k|    ImGuiWindow* window = GImGui->CurrentWindow;
11250|  16.9k|    return GetContentRegionMaxAbs() - window->DC.CursorPos;
11251|  16.9k|}
_ZN5ImGui25GetWindowContentRegionMaxEv:
11261|  16.9k|{
11262|  16.9k|    ImGuiWindow* window = GImGui->CurrentWindow;
11263|  16.9k|    return window->ContentRegionRect.Max - window->Pos;
11264|  16.9k|}
_ZN5ImGui14ScrollToRectExEP11ImGuiWindowRK6ImRecti:
11421|     51|{
11422|     51|    ImGuiContext& g = *GImGui;
11423|     51|    ImRect scroll_rect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1));
11424|     51|    scroll_rect.Min.x = ImMin(scroll_rect.Min.x + window->DecoInnerSizeX1, scroll_rect.Max.x);
11425|     51|    scroll_rect.Min.y = ImMin(scroll_rect.Min.y + window->DecoInnerSizeY1, scroll_rect.Max.y);
11426|       |    //GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max, IM_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
11427|       |    //GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max, IM_COL32_WHITE); // [DEBUG]
11428|       |
11429|       |    // Check that only one behavior is selected per axis
11430|     51|    IM_ASSERT((flags & ImGuiScrollFlags_MaskX_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskX_));
  ------------------
  |  |   23|     51|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11431|     51|    IM_ASSERT((flags & ImGuiScrollFlags_MaskY_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskY_));
  ------------------
  |  |   23|     51|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11432|       |
11433|       |    // Defaults
11434|     51|    ImGuiScrollFlags in_flags = flags;
11435|     51|    if ((flags & ImGuiScrollFlags_MaskX_) == 0 && window->ScrollbarX)
  ------------------
  |  Branch (11435:9): [True: 49, False: 2]
  |  Branch (11435:51): [True: 0, False: 49]
  ------------------
11436|      0|        flags |= ImGuiScrollFlags_KeepVisibleEdgeX;
11437|     51|    if ((flags & ImGuiScrollFlags_MaskY_) == 0)
  ------------------
  |  Branch (11437:9): [True: 49, False: 2]
  ------------------
11438|     49|        flags |= window->Appearing ? ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeY;
  ------------------
  |  Branch (11438:18): [True: 0, False: 49]
  ------------------
11439|       |
11440|     51|    const bool fully_visible_x = item_rect.Min.x >= scroll_rect.Min.x && item_rect.Max.x <= scroll_rect.Max.x;
  ------------------
  |  Branch (11440:34): [True: 51, False: 0]
  |  Branch (11440:74): [True: 51, False: 0]
  ------------------
11441|     51|    const bool fully_visible_y = item_rect.Min.y >= scroll_rect.Min.y && item_rect.Max.y <= scroll_rect.Max.y;
  ------------------
  |  Branch (11441:34): [True: 51, False: 0]
  |  Branch (11441:74): [True: 51, False: 0]
  ------------------
11442|     51|    const bool can_be_fully_visible_x = (item_rect.GetWidth() + g.Style.ItemSpacing.x * 2.0f) <= scroll_rect.GetWidth() || (window->AutoFitFramesX > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;
  ------------------
  |  Branch (11442:41): [True: 51, False: 0]
  |  Branch (11442:124): [True: 0, False: 0]
  |  Branch (11442:156): [True: 0, False: 0]
  ------------------
11443|     51|    const bool can_be_fully_visible_y = (item_rect.GetHeight() + g.Style.ItemSpacing.y * 2.0f) <= scroll_rect.GetHeight() || (window->AutoFitFramesY > 0) || (window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0;
  ------------------
  |  Branch (11443:41): [True: 51, False: 0]
  |  Branch (11443:126): [True: 0, False: 0]
  |  Branch (11443:158): [True: 0, False: 0]
  ------------------
11444|       |
11445|     51|    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeX) && !fully_visible_x)
  ------------------
  |  Branch (11445:9): [True: 2, False: 49]
  |  Branch (11445:56): [True: 0, False: 2]
  ------------------
11446|      0|    {
11447|      0|        if (item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x)
  ------------------
  |  Branch (11447:13): [True: 0, False: 0]
  |  Branch (11447:52): [True: 0, False: 0]
  ------------------
11448|      0|            SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window->Pos.x, 0.0f);
11449|      0|        else if (item_rect.Max.x >= scroll_rect.Max.x)
  ------------------
  |  Branch (11449:18): [True: 0, False: 0]
  ------------------
11450|      0|            SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window->Pos.x, 1.0f);
11451|      0|    }
11452|     51|    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterX) && !fully_visible_x) || (flags & ImGuiScrollFlags_AlwaysCenterX))
  ------------------
  |  Branch (11452:15): [True: 0, False: 51]
  |  Branch (11452:64): [True: 0, False: 0]
  |  Branch (11452:85): [True: 0, False: 51]
  ------------------
11453|      0|    {
11454|      0|        if (can_be_fully_visible_x)
  ------------------
  |  Branch (11454:13): [True: 0, False: 0]
  ------------------
11455|      0|            SetScrollFromPosX(window, ImTrunc((item_rect.Min.x + item_rect.Max.x) * 0.5f) - window->Pos.x, 0.5f);
11456|      0|        else
11457|      0|            SetScrollFromPosX(window, item_rect.Min.x - window->Pos.x, 0.0f);
11458|      0|    }
11459|       |
11460|     51|    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeY) && !fully_visible_y)
  ------------------
  |  Branch (11460:9): [True: 51, False: 0]
  |  Branch (11460:56): [True: 0, False: 51]
  ------------------
11461|      0|    {
11462|      0|        if (item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y)
  ------------------
  |  Branch (11462:13): [True: 0, False: 0]
  |  Branch (11462:52): [True: 0, False: 0]
  ------------------
11463|      0|            SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window->Pos.y, 0.0f);
11464|      0|        else if (item_rect.Max.y >= scroll_rect.Max.y)
  ------------------
  |  Branch (11464:18): [True: 0, False: 0]
  ------------------
11465|      0|            SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window->Pos.y, 1.0f);
11466|      0|    }
11467|     51|    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterY) && !fully_visible_y) || (flags & ImGuiScrollFlags_AlwaysCenterY))
  ------------------
  |  Branch (11467:15): [True: 0, False: 51]
  |  Branch (11467:64): [True: 0, False: 0]
  |  Branch (11467:85): [True: 0, False: 51]
  ------------------
11468|      0|    {
11469|      0|        if (can_be_fully_visible_y)
  ------------------
  |  Branch (11469:13): [True: 0, False: 0]
  ------------------
11470|      0|            SetScrollFromPosY(window, ImTrunc((item_rect.Min.y + item_rect.Max.y) * 0.5f) - window->Pos.y, 0.5f);
11471|      0|        else
11472|      0|            SetScrollFromPosY(window, item_rect.Min.y - window->Pos.y, 0.0f);
11473|      0|    }
11474|       |
11475|     51|    ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
11476|     51|    ImVec2 delta_scroll = next_scroll - window->Scroll;
11477|       |
11478|       |    // Also scroll parent window to keep us into view if necessary
11479|     51|    if (!(flags & ImGuiScrollFlags_NoScrollParent) && (window->Flags & ImGuiWindowFlags_ChildWindow))
  ------------------
  |  Branch (11479:9): [True: 51, False: 0]
  |  Branch (11479:55): [True: 0, False: 51]
  ------------------
11480|      0|    {
11481|       |        // FIXME-SCROLL: May be an option?
11482|      0|        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_KeepVisibleCenterX)) != 0)
  ------------------
  |  Branch (11482:13): [True: 0, False: 0]
  ------------------
11483|      0|            in_flags = (in_flags & ~ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_KeepVisibleEdgeX;
11484|      0|        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_KeepVisibleCenterY)) != 0)
  ------------------
  |  Branch (11484:13): [True: 0, False: 0]
  ------------------
11485|      0|            in_flags = (in_flags & ~ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_KeepVisibleEdgeY;
11486|      0|        delta_scroll += ScrollToRectEx(window->ParentWindow, ImRect(item_rect.Min - delta_scroll, item_rect.Max - delta_scroll), in_flags);
11487|      0|    }
11488|       |
11489|     51|    return delta_scroll;
11490|     51|}
_ZN5ImGui10GetScrollXEv:
11493|  21.4k|{
11494|  21.4k|    ImGuiWindow* window = GImGui->CurrentWindow;
11495|  21.4k|    return window->Scroll.x;
11496|  21.4k|}
_ZN5ImGui10GetScrollYEv:
11499|  21.4k|{
11500|  21.4k|    ImGuiWindow* window = GImGui->CurrentWindow;
11501|  21.4k|    return window->Scroll.y;
11502|  21.4k|}
_ZN5ImGui10SetScrollXEP11ImGuiWindowf:
11517|  4.63k|{
11518|  4.63k|    window->ScrollTarget.x = scroll_x;
11519|  4.63k|    window->ScrollTargetCenterRatio.x = 0.0f;
11520|  4.63k|    window->ScrollTargetEdgeSnapDist.x = 0.0f;
11521|  4.63k|}
_ZN5ImGui10SetScrollYEP11ImGuiWindowf:
11524|  3.82k|{
11525|  3.82k|    window->ScrollTarget.y = scroll_y;
11526|  3.82k|    window->ScrollTargetCenterRatio.y = 0.0f;
11527|  3.82k|    window->ScrollTargetEdgeSnapDist.y = 0.0f;
11528|  3.82k|}
_ZN5ImGui10SetScrollXEf:
11531|  4.53k|{
11532|  4.53k|    ImGuiContext& g = *GImGui;
11533|  4.53k|    SetScrollX(g.CurrentWindow, scroll_x);
11534|  4.53k|}
_ZN5ImGui10SetScrollYEf:
11537|  3.53k|{
11538|  3.53k|    ImGuiContext& g = *GImGui;
11539|  3.53k|    SetScrollY(g.CurrentWindow, scroll_y);
11540|  3.53k|}
_ZN5ImGui20GetTopMostPopupModalEv:
11748|   230k|{
11749|   230k|    ImGuiContext& g = *GImGui;
11750|   230k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (11750:45): [True: 0, False: 230k]
  ------------------
11751|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (11751:26): [True: 0, False: 0]
  ------------------
11752|      0|            if (popup->Flags & ImGuiWindowFlags_Modal)
  ------------------
  |  Branch (11752:17): [True: 0, False: 0]
  ------------------
11753|      0|                return popup;
11754|   230k|    return NULL;
11755|   230k|}
_ZN5ImGui30GetTopMostAndVisiblePopupModalEv:
11759|  76.6k|{
11760|  76.6k|    ImGuiContext& g = *GImGui;
11761|  76.6k|    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (11761:45): [True: 0, False: 76.6k]
  ------------------
11762|      0|        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
  ------------------
  |  Branch (11762:26): [True: 0, False: 0]
  ------------------
11763|      0|            if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
  ------------------
  |  Branch (11763:17): [True: 0, False: 0]
  |  Branch (11763:60): [True: 0, False: 0]
  ------------------
11764|      0|                return popup;
11765|  76.6k|    return NULL;
11766|  76.6k|}
_ZN5ImGui21ClosePopupsOverWindowEP11ImGuiWindowb:
11841|  6.66k|{
11842|  6.66k|    ImGuiContext& g = *GImGui;
11843|  6.66k|    if (g.OpenPopupStack.Size == 0)
  ------------------
  |  Branch (11843:9): [True: 6.66k, False: 0]
  ------------------
11844|  6.66k|        return;
11845|       |
11846|       |    // Don't close our own child popup windows.
11847|       |    //IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window->Name : "<NULL>", restore_focus_to_window_under_popup);
11848|      0|    int popup_count_to_keep = 0;
11849|      0|    if (ref_window)
  ------------------
  |  Branch (11849:9): [True: 0, False: 0]
  ------------------
11850|      0|    {
11851|       |        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
11852|      0|        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
  ------------------
  |  Branch (11852:16): [True: 0, False: 0]
  ------------------
11853|      0|        {
11854|      0|            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
11855|      0|            if (!popup.Window)
  ------------------
  |  Branch (11855:17): [True: 0, False: 0]
  ------------------
11856|      0|                continue;
11857|      0|            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
11858|       |
11859|       |            // Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
11860|       |            // - Clicking/Focusing Window2 won't close Popup1:
11861|       |            //     Window -> Popup1 -> Window2(Ref)
11862|       |            // - Clicking/focusing Popup1 will close Popup2 and Popup3:
11863|       |            //     Window -> Popup1(Ref) -> Popup2 -> Popup3
11864|       |            // - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
11865|       |            //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
11866|       |            // We step through every popup from bottom to top to validate their position relative to reference window.
11867|      0|            bool ref_window_is_descendent_of_popup = false;
11868|      0|            for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
  ------------------
  |  Branch (11868:47): [True: 0, False: 0]
  ------------------
11869|      0|                if (ImGuiWindow* popup_window = g.OpenPopupStack[n].Window)
  ------------------
  |  Branch (11869:34): [True: 0, False: 0]
  ------------------
11870|       |                    //if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree) // FIXME-MERGE
11871|      0|                    if (IsWindowWithinBeginStackOf(ref_window, popup_window))
  ------------------
  |  Branch (11871:25): [True: 0, False: 0]
  ------------------
11872|      0|                    {
11873|      0|                        ref_window_is_descendent_of_popup = true;
11874|      0|                        break;
11875|      0|                    }
11876|      0|            if (!ref_window_is_descendent_of_popup)
  ------------------
  |  Branch (11876:17): [True: 0, False: 0]
  ------------------
11877|      0|                break;
11878|      0|        }
11879|      0|    }
11880|      0|    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
  ------------------
  |  Branch (11880:9): [True: 0, False: 0]
  ------------------
11881|      0|    {
11882|      0|        IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>");
  ------------------
  |  |  247|      0|#define IMGUI_DEBUG_LOG_POPUP(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (247:50): [True: 0, False: 0]
  |  |  |  Branch (247:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
11883|      0|        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
11884|      0|    }
11885|      0|}
_ZN5ImGui12SetNavWindowEP11ImGuiWindow:
12276|  6.33k|{
12277|  6.33k|    ImGuiContext& g = *GImGui;
12278|  6.33k|    if (g.NavWindow != window)
  ------------------
  |  Branch (12278:9): [True: 6.33k, False: 0]
  ------------------
12279|  6.33k|    {
12280|  6.33k|        IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>");
  ------------------
  |  |  246|  6.33k|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 6.33k]
  |  |  |  Branch (246:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
12281|  6.33k|        g.NavWindow = window;
12282|  6.33k|        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1736|  6.33k|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
12283|  6.33k|    }
12284|  6.33k|    g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
12285|  6.33k|    NavUpdateAnyRequestFlag();
12286|  6.33k|}
_ZN5ImGui21NavHighlightActivatedEj:
12289|     18|{
12290|     18|    ImGuiContext& g = *GImGui;
12291|     18|    g.NavHighlightActivatedId = id;
12292|     18|    g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER;
12293|     18|}
_ZN5ImGui27NavClearPreferredPosForAxisE9ImGuiAxis:
12296|    987|{
12297|    987|    ImGuiContext& g = *GImGui;
12298|    987|    g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX;
12299|    987|}
_ZN5ImGui8SetNavIDEj13ImGuiNavLayerjRK6ImRect:
12302|    339|{
12303|    339|    ImGuiContext& g = *GImGui;
12304|    339|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|    339|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12305|    339|    IM_ASSERT(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|    339|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12306|    339|    g.NavId = id;
12307|    339|    g.NavLayer = nav_layer;
12308|    339|    SetNavFocusScope(focus_scope_id);
12309|    339|    g.NavWindow->NavLastIds[nav_layer] = id;
12310|    339|    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
12311|       |
12312|       |    // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
12313|    339|    NavClearPreferredPosForAxis(ImGuiAxis_X);
12314|    339|    NavClearPreferredPosForAxis(ImGuiAxis_Y);
12315|    339|}
_ZN5ImGui10SetFocusIDEjP11ImGuiWindow:
12318|      1|{
12319|      1|    ImGuiContext& g = *GImGui;
12320|      1|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12321|       |
12322|      1|    if (g.NavWindow != window)
  ------------------
  |  Branch (12322:9): [True: 1, False: 0]
  ------------------
12323|      1|       SetNavWindow(window);
12324|       |
12325|       |    // Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
12326|       |    // Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
12327|      1|    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
12328|      1|    g.NavId = id;
12329|      1|    g.NavLayer = nav_layer;
12330|      1|    SetNavFocusScope(g.CurrentFocusScopeId);
12331|      1|    window->NavLastIds[nav_layer] = id;
12332|      1|    if (g.LastItemData.ID == id)
  ------------------
  |  Branch (12332:9): [True: 1, False: 0]
  ------------------
12333|      1|        window->NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect);
12334|       |
12335|      1|    if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (12335:9): [True: 1, False: 0]
  |  Branch (12335:58): [True: 0, False: 0]
  ------------------
12336|      1|        g.NavDisableMouseHover = true;
12337|      0|    else
12338|      0|        g.NavDisableHighlight = true;
12339|       |
12340|       |    // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
12341|      1|    NavClearPreferredPosForAxis(ImGuiAxis_X);
12342|      1|    NavClearPreferredPosForAxis(ImGuiAxis_Y);
12343|      1|}
_ZN5ImGui39NavUpdateCurrentWindowIsScrollPushableXEv:
12519|   263k|{
12520|   263k|    ImGuiContext& g = *GImGui;
12521|   263k|    ImGuiWindow* window = g.CurrentWindow;
12522|   263k|    window->DC.NavIsScrollPushableX = (g.CurrentTable == NULL && window->DC.CurrentColumns == NULL);
  ------------------
  |  Branch (12522:40): [True: 263k, False: 0]
  |  Branch (12522:66): [True: 263k, False: 0]
  ------------------
12523|   263k|}
_ZN5ImGui28NavMoveRequestButNoResultYetEv:
12670|  10.5k|{
12671|  10.5k|    ImGuiContext& g = *GImGui;
12672|  10.5k|    return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
  ------------------
  |  Branch (12672:12): [True: 507, False: 9.99k]
  |  Branch (12672:37): [True: 420, False: 87]
  |  Branch (12672:69): [True: 420, False: 0]
  ------------------
12673|  10.5k|}
_ZN5ImGui20NavMoveRequestSubmitE8ImGuiDirS0_ii:
12677|    507|{
12678|    507|    ImGuiContext& g = *GImGui;
12679|    507|    IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|    507|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12680|       |
12681|    507|    if (move_flags & ImGuiNavMoveFlags_IsTabbing)
  ------------------
  |  Branch (12681:9): [True: 60, False: 447]
  ------------------
12682|     60|        move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;
12683|       |
12684|    507|    g.NavMoveSubmitted = g.NavMoveScoringItems = true;
12685|    507|    g.NavMoveDir = move_dir;
12686|    507|    g.NavMoveDirForDebug = move_dir;
12687|    507|    g.NavMoveClipDir = clip_dir;
12688|    507|    g.NavMoveFlags = move_flags;
12689|    507|    g.NavMoveScrollFlags = scroll_flags;
12690|    507|    g.NavMoveForwardToNextFrame = false;
12691|    507|    g.NavMoveKeyMods = (move_flags & ImGuiNavMoveFlags_FocusApi) ? 0 : g.IO.KeyMods;
  ------------------
  |  Branch (12691:24): [True: 0, False: 507]
  ------------------
12692|    507|    g.NavMoveResultLocal.Clear();
12693|    507|    g.NavMoveResultLocalVisible.Clear();
12694|    507|    g.NavMoveResultOther.Clear();
12695|    507|    g.NavTabbingCounter = 0;
12696|    507|    g.NavTabbingResultFirst.Clear();
12697|    507|    NavUpdateAnyRequestFlag();
12698|    507|}
_ZN5ImGui20NavMoveRequestCancelEv:
12722|    239|{
12723|    239|    ImGuiContext& g = *GImGui;
12724|    239|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
12725|    239|    NavUpdateAnyRequestFlag();
12726|    239|}
_ZN5ImGui28NavRestoreHighlightAfterMoveEv:
12801|    326|{
12802|    326|    ImGuiContext& g = *GImGui;
12803|    326|    g.NavDisableHighlight = false;
12804|    326|    g.NavDisableMouseHover = g.NavMousePosDirty = true;
12805|    326|}
_ZN5ImGui13NavInitWindowEP11ImGuiWindowb:
12817|     82|{
12818|       |    // FIXME: ChildWindow test here is wrong for docking
12819|     82|    ImGuiContext& g = *GImGui;
12820|     82|    IM_ASSERT(window == g.NavWindow);
  ------------------
  |  |   23|     82|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12821|       |
12822|     82|    if (window->Flags & ImGuiWindowFlags_NoNavInputs)
  ------------------
  |  Branch (12822:9): [True: 0, False: 82]
  ------------------
12823|      0|    {
12824|      0|        g.NavId = 0;
12825|      0|        SetNavFocusScope(window->NavRootFocusScopeId);
12826|      0|        return;
12827|      0|    }
12828|       |
12829|     82|    bool init_for_nav = false;
12830|     82|    if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
  ------------------
  |  Branch (12830:9): [True: 48, False: 34]
  |  Branch (12830:41): [True: 0, False: 34]
  |  Branch (12830:85): [True: 34, False: 0]
  |  Branch (12830:117): [True: 0, False: 0]
  ------------------
12831|     82|        init_for_nav = true;
12832|     82|    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer);
  ------------------
  |  |  248|     82|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 82]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
12833|     82|    if (init_for_nav)
  ------------------
  |  Branch (12833:9): [True: 82, False: 0]
  ------------------
12834|     82|    {
12835|     82|        SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
12836|     82|        g.NavInitRequest = true;
12837|     82|        g.NavInitRequestFromMove = false;
12838|     82|        g.NavInitResult.ID = 0;
12839|     82|        NavUpdateAnyRequestFlag();
12840|     82|    }
12841|      0|    else
12842|      0|    {
12843|      0|        g.NavId = window->NavLastIds[0];
12844|      0|        SetNavFocusScope(window->NavRootFocusScopeId);
12845|      0|    }
12846|     82|}
_ZN5ImGui25NavInitRequestApplyResultEv:
13075|     68|{
13076|       |    // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
13077|     68|    ImGuiContext& g = *GImGui;
13078|     68|    if (!g.NavWindow)
  ------------------
  |  Branch (13078:9): [True: 33, False: 35]
  ------------------
13079|     33|        return;
13080|       |
13081|     35|    ImGuiNavItemData* result = &g.NavInitResult;
13082|     35|    if (g.NavId != result->ID)
  ------------------
  |  Branch (13082:9): [True: 32, False: 3]
  ------------------
13083|     32|    {
13084|     32|        g.NavJustMovedToId = result->ID;
13085|     32|        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
13086|     32|        g.NavJustMovedToKeyMods = 0;
13087|     32|        g.NavJustMovedToIsTabbing = false;
13088|     32|        g.NavJustMovedToHasSelectionData = (result->InFlags & ImGuiItemFlags_HasSelectionUserData) != 0;
13089|     32|    }
13090|       |
13091|       |    // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
13092|       |    // FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
13093|     35|    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
  ------------------
  |  |  248|     35|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 35]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13094|     35|    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
13095|     35|    g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
13096|     35|    if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
  ------------------
  |  | 1736|     35|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
  |  Branch (13096:9): [True: 0, False: 35]
  ------------------
13097|      0|        g.NavLastValidSelectionUserData = result->SelectionUserData;
13098|     35|    if (g.NavInitRequestFromMove)
  ------------------
  |  Branch (13098:9): [True: 0, False: 35]
  ------------------
13099|      0|        NavRestoreHighlightAfterMove();
13100|     35|}
_ZN5ImGui25NavMoveRequestApplyResultEv:
13272|    358|{
13273|    358|    ImGuiContext& g = *GImGui;
13274|       |#if IMGUI_DEBUG_NAV_SCORING
13275|       |    if (g.NavMoveFlags & ImGuiNavMoveFlags_DebugNoResult) // [DEBUG] Scoring all items in NavWindow at all times
13276|       |        return;
13277|       |#endif
13278|       |
13279|       |    // Select which result to use
13280|    358|    ImGuiNavItemData* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : NULL;
  ------------------
  |  Branch (13280:32): [True: 49, False: 309]
  |  Branch (13280:89): [True: 0, False: 309]
  ------------------
13281|       |
13282|       |    // Tabbing forward wrap
13283|    358|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && result == NULL)
  ------------------
  |  Branch (13283:9): [True: 36, False: 322]
  |  Branch (13283:59): [True: 36, False: 0]
  ------------------
13284|     36|        if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID)
  ------------------
  |  Branch (13284:14): [True: 2, False: 34]
  |  Branch (13284:42): [True: 0, False: 34]
  |  Branch (13284:67): [True: 2, False: 0]
  ------------------
13285|      2|            result = &g.NavTabbingResultFirst;
13286|       |
13287|       |    // In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
13288|    358|    const ImGuiAxis axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
  ------------------
  |  Branch (13288:29): [True: 54, False: 304]
  |  Branch (13288:60): [True: 167, False: 137]
  ------------------
13289|    358|    if (result == NULL)
  ------------------
  |  Branch (13289:9): [True: 307, False: 51]
  ------------------
13290|    307|    {
13291|    307|        if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
  ------------------
  |  Branch (13291:13): [True: 34, False: 273]
  ------------------
13292|     34|            g.NavMoveFlags |= ImGuiNavMoveFlags_NoSetNavHighlight;
13293|    307|        if (g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavHighlight) == 0)
  ------------------
  |  Branch (13293:13): [True: 52, False: 255]
  |  Branch (13293:29): [True: 42, False: 10]
  ------------------
13294|     42|            NavRestoreHighlightAfterMove();
13295|    307|        NavClearPreferredPosForAxis(axis); // On a failed move, clear preferred pos for this axis.
13296|    307|        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveSubmitted but not led to a result!\n");
  ------------------
  |  |  248|    307|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 307]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13297|    307|        return;
13298|    307|    }
13299|       |
13300|       |    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
13301|     51|    if (g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
  ------------------
  |  Branch (13301:9): [True: 43, False: 8]
  ------------------
13302|     43|        if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId)
  ------------------
  |  Branch (13302:13): [True: 43, False: 0]
  |  Branch (13302:52): [True: 0, False: 43]
  ------------------
13303|      0|            result = &g.NavMoveResultLocalVisible;
13304|       |
13305|       |    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
13306|     51|    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (13306:9): [True: 51, False: 0]
  |  Branch (13306:44): [True: 0, False: 51]
  |  Branch (13306:76): [True: 0, False: 0]
  ------------------
13307|      0|        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
  ------------------
  |  Branch (13307:13): [True: 0, False: 0]
  |  Branch (13307:66): [True: 0, False: 0]
  |  Branch (13307:117): [True: 0, False: 0]
  ------------------
13308|      0|            result = &g.NavMoveResultOther;
13309|     51|    IM_ASSERT(g.NavWindow && result->Window);
  ------------------
  |  |   23|     51|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13310|       |
13311|       |    // Scroll to keep newly navigated item fully into view.
13312|     51|    if (g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (13312:9): [True: 51, False: 0]
  ------------------
13313|     51|    {
13314|     51|        ImRect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
13315|     51|        ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);
13316|       |
13317|     51|        if (g.NavMoveFlags & ImGuiNavMoveFlags_ScrollToEdgeY)
  ------------------
  |  Branch (13317:13): [True: 6, False: 45]
  ------------------
13318|      6|        {
13319|       |            // FIXME: Should remove this? Or make more precise: use ScrollToRectEx() with edge?
13320|      6|            float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
  ------------------
  |  Branch (13320:35): [True: 0, False: 6]
  ------------------
13321|      6|            SetScrollY(result->Window, scroll_target);
13322|      6|        }
13323|     51|    }
13324|       |
13325|     51|    if (g.NavWindow != result->Window)
  ------------------
  |  Branch (13325:9): [True: 0, False: 51]
  ------------------
13326|      0|    {
13327|      0|        IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result->Window->Name);
  ------------------
  |  |  246|      0|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 0]
  |  |  |  Branch (246:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13328|      0|        g.NavWindow = result->Window;
13329|      0|        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1736|      0|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
13330|      0|    }
13331|       |
13332|       |    // Clear active id unless requested not to
13333|       |    // FIXME: ImGuiNavMoveFlags_NoClearActiveId is currently unused as we don't have a clear strategy to preserve active id after interaction,
13334|       |    // so this is mostly provided as a gateway for further experiments (see #1418, #2890)
13335|     51|    if (g.ActiveId != result->ID && (g.NavMoveFlags & ImGuiNavMoveFlags_NoClearActiveId) == 0)
  ------------------
  |  Branch (13335:9): [True: 51, False: 0]
  |  Branch (13335:37): [True: 51, False: 0]
  ------------------
13336|     51|        ClearActiveID();
13337|       |
13338|       |    // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
13339|       |    // PageUp/PageDown however sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking Windows behavior.
13340|     51|    if ((g.NavId != result->ID || (g.NavMoveFlags & ImGuiNavMoveFlags_IsPageMove)) && (g.NavMoveFlags & ImGuiNavMoveFlags_NoSelect) == 0)
  ------------------
  |  Branch (13340:10): [True: 0, False: 51]
  |  Branch (13340:35): [True: 43, False: 8]
  |  Branch (13340:87): [True: 43, False: 0]
  ------------------
13341|     43|    {
13342|     43|        g.NavJustMovedToId = result->ID;
13343|     43|        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
13344|     43|        g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
13345|     43|        g.NavJustMovedToIsTabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
13346|     43|        g.NavJustMovedToHasSelectionData = (result->InFlags & ImGuiItemFlags_HasSelectionUserData) != 0;
13347|       |        //IMGUI_DEBUG_LOG_NAV("[nav] NavJustMovedFromFocusScopeId = 0x%08X, NavJustMovedToFocusScopeId = 0x%08X\n", g.NavJustMovedFromFocusScopeId, g.NavJustMovedToFocusScopeId);
13348|     43|    }
13349|       |
13350|       |    // Apply new NavID/Focus
13351|     51|    IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name);
  ------------------
  |  |  248|     51|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 51]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13352|     51|    ImVec2 preferred_scoring_pos_rel = g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer];
13353|     51|    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);
13354|     51|    if (result->SelectionUserData != ImGuiSelectionUserData_Invalid)
  ------------------
  |  | 1736|     51|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
  |  Branch (13354:9): [True: 0, False: 51]
  ------------------
13355|      0|        g.NavLastValidSelectionUserData = result->SelectionUserData;
13356|       |
13357|       |    // Restore last preferred position for current axis
13358|       |    // (storing in RootWindowForNav-> as the info is desirable at the beginning of a Move Request. In theory all storage should use RootWindowForNav..)
13359|     51|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) == 0)
  ------------------
  |  Branch (13359:9): [True: 49, False: 2]
  ------------------
13360|     49|    {
13361|     49|        preferred_scoring_pos_rel[axis] = result->RectRel.GetCenter()[axis];
13362|     49|        g.NavWindow->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer] = preferred_scoring_pos_rel;
13363|     49|    }
13364|       |
13365|       |    // Tabbing: Activates Inputable, otherwise only Focus
13366|     51|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) && (result->InFlags & ImGuiItemFlags_Inputable) == 0)
  ------------------
  |  Branch (13366:9): [True: 2, False: 49]
  |  Branch (13366:59): [True: 2, False: 0]
  ------------------
13367|      2|        g.NavMoveFlags &= ~ImGuiNavMoveFlags_Activate;
13368|       |
13369|       |    // Activate
13370|     51|    if (g.NavMoveFlags & ImGuiNavMoveFlags_Activate)
  ------------------
  |  Branch (13370:9): [True: 0, False: 51]
  ------------------
13371|      0|    {
13372|      0|        g.NavNextActivateId = result->ID;
13373|      0|        g.NavNextActivateFlags = ImGuiActivateFlags_None;
13374|      0|        if (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing)
  ------------------
  |  Branch (13374:13): [True: 0, False: 0]
  ------------------
13375|      0|            g.NavNextActivateFlags |= ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState | ImGuiActivateFlags_FromTabbing;
13376|      0|    }
13377|       |
13378|       |    // Enable nav highlight
13379|     51|    if ((g.NavMoveFlags & ImGuiNavMoveFlags_NoSetNavHighlight) == 0)
  ------------------
  |  Branch (13379:9): [True: 51, False: 0]
  ------------------
13380|     51|        NavRestoreHighlightAfterMove();
13381|     51|}
_ZN5ImGui13ClearDragDropEv:
13883|      4|{
13884|      4|    ImGuiContext& g = *GImGui;
13885|      4|    if (g.DragDropActive)
  ------------------
  |  Branch (13885:9): [True: 2, False: 2]
  ------------------
13886|      2|        IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] ClearDragDrop()\n");
  ------------------
  |  |  245|      2|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (245:50): [True: 0, False: 2]
  |  |  |  Branch (245:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13887|      4|    g.DragDropActive = false;
13888|      4|    g.DragDropPayload.Clear();
13889|      4|    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
13890|      4|    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
13891|      4|    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
13892|      4|    g.DragDropAcceptFrameCount = -1;
13893|       |
13894|      4|    g.DragDropPayloadBufHeap.clear();
13895|      4|    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
13896|      4|}
_ZN5ImGui19BeginDragDropSourceEi:
13914|    207|{
13915|    207|    ImGuiContext& g = *GImGui;
13916|    207|    ImGuiWindow* window = g.CurrentWindow;
13917|       |
13918|       |    // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
13919|       |    // in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
13920|    207|    ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;
13921|       |
13922|    207|    bool source_drag_active = false;
13923|    207|    ImGuiID source_id = 0;
13924|    207|    ImGuiID source_parent_id = 0;
13925|    207|    if ((flags & ImGuiDragDropFlags_SourceExtern) == 0)
  ------------------
  |  Branch (13925:9): [True: 207, False: 0]
  ------------------
13926|    207|    {
13927|    207|        source_id = g.LastItemData.ID;
13928|    207|        if (source_id != 0)
  ------------------
  |  Branch (13928:13): [True: 207, False: 0]
  ------------------
13929|    207|        {
13930|       |            // Common path: items with ID
13931|    207|            if (g.ActiveId != source_id)
  ------------------
  |  Branch (13931:17): [True: 0, False: 207]
  ------------------
13932|      0|                return false;
13933|    207|            if (g.ActiveIdMouseButton != -1)
  ------------------
  |  Branch (13933:17): [True: 0, False: 207]
  ------------------
13934|      0|                mouse_button = g.ActiveIdMouseButton;
13935|    207|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (13935:17): [True: 0, False: 207]
  |  Branch (13935:58): [True: 0, False: 207]
  ------------------
13936|      0|                return false;
13937|    207|            g.ActiveIdAllowOverlap = false;
13938|    207|        }
13939|      0|        else
13940|      0|        {
13941|       |            // Uncommon path: items without ID
13942|      0|            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
  ------------------
  |  Branch (13942:17): [True: 0, False: 0]
  |  Branch (13942:58): [True: 0, False: 0]
  ------------------
13943|      0|                return false;
13944|      0|            if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
  ------------------
  |  Branch (13944:17): [True: 0, False: 0]
  |  Branch (13944:90): [True: 0, False: 0]
  |  Branch (13944:109): [True: 0, False: 0]
  ------------------
13945|      0|                return false;
13946|       |
13947|       |            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
13948|       |            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
13949|      0|            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
  ------------------
  |  Branch (13949:17): [True: 0, False: 0]
  ------------------
13950|      0|            {
13951|      0|                IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13952|      0|                return false;
13953|      0|            }
13954|       |
13955|       |            // Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
13956|       |            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
13957|       |            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
13958|       |            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
13959|       |            // Rely on keeping other window->LastItemXXX fields intact.
13960|      0|            source_id = g.LastItemData.ID = window->GetIDFromRectangle(g.LastItemData.Rect);
13961|      0|            KeepAliveID(source_id);
13962|      0|            bool is_hovered = ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.InFlags);
13963|      0|            if (is_hovered && g.IO.MouseClicked[mouse_button])
  ------------------
  |  Branch (13963:17): [True: 0, False: 0]
  |  Branch (13963:31): [True: 0, False: 0]
  ------------------
13964|      0|            {
13965|      0|                SetActiveID(source_id, window);
13966|      0|                FocusWindow(window);
13967|      0|            }
13968|      0|            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
  ------------------
  |  Branch (13968:17): [True: 0, False: 0]
  ------------------
13969|      0|                g.ActiveIdAllowOverlap = is_hovered;
13970|      0|        }
13971|    207|        if (g.ActiveId != source_id)
  ------------------
  |  Branch (13971:13): [True: 0, False: 207]
  ------------------
13972|      0|            return false;
13973|    207|        source_parent_id = window->IDStack.back();
13974|    207|        source_drag_active = IsMouseDragging(mouse_button);
13975|       |
13976|       |        // Disable navigation and key inputs while dragging + cancel existing request if any
13977|    207|        SetActiveIdUsingAllKeyboardKeys();
13978|    207|    }
13979|      0|    else
13980|      0|    {
13981|       |        // When ImGuiDragDropFlags_SourceExtern is set:
13982|      0|        window = NULL;
13983|      0|        source_id = ImHashStr("#SourceExtern");
13984|      0|        source_drag_active = true;
13985|      0|        mouse_button = g.IO.MouseDown[0] ? 0 : -1;
  ------------------
  |  Branch (13985:24): [True: 0, False: 0]
  ------------------
13986|      0|        KeepAliveID(source_id);
13987|      0|        SetActiveID(source_id, NULL);
13988|      0|    }
13989|       |
13990|    207|    IM_ASSERT(g.DragDropWithinTarget == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
  ------------------
  |  |   23|    207|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13991|    207|    if (!source_drag_active)
  ------------------
  |  Branch (13991:9): [True: 49, False: 158]
  ------------------
13992|     49|        return false;
13993|       |
13994|       |    // Activate drag and drop
13995|    158|    if (!g.DragDropActive)
  ------------------
  |  Branch (13995:9): [True: 2, False: 156]
  ------------------
13996|      2|    {
13997|      2|        IM_ASSERT(source_id != 0);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13998|      2|        ClearDragDrop();
13999|      2|        IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] BeginDragDropSource() DragDropActive = true, source_id = 0x%08X%s\n",
  ------------------
  |  |  245|      2|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (245:50): [True: 0, False: 2]
  |  |  |  Branch (245:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
14000|      2|            source_id, (flags & ImGuiDragDropFlags_SourceExtern) ? " (EXTERN)" : "");
14001|      2|        ImGuiPayload& payload = g.DragDropPayload;
14002|      2|        payload.SourceId = source_id;
14003|      2|        payload.SourceParentId = source_parent_id;
14004|      2|        g.DragDropActive = true;
14005|      2|        g.DragDropSourceFlags = flags;
14006|      2|        g.DragDropMouseButton = mouse_button;
14007|      2|        if (payload.SourceId == g.ActiveId)
  ------------------
  |  Branch (14007:13): [True: 2, False: 0]
  ------------------
14008|      2|            g.ActiveIdNoClearOnFocusLoss = true;
14009|      2|    }
14010|    158|    g.DragDropSourceFrameCount = g.FrameCount;
14011|    158|    g.DragDropWithinSource = true;
14012|       |
14013|    158|    if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (14013:9): [True: 0, False: 158]
  ------------------
14014|      0|    {
14015|       |        // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
14016|       |        // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
14017|      0|        bool ret;
14018|      0|        if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
  ------------------
  |  Branch (14018:13): [True: 0, False: 0]
  |  Branch (14018:39): [True: 0, False: 0]
  ------------------
14019|      0|            ret = BeginTooltipHidden();
14020|      0|        else
14021|      0|            ret = BeginTooltip();
14022|      0|        IM_ASSERT(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to Begin("##Hidden", NULL, ImGuiWindowFlags_NoSavedSettings) + SetWindowHiddendAndSkipItemsForCurrentFrame().
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14023|      0|        IM_UNUSED(ret);
  ------------------
  |  |   94|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
14024|      0|    }
14025|       |
14026|    158|    if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
  ------------------
  |  Branch (14026:9): [True: 158, False: 0]
  |  Branch (14026:63): [True: 158, False: 0]
  ------------------
14027|    158|        g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;
14028|       |
14029|    158|    return true;
14030|    207|}
_ZN5ImGui17EndDragDropSourceEv:
14033|    158|{
14034|    158|    ImGuiContext& g = *GImGui;
14035|    158|    IM_ASSERT(g.DragDropActive);
  ------------------
  |  |   23|    158|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14036|    158|    IM_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?");
  ------------------
  |  |   23|    158|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14037|       |
14038|    158|    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
  ------------------
  |  Branch (14038:9): [True: 0, False: 158]
  ------------------
14039|      0|        EndTooltip();
14040|       |
14041|       |    // Discard the drag if have not called SetDragDropPayload()
14042|    158|    if (g.DragDropPayload.DataFrameCount == -1)
  ------------------
  |  Branch (14042:9): [True: 0, False: 158]
  ------------------
14043|      0|        ClearDragDrop();
14044|    158|    g.DragDropWithinSource = false;
14045|    158|}
_ZN5ImGui18SetDragDropPayloadEPKcPKvmi:
14049|    158|{
14050|    158|    ImGuiContext& g = *GImGui;
14051|    158|    ImGuiPayload& payload = g.DragDropPayload;
14052|    158|    if (cond == 0)
  ------------------
  |  Branch (14052:9): [True: 158, False: 0]
  ------------------
14053|    158|        cond = ImGuiCond_Always;
14054|       |
14055|    158|    IM_ASSERT(type != NULL);
  ------------------
  |  |   23|    158|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14056|    158|    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
  ------------------
  |  |   23|    158|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14057|    158|    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
  ------------------
  |  |   23|    158|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14058|    158|    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
  ------------------
  |  |   23|    158|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14059|    158|    IM_ASSERT(payload.SourceId != 0); // Not called between BeginDragDropSource() and EndDragDropSource()
  ------------------
  |  |   23|    158|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14060|       |
14061|    158|    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
  ------------------
  |  Branch (14061:9): [True: 158, False: 0]
  |  Branch (14061:37): [True: 0, False: 0]
  ------------------
14062|    158|    {
14063|       |        // Copy payload
14064|    158|        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
  ------------------
  |  |   93|    158|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
14065|    158|        g.DragDropPayloadBufHeap.resize(0);
14066|    158|        if (data_size > sizeof(g.DragDropPayloadBufLocal))
  ------------------
  |  Branch (14066:13): [True: 0, False: 158]
  ------------------
14067|      0|        {
14068|       |            // Store in heap
14069|      0|            g.DragDropPayloadBufHeap.resize((int)data_size);
14070|      0|            payload.Data = g.DragDropPayloadBufHeap.Data;
14071|      0|            memcpy(payload.Data, data, data_size);
14072|      0|        }
14073|    158|        else if (data_size > 0)
  ------------------
  |  Branch (14073:18): [True: 158, False: 0]
  ------------------
14074|    158|        {
14075|       |            // Store locally
14076|    158|            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
14077|    158|            payload.Data = g.DragDropPayloadBufLocal;
14078|    158|            memcpy(payload.Data, data, data_size);
14079|    158|        }
14080|      0|        else
14081|      0|        {
14082|      0|            payload.Data = NULL;
14083|      0|        }
14084|    158|        payload.DataSize = (int)data_size;
14085|    158|    }
14086|    158|    payload.DataFrameCount = g.FrameCount;
14087|       |
14088|       |    // Return whether the payload has been accepted
14089|    158|    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
  ------------------
  |  Branch (14089:12): [True: 0, False: 158]
  |  Branch (14089:60): [True: 0, False: 158]
  ------------------
14090|    158|}
_ZN5ImGui25BeginDragDropTargetCustomERK6ImRectj:
14093|    164|{
14094|    164|    ImGuiContext& g = *GImGui;
14095|    164|    if (!g.DragDropActive)
  ------------------
  |  Branch (14095:9): [True: 0, False: 164]
  ------------------
14096|      0|        return false;
14097|       |
14098|    164|    ImGuiWindow* window = g.CurrentWindow;
14099|    164|    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
14100|    164|    if (hovered_window == NULL || window->RootWindowDockTree != hovered_window->RootWindowDockTree)
  ------------------
  |  Branch (14100:9): [True: 160, False: 4]
  |  Branch (14100:35): [True: 2, False: 2]
  ------------------
14101|    162|        return false;
14102|      2|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14103|      2|    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
  ------------------
  |  Branch (14103:9): [True: 1, False: 1]
  |  Branch (14103:49): [True: 0, False: 1]
  ------------------
14104|      1|        return false;
14105|      1|    if (window->SkipItems)
  ------------------
  |  Branch (14105:9): [True: 0, False: 1]
  ------------------
14106|      0|        return false;
14107|       |
14108|      1|    IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14109|      1|    g.DragDropTargetRect = bb;
14110|      1|    g.DragDropTargetClipRect = window->ClipRect; // May want to be overriden by user depending on use case?
14111|      1|    g.DragDropTargetId = id;
14112|      1|    g.DragDropWithinTarget = true;
14113|      1|    return true;
14114|      1|}
_ZN5ImGui30IsDragDropPayloadBeingAcceptedEv:
14152|     32|{
14153|     32|    ImGuiContext& g = *GImGui;
14154|     32|    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
  ------------------
  |  Branch (14154:12): [True: 2, False: 30]
  |  Branch (14154:32): [True: 0, False: 2]
  ------------------
14155|     32|}
_ZN5ImGui21AcceptDragDropPayloadEPKci:
14158|      1|{
14159|      1|    ImGuiContext& g = *GImGui;
14160|      1|    ImGuiPayload& payload = g.DragDropPayload;
14161|      1|    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14162|      1|    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14163|      1|    if (type != NULL && !payload.IsDataType(type))
  ------------------
  |  Branch (14163:9): [True: 1, False: 0]
  |  Branch (14163:25): [True: 0, False: 1]
  ------------------
14164|      0|        return NULL;
14165|       |
14166|       |    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
14167|       |    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
14168|      1|    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
14169|      1|    ImRect r = g.DragDropTargetRect;
14170|      1|    float r_surface = r.GetWidth() * r.GetHeight();
14171|      1|    if (r_surface > g.DragDropAcceptIdCurrRectSurface)
  ------------------
  |  Branch (14171:9): [True: 0, False: 1]
  ------------------
14172|      0|        return NULL;
14173|       |
14174|      1|    g.DragDropAcceptFlags = flags;
14175|      1|    g.DragDropAcceptIdCurr = g.DragDropTargetId;
14176|      1|    g.DragDropAcceptIdCurrRectSurface = r_surface;
14177|       |    //IMGUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: accept\n", g.DragDropTargetId);
14178|       |
14179|       |    // Render default drop visuals
14180|      1|    payload.Preview = was_accepted_previously;
14181|      1|    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that live for 1 frame)
14182|      1|    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
  ------------------
  |  Branch (14182:9): [True: 0, False: 1]
  |  Branch (14182:66): [True: 0, False: 0]
  ------------------
14183|      0|        RenderDragDropTargetRect(r, g.DragDropTargetClipRect);
14184|       |
14185|      1|    g.DragDropAcceptFrameCount = g.FrameCount;
14186|      1|    if ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) && g.DragDropMouseButton == -1)
  ------------------
  |  Branch (14186:9): [True: 0, False: 1]
  |  Branch (14186:70): [True: 0, False: 0]
  ------------------
14187|      0|        payload.Delivery = was_accepted_previously && (g.DragDropSourceFrameCount < g.FrameCount);
  ------------------
  |  Branch (14187:28): [True: 0, False: 0]
  |  Branch (14187:55): [True: 0, False: 0]
  ------------------
14188|      1|    else
14189|      1|        payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting OS window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
  ------------------
  |  Branch (14189:28): [True: 0, False: 1]
  |  Branch (14189:55): [True: 0, False: 0]
  ------------------
14190|      1|    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
  ------------------
  |  Branch (14190:9): [True: 1, False: 0]
  |  Branch (14190:30): [True: 0, False: 1]
  ------------------
14191|      0|        return NULL;
14192|       |
14193|      1|    if (payload.Delivery)
  ------------------
  |  Branch (14193:9): [True: 0, False: 1]
  ------------------
14194|      0|        IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] AcceptDragDropPayload(): 0x%08X: payload delivery\n", g.DragDropTargetId);
  ------------------
  |  |  245|      0|#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (245:50): [True: 0, False: 0]
  |  |  |  Branch (245:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
14195|      1|    return &payload;
14196|      1|}
_ZN5ImGui17EndDragDropTargetEv:
14221|      1|{
14222|      1|    ImGuiContext& g = *GImGui;
14223|      1|    IM_ASSERT(g.DragDropActive);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14224|      1|    IM_ASSERT(g.DragDropWithinTarget);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14225|      1|    g.DragDropWithinTarget = false;
14226|       |
14227|       |    // Clear drag and drop state payload right after delivery
14228|      1|    if (g.DragDropPayload.Delivery)
  ------------------
  |  Branch (14228:9): [True: 0, False: 1]
  ------------------
14229|      0|        ClearDragDrop();
14230|      1|}
_ZN5ImGui9LogFinishEv:
14416|   153k|{
14417|   153k|    ImGuiContext& g = *GImGui;
14418|   153k|    if (!g.LogEnabled)
  ------------------
  |  Branch (14418:9): [True: 153k, False: 0]
  ------------------
14419|   153k|        return;
14420|       |
14421|      0|    LogText(IM_NEWLINE);
  ------------------
  |  |  279|      0|#define IM_NEWLINE                      "\n"
  ------------------
14422|      0|    switch (g.LogType)
  ------------------
  |  Branch (14422:13): [True: 0, False: 0]
  ------------------
14423|      0|    {
14424|      0|    case ImGuiLogType_TTY:
  ------------------
  |  Branch (14424:5): [True: 0, False: 0]
  ------------------
14425|      0|#ifndef IMGUI_DISABLE_TTY_FUNCTIONS
14426|      0|        fflush(g.LogFile);
14427|      0|#endif
14428|      0|        break;
14429|      0|    case ImGuiLogType_File:
  ------------------
  |  Branch (14429:5): [True: 0, False: 0]
  ------------------
14430|      0|        ImFileClose(g.LogFile);
14431|      0|        break;
14432|      0|    case ImGuiLogType_Buffer:
  ------------------
  |  Branch (14432:5): [True: 0, False: 0]
  ------------------
14433|      0|        break;
14434|      0|    case ImGuiLogType_Clipboard:
  ------------------
  |  Branch (14434:5): [True: 0, False: 0]
  ------------------
14435|      0|        if (!g.LogBuffer.empty())
  ------------------
  |  Branch (14435:13): [True: 0, False: 0]
  ------------------
14436|      0|            SetClipboardText(g.LogBuffer.begin());
14437|      0|        break;
14438|      0|    case ImGuiLogType_None:
  ------------------
  |  Branch (14438:5): [True: 0, False: 0]
  ------------------
14439|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14440|      0|        break;
14441|      0|    }
14442|       |
14443|      0|    g.LogEnabled = g.ItemUnclipByLog = false;
14444|      0|    g.LogType = ImGuiLogType_None;
14445|      0|    g.LogFile = NULL;
14446|      0|    g.LogBuffer.clear();
14447|      0|}
_ZN5ImGui20MarkIniSettingsDirtyEP11ImGuiWindow:
14534|  17.1k|{
14535|  17.1k|    ImGuiContext& g = *GImGui;
14536|  17.1k|    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (14536:9): [True: 266, False: 16.8k]
  ------------------
14537|    266|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (14537:13): [True: 6, False: 260]
  ------------------
14538|      6|            g.SettingsDirtyTimer = g.IO.IniSavingRate;
14539|  17.1k|}
_ZN5ImGui18AddSettingsHandlerEPK20ImGuiSettingsHandler:
14542|      2|{
14543|      2|    ImGuiContext& g = *GImGui;
14544|      2|    IM_ASSERT(FindSettingsHandler(handler->TypeName) == NULL);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14545|      2|    g.SettingsHandlers.push_back(*handler);
14546|      2|}
_ZN5ImGui19FindSettingsHandlerEPKc:
14556|      2|{
14557|      2|    ImGuiContext& g = *GImGui;
14558|      2|    const ImGuiID type_hash = ImHashStr(type_name);
14559|      2|    for (ImGuiSettingsHandler& handler : g.SettingsHandlers)
  ------------------
  |  Branch (14559:40): [True: 1, False: 2]
  ------------------
14560|      1|        if (handler.TypeHash == type_hash)
  ------------------
  |  Branch (14560:13): [True: 0, False: 1]
  ------------------
14561|      0|            return &handler;
14562|      2|    return NULL;
14563|      2|}
_ZN5ImGui22FindWindowSettingsByIDEj:
14714|      2|{
14715|      2|    ImGuiContext& g = *GImGui;
14716|      2|    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != NULL; settings = g.SettingsWindows.next_chunk(settings))
  ------------------
  |  Branch (14716:69): [True: 0, False: 2]
  ------------------
14717|      0|        if (settings->ID == id && !settings->WantDelete)
  ------------------
  |  Branch (14717:13): [True: 0, False: 0]
  |  Branch (14717:35): [True: 0, False: 0]
  ------------------
14718|      0|            return settings;
14719|      2|    return NULL;
14720|      2|}
_ZN5ImGui26FindWindowSettingsByWindowEP11ImGuiWindow:
14724|      2|{
14725|      2|    ImGuiContext& g = *GImGui;
14726|      2|    if (window->SettingsOffset != -1)
  ------------------
  |  Branch (14726:9): [True: 0, False: 2]
  ------------------
14727|      0|        return g.SettingsWindows.ptr_from_offset(window->SettingsOffset);
14728|      2|    return FindWindowSettingsByID(window->ID);
14729|      2|}
_ZN5ImGui23LocalizeRegisterEntriesEPK13ImGuiLocEntryi:
14875|      1|{
14876|      1|    ImGuiContext& g = *GImGui;
14877|     12|    for (int n = 0; n < count; n++)
  ------------------
  |  Branch (14877:21): [True: 11, False: 1]
  ------------------
14878|     11|        g.LocalizationTable[entries[n].Key] = entries[n].Text;
14879|      1|}
_ZN5ImGui15GetMainViewportEv:
14911|   323k|{
14912|   323k|    ImGuiContext& g = *GImGui;
14913|   323k|    return g.Viewports[0];
14914|   323k|}
_ZN5ImGui16FindViewportByIDEj:
14918|  76.6k|{
14919|  76.6k|    ImGuiContext& g = *GImGui;
14920|  76.6k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (14920:35): [True: 76.6k, False: 0]
  ------------------
14921|  76.6k|        if (viewport->ID == id)
  ------------------
  |  Branch (14921:13): [True: 76.6k, False: 0]
  ------------------
14922|  76.6k|            return viewport;
14923|      0|    return NULL;
14924|  76.6k|}
_ZN5ImGui18SetCurrentViewportEP11ImGuiWindowP14ImGuiViewportP:
14936|   340k|{
14937|   340k|    ImGuiContext& g = *GImGui;
14938|   340k|    (void)current_window;
14939|       |
14940|   340k|    if (viewport)
  ------------------
  |  Branch (14940:9): [True: 263k, False: 76.6k]
  ------------------
14941|   263k|        viewport->LastFrameActive = g.FrameCount;
14942|   340k|    if (g.CurrentViewport == viewport)
  ------------------
  |  Branch (14942:9): [True: 187k, False: 153k]
  ------------------
14943|   187k|        return;
14944|   153k|    g.CurrentDpiScale = viewport ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (14944:25): [True: 76.6k, False: 76.6k]
  ------------------
14945|   153k|    g.CurrentViewport = viewport;
14946|       |    //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);
14947|       |
14948|       |    // Notify platform layer of viewport changes
14949|       |    // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
14950|   153k|    if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport)
  ------------------
  |  Branch (14950:9): [True: 76.6k, False: 76.6k]
  |  Branch (14950:30): [True: 0, False: 76.6k]
  ------------------
14951|      0|        g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
14952|   153k|}
_ZN5ImGui17SetWindowViewportEP11ImGuiWindowP14ImGuiViewportP:
14955|   170k|{
14956|       |    // Abandon viewport
14957|   170k|    if (window->ViewportOwned && window->Viewport->Window == window)
  ------------------
  |  Branch (14957:9): [True: 0, False: 170k]
  |  Branch (14957:34): [True: 0, False: 0]
  ------------------
14958|      0|        window->Viewport->Size = ImVec2(0.0f, 0.0f);
14959|       |
14960|   170k|    window->Viewport = viewport;
14961|   170k|    window->ViewportId = viewport->ID;
14962|   170k|    window->ViewportOwned = (viewport->Window == window);
14963|   170k|}
_ZN5ImGui21DockContextInitializeEP12ImGuiContext:
16102|      1|{
16103|      1|    ImGuiContext& g = *ctx;
16104|       |
16105|       |    // Add .ini handle for persistent docking data
16106|      1|    ImGuiSettingsHandler ini_handler;
16107|      1|    ini_handler.TypeName = "Docking";
16108|      1|    ini_handler.TypeHash = ImHashStr("Docking");
16109|      1|    ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
16110|      1|    ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
16111|      1|    ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
16112|      1|    ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
16113|      1|    ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
16114|      1|    ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
16115|      1|    g.SettingsHandlers.push_back(ini_handler);
16116|       |
16117|      1|    g.DockNodeWindowMenuHandler = &DockNodeWindowMenuHandler_Default;
16118|      1|}
_ZN5ImGui34DockContextNewFrameUpdateUndockingEP12ImGuiContext:
16152|  76.6k|{
16153|  76.6k|    ImGuiContext& g = *ctx;
16154|  76.6k|    ImGuiDockContext* dc = &ctx->DockContext;
16155|  76.6k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (16155:9): [True: 0, False: 76.6k]
  ------------------
16156|      0|    {
16157|      0|        if (dc->Nodes.Data.Size > 0 || dc->Requests.Size > 0)
  ------------------
  |  Branch (16157:13): [True: 0, False: 0]
  |  Branch (16157:40): [True: 0, False: 0]
  ------------------
16158|      0|            DockContextClearNodes(ctx, 0, true);
16159|      0|        return;
16160|      0|    }
16161|       |
16162|       |    // Setting NoSplit at runtime merges all nodes
16163|  76.6k|    if (g.IO.ConfigDockingNoSplit)
  ------------------
  |  Branch (16163:9): [True: 0, False: 76.6k]
  ------------------
16164|      0|        for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (16164:25): [True: 0, False: 0]
  ------------------
16165|      0|            if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (16165:32): [True: 0, False: 0]
  ------------------
16166|      0|                if (node->IsRootNode() && node->IsSplitNode())
  ------------------
  |  Branch (16166:21): [True: 0, False: 0]
  |  Branch (16166:43): [True: 0, False: 0]
  ------------------
16167|      0|                {
16168|      0|                    DockBuilderRemoveNodeChildNodes(node->ID);
16169|       |                    //dc->WantFullRebuild = true;
16170|      0|                }
16171|       |
16172|       |    // Process full rebuild
16173|       |#if 0
16174|       |    if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))
16175|       |        dc->WantFullRebuild = true;
16176|       |#endif
16177|  76.6k|    if (dc->WantFullRebuild)
  ------------------
  |  Branch (16177:9): [True: 0, False: 76.6k]
  ------------------
16178|      0|    {
16179|      0|        DockContextRebuildNodes(ctx);
16180|      0|        dc->WantFullRebuild = false;
16181|      0|    }
16182|       |
16183|       |    // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
16184|  76.6k|    for (ImGuiDockRequest& req : dc->Requests)
  ------------------
  |  Branch (16184:32): [True: 0, False: 76.6k]
  ------------------
16185|      0|    {
16186|      0|        if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetWindow)
  ------------------
  |  Branch (16186:13): [True: 0, False: 0]
  |  Branch (16186:56): [True: 0, False: 0]
  ------------------
16187|      0|            DockContextProcessUndockWindow(ctx, req.UndockTargetWindow);
16188|      0|        else if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetNode)
  ------------------
  |  Branch (16188:18): [True: 0, False: 0]
  |  Branch (16188:61): [True: 0, False: 0]
  ------------------
16189|      0|            DockContextProcessUndockNode(ctx, req.UndockTargetNode);
16190|      0|    }
16191|  76.6k|}
_ZN5ImGui32DockContextNewFrameUpdateDockingEP12ImGuiContext:
16195|  76.6k|{
16196|  76.6k|    ImGuiContext& g = *ctx;
16197|  76.6k|    ImGuiDockContext* dc = &ctx->DockContext;
16198|  76.6k|    if (!(g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (16198:9): [True: 0, False: 76.6k]
  ------------------
16199|      0|        return;
16200|       |
16201|       |    // [DEBUG] Store hovered dock node.
16202|       |    // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
16203|       |    // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
16204|  76.6k|    g.DebugHoveredDockNode = NULL;
16205|  76.6k|    if (ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow)
  ------------------
  |  Branch (16205:22): [True: 393, False: 76.3k]
  ------------------
16206|    393|    {
16207|    393|        if (hovered_window->DockNodeAsHost)
  ------------------
  |  Branch (16207:13): [True: 0, False: 393]
  ------------------
16208|      0|            g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window->DockNodeAsHost, g.IO.MousePos);
16209|    393|        else if (hovered_window->RootWindow->DockNode)
  ------------------
  |  Branch (16209:18): [True: 0, False: 393]
  ------------------
16210|      0|            g.DebugHoveredDockNode = hovered_window->RootWindow->DockNode;
16211|    393|    }
16212|       |
16213|       |    // Process Docking requests
16214|  76.6k|    for (ImGuiDockRequest& req : dc->Requests)
  ------------------
  |  Branch (16214:32): [True: 0, False: 76.6k]
  ------------------
16215|      0|        if (req.Type == ImGuiDockRequestType_Dock)
  ------------------
  |  Branch (16215:13): [True: 0, False: 0]
  ------------------
16216|      0|            DockContextProcessDock(ctx, &req);
16217|  76.6k|    dc->Requests.resize(0);
16218|       |
16219|       |    // Create windows for each automatic docking nodes
16220|       |    // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
16221|  76.6k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (16221:21): [True: 0, False: 76.6k]
  ------------------
16222|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (16222:28): [True: 0, False: 0]
  ------------------
16223|      0|            if (node->IsFloatingNode())
  ------------------
  |  Branch (16223:17): [True: 0, False: 0]
  ------------------
16224|      0|                DockNodeUpdate(node);
16225|  76.6k|}
_ZN5ImGui19DockContextEndFrameEP12ImGuiContext:
16228|  76.6k|{
16229|       |    // Draw backgrounds of node missing their window
16230|  76.6k|    ImGuiContext& g = *ctx;
16231|  76.6k|    ImGuiDockContext* dc = &g.DockContext;
16232|  76.6k|    for (int n = 0; n < dc->Nodes.Data.Size; n++)
  ------------------
  |  Branch (16232:21): [True: 0, False: 76.6k]
  ------------------
16233|      0|        if (ImGuiDockNode* node = (ImGuiDockNode*)dc->Nodes.Data[n].val_p)
  ------------------
  |  Branch (16233:28): [True: 0, False: 0]
  ------------------
16234|      0|            if (node->LastFrameActive == g.FrameCount && node->IsVisible && node->HostWindow && node->IsLeafNode() && !node->IsBgDrawnThisFrame)
  ------------------
  |  Branch (16234:17): [True: 0, False: 0]
  |  Branch (16234:58): [True: 0, False: 0]
  |  Branch (16234:77): [True: 0, False: 0]
  |  Branch (16234:97): [True: 0, False: 0]
  |  Branch (16234:119): [True: 0, False: 0]
  ------------------
16235|      0|            {
16236|      0|                ImRect bg_rect(node->Pos + ImVec2(0.0f, GetFrameHeight()), node->Pos + node->Size);
16237|      0|                ImDrawFlags bg_rounding_flags = CalcRoundingFlagsForRectInRect(bg_rect, node->HostWindow->Rect(), g.Style.DockingSeparatorSize);
16238|      0|                node->HostWindow->DrawList->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1746|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
16239|      0|                node->HostWindow->DrawList->AddRectFilled(bg_rect.Min, bg_rect.Max, node->LastBgColor, node->HostWindow->WindowRounding, bg_rounding_flags);
16240|      0|            }
16241|  76.6k|}
_ZN5ImGui28GetWindowAlwaysWantOwnTabBarEP11ImGuiWindow:
19300|   170k|{
19301|   170k|    ImGuiContext& g = *GImGui;
19302|   170k|    if (g.IO.ConfigDockingAlwaysTabBar || window->WindowClass.DockingAlwaysTabBar)
  ------------------
  |  Branch (19302:9): [True: 0, False: 170k]
  |  Branch (19302:43): [True: 0, False: 170k]
  ------------------
19303|      0|        if ((window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0)
  ------------------
  |  Branch (19303:13): [True: 0, False: 0]
  ------------------
19304|      0|            if (!window->IsFallbackWindow)    // We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
  ------------------
  |  Branch (19304:17): [True: 0, False: 0]
  ------------------
19305|      0|                return true;
19306|   170k|    return false;
19307|   170k|}
_ZN5ImGui27BeginDockableDragDropSourceEP11ImGuiWindow:
19486|    530|{
19487|    530|    ImGuiContext& g = *GImGui;
19488|    530|    IM_ASSERT(g.ActiveId == window->MoveId);
  ------------------
  |  |   23|    530|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
19489|    530|    IM_ASSERT(g.MovingWindow == window);
  ------------------
  |  |   23|    530|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
19490|    530|    IM_ASSERT(g.CurrentWindow == window);
  ------------------
  |  |   23|    530|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
19491|       |
19492|       |    // 0: Hold SHIFT to disable docking, 1: Hold SHIFT to enable docking.
19493|    530|    if (g.IO.ConfigDockingWithShift != g.IO.KeyShift)
  ------------------
  |  Branch (19493:9): [True: 0, False: 530]
  ------------------
19494|      0|    {
19495|       |        // When ConfigDockingWithShift is set, display a tooltip to increase UI affordance.
19496|       |        // We cannot set for HoveredWindowUnderMovingWindow != NULL here, as it is only valid/useful when drag and drop is already active
19497|       |        // (because of the 'is_mouse_dragging_with_an_expected_destination' logic in UpdateViewportsNewFrame() function)
19498|      0|        IM_ASSERT(g.NextWindowData.Flags == 0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
19499|      0|        if (g.IO.ConfigDockingWithShift && g.MouseStationaryTimer >= 1.0f && g.ActiveId >= 1.0f)
  ------------------
  |  Branch (19499:13): [True: 0, False: 0]
  |  Branch (19499:44): [True: 0, False: 0]
  |  Branch (19499:78): [True: 0, False: 0]
  ------------------
19500|      0|            SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey_DockingHoldShiftToDock));
19501|      0|        return;
19502|      0|    }
19503|       |
19504|    530|    g.LastItemData.ID = window->MoveId;
19505|    530|    window = window->RootWindowDockTree;
19506|    530|    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
  ------------------
  |  |   23|    530|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
19507|    530|    bool is_drag_docking = (g.IO.ConfigDockingWithShift) || ImRect(0, 0, window->SizeFull.x, GetFrameHeight()).Contains(g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
  ------------------
  |  Branch (19507:28): [True: 0, False: 530]
  |  Branch (19507:61): [True: 207, False: 323]
  ------------------
19508|    530|    ImGuiDragDropFlags drag_drop_flags = ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_PayloadAutoExpire | ImGuiDragDropFlags_PayloadNoCrossContext | ImGuiDragDropFlags_PayloadNoCrossProcess;
19509|    530|    if (is_drag_docking && BeginDragDropSource(drag_drop_flags))
  ------------------
  |  Branch (19509:9): [True: 207, False: 323]
  |  Branch (19509:28): [True: 158, False: 49]
  ------------------
19510|    158|    {
19511|    158|        SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, sizeof(window));
  ------------------
  |  |  227|    158|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
19512|    158|        EndDragDropSource();
19513|    158|        StoreDockStyleForWindow(window); // Store style overrides while dragging (even when not docked) because docking preview may need it.
19514|    158|    }
19515|    530|}
_ZN5ImGui27BeginDockableDragDropTargetEP11ImGuiWindow:
19518|    164|{
19519|    164|    ImGuiContext& g = *GImGui;
19520|       |
19521|       |    //IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
19522|    164|    IM_ASSERT((window->Flags & ImGuiWindowFlags_NoDocking) == 0);
  ------------------
  |  |   23|    164|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
19523|    164|    if (!g.DragDropActive)
  ------------------
  |  Branch (19523:9): [True: 0, False: 164]
  ------------------
19524|      0|        return;
19525|       |    //GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
19526|    164|    if (!BeginDragDropTargetCustom(window->Rect(), window->ID))
  ------------------
  |  Branch (19526:9): [True: 163, False: 1]
  ------------------
19527|    163|        return;
19528|       |
19529|       |    // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
19530|       |    // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
19531|      1|    const ImGuiPayload* payload = &g.DragDropPayload;
19532|      1|    if (!payload->IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, *(ImGuiWindow**)payload->Data))
  ------------------
  |  |  227|      1|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (19532:9): [True: 0, False: 1]
  |  Branch (19532:60): [True: 0, False: 1]
  ------------------
19533|      0|    {
19534|      0|        EndDragDropTarget();
19535|      0|        return;
19536|      0|    }
19537|       |
19538|      1|    ImGuiWindow* payload_window = *(ImGuiWindow**)payload->Data;
19539|      1|    if (AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect))
  ------------------
  |  |  227|      1|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (19539:9): [True: 1, False: 0]
  ------------------
19540|      1|    {
19541|       |        // Select target node
19542|       |        // (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
19543|      1|        bool dock_into_floating_window = false;
19544|      1|        ImGuiDockNode* node = NULL;
19545|      1|        if (window->DockNodeAsHost)
  ------------------
  |  Branch (19545:13): [True: 0, False: 1]
  ------------------
19546|      0|        {
19547|       |            // Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
19548|      0|            node = DockNodeTreeFindVisibleNodeByPos(window->DockNodeAsHost, g.IO.MousePos);
19549|       |
19550|       |            // There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
19551|       |            // In this case we need to fallback into any leaf mode, possibly the central node.
19552|       |            // FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
19553|      0|            if (node && node->IsDockSpace() && node->IsRootNode())
  ------------------
  |  Branch (19553:17): [True: 0, False: 0]
  |  Branch (19553:25): [True: 0, False: 0]
  |  Branch (19553:48): [True: 0, False: 0]
  ------------------
19554|      0|                node = (node->CentralNode && node->IsLeafNode()) ? node->CentralNode : DockNodeTreeFindFallbackLeafNode(node);
  ------------------
  |  Branch (19554:25): [True: 0, False: 0]
  |  Branch (19554:46): [True: 0, False: 0]
  ------------------
19555|      0|        }
19556|      1|        else
19557|      1|        {
19558|      1|            if (window->DockNode)
  ------------------
  |  Branch (19558:17): [True: 0, False: 1]
  ------------------
19559|      0|                node = window->DockNode;
19560|      1|            else
19561|      1|                dock_into_floating_window = true; // Dock into a regular window
19562|      1|        }
19563|       |
19564|      1|        const ImRect explicit_target_rect = (node && node->TabBar && !node->IsHiddenTabBar() && !node->IsNoTabBar()) ? node->TabBar->BarRect : ImRect(window->Pos, window->Pos + ImVec2(window->Size.x, GetFrameHeight()));
  ------------------
  |  Branch (19564:46): [True: 0, False: 1]
  |  Branch (19564:54): [True: 0, False: 0]
  |  Branch (19564:70): [True: 0, False: 0]
  |  Branch (19564:97): [True: 0, False: 0]
  ------------------
19565|      1|        const bool is_explicit_target = g.IO.ConfigDockingWithShift || IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max);
  ------------------
  |  Branch (19565:41): [True: 0, False: 1]
  |  Branch (19565:72): [True: 1, False: 0]
  ------------------
19566|       |
19567|       |        // Preview docking request and find out split direction/ratio
19568|       |        //const bool do_preview = true;     // Ignore testing for payload->IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
19569|      1|        const bool do_preview = payload->IsPreview() || payload->IsDelivery();
  ------------------
  |  Branch (19569:33): [True: 0, False: 1]
  |  Branch (19569:57): [True: 0, False: 1]
  ------------------
19570|      1|        if (do_preview && (node != NULL || dock_into_floating_window))
  ------------------
  |  Branch (19570:13): [True: 0, False: 1]
  |  Branch (19570:28): [True: 0, False: 0]
  |  Branch (19570:44): [True: 0, False: 0]
  ------------------
19571|      0|        {
19572|       |            // If we have a non-leaf node it means we are hovering the border of a parent node, in which case only outer markers will appear.
19573|      0|            ImGuiDockPreviewData split_inner;
19574|      0|            ImGuiDockPreviewData split_outer;
19575|      0|            ImGuiDockPreviewData* split_data = &split_inner;
19576|      0|            if (node && (node->ParentNode || node->IsCentralNode() || !node->IsLeafNode()))
  ------------------
  |  Branch (19576:17): [True: 0, False: 0]
  |  Branch (19576:26): [True: 0, False: 0]
  |  Branch (19576:46): [True: 0, False: 0]
  |  Branch (19576:71): [True: 0, False: 0]
  ------------------
19577|      0|                if (ImGuiDockNode* root_node = DockNodeGetRootNode(node))
  ------------------
  |  Branch (19577:36): [True: 0, False: 0]
  ------------------
19578|      0|                {
19579|      0|                    DockNodePreviewDockSetup(window, root_node, payload_window, NULL, &split_outer, is_explicit_target, true);
19580|      0|                    if (split_outer.IsSplitDirExplicit)
  ------------------
  |  Branch (19580:25): [True: 0, False: 0]
  ------------------
19581|      0|                        split_data = &split_outer;
19582|      0|                }
19583|      0|            if (!node || node->IsLeafNode())
  ------------------
  |  Branch (19583:17): [True: 0, False: 0]
  |  Branch (19583:26): [True: 0, False: 0]
  ------------------
19584|      0|                DockNodePreviewDockSetup(window, node, payload_window, NULL, &split_inner, is_explicit_target, false);
19585|      0|            if (split_data == &split_outer)
  ------------------
  |  Branch (19585:17): [True: 0, False: 0]
  ------------------
19586|      0|                split_inner.IsDropAllowed = false;
19587|       |
19588|       |            // Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
19589|      0|            DockNodePreviewDockRender(window, node, payload_window, &split_inner);
19590|      0|            DockNodePreviewDockRender(window, node, payload_window, &split_outer);
19591|       |
19592|       |            // Queue docking request
19593|      0|            if (split_data->IsDropAllowed && payload->IsDelivery())
  ------------------
  |  Branch (19593:17): [True: 0, False: 0]
  |  Branch (19593:46): [True: 0, False: 0]
  ------------------
19594|      0|                DockContextQueueDock(&g, window, split_data->SplitNode, payload_window, split_data->SplitDir, split_data->SplitRatio, split_data == &split_outer);
19595|      0|        }
19596|      1|    }
19597|      1|    EndDragDropTarget();
19598|      1|}
imgui.cpp:_ZL20FindLatestInputEventP12ImGuiContext19ImGuiInputEventTypei:
 1547|  30.0k|{
 1548|  30.0k|    ImGuiContext& g = *ctx;
 1549|  50.1k|    for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
  ------------------
  |  Branch (1549:47): [True: 29.0k, False: 21.1k]
  ------------------
 1550|  29.0k|    {
 1551|  29.0k|        ImGuiInputEvent* e = &g.InputEventsQueue[n];
 1552|  29.0k|        if (e->Type != type)
  ------------------
  |  Branch (1552:13): [True: 15.9k, False: 13.1k]
  ------------------
 1553|  15.9k|            continue;
 1554|  13.1k|        if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
  ------------------
  |  Branch (1554:13): [True: 3.83k, False: 9.29k]
  |  Branch (1554:48): [True: 1.80k, False: 2.03k]
  ------------------
 1555|  1.80k|            continue;
 1556|  11.3k|        if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
  ------------------
  |  Branch (1556:13): [True: 7.05k, False: 4.26k]
  |  Branch (1556:56): [True: 2.34k, False: 4.71k]
  ------------------
 1557|  2.34k|            continue;
 1558|  8.98k|        return e;
 1559|  11.3k|    }
 1560|  21.1k|    return NULL;
 1561|  30.0k|}
imgui.cpp:_ZL13MallocWrappermPv:
 1240|  1.22k|static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }
  ------------------
  |  |   94|  1.22k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL11FreeWrapperPvS_:
 1241|  1.18k|static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }
  ------------------
  |  |   94|  1.18k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
imgui.cpp:_ZL23SetupDrawListSharedDatav:
 4817|  76.6k|{
 4818|  76.6k|    ImGuiContext& g = *GImGui;
 4819|  76.6k|    ImRect virtual_space(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
 4820|  76.6k|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (4820:35): [True: 76.6k, False: 76.6k]
  ------------------
 4821|  76.6k|        virtual_space.Add(viewport->GetMainRect());
 4822|  76.6k|    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
 4823|  76.6k|    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
 4824|  76.6k|    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
 4825|  76.6k|    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
 4826|  76.6k|    if (g.Style.AntiAliasedLines)
  ------------------
  |  Branch (4826:9): [True: 76.6k, False: 0]
  ------------------
 4827|  76.6k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
 4828|  76.6k|    if (g.Style.AntiAliasedLinesUseTex && !(g.IO.Fonts->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (4828:9): [True: 76.6k, False: 0]
  |  Branch (4828:43): [True: 76.6k, False: 0]
  ------------------
 4829|  76.6k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
 4830|  76.6k|    if (g.Style.AntiAliasedFill)
  ------------------
  |  Branch (4830:9): [True: 76.6k, False: 0]
  ------------------
 4831|  76.6k|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
 4832|  76.6k|    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
  ------------------
  |  Branch (4832:9): [True: 0, False: 76.6k]
  ------------------
 4833|      0|        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;
 4834|  76.6k|}
imgui.cpp:_ZL24IsWindowActiveAndVisibleP11ImGuiWindow:
 4730|   247k|{
 4731|   247k|    return (window->Active) && (!window->Hidden);
  ------------------
  |  Branch (4731:12): [True: 110k, False: 136k]
  |  Branch (4731:32): [True: 110k, False: 24]
  ------------------
 4732|   247k|}
imgui.cpp:_ZL21GetWindowDisplayLayerP11ImGuiWindow:
 5160|  76.6k|{
 5161|  76.6k|    return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
  ------------------
  |  Branch (5161:12): [True: 0, False: 76.6k]
  ------------------
 5162|  76.6k|}
imgui.cpp:_ZL21AddWindowToSortBufferP8ImVectorIP11ImGuiWindowES1_:
 5130|   230k|{
 5131|   230k|    out_sorted_windows->push_back(window);
 5132|   230k|    if (window->Active)
  ------------------
  |  Branch (5132:9): [True: 93.6k, False: 136k]
  ------------------
 5133|  93.6k|    {
 5134|  93.6k|        int count = window->DC.ChildWindows.Size;
 5135|  93.6k|        ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
 5136|   110k|        for (int i = 0; i < count; i++)
  ------------------
  |  Branch (5136:25): [True: 16.9k, False: 93.6k]
  ------------------
 5137|  16.9k|        {
 5138|  16.9k|            ImGuiWindow* child = window->DC.ChildWindows[i];
 5139|  16.9k|            if (child->Active)
  ------------------
  |  Branch (5139:17): [True: 16.9k, False: 0]
  ------------------
 5140|  16.9k|                AddWindowToSortBuffer(out_sorted_windows, child);
 5141|  16.9k|        }
 5142|  93.6k|    }
 5143|   230k|}
imgui.cpp:_ZL20InitViewportDrawDataP14ImGuiViewportP:
 5189|  76.6k|{
 5190|  76.6k|    ImGuiIO& io = ImGui::GetIO();
 5191|  76.6k|    ImDrawData* draw_data = &viewport->DrawDataP;
 5192|       |
 5193|  76.6k|    viewport->DrawData = draw_data; // Make publicly accessible
 5194|  76.6k|    viewport->DrawDataBuilder.Layers[0] = &draw_data->CmdLists;
 5195|  76.6k|    viewport->DrawDataBuilder.Layers[1] = &viewport->DrawDataBuilder.LayerData1;
 5196|  76.6k|    viewport->DrawDataBuilder.Layers[0]->resize(0);
 5197|  76.6k|    viewport->DrawDataBuilder.Layers[1]->resize(0);
 5198|       |
 5199|       |    // When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
 5200|       |    // and to allow applications/backends to easily skip rendering.
 5201|       |    // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
 5202|       |    // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
 5203|       |    // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
 5204|  76.6k|    const bool is_minimized = (viewport->Flags & ImGuiViewportFlags_IsMinimized) != 0;
 5205|       |
 5206|  76.6k|    draw_data->Valid = true;
 5207|  76.6k|    draw_data->CmdListsCount = 0;
 5208|  76.6k|    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
 5209|  76.6k|    draw_data->DisplayPos = viewport->Pos;
 5210|  76.6k|    draw_data->DisplaySize = is_minimized ? ImVec2(0.0f, 0.0f) : viewport->Size;
  ------------------
  |  Branch (5210:30): [True: 0, False: 76.6k]
  ------------------
 5211|  76.6k|    draw_data->FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
 5212|  76.6k|    draw_data->OwnerViewport = viewport;
 5213|  76.6k|}
imgui.cpp:_ZN5ImGuiL23RenderDimmedBackgroundsEv:
 5302|  76.6k|{
 5303|  76.6k|    ImGuiContext& g = *GImGui;
 5304|  76.6k|    ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
 5305|  76.6k|    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (5305:9): [True: 76.6k, False: 0]
  |  Branch (5305:33): [True: 76.6k, False: 0]
  ------------------
 5306|  76.6k|        return;
 5307|      0|    const bool dim_bg_for_modal = (modal_window != NULL);
 5308|      0|    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != NULL && g.NavWindowingTargetAnim->Active);
  ------------------
  |  Branch (5308:42): [True: 0, False: 0]
  |  Branch (5308:78): [True: 0, False: 0]
  ------------------
 5309|      0|    if (!dim_bg_for_modal && !dim_bg_for_window_list)
  ------------------
  |  Branch (5309:9): [True: 0, False: 0]
  |  Branch (5309:30): [True: 0, False: 0]
  ------------------
 5310|      0|        return;
 5311|       |
 5312|      0|    ImGuiViewport* viewports_already_dimmed[2] = { NULL, NULL };
 5313|      0|    if (dim_bg_for_modal)
  ------------------
  |  Branch (5313:9): [True: 0, False: 0]
  ------------------
 5314|      0|    {
 5315|       |        // Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
 5316|      0|        ImGuiWindow* dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);
 5317|      0|        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(modal_window->DC.ModalDimBgColor, g.DimBgRatio));
 5318|      0|        viewports_already_dimmed[0] = modal_window->Viewport;
 5319|      0|    }
 5320|      0|    else if (dim_bg_for_window_list)
  ------------------
  |  Branch (5320:14): [True: 0, False: 0]
  ------------------
 5321|      0|    {
 5322|       |        // Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
 5323|      0|        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5324|      0|        if (g.NavWindowingListWindow != NULL && g.NavWindowingListWindow->Viewport && g.NavWindowingListWindow->Viewport != g.NavWindowingTargetAnim->Viewport)
  ------------------
  |  Branch (5324:13): [True: 0, False: 0]
  |  Branch (5324:49): [True: 0, False: 0]
  |  Branch (5324:87): [True: 0, False: 0]
  ------------------
 5325|      0|            RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));
 5326|      0|        viewports_already_dimmed[0] = g.NavWindowingTargetAnim->Viewport;
 5327|      0|        viewports_already_dimmed[1] = g.NavWindowingListWindow ? g.NavWindowingListWindow->Viewport : NULL;
  ------------------
  |  Branch (5327:39): [True: 0, False: 0]
  ------------------
 5328|       |
 5329|       |        // Draw border around CTRL+Tab target window
 5330|      0|        ImGuiWindow* window = g.NavWindowingTargetAnim;
 5331|      0|        ImGuiViewport* viewport = window->Viewport;
 5332|      0|        float distance = g.FontSize;
 5333|      0|        ImRect bb = window->Rect();
 5334|      0|        bb.Expand(distance);
 5335|      0|        if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
  ------------------
  |  Branch (5335:13): [True: 0, False: 0]
  |  Branch (5335:50): [True: 0, False: 0]
  ------------------
 5336|      0|            bb.Expand(-distance - 1.0f); // If a window fits the entire viewport, adjust its highlight inward
 5337|      0|        window->DrawList->ChannelsMerge();
 5338|      0|        if (window->DrawList->CmdBuffer.Size == 0)
  ------------------
  |  Branch (5338:13): [True: 0, False: 0]
  ------------------
 5339|      0|            window->DrawList->AddDrawCmd();
 5340|      0|        window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);
 5341|      0|        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);
 5342|      0|        window->DrawList->PopClipRect();
 5343|      0|    }
 5344|       |
 5345|       |    // Draw dimming background on _other_ viewports than the ones our windows are in
 5346|      0|    for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (5346:35): [True: 0, False: 0]
  ------------------
 5347|      0|    {
 5348|      0|        if (viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1])
  ------------------
  |  Branch (5348:13): [True: 0, False: 0]
  |  Branch (5348:56): [True: 0, False: 0]
  ------------------
 5349|      0|            continue;
 5350|      0|        if (modal_window && viewport->Window && IsWindowAbove(viewport->Window, modal_window))
  ------------------
  |  Branch (5350:13): [True: 0, False: 0]
  |  Branch (5350:29): [True: 0, False: 0]
  |  Branch (5350:49): [True: 0, False: 0]
  ------------------
 5351|      0|            continue;
 5352|      0|        ImDrawList* draw_list = GetForegroundDrawList(viewport);
 5353|      0|        const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
  ------------------
  |  Branch (5353:46): [True: 0, False: 0]
  ------------------
 5354|      0|        draw_list->AddRectFilled(viewport->Pos, viewport->Pos + viewport->Size, dim_bg_col);
 5355|      0|    }
 5356|      0|}
imgui.cpp:_ZL23AddRootWindowToDrawDataP11ImGuiWindow:
 5166|  76.6k|{
 5167|  76.6k|    AddWindowToDrawData(window, GetWindowDisplayLayer(window));
 5168|  76.6k|}
imgui.cpp:_ZL19AddWindowToDrawDataP11ImGuiWindowi:
 5146|  93.6k|{
 5147|  93.6k|    ImGuiContext& g = *GImGui;
 5148|  93.6k|    ImGuiViewportP* viewport = window->Viewport;
 5149|  93.6k|    IM_ASSERT(viewport != NULL);
  ------------------
  |  |   23|  93.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5150|  93.6k|    g.IO.MetricsRenderWindows++;
 5151|  93.6k|    if (window->DrawList->_Splitter._Count > 1)
  ------------------
  |  Branch (5151:9): [True: 0, False: 93.6k]
  ------------------
 5152|      0|        window->DrawList->ChannelsMerge(); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
 5153|  93.6k|    ImGui::AddDrawListToDrawDataEx(&viewport->DrawDataP, viewport->DrawDataBuilder.Layers[layer], window->DrawList);
 5154|  93.6k|    for (ImGuiWindow* child : window->DC.ChildWindows)
  ------------------
  |  Branch (5154:29): [True: 16.9k, False: 93.6k]
  ------------------
 5155|  16.9k|        if (IsWindowActiveAndVisible(child)) // Clipped children may have been marked not active
  ------------------
  |  Branch (5155:13): [True: 16.9k, False: 11]
  ------------------
 5156|  16.9k|            AddWindowToDrawData(child, layer);
 5157|  93.6k|}
imgui.cpp:_ZL30FlattenDrawDataIntoSingleLayerP17ImDrawDataBuilder:
 5171|  76.6k|{
 5172|  76.6k|    int n = builder->Layers[0]->Size;
 5173|  76.6k|    int full_size = n;
 5174|   153k|    for (int i = 1; i < IM_ARRAYSIZE(builder->Layers); i++)
  ------------------
  |  |   93|   153k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5174:21): [True: 76.6k, False: 76.6k]
  ------------------
 5175|  76.6k|        full_size += builder->Layers[i]->Size;
 5176|  76.6k|    builder->Layers[0]->resize(full_size);
 5177|   153k|    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(builder->Layers); layer_n++)
  ------------------
  |  |   93|   153k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (5177:27): [True: 76.6k, False: 76.6k]
  ------------------
 5178|  76.6k|    {
 5179|  76.6k|        ImVector<ImDrawList*>* layer = builder->Layers[layer_n];
 5180|  76.6k|        if (layer->empty())
  ------------------
  |  Branch (5180:13): [True: 76.6k, False: 0]
  ------------------
 5181|  76.6k|            continue;
 5182|      0|        memcpy(builder->Layers[0]->Data + n, layer->Data, layer->Size * sizeof(ImDrawList*));
 5183|      0|        n += layer->Size;
 5184|      0|        layer->resize(0);
 5185|      0|    }
 5186|  76.6k|}
imgui.cpp:_ZL22CalcWindowContentSizesP11ImGuiWindowP6ImVec2S2_:
 6131|   170k|{
 6132|   170k|    bool preserve_old_content_sizes = false;
 6133|   170k|    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
  ------------------
  |  Branch (6133:9): [True: 59.7k, False: 110k]
  |  Branch (6133:30): [True: 59.7k, False: 0]
  |  Branch (6133:61): [True: 59.7k, False: 0]
  ------------------
 6134|  59.7k|        preserve_old_content_sizes = true;
 6135|   110k|    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
  ------------------
  |  Branch (6135:14): [True: 13, False: 110k]
  |  Branch (6135:32): [True: 11, False: 2]
  |  Branch (6135:76): [True: 11, False: 0]
  ------------------
 6136|     11|        preserve_old_content_sizes = true;
 6137|   170k|    if (preserve_old_content_sizes)
  ------------------
  |  Branch (6137:9): [True: 59.7k, False: 110k]
  ------------------
 6138|  59.7k|    {
 6139|  59.7k|        *content_size_current = window->ContentSize;
 6140|  59.7k|        *content_size_ideal = window->ContentSizeIdeal;
 6141|  59.7k|        return;
 6142|  59.7k|    }
 6143|       |
 6144|   110k|    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x);
  ------------------
  |  |  287|   221k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6144:31): [True: 0, False: 110k]
  ------------------
 6145|   110k|    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y);
  ------------------
  |  |  287|   221k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6145:31): [True: 0, False: 110k]
  ------------------
 6146|   110k|    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : IM_TRUNC(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x);
  ------------------
  |  |  287|   221k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6146:29): [True: 0, False: 110k]
  ------------------
 6147|   110k|    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : IM_TRUNC(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y);
  ------------------
  |  |  287|   221k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6147:29): [True: 0, False: 110k]
  ------------------
 6148|   110k|}
imgui.cpp:_ZL21CalcWindowAutoFitSizeP11ImGuiWindowRK6ImVec2:
 6151|   170k|{
 6152|   170k|    ImGuiContext& g = *GImGui;
 6153|   170k|    ImGuiStyle& style = g.Style;
 6154|   170k|    const float decoration_w_without_scrollbars = window->DecoOuterSizeX1 + window->DecoOuterSizeX2 - window->ScrollbarSizes.x;
 6155|   170k|    const float decoration_h_without_scrollbars = window->DecoOuterSizeY1 + window->DecoOuterSizeY2 - window->ScrollbarSizes.y;
 6156|   170k|    ImVec2 size_pad = window->WindowPadding * 2.0f;
 6157|   170k|    ImVec2 size_desired = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars);
 6158|   170k|    if (window->Flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (6158:9): [True: 0, False: 170k]
  ------------------
 6159|      0|    {
 6160|       |        // Tooltip always resize
 6161|      0|        return size_desired;
 6162|      0|    }
 6163|   170k|    else
 6164|   170k|    {
 6165|       |        // Maximum window size is determined by the viewport size or monitor size
 6166|   170k|        ImVec2 size_min = CalcWindowMinSize(window);
 6167|   170k|        ImVec2 size_max = ImVec2(FLT_MAX, FLT_MAX);
 6168|       |
 6169|       |        // Child windows are layed within their parent (unless they are also popups/menus) and thus have no restriction
 6170|   170k|        if ((window->Flags & ImGuiWindowFlags_ChildWindow) == 0 || (window->Flags & ImGuiWindowFlags_Popup) != 0)
  ------------------
  |  Branch (6170:13): [True: 153k, False: 16.9k]
  |  Branch (6170:68): [True: 0, False: 16.9k]
  ------------------
 6171|   153k|        {
 6172|   153k|            if (!window->ViewportOwned)
  ------------------
  |  Branch (6172:17): [True: 153k, False: 0]
  ------------------
 6173|   153k|                size_max = ImGui::GetMainViewport()->WorkSize - style.DisplaySafeAreaPadding * 2.0f;
 6174|   153k|            const int monitor_idx = window->ViewportAllowPlatformMonitorExtend;
 6175|   153k|            if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size)
  ------------------
  |  Branch (6175:17): [True: 0, False: 153k]
  |  Branch (6175:37): [True: 0, False: 0]
  ------------------
 6176|      0|                size_max = g.PlatformIO.Monitors[monitor_idx].WorkSize - style.DisplaySafeAreaPadding * 2.0f;
 6177|   153k|        }
 6178|       |
 6179|   170k|        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, size_max));
 6180|       |
 6181|       |        // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one axis may be auto-fit when calculating scrollbars,
 6182|       |        // we may need to compute/store three variants of size_auto_fit, for x/y/xy.
 6183|       |        // Here we implement a workaround for child windows only, but a full solution would apply to normal windows as well:
 6184|   170k|        if ((window->ChildFlags & ImGuiChildFlags_ResizeX) && !(window->ChildFlags & ImGuiChildFlags_ResizeY))
  ------------------
  |  Branch (6184:13): [True: 0, False: 170k]
  |  Branch (6184:63): [True: 0, False: 0]
  ------------------
 6185|      0|            size_auto_fit.y = window->SizeFull.y;
 6186|   170k|        else if (!(window->ChildFlags & ImGuiChildFlags_ResizeX) && (window->ChildFlags & ImGuiChildFlags_ResizeY))
  ------------------
  |  Branch (6186:18): [True: 170k, False: 0]
  |  Branch (6186:69): [True: 0, False: 170k]
  ------------------
 6187|      0|            size_auto_fit.x = window->SizeFull.x;
 6188|       |
 6189|       |        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
 6190|       |        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
 6191|   170k|        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 6192|   170k|        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
  ------------------
  |  Branch (6192:39): [True: 22, False: 170k]
  |  Branch (6192:140): [True: 22, False: 0]
  |  Branch (6192:191): [True: 0, False: 22]
  |  Branch (6192:250): [True: 16.9k, False: 153k]
  ------------------
 6193|   170k|        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
  ------------------
  |  Branch (6193:39): [True: 178, False: 170k]
  |  Branch (6193:140): [True: 178, False: 0]
  |  Branch (6193:192): [True: 0, False: 170k]
  ------------------
 6194|   170k|        if (will_have_scrollbar_x)
  ------------------
  |  Branch (6194:13): [True: 16.9k, False: 153k]
  ------------------
 6195|  16.9k|            size_auto_fit.y += style.ScrollbarSize;
 6196|   170k|        if (will_have_scrollbar_y)
  ------------------
  |  Branch (6196:13): [True: 178, False: 170k]
  ------------------
 6197|    178|            size_auto_fit.x += style.ScrollbarSize;
 6198|   170k|        return size_auto_fit;
 6199|   170k|    }
 6200|   170k|}
imgui.cpp:_ZL17CalcWindowMinSizeP11ImGuiWindow:
 6078|   511k|{
 6079|       |    // We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
 6080|       |    // FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
 6081|       |    // Perhaps should tend further a neater test for this.
 6082|   511k|    ImGuiContext& g = *GImGui;
 6083|   511k|    ImVec2 size_min;
 6084|   511k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !(window->Flags & ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (6084:9): [True: 50.8k, False: 460k]
  |  Branch (6084:59): [True: 50.8k, False: 0]
  ------------------
 6085|  50.8k|    {
 6086|  50.8k|        size_min.x = (window->ChildFlags & ImGuiChildFlags_ResizeX) ? g.Style.WindowMinSize.x : 4.0f;
  ------------------
  |  Branch (6086:22): [True: 0, False: 50.8k]
  ------------------
 6087|  50.8k|        size_min.y = (window->ChildFlags & ImGuiChildFlags_ResizeY) ? g.Style.WindowMinSize.y : 4.0f;
  ------------------
  |  Branch (6087:22): [True: 0, False: 50.8k]
  ------------------
 6088|  50.8k|    }
 6089|   460k|    else
 6090|   460k|    {
 6091|   460k|        size_min.x = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.x : 4.0f;
  ------------------
  |  Branch (6091:22): [True: 460k, False: 0]
  ------------------
 6092|   460k|        size_min.y = ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.y : 4.0f;
  ------------------
  |  Branch (6092:22): [True: 460k, False: 0]
  ------------------
 6093|   460k|    }
 6094|       |
 6095|       |    // Reduce artifacts with very small windows
 6096|   511k|    ImGuiWindow* window_for_height = GetWindowForTitleAndMenuHeight(window);
 6097|   511k|    size_min.y = ImMax(size_min.y, window_for_height->TitleBarHeight + window_for_height->MenuBarHeight + ImMax(0.0f, g.Style.WindowRounding - 1.0f));
 6098|   511k|    return size_min;
 6099|   511k|}
imgui.cpp:_ZL30GetWindowForTitleAndMenuHeightP11ImGuiWindow:
 6073|   511k|{
 6074|   511k|    return (window->DockNodeAsHost && window->DockNodeAsHost->VisibleWindow) ? window->DockNodeAsHost->VisibleWindow : window;
  ------------------
  |  Branch (6074:13): [True: 0, False: 511k]
  |  Branch (6074:39): [True: 0, False: 0]
  ------------------
 6075|   511k|}
imgui.cpp:_ZL29CalcWindowSizeAfterConstraintP11ImGuiWindowRK6ImVec2:
 6102|   340k|{
 6103|   340k|    ImGuiContext& g = *GImGui;
 6104|   340k|    ImVec2 new_size = size_desired;
 6105|   340k|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
  ------------------
  |  Branch (6105:9): [True: 0, False: 340k]
  ------------------
 6106|      0|    {
 6107|       |        // See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
 6108|      0|        ImRect cr = g.NextWindowData.SizeConstraintRect;
 6109|      0|        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
  ------------------
  |  Branch (6109:23): [True: 0, False: 0]
  |  Branch (6109:40): [True: 0, False: 0]
  ------------------
 6110|      0|        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
  ------------------
  |  Branch (6110:23): [True: 0, False: 0]
  |  Branch (6110:40): [True: 0, False: 0]
  ------------------
 6111|      0|        if (g.NextWindowData.SizeCallback)
  ------------------
  |  Branch (6111:13): [True: 0, False: 0]
  ------------------
 6112|      0|        {
 6113|      0|            ImGuiSizeCallbackData data;
 6114|      0|            data.UserData = g.NextWindowData.SizeCallbackUserData;
 6115|      0|            data.Pos = window->Pos;
 6116|      0|            data.CurrentSize = window->SizeFull;
 6117|      0|            data.DesiredSize = new_size;
 6118|      0|            g.NextWindowData.SizeCallback(&data);
 6119|      0|            new_size = data.DesiredSize;
 6120|      0|        }
 6121|      0|        new_size.x = IM_TRUNC(new_size.x);
  ------------------
  |  |  287|      0|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 6122|      0|        new_size.y = IM_TRUNC(new_size.y);
  ------------------
  |  |  287|      0|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 6123|      0|    }
 6124|       |
 6125|       |    // Minimum size
 6126|   340k|    ImVec2 size_min = CalcWindowMinSize(window);
 6127|   340k|    return ImMax(new_size, size_min);
 6128|   340k|}
imgui.cpp:_ZL15CreateNewWindowPKci:
 6044|      3|{
 6045|       |    // Create window the first time
 6046|       |    //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
 6047|      3|    ImGuiContext& g = *GImGui;
 6048|      3|    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
  ------------------
  |  | 2054|      6|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 6049|      3|    window->Flags = flags;
 6050|      3|    g.WindowsById.SetVoidPtr(window->ID, window);
 6051|       |
 6052|      3|    ImGuiWindowSettings* settings = NULL;
 6053|      3|    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
  ------------------
  |  Branch (6053:9): [True: 2, False: 1]
  ------------------
 6054|      2|        if ((settings = ImGui::FindWindowSettingsByWindow(window)) != 0)
  ------------------
  |  Branch (6054:13): [True: 0, False: 2]
  ------------------
 6055|      0|            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
 6056|       |
 6057|      3|    InitOrLoadWindowSettings(window, settings);
 6058|       |
 6059|      3|    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
  ------------------
  |  Branch (6059:9): [True: 0, False: 3]
  ------------------
 6060|      0|        g.Windows.push_front(window); // Quite slow but rare and only once
 6061|      3|    else
 6062|      3|        g.Windows.push_back(window);
 6063|       |
 6064|      3|    return window;
 6065|      3|}
imgui.cpp:_ZL28UpdateWindowInFocusOrderListP11ImGuiWindowbi:
 5989|   170k|{
 5990|   170k|    ImGuiContext& g = *GImGui;
 5991|       |
 5992|   170k|    const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
  ------------------
  |  Branch (5992:40): [True: 16.9k, False: 153k]
  |  Branch (5992:92): [True: 16.9k, False: 0]
  |  Branch (5992:137): [True: 0, False: 0]
  ------------------
 5993|   170k|    const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
 5994|   170k|    if ((just_created || child_flag_changed) && !new_is_explicit_child)
  ------------------
  |  Branch (5994:10): [True: 3, False: 170k]
  |  Branch (5994:26): [True: 0, False: 170k]
  |  Branch (5994:49): [True: 2, False: 1]
  ------------------
 5995|      2|    {
 5996|      2|        IM_ASSERT(!g.WindowsFocusOrder.contains(window));
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 5997|      2|        g.WindowsFocusOrder.push_back(window);
 5998|      2|        window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
 5999|      2|    }
 6000|   170k|    else if (!just_created && child_flag_changed && new_is_explicit_child)
  ------------------
  |  Branch (6000:14): [True: 170k, False: 1]
  |  Branch (6000:31): [True: 0, False: 170k]
  |  Branch (6000:53): [True: 0, False: 0]
  ------------------
 6001|      0|    {
 6002|      0|        IM_ASSERT(g.WindowsFocusOrder[window->FocusOrder] == window);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6003|      0|        for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
  ------------------
  |  Branch (6003:46): [True: 0, False: 0]
  ------------------
 6004|      0|            g.WindowsFocusOrder[n]->FocusOrder--;
 6005|      0|        g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
 6006|      0|        window->FocusOrder = -1;
 6007|      0|    }
 6008|   170k|    window->IsExplicitChild = new_is_explicit_child;
 6009|   170k|}
imgui.cpp:_ZL28SetWindowConditionAllowFlagsP11ImGuiWindowib:
 5952|      8|{
 5953|      8|    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
  ------------------
  |  Branch (5953:44): [True: 4, False: 4]
  ------------------
 5954|      8|    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
  ------------------
  |  Branch (5954:44): [True: 4, False: 4]
  ------------------
 5955|      8|    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
  ------------------
  |  Branch (5955:44): [True: 4, False: 4]
  ------------------
 5956|      8|    window->SetWindowDockAllowFlags      = enabled ? (window->SetWindowDockAllowFlags      | flags) : (window->SetWindowDockAllowFlags      & ~flags);
  ------------------
  |  Branch (5956:44): [True: 4, False: 4]
  ------------------
 5957|      8|}
imgui.cpp:_ZL16SetCurrentWindowP11ImGuiWindow:
 3980|   340k|{
 3981|   340k|    ImGuiContext& g = *GImGui;
 3982|   340k|    g.CurrentWindow = window;
 3983|   340k|    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : NULL;
  ------------------
  |  Branch (3983:22): [True: 263k, False: 76.6k]
  |  Branch (3983:32): [True: 0, False: 263k]
  ------------------
 3984|   340k|    if (window)
  ------------------
  |  Branch (3984:9): [True: 263k, False: 76.6k]
  ------------------
 3985|   263k|    {
 3986|   263k|        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
 3987|   263k|        ImGui::NavUpdateCurrentWindowIsScrollPushableX();
 3988|   263k|    }
 3989|   340k|}
imgui.cpp:_ZL14ClampWindowPosP11ImGuiWindowRK6ImRect:
 6525|   153k|{
 6526|   153k|    ImGuiContext& g = *GImGui;
 6527|   153k|    ImVec2 size_for_clamping = window->Size;
 6528|   153k|    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && window->DockNodeAsHost)
  ------------------
  |  Branch (6528:9): [True: 0, False: 153k]
  |  Branch (6528:51): [True: 0, False: 0]
  ------------------
 6529|      0|        size_for_clamping.y = ImGui::GetFrameHeight(); // Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
 6530|   153k|    else if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
  ------------------
  |  Branch (6530:14): [True: 0, False: 153k]
  |  Branch (6530:56): [True: 0, False: 0]
  ------------------
 6531|      0|        size_for_clamping.y = window->TitleBarHeight;
 6532|   153k|    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
 6533|   153k|}
imgui.cpp:_ZN5ImGuiL24UpdateWindowManualResizeEP11ImGuiWindowRK6ImVec2PiS5_iPjRK6ImRect:
 6302|   110k|{
 6303|   110k|    ImGuiContext& g = *GImGui;
 6304|   110k|    ImGuiWindowFlags flags = window->Flags;
 6305|       |
 6306|   110k|    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
  ------------------
  |  Branch (6306:9): [True: 16.9k, False: 93.6k]
  |  Branch (6306:48): [True: 0, False: 93.6k]
  |  Branch (6306:95): [True: 2, False: 93.6k]
  |  Branch (6306:125): [True: 0, False: 93.6k]
  ------------------
 6307|  16.9k|        return false;
 6308|  93.6k|    if (window->WasActive == false) // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
  ------------------
  |  Branch (6308:9): [True: 76.6k, False: 16.9k]
  ------------------
 6309|  76.6k|        return false;
 6310|       |
 6311|  16.9k|    int ret_auto_fit_mask = 0x00;
 6312|  16.9k|    const float grip_draw_size = IM_TRUNC(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f));
  ------------------
  |  |  287|  16.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 6313|  16.9k|    const float grip_hover_inner_size = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75f) : 0.0f;
  ------------------
  |  |  287|  16.9k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  |  Branch (6313:41): [True: 16.9k, False: 0]
  ------------------
 6314|  16.9k|    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;
  ------------------
  |  Branch (6314:41): [True: 16.9k, False: 0]
  ------------------
 6315|       |
 6316|  16.9k|    ImRect clamp_rect = visibility_rect;
 6317|  16.9k|    const bool window_move_from_title_bar = g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar);
  ------------------
  |  Branch (6317:45): [True: 0, False: 16.9k]
  |  Branch (6317:87): [True: 0, False: 0]
  ------------------
 6318|  16.9k|    if (window_move_from_title_bar)
  ------------------
  |  Branch (6318:9): [True: 0, False: 16.9k]
  ------------------
 6319|      0|        clamp_rect.Min.y -= window->TitleBarHeight;
 6320|       |
 6321|  16.9k|    ImVec2 pos_target(FLT_MAX, FLT_MAX);
 6322|  16.9k|    ImVec2 size_target(FLT_MAX, FLT_MAX);
 6323|       |
 6324|       |    // Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
 6325|       |    // - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
 6326|       |    //   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
 6327|       |    // - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
 6328|       |    // - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
 6329|       |    // We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
 6330|  16.9k|    const bool clip_with_viewport_rect = !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport) || (g.IO.MouseHoveredViewport != window->ViewportId) || !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration);
  ------------------
  |  Branch (6330:42): [True: 16.9k, False: 0]
  |  Branch (6330:110): [True: 0, False: 0]
  |  Branch (6330:163): [True: 0, False: 0]
  ------------------
 6331|  16.9k|    if (clip_with_viewport_rect)
  ------------------
  |  Branch (6331:9): [True: 16.9k, False: 0]
  ------------------
 6332|  16.9k|        window->ClipRect = window->Viewport->GetMainRect();
 6333|       |
 6334|       |    // Resize grips and borders are on layer 1
 6335|  16.9k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 6336|       |
 6337|       |    // Manual resize grips
 6338|  16.9k|    PushID("#RESIZE");
 6339|  50.8k|    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (6339:33): [True: 33.8k, False: 16.9k]
  ------------------
 6340|  33.8k|    {
 6341|  33.8k|        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];
 6342|  33.8k|        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);
 6343|       |
 6344|       |        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
 6345|  33.8k|        bool hovered, held;
 6346|  33.8k|        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
 6347|  33.8k|        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
  ------------------
  |  Branch (6347:13): [True: 16.9k, False: 16.9k]
  ------------------
 6348|  33.8k|        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
  ------------------
  |  Branch (6348:13): [True: 33.8k, False: 0]
  ------------------
 6349|  33.8k|        ImGuiID resize_grip_id = window->GetID(resize_grip_n); // == GetWindowResizeCornerID()
 6350|  33.8k|        ItemAdd(resize_rect, resize_grip_id, NULL, ImGuiItemFlags_NoNav);
 6351|  33.8k|        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 6352|       |        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
 6353|  33.8k|        if (hovered || held)
  ------------------
  |  Branch (6353:13): [True: 80, False: 33.8k]
  |  Branch (6353:24): [True: 0, False: 33.8k]
  ------------------
 6354|     80|            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;
  ------------------
  |  Branch (6354:29): [True: 79, False: 1]
  ------------------
 6355|       |
 6356|  33.8k|        if (held && g.IO.MouseDoubleClicked[0])
  ------------------
  |  Branch (6356:13): [True: 2, False: 33.8k]
  |  Branch (6356:21): [True: 0, False: 2]
  ------------------
 6357|      0|        {
 6358|       |            // Auto-fit when double-clicking
 6359|      0|            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
 6360|      0|            ret_auto_fit_mask = 0x03; // Both axises
 6361|      0|            ClearActiveID();
 6362|      0|        }
 6363|  33.8k|        else if (held)
  ------------------
  |  Branch (6363:18): [True: 2, False: 33.8k]
  ------------------
 6364|      2|        {
 6365|       |            // Resize from any of the four corners
 6366|       |            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
 6367|      2|            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? clamp_rect.Min.x : -FLT_MAX, (def.CornerPosN.y == 1.0f || (def.CornerPosN.y == 0.0f && window_move_from_title_bar)) ? clamp_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (6367:39): [True: 0, False: 2]
  |  Branch (6367:96): [True: 2, False: 0]
  |  Branch (6367:125): [True: 0, False: 0]
  |  Branch (6367:153): [True: 0, False: 0]
  ------------------
 6368|      2|            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? clamp_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0f ? clamp_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (6368:39): [True: 2, False: 0]
  |  Branch (6368:95): [True: 0, False: 2]
  ------------------
 6369|      2|            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
 6370|      2|            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
 6371|      2|            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
 6372|      2|        }
 6373|       |
 6374|       |        // Only lower-left grip is visible before hovering/activating
 6375|  33.8k|        if (resize_grip_n == 0 || held || hovered)
  ------------------
  |  Branch (6375:13): [True: 16.9k, False: 16.9k]
  |  Branch (6375:35): [True: 2, False: 16.9k]
  |  Branch (6375:43): [True: 77, False: 16.8k]
  ------------------
 6376|  17.0k|            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
  ------------------
  |  Branch (6376:58): [True: 2, False: 17.0k]
  |  Branch (6376:93): [True: 78, False: 16.9k]
  ------------------
 6377|  33.8k|    }
 6378|       |
 6379|  16.9k|    int resize_border_mask = 0x00;
 6380|  16.9k|    if (window->Flags & ImGuiWindowFlags_ChildWindow)
  ------------------
  |  Branch (6380:9): [True: 0, False: 16.9k]
  ------------------
 6381|      0|        resize_border_mask |= ((window->ChildFlags & ImGuiChildFlags_ResizeX) ? 0x02 : 0) | ((window->ChildFlags & ImGuiChildFlags_ResizeY) ? 0x08 : 0);
  ------------------
  |  Branch (6381:32): [True: 0, False: 0]
  |  Branch (6381:94): [True: 0, False: 0]
  ------------------
 6382|  16.9k|    else
 6383|  16.9k|        resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00;
  ------------------
  |  Branch (6383:30): [True: 16.9k, False: 0]
  ------------------
 6384|  84.7k|    for (int border_n = 0; border_n < 4; border_n++)
  ------------------
  |  Branch (6384:28): [True: 67.7k, False: 16.9k]
  ------------------
 6385|  67.7k|    {
 6386|  67.7k|        if ((resize_border_mask & (1 << border_n)) == 0)
  ------------------
  |  Branch (6386:13): [True: 0, False: 67.7k]
  ------------------
 6387|      0|            continue;
 6388|  67.7k|        const ImGuiResizeBorderDef& def = resize_border_def[border_n];
 6389|  67.7k|        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;
  ------------------
  |  Branch (6389:33): [True: 16.9k, False: 50.8k]
  |  Branch (6389:62): [True: 16.9k, False: 33.8k]
  ------------------
 6390|       |
 6391|  67.7k|        bool hovered, held;
 6392|  67.7k|        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
 6393|  67.7k|        ImGuiID border_id = window->GetID(border_n + 4); // == GetWindowResizeBorderID()
 6394|  67.7k|        ItemAdd(border_rect, border_id, NULL, ImGuiItemFlags_NoNav);
 6395|  67.7k|        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
 6396|       |        //GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
 6397|  67.7k|        if (hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER)
  ------------------
  |  Branch (6397:13): [True: 37, False: 67.7k]
  |  Branch (6397:24): [True: 21, False: 16]
  ------------------
 6398|     21|            hovered = false;
 6399|  67.7k|        if (hovered || held)
  ------------------
  |  Branch (6399:13): [True: 16, False: 67.7k]
  |  Branch (6399:24): [True: 2, False: 67.7k]
  ------------------
 6400|     18|            g.MouseCursor = (axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
  ------------------
  |  Branch (6400:29): [True: 13, False: 5]
  ------------------
 6401|  67.7k|        if (held && g.IO.MouseDoubleClicked[0])
  ------------------
  |  Branch (6401:13): [True: 2, False: 67.7k]
  |  Branch (6401:21): [True: 0, False: 2]
  ------------------
 6402|      0|        {
 6403|       |            // Double-clicking bottom or right border auto-fit on this axis
 6404|       |            // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one side may be auto-fit when calculating scrollbars.
 6405|       |            // FIXME: Support top and right borders: rework CalcResizePosSizeFromAnyCorner() to be reusable in both cases.
 6406|      0|            if (border_n == 1 || border_n == 3) // Right and bottom border
  ------------------
  |  Branch (6406:17): [True: 0, False: 0]
  |  Branch (6406:34): [True: 0, False: 0]
  ------------------
 6407|      0|            {
 6408|      0|                size_target[axis] = CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis];
 6409|      0|                ret_auto_fit_mask |= (1 << axis);
 6410|      0|                hovered = held = false; // So border doesn't show highlighted at new position
 6411|      0|            }
 6412|      0|            ClearActiveID();
 6413|      0|        }
 6414|  67.7k|        else if (held)
  ------------------
  |  Branch (6414:18): [True: 2, False: 67.7k]
  ------------------
 6415|      2|        {
 6416|       |            // Switch to relative resizing mode when border geometry moved (e.g. resizing a child altering parent scroll), in order to avoid resizing feedback loop.
 6417|       |            // Currently only using relative mode on resizable child windows, as the problem to solve is more likely noticeable for them, but could apply for all windows eventually.
 6418|       |            // FIXME: May want to generalize this idiom at lower-level, so more widgets can use it!
 6419|      2|            const bool just_scrolled_manually_while_resizing = (g.WheelingWindow != NULL && g.WheelingWindowScrolledFrame == g.FrameCount && IsWindowChildOf(window, g.WheelingWindow, false, true));
  ------------------
  |  Branch (6419:65): [True: 0, False: 2]
  |  Branch (6419:93): [True: 0, False: 0]
  |  Branch (6419:142): [True: 0, False: 0]
  ------------------
 6420|      2|            if (g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing)
  ------------------
  |  Branch (6420:17): [True: 1, False: 1]
  |  Branch (6420:46): [True: 0, False: 1]
  ------------------
 6421|      1|            {
 6422|      1|                g.WindowResizeBorderExpectedRect = border_rect;
 6423|      1|                g.WindowResizeRelativeMode = false;
 6424|      1|            }
 6425|      2|            if ((window->Flags & ImGuiWindowFlags_ChildWindow) && memcmp(&g.WindowResizeBorderExpectedRect, &border_rect, sizeof(ImRect)) != 0)
  ------------------
  |  Branch (6425:17): [True: 0, False: 2]
  |  Branch (6425:67): [True: 0, False: 0]
  ------------------
 6426|      0|                g.WindowResizeRelativeMode = true;
 6427|       |
 6428|      2|            const ImVec2 border_curr = (window->Pos + ImMin(def.SegmentN1, def.SegmentN2) * window->Size);
 6429|      2|            const float border_target_rel_mode_for_axis = border_curr[axis] + g.IO.MouseDelta[axis];
 6430|      2|            const float border_target_abs_mode_for_axis = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.
 6431|       |
 6432|       |            // Use absolute mode position
 6433|      2|            ImVec2 border_target = window->Pos;
 6434|      2|            border_target[axis] = border_target_abs_mode_for_axis;
 6435|       |
 6436|       |            // Use relative mode target for child window, ignore resize when moving back toward the ideal absolute position.
 6437|      2|            bool ignore_resize = false;
 6438|      2|            if (g.WindowResizeRelativeMode)
  ------------------
  |  Branch (6438:17): [True: 0, False: 2]
  ------------------
 6439|      0|            {
 6440|       |                //GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos, IM_COL32_WHITE, "Relative Mode");
 6441|      0|                border_target[axis] = border_target_rel_mode_for_axis;
 6442|      0|                if (g.IO.MouseDelta[axis] == 0.0f || (g.IO.MouseDelta[axis] > 0.0f) == (border_target_rel_mode_for_axis > border_target_abs_mode_for_axis))
  ------------------
  |  Branch (6442:21): [True: 0, False: 0]
  |  Branch (6442:54): [True: 0, False: 0]
  ------------------
 6443|      0|                    ignore_resize = true;
 6444|      0|            }
 6445|       |
 6446|       |            // Clamp, apply
 6447|      2|            ImVec2 clamp_min(border_n == ImGuiDir_Right ? clamp_rect.Min.x : -FLT_MAX, border_n == ImGuiDir_Down || (border_n == ImGuiDir_Up && window_move_from_title_bar) ? clamp_rect.Min.y : -FLT_MAX);
  ------------------
  |  Branch (6447:30): [True: 2, False: 0]
  |  Branch (6447:88): [True: 0, False: 2]
  |  Branch (6447:118): [True: 0, False: 2]
  |  Branch (6447:145): [True: 0, False: 0]
  ------------------
 6448|      2|            ImVec2 clamp_max(border_n == ImGuiDir_Left ? clamp_rect.Max.x : +FLT_MAX, border_n == ImGuiDir_Up ? clamp_rect.Max.y : +FLT_MAX);
  ------------------
  |  Branch (6448:30): [True: 0, False: 2]
  |  Branch (6448:87): [True: 0, False: 2]
  ------------------
 6449|      2|            border_target = ImClamp(border_target, clamp_min, clamp_max);
 6450|      2|            if (flags & ImGuiWindowFlags_ChildWindow) // Clamp resizing of childs within parent
  ------------------
  |  Branch (6450:17): [True: 0, False: 2]
  ------------------
 6451|      0|            {
 6452|      0|                ImGuiWindow* parent_window = window->ParentWindow;
 6453|      0|                ImGuiWindowFlags parent_flags = parent_window->Flags;
 6454|      0|                ImRect border_limit_rect = parent_window->InnerRect;
 6455|      0|                border_limit_rect.Expand(ImVec2(-ImMax(parent_window->WindowPadding.x, parent_window->WindowBorderSize), -ImMax(parent_window->WindowPadding.y, parent_window->WindowBorderSize)));
 6456|      0|                if ((axis == ImGuiAxis_X) && ((parent_flags & (ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar)) == 0 || (parent_flags & ImGuiWindowFlags_NoScrollbar)))
  ------------------
  |  Branch (6456:21): [True: 0, False: 0]
  |  Branch (6456:47): [True: 0, False: 0]
  |  Branch (6456:156): [True: 0, False: 0]
  ------------------
 6457|      0|                    border_target.x = ImClamp(border_target.x, border_limit_rect.Min.x, border_limit_rect.Max.x);
 6458|      0|                if ((axis == ImGuiAxis_Y) && (parent_flags & ImGuiWindowFlags_NoScrollbar))
  ------------------
  |  Branch (6458:21): [True: 0, False: 0]
  |  Branch (6458:46): [True: 0, False: 0]
  ------------------
 6459|      0|                    border_target.y = ImClamp(border_target.y, border_limit_rect.Min.y, border_limit_rect.Max.y);
 6460|      0|            }
 6461|      2|            if (!ignore_resize)
  ------------------
  |  Branch (6461:17): [True: 2, False: 0]
  ------------------
 6462|      2|                CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
 6463|      2|        }
 6464|  67.7k|        if (hovered)
  ------------------
  |  Branch (6464:13): [True: 16, False: 67.7k]
  ------------------
 6465|     16|            *border_hovered = border_n;
 6466|  67.7k|        if (held)
  ------------------
  |  Branch (6466:13): [True: 2, False: 67.7k]
  ------------------
 6467|      2|            *border_held = border_n;
 6468|  67.7k|    }
 6469|  16.9k|    PopID();
 6470|       |
 6471|       |    // Restore nav layer
 6472|  16.9k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 6473|       |
 6474|       |    // Navigation resize (keyboard/gamepad)
 6475|       |    // FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
 6476|       |    // Not even sure the callback works here.
 6477|  16.9k|    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindowDockTree == window)
  ------------------
  |  Branch (6477:9): [True: 0, False: 16.9k]
  |  Branch (6477:33): [True: 0, False: 0]
  ------------------
 6478|      0|    {
 6479|      0|        ImVec2 nav_resize_dir;
 6480|      0|        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
  ------------------
  |  Branch (6480:13): [True: 0, False: 0]
  |  Branch (6480:62): [True: 0, False: 0]
  ------------------
 6481|      0|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
 6482|      0|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (6482:13): [True: 0, False: 0]
  ------------------
 6483|      0|            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);
 6484|      0|        if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f)
  ------------------
  |  Branch (6484:13): [True: 0, False: 0]
  |  Branch (6484:41): [True: 0, False: 0]
  ------------------
 6485|      0|        {
 6486|      0|            const float NAV_RESIZE_SPEED = 600.0f;
 6487|      0|            const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
 6488|      0|            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
 6489|      0|            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window->Pos - window->Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window->Pos - window->Size
 6490|      0|            g.NavWindowingToggleLayer = false;
 6491|      0|            g.NavDisableMouseHover = true;
 6492|      0|            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
 6493|      0|            ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaSize);
 6494|      0|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (6494:17): [True: 0, False: 0]
  |  Branch (6494:44): [True: 0, False: 0]
  ------------------
 6495|      0|            {
 6496|       |                // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
 6497|      0|                size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);
 6498|      0|                g.NavWindowingAccumDeltaSize -= accum_floored;
 6499|      0|            }
 6500|      0|        }
 6501|      0|    }
 6502|       |
 6503|       |    // Apply back modified position/size to window
 6504|  16.9k|    const ImVec2 curr_pos = window->Pos;
 6505|  16.9k|    const ImVec2 curr_size = window->SizeFull;
 6506|  16.9k|    if (size_target.x != FLT_MAX && (window->Size.x != size_target.x || window->SizeFull.x != size_target.x))
  ------------------
  |  Branch (6506:9): [True: 4, False: 16.9k]
  |  Branch (6506:38): [True: 0, False: 4]
  |  Branch (6506:73): [True: 0, False: 4]
  ------------------
 6507|      0|        window->Size.x = window->SizeFull.x = size_target.x;
 6508|  16.9k|    if (size_target.y != FLT_MAX && (window->Size.y != size_target.y || window->SizeFull.y != size_target.y))
  ------------------
  |  Branch (6508:9): [True: 4, False: 16.9k]
  |  Branch (6508:38): [True: 0, False: 4]
  |  Branch (6508:73): [True: 0, False: 4]
  ------------------
 6509|      0|        window->Size.y = window->SizeFull.y = size_target.y;
 6510|  16.9k|    if (pos_target.x != FLT_MAX && window->Pos.x != ImTrunc(pos_target.x))
  ------------------
  |  Branch (6510:9): [True: 4, False: 16.9k]
  |  Branch (6510:36): [True: 0, False: 4]
  ------------------
 6511|      0|        window->Pos.x = ImTrunc(pos_target.x);
 6512|  16.9k|    if (pos_target.y != FLT_MAX && window->Pos.y != ImTrunc(pos_target.y))
  ------------------
  |  Branch (6512:9): [True: 4, False: 16.9k]
  |  Branch (6512:36): [True: 0, False: 4]
  ------------------
 6513|      0|        window->Pos.y = ImTrunc(pos_target.y);
 6514|  16.9k|    if (curr_pos.x != window->Pos.x || curr_pos.y != window->Pos.y || curr_size.x != window->SizeFull.x || curr_size.y != window->SizeFull.y)
  ------------------
  |  Branch (6514:9): [True: 0, False: 16.9k]
  |  Branch (6514:40): [True: 0, False: 16.9k]
  |  Branch (6514:71): [True: 0, False: 16.9k]
  |  Branch (6514:108): [True: 0, False: 16.9k]
  ------------------
 6515|      0|        MarkIniSettingsDirty(window);
 6516|       |
 6517|       |    // Recalculate next expected border expected coordinates
 6518|  16.9k|    if (*border_held != -1)
  ------------------
  |  Branch (6518:9): [True: 2, False: 16.9k]
  ------------------
 6519|      2|        g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, *border_held, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
 6520|       |
 6521|  16.9k|    return ret_auto_fit_mask;
 6522|  93.6k|}
imgui.cpp:_ZL30CalcResizePosSizeFromAnyCornerP11ImGuiWindowRK6ImVec2S3_PS1_S4_:
 6222|      4|{
 6223|      4|    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
 6224|      4|    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
 6225|      4|    ImVec2 size_expected = pos_max - pos_min;
 6226|      4|    ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
 6227|      4|    *out_pos = pos_min;
 6228|      4|    if (corner_norm.x == 0.0f)
  ------------------
  |  Branch (6228:9): [True: 2, False: 2]
  ------------------
 6229|      2|        out_pos->x -= (size_constrained.x - size_expected.x);
 6230|      4|    if (corner_norm.y == 0.0f)
  ------------------
  |  Branch (6230:9): [True: 2, False: 2]
  ------------------
 6231|      2|        out_pos->y -= (size_constrained.y - size_expected.y);
 6232|      4|    *out_size = size_constrained;
 6233|      4|}
imgui.cpp:_ZL19GetResizeBorderRectP11ImGuiWindowiff:
 6266|  67.8k|{
 6267|  67.8k|    ImRect rect = window->Rect();
 6268|  67.8k|    if (thickness == 0.0f)
  ------------------
  |  Branch (6268:9): [True: 18, False: 67.7k]
  ------------------
 6269|     18|        rect.Max -= ImVec2(1, 1);
 6270|  67.8k|    if (border_n == ImGuiDir_Left)  { return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding); }
  ------------------
  |  Branch (6270:9): [True: 16.9k, False: 50.8k]
  ------------------
 6271|  50.8k|    if (border_n == ImGuiDir_Right) { return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding); }
  ------------------
  |  Branch (6271:9): [True: 16.9k, False: 33.8k]
  ------------------
 6272|  33.8k|    if (border_n == ImGuiDir_Up)    { return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);    }
  ------------------
  |  Branch (6272:9): [True: 16.9k, False: 16.9k]
  ------------------
 6273|  16.9k|    if (border_n == ImGuiDir_Down)  { return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);    }
  ------------------
  |  Branch (6273:9): [True: 16.9k, False: 0]
  ------------------
 6274|      0|    IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6275|      0|    return ImRect();
 6276|  16.9k|}
imgui.cpp:_ZN5ImGuiL23RenderWindowDecorationsEP11ImGuiWindowRK6ImRectbbiPKjf:
 6575|   170k|{
 6576|   170k|    ImGuiContext& g = *GImGui;
 6577|   170k|    ImGuiStyle& style = g.Style;
 6578|   170k|    ImGuiWindowFlags flags = window->Flags;
 6579|       |
 6580|       |    // Ensure that ScrollBar doesn't read last frame's SkipItems
 6581|   170k|    IM_ASSERT(window->BeginCount == 0);
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 6582|   170k|    window->SkipItems = false;
 6583|       |
 6584|       |    // Draw window + handle manual resize
 6585|       |    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
 6586|   170k|    const float window_rounding = window->WindowRounding;
 6587|   170k|    const float window_border_size = window->WindowBorderSize;
 6588|   170k|    if (window->Collapsed)
  ------------------
  |  Branch (6588:9): [True: 59.7k, False: 110k]
  ------------------
 6589|  59.7k|    {
 6590|       |        // Title bar only
 6591|  59.7k|        const float backup_border_size = style.FrameBorderSize;
 6592|  59.7k|        g.Style.FrameBorderSize = window->WindowBorderSize;
 6593|  59.7k|        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
  ------------------
  |  Branch (6593:44): [True: 381, False: 59.3k]
  |  Branch (6593:70): [True: 1, False: 380]
  ------------------
 6594|  59.7k|        if (window->ViewportOwned)
  ------------------
  |  Branch (6594:13): [True: 0, False: 59.7k]
  ------------------
 6595|      0|            title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
  ------------------
  |  | 2750|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6596|  59.7k|        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
 6597|  59.7k|        g.Style.FrameBorderSize = backup_border_size;
 6598|  59.7k|    }
 6599|   110k|    else
 6600|   110k|    {
 6601|       |        // Window background
 6602|   110k|        if (!(flags & ImGuiWindowFlags_NoBackground))
  ------------------
  |  Branch (6602:13): [True: 110k, False: 0]
  ------------------
 6603|   110k|        {
 6604|   110k|            bool is_docking_transparent_payload = false;
 6605|   110k|            if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload)
  ------------------
  |  Branch (6605:17): [True: 482, False: 110k]
  |  Branch (6605:37): [True: 1, False: 481]
  |  Branch (6605:89): [True: 0, False: 1]
  ------------------
 6606|      0|                if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && *(ImGuiWindow**)g.DragDropPayload.Data == window)
  ------------------
  |  |  227|      0|#define IMGUI_PAYLOAD_TYPE_WINDOW       "_IMWINDOW"     // Payload == ImGuiWindow*
  ------------------
  |  Branch (6606:21): [True: 0, False: 0]
  |  Branch (6606:80): [True: 0, False: 0]
  ------------------
 6607|      0|                    is_docking_transparent_payload = true;
 6608|       |
 6609|   110k|            ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
 6610|   110k|            if (window->ViewportOwned)
  ------------------
  |  Branch (6610:17): [True: 0, False: 110k]
  ------------------
 6611|      0|            {
 6612|      0|                bg_col |= IM_COL32_A_MASK; // No alpha
  ------------------
  |  | 2750|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6613|      0|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6613:21): [True: 0, False: 0]
  ------------------
 6614|      0|                    window->Viewport->Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
 6615|      0|            }
 6616|   110k|            else
 6617|   110k|            {
 6618|       |                // Adjust alpha. For docking
 6619|   110k|                bool override_alpha = false;
 6620|   110k|                float alpha = 1.0f;
 6621|   110k|                if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
  ------------------
  |  Branch (6621:21): [True: 0, False: 110k]
  ------------------
 6622|      0|                {
 6623|      0|                    alpha = g.NextWindowData.BgAlphaVal;
 6624|      0|                    override_alpha = true;
 6625|      0|                }
 6626|   110k|                if (is_docking_transparent_payload)
  ------------------
  |  Branch (6626:21): [True: 0, False: 110k]
  ------------------
 6627|      0|                {
 6628|      0|                    alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
 6629|      0|                    override_alpha = true;
 6630|      0|                }
 6631|   110k|                if (override_alpha)
  ------------------
  |  Branch (6631:21): [True: 0, False: 110k]
  ------------------
 6632|      0|                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2750|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  |  286|      0|#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
  ------------------
                                  bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
  ------------------
  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  ------------------
 6633|   110k|            }
 6634|       |
 6635|       |            // Render, for docked windows and host windows we ensure bg goes before decorations
 6636|   110k|            if (window->DockIsActive)
  ------------------
  |  Branch (6636:17): [True: 0, False: 110k]
  ------------------
 6637|      0|                window->DockNode->LastBgColor = bg_col;
 6638|   110k|            ImDrawList* bg_draw_list = window->DockIsActive ? window->DockNode->HostWindow->DrawList : window->DrawList;
  ------------------
  |  Branch (6638:40): [True: 0, False: 110k]
  ------------------
 6639|   110k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6639:17): [True: 0, False: 110k]
  |  Branch (6639:41): [True: 0, False: 110k]
  ------------------
 6640|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
  ------------------
  |  | 1746|      0|#define DOCKING_HOST_DRAW_CHANNEL_BG 0  // Dock host: background fill
  ------------------
 6641|   110k|            bg_draw_list->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
  ------------------
  |  Branch (6641:143): [True: 16.9k, False: 93.6k]
  ------------------
 6642|   110k|            if (window->DockIsActive || (flags & ImGuiWindowFlags_DockNodeHost))
  ------------------
  |  Branch (6642:17): [True: 0, False: 110k]
  |  Branch (6642:41): [True: 0, False: 110k]
  ------------------
 6643|      0|                bg_draw_list->ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
  ------------------
  |  | 1747|      0|#define DOCKING_HOST_DRAW_CHANNEL_FG 1  // Dock host: decorations and contents
  ------------------
 6644|   110k|        }
 6645|   110k|        if (window->DockIsActive)
  ------------------
  |  Branch (6645:13): [True: 0, False: 110k]
  ------------------
 6646|      0|            window->DockNode->IsBgDrawnThisFrame = true;
 6647|       |
 6648|       |        // Title bar
 6649|       |        // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
 6650|       |        // in order for their pos/size to be matching their undocking state.)
 6651|   110k|        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6651:13): [True: 93.6k, False: 16.9k]
  |  Branch (6651:55): [True: 93.6k, False: 0]
  ------------------
 6652|  93.6k|        {
 6653|  93.6k|            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
  ------------------
  |  Branch (6653:47): [True: 7.19k, False: 86.4k]
  ------------------
 6654|  93.6k|            if (window->ViewportOwned)
  ------------------
  |  Branch (6654:17): [True: 0, False: 93.6k]
  ------------------
 6655|      0|                title_bar_col |= IM_COL32_A_MASK; // No alpha
  ------------------
  |  | 2750|      0|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 6656|  93.6k|            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
 6657|  93.6k|        }
 6658|       |
 6659|       |        // Menu bar
 6660|   110k|        if (flags & ImGuiWindowFlags_MenuBar)
  ------------------
  |  Branch (6660:13): [True: 0, False: 110k]
  ------------------
 6661|      0|        {
 6662|      0|            ImRect menu_bar_rect = window->MenuBarRect();
 6663|      0|            menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
 6664|      0|            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
  ------------------
  |  Branch (6664:180): [True: 0, False: 0]
  ------------------
 6665|      0|            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
  ------------------
  |  Branch (6665:17): [True: 0, False: 0]
  |  Branch (6665:49): [True: 0, False: 0]
  ------------------
 6666|      0|                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
 6667|      0|        }
 6668|       |
 6669|       |        // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
 6670|   110k|        ImGuiDockNode* node = window->DockNode;
 6671|   110k|        if (window->DockIsActive && node->IsHiddenTabBar() && !node->IsNoTabBar())
  ------------------
  |  Branch (6671:13): [True: 0, False: 110k]
  |  Branch (6671:37): [True: 0, False: 0]
  |  Branch (6671:63): [True: 0, False: 0]
  ------------------
 6672|      0|        {
 6673|      0|            float unhide_sz_draw = ImTrunc(g.FontSize * 0.70f);
 6674|      0|            float unhide_sz_hit = ImTrunc(g.FontSize * 0.55f);
 6675|      0|            ImVec2 p = node->Pos;
 6676|      0|            ImRect r(p, p + ImVec2(unhide_sz_hit, unhide_sz_hit));
 6677|      0|            ImGuiID unhide_id = window->GetID("#UNHIDE");
 6678|      0|            KeepAliveID(unhide_id);
 6679|      0|            bool hovered, held;
 6680|      0|            if (ButtonBehavior(r, unhide_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren))
  ------------------
  |  Branch (6680:17): [True: 0, False: 0]
  ------------------
 6681|      0|                node->WantHiddenTabBarToggle = true;
 6682|      0|            else if (held && IsMouseDragging(0))
  ------------------
  |  Branch (6682:22): [True: 0, False: 0]
  |  Branch (6682:30): [True: 0, False: 0]
  ------------------
 6683|      0|                StartMouseMovingWindowOrNode(window, node, true); // Undock from tab-bar triangle = same as window/collapse menu button
 6684|       |
 6685|       |            // FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
 6686|      0|            ImU32 col = GetColorU32(((held && hovered) || (node->IsFocused && !hovered)) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (6686:39): [True: 0, False: 0]
  |  Branch (6686:47): [True: 0, False: 0]
  |  Branch (6686:60): [True: 0, False: 0]
  |  Branch (6686:79): [True: 0, False: 0]
  |  Branch (6686:116): [True: 0, False: 0]
  ------------------
 6687|      0|            window->DrawList->AddTriangleFilled(p, p + ImVec2(unhide_sz_draw, 0.0f), p + ImVec2(0.0f, unhide_sz_draw), col);
 6688|      0|        }
 6689|       |
 6690|       |        // Scrollbars
 6691|   110k|        if (window->ScrollbarX)
  ------------------
  |  Branch (6691:13): [True: 16.9k, False: 93.6k]
  ------------------
 6692|  16.9k|            Scrollbar(ImGuiAxis_X);
 6693|   110k|        if (window->ScrollbarY)
  ------------------
  |  Branch (6693:13): [True: 17.6k, False: 92.9k]
  ------------------
 6694|  17.6k|            Scrollbar(ImGuiAxis_Y);
 6695|       |
 6696|       |        // Render resize grips (after their input handling so we don't have a frame of latency)
 6697|   110k|        if (handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_NoResize))
  ------------------
  |  Branch (6697:13): [True: 110k, False: 0]
  |  Branch (6697:48): [True: 93.6k, False: 16.9k]
  ------------------
 6698|  93.6k|        {
 6699|   280k|            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
  ------------------
  |  Branch (6699:41): [True: 187k, False: 93.6k]
  ------------------
 6700|   187k|            {
 6701|   187k|                const ImU32 col = resize_grip_col[resize_grip_n];
 6702|   187k|                if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|   187k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (6702:21): [True: 170k, False: 17.0k]
  ------------------
 6703|   170k|                    continue;
 6704|  17.0k|                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
 6705|  17.0k|                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
 6706|  17.0k|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
  ------------------
  |  Branch (6706:72): [True: 79, False: 16.9k]
  ------------------
 6707|  17.0k|                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
  ------------------
  |  Branch (6707:72): [True: 79, False: 16.9k]
  ------------------
 6708|  17.0k|                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
 6709|  17.0k|                window->DrawList->PathFillConvex(col);
 6710|  17.0k|            }
 6711|  93.6k|        }
 6712|       |
 6713|       |        // Borders (for dock node host they will be rendered over after the tab bar)
 6714|   110k|        if (handle_borders_and_resize_grips && !window->DockNodeAsHost)
  ------------------
  |  Branch (6714:13): [True: 110k, False: 0]
  |  Branch (6714:48): [True: 110k, False: 0]
  ------------------
 6715|   110k|            RenderWindowOuterBorders(window);
 6716|   110k|    }
 6717|   170k|}
imgui.cpp:_ZL19GetWindowBgColorIdxP11ImGuiWindow:
 6213|   110k|{
 6214|   110k|    if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (6214:9): [True: 0, False: 110k]
  ------------------
 6215|      0|        return ImGuiCol_PopupBg;
 6216|   110k|    if ((window->Flags & ImGuiWindowFlags_ChildWindow) && !window->DockIsActive)
  ------------------
  |  Branch (6216:9): [True: 16.9k, False: 93.6k]
  |  Branch (6216:59): [True: 16.9k, False: 0]
  ------------------
 6217|  16.9k|        return ImGuiCol_ChildBg;
 6218|  93.6k|    return ImGuiCol_WindowBg;
 6219|   110k|}
imgui.cpp:_ZN5ImGuiL24RenderWindowOuterBordersEP11ImGuiWindow:
 6546|   110k|{
 6547|   110k|    ImGuiContext& g = *GImGui;
 6548|   110k|    const float border_size = window->WindowBorderSize;
 6549|   110k|    const ImU32 border_col = GetColorU32(ImGuiCol_Border);
 6550|   110k|    if (border_size > 0.0f && (window->Flags & ImGuiWindowFlags_NoBackground) == 0)
  ------------------
  |  Branch (6550:9): [True: 102k, False: 7.83k]
  |  Branch (6550:31): [True: 102k, False: 0]
  ------------------
 6551|   102k|        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, border_col, window->WindowRounding, 0, window->WindowBorderSize);
 6552|  7.83k|    else if (border_size > 0.0f)
  ------------------
  |  Branch (6552:14): [True: 0, False: 7.83k]
  ------------------
 6553|      0|    {
 6554|      0|        if (window->ChildFlags & ImGuiChildFlags_ResizeX) // Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.
  ------------------
  |  Branch (6554:13): [True: 0, False: 0]
  ------------------
 6555|      0|            RenderWindowOuterSingleBorder(window, 1, border_col, border_size);
 6556|      0|        if (window->ChildFlags & ImGuiChildFlags_ResizeY)
  ------------------
  |  Branch (6556:13): [True: 0, False: 0]
  ------------------
 6557|      0|            RenderWindowOuterSingleBorder(window, 3, border_col, border_size);
 6558|      0|    }
 6559|   110k|    if (window->ResizeBorderHovered != -1 || window->ResizeBorderHeld != -1)
  ------------------
  |  Branch (6559:9): [True: 16, False: 110k]
  |  Branch (6559:46): [True: 2, False: 110k]
  ------------------
 6560|     18|    {
 6561|     18|        const int border_n = (window->ResizeBorderHeld != -1) ? window->ResizeBorderHeld : window->ResizeBorderHovered;
  ------------------
  |  Branch (6561:30): [True: 2, False: 16]
  ------------------
 6562|     18|        const ImU32 border_col_resizing = GetColorU32((window->ResizeBorderHeld != -1) ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
  ------------------
  |  Branch (6562:55): [True: 2, False: 16]
  ------------------
 6563|     18|        RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0f, window->WindowBorderSize)); // Thicker than usual
 6564|     18|    }
 6565|   110k|    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar) && !window->DockIsActive)
  ------------------
  |  Branch (6565:9): [True: 0, False: 110k]
  |  Branch (6565:40): [True: 0, False: 0]
  |  Branch (6565:90): [True: 0, False: 0]
  ------------------
 6566|      0|    {
 6567|      0|        float y = window->Pos.y + window->TitleBarHeight - 1;
 6568|      0|        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), border_col, g.Style.FrameBorderSize);
 6569|      0|    }
 6570|   110k|}
imgui.cpp:_ZL29RenderWindowOuterSingleBorderP11ImGuiWindowijf:
 6536|     18|{
 6537|     18|    const ImGuiResizeBorderDef& def = resize_border_def[border_n];
 6538|     18|    const float rounding = window->WindowRounding;
 6539|     18|    const ImRect border_r = GetResizeBorderRect(window, border_n, rounding, 0.0f);
 6540|     18|    window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
  ------------------
  |  |  275|     18|#define IM_PI                           3.14159265358979323846f
  ------------------
 6541|     18|    window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
  ------------------
  |  |  275|     18|#define IM_PI                           3.14159265358979323846f
  ------------------
 6542|     18|    window->DrawList->PathStroke(border_col, ImDrawFlags_None, border_size);
 6543|     18|}
imgui.cpp:_ZN5ImGuiL28RenderWindowTitleBarContentsEP11ImGuiWindowRK6ImRectPKcPb:
 6722|   153k|{
 6723|   153k|    ImGuiContext& g = *GImGui;
 6724|   153k|    ImGuiStyle& style = g.Style;
 6725|   153k|    ImGuiWindowFlags flags = window->Flags;
 6726|       |
 6727|   153k|    const bool has_close_button = (p_open != NULL);
 6728|   153k|    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);
  ------------------
  |  Branch (6728:38): [True: 153k, False: 0]
  |  Branch (6728:80): [True: 153k, False: 0]
  ------------------
 6729|       |
 6730|       |    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
 6731|       |    // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
 6732|   153k|    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
 6733|   153k|    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
 6734|   153k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;
 6735|       |
 6736|       |    // Layout buttons
 6737|       |    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
 6738|   153k|    float pad_l = style.FramePadding.x;
 6739|   153k|    float pad_r = style.FramePadding.x;
 6740|   153k|    float button_sz = g.FontSize;
 6741|   153k|    ImVec2 close_button_pos;
 6742|   153k|    ImVec2 collapse_button_pos;
 6743|   153k|    if (has_close_button)
  ------------------
  |  Branch (6743:9): [True: 0, False: 153k]
  ------------------
 6744|      0|    {
 6745|      0|        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
 6746|      0|        pad_r += button_sz + style.ItemInnerSpacing.x;
 6747|      0|    }
 6748|   153k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
  ------------------
  |  Branch (6748:9): [True: 153k, False: 0]
  |  Branch (6748:32): [True: 0, False: 153k]
  ------------------
 6749|      0|    {
 6750|      0|        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y);
 6751|      0|        pad_r += button_sz + style.ItemInnerSpacing.x;
 6752|      0|    }
 6753|   153k|    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
  ------------------
  |  Branch (6753:9): [True: 153k, False: 0]
  |  Branch (6753:32): [True: 153k, False: 0]
  ------------------
 6754|   153k|    {
 6755|   153k|        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y);
 6756|   153k|        pad_l += button_sz + style.ItemInnerSpacing.x;
 6757|   153k|    }
 6758|       |
 6759|       |    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
 6760|   153k|    if (has_collapse_button)
  ------------------
  |  Branch (6760:9): [True: 153k, False: 0]
  ------------------
 6761|   153k|        if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos, NULL))
  ------------------
  |  Branch (6761:13): [True: 1, False: 153k]
  ------------------
 6762|      1|            window->WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
 6763|       |
 6764|       |    // Close button
 6765|   153k|    if (has_close_button)
  ------------------
  |  Branch (6765:9): [True: 0, False: 153k]
  ------------------
 6766|      0|        if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
  ------------------
  |  Branch (6766:13): [True: 0, False: 0]
  ------------------
 6767|      0|            *p_open = false;
 6768|       |
 6769|   153k|    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
 6770|   153k|    g.CurrentItemFlags = item_flags_backup;
 6771|       |
 6772|       |    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
 6773|       |    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
 6774|   153k|    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
  ------------------
  |  Branch (6774:33): [True: 0, False: 153k]
  ------------------
 6775|   153k|    const ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);
 6776|       |
 6777|       |    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
 6778|       |    // while uncentered title text will still reach edges correctly.
 6779|   153k|    if (pad_l > style.FramePadding.x)
  ------------------
  |  Branch (6779:9): [True: 153k, False: 0]
  ------------------
 6780|   153k|        pad_l += g.Style.ItemInnerSpacing.x;
 6781|   153k|    if (pad_r > style.FramePadding.x)
  ------------------
  |  Branch (6781:9): [True: 0, False: 153k]
  ------------------
 6782|      0|        pad_r += g.Style.ItemInnerSpacing.x;
 6783|   153k|    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
  ------------------
  |  Branch (6783:9): [True: 0, False: 153k]
  |  Branch (6783:44): [True: 0, False: 0]
  ------------------
 6784|      0|    {
 6785|      0|        float centerness = ImSaturate(1.0f - ImFabs(style.WindowTitleAlign.x - 0.5f) * 2.0f); // 0.0f on either edges, 1.0f on center
  ------------------
  |  |  451|      0|#define ImFabs(X)           fabsf(X)
  ------------------
 6786|      0|        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
 6787|      0|        pad_l = ImMax(pad_l, pad_extend * centerness);
 6788|      0|        pad_r = ImMax(pad_r, pad_extend * centerness);
 6789|      0|    }
 6790|       |
 6791|   153k|    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
 6792|   153k|    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
 6793|   153k|    if (flags & ImGuiWindowFlags_UnsavedDocument)
  ------------------
  |  Branch (6793:9): [True: 0, False: 153k]
  ------------------
 6794|      0|    {
 6795|      0|        ImVec2 marker_pos;
 6796|      0|        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
 6797|      0|        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
 6798|      0|        if (marker_pos.x > layout_r.Min.x)
  ------------------
  |  Branch (6798:13): [True: 0, False: 0]
  ------------------
 6799|      0|        {
 6800|      0|            RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
 6801|      0|            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
 6802|      0|        }
 6803|      0|    }
 6804|       |    //if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6805|       |    //if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
 6806|   153k|    RenderTextClipped(layout_r.Min, layout_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_r);
 6807|   153k|}
imgui.cpp:_ZN5ImGuiL24SetLastItemDataForWindowEP11ImGuiWindowRK6ImRect:
 7814|   170k|{
 7815|   170k|    ImGuiContext& g = *GImGui;
 7816|   170k|    if (window->DockIsActive)
  ------------------
  |  Branch (7816:9): [True: 0, False: 170k]
  ------------------
 7817|      0|        SetLastItemData(window->MoveId, g.CurrentItemFlags, window->DockTabItemStatusFlags, window->DockTabItemRect);
 7818|   170k|    else
 7819|   170k|        SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, rect);
  ------------------
  |  Branch (7819:61): [True: 3.06k, False: 167k]
  ------------------
 7820|   170k|}
imgui.cpp:_ZN5ImGuiL20UpdateKeyboardInputsEv:
 9768|  76.6k|{
 9769|  76.6k|    ImGuiContext& g = *GImGui;
 9770|  76.6k|    ImGuiIO& io = g.IO;
 9771|       |
 9772|  76.6k|    if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)
  ------------------
  |  Branch (9772:9): [True: 0, False: 76.6k]
  ------------------
 9773|      0|        io.ClearInputKeys();
 9774|       |
 9775|       |    // Import legacy keys or verify they are not used
 9776|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9777|       |    if (io.BackendUsingLegacyKeyArrays == 0)
 9778|       |    {
 9779|       |        // Backend used new io.AddKeyEvent() API: Good! Verify that old arrays are never written to externally.
 9780|       |        for (int n = 0; n < ImGuiKey_LegacyNativeKey_END; n++)
 9781|       |            IM_ASSERT((io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!");
 9782|       |    }
 9783|       |    else
 9784|       |    {
 9785|       |        if (g.FrameCount == 0)
 9786|       |            for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 9787|       |                IM_ASSERT(g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!");
 9788|       |
 9789|       |        // Build reverse KeyMap (Named -> Legacy)
 9790|       |        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
 9791|       |            if (io.KeyMap[n] != -1)
 9792|       |            {
 9793|       |                IM_ASSERT(IsLegacyKey((ImGuiKey)io.KeyMap[n]));
 9794|       |                io.KeyMap[io.KeyMap[n]] = n;
 9795|       |            }
 9796|       |
 9797|       |        // Import legacy keys into new ones
 9798|       |        for (int n = ImGuiKey_LegacyNativeKey_BEGIN; n < ImGuiKey_LegacyNativeKey_END; n++)
 9799|       |            if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
 9800|       |            {
 9801|       |                const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
 9802|       |                IM_ASSERT(io.KeyMap[n] == -1 || IsNamedKey(key));
 9803|       |                io.KeysData[key].Down = io.KeysDown[n];
 9804|       |                if (key != n)
 9805|       |                    io.KeysDown[key] = io.KeysDown[n]; // Allow legacy code using io.KeysDown[GetKeyIndex()] with old backends
 9806|       |                io.BackendUsingLegacyKeyArrays = 1;
 9807|       |            }
 9808|       |        if (io.BackendUsingLegacyKeyArrays == 1)
 9809|       |        {
 9810|       |            GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
 9811|       |            GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
 9812|       |            GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
 9813|       |            GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
 9814|       |        }
 9815|       |    }
 9816|       |#endif
 9817|       |
 9818|       |    // Import legacy ImGuiNavInput_ io inputs and convert to gamepad keys
 9819|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 9820|       |    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
 9821|       |    if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
 9822|       |    {
 9823|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY1(_KEY, _NAV1)           do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f); io.KeysData[_KEY].AnalogValue = io.NavInputs[_NAV1]; } while (0)
 9824|       |        #define MAP_LEGACY_NAV_INPUT_TO_KEY2(_KEY, _NAV1, _NAV2)    do { io.KeysData[_KEY].Down = (io.NavInputs[_NAV1] > 0.0f) || (io.NavInputs[_NAV2] > 0.0f); io.KeysData[_KEY].AnalogValue = ImMax(io.NavInputs[_NAV1], io.NavInputs[_NAV2]); } while (0)
 9825|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceDown, ImGuiNavInput_Activate);
 9826|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceRight, ImGuiNavInput_Cancel);
 9827|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceLeft, ImGuiNavInput_Menu);
 9828|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadFaceUp, ImGuiNavInput_Input);
 9829|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadLeft, ImGuiNavInput_DpadLeft);
 9830|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadRight, ImGuiNavInput_DpadRight);
 9831|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadUp, ImGuiNavInput_DpadUp);
 9832|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadDpadDown, ImGuiNavInput_DpadDown);
 9833|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadL1, ImGuiNavInput_FocusPrev, ImGuiNavInput_TweakSlow);
 9834|       |        MAP_LEGACY_NAV_INPUT_TO_KEY2(ImGuiKey_GamepadR1, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakFast);
 9835|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickLeft, ImGuiNavInput_LStickLeft);
 9836|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickRight, ImGuiNavInput_LStickRight);
 9837|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickUp, ImGuiNavInput_LStickUp);
 9838|       |        MAP_LEGACY_NAV_INPUT_TO_KEY1(ImGuiKey_GamepadLStickDown, ImGuiNavInput_LStickDown);
 9839|       |        #undef NAV_MAP_KEY
 9840|       |    }
 9841|       |#endif
 9842|       |
 9843|       |    // Update aliases
 9844|   460k|    for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
  ------------------
  |  Branch (9844:21): [True: 383k, False: 76.6k]
  ------------------
 9845|   383k|        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
  ------------------
  |  Branch (9845:62): [True: 119k, False: 263k]
  ------------------
 9846|  76.6k|    UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
 9847|  76.6k|    UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);
 9848|       |
 9849|       |    // Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
 9850|       |    // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 9851|       |    // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
 9852|       |    // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
 9853|  76.6k|    const ImGuiKeyChord prev_key_mods = io.KeyMods;
 9854|  76.6k|    io.KeyMods = GetMergedModsFromKeys();
 9855|  76.6k|    io.KeyCtrl = (io.KeyMods & ImGuiMod_Ctrl) != 0;
 9856|  76.6k|    io.KeyShift = (io.KeyMods & ImGuiMod_Shift) != 0;
 9857|  76.6k|    io.KeyAlt = (io.KeyMods & ImGuiMod_Alt) != 0;
 9858|  76.6k|    io.KeySuper = (io.KeyMods & ImGuiMod_Super) != 0;
 9859|  76.6k|    if (prev_key_mods != io.KeyMods)
  ------------------
  |  Branch (9859:9): [True: 0, False: 76.6k]
  ------------------
 9860|      0|        g.LastKeyModsChangeTime = g.Time;
 9861|  76.6k|    if (prev_key_mods != io.KeyMods && prev_key_mods == 0)
  ------------------
  |  Branch (9861:9): [True: 0, False: 76.6k]
  |  Branch (9861:40): [True: 0, False: 0]
  ------------------
 9862|      0|        g.LastKeyModsChangeFromNoneTime = g.Time;
 9863|       |
 9864|       |    // Clear gamepad data if disabled
 9865|  76.6k|    if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
  ------------------
  |  Branch (9865:9): [True: 76.6k, False: 0]
  ------------------
 9866|  1.91M|        for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1363|  76.6k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                      for (int i = ImGuiKey_Gamepad_BEGIN; i < ImGuiKey_Gamepad_END; i++)
  ------------------
  |  | 1364|  1.91M|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (9866:46): [True: 1.84M, False: 76.6k]
  ------------------
 9867|  1.84M|        {
 9868|  1.84M|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
 9869|  1.84M|            io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
 9870|  1.84M|        }
 9871|       |
 9872|       |    // Update keys
 9873|  11.8M|    for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
  ------------------
  |  Branch (9873:21): [True: 11.8M, False: 76.6k]
  ------------------
 9874|  11.8M|    {
 9875|  11.8M|        ImGuiKeyData* key_data = &io.KeysData[i];
 9876|  11.8M|        key_data->DownDurationPrev = key_data->DownDuration;
 9877|  11.8M|        key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (9877:34): [True: 185k, False: 11.6M]
  |  Branch (9877:52): [True: 11.9k, False: 173k]
  ------------------
 9878|  11.8M|        if (key_data->DownDuration == 0.0f)
  ------------------
  |  Branch (9878:13): [True: 11.9k, False: 11.7M]
  ------------------
 9879|  11.9k|        {
 9880|  11.9k|            ImGuiKey key = (ImGuiKey)(ImGuiKey_KeysData_OFFSET + i);
 9881|  11.9k|            if (IsKeyboardKey(key))
  ------------------
  |  Branch (9881:17): [True: 4.93k, False: 7.01k]
  ------------------
 9882|  4.93k|                g.LastKeyboardKeyPressTime = g.Time;
 9883|  7.01k|            else if (key == ImGuiKey_ReservedForModCtrl || key == ImGuiKey_ReservedForModShift || key == ImGuiKey_ReservedForModAlt || key == ImGuiKey_ReservedForModSuper)
  ------------------
  |  Branch (9883:22): [True: 0, False: 7.01k]
  |  Branch (9883:60): [True: 0, False: 7.01k]
  |  Branch (9883:99): [True: 0, False: 7.01k]
  |  Branch (9883:136): [True: 0, False: 7.01k]
  ------------------
 9884|      0|                g.LastKeyboardKeyPressTime = g.Time;
 9885|  11.9k|        }
 9886|  11.8M|    }
 9887|       |
 9888|       |    // Update keys/input owner (named keys only): one entry per key
 9889|  11.8M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (9889:50): [True: 11.8M, False: 76.6k]
  ------------------
 9890|  11.8M|    {
 9891|  11.8M|        ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
 9892|  11.8M|        ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
 9893|  11.8M|        owner_data->OwnerCurr = owner_data->OwnerNext;
 9894|  11.8M|        if (!key_data->Down) // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
  ------------------
  |  Branch (9894:13): [True: 11.6M, False: 185k]
  ------------------
 9895|  11.6M|            owner_data->OwnerNext = ImGuiKeyOwner_NoOwner;
  ------------------
  |  | 1434|  11.6M|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 9896|  11.8M|        owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;  // Clear LockUntilRelease when key is not Down anymore
  ------------------
  |  Branch (9896:68): [True: 0, False: 11.8M]
  |  Branch (9896:100): [True: 0, False: 0]
  ------------------
 9897|  11.8M|    }
 9898|       |
 9899|       |    // Update key routing (for e.g. shortcuts)
 9900|  76.6k|    UpdateKeyRoutingTable(&g.KeysRoutingTable);
 9901|  76.6k|}
imgui.cpp:_ZL14UpdateAliasKey8ImGuiKeybf:
 9749|   536k|{
 9750|   536k|    IM_ASSERT(ImGui::IsAliasKey(key));
  ------------------
  |  |   23|   536k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 9751|   536k|    ImGuiKeyData* key_data = ImGui::GetKeyData(key);
 9752|   536k|    key_data->Down = v;
 9753|   536k|    key_data->AnalogValue = analog_value;
 9754|   536k|}
imgui.cpp:_ZL21GetMergedModsFromKeysv:
 9758|   153k|{
 9759|   153k|    ImGuiKeyChord mods = 0;
 9760|   153k|    if (ImGui::IsKeyDown(ImGuiMod_Ctrl))     { mods |= ImGuiMod_Ctrl; }
  ------------------
  |  Branch (9760:9): [True: 0, False: 153k]
  ------------------
 9761|   153k|    if (ImGui::IsKeyDown(ImGuiMod_Shift))    { mods |= ImGuiMod_Shift; }
  ------------------
  |  Branch (9761:9): [True: 0, False: 153k]
  ------------------
 9762|   153k|    if (ImGui::IsKeyDown(ImGuiMod_Alt))      { mods |= ImGuiMod_Alt; }
  ------------------
  |  Branch (9762:9): [True: 0, False: 153k]
  ------------------
 9763|   153k|    if (ImGui::IsKeyDown(ImGuiMod_Super))    { mods |= ImGuiMod_Super; }
  ------------------
  |  Branch (9763:9): [True: 0, False: 153k]
  ------------------
 9764|   153k|    return mods;
 9765|   153k|}
imgui.cpp:_ZN5ImGuiL21UpdateKeyRoutingTableEP20ImGuiKeyRoutingTable:
 9220|  76.6k|{
 9221|  76.6k|    ImGuiContext& g = *GImGui;
 9222|  76.6k|    rt->EntriesNext.resize(0);
 9223|  11.8M|    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
  ------------------
  |  Branch (9223:50): [True: 11.8M, False: 76.6k]
  ------------------
 9224|  11.8M|    {
 9225|  11.8M|        const int new_routing_start_idx = rt->EntriesNext.Size;
 9226|  11.8M|        ImGuiKeyRoutingData* routing_entry;
 9227|  11.8M|        for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
  ------------------
  |  Branch (9227:78): [True: 0, False: 11.8M]
  ------------------
 9228|      0|        {
 9229|      0|            routing_entry = &rt->Entries[old_routing_idx];
 9230|      0|            routing_entry->RoutingCurrScore = routing_entry->RoutingNextScore;
 9231|      0|            routing_entry->RoutingCurr = routing_entry->RoutingNext; // Update entry
 9232|      0|            routing_entry->RoutingNext = ImGuiKeyOwner_NoOwner;
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
 9233|      0|            routing_entry->RoutingNextScore = 255;
 9234|      0|            if (routing_entry->RoutingCurr == ImGuiKeyOwner_NoOwner)
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9234:17): [True: 0, False: 0]
  ------------------
 9235|      0|                continue;
 9236|      0|            rt->EntriesNext.push_back(*routing_entry); // Write alive ones into new buffer
 9237|       |
 9238|       |            // Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
 9239|       |            // This is the result of previous frame's SetShortcutRouting() call.
 9240|      0|            if (routing_entry->Mods == g.IO.KeyMods)
  ------------------
  |  Branch (9240:17): [True: 0, False: 0]
  ------------------
 9241|      0|            {
 9242|      0|                ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(&g, key);
 9243|      0|                if (owner_data->OwnerCurr == ImGuiKeyOwner_NoOwner)
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (9243:21): [True: 0, False: 0]
  ------------------
 9244|      0|                {
 9245|      0|                    owner_data->OwnerCurr = routing_entry->RoutingCurr;
 9246|       |                    //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry->RoutingCurr);
 9247|      0|                }
 9248|      0|            }
 9249|      0|        }
 9250|       |
 9251|       |        // Rewrite linked-list
 9252|  11.8M|        rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
  ------------------
  |  Branch (9252:75): [True: 0, False: 11.8M]
  ------------------
 9253|  11.8M|        for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
  ------------------
  |  Branch (9253:45): [True: 0, False: 11.8M]
  ------------------
 9254|      0|            rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
  ------------------
  |  Branch (9254:72): [True: 0, False: 0]
  ------------------
 9255|  11.8M|    }
 9256|  76.6k|    rt->Entries.swap(rt->EntriesNext); // Swap new and old indexes
 9257|  76.6k|}
imgui.cpp:_ZN5ImGuiL17UpdateMouseInputsEv:
 9904|  76.6k|{
 9905|  76.6k|    ImGuiContext& g = *GImGui;
 9906|  76.6k|    ImGuiIO& io = g.IO;
 9907|       |
 9908|       |    // Mouse Wheel swapping flag
 9909|       |    // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
 9910|       |    // - We avoid doing it on OSX as it the OS input layer handles this already.
 9911|       |    // - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
 9912|       |    // - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
 9913|  76.6k|    io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;
  ------------------
  |  Branch (9913:36): [True: 0, False: 76.6k]
  |  Branch (9913:51): [True: 0, False: 0]
  ------------------
 9914|       |
 9915|       |    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
 9916|  76.6k|    if (IsMousePosValid(&io.MousePos))
  ------------------
  |  Branch (9916:9): [True: 57.8k, False: 18.8k]
  ------------------
 9917|  57.8k|        io.MousePos = g.MouseLastValidPos = ImFloor(io.MousePos);
 9918|       |
 9919|       |    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
 9920|  76.6k|    if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (9920:9): [True: 57.8k, False: 18.8k]
  |  Branch (9920:42): [True: 57.6k, False: 296]
  ------------------
 9921|  57.6k|        io.MouseDelta = io.MousePos - io.MousePosPrev;
 9922|  19.0k|    else
 9923|  19.0k|        io.MouseDelta = ImVec2(0.0f, 0.0f);
 9924|       |
 9925|       |    // Update stationary timer.
 9926|       |    // FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
 9927|  76.6k|    const float mouse_stationary_threshold = (io.MouseSource == ImGuiMouseSource_Mouse) ? 2.0f : 3.0f; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
  ------------------
  |  Branch (9927:46): [True: 76.6k, False: 0]
  ------------------
 9928|  76.6k|    const bool mouse_stationary = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold);
 9929|  76.6k|    g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0f;
  ------------------
  |  Branch (9929:30): [True: 74.3k, False: 2.37k]
  ------------------
 9930|       |    //IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);
 9931|       |
 9932|       |    // If mouse moved we re-enable mouse hovering in case it was disabled by gamepad/keyboard. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
 9933|  76.6k|    if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
  ------------------
  |  Branch (9933:9): [True: 2.11k, False: 74.5k]
  |  Branch (9933:36): [True: 607, False: 73.9k]
  ------------------
 9934|  2.72k|        g.NavDisableMouseHover = false;
 9935|       |
 9936|   460k|    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)
  ------------------
  |  |   93|   460k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (9936:21): [True: 383k, False: 76.6k]
  ------------------
 9937|   383k|    {
 9938|   383k|        io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
  ------------------
  |  Branch (9938:30): [True: 119k, False: 263k]
  |  Branch (9938:49): [True: 3.88k, False: 115k]
  ------------------
 9939|   383k|        io.MouseClickedCount[i] = 0; // Will be filled below
 9940|   383k|        io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
  ------------------
  |  Branch (9940:31): [True: 263k, False: 119k]
  |  Branch (9940:51): [True: 3.03k, False: 260k]
  ------------------
 9941|   383k|        io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
 9942|   383k|        io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
  ------------------
  |  Branch (9942:35): [True: 119k, False: 263k]
  |  Branch (9942:54): [True: 3.88k, False: 115k]
  ------------------
 9943|   383k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (9943:13): [True: 3.88k, False: 379k]
  ------------------
 9944|  3.88k|        {
 9945|  3.88k|            bool is_repeated_click = false;
 9946|  3.88k|            if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
  ------------------
  |  Branch (9946:17): [True: 3.11k, False: 773]
  ------------------
 9947|  3.11k|            {
 9948|  3.11k|                ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (9948:47): [True: 2.50k, False: 610]
  ------------------
 9949|  3.11k|                if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
  ------------------
  |  Branch (9949:21): [True: 2.75k, False: 358]
  ------------------
 9950|  2.75k|                    is_repeated_click = true;
 9951|  3.11k|            }
 9952|  3.88k|            if (is_repeated_click)
  ------------------
  |  Branch (9952:17): [True: 2.75k, False: 1.13k]
  ------------------
 9953|  2.75k|                io.MouseClickedLastCount[i]++;
 9954|  1.13k|            else
 9955|  1.13k|                io.MouseClickedLastCount[i] = 1;
 9956|  3.88k|            io.MouseClickedTime[i] = g.Time;
 9957|  3.88k|            io.MouseClickedPos[i] = io.MousePos;
 9958|  3.88k|            io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
 9959|  3.88k|            io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
 9960|  3.88k|            io.MouseDragMaxDistanceSqr[i] = 0.0f;
 9961|  3.88k|        }
 9962|   379k|        else if (io.MouseDown[i])
  ------------------
  |  Branch (9962:18): [True: 115k, False: 263k]
  ------------------
 9963|   115k|        {
 9964|       |            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
 9965|   115k|            ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (9965:43): [True: 102k, False: 12.9k]
  ------------------
 9966|   115k|            io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
 9967|   115k|            io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
  ------------------
  |  Branch (9967:86): [True: 23.0k, False: 92.7k]
  ------------------
 9968|   115k|            io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
  ------------------
  |  Branch (9968:86): [True: 30.1k, False: 85.6k]
  ------------------
 9969|   115k|        }
 9970|       |
 9971|       |        // We provide io.MouseDoubleClicked[] as a legacy service
 9972|   383k|        io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);
 9973|       |
 9974|       |        // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
 9975|   383k|        if (io.MouseClicked[i])
  ------------------
  |  Branch (9975:13): [True: 3.88k, False: 379k]
  ------------------
 9976|  3.88k|            g.NavDisableMouseHover = false;
 9977|   383k|    }
 9978|  76.6k|}
imgui.cpp:_ZN5ImGuiL16UpdateMouseWheelEv:
10040|  76.6k|{
10041|       |    // Reset the locked window if we move the mouse or after the timer elapses.
10042|       |    // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
10043|  76.6k|    ImGuiContext& g = *GImGui;
10044|  76.6k|    if (g.WheelingWindow != NULL)
  ------------------
  |  Branch (10044:9): [True: 1, False: 76.6k]
  ------------------
10045|      1|    {
10046|      1|        g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
10047|      1|        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
  ------------------
  |  Branch (10047:13): [True: 1, False: 0]
  |  Branch (10047:13): [True: 0, False: 1]
  |  Branch (10047:34): [True: 0, False: 1]
  ------------------
10048|      0|            g.WheelingWindowReleaseTimer = 0.0f;
10049|      1|        if (g.WheelingWindowReleaseTimer <= 0.0f)
  ------------------
  |  Branch (10049:13): [True: 1, False: 0]
  ------------------
10050|      1|            LockWheelingWindow(NULL, 0.0f);
10051|      1|    }
10052|       |
10053|  76.6k|    ImVec2 wheel;
10054|  76.6k|    wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheelH : 0.0f;
  ------------------
  |  | 1434|  76.6k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (10054:15): [True: 76.6k, False: 0]
  ------------------
10055|  76.6k|    wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheel : 0.0f;
  ------------------
  |  | 1434|  76.6k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (10055:15): [True: 76.6k, False: 0]
  ------------------
10056|       |
10057|       |    //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
10058|  76.6k|    ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
  ------------------
  |  Branch (10058:33): [True: 0, False: 76.6k]
  ------------------
10059|  76.6k|    if (!mouse_window || mouse_window->Collapsed)
  ------------------
  |  Branch (10059:9): [True: 75.7k, False: 955]
  |  Branch (10059:26): [True: 508, False: 447]
  ------------------
10060|  76.2k|        return;
10061|       |
10062|       |    // Zoom / Scale window
10063|       |    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
10064|    447|    if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
  ------------------
  |  Branch (10064:9): [True: 3, False: 444]
  |  Branch (10064:28): [True: 0, False: 3]
  |  Branch (10064:44): [True: 0, False: 0]
  ------------------
10065|      0|    {
10066|      0|        LockWheelingWindow(mouse_window, wheel.y);
10067|      0|        ImGuiWindow* window = mouse_window;
10068|      0|        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
10069|      0|        const float scale = new_font_scale / window->FontWindowScale;
10070|      0|        window->FontWindowScale = new_font_scale;
10071|      0|        if (window == window->RootWindow)
  ------------------
  |  Branch (10071:13): [True: 0, False: 0]
  ------------------
10072|      0|        {
10073|      0|            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
10074|      0|            SetWindowPos(window, window->Pos + offset, 0);
10075|      0|            window->Size = ImTrunc(window->Size * scale);
10076|      0|            window->SizeFull = ImTrunc(window->SizeFull * scale);
10077|      0|        }
10078|      0|        return;
10079|      0|    }
10080|    447|    if (g.IO.KeyCtrl)
  ------------------
  |  Branch (10080:9): [True: 0, False: 447]
  ------------------
10081|      0|        return;
10082|       |
10083|       |    // Mouse wheel scrolling
10084|       |    // Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
10085|    447|    if (g.IO.MouseWheelRequestAxisSwap)
  ------------------
  |  Branch (10085:9): [True: 0, False: 447]
  ------------------
10086|      0|        wheel = ImVec2(wheel.y, 0.0f);
10087|       |
10088|       |    // Maintain a rough average of moving magnitude on both axises
10089|       |    // FIXME: should by based on wall clock time rather than frame-counter
10090|    447|    g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
10091|    447|    g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);
10092|       |
10093|       |    // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
10094|    447|    wheel += g.WheelingWindowWheelRemainder;
10095|    447|    g.WheelingWindowWheelRemainder = ImVec2(0.0f, 0.0f);
10096|    447|    if (wheel.x == 0.0f && wheel.y == 0.0f)
  ------------------
  |  Branch (10096:9): [True: 444, False: 3]
  |  Branch (10096:28): [True: 444, False: 0]
  ------------------
10097|    444|        return;
10098|       |
10099|       |    // Mouse wheel scrolling: find target and apply
10100|       |    // - don't renew lock if axis doesn't apply on the window.
10101|       |    // - select a main axis when both axises are being moved.
10102|      3|    if (ImGuiWindow* window = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)))
  ------------------
  |  Branch (10102:22): [True: 3, False: 0]
  ------------------
10103|      3|        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
  ------------------
  |  Branch (10103:13): [True: 3, False: 0]
  |  Branch (10103:70): [True: 3, False: 0]
  ------------------
10104|      3|        {
10105|      3|            bool do_scroll[2] = { wheel.x != 0.0f && window->ScrollMax.x != 0.0f, wheel.y != 0.0f && window->ScrollMax.y != 0.0f };
  ------------------
  |  Branch (10105:35): [True: 3, False: 0]
  |  Branch (10105:54): [True: 1, False: 2]
  |  Branch (10105:83): [True: 3, False: 0]
  |  Branch (10105:102): [True: 1, False: 2]
  ------------------
10106|      3|            if (do_scroll[ImGuiAxis_X] && do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (10106:17): [True: 1, False: 2]
  |  Branch (10106:43): [True: 1, False: 0]
  ------------------
10107|      1|                do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis_Y : ImGuiAxis_X] = false;
  ------------------
  |  Branch (10107:27): [True: 0, False: 1]
  ------------------
10108|      3|            if (do_scroll[ImGuiAxis_X])
  ------------------
  |  Branch (10108:17): [True: 0, False: 3]
  ------------------
10109|      0|            {
10110|      0|                LockWheelingWindow(window, wheel.x);
10111|      0|                float max_step = window->InnerRect.GetWidth() * 0.67f;
10112|      0|                float scroll_step = ImTrunc(ImMin(2 * window->CalcFontSize(), max_step));
10113|      0|                SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
10114|      0|                g.WheelingWindowScrolledFrame = g.FrameCount;
10115|      0|            }
10116|      3|            if (do_scroll[ImGuiAxis_Y])
  ------------------
  |  Branch (10116:17): [True: 1, False: 2]
  ------------------
10117|      1|            {
10118|      1|                LockWheelingWindow(window, wheel.y);
10119|      1|                float max_step = window->InnerRect.GetHeight() * 0.67f;
10120|      1|                float scroll_step = ImTrunc(ImMin(5 * window->CalcFontSize(), max_step));
10121|      1|                SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
10122|      1|                g.WheelingWindowScrolledFrame = g.FrameCount;
10123|      1|            }
10124|      3|        }
10125|      3|}
imgui.cpp:_ZL18LockWheelingWindowP11ImGuiWindowf:
 9981|      2|{
 9982|      2|    ImGuiContext& g = *GImGui;
 9983|      2|    if (window)
  ------------------
  |  Branch (9983:9): [True: 1, False: 1]
  ------------------
 9984|      1|        g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
 9985|      1|    else
 9986|      1|        g.WheelingWindowReleaseTimer = 0.0f;
 9987|      2|    if (g.WheelingWindow == window)
  ------------------
  |  Branch (9987:9): [True: 0, False: 2]
  ------------------
 9988|      0|        return;
 9989|      2|    IMGUI_DEBUG_LOG_IO("[io] LockWheelingWindow() \"%s\"\n", window ? window->Name : "NULL");
  ------------------
  |  |  251|      2|#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)          IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (251:50): [True: 0, False: 2]
  |  |  |  Branch (251:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
 9990|      2|    g.WheelingWindow = window;
 9991|      2|    g.WheelingWindowRefMousePos = g.IO.MousePos;
 9992|      2|    if (window == NULL)
  ------------------
  |  Branch (9992:9): [True: 1, False: 1]
  ------------------
 9993|      1|    {
 9994|      1|        g.WheelingWindowStartFrame = -1;
 9995|      1|        g.WheelingAxisAvg = ImVec2(0.0f, 0.0f);
 9996|      1|    }
 9997|      2|}
imgui.cpp:_ZL22FindBestWheelingWindowRK6ImVec2:
10000|      3|{
10001|       |    // For each axis, find window in the hierarchy that may want to use scrolling
10002|      3|    ImGuiContext& g = *GImGui;
10003|      3|    ImGuiWindow* windows[2] = { NULL, NULL };
10004|      9|    for (int axis = 0; axis < 2; axis++)
  ------------------
  |  Branch (10004:24): [True: 6, False: 3]
  ------------------
10005|      6|        if (wheel[axis] != 0.0f)
  ------------------
  |  Branch (10005:13): [True: 6, False: 0]
  ------------------
10006|      6|            for (ImGuiWindow* window = windows[axis] = g.HoveredWindow; window->Flags & ImGuiWindowFlags_ChildWindow; window = windows[axis] = window->ParentWindow)
  ------------------
  |  Branch (10006:73): [True: 0, False: 6]
  ------------------
10007|      0|            {
10008|       |                // Bubble up into parent window if:
10009|       |                // - a child window doesn't allow any scrolling.
10010|       |                // - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
10011|       |                //// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
10012|      0|                const bool has_scrolling = (window->ScrollMax[axis] != 0.0f);
10013|      0|                const bool inputs_disabled = (window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs);
  ------------------
  |  Branch (10013:46): [True: 0, False: 0]
  |  Branch (10013:102): [True: 0, False: 0]
  ------------------
10014|       |                //const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >= window->ScrollMax[axis]);
10015|      0|                if (has_scrolling && !inputs_disabled) // && !scrolling_past_limits)
  ------------------
  |  Branch (10015:21): [True: 0, False: 0]
  |  Branch (10015:38): [True: 0, False: 0]
  ------------------
10016|      0|                    break; // select this window
10017|      0|            }
10018|      3|    if (windows[0] == NULL && windows[1] == NULL)
  ------------------
  |  Branch (10018:9): [True: 0, False: 3]
  |  Branch (10018:31): [True: 0, False: 0]
  ------------------
10019|      0|        return NULL;
10020|       |
10021|       |    // If there's only one window or only one axis then there's no ambiguity
10022|      3|    if (windows[0] == windows[1] || windows[0] == NULL || windows[1] == NULL)
  ------------------
  |  Branch (10022:9): [True: 3, False: 0]
  |  Branch (10022:37): [True: 0, False: 0]
  |  Branch (10022:59): [True: 0, False: 0]
  ------------------
10023|      3|        return windows[1] ? windows[1] : windows[0];
  ------------------
  |  Branch (10023:16): [True: 3, False: 0]
  ------------------
10024|       |
10025|       |    // If candidate are different windows we need to decide which one to prioritize
10026|       |    // - First frame: only find a winner if one axis is zero.
10027|       |    // - Subsequent frames: only find a winner when one is more than the other.
10028|      0|    if (g.WheelingWindowStartFrame == -1)
  ------------------
  |  Branch (10028:9): [True: 0, False: 0]
  ------------------
10029|      0|        g.WheelingWindowStartFrame = g.FrameCount;
10030|      0|    if ((g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0f && wheel.y != 0.0f) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y))
  ------------------
  |  Branch (10030:10): [True: 0, False: 0]
  |  Branch (10030:56): [True: 0, False: 0]
  |  Branch (10030:75): [True: 0, False: 0]
  |  Branch (10030:95): [True: 0, False: 0]
  ------------------
10031|      0|    {
10032|      0|        g.WheelingWindowWheelRemainder = wheel;
10033|      0|        return NULL;
10034|      0|    }
10035|      0|    return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
  ------------------
  |  Branch (10035:12): [True: 0, False: 0]
  ------------------
10036|      0|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckNewFrameSanityChecksEv:
10562|  76.6k|{
10563|  76.6k|    ImGuiContext& g = *GImGui;
10564|       |
10565|       |    // Check user IM_ASSERT macro
10566|       |    // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
10567|       |    //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
10568|       |    //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
10569|       |    // #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
10570|       |    // #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
10571|  76.6k|    if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  if (true) IM_ASSERT(1); else IM_ASSERT(0);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (10571:9): [Folded - Ignored]
  ------------------
10572|       |
10573|       |    // Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
10574|       |    // Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
10575|       |#ifdef __EMSCRIPTEN__
10576|       |    if (g.IO.DeltaTime <= 0.0f && g.FrameCount > 0)
10577|       |        g.IO.DeltaTime = 0.00001f;
10578|       |#endif
10579|       |
10580|       |    // Check user data
10581|       |    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
10582|  76.6k|    IM_ASSERT(g.Initialized);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10583|  76.6k|    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10584|  76.6k|    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10585|  76.6k|    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10586|  76.6k|    IM_ASSERT(g.IO.Fonts->IsBuilt()                                     && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10587|  76.6k|    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10588|  76.6k|    IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0f                 && "Invalid style setting!");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10589|  76.6k|    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10590|  76.6k|    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10591|  76.6k|    IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10592|  76.6k|    IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10593|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
10594|       |    for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
10595|       |        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ImGuiKey_LegacyNativeKey_END && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)");
10596|       |
10597|       |    // Check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only added in 1.60 WIP)
10598|       |    if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
10599|       |        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");
10600|       |#endif
10601|       |
10602|       |    // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
10603|  76.6k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0)
  ------------------
  |  Branch (10603:9): [True: 5, False: 76.6k]
  |  Branch (10603:30): [True: 5, False: 0]
  |  Branch (10603:85): [True: 0, False: 5]
  ------------------
10604|  76.6k|        IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10605|  76.6k|    if (g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0)
  ------------------
  |  Branch (10605:9): [True: 5, False: 76.6k]
  |  Branch (10605:30): [True: 0, False: 5]
  |  Branch (10605:87): [True: 0, False: 0]
  ------------------
10606|  76.6k|        IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10607|       |
10608|       |    // Perform simple checks: multi-viewport and platform windows support
10609|  76.6k|    if (g.IO.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (10609:9): [True: 1, False: 76.6k]
  ------------------
10610|      1|    {
10611|      1|        if ((g.IO.BackendFlags & ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasViewports))
  ------------------
  |  Branch (10611:13): [True: 0, False: 1]
  |  Branch (10611:77): [True: 0, False: 0]
  ------------------
10612|      0|        {
10613|      0|            IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10614|      0|            IM_ASSERT(g.PlatformIO.Platform_CreateWindow  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10615|      0|            IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10616|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10617|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowPos  != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10618|      0|            IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10619|      0|            IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != NULL && "Platform init didn't install handlers?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10620|      0|            IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10621|      0|            IM_ASSERT((g.Viewports[0]->PlatformUserData != NULL || g.Viewports[0]->PlatformHandle != NULL) && "Platform init didn't setup main viewport.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10622|      0|            if (g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_DockingEnable))
  ------------------
  |  Branch (10622:17): [True: 0, False: 0]
  |  Branch (10622:57): [True: 0, False: 0]
  ------------------
10623|      0|                IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != NULL && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10624|      0|        }
10625|      1|        else
10626|      1|        {
10627|       |            // Disable feature, our backends do not support it
10628|      1|            g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
10629|      1|        }
10630|       |
10631|       |        // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
10632|      1|        for (ImGuiPlatformMonitor& mon : g.PlatformIO.Monitors)
  ------------------
  |  Branch (10632:40): [True: 0, False: 1]
  ------------------
10633|      0|        {
10634|      0|            IM_UNUSED(mon);
  ------------------
  |  |   94|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
10635|      0|            IM_ASSERT(mon.MainSize.x > 0.0f && mon.MainSize.y > 0.0f && "Monitor main bounds not setup properly.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10636|      0|            IM_ASSERT(ImRect(mon.MainPos, mon.MainPos + mon.MainSize).Contains(ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10637|      0|            IM_ASSERT(mon.DpiScale != 0.0f);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10638|      0|        }
10639|      1|    }
10640|  76.6k|}
imgui.cpp:_ZN5ImGuiL30ErrorCheckEndFrameSanityChecksEv:
10643|  76.6k|{
10644|  76.6k|    ImGuiContext& g = *GImGui;
10645|       |
10646|       |    // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
10647|       |    // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
10648|       |    // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
10649|       |    // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
10650|       |    // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
10651|       |    // while still correctly asserting on mid-frame key press events.
10652|  76.6k|    const ImGuiKeyChord key_mods = GetMergedModsFromKeys();
10653|  76.6k|    IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
10654|  76.6k|    IM_UNUSED(key_mods);
  ------------------
  |  |   94|  76.6k|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
10655|       |
10656|       |    // [EXPERIMENTAL] Recover from errors: You may call this yourself before EndFrame().
10657|       |    //ErrorCheckEndFrameRecover();
10658|       |
10659|       |    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
10660|       |    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
10661|  76.6k|    if (g.CurrentWindowStack.Size != 1)
  ------------------
  |  Branch (10661:9): [True: 0, False: 76.6k]
  ------------------
10662|      0|    {
10663|      0|        if (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (10663:13): [True: 0, False: 0]
  ------------------
10664|      0|        {
10665|      0|            ImGuiWindow* window = g.CurrentWindowStack.back().Window; // <-- This window was not Ended!
10666|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
  ------------------
  |  |  271|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
10667|      0|            IM_UNUSED(window);
  ------------------
  |  |   94|      0|#define IM_UNUSED(_VAR)             ((void)(_VAR))                              // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.
  ------------------
10668|      0|            while (g.CurrentWindowStack.Size > 1)
  ------------------
  |  Branch (10668:20): [True: 0, False: 0]
  ------------------
10669|      0|                End();
10670|      0|        }
10671|      0|        else
10672|      0|        {
10673|      0|            IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size == 1, "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
  ------------------
  |  |  271|      0|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
10674|      0|        }
10675|      0|    }
10676|       |
10677|  76.6k|    IM_ASSERT_USER_ERROR(g.GroupStack.Size == 0, "Missing EndGroup call!");
  ------------------
  |  |  271|  76.6k|#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
  |  |  ------------------
  |  |  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
10678|  76.6k|}
imgui.cpp:_ZL38CalcNextScrollFromScrollTargetAndClampP11ImGuiWindow:
11383|   170k|{
11384|   170k|    ImVec2 scroll = window->Scroll;
11385|   170k|    ImVec2 decoration_size(window->DecoOuterSizeX1 + window->DecoInnerSizeX1 + window->DecoOuterSizeX2, window->DecoOuterSizeY1 + window->DecoInnerSizeY1 + window->DecoOuterSizeY2);
11386|   511k|    for (int axis = 0; axis < 2; axis++)
  ------------------
  |  Branch (11386:24): [True: 340k, False: 170k]
  ------------------
11387|   340k|    {
11388|   340k|        if (window->ScrollTarget[axis] < FLT_MAX)
  ------------------
  |  Branch (11388:13): [True: 8.32k, False: 332k]
  ------------------
11389|  8.32k|        {
11390|  8.32k|            float center_ratio = window->ScrollTargetCenterRatio[axis];
11391|  8.32k|            float scroll_target = window->ScrollTarget[axis];
11392|  8.32k|            if (window->ScrollTargetEdgeSnapDist[axis] > 0.0f)
  ------------------
  |  Branch (11392:17): [True: 0, False: 8.32k]
  ------------------
11393|      0|            {
11394|      0|                float snap_min = 0.0f;
11395|      0|                float snap_max = window->ScrollMax[axis] + window->SizeFull[axis] - decoration_size[axis];
11396|      0|                scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window->ScrollTargetEdgeSnapDist[axis], center_ratio);
11397|      0|            }
11398|  8.32k|            scroll[axis] = scroll_target - center_ratio * (window->SizeFull[axis] - decoration_size[axis]);
11399|  8.32k|        }
11400|   340k|        scroll[axis] = IM_ROUND(ImMax(scroll[axis], 0.0f));
  ------------------
  |  |  288|   340k|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
11401|   340k|        if (!window->Collapsed && !window->SkipItems)
  ------------------
  |  Branch (11401:13): [True: 221k, False: 119k]
  |  Branch (11401:35): [True: 221k, False: 24]
  ------------------
11402|   221k|            scroll[axis] = ImMin(scroll[axis], window->ScrollMax[axis]);
11403|   340k|    }
11404|   170k|    return scroll;
11405|   170k|}
imgui.cpp:_ZN5ImGuiL20NavApplyItemToResultEP16ImGuiNavItemData:
12501|    224|{
12502|    224|    ImGuiContext& g = *GImGui;
12503|    224|    ImGuiWindow* window = g.CurrentWindow;
12504|    224|    result->Window = window;
12505|    224|    result->ID = g.LastItemData.ID;
12506|    224|    result->FocusScopeId = g.CurrentFocusScopeId;
12507|    224|    result->InFlags = g.LastItemData.InFlags;
12508|    224|    result->RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect);
12509|    224|    if (result->InFlags & ImGuiItemFlags_HasSelectionUserData)
  ------------------
  |  Branch (12509:9): [True: 0, False: 224]
  ------------------
12510|      0|    {
12511|      0|        IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12512|      0|        result->SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
12513|      0|    }
12514|    224|}
imgui.cpp:_ZN5ImGuiL14NavProcessItemEv:
12528|    664|{
12529|    664|    ImGuiContext& g = *GImGui;
12530|    664|    ImGuiWindow* window = g.CurrentWindow;
12531|    664|    const ImGuiID id = g.LastItemData.ID;
12532|    664|    const ImGuiItemFlags item_flags = g.LastItemData.InFlags;
12533|       |
12534|       |    // When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
12535|    664|    if (window->DC.NavIsScrollPushableX == false)
  ------------------
  |  Branch (12535:9): [True: 0, False: 664]
  ------------------
12536|      0|    {
12537|      0|        g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
12538|      0|        g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
12539|      0|    }
12540|    664|    const ImRect nav_bb = g.LastItemData.NavRect;
12541|       |
12542|       |    // Process Init Request
12543|    664|    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
  ------------------
  |  Branch (12543:9): [True: 133, False: 531]
  |  Branch (12543:29): [True: 68, False: 65]
  |  Branch (12543:73): [True: 68, False: 0]
  ------------------
12544|     68|    {
12545|       |        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
12546|     68|        const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
12547|     68|        if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0)
  ------------------
  |  Branch (12547:13): [True: 22, False: 46]
  |  Branch (12547:48): [True: 46, False: 0]
  ------------------
12548|     68|        {
12549|     68|            NavApplyItemToResult(&g.NavInitResult);
12550|     68|        }
12551|     68|        if (candidate_for_nav_default_focus)
  ------------------
  |  Branch (12551:13): [True: 22, False: 46]
  ------------------
12552|     22|        {
12553|     22|            g.NavInitRequest = false; // Found a match, clear request
12554|     22|            NavUpdateAnyRequestFlag();
12555|     22|        }
12556|     68|    }
12557|       |
12558|       |    // Process Move Request (scoring for navigation)
12559|       |    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
12560|    664|    if (g.NavMoveScoringItems && (item_flags & ImGuiItemFlags_Disabled) == 0)
  ------------------
  |  Branch (12560:9): [True: 262, False: 402]
  |  Branch (12560:34): [True: 262, False: 0]
  ------------------
12561|    262|    {
12562|    262|        if ((g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi) || (window->Flags & ImGuiWindowFlags_NoNavInputs) == 0)
  ------------------
  |  Branch (12562:13): [True: 0, False: 262]
  |  Branch (12562:62): [True: 262, False: 0]
  ------------------
12563|    262|        {
12564|    262|            const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_IsTabbing) != 0;
12565|    262|            if (is_tabbing)
  ------------------
  |  Branch (12565:17): [True: 28, False: 234]
  ------------------
12566|     28|            {
12567|     28|                NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
12568|     28|            }
12569|    234|            else if (g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_AllowCurrentNavId))
  ------------------
  |  Branch (12569:22): [True: 140, False: 94]
  |  Branch (12569:39): [True: 75, False: 19]
  ------------------
12570|    215|            {
12571|    215|                ImGuiNavItemData* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
  ------------------
  |  Branch (12571:44): [True: 215, False: 0]
  ------------------
12572|    215|                if (NavScoreItem(result))
  ------------------
  |  Branch (12572:21): [True: 87, False: 128]
  ------------------
12573|     87|                    NavApplyItemToResult(result);
12574|       |
12575|       |                // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
12576|    215|                const float VISIBLE_RATIO = 0.70f;
12577|    215|                if ((g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
  ------------------
  |  Branch (12577:21): [True: 126, False: 89]
  |  Branch (12577:81): [True: 126, False: 0]
  ------------------
12578|    126|                    if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
  ------------------
  |  Branch (12578:25): [True: 126, False: 0]
  ------------------
12579|    126|                        if (NavScoreItem(&g.NavMoveResultLocalVisible))
  ------------------
  |  Branch (12579:29): [True: 63, False: 63]
  ------------------
12580|     63|                            NavApplyItemToResult(&g.NavMoveResultLocalVisible);
12581|    215|            }
12582|    262|        }
12583|    262|    }
12584|       |
12585|       |    // Update information for currently focused/navigated item
12586|    664|    if (g.NavId == id)
  ------------------
  |  Branch (12586:9): [True: 418, False: 246]
  ------------------
12587|    418|    {
12588|    418|        if (g.NavWindow != window)
  ------------------
  |  Branch (12588:13): [True: 0, False: 418]
  ------------------
12589|      0|            SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
12590|    418|        g.NavLayer = window->DC.NavLayerCurrent;
12591|    418|        SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
12592|    418|        g.NavFocusScopeId = g.CurrentFocusScopeId;
12593|    418|        g.NavIdIsAlive = true;
12594|    418|        if (g.LastItemData.InFlags & ImGuiItemFlags_HasSelectionUserData)
  ------------------
  |  Branch (12594:13): [True: 0, False: 418]
  ------------------
12595|      0|        {
12596|      0|            IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12597|      0|            g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
12598|      0|        }
12599|    418|        window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
12600|    418|    }
12601|    664|}
imgui.cpp:_ZN5ImGuiL31NavProcessItemForTabbingRequestEjii:
12611|     28|{
12612|     28|    ImGuiContext& g = *GImGui;
12613|       |
12614|     28|    if ((move_flags & ImGuiNavMoveFlags_FocusApi) == 0)
  ------------------
  |  Branch (12614:9): [True: 28, False: 0]
  ------------------
12615|     28|    {
12616|     28|        if (g.NavLayer != g.CurrentWindow->DC.NavLayerCurrent)
  ------------------
  |  Branch (12616:13): [True: 17, False: 11]
  ------------------
12617|     17|            return;
12618|     11|        if (g.NavFocusScopeId != g.CurrentFocusScopeId)
  ------------------
  |  Branch (12618:13): [True: 5, False: 6]
  ------------------
12619|      5|            return;
12620|     11|    }
12621|       |
12622|       |    // - Can always land on an item when using API call.
12623|       |    // - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every item.
12624|       |    // - Tabbing without _NavEnableKeyboard: goes through inputable items only.
12625|      6|    bool can_stop;
12626|      6|    if (move_flags & ImGuiNavMoveFlags_FocusApi)
  ------------------
  |  Branch (12626:9): [True: 0, False: 6]
  ------------------
12627|      0|        can_stop = true;
12628|      6|    else
12629|      6|        can_stop = (item_flags & ImGuiItemFlags_NoTabStop) == 0 && ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) || (item_flags & ImGuiItemFlags_Inputable));
  ------------------
  |  Branch (12629:20): [True: 6, False: 0]
  |  Branch (12629:69): [True: 6, False: 0]
  |  Branch (12629:128): [True: 0, False: 0]
  ------------------
12630|       |
12631|       |    // Always store in NavMoveResultLocal (unlike directional request which uses NavMoveResultOther on sibling/flattened windows)
12632|      6|    ImGuiNavItemData* result = &g.NavMoveResultLocal;
12633|      6|    if (g.NavTabbingDir == +1)
  ------------------
  |  Branch (12633:9): [True: 6, False: 0]
  ------------------
12634|      6|    {
12635|       |        // Tab Forward or SetKeyboardFocusHere() with >= 0
12636|      6|        if (can_stop && g.NavTabbingResultFirst.ID == 0)
  ------------------
  |  Branch (12636:13): [True: 6, False: 0]
  |  Branch (12636:25): [True: 6, False: 0]
  ------------------
12637|      6|            NavApplyItemToResult(&g.NavTabbingResultFirst);
12638|      6|        if (can_stop && g.NavTabbingCounter > 0 && --g.NavTabbingCounter == 0)
  ------------------
  |  Branch (12638:13): [True: 6, False: 0]
  |  Branch (12638:25): [True: 0, False: 6]
  |  Branch (12638:52): [True: 0, False: 0]
  ------------------
12639|      0|            NavMoveRequestResolveWithLastItem(result);
12640|      6|        else if (g.NavId == id)
  ------------------
  |  Branch (12640:18): [True: 6, False: 0]
  ------------------
12641|      6|            g.NavTabbingCounter = 1;
12642|      6|    }
12643|      0|    else if (g.NavTabbingDir == -1)
  ------------------
  |  Branch (12643:14): [True: 0, False: 0]
  ------------------
12644|      0|    {
12645|       |        // Tab Backward
12646|      0|        if (g.NavId == id)
  ------------------
  |  Branch (12646:13): [True: 0, False: 0]
  ------------------
12647|      0|        {
12648|      0|            if (result->ID)
  ------------------
  |  Branch (12648:17): [True: 0, False: 0]
  ------------------
12649|      0|            {
12650|      0|                g.NavMoveScoringItems = false;
12651|      0|                NavUpdateAnyRequestFlag();
12652|      0|            }
12653|      0|        }
12654|      0|        else if (can_stop)
  ------------------
  |  Branch (12654:18): [True: 0, False: 0]
  ------------------
12655|      0|        {
12656|       |            // Keep applying until reaching NavId
12657|      0|            NavApplyItemToResult(result);
12658|      0|        }
12659|      0|    }
12660|      0|    else if (g.NavTabbingDir == 0)
  ------------------
  |  Branch (12660:14): [True: 0, False: 0]
  ------------------
12661|      0|    {
12662|      0|        if (can_stop && g.NavId == id)
  ------------------
  |  Branch (12662:13): [True: 0, False: 0]
  |  Branch (12662:25): [True: 0, False: 0]
  ------------------
12663|      0|            NavMoveRequestResolveWithLastItem(result);
12664|      0|        if (can_stop && g.NavTabbingResultFirst.ID == 0) // Tab init
  ------------------
  |  Branch (12664:13): [True: 0, False: 0]
  |  Branch (12664:25): [True: 0, False: 0]
  ------------------
12665|      0|            NavApplyItemToResult(&g.NavTabbingResultFirst);
12666|      0|    }
12667|      6|}
imgui.cpp:_ZN5ImGuiL12NavScoreItemEP16ImGuiNavItemData:
12363|    341|{
12364|    341|    ImGuiContext& g = *GImGui;
12365|    341|    ImGuiWindow* window = g.CurrentWindow;
12366|    341|    if (g.NavLayer != window->DC.NavLayerCurrent)
  ------------------
  |  Branch (12366:9): [True: 181, False: 160]
  ------------------
12367|    181|        return false;
12368|       |
12369|       |    // FIXME: Those are not good variables names
12370|    160|    ImRect cand = g.LastItemData.NavRect;   // Current item nav rectangle
12371|    160|    const ImRect curr = g.NavScoringRect;   // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
12372|    160|    g.NavScoringDebugCount++;
12373|       |
12374|       |    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
12375|    160|    if (window->ParentWindow == g.NavWindow)
  ------------------
  |  Branch (12375:9): [True: 0, False: 160]
  ------------------
12376|      0|    {
12377|      0|        IM_ASSERT((window->ChildFlags | g.NavWindow->ChildFlags) & ImGuiChildFlags_NavFlattened);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12378|      0|        if (!window->ClipRect.Overlaps(cand))
  ------------------
  |  Branch (12378:13): [True: 0, False: 0]
  ------------------
12379|      0|            return false;
12380|      0|        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
12381|      0|    }
12382|       |
12383|       |    // Compute distance between boxes
12384|       |    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
12385|    160|    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
12386|    160|    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
12387|    160|    if (dby != 0.0f && dbx != 0.0f)
  ------------------
  |  Branch (12387:9): [True: 145, False: 15]
  |  Branch (12387:24): [True: 0, False: 145]
  ------------------
12388|      0|        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
  ------------------
  |  Branch (12388:34): [True: 0, False: 0]
  ------------------
12389|    160|    float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  451|    160|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_box = ImFabs(dbx) + ImFabs(dby);
  ------------------
  |  |  451|    160|#define ImFabs(X)           fabsf(X)
  ------------------
12390|       |
12391|       |    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
12392|    160|    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
12393|    160|    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
12394|    160|    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  451|    160|#define ImFabs(X)           fabsf(X)
  ------------------
                  float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)
  ------------------
  |  |  451|    160|#define ImFabs(X)           fabsf(X)
  ------------------
12395|       |
12396|       |    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
12397|    160|    ImGuiDir quadrant;
12398|    160|    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
12399|    160|    if (dbx != 0.0f || dby != 0.0f)
  ------------------
  |  Branch (12399:9): [True: 0, False: 160]
  |  Branch (12399:24): [True: 145, False: 15]
  ------------------
12400|    145|    {
12401|       |        // For non-overlapping boxes, use distance between boxes
12402|    145|        dax = dbx;
12403|    145|        day = dby;
12404|    145|        dist_axial = dist_box;
12405|    145|        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
12406|    145|    }
12407|     15|    else if (dcx != 0.0f || dcy != 0.0f)
  ------------------
  |  Branch (12407:14): [True: 15, False: 0]
  |  Branch (12407:29): [True: 0, False: 0]
  ------------------
12408|     15|    {
12409|       |        // For overlapping boxes with different centers, use distance between centers
12410|     15|        dax = dcx;
12411|     15|        day = dcy;
12412|     15|        dist_axial = dist_center;
12413|     15|        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
12414|     15|    }
12415|      0|    else
12416|      0|    {
12417|       |        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
12418|      0|        quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
  ------------------
  |  Branch (12418:20): [True: 0, False: 0]
  ------------------
12419|      0|    }
12420|       |
12421|    160|    const ImGuiDir move_dir = g.NavMoveDir;
12422|       |#if IMGUI_DEBUG_NAV_SCORING
12423|       |    char buf[200];
12424|       |    if (g.IO.KeyCtrl) // Hold CTRL to preview score in matching quadrant. CTRL+Arrow to rotate.
12425|       |    {
12426|       |        if (quadrant == move_dir)
12427|       |        {
12428|       |            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
12429|       |            ImDrawList* draw_list = GetForegroundDrawList(window);
12430|       |            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 80));
12431|       |            draw_list->AddRectFilled(cand.Min, cand.Min + CalcTextSize(buf), IM_COL32(255, 0, 0, 200));
12432|       |            draw_list->AddText(cand.Min, IM_COL32(255, 255, 255, 255), buf);
12433|       |        }
12434|       |    }
12435|       |    const bool debug_hovering = IsMouseHoveringRect(cand.Min, cand.Max);
12436|       |    const bool debug_tty = (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey_Space));
12437|       |    if (debug_hovering || debug_tty)
12438|       |    {
12439|       |        ImFormatString(buf, IM_ARRAYSIZE(buf),
12440|       |            "d-box    (%7.3f,%7.3f) -> %7.3f\nd-center (%7.3f,%7.3f) -> %7.3f\nd-axial  (%7.3f,%7.3f) -> %7.3f\nnav %c, quadrant %c",
12441|       |            dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "-WENS"[move_dir+1], "-WENS"[quadrant+1]);
12442|       |        if (debug_hovering)
12443|       |        {
12444|       |            ImDrawList* draw_list = GetForegroundDrawList(window);
12445|       |            draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
12446|       |            draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
12447|       |            draw_list->AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40, 0, 0, 200));
12448|       |            draw_list->AddText(cand.Max, ~0U, buf);
12449|       |        }
12450|       |        if (debug_tty) { IMGUI_DEBUG_LOG_NAV("id 0x%08X\n%s\n", g.LastItemData.ID, buf); }
12451|       |    }
12452|       |#endif
12453|       |
12454|       |    // Is it in the quadrant we're interested in moving to?
12455|    160|    bool new_best = false;
12456|    160|    if (quadrant == move_dir)
  ------------------
  |  Branch (12456:9): [True: 150, False: 10]
  ------------------
12457|    150|    {
12458|       |        // Does it beat the current best candidate?
12459|    150|        if (dist_box < result->DistBox)
  ------------------
  |  Branch (12459:13): [True: 150, False: 0]
  ------------------
12460|    150|        {
12461|    150|            result->DistBox = dist_box;
12462|    150|            result->DistCenter = dist_center;
12463|    150|            return true;
12464|    150|        }
12465|      0|        if (dist_box == result->DistBox)
  ------------------
  |  Branch (12465:13): [True: 0, False: 0]
  ------------------
12466|      0|        {
12467|       |            // Try using distance between center points to break ties
12468|      0|            if (dist_center < result->DistCenter)
  ------------------
  |  Branch (12468:17): [True: 0, False: 0]
  ------------------
12469|      0|            {
12470|      0|                result->DistCenter = dist_center;
12471|      0|                new_best = true;
12472|      0|            }
12473|      0|            else if (dist_center == result->DistCenter)
  ------------------
  |  Branch (12473:22): [True: 0, False: 0]
  ------------------
12474|      0|            {
12475|       |                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
12476|       |                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
12477|       |                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
12478|      0|                if (((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
  ------------------
  |  Branch (12478:21): [True: 0, False: 0]
  |  Branch (12478:23): [True: 0, False: 0]
  |  Branch (12478:50): [True: 0, False: 0]
  ------------------
12479|      0|                    new_best = true;
12480|      0|            }
12481|      0|        }
12482|      0|    }
12483|       |
12484|       |    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
12485|       |    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
12486|       |    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
12487|       |    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
12488|       |    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
12489|     10|    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
  ------------------
  |  Branch (12489:9): [True: 10, False: 0]
  |  Branch (12489:39): [True: 10, False: 0]
  ------------------
12490|     10|        if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (12490:13): [True: 0, False: 10]
  |  Branch (12490:49): [True: 0, False: 0]
  ------------------
12491|      0|            if ((move_dir == ImGuiDir_Left && dax < 0.0f) || (move_dir == ImGuiDir_Right && dax > 0.0f) || (move_dir == ImGuiDir_Up && day < 0.0f) || (move_dir == ImGuiDir_Down && day > 0.0f))
  ------------------
  |  Branch (12491:18): [True: 0, False: 0]
  |  Branch (12491:47): [True: 0, False: 0]
  |  Branch (12491:63): [True: 0, False: 0]
  |  Branch (12491:93): [True: 0, False: 0]
  |  Branch (12491:109): [True: 0, False: 0]
  |  Branch (12491:136): [True: 0, False: 0]
  |  Branch (12491:152): [True: 0, False: 0]
  |  Branch (12491:181): [True: 0, False: 0]
  ------------------
12492|      0|            {
12493|      0|                result->DistAxial = dist_axial;
12494|      0|                new_best = true;
12495|      0|            }
12496|       |
12497|     10|    return new_best;
12498|    160|}
imgui.cpp:_ZL24NavScoreItemDistIntervalffff:
12353|    320|{
12354|    320|    if (cand_max < curr_min)
  ------------------
  |  Branch (12354:9): [True: 122, False: 198]
  ------------------
12355|    122|        return cand_max - curr_min;
12356|    198|    if (curr_max < cand_min)
  ------------------
  |  Branch (12356:9): [True: 23, False: 175]
  ------------------
12357|     23|        return cand_min - curr_max;
12358|    175|    return 0.0f;
12359|    198|}
imgui.cpp:_ZL25ImGetDirQuadrantFromDeltaff:
12346|    160|{
12347|    160|    if (ImFabs(dx) > ImFabs(dy))
  ------------------
  |  |  451|    160|#define ImFabs(X)           fabsf(X)
  ------------------
                  if (ImFabs(dx) > ImFabs(dy))
  ------------------
  |  |  451|    160|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (12347:9): [True: 11, False: 149]
  ------------------
12348|     11|        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
  ------------------
  |  Branch (12348:16): [True: 11, False: 0]
  ------------------
12349|    149|    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
  ------------------
  |  Branch (12349:12): [True: 27, False: 122]
  ------------------
12350|    160|}
imgui.cpp:_ZN5ImGuiL28NavRestoreLastChildNavWindowEP11ImGuiWindow:
12768|     18|{
12769|     18|    if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
  ------------------
  |  Branch (12769:9): [True: 18, False: 0]
  |  Branch (12769:42): [True: 18, False: 0]
  ------------------
12770|     18|        return window->NavLastChildNavWindow;
12771|      0|    if (window->DockNodeAsHost && window->DockNodeAsHost->TabBar)
  ------------------
  |  Branch (12771:9): [True: 0, False: 0]
  |  Branch (12771:35): [True: 0, False: 0]
  ------------------
12772|      0|        if (ImGuiTabItem* tab = TabBarFindMostRecentlySelectedTabForActiveWindow(window->DockNodeAsHost->TabBar))
  ------------------
  |  Branch (12772:27): [True: 0, False: 0]
  ------------------
12773|      0|            return tab->Window;
12774|      0|    return window;
12775|      0|}
imgui.cpp:_ZN5ImGuiL23NavUpdateAnyRequestFlagEv:
12808|  83.8k|{
12809|  83.8k|    ImGuiContext& g = *GImGui;
12810|  83.8k|    g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
  ------------------
  |  | 1100|   165k|#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
  |  |  ------------------
  |  |  |  Branch (1100:37): [Folded - Ignored]
  |  |  ------------------
  ------------------
  |  Branch (12810:23): [True: 1.03k, False: 82.8k]
  |  Branch (12810:48): [True: 145, False: 82.7k]
  |  Branch (12810:96): [True: 0, False: 0]
  ------------------
12811|  83.8k|    if (g.NavAnyRequest)
  ------------------
  |  Branch (12811:9): [True: 1.18k, False: 82.7k]
  ------------------
12812|  83.8k|        IM_ASSERT(g.NavWindow != NULL);
  ------------------
  |  |   23|  83.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12813|  83.8k|}
imgui.cpp:_ZN5ImGuiL9NavUpdateEv:
12908|  76.6k|{
12909|  76.6k|    ImGuiContext& g = *GImGui;
12910|  76.6k|    ImGuiIO& io = g.IO;
12911|       |
12912|  76.6k|    io.WantSetMousePos = false;
12913|       |    //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
12914|       |
12915|       |    // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
12916|       |    // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
12917|  76.6k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (12917:37): [True: 76.6k, False: 0]
  |  Branch (12917:98): [True: 0, False: 76.6k]
  ------------------
12918|  76.6k|    const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
12919|  76.6k|    if (nav_gamepad_active)
  ------------------
  |  Branch (12919:9): [True: 0, False: 76.6k]
  ------------------
12920|      0|        for (ImGuiKey key : nav_gamepad_keys_to_change_source)
  ------------------
  |  Branch (12920:27): [True: 0, False: 0]
  ------------------
12921|      0|            if (IsKeyDown(key))
  ------------------
  |  Branch (12921:17): [True: 0, False: 0]
  ------------------
12922|      0|                g.NavInputSource = ImGuiInputSource_Gamepad;
12923|  76.6k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
12924|  76.6k|    const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
12925|  76.6k|    if (nav_keyboard_active)
  ------------------
  |  Branch (12925:9): [True: 76.6k, False: 0]
  ------------------
12926|  76.6k|        for (ImGuiKey key : nav_keyboard_keys_to_change_source)
  ------------------
  |  Branch (12926:27): [True: 536k, False: 76.6k]
  ------------------
12927|   536k|            if (IsKeyDown(key))
  ------------------
  |  Branch (12927:17): [True: 48.9k, False: 487k]
  ------------------
12928|  48.9k|                g.NavInputSource = ImGuiInputSource_Keyboard;
12929|       |
12930|       |    // Process navigation init request (select first/default focus)
12931|  76.6k|    g.NavJustMovedToId = 0;
12932|  76.6k|    if (g.NavInitResult.ID != 0)
  ------------------
  |  Branch (12932:9): [True: 68, False: 76.6k]
  ------------------
12933|     68|        NavInitRequestApplyResult();
12934|  76.6k|    g.NavInitRequest = false;
12935|  76.6k|    g.NavInitRequestFromMove = false;
12936|  76.6k|    g.NavInitResult.ID = 0;
12937|       |
12938|       |    // Process navigation move request
12939|  76.6k|    if (g.NavMoveSubmitted)
  ------------------
  |  Branch (12939:9): [True: 358, False: 76.3k]
  ------------------
12940|    358|        NavMoveRequestApplyResult();
12941|  76.6k|    g.NavTabbingCounter = 0;
12942|  76.6k|    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
12943|       |
12944|       |    // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
12945|  76.6k|    bool set_mouse_pos = false;
12946|  76.6k|    if (g.NavMousePosDirty && g.NavIdIsAlive)
  ------------------
  |  Branch (12946:9): [True: 836, False: 75.8k]
  |  Branch (12946:31): [True: 189, False: 647]
  ------------------
12947|    189|        if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
  ------------------
  |  Branch (12947:13): [True: 189, False: 0]
  |  Branch (12947:39): [True: 177, False: 12]
  |  Branch (12947:65): [True: 177, False: 0]
  ------------------
12948|    177|            set_mouse_pos = true;
12949|  76.6k|    g.NavMousePosDirty = false;
12950|  76.6k|    IM_ASSERT(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12951|       |
12952|       |    // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
12953|  76.6k|    if (g.NavWindow)
  ------------------
  |  Branch (12953:9): [True: 7.51k, False: 69.1k]
  ------------------
12954|  7.51k|        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
12955|  76.6k|    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (12955:9): [True: 7.51k, False: 69.1k]
  |  Branch (12955:24): [True: 216, False: 7.29k]
  |  Branch (12955:70): [True: 140, False: 76]
  ------------------
12956|    140|        g.NavWindow->NavLastChildNavWindow = NULL;
12957|       |
12958|       |    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
12959|  76.6k|    NavUpdateWindowing();
12960|       |
12961|       |    // Set output flags for user application
12962|  76.6k|    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
  ------------------
  |  Branch (12962:21): [True: 76.6k, False: 0]
  |  Branch (12962:44): [True: 0, False: 0]
  |  Branch (12962:67): [True: 7.51k, False: 69.1k]
  |  Branch (12962:82): [True: 7.51k, False: 0]
  ------------------
12963|  76.6k|    io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);
  ------------------
  |  Branch (12963:22): [True: 7.51k, False: 69.1k]
  |  Branch (12963:38): [True: 691, False: 6.82k]
  |  Branch (12963:54): [True: 641, False: 50]
  |  Branch (12963:81): [True: 0, False: 76.0k]
  ------------------
12964|       |
12965|       |    // Process NavCancel input (to close a popup, get back to parent, clear focus)
12966|  76.6k|    NavUpdateCancelRequest();
12967|       |
12968|       |    // Process manual activation request
12969|  76.6k|    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = 0;
12970|  76.6k|    g.NavActivateFlags = ImGuiActivateFlags_None;
12971|  76.6k|    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (12971:9): [True: 825, False: 75.8k]
  |  Branch (12971:25): [True: 775, False: 50]
  |  Branch (12971:51): [True: 775, False: 0]
  |  Branch (12971:76): [True: 775, False: 0]
  |  Branch (12971:91): [True: 775, False: 0]
  ------------------
12972|    775|    {
12973|    775|        const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_NoOwner));
  ------------------
  |  | 1434|    775|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                      const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_NoOwner));
  ------------------
  |  | 1375|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
                      const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_NoOwner));
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12973:37): [True: 775, False: 0]
  |  Branch (12973:60): [True: 30, False: 745]
  |  Branch (12973:114): [True: 0, False: 745]
  |  Branch (12973:136): [True: 0, False: 0]
  ------------------
12974|    775|        const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, 0, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, 0, ImGuiKeyOwner_NoOwner)));
  ------------------
  |  | 1434|     30|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                      const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, 0, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, 0, ImGuiKeyOwner_NoOwner)));
  ------------------
  |  | 1375|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
                      const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, 0, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, 0, ImGuiKeyOwner_NoOwner)));
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12974:39): [True: 30, False: 745]
  |  Branch (12974:58): [True: 30, False: 0]
  |  Branch (12974:81): [True: 8, False: 22]
  |  Branch (12974:141): [True: 0, False: 22]
  |  Branch (12974:163): [True: 0, False: 0]
  ------------------
12975|    775|        const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner));
  ------------------
  |  | 1434|    775|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                      const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner));
  ------------------
  |  | 1434|    721|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                      const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner));
  ------------------
  |  | 1378|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
                      const bool input_down = (nav_keyboard_active && (IsKeyDown(ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner));
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12975:34): [True: 775, False: 0]
  |  Branch (12975:58): [True: 54, False: 721]
  |  Branch (12975:110): [True: 0, False: 721]
  |  Branch (12975:171): [True: 0, False: 721]
  |  Branch (12975:193): [True: 0, False: 0]
  ------------------
12976|    775|        const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey_KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)));
  ------------------
  |  | 1434|     54|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                      const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey_KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)));
  ------------------
  |  | 1434|     44|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                      const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey_KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)));
  ------------------
  |  | 1378|      0|#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp
  ------------------
                      const bool input_pressed = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey_Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey_KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)));
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (12976:36): [True: 54, False: 721]
  |  Branch (12976:52): [True: 54, False: 0]
  |  Branch (12976:76): [True: 10, False: 44]
  |  Branch (12976:134): [True: 0, False: 44]
  |  Branch (12976:201): [True: 0, False: 44]
  |  Branch (12976:223): [True: 0, False: 0]
  ------------------
12977|    775|        if (g.ActiveId == 0 && activate_pressed)
  ------------------
  |  Branch (12977:13): [True: 774, False: 1]
  |  Branch (12977:32): [True: 8, False: 766]
  ------------------
12978|      8|        {
12979|      8|            g.NavActivateId = g.NavId;
12980|      8|            g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
12981|      8|        }
12982|    775|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed)
  ------------------
  |  Branch (12982:14): [True: 774, False: 1]
  |  Branch (12982:33): [True: 0, False: 1]
  |  Branch (12982:59): [True: 10, False: 764]
  ------------------
12983|     10|        {
12984|     10|            g.NavActivateId = g.NavId;
12985|     10|            g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
12986|     10|        }
12987|    775|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down))
  ------------------
  |  Branch (12987:14): [True: 774, False: 1]
  |  Branch (12987:33): [True: 0, False: 1]
  |  Branch (12987:60): [True: 30, False: 744]
  |  Branch (12987:77): [True: 54, False: 690]
  ------------------
12988|     84|            g.NavActivateDownId = g.NavId;
12989|    775|        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed))
  ------------------
  |  Branch (12989:14): [True: 774, False: 1]
  |  Branch (12989:33): [True: 0, False: 1]
  |  Branch (12989:60): [True: 8, False: 766]
  |  Branch (12989:80): [True: 10, False: 756]
  ------------------
12990|     18|        {
12991|     18|            g.NavActivatePressedId = g.NavId;
12992|     18|            NavHighlightActivated(g.NavId);
12993|     18|        }
12994|    775|    }
12995|  76.6k|    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (12995:9): [True: 7.51k, False: 69.1k]
  |  Branch (12995:24): [True: 0, False: 7.51k]
  ------------------
12996|      0|        g.NavDisableHighlight = true;
12997|  76.6k|    if (g.NavActivateId != 0)
  ------------------
  |  Branch (12997:9): [True: 18, False: 76.6k]
  ------------------
12998|  76.6k|        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
12999|       |
13000|       |    // Highlight
13001|  76.6k|    if (g.NavHighlightActivatedTimer > 0.0f)
  ------------------
  |  Branch (13001:9): [True: 96, False: 76.6k]
  ------------------
13002|     96|        g.NavHighlightActivatedTimer = ImMax(0.0f, g.NavHighlightActivatedTimer - io.DeltaTime);
13003|  76.6k|    if (g.NavHighlightActivatedTimer == 0.0f)
  ------------------
  |  Branch (13003:9): [True: 76.6k, False: 88]
  ------------------
13004|  76.6k|        g.NavHighlightActivatedId = 0;
13005|       |
13006|       |    // Process programmatic activation request
13007|       |    // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
13008|  76.6k|    if (g.NavNextActivateId != 0)
  ------------------
  |  Branch (13008:9): [True: 0, False: 76.6k]
  ------------------
13009|      0|    {
13010|      0|        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
13011|      0|        g.NavActivateFlags = g.NavNextActivateFlags;
13012|      0|    }
13013|  76.6k|    g.NavNextActivateId = 0;
13014|       |
13015|       |    // Process move requests
13016|  76.6k|    NavUpdateCreateMoveRequest();
13017|  76.6k|    if (g.NavMoveDir == ImGuiDir_None)
  ------------------
  |  Branch (13017:9): [True: 76.2k, False: 447]
  ------------------
13018|  76.2k|        NavUpdateCreateTabbingRequest();
13019|  76.6k|    NavUpdateAnyRequestFlag();
13020|  76.6k|    g.NavIdIsAlive = false;
13021|       |
13022|       |    // Scrolling
13023|  76.6k|    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
  ------------------
  |  Branch (13023:9): [True: 7.51k, False: 69.1k]
  |  Branch (13023:24): [True: 7.51k, False: 0]
  |  Branch (13023:80): [True: 7.51k, False: 0]
  ------------------
13024|  7.51k|    {
13025|       |        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
13026|  7.51k|        ImGuiWindow* window = g.NavWindow;
13027|  7.51k|        const float scroll_speed = IM_ROUND(window->CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
  ------------------
  |  |  288|  7.51k|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
13028|  7.51k|        const ImGuiDir move_dir = g.NavMoveDir;
13029|  7.51k|        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY && move_dir != ImGuiDir_None)
  ------------------
  |  Branch (13029:13): [True: 6.44k, False: 1.07k]
  |  Branch (13029:55): [True: 5.93k, False: 509]
  |  Branch (13029:89): [True: 313, False: 5.61k]
  ------------------
13030|    313|        {
13031|    313|            if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
  ------------------
  |  Branch (13031:17): [True: 47, False: 266]
  |  Branch (13031:46): [True: 57, False: 209]
  ------------------
13032|    104|                SetScrollX(window, ImTrunc(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (13032:64): [True: 47, False: 57]
  ------------------
13033|    313|            if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
  ------------------
  |  Branch (13033:17): [True: 8, False: 305]
  |  Branch (13033:44): [True: 201, False: 104]
  ------------------
13034|    209|                SetScrollY(window, ImTrunc(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
  ------------------
  |  Branch (13034:64): [True: 8, False: 201]
  ------------------
13035|    313|        }
13036|       |
13037|       |        // *Normal* Manual scroll with LStick
13038|       |        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
13039|  7.51k|        if (nav_gamepad_active)
  ------------------
  |  Branch (13039:13): [True: 0, False: 7.51k]
  ------------------
13040|      0|        {
13041|      0|            const ImVec2 scroll_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
13042|      0|            const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1373|      0|#define ImGuiKey_NavGamepadTweakSlow    ImGuiKey_GamepadL1
  ------------------
                          const float tweak_factor = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0f : 1.0f;
  ------------------
  |  | 1374|      0|#define ImGuiKey_NavGamepadTweakFast    ImGuiKey_GamepadR1
  ------------------
  |  Branch (13042:40): [True: 0, False: 0]
  |  Branch (13042:97): [True: 0, False: 0]
  ------------------
13043|      0|            if (scroll_dir.x != 0.0f && window->ScrollbarX)
  ------------------
  |  Branch (13043:17): [True: 0, False: 0]
  |  Branch (13043:41): [True: 0, False: 0]
  ------------------
13044|      0|                SetScrollX(window, ImTrunc(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
13045|      0|            if (scroll_dir.y != 0.0f)
  ------------------
  |  Branch (13045:17): [True: 0, False: 0]
  ------------------
13046|      0|                SetScrollY(window, ImTrunc(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
13047|      0|        }
13048|  7.51k|    }
13049|       |
13050|       |    // Always prioritize mouse highlight if navigation is disabled
13051|  76.6k|    if (!nav_keyboard_active && !nav_gamepad_active)
  ------------------
  |  Branch (13051:9): [True: 0, False: 76.6k]
  |  Branch (13051:33): [True: 0, False: 0]
  ------------------
13052|      0|    {
13053|      0|        g.NavDisableHighlight = true;
13054|      0|        g.NavDisableMouseHover = set_mouse_pos = false;
13055|      0|    }
13056|       |
13057|       |    // Update mouse position if requested
13058|       |    // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
13059|  76.6k|    if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
  ------------------
  |  Branch (13059:9): [True: 177, False: 76.5k]
  |  Branch (13059:26): [True: 0, False: 177]
  |  Branch (13059:86): [True: 0, False: 0]
  ------------------
13060|      0|        TeleportMousePos(NavCalcPreferredRefPos());
13061|       |
13062|       |    // [DEBUG]
13063|  76.6k|    g.NavScoringDebugCount = 0;
13064|       |#if IMGUI_DEBUG_NAV_RECTS
13065|       |    if (ImGuiWindow* debug_window = g.NavWindow)
13066|       |    {
13067|       |        ImDrawList* draw_list = GetForegroundDrawList(debug_window);
13068|       |        int layer = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/ { ImRect r = WindowRectRelToAbs(debug_window, debug_window->NavRectRel[layer]); draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 200, 0, 255)); }
13069|       |        //if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
13070|       |    }
13071|       |#endif
13072|  76.6k|}
imgui.cpp:_ZN5ImGuiL35NavSaveLastChildNavWindowIntoParentEP11ImGuiWindow:
12757|  7.51k|{
12758|  7.51k|    ImGuiWindow* parent = nav_window;
12759|  14.1k|    while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (12759:12): [True: 14.1k, False: 0]
  |  Branch (12759:22): [True: 6.63k, False: 7.51k]
  |  Branch (12759:54): [True: 6.63k, False: 0]
  ------------------
12760|  6.63k|        parent = parent->ParentWindow;
12761|  7.51k|    if (parent && parent != nav_window)
  ------------------
  |  Branch (12761:9): [True: 7.51k, False: 0]
  |  Branch (12761:19): [True: 6.63k, False: 873]
  ------------------
12762|  6.63k|        parent->NavLastChildNavWindow = nav_window;
12763|  7.51k|}
imgui.cpp:_ZN5ImGuiL18NavUpdateWindowingEv:
13624|  76.6k|{
13625|  76.6k|    ImGuiContext& g = *GImGui;
13626|  76.6k|    ImGuiIO& io = g.IO;
13627|       |
13628|  76.6k|    ImGuiWindow* apply_focus_window = NULL;
13629|  76.6k|    bool apply_toggle_layer = false;
13630|       |
13631|  76.6k|    ImGuiWindow* modal_window = GetTopMostPopupModal();
13632|  76.6k|    bool allow_windowing = (modal_window == NULL); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
13633|  76.6k|    if (!allow_windowing)
  ------------------
  |  Branch (13633:9): [True: 0, False: 76.6k]
  ------------------
13634|      0|        g.NavWindowingTarget = NULL;
13635|       |
13636|       |    // Fade out
13637|  76.6k|    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
  ------------------
  |  Branch (13637:9): [True: 0, False: 76.6k]
  |  Branch (13637:37): [True: 0, False: 0]
  ------------------
13638|      0|    {
13639|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
13640|      0|        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
  ------------------
  |  Branch (13640:13): [True: 0, False: 0]
  |  Branch (13640:37): [True: 0, False: 0]
  ------------------
13641|      0|            g.NavWindowingTargetAnim = NULL;
13642|      0|    }
13643|       |
13644|       |    // Start CTRL+Tab or Square+L/R window selection
13645|       |    // (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiMod_Ctrl|ImGuiKey_Tab and ImGuiMod_Ctrl|ImGuiMod_Shift|ImGuiKey_Tab)
13646|  76.6k|    const ImGuiID owner_id = ImHashStr("###NavUpdateWindowing");
13647|  76.6k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (13647:37): [True: 76.6k, False: 0]
  |  Branch (13647:98): [True: 0, False: 76.6k]
  ------------------
13648|  76.6k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
13649|  76.6k|    const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
  ------------------
  |  Branch (13649:39): [True: 76.6k, False: 0]
  |  Branch (13649:58): [True: 76.6k, False: 0]
  |  Branch (13649:89): [True: 0, False: 76.6k]
  ------------------
13650|  76.6k|    const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
  ------------------
  |  Branch (13650:39): [True: 76.6k, False: 0]
  |  Branch (13650:58): [True: 76.6k, False: 0]
  |  Branch (13650:89): [True: 0, False: 76.6k]
  ------------------
13651|  76.6k|    const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, ImGuiInputFlags_None);
  ------------------
  |  | 1377|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (13651:47): [True: 76.6k, False: 0]
  |  Branch (13651:66): [True: 0, False: 76.6k]
  |  Branch (13651:88): [True: 0, False: 0]
  |  Branch (13651:113): [True: 0, False: 0]
  ------------------
13652|  76.6k|    const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
  ------------------
  |  Branch (13652:48): [True: 76.6k, False: 0]
  |  Branch (13652:67): [True: 76.6k, False: 0]
  |  Branch (13652:93): [True: 0, False: 76.6k]
  |  Branch (13652:117): [True: 0, False: 76.6k]
  ------------------
13653|  76.6k|    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
  ------------------
  |  Branch (13653:9): [True: 0, False: 76.6k]
  |  Branch (13653:41): [True: 0, False: 76.6k]
  ------------------
13654|      0|        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
  ------------------
  |  Branch (13654:26): [True: 0, False: 0]
  ------------------
13655|      0|        {
13656|      0|            g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
13657|      0|            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
13658|      0|            g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
13659|      0|            g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
  ------------------
  |  Branch (13659:41): [True: 0, False: 0]
  ------------------
13660|      0|            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
  ------------------
  |  Branch (13660:32): [True: 0, False: 0]
  ------------------
13661|       |
13662|       |            // Manually register ownership of our mods. Using a global route in the Shortcut() calls instead would probably be correct but may have more side-effects.
13663|      0|            if (keyboard_next_window || keyboard_prev_window)
  ------------------
  |  Branch (13663:17): [True: 0, False: 0]
  |  Branch (13663:41): [True: 0, False: 0]
  ------------------
13664|      0|                SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiMod_Mask_, owner_id);
13665|      0|        }
13666|       |
13667|       |    // Gamepad update
13668|  76.6k|    g.NavWindowingTimer += io.DeltaTime;
13669|  76.6k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (13669:9): [True: 0, False: 76.6k]
  |  Branch (13669:33): [True: 0, False: 0]
  ------------------
13670|      0|    {
13671|       |        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
13672|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
13673|       |
13674|       |        // Select window to focus
13675|      0|        const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
13676|      0|        if (focus_change_dir != 0)
  ------------------
  |  Branch (13676:13): [True: 0, False: 0]
  ------------------
13677|      0|        {
13678|      0|            NavUpdateWindowingHighlightWindow(focus_change_dir);
13679|      0|            g.NavWindowingHighlightAlpha = 1.0f;
13680|      0|        }
13681|       |
13682|       |        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
13683|      0|        if (!IsKeyDown(ImGuiKey_NavGamepadMenu))
  ------------------
  |  | 1377|      0|#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
  ------------------
  |  Branch (13683:13): [True: 0, False: 0]
  ------------------
13684|      0|        {
13685|      0|            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
13686|      0|            if (g.NavWindowingToggleLayer && g.NavWindow)
  ------------------
  |  Branch (13686:17): [True: 0, False: 0]
  |  Branch (13686:46): [True: 0, False: 0]
  ------------------
13687|      0|                apply_toggle_layer = true;
13688|      0|            else if (!g.NavWindowingToggleLayer)
  ------------------
  |  Branch (13688:22): [True: 0, False: 0]
  ------------------
13689|      0|                apply_focus_window = g.NavWindowingTarget;
13690|      0|            g.NavWindowingTarget = NULL;
13691|      0|        }
13692|      0|    }
13693|       |
13694|       |    // Keyboard: Focus
13695|  76.6k|    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (13695:9): [True: 0, False: 76.6k]
  |  Branch (13695:33): [True: 0, False: 0]
  ------------------
13696|      0|    {
13697|       |        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
13698|      0|        ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
  ------------------
  |  Branch (13698:39): [True: 0, False: 0]
  |  Branch (13698:118): [True: 0, False: 0]
  ------------------
13699|      0|        IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13700|      0|        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
13701|      0|        if (keyboard_next_window || keyboard_prev_window)
  ------------------
  |  Branch (13701:13): [True: 0, False: 0]
  |  Branch (13701:37): [True: 0, False: 0]
  ------------------
13702|      0|            NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
  ------------------
  |  Branch (13702:47): [True: 0, False: 0]
  ------------------
13703|      0|        else if ((io.KeyMods & shared_mods) != shared_mods)
  ------------------
  |  Branch (13703:18): [True: 0, False: 0]
  ------------------
13704|      0|            apply_focus_window = g.NavWindowingTarget;
13705|      0|    }
13706|       |
13707|       |    // Keyboard: Press and Release ALT to toggle menu layer
13708|  76.6k|    const ImGuiKey windowing_toggle_keys[] = { ImGuiKey_LeftAlt, ImGuiKey_RightAlt };
13709|  76.6k|    for (ImGuiKey windowing_toggle_key : windowing_toggle_keys)
  ------------------
  |  Branch (13709:40): [True: 153k, False: 75.9k]
  ------------------
13710|   153k|        if (nav_keyboard_active && IsKeyPressed(windowing_toggle_key, 0, ImGuiKeyOwner_NoOwner))
  ------------------
  |  | 1434|   153k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13710:13): [True: 153k, False: 0]
  |  Branch (13710:36): [True: 749, False: 152k]
  ------------------
13711|    749|        {
13712|    749|            g.NavWindowingToggleLayer = true;
13713|    749|            g.NavWindowingToggleKey = windowing_toggle_key;
13714|    749|            g.NavInputSource = ImGuiInputSource_Keyboard;
13715|    749|            break;
13716|    749|        }
13717|  76.6k|    if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
  ------------------
  |  Branch (13717:9): [True: 2.50k, False: 74.1k]
  |  Branch (13717:38): [True: 2.50k, False: 0]
  ------------------
13718|  2.50k|    {
13719|       |        // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
13720|       |        // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
13721|       |        // - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
13722|       |        // We cancel toggling nav layer if an owner has claimed the key.
13723|  2.50k|        if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper)
  ------------------
  |  Branch (13723:13): [True: 70, False: 2.43k]
  |  Branch (13723:49): [True: 0, False: 2.43k]
  |  Branch (13723:63): [True: 0, False: 2.43k]
  |  Branch (13723:78): [True: 0, False: 2.43k]
  ------------------
13724|     70|            g.NavWindowingToggleLayer = false;
13725|  2.50k|        if (TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_NoOwner) == false || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_NoOwner) == false)
  ------------------
  |  | 1434|  2.50k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                      if (TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_NoOwner) == false || TestKeyOwner(ImGuiMod_Alt, ImGuiKeyOwner_NoOwner) == false)
  ------------------
  |  | 1434|  2.50k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13725:13): [True: 0, False: 2.50k]
  |  Branch (13725:86): [True: 0, False: 2.50k]
  ------------------
13726|      0|            g.NavWindowingToggleLayer = false;
13727|       |
13728|       |        // Apply layer toggle on Alt release
13729|       |        // Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
13730|  2.50k|        if (IsKeyReleased(g.NavWindowingToggleKey) && g.NavWindowingToggleLayer)
  ------------------
  |  Branch (13730:13): [True: 611, False: 1.89k]
  |  Branch (13730:55): [True: 550, False: 61]
  ------------------
13731|    550|            if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
  ------------------
  |  Branch (13731:17): [True: 550, False: 0]
  |  Branch (13731:36): [True: 0, False: 0]
  ------------------
13732|    550|                if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
  ------------------
  |  Branch (13732:21): [True: 549, False: 1]
  ------------------
13733|    549|                    apply_toggle_layer = true;
13734|  2.50k|        if (!IsKeyDown(g.NavWindowingToggleKey))
  ------------------
  |  Branch (13734:13): [True: 732, False: 1.76k]
  ------------------
13735|    732|            g.NavWindowingToggleLayer = false;
13736|  2.50k|    }
13737|       |
13738|       |    // Move window
13739|  76.6k|    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
  ------------------
  |  Branch (13739:9): [True: 0, False: 76.6k]
  |  Branch (13739:33): [True: 0, False: 0]
  ------------------
13740|      0|    {
13741|      0|        ImVec2 nav_move_dir;
13742|      0|        if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
  ------------------
  |  Branch (13742:13): [True: 0, False: 0]
  |  Branch (13742:62): [True: 0, False: 0]
  ------------------
13743|      0|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
13744|      0|        if (g.NavInputSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (13744:13): [True: 0, False: 0]
  ------------------
13745|      0|            nav_move_dir = GetKeyMagnitude2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
13746|      0|        if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
  ------------------
  |  Branch (13746:13): [True: 0, False: 0]
  |  Branch (13746:39): [True: 0, False: 0]
  ------------------
13747|      0|        {
13748|      0|            const float NAV_MOVE_SPEED = 800.0f;
13749|      0|            const float move_step = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
13750|      0|            g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
13751|      0|            g.NavDisableMouseHover = true;
13752|      0|            ImVec2 accum_floored = ImTrunc(g.NavWindowingAccumDeltaPos);
13753|      0|            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
  ------------------
  |  Branch (13753:17): [True: 0, False: 0]
  |  Branch (13753:44): [True: 0, False: 0]
  ------------------
13754|      0|            {
13755|      0|                ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindowDockTree;
13756|      0|                SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
13757|      0|                g.NavWindowingAccumDeltaPos -= accum_floored;
13758|      0|            }
13759|      0|        }
13760|      0|    }
13761|       |
13762|       |    // Apply final focus
13763|  76.6k|    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
  ------------------
  |  Branch (13763:9): [True: 0, False: 76.6k]
  |  Branch (13763:32): [True: 0, False: 0]
  |  Branch (13763:55): [True: 0, False: 0]
  ------------------
13764|      0|    {
13765|       |        // FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
13766|       |        // Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
13767|      0|        ImGuiViewport* previous_viewport = g.NavWindow ? g.NavWindow->Viewport : NULL;
  ------------------
  |  Branch (13767:44): [True: 0, False: 0]
  ------------------
13768|      0|        ClearActiveID();
13769|      0|        NavRestoreHighlightAfterMove();
13770|      0|        ClosePopupsOverWindow(apply_focus_window, false);
13771|      0|        FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_RestoreFocusedChild);
13772|      0|        apply_focus_window = g.NavWindow;
13773|      0|        if (apply_focus_window->NavLastIds[0] == 0)
  ------------------
  |  Branch (13773:13): [True: 0, False: 0]
  ------------------
13774|      0|            NavInitWindow(apply_focus_window, false);
13775|       |
13776|       |        // If the window has ONLY a menu layer (no main layer), select it directly
13777|       |        // Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
13778|       |        // so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
13779|       |        // the target window as already been previewed once.
13780|       |        // FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
13781|       |        // we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
13782|       |        // won't be valid.
13783|      0|        if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
  ------------------
  |  Branch (13783:13): [True: 0, False: 0]
  ------------------
13784|      0|            g.NavLayer = ImGuiNavLayer_Menu;
13785|       |
13786|       |        // Request OS level focus
13787|      0|        if (apply_focus_window->Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus)
  ------------------
  |  Branch (13787:13): [True: 0, False: 0]
  |  Branch (13787:66): [True: 0, False: 0]
  ------------------
13788|      0|            g.PlatformIO.Platform_SetWindowFocus(apply_focus_window->Viewport);
13789|      0|    }
13790|  76.6k|    if (apply_focus_window)
  ------------------
  |  Branch (13790:9): [True: 0, False: 76.6k]
  ------------------
13791|      0|        g.NavWindowingTarget = NULL;
13792|       |
13793|       |    // Apply menu/layer toggle
13794|  76.6k|    if (apply_toggle_layer && g.NavWindow)
  ------------------
  |  Branch (13794:9): [True: 549, False: 76.1k]
  |  Branch (13794:31): [True: 63, False: 486]
  ------------------
13795|     63|    {
13796|     63|        ClearActiveID();
13797|       |
13798|       |        // Move to parent menu if necessary
13799|     63|        ImGuiWindow* new_nav_window = g.NavWindow;
13800|    109|        while (new_nav_window->ParentWindow
  ------------------
  |  Branch (13800:16): [True: 46, False: 63]
  ------------------
13801|    109|            && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
  ------------------
  |  Branch (13801:16): [True: 46, False: 0]
  ------------------
13802|    109|            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
  ------------------
  |  Branch (13802:16): [True: 46, False: 0]
  ------------------
13803|    109|            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
  ------------------
  |  Branch (13803:16): [True: 46, False: 0]
  ------------------
13804|     46|            new_nav_window = new_nav_window->ParentWindow;
13805|     63|        if (new_nav_window != g.NavWindow)
  ------------------
  |  Branch (13805:13): [True: 46, False: 17]
  ------------------
13806|     46|        {
13807|     46|            ImGuiWindow* old_nav_window = g.NavWindow;
13808|     46|            FocusWindow(new_nav_window);
13809|     46|            new_nav_window->NavLastChildNavWindow = old_nav_window;
13810|     46|        }
13811|       |
13812|       |        // Toggle layer
13813|     63|        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
  ------------------
  |  Branch (13813:45): [True: 63, False: 0]
  ------------------
13814|     63|        if (new_nav_layer != g.NavLayer)
  ------------------
  |  Branch (13814:13): [True: 63, False: 0]
  ------------------
13815|     63|        {
13816|       |            // Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
13817|     63|            const bool preserve_layer_1_nav_id = (new_nav_window->DockNodeAsHost != NULL);
13818|     63|            if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id)
  ------------------
  |  Branch (13818:17): [True: 46, False: 17]
  |  Branch (13818:56): [True: 46, False: 0]
  ------------------
13819|     46|                g.NavWindow->NavLastIds[new_nav_layer] = 0;
13820|     63|            NavRestoreLayer(new_nav_layer);
13821|     63|            NavRestoreHighlightAfterMove();
13822|     63|        }
13823|     63|    }
13824|  76.6k|}
imgui.cpp:_ZN5ImGuiL15NavRestoreLayerE13ImGuiNavLayer:
12778|     64|{
12779|     64|    ImGuiContext& g = *GImGui;
12780|     64|    if (layer == ImGuiNavLayer_Main)
  ------------------
  |  Branch (12780:9): [True: 18, False: 46]
  ------------------
12781|     18|    {
12782|     18|        ImGuiWindow* prev_nav_window = g.NavWindow;
12783|     18|        g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);    // FIXME-NAV: Should clear ongoing nav requests?
12784|     18|        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1736|     18|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
12785|     18|        if (prev_nav_window)
  ------------------
  |  Branch (12785:13): [True: 18, False: 0]
  ------------------
12786|     18|            IMGUI_DEBUG_LOG_FOCUS("[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window->Name, g.NavWindow->Name);
  ------------------
  |  |  246|     18|#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (246:50): [True: 0, False: 18]
  |  |  |  Branch (246:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
12787|     18|    }
12788|     64|    ImGuiWindow* window = g.NavWindow;
12789|     64|    if (window->NavLastIds[layer] != 0)
  ------------------
  |  Branch (12789:9): [True: 1, False: 63]
  ------------------
12790|      1|    {
12791|      1|        SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
12792|      1|    }
12793|     63|    else
12794|     63|    {
12795|     63|        g.NavLayer = layer;
12796|     63|        NavInitWindow(window, true);
12797|     63|    }
12798|     64|}
imgui.cpp:_ZN5ImGuiL22NavUpdateCancelRequestEv:
13388|  76.6k|{
13389|  76.6k|    ImGuiContext& g = *GImGui;
13390|  76.6k|    const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (13390:37): [True: 76.6k, False: 0]
  |  Branch (13390:100): [True: 0, False: 76.6k]
  ------------------
13391|  76.6k|    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
13392|  76.6k|    if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, 0, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, 0, ImGuiKeyOwner_NoOwner)))
  ------------------
  |  | 1434|  76.6k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, 0, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, 0, ImGuiKeyOwner_NoOwner)))
  ------------------
  |  | 1376|      0|#define ImGuiKey_NavGamepadCancel       ImGuiKey_GamepadFaceRight
  ------------------
                  if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, 0, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, 0, ImGuiKeyOwner_NoOwner)))
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13392:11): [True: 76.6k, False: 0]
  |  Branch (13392:34): [True: 1.06k, False: 75.6k]
  |  Branch (13392:96): [True: 0, False: 75.6k]
  |  Branch (13392:118): [True: 0, False: 0]
  ------------------
13393|  75.6k|        return;
13394|       |
13395|  1.06k|    IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
  ------------------
  |  |  248|  1.06k|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 1.06k]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13396|  1.06k|    if (g.ActiveId != 0)
  ------------------
  |  Branch (13396:9): [True: 1, False: 1.05k]
  ------------------
13397|      1|    {
13398|      1|        ClearActiveID();
13399|      1|    }
13400|  1.05k|    else if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (13400:14): [True: 0, False: 1.05k]
  ------------------
13401|      0|    {
13402|       |        // Leave the "menu" layer
13403|      0|        NavRestoreLayer(ImGuiNavLayer_Main);
13404|      0|        NavRestoreHighlightAfterMove();
13405|      0|    }
13406|  1.05k|    else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->RootWindowForNav->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->RootWindowForNav->ParentWindow)
  ------------------
  |  Branch (13406:14): [True: 220, False: 839]
  |  Branch (13406:29): [True: 170, False: 50]
  |  Branch (13406:71): [True: 170, False: 0]
  |  Branch (13406:139): [True: 170, False: 0]
  ------------------
13407|    170|    {
13408|       |        // Exit child window
13409|    170|        ImGuiWindow* child_window = g.NavWindow->RootWindowForNav;
13410|    170|        ImGuiWindow* parent_window = child_window->ParentWindow;
13411|    170|        IM_ASSERT(child_window->ChildId != 0);
  ------------------
  |  |   23|    170|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13412|    170|        FocusWindow(parent_window);
13413|    170|        SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_window->Rect()));
13414|    170|        NavRestoreHighlightAfterMove();
13415|    170|    }
13416|    889|    else if (g.OpenPopupStack.Size > 0 && g.OpenPopupStack.back().Window != NULL && !(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
  ------------------
  |  Branch (13416:14): [True: 0, False: 889]
  |  Branch (13416:43): [True: 0, False: 0]
  |  Branch (13416:85): [True: 0, False: 0]
  ------------------
13417|      0|    {
13418|       |        // Close open popup/menu
13419|      0|        ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
13420|      0|    }
13421|    889|    else
13422|    889|    {
13423|       |        // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
13424|    889|        if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
  ------------------
  |  Branch (13424:13): [True: 50, False: 839]
  |  Branch (13424:29): [True: 0, False: 50]
  |  Branch (13424:78): [True: 50, False: 0]
  ------------------
13425|     50|            g.NavWindow->NavLastIds[0] = 0;
13426|    889|        g.NavId = 0;
13427|    889|    }
13428|  1.06k|}
imgui.cpp:_ZN5ImGuiL26NavUpdateCreateMoveRequestEv:
13128|  76.6k|{
13129|  76.6k|    ImGuiContext& g = *GImGui;
13130|  76.6k|    ImGuiIO& io = g.IO;
13131|  76.6k|    ImGuiWindow* window = g.NavWindow;
13132|  76.6k|    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
  ------------------
  |  Branch (13132:37): [True: 76.6k, False: 0]
  |  Branch (13132:98): [True: 0, False: 76.6k]
  ------------------
13133|  76.6k|    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
13134|       |
13135|  76.6k|    if (g.NavMoveForwardToNextFrame && window != NULL)
  ------------------
  |  Branch (13135:9): [True: 0, False: 76.6k]
  |  Branch (13135:40): [True: 0, False: 0]
  ------------------
13136|      0|    {
13137|       |        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
13138|       |        // (preserve most state, which were already set by the NavMoveRequestForward() function)
13139|      0|        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13140|      0|        IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13141|      0|        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
  ------------------
  |  |  248|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 0]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13142|      0|    }
13143|  76.6k|    else
13144|  76.6k|    {
13145|       |        // Initiate directional inputs request
13146|  76.6k|        g.NavMoveDir = ImGuiDir_None;
13147|  76.6k|        g.NavMoveFlags = ImGuiNavMoveFlags_None;
13148|  76.6k|        g.NavMoveScrollFlags = ImGuiScrollFlags_None;
13149|  76.6k|        if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (13149:13): [True: 7.51k, False: 69.1k]
  |  Branch (13149:23): [True: 7.51k, False: 0]
  |  Branch (13149:48): [True: 7.51k, False: 0]
  ------------------
13150|  7.51k|        {
13151|  7.51k|            const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | (ImGuiInputFlags)ImGuiInputFlags_RepeatRateNavMove;
13152|  7.51k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Left; }
  ------------------
  |  | 1434|  7.00k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13152:17): [True: 7.00k, False: 502]
  |  Branch (13152:61): [True: 0, False: 7.00k]
  |  Branch (13152:83): [True: 0, False: 0]
  |  Branch (13152:164): [True: 7.00k, False: 0]
  |  Branch (13152:187): [True: 49, False: 6.96k]
  ------------------
13153|  7.51k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Right; }
  ------------------
  |  | 1434|  7.00k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13153:17): [True: 7.00k, False: 502]
  |  Branch (13153:61): [True: 0, False: 7.00k]
  |  Branch (13153:83): [True: 0, False: 0]
  |  Branch (13153:164): [True: 7.00k, False: 0]
  |  Branch (13153:187): [True: 104, False: 6.90k]
  ------------------
13154|  7.51k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp,    repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow,    repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Up; }
  ------------------
  |  | 1434|  7.00k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13154:17): [True: 7.00k, False: 502]
  |  Branch (13154:61): [True: 0, False: 7.00k]
  |  Branch (13154:83): [True: 0, False: 0]
  |  Branch (13154:164): [True: 7.00k, False: 0]
  |  Branch (13154:187): [True: 8, False: 7.00k]
  ------------------
13155|  7.51k|            if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1434|      0|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
                          if (!IsActiveIdUsingNavDir(ImGuiDir_Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir_Down; }
  ------------------
  |  | 1434|  7.00k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13155:17): [True: 7.00k, False: 502]
  |  Branch (13155:61): [True: 0, False: 7.00k]
  |  Branch (13155:83): [True: 0, False: 0]
  |  Branch (13155:164): [True: 7.00k, False: 0]
  |  Branch (13155:187): [True: 200, False: 6.80k]
  ------------------
13156|  7.51k|        }
13157|  76.6k|        g.NavMoveClipDir = g.NavMoveDir;
13158|  76.6k|        g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
13159|  76.6k|    }
13160|       |
13161|       |    // Update PageUp/PageDown/Home/End scroll
13162|       |    // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
13163|  76.6k|    float scoring_rect_offset_y = 0.0f;
13164|  76.6k|    if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
  ------------------
  |  Branch (13164:9): [True: 7.51k, False: 69.1k]
  |  Branch (13164:19): [True: 7.15k, False: 361]
  |  Branch (13164:52): [True: 7.15k, False: 0]
  ------------------
13165|  7.15k|        scoring_rect_offset_y = NavUpdatePageUpPageDown();
13166|  76.6k|    if (scoring_rect_offset_y != 0.0f)
  ------------------
  |  Branch (13166:9): [True: 68, False: 76.6k]
  ------------------
13167|     68|    {
13168|     68|        g.NavScoringNoClipRect = window->InnerRect;
13169|     68|        g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
13170|     68|    }
13171|       |
13172|       |    // [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
13173|       |#if IMGUI_DEBUG_NAV_SCORING
13174|       |    //if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
13175|       |    //    g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
13176|       |    if (io.KeyCtrl)
13177|       |    {
13178|       |        if (g.NavMoveDir == ImGuiDir_None)
13179|       |            g.NavMoveDir = g.NavMoveDirForDebug;
13180|       |        g.NavMoveClipDir = g.NavMoveDir;
13181|       |        g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
13182|       |    }
13183|       |#endif
13184|       |
13185|       |    // Submit
13186|  76.6k|    g.NavMoveForwardToNextFrame = false;
13187|  76.6k|    if (g.NavMoveDir != ImGuiDir_None)
  ------------------
  |  Branch (13187:9): [True: 447, False: 76.2k]
  ------------------
13188|    447|        NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
13189|       |
13190|       |    // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
13191|  76.6k|    if (g.NavMoveSubmitted && g.NavId == 0)
  ------------------
  |  Branch (13191:9): [True: 447, False: 76.2k]
  |  Branch (13191:31): [True: 318, False: 129]
  ------------------
13192|    318|    {
13193|    318|        IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer);
  ------------------
  |  |  248|    318|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 318]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13194|    318|        g.NavInitRequest = g.NavInitRequestFromMove = true;
13195|    318|        g.NavInitResult.ID = 0;
13196|    318|        g.NavDisableHighlight = false;
13197|    318|    }
13198|       |
13199|       |    // When using gamepad, we project the reference nav bounding box into window visible area.
13200|       |    // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
13201|       |    // since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
13202|  76.6k|    if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != NULL)// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
  ------------------
  |  Branch (13202:9): [True: 447, False: 76.2k]
  |  Branch (13202:31): [True: 0, False: 447]
  |  Branch (13202:79): [True: 0, False: 0]
  |  Branch (13202:115): [True: 0, False: 0]
  ------------------
13203|      0|    {
13204|      0|        bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
13205|      0|        bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
13206|      0|        ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));
13207|       |
13208|       |        // Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
13209|       |        // Otherwise 'inner_rect_rel' would be off on the move result frame.
13210|      0|        inner_rect_rel.Translate(CalcNextScrollFromScrollTargetAndClamp(window) - window->Scroll);
13211|       |
13212|      0|        if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
  ------------------
  |  Branch (13212:14): [True: 0, False: 0]
  |  Branch (13212:25): [True: 0, False: 0]
  |  Branch (13212:37): [True: 0, False: 0]
  ------------------
13213|      0|        {
13214|      0|            IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
  ------------------
  |  |  248|      0|#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)         IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (248:50): [True: 0, False: 0]
  |  |  |  Branch (248:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
13215|      0|            float pad_x = ImMin(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
13216|      0|            float pad_y = ImMin(inner_rect_rel.GetHeight(), window->CalcFontSize() * 0.5f); // Terrible approximation for the intent of starting navigation from first fully visible item
13217|      0|            inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX;
  ------------------
  |  Branch (13217:36): [True: 0, False: 0]
  ------------------
13218|      0|            inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX;
  ------------------
  |  Branch (13218:36): [True: 0, False: 0]
  ------------------
13219|      0|            inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX;
  ------------------
  |  Branch (13219:36): [True: 0, False: 0]
  ------------------
13220|      0|            inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX;
  ------------------
  |  Branch (13220:36): [True: 0, False: 0]
  ------------------
13221|      0|            window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
13222|      0|            g.NavId = 0;
13223|      0|        }
13224|      0|    }
13225|       |
13226|       |    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
13227|  76.6k|    ImRect scoring_rect;
13228|  76.6k|    if (window != NULL)
  ------------------
  |  Branch (13228:9): [True: 7.51k, False: 69.1k]
  ------------------
13229|  7.51k|    {
13230|  7.51k|        ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
  ------------------
  |  Branch (13230:31): [True: 7.51k, False: 0]
  ------------------
13231|  7.51k|        scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
13232|  7.51k|        scoring_rect.TranslateY(scoring_rect_offset_y);
13233|  7.51k|        if (g.NavMoveSubmitted)
  ------------------
  |  Branch (13233:13): [True: 447, False: 7.06k]
  ------------------
13234|    447|            NavBiasScoringRect(scoring_rect, window->RootWindowForNav->NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags);
13235|  7.51k|        IM_ASSERT(!scoring_rect.IsInverted()); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
  ------------------
  |  |   23|  7.51k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13236|       |        //GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
13237|       |        //if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
13238|  7.51k|    }
13239|  76.6k|    g.NavScoringRect = scoring_rect;
13240|  76.6k|    g.NavScoringNoClipRect.Add(scoring_rect);
13241|  76.6k|}
imgui.cpp:_ZN5ImGuiL23NavUpdatePageUpPageDownEv:
13435|  7.15k|{
13436|  7.15k|    ImGuiContext& g = *GImGui;
13437|  7.15k|    ImGuiWindow* window = g.NavWindow;
13438|  7.15k|    if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (13438:9): [True: 0, False: 7.15k]
  |  Branch (13438:59): [True: 0, False: 7.15k]
  ------------------
13439|      0|        return 0.0f;
13440|       |
13441|  7.15k|    const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ImGuiKeyOwner_NoOwner);
  ------------------
  |  | 1434|  7.15k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
13442|  7.15k|    const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ImGuiKeyOwner_NoOwner);
  ------------------
  |  | 1434|  7.15k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
13443|  7.15k|    const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
  ------------------
  |  | 1434|  7.15k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
13444|  7.15k|    const bool end_pressed = IsKeyPressed(ImGuiKey_End, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
  ------------------
  |  | 1434|  7.15k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
13445|  7.15k|    if (page_up_held == page_down_held && home_pressed == end_pressed) // Proceed if either (not both) are pressed, otherwise early out
  ------------------
  |  Branch (13445:9): [True: 6.04k, False: 1.10k]
  |  Branch (13445:43): [True: 6.02k, False: 29]
  ------------------
13446|  6.02k|        return 0.0f;
13447|       |
13448|  1.13k|    if (g.NavLayer != ImGuiNavLayer_Main)
  ------------------
  |  Branch (13448:9): [True: 1, False: 1.12k]
  ------------------
13449|      1|        NavRestoreLayer(ImGuiNavLayer_Main);
13450|       |
13451|  1.13k|    if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavWindowHasScrollY)
  ------------------
  |  Branch (13451:9): [True: 917, False: 213]
  |  Branch (13451:51): [True: 814, False: 103]
  ------------------
13452|    814|    {
13453|       |        // Fallback manual-scroll when window has no navigable item
13454|    814|        if (IsKeyPressed(ImGuiKey_PageUp, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner))
  ------------------
  |  | 1434|    814|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13454:13): [True: 2, False: 812]
  ------------------
13455|      2|            SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
13456|    812|        else if (IsKeyPressed(ImGuiKey_PageDown, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner))
  ------------------
  |  | 1434|    812|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13456:18): [True: 51, False: 761]
  ------------------
13457|     51|            SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
13458|    761|        else if (home_pressed)
  ------------------
  |  Branch (13458:18): [True: 13, False: 748]
  ------------------
13459|     13|            SetScrollY(window, 0.0f);
13460|    748|        else if (end_pressed)
  ------------------
  |  Branch (13460:18): [True: 11, False: 737]
  ------------------
13461|     11|            SetScrollY(window, window->ScrollMax.y);
13462|    814|    }
13463|    316|    else
13464|    316|    {
13465|    316|        ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
13466|    316|        const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
13467|    316|        float nav_scoring_rect_offset_y = 0.0f;
13468|    316|        if (IsKeyPressed(ImGuiKey_PageUp, true))
  ------------------
  |  Branch (13468:13): [True: 5, False: 311]
  ------------------
13469|      5|        {
13470|      5|            nav_scoring_rect_offset_y = -page_offset_y;
13471|      5|            g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
13472|      5|            g.NavMoveClipDir = ImGuiDir_Up;
13473|      5|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
13474|      5|        }
13475|    311|        else if (IsKeyPressed(ImGuiKey_PageDown, true))
  ------------------
  |  Branch (13475:18): [True: 63, False: 248]
  ------------------
13476|     63|        {
13477|     63|            nav_scoring_rect_offset_y = +page_offset_y;
13478|     63|            g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
13479|     63|            g.NavMoveClipDir = ImGuiDir_Down;
13480|     63|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
13481|     63|        }
13482|    248|        else if (home_pressed)
  ------------------
  |  Branch (13482:18): [True: 14, False: 234]
  ------------------
13483|     14|        {
13484|       |            // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
13485|       |            // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
13486|       |            // Preserve current horizontal position if we have any.
13487|     14|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
13488|     14|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (13488:17): [True: 0, False: 14]
  ------------------
13489|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
13490|     14|            g.NavMoveDir = ImGuiDir_Down;
13491|     14|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
13492|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
13493|     14|        }
13494|    234|        else if (end_pressed)
  ------------------
  |  Branch (13494:18): [True: 4, False: 230]
  ------------------
13495|      4|        {
13496|      4|            nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
13497|      4|            if (nav_rect_rel.IsInverted())
  ------------------
  |  Branch (13497:17): [True: 0, False: 4]
  ------------------
13498|      0|                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
13499|      4|            g.NavMoveDir = ImGuiDir_Up;
13500|      4|            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
13501|       |            // FIXME-NAV: MoveClipDir left to _None, intentional?
13502|      4|        }
13503|    316|        return nav_scoring_rect_offset_y;
13504|    316|    }
13505|    814|    return 0.0f;
13506|  1.13k|}
imgui.cpp:_ZL18NavBiasScoringRectR6ImRectR6ImVec28ImGuiDiri:
13104|    447|{
13105|       |    // Bias initial rect
13106|    447|    ImGuiContext& g = *GImGui;
13107|    447|    const ImVec2 rel_to_abs_offset = g.NavWindow->DC.CursorStartPos;
13108|       |
13109|       |    // Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
13110|       |    // - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
13111|       |    // - But each successful move sets new bias on one axis, only cleared when using mouse.
13112|    447|    if ((move_flags & ImGuiNavMoveFlags_Forwarded) == 0)
  ------------------
  |  Branch (13112:9): [True: 447, False: 0]
  ------------------
13113|    447|    {
13114|    447|        if (preferred_pos_rel.x == FLT_MAX)
  ------------------
  |  Branch (13114:13): [True: 206, False: 241]
  ------------------
13115|    206|            preferred_pos_rel.x = ImMin(r.Min.x + 1.0f, r.Max.x) - rel_to_abs_offset.x;
13116|    447|        if (preferred_pos_rel.y == FLT_MAX)
  ------------------
  |  Branch (13116:13): [True: 279, False: 168]
  ------------------
13117|    279|            preferred_pos_rel.y = r.GetCenter().y - rel_to_abs_offset.y;
13118|    447|    }
13119|       |
13120|       |    // Apply general bias on the other axis
13121|    447|    if ((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX)
  ------------------
  |  Branch (13121:10): [True: 75, False: 372]
  |  Branch (13121:37): [True: 219, False: 153]
  |  Branch (13121:67): [True: 294, False: 0]
  ------------------
13122|    294|        r.Min.x = r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
13123|    153|    else if ((move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX)
  ------------------
  |  Branch (13123:15): [True: 49, False: 104]
  |  Branch (13123:44): [True: 104, False: 0]
  |  Branch (13123:75): [True: 153, False: 0]
  ------------------
13124|    153|        r.Min.y = r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
13125|    447|}
imgui.cpp:_ZN5ImGuiL29NavUpdateCreateTabbingRequestEv:
13244|  76.2k|{
13245|  76.2k|    ImGuiContext& g = *GImGui;
13246|  76.2k|    ImGuiWindow* window = g.NavWindow;
13247|  76.2k|    IM_ASSERT(g.NavMoveDir == ImGuiDir_None);
  ------------------
  |  |   23|  76.2k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
13248|  76.2k|    if (window == NULL || g.NavWindowingTarget != NULL || (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (13248:9): [True: 69.1k, False: 7.06k]
  |  Branch (13248:27): [True: 0, False: 7.06k]
  |  Branch (13248:59): [True: 0, False: 7.06k]
  ------------------
13249|  69.1k|        return;
13250|       |
13251|  7.06k|    const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
  ------------------
  |  | 1434|  7.06k|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
  |  Branch (13251:30): [True: 60, False: 7.00k]
  |  Branch (13251:107): [True: 60, False: 0]
  |  Branch (13251:124): [True: 60, False: 0]
  ------------------
13252|  7.06k|    if (!tab_pressed)
  ------------------
  |  Branch (13252:9): [True: 7.00k, False: 60]
  ------------------
13253|  7.00k|        return;
13254|       |
13255|       |    // Initiate tabbing request
13256|       |    // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
13257|       |    // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
13258|     60|    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
13259|     60|    if (nav_keyboard_active)
  ------------------
  |  Branch (13259:9): [True: 60, False: 0]
  ------------------
13260|     60|        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavDisableHighlight == true && g.ActiveId == 0) ? 0 : +1;
  ------------------
  |  Branch (13260:27): [True: 0, False: 60]
  |  Branch (13260:49): [True: 0, False: 60]
  |  Branch (13260:82): [True: 0, False: 0]
  ------------------
13261|      0|    else
13262|      0|        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
  ------------------
  |  Branch (13262:27): [True: 0, False: 0]
  |  Branch (13262:48): [True: 0, False: 0]
  ------------------
13263|     60|    ImGuiNavMoveFlags move_flags = ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate;
13264|     60|    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
  ------------------
  |  Branch (13264:37): [True: 0, False: 60]
  ------------------
13265|     60|    ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
  ------------------
  |  Branch (13265:25): [True: 0, False: 60]
  ------------------
13266|     60|    NavMoveRequestSubmit(ImGuiDir_None, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
13267|     60|    g.NavTabbingCounter = -1;
13268|     60|}
imgui.cpp:_ZN5ImGuiL11NavEndFrameEv:
13509|  76.6k|{
13510|  76.6k|    ImGuiContext& g = *GImGui;
13511|       |
13512|       |    // Show CTRL+TAB list window
13513|  76.6k|    if (g.NavWindowingTarget != NULL)
  ------------------
  |  Branch (13513:9): [True: 0, False: 76.6k]
  ------------------
13514|      0|        NavUpdateWindowingOverlay();
13515|       |
13516|       |    // Perform wrap-around in menus
13517|       |    // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
13518|       |    // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
13519|  76.6k|    if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_WrapMask_) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
  ------------------
  |  Branch (13519:9): [True: 10.5k, False: 66.1k]
  |  Branch (13519:24): [True: 420, False: 10.0k]
  |  Branch (13519:58): [True: 0, False: 420]
  |  Branch (13519:108): [True: 0, False: 0]
  ------------------
13520|      0|        NavUpdateCreateWrappingRequest();
13521|  76.6k|}
imgui.cpp:_ZN5ImGuiL14UpdateSettingsEv:
14500|  76.6k|{
14501|       |    // Load settings on first frame (if not explicitly loaded manually before)
14502|  76.6k|    ImGuiContext& g = *GImGui;
14503|  76.6k|    if (!g.SettingsLoaded)
  ------------------
  |  Branch (14503:9): [True: 1, False: 76.6k]
  ------------------
14504|      1|    {
14505|      1|        IM_ASSERT(g.SettingsWindows.empty());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
14506|      1|        if (g.IO.IniFilename)
  ------------------
  |  Branch (14506:13): [True: 0, False: 1]
  ------------------
14507|      0|            LoadIniSettingsFromDisk(g.IO.IniFilename);
14508|      1|        g.SettingsLoaded = true;
14509|      1|    }
14510|       |
14511|       |    // Save settings (with a delay after the last modification, so we don't spam disk too much)
14512|  76.6k|    if (g.SettingsDirtyTimer > 0.0f)
  ------------------
  |  Branch (14512:9): [True: 1.80k, False: 74.8k]
  ------------------
14513|  1.80k|    {
14514|  1.80k|        g.SettingsDirtyTimer -= g.IO.DeltaTime;
14515|  1.80k|        if (g.SettingsDirtyTimer <= 0.0f)
  ------------------
  |  Branch (14515:13): [True: 6, False: 1.79k]
  ------------------
14516|      6|        {
14517|      6|            if (g.IO.IniFilename != NULL)
  ------------------
  |  Branch (14517:17): [True: 0, False: 6]
  ------------------
14518|      0|                SaveIniSettingsToDisk(g.IO.IniFilename);
14519|      6|            else
14520|      6|                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
14521|      6|            g.SettingsDirtyTimer = 0.0f;
14522|      6|        }
14523|  1.80k|    }
14524|  76.6k|}
imgui.cpp:_ZL24InitOrLoadWindowSettingsP11ImGuiWindowP19ImGuiWindowSettings:
 6012|      3|{
 6013|       |    // Initial window state with e.g. default/arbitrary window position
 6014|       |    // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
 6015|      3|    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
 6016|      3|    window->Pos = main_viewport->Pos + ImVec2(60, 60);
 6017|      3|    window->Size = window->SizeFull = ImVec2(0, 0);
 6018|      3|    window->ViewportPos = main_viewport->Pos;
 6019|      3|    window->SetWindowPosAllowFlags = window->SetWindowSizeAllowFlags = window->SetWindowCollapsedAllowFlags = window->SetWindowDockAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
 6020|       |
 6021|      3|    if (settings != NULL)
  ------------------
  |  Branch (6021:9): [True: 0, False: 3]
  ------------------
 6022|      0|    {
 6023|      0|        SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
 6024|      0|        ApplyWindowSettings(window, settings);
 6025|      0|    }
 6026|      3|    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values
 6027|       |
 6028|      3|    if ((window->Flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
  ------------------
  |  Branch (6028:9): [True: 0, False: 3]
  ------------------
 6029|      0|    {
 6030|      0|        window->AutoFitFramesX = window->AutoFitFramesY = 2;
 6031|      0|        window->AutoFitOnlyGrows = false;
 6032|      0|    }
 6033|      3|    else
 6034|      3|    {
 6035|      3|        if (window->Size.x <= 0.0f)
  ------------------
  |  Branch (6035:13): [True: 3, False: 0]
  ------------------
 6036|      3|            window->AutoFitFramesX = 2;
 6037|      3|        if (window->Size.y <= 0.0f)
  ------------------
  |  Branch (6037:13): [True: 3, False: 0]
  ------------------
 6038|      3|            window->AutoFitFramesY = 2;
 6039|      3|        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
  ------------------
  |  Branch (6039:36): [True: 3, False: 0]
  |  Branch (6039:68): [True: 0, False: 0]
  ------------------
 6040|      3|    }
 6041|      3|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsNewFrameEv:
15074|  76.6k|{
15075|  76.6k|    ImGuiContext& g = *GImGui;
15076|  76.6k|    IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15077|       |
15078|       |    // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
15079|       |    // Update Focused status
15080|  76.6k|    const bool viewports_enabled = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
15081|  76.6k|    if (viewports_enabled)
  ------------------
  |  Branch (15081:9): [True: 0, False: 76.6k]
  ------------------
15082|      0|    {
15083|      0|        ImGuiViewportP* focused_viewport = NULL;
15084|      0|        for (ImGuiViewportP* viewport : g.Viewports)
  ------------------
  |  Branch (15084:39): [True: 0, False: 0]
  ------------------
15085|      0|        {
15086|      0|            const bool platform_funcs_available = viewport->PlatformWindowCreated;
15087|      0|            if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
  ------------------
  |  Branch (15087:17): [True: 0, False: 0]
  |  Branch (15087:61): [True: 0, False: 0]
  ------------------
15088|      0|            {
15089|      0|                bool is_minimized = g.PlatformIO.Platform_GetWindowMinimized(viewport);
15090|      0|                if (is_minimized)
  ------------------
  |  Branch (15090:21): [True: 0, False: 0]
  ------------------
15091|      0|                    viewport->Flags |= ImGuiViewportFlags_IsMinimized;
15092|      0|                else
15093|      0|                    viewport->Flags &= ~ImGuiViewportFlags_IsMinimized;
15094|      0|            }
15095|       |
15096|       |            // Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
15097|       |            // When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
15098|      0|            if (g.PlatformIO.Platform_GetWindowFocus && platform_funcs_available)
  ------------------
  |  Branch (15098:17): [True: 0, False: 0]
  |  Branch (15098:57): [True: 0, False: 0]
  ------------------
15099|      0|            {
15100|      0|                bool is_focused = g.PlatformIO.Platform_GetWindowFocus(viewport);
15101|      0|                if (is_focused)
  ------------------
  |  Branch (15101:21): [True: 0, False: 0]
  ------------------
15102|      0|                    viewport->Flags |= ImGuiViewportFlags_IsFocused;
15103|      0|                else
15104|      0|                    viewport->Flags &= ~ImGuiViewportFlags_IsFocused;
15105|      0|                if (is_focused)
  ------------------
  |  Branch (15105:21): [True: 0, False: 0]
  ------------------
15106|      0|                    focused_viewport = viewport;
15107|      0|            }
15108|      0|        }
15109|       |
15110|       |        // Focused viewport has changed?
15111|      0|        if (focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport->ID)
  ------------------
  |  Branch (15111:13): [True: 0, False: 0]
  |  Branch (15111:33): [True: 0, False: 0]
  ------------------
15112|      0|        {
15113|      0|            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport->ID);
  ------------------
  |  |  254|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (254:50): [True: 0, False: 0]
  |  |  |  Branch (254:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
15114|      0|            const ImGuiViewport* prev_focused_viewport = FindViewportByID(g.PlatformLastFocusedViewportId);
15115|      0|            const bool prev_focused_has_been_destroyed = (prev_focused_viewport == NULL) || (prev_focused_viewport->PlatformWindowCreated == false);
  ------------------
  |  Branch (15115:58): [True: 0, False: 0]
  |  Branch (15115:93): [True: 0, False: 0]
  ------------------
15116|       |
15117|       |            // Store a tag so we can infer z-order easily from all our windows
15118|       |            // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
15119|       |            // will keep the front most stamp instead of losing it back to their parent viewport.
15120|      0|            if (focused_viewport->LastFocusedStampCount != g.ViewportFocusedStampCount)
  ------------------
  |  Branch (15120:17): [True: 0, False: 0]
  ------------------
15121|      0|                focused_viewport->LastFocusedStampCount = ++g.ViewportFocusedStampCount;
15122|      0|            g.PlatformLastFocusedViewportId = focused_viewport->ID;
15123|       |
15124|       |            // Focus associated dear imgui window
15125|       |            // - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
15126|       |            // - if focus didn't happen because we destroyed another window (#6462)
15127|       |            // FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window->Window != NULL' case as well.
15128|      0|            const bool apply_imgui_focus_on_focused_viewport = !IsAnyMouseDown() && !prev_focused_has_been_destroyed;
  ------------------
  |  Branch (15128:64): [True: 0, False: 0]
  |  Branch (15128:85): [True: 0, False: 0]
  ------------------
15129|      0|            if (apply_imgui_focus_on_focused_viewport)
  ------------------
  |  Branch (15129:17): [True: 0, False: 0]
  ------------------
15130|      0|            {
15131|      0|                focused_viewport->LastFocusedHadNavWindow |= (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
  ------------------
  |  Branch (15131:62): [True: 0, False: 0]
  |  Branch (15131:87): [True: 0, False: 0]
  ------------------
15132|      0|                ImGuiFocusRequestFlags focus_request_flags = ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild;
15133|      0|                if (focused_viewport->Window != NULL)
  ------------------
  |  Branch (15133:21): [True: 0, False: 0]
  ------------------
15134|      0|                    FocusWindow(focused_viewport->Window, focus_request_flags);
15135|      0|                else if (focused_viewport->LastFocusedHadNavWindow)
  ------------------
  |  Branch (15135:26): [True: 0, False: 0]
  ------------------
15136|      0|                    FocusTopMostWindowUnderOne(NULL, NULL, focused_viewport, focus_request_flags); // Focus top most in viewport
15137|      0|                else
15138|      0|                    FocusWindow(NULL, focus_request_flags); // No window had focus last time viewport was focused
15139|      0|            }
15140|      0|        }
15141|      0|        if (focused_viewport)
  ------------------
  |  Branch (15141:13): [True: 0, False: 0]
  ------------------
15142|      0|            focused_viewport->LastFocusedHadNavWindow = (g.NavWindow != NULL) && (g.NavWindow->Viewport == focused_viewport);
  ------------------
  |  Branch (15142:57): [True: 0, False: 0]
  |  Branch (15142:82): [True: 0, False: 0]
  ------------------
15143|      0|    }
15144|       |
15145|       |    // Create/update main viewport with current platform position.
15146|       |    // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
15147|  76.6k|    ImGuiViewportP* main_viewport = g.Viewports[0];
15148|  76.6k|    IM_ASSERT(main_viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15149|  76.6k|    IM_ASSERT(main_viewport->Window == NULL);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15150|  76.6k|    ImVec2 main_viewport_pos = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2(0.0f, 0.0f);
  ------------------
  |  Branch (15150:32): [True: 0, False: 76.6k]
  ------------------
15151|  76.6k|    ImVec2 main_viewport_size = g.IO.DisplaySize;
15152|  76.6k|    if (viewports_enabled && (main_viewport->Flags & ImGuiViewportFlags_IsMinimized))
  ------------------
  |  Branch (15152:9): [True: 0, False: 76.6k]
  |  Branch (15152:30): [True: 0, False: 0]
  ------------------
15153|      0|    {
15154|      0|        main_viewport_pos = main_viewport->Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
15155|      0|        main_viewport_size = main_viewport->Size;
15156|      0|    }
15157|  76.6k|    AddUpdateViewport(NULL, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);
15158|       |
15159|  76.6k|    g.CurrentDpiScale = 0.0f;
15160|  76.6k|    g.CurrentViewport = NULL;
15161|  76.6k|    g.MouseViewport = NULL;
15162|   153k|    for (int n = 0; n < g.Viewports.Size; n++)
  ------------------
  |  Branch (15162:21): [True: 76.6k, False: 76.6k]
  ------------------
15163|  76.6k|    {
15164|  76.6k|        ImGuiViewportP* viewport = g.Viewports[n];
15165|  76.6k|        viewport->Idx = n;
15166|       |
15167|       |        // Erase unused viewports
15168|  76.6k|        if (n > 0 && viewport->LastFrameActive < g.FrameCount - 2)
  ------------------
  |  Branch (15168:13): [True: 0, False: 76.6k]
  |  Branch (15168:22): [True: 0, False: 0]
  ------------------
15169|      0|        {
15170|      0|            DestroyViewport(viewport);
15171|      0|            n--;
15172|      0|            continue;
15173|      0|        }
15174|       |
15175|  76.6k|        const bool platform_funcs_available = viewport->PlatformWindowCreated;
15176|  76.6k|        if (viewports_enabled)
  ------------------
  |  Branch (15176:13): [True: 0, False: 76.6k]
  ------------------
15177|      0|        {
15178|       |            // Update Position and Size (from Platform Window to ImGui) if requested.
15179|       |            // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
15180|      0|            if (!(viewport->Flags & ImGuiViewportFlags_IsMinimized) && platform_funcs_available)
  ------------------
  |  Branch (15180:17): [True: 0, False: 0]
  |  Branch (15180:72): [True: 0, False: 0]
  ------------------
15181|      0|            {
15182|       |                // Viewport->WorkPos and WorkSize will be updated below
15183|      0|                if (viewport->PlatformRequestMove)
  ------------------
  |  Branch (15183:21): [True: 0, False: 0]
  ------------------
15184|      0|                    viewport->Pos = viewport->LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
15185|      0|                if (viewport->PlatformRequestResize)
  ------------------
  |  Branch (15185:21): [True: 0, False: 0]
  ------------------
15186|      0|                    viewport->Size = viewport->LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
15187|      0|            }
15188|      0|        }
15189|       |
15190|       |        // Update/copy monitor info
15191|  76.6k|        UpdateViewportPlatformMonitor(viewport);
15192|       |
15193|       |        // Lock down space taken by menu bars and status bars, reset the offset for functions like BeginMainMenuBar() to alter them again.
15194|  76.6k|        viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
15195|  76.6k|        viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
15196|  76.6k|        viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
15197|  76.6k|        viewport->UpdateWorkRect();
15198|       |
15199|       |        // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
15200|  76.6k|        viewport->Alpha = 1.0f;
15201|       |
15202|       |        // Translate Dear ImGui windows when a Host Viewport has been moved
15203|       |        // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
15204|  76.6k|        const ImVec2 viewport_delta_pos = viewport->Pos - viewport->LastPos;
15205|  76.6k|        if ((viewport->Flags & ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0f || viewport_delta_pos.y != 0.0f))
  ------------------
  |  Branch (15205:13): [True: 76.6k, False: 0]
  |  Branch (15205:76): [True: 0, False: 76.6k]
  |  Branch (15205:108): [True: 0, False: 76.6k]
  ------------------
15206|      0|            TranslateWindowsInViewport(viewport, viewport->LastPos, viewport->Pos);
15207|       |
15208|       |        // Update DPI scale
15209|  76.6k|        float new_dpi_scale;
15210|  76.6k|        if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available)
  ------------------
  |  Branch (15210:13): [True: 0, False: 76.6k]
  |  Branch (15210:56): [True: 0, False: 0]
  ------------------
15211|      0|            new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
15212|  76.6k|        else if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (15212:18): [True: 0, False: 76.6k]
  ------------------
15213|      0|            new_dpi_scale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
15214|  76.6k|        else
15215|  76.6k|            new_dpi_scale = (viewport->DpiScale != 0.0f) ? viewport->DpiScale : 1.0f;
  ------------------
  |  Branch (15215:29): [True: 76.6k, False: 1]
  ------------------
15216|  76.6k|        if (viewport->DpiScale != 0.0f && new_dpi_scale != viewport->DpiScale)
  ------------------
  |  Branch (15216:13): [True: 76.6k, False: 1]
  |  Branch (15216:43): [True: 0, False: 76.6k]
  ------------------
15217|      0|        {
15218|      0|            float scale_factor = new_dpi_scale / viewport->DpiScale;
15219|      0|            if (g.IO.ConfigFlags & ImGuiConfigFlags_DpiEnableScaleViewports)
  ------------------
  |  Branch (15219:17): [True: 0, False: 0]
  ------------------
15220|      0|                ScaleWindowsInViewport(viewport, scale_factor);
15221|       |            //if (viewport == GetMainViewport())
15222|       |            //    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);
15223|       |
15224|       |            // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
15225|       |            // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
15226|       |            // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
15227|       |            //if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
15228|       |            //    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
15229|      0|        }
15230|  76.6k|        viewport->DpiScale = new_dpi_scale;
15231|  76.6k|    }
15232|       |
15233|       |    // Update fallback monitor
15234|  76.6k|    g.PlatformMonitorsFullWorkRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
15235|  76.6k|    if (g.PlatformIO.Monitors.Size == 0)
  ------------------
  |  Branch (15235:9): [True: 76.6k, False: 0]
  ------------------
15236|  76.6k|    {
15237|  76.6k|        ImGuiPlatformMonitor* monitor = &g.FallbackMonitor;
15238|  76.6k|        monitor->MainPos = main_viewport->Pos;
15239|  76.6k|        monitor->MainSize = main_viewport->Size;
15240|  76.6k|        monitor->WorkPos = main_viewport->WorkPos;
15241|  76.6k|        monitor->WorkSize = main_viewport->WorkSize;
15242|  76.6k|        monitor->DpiScale = main_viewport->DpiScale;
15243|  76.6k|        g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos);
15244|  76.6k|        g.PlatformMonitorsFullWorkRect.Add(monitor->WorkPos + monitor->WorkSize);
15245|  76.6k|    }
15246|  76.6k|    for (ImGuiPlatformMonitor& monitor : g.PlatformIO.Monitors)
  ------------------
  |  Branch (15246:40): [True: 0, False: 76.6k]
  ------------------
15247|      0|    {
15248|      0|        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos);
15249|      0|        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos + monitor.WorkSize);
15250|      0|    }
15251|       |
15252|  76.6k|    if (!viewports_enabled)
  ------------------
  |  Branch (15252:9): [True: 76.6k, False: 0]
  ------------------
15253|  76.6k|    {
15254|  76.6k|        g.MouseViewport = main_viewport;
15255|  76.6k|        return;
15256|  76.6k|    }
15257|       |
15258|       |    // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
15259|       |    // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
15260|      0|    ImGuiViewportP* viewport_hovered = NULL;
15261|      0|    if (g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport)
  ------------------
  |  Branch (15261:9): [True: 0, False: 0]
  ------------------
15262|      0|    {
15263|      0|        viewport_hovered = g.IO.MouseHoveredViewport ? (ImGuiViewportP*)FindViewportByID(g.IO.MouseHoveredViewport) : NULL;
  ------------------
  |  Branch (15263:28): [True: 0, False: 0]
  ------------------
15264|      0|        if (viewport_hovered && (viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (15264:13): [True: 0, False: 0]
  |  Branch (15264:33): [True: 0, False: 0]
  ------------------
15265|      0|            viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
15266|      0|    }
15267|      0|    else
15268|      0|    {
15269|       |        // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
15270|       |        // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
15271|       |        // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
15272|       |        // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
15273|      0|        viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
15274|      0|    }
15275|      0|    if (viewport_hovered != NULL)
  ------------------
  |  Branch (15275:9): [True: 0, False: 0]
  ------------------
15276|      0|        g.MouseLastHoveredViewport = viewport_hovered;
15277|      0|    else if (g.MouseLastHoveredViewport == NULL)
  ------------------
  |  Branch (15277:14): [True: 0, False: 0]
  ------------------
15278|      0|        g.MouseLastHoveredViewport = g.Viewports[0];
15279|       |
15280|       |    // Update mouse reference viewport
15281|       |    // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
15282|       |    // (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
15283|      0|    if (g.MovingWindow && g.MovingWindow->Viewport)
  ------------------
  |  Branch (15283:9): [True: 0, False: 0]
  |  Branch (15283:27): [True: 0, False: 0]
  ------------------
15284|      0|        g.MouseViewport = g.MovingWindow->Viewport;
15285|      0|    else
15286|      0|        g.MouseViewport = g.MouseLastHoveredViewport;
15287|       |
15288|       |    // When dragging something, always refer to the last hovered viewport.
15289|       |    // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
15290|       |    // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
15291|       |    // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
15292|       |    // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
15293|      0|    const bool is_mouse_dragging_with_an_expected_destination = g.DragDropActive;
15294|      0|    if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == NULL)
  ------------------
  |  Branch (15294:9): [True: 0, False: 0]
  |  Branch (15294:59): [True: 0, False: 0]
  ------------------
15295|      0|        viewport_hovered = g.MouseLastHoveredViewport;
15296|      0|    if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown())
  ------------------
  |  Branch (15296:9): [True: 0, False: 0]
  |  Branch (15296:59): [True: 0, False: 0]
  |  Branch (15296:78): [True: 0, False: 0]
  ------------------
15297|      0|        if (viewport_hovered != NULL && viewport_hovered != g.MouseViewport && !(viewport_hovered->Flags & ImGuiViewportFlags_NoInputs))
  ------------------
  |  Branch (15297:13): [True: 0, False: 0]
  |  Branch (15297:41): [True: 0, False: 0]
  |  Branch (15297:80): [True: 0, False: 0]
  ------------------
15298|      0|            g.MouseViewport = viewport_hovered;
15299|       |
15300|      0|    IM_ASSERT(g.MouseViewport != NULL);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15301|      0|}
imgui.cpp:_ZN5ImGuiL29UpdateViewportPlatformMonitorEP14ImGuiViewportP:
15823|  76.6k|{
15824|  76.6k|    viewport->PlatformMonitor = (short)FindPlatformMonitorForRect(viewport->GetMainRect());
15825|  76.6k|}
imgui.cpp:_ZN5ImGuiL26FindPlatformMonitorForRectERK6ImRect:
15791|  76.6k|{
15792|  76.6k|    ImGuiContext& g = *GImGui;
15793|       |
15794|  76.6k|    const int monitor_count = g.PlatformIO.Monitors.Size;
15795|  76.6k|    if (monitor_count <= 1)
  ------------------
  |  Branch (15795:9): [True: 76.6k, False: 0]
  ------------------
15796|  76.6k|        return monitor_count - 1;
15797|       |
15798|       |    // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
15799|       |    // This is necessary for tooltips which always resize down to zero at first.
15800|      0|    const float surface_threshold = ImMax(rect.GetWidth() * rect.GetHeight() * 0.5f, 1.0f);
15801|      0|    int best_monitor_n = -1;
15802|      0|    float best_monitor_surface = 0.001f;
15803|       |
15804|      0|    for (int monitor_n = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n++)
  ------------------
  |  Branch (15804:29): [True: 0, False: 0]
  |  Branch (15804:71): [True: 0, False: 0]
  ------------------
15805|      0|    {
15806|      0|        const ImGuiPlatformMonitor& monitor = g.PlatformIO.Monitors[monitor_n];
15807|      0|        const ImRect monitor_rect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize);
15808|      0|        if (monitor_rect.Contains(rect))
  ------------------
  |  Branch (15808:13): [True: 0, False: 0]
  ------------------
15809|      0|            return monitor_n;
15810|      0|        ImRect overlapping_rect = rect;
15811|      0|        overlapping_rect.ClipWithFull(monitor_rect);
15812|      0|        float overlapping_surface = overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
15813|      0|        if (overlapping_surface < best_monitor_surface)
  ------------------
  |  Branch (15813:13): [True: 0, False: 0]
  ------------------
15814|      0|            continue;
15815|      0|        best_monitor_surface = overlapping_surface;
15816|      0|        best_monitor_n = monitor_n;
15817|      0|    }
15818|      0|    return best_monitor_n;
15819|      0|}
imgui.cpp:_ZN5ImGuiL23UpdateViewportsEndFrameEv:
15305|  76.6k|{
15306|  76.6k|    ImGuiContext& g = *GImGui;
15307|  76.6k|    g.PlatformIO.Viewports.resize(0);
15308|   153k|    for (int i = 0; i < g.Viewports.Size; i++)
  ------------------
  |  Branch (15308:21): [True: 76.6k, False: 76.6k]
  ------------------
15309|  76.6k|    {
15310|  76.6k|        ImGuiViewportP* viewport = g.Viewports[i];
15311|  76.6k|        viewport->LastPos = viewport->Pos;
15312|  76.6k|        if (viewport->LastFrameActive < g.FrameCount || viewport->Size.x <= 0.0f || viewport->Size.y <= 0.0f)
  ------------------
  |  Branch (15312:13): [True: 0, False: 76.6k]
  |  Branch (15312:57): [True: 0, False: 76.6k]
  |  Branch (15312:85): [True: 0, False: 76.6k]
  ------------------
15313|      0|            if (i > 0) // Always include main viewport in the list
  ------------------
  |  Branch (15313:17): [True: 0, False: 0]
  ------------------
15314|      0|                continue;
15315|  76.6k|        if (viewport->Window && !IsWindowActiveAndVisible(viewport->Window))
  ------------------
  |  Branch (15315:13): [True: 0, False: 76.6k]
  |  Branch (15315:33): [True: 0, False: 0]
  ------------------
15316|      0|            continue;
15317|  76.6k|        if (i > 0)
  ------------------
  |  Branch (15317:13): [True: 0, False: 76.6k]
  ------------------
15318|  76.6k|            IM_ASSERT(viewport->Window != NULL);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15319|  76.6k|        g.PlatformIO.Viewports.push_back(viewport);
15320|  76.6k|    }
15321|  76.6k|    g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
15322|  76.6k|}
imgui.cpp:_ZN5ImGuiL17AddUpdateViewportEP11ImGuiWindowjRK6ImVec2S4_i:
15326|  76.6k|{
15327|  76.6k|    ImGuiContext& g = *GImGui;
15328|  76.6k|    IM_ASSERT(id != 0);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15329|       |
15330|  76.6k|    flags |= ImGuiViewportFlags_IsPlatformWindow;
15331|  76.6k|    if (window != NULL)
  ------------------
  |  Branch (15331:9): [True: 0, False: 76.6k]
  ------------------
15332|      0|    {
15333|      0|        if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window)
  ------------------
  |  Branch (15333:13): [True: 0, False: 0]
  |  Branch (15333:31): [True: 0, False: 0]
  ------------------
15334|      0|            flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
15335|      0|        if ((window->Flags & ImGuiWindowFlags_NoMouseInputs) && (window->Flags & ImGuiWindowFlags_NoNavInputs))
  ------------------
  |  Branch (15335:13): [True: 0, False: 0]
  |  Branch (15335:65): [True: 0, False: 0]
  ------------------
15336|      0|            flags |= ImGuiViewportFlags_NoInputs;
15337|      0|        if (window->Flags & ImGuiWindowFlags_NoFocusOnAppearing)
  ------------------
  |  Branch (15337:13): [True: 0, False: 0]
  ------------------
15338|      0|            flags |= ImGuiViewportFlags_NoFocusOnAppearing;
15339|      0|    }
15340|       |
15341|  76.6k|    ImGuiViewportP* viewport = (ImGuiViewportP*)FindViewportByID(id);
15342|  76.6k|    if (viewport)
  ------------------
  |  Branch (15342:9): [True: 76.6k, False: 0]
  ------------------
15343|  76.6k|    {
15344|       |        // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
15345|  76.6k|        if (!viewport->PlatformRequestMove || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (15345:13): [True: 76.6k, False: 0]
  |  Branch (15345:47): [True: 0, False: 0]
  ------------------
15346|  76.6k|            viewport->Pos = pos;
15347|  76.6k|        if (!viewport->PlatformRequestResize || viewport->ID == IMGUI_VIEWPORT_DEFAULT_ID)
  ------------------
  |  Branch (15347:13): [True: 76.6k, False: 0]
  |  Branch (15347:49): [True: 0, False: 0]
  ------------------
15348|  76.6k|            viewport->Size = size;
15349|  76.6k|        viewport->Flags = flags | (viewport->Flags & (ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_IsFocused)); // Preserve existing flags
15350|  76.6k|    }
15351|      0|    else
15352|      0|    {
15353|       |        // New viewport
15354|      0|        viewport = IM_NEW(ImGuiViewportP)();
  ------------------
  |  | 2054|      0|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
15355|      0|        viewport->ID = id;
15356|      0|        viewport->Idx = g.Viewports.Size;
15357|      0|        viewport->Pos = viewport->LastPos = pos;
15358|      0|        viewport->Size = size;
15359|      0|        viewport->Flags = flags;
15360|      0|        UpdateViewportPlatformMonitor(viewport);
15361|      0|        g.Viewports.push_back(viewport);
15362|      0|        g.ViewportCreatedCount++;
15363|      0|        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window->Name : "<NULL>");
  ------------------
  |  |  254|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (241:57): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (254:50): [True: 0, False: 0]
  |  |  |  Branch (254:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
15364|       |
15365|       |        // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
15366|       |        // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
15367|      0|        g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport->Pos.x);
15368|      0|        g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport->Pos.y);
15369|      0|        g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport->Pos.x + viewport->Size.x);
15370|      0|        g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport->Pos.y + viewport->Size.y);
15371|       |
15372|       |        // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
15373|       |        // This is so we can select an appropriate font size on the first frame of our window lifetime
15374|      0|        if (viewport->PlatformMonitor != -1)
  ------------------
  |  Branch (15374:13): [True: 0, False: 0]
  ------------------
15375|      0|            viewport->DpiScale = g.PlatformIO.Monitors[viewport->PlatformMonitor].DpiScale;
15376|      0|    }
15377|       |
15378|  76.6k|    viewport->Window = window;
15379|  76.6k|    viewport->LastFrameActive = g.FrameCount;
15380|  76.6k|    viewport->UpdateWorkRect();
15381|  76.6k|    IM_ASSERT(window == NULL || viewport->ID == window->ID);
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15382|       |
15383|  76.6k|    if (window != NULL)
  ------------------
  |  Branch (15383:9): [True: 0, False: 76.6k]
  ------------------
15384|      0|        window->ViewportOwned = true;
15385|       |
15386|  76.6k|    return viewport;
15387|  76.6k|}
imgui.cpp:_ZN5ImGuiL20WindowSelectViewportEP11ImGuiWindow:
15414|   170k|{
15415|   170k|    ImGuiContext& g = *GImGui;
15416|   170k|    ImGuiWindowFlags flags = window->Flags;
15417|   170k|    window->ViewportAllowPlatformMonitorExtend = -1;
15418|       |
15419|       |    // Restore main viewport if multi-viewport is not supported by the backend
15420|   170k|    ImGuiViewportP* main_viewport = (ImGuiViewportP*)(void*)GetMainViewport();
15421|   170k|    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
  ------------------
  |  Branch (15421:9): [True: 170k, False: 0]
  ------------------
15422|   170k|    {
15423|   170k|        SetWindowViewport(window, main_viewport);
15424|   170k|        return;
15425|   170k|    }
15426|      0|    window->ViewportOwned = false;
15427|       |
15428|       |    // Appearing popups reset their viewport so they can inherit again
15429|      0|    if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window->Appearing)
  ------------------
  |  Branch (15429:9): [True: 0, False: 0]
  |  Branch (15429:74): [True: 0, False: 0]
  ------------------
15430|      0|    {
15431|      0|        window->Viewport = NULL;
15432|      0|        window->ViewportId = 0;
15433|      0|    }
15434|       |
15435|      0|    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport) == 0)
  ------------------
  |  Branch (15435:9): [True: 0, False: 0]
  ------------------
15436|      0|    {
15437|       |        // By default inherit from parent window
15438|      0|        if (window->Viewport == NULL && window->ParentWindow && (!window->ParentWindow->IsFallbackWindow || window->ParentWindow->WasActive))
  ------------------
  |  Branch (15438:13): [True: 0, False: 0]
  |  Branch (15438:41): [True: 0, False: 0]
  |  Branch (15438:66): [True: 0, False: 0]
  |  Branch (15438:109): [True: 0, False: 0]
  ------------------
15439|      0|            window->Viewport = window->ParentWindow->Viewport;
15440|       |
15441|       |        // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
15442|      0|        if (window->Viewport == NULL && window->ViewportId != 0)
  ------------------
  |  Branch (15442:13): [True: 0, False: 0]
  |  Branch (15442:41): [True: 0, False: 0]
  ------------------
15443|      0|        {
15444|      0|            window->Viewport = (ImGuiViewportP*)FindViewportByID(window->ViewportId);
15445|      0|            if (window->Viewport == NULL && window->ViewportPos.x != FLT_MAX && window->ViewportPos.y != FLT_MAX)
  ------------------
  |  Branch (15445:17): [True: 0, False: 0]
  |  Branch (15445:45): [True: 0, False: 0]
  |  Branch (15445:81): [True: 0, False: 0]
  ------------------
15446|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->ViewportPos, window->Size, ImGuiViewportFlags_None);
15447|      0|        }
15448|      0|    }
15449|       |
15450|      0|    bool lock_viewport = false;
15451|      0|    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasViewport)
  ------------------
  |  Branch (15451:9): [True: 0, False: 0]
  ------------------
15452|      0|    {
15453|       |        // Code explicitly request a viewport
15454|      0|        window->Viewport = (ImGuiViewportP*)FindViewportByID(g.NextWindowData.ViewportId);
15455|      0|        window->ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
15456|      0|        if (window->Viewport && (window->Flags & ImGuiWindowFlags_DockNodeHost) != 0 && window->Viewport->Window != NULL)
  ------------------
  |  Branch (15456:13): [True: 0, False: 0]
  |  Branch (15456:33): [True: 0, False: 0]
  |  Branch (15456:89): [True: 0, False: 0]
  ------------------
15457|      0|        {
15458|      0|            window->Viewport->Window = window;
15459|      0|            window->Viewport->ID = window->ViewportId = window->ID; // Overwrite ID (always owned by node)
15460|      0|        }
15461|      0|        lock_viewport = true;
15462|      0|    }
15463|      0|    else if ((flags & ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_ChildMenu))
  ------------------
  |  Branch (15463:14): [True: 0, False: 0]
  |  Branch (15463:56): [True: 0, False: 0]
  ------------------
15464|      0|    {
15465|       |        // Always inherit viewport from parent window
15466|      0|        if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (15466:13): [True: 0, False: 0]
  |  Branch (15466:33): [True: 0, False: 0]
  ------------------
15467|      0|            IM_ASSERT(window->DockNode->HostWindow->Viewport == window->ParentWindow->Viewport);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
15468|      0|        window->Viewport = window->ParentWindow->Viewport;
15469|      0|    }
15470|      0|    else if (window->DockNode && window->DockNode->HostWindow)
  ------------------
  |  Branch (15470:14): [True: 0, False: 0]
  |  Branch (15470:34): [True: 0, False: 0]
  ------------------
15471|      0|    {
15472|       |        // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
15473|      0|        window->Viewport = window->DockNode->HostWindow->Viewport;
15474|      0|    }
15475|      0|    else if (flags & ImGuiWindowFlags_Tooltip)
  ------------------
  |  Branch (15475:14): [True: 0, False: 0]
  ------------------
15476|      0|    {
15477|      0|        window->Viewport = g.MouseViewport;
15478|      0|    }
15479|      0|    else if (GetWindowAlwaysWantOwnViewport(window))
  ------------------
  |  Branch (15479:14): [True: 0, False: 0]
  ------------------
15480|      0|    {
15481|      0|        window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
15482|      0|    }
15483|      0|    else if (g.MovingWindow && g.MovingWindow->RootWindowDockTree == window && IsMousePosValid())
  ------------------
  |  Branch (15483:14): [True: 0, False: 0]
  |  Branch (15483:32): [True: 0, False: 0]
  |  Branch (15483:80): [True: 0, False: 0]
  ------------------
15484|      0|    {
15485|      0|        if (window->Viewport != NULL && window->Viewport->Window == window)
  ------------------
  |  Branch (15485:13): [True: 0, False: 0]
  |  Branch (15485:41): [True: 0, False: 0]
  ------------------
15486|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
15487|      0|    }
15488|      0|    else
15489|      0|    {
15490|       |        // Merge into host viewport?
15491|       |        // We cannot test window->ViewportOwned as it set lower in the function.
15492|       |        // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
15493|      0|        bool try_to_merge_into_host_viewport = (window->Viewport && window == window->Viewport->Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
  ------------------
  |  Branch (15493:49): [True: 0, False: 0]
  |  Branch (15493:69): [True: 0, False: 0]
  |  Branch (15493:108): [True: 0, False: 0]
  |  Branch (15493:127): [True: 0, False: 0]
  ------------------
15494|      0|        if (try_to_merge_into_host_viewport)
  ------------------
  |  Branch (15494:13): [True: 0, False: 0]
  ------------------
15495|      0|            UpdateTryMergeWindowIntoHostViewports(window);
15496|      0|    }
15497|       |
15498|       |    // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
15499|      0|    if (window->Viewport == NULL)
  ------------------
  |  Branch (15499:9): [True: 0, False: 0]
  ------------------
15500|      0|        if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport))
  ------------------
  |  Branch (15500:13): [True: 0, False: 0]
  ------------------
15501|      0|            window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_None);
15502|       |
15503|       |    // Mark window as allowed to protrude outside of its viewport and into the current monitor
15504|      0|    if (!lock_viewport)
  ------------------
  |  Branch (15504:9): [True: 0, False: 0]
  ------------------
15505|      0|    {
15506|      0|        if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
  ------------------
  |  Branch (15506:13): [True: 0, False: 0]
  ------------------
15507|      0|        {
15508|       |            // We need to take account of the possibility that mouse may become invalid.
15509|       |            // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
15510|      0|            ImVec2 mouse_ref = (flags & ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
  ------------------
  |  Branch (15510:32): [True: 0, False: 0]
  ------------------
15511|      0|            bool use_mouse_ref = (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow);
  ------------------
  |  Branch (15511:35): [True: 0, False: 0]
  |  Branch (15511:60): [True: 0, False: 0]
  |  Branch (15511:87): [True: 0, False: 0]
  ------------------
15512|      0|            bool mouse_valid = IsMousePosValid(&mouse_ref);
15513|      0|            if ((window->Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid))
  ------------------
  |  Branch (15513:18): [True: 0, False: 0]
  |  Branch (15513:39): [True: 0, False: 0]
  |  Branch (15513:110): [True: 0, False: 0]
  |  Branch (15513:128): [True: 0, False: 0]
  ------------------
15514|      0|                window->ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
  ------------------
  |  Branch (15514:89): [True: 0, False: 0]
  |  Branch (15514:106): [True: 0, False: 0]
  ------------------
15515|      0|            else
15516|      0|                window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
15517|      0|        }
15518|      0|        else if (window->Viewport && window != window->Viewport->Window && window->Viewport->Window && !(flags & ImGuiWindowFlags_ChildWindow) && window->DockNode == NULL)
  ------------------
  |  Branch (15518:18): [True: 0, False: 0]
  |  Branch (15518:38): [True: 0, False: 0]
  |  Branch (15518:76): [True: 0, False: 0]
  |  Branch (15518:104): [True: 0, False: 0]
  |  Branch (15518:147): [True: 0, False: 0]
  ------------------
15519|      0|        {
15520|       |            // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
15521|      0|            const bool will_be_visible = (window->DockIsActive && !window->DockTabIsVisible) ? false : true;
  ------------------
  |  Branch (15521:43): [True: 0, False: 0]
  |  Branch (15521:67): [True: 0, False: 0]
  ------------------
15522|      0|            if ((window->Flags & ImGuiWindowFlags_DockNodeHost) && window->Viewport->LastFrameActive < g.FrameCount && will_be_visible)
  ------------------
  |  Branch (15522:17): [True: 0, False: 0]
  |  Branch (15522:68): [True: 0, False: 0]
  |  Branch (15522:120): [True: 0, False: 0]
  ------------------
15523|      0|            {
15524|       |                // Steal/transfer ownership
15525|      0|                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window->Name, window->Viewport->ID, window->Viewport->Window->Name);
  ------------------
  |  |  254|      0|#define IMGUI_DEBUG_LOG_VIEWPORT(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventViewport)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
  |  |  ------------------
  |  |  |  |  241|      0|#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
  |  |  ------------------
  |  |  |  Branch (254:50): [True: 0, False: 0]
  |  |  |  Branch (254:144): [Folded - Ignored]
  |  |  ------------------
  ------------------
15526|      0|                window->Viewport->Window = window;
15527|      0|                window->Viewport->ID = window->ID;
15528|      0|                window->Viewport->LastNameHash = 0;
15529|      0|            }
15530|      0|            else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
  ------------------
  |  Branch (15530:22): [True: 0, False: 0]
  ------------------
15531|      0|            {
15532|       |                // New viewport
15533|      0|                window->Viewport = AddUpdateViewport(window, window->ID, window->Pos, window->Size, ImGuiViewportFlags_NoFocusOnAppearing);
15534|      0|            }
15535|      0|        }
15536|      0|        else if (window->ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_ChildWindow) == 0)
  ------------------
  |  Branch (15536:18): [True: 0, False: 0]
  |  Branch (15536:68): [True: 0, False: 0]
  ------------------
15537|      0|        {
15538|       |            // Regular (non-child, non-popup) windows by default are also allowed to protrude
15539|       |            // Child windows are kept contained within their parent.
15540|      0|            window->ViewportAllowPlatformMonitorExtend = window->Viewport->PlatformMonitor;
15541|      0|        }
15542|      0|    }
15543|       |
15544|       |    // Update flags
15545|      0|    window->ViewportOwned = (window == window->Viewport->Window);
15546|      0|    window->ViewportId = window->Viewport->ID;
15547|       |
15548|       |    // If the OS window has a title bar, hide our imgui title bar
15549|       |    //if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
15550|       |    //    window->Flags |= ImGuiWindowFlags_NoTitleBar;
15551|      0|}
imgui.cpp:_ZL23StoreDockStyleForWindowP11ImGuiWindow:
19353|    158|{
19354|    158|    ImGuiContext& g = *GImGui;
19355|  1.42k|    for (int color_n = 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n++)
  ------------------
  |  Branch (19355:27): [True: 1.26k, False: 158]
  ------------------
19356|  1.26k|        window->DockStyle.Colors[color_n] = ImGui::ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
19357|    158|}
imgui.cpp:_ZN5ImGuiL21DockNodeIsDropAllowedEP11ImGuiWindowS1_:
17954|      1|{
17955|      1|    if (root_payload->DockNodeAsHost && root_payload->DockNodeAsHost->IsSplitNode()) // FIXME-DOCK: Missing filtering
  ------------------
  |  Branch (17955:9): [True: 0, False: 1]
  |  Branch (17955:41): [True: 0, False: 0]
  ------------------
17956|      0|        return true;
17957|       |
17958|      1|    const int payload_count = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows.Size : 1;
  ------------------
  |  Branch (17958:31): [True: 0, False: 1]
  ------------------
17959|      1|    for (int payload_n = 0; payload_n < payload_count; payload_n++)
  ------------------
  |  Branch (17959:29): [True: 1, False: 0]
  ------------------
17960|      1|    {
17961|      1|        ImGuiWindow* payload = root_payload->DockNodeAsHost ? root_payload->DockNodeAsHost->Windows[payload_n] : root_payload;
  ------------------
  |  Branch (17961:32): [True: 0, False: 1]
  ------------------
17962|      1|        if (DockNodeIsDropAllowedOne(payload, host_window))
  ------------------
  |  Branch (17962:13): [True: 1, False: 0]
  ------------------
17963|      1|            return true;
17964|      1|    }
17965|      0|    return false;
17966|      1|}
imgui.cpp:_ZL24DockNodeIsDropAllowedOneP11ImGuiWindowS0_:
17922|      1|{
17923|      1|    if (host_window->DockNodeAsHost && host_window->DockNodeAsHost->IsDockSpace() && payload->BeginOrderWithinContext < host_window->BeginOrderWithinContext)
  ------------------
  |  Branch (17923:9): [True: 0, False: 1]
  |  Branch (17923:40): [True: 0, False: 0]
  |  Branch (17923:86): [True: 0, False: 0]
  ------------------
17924|      0|        return false;
17925|       |
17926|      1|    ImGuiWindowClass* host_class = host_window->DockNodeAsHost ? &host_window->DockNodeAsHost->WindowClass : &host_window->WindowClass;
  ------------------
  |  Branch (17926:36): [True: 0, False: 1]
  ------------------
17927|      1|    ImGuiWindowClass* payload_class = &payload->WindowClass;
17928|      1|    if (host_class->ClassId != payload_class->ClassId)
  ------------------
  |  Branch (17928:9): [True: 0, False: 1]
  ------------------
17929|      0|    {
17930|      0|        bool pass = false;
17931|      0|        if (host_class->ClassId != 0 && host_class->DockingAllowUnclassed && payload_class->ClassId == 0)
  ------------------
  |  Branch (17931:13): [True: 0, False: 0]
  |  Branch (17931:41): [True: 0, False: 0]
  |  Branch (17931:78): [True: 0, False: 0]
  ------------------
17932|      0|            pass = true;
17933|      0|        if (payload_class->ClassId != 0 && payload_class->DockingAllowUnclassed && host_class->ClassId == 0)
  ------------------
  |  Branch (17933:13): [True: 0, False: 0]
  |  Branch (17933:44): [True: 0, False: 0]
  |  Branch (17933:84): [True: 0, False: 0]
  ------------------
17934|      0|            pass = true;
17935|      0|        if (!pass)
  ------------------
  |  Branch (17935:13): [True: 0, False: 0]
  ------------------
17936|      0|            return false;
17937|      0|    }
17938|       |
17939|       |    // Prevent docking any window created above a popup
17940|       |    // Technically we should support it (e.g. in the case of a long-lived modal window that had fancy docking features),
17941|       |    // by e.g. adding a 'if (!ImGui::IsWindowWithinBeginStackOf(host_window, popup_window))' test.
17942|       |    // But it would requires more work on our end because the dock host windows is technically created in NewFrame()
17943|       |    // and our ->ParentXXX and ->RootXXX pointers inside windows are currently mislading or lacking.
17944|      1|    ImGuiContext& g = *GImGui;
17945|      1|    for (int i = g.OpenPopupStack.Size - 1; i >= 0; i--)
  ------------------
  |  Branch (17945:45): [True: 0, False: 1]
  ------------------
17946|      0|        if (ImGuiWindow* popup_window = g.OpenPopupStack[i].Window)
  ------------------
  |  Branch (17946:26): [True: 0, False: 0]
  ------------------
17947|      0|            if (ImGui::IsWindowWithinBeginStackOf(payload, popup_window))   // Payload is created from within a popup begin stack.
  ------------------
  |  Branch (17947:17): [True: 0, False: 0]
  ------------------
17948|      0|                return false;
17949|       |
17950|      1|    return true;
17951|      1|}
imgui.cpp:_ZN5ImGuiL30UpdateDebugToolFlashStyleColorEv:
20191|  76.6k|{
20192|  76.6k|    ImGuiContext& g = *GImGui;
20193|  76.6k|    if (g.DebugFlashStyleColorTime <= 0.0f)
  ------------------
  |  Branch (20193:9): [True: 76.6k, False: 0]
  ------------------
20194|  76.6k|        return;
20195|      0|    ColorConvertHSVtoRGB(cosf(g.DebugFlashStyleColorTime * 6.0f) * 0.5f + 0.5f, 0.5f, 0.5f, g.Style.Colors[g.DebugFlashStyleColorIdx].x, g.Style.Colors[g.DebugFlashStyleColorIdx].y, g.Style.Colors[g.DebugFlashStyleColorIdx].z);
20196|      0|    g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0f;
20197|      0|    if ((g.DebugFlashStyleColorTime -= g.IO.DeltaTime) <= 0.0f)
  ------------------
  |  Branch (20197:9): [True: 0, False: 0]
  ------------------
20198|      0|        DebugFlashStyleColorStop();
20199|      0|}
imgui.cpp:_ZN5ImGuiL25UpdateDebugToolItemPickerEv:
21723|  76.6k|{
21724|  76.6k|    ImGuiContext& g = *GImGui;
21725|  76.6k|    g.DebugItemPickerBreakId = 0;
21726|  76.6k|    if (!g.DebugItemPickerActive)
  ------------------
  |  Branch (21726:9): [True: 76.6k, False: 0]
  ------------------
21727|  76.6k|        return;
21728|       |
21729|      0|    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
21730|      0|    SetMouseCursor(ImGuiMouseCursor_Hand);
21731|      0|    if (IsKeyPressed(ImGuiKey_Escape))
  ------------------
  |  Branch (21731:9): [True: 0, False: 0]
  ------------------
21732|      0|        g.DebugItemPickerActive = false;
21733|      0|    const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
21734|      0|    if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
  ------------------
  |  Branch (21734:9): [True: 0, False: 0]
  |  Branch (21734:28): [True: 0, False: 0]
  |  Branch (21734:76): [True: 0, False: 0]
  ------------------
21735|      0|    {
21736|      0|        g.DebugItemPickerBreakId = hovered_id;
21737|      0|        g.DebugItemPickerActive = false;
21738|      0|    }
21739|      0|    for (int mouse_button = 0; mouse_button < 3; mouse_button++)
  ------------------
  |  Branch (21739:32): [True: 0, False: 0]
  ------------------
21740|      0|        if (change_mapping && IsMouseClicked(mouse_button))
  ------------------
  |  Branch (21740:13): [True: 0, False: 0]
  |  Branch (21740:31): [True: 0, False: 0]
  ------------------
21741|      0|            g.DebugItemPickerMouseButton = (ImU8)mouse_button;
21742|      0|    SetNextWindowBgAlpha(0.70f);
21743|      0|    if (!BeginTooltip())
  ------------------
  |  Branch (21743:9): [True: 0, False: 0]
  ------------------
21744|      0|        return;
21745|      0|    Text("HoveredId: 0x%08X", hovered_id);
21746|      0|    Text("Press ESC to abort picking.");
21747|      0|    const char* mouse_button_names[] = { "Left", "Right", "Middle" };
21748|      0|    if (change_mapping)
  ------------------
  |  Branch (21748:9): [True: 0, False: 0]
  ------------------
21749|      0|        Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
21750|      0|    else
21751|      0|        TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
  ------------------
  |  Branch (21751:39): [True: 0, False: 0]
  ------------------
21752|      0|    EndTooltip();
21753|      0|}
imgui.cpp:_ZN5ImGuiL27UpdateDebugToolStackQueriesEv:
21757|  76.6k|{
21758|  76.6k|    ImGuiContext& g = *GImGui;
21759|  76.6k|    ImGuiIDStackTool* tool = &g.DebugIDStackTool;
21760|       |
21761|       |    // Clear hook when id stack tool is not visible
21762|  76.6k|    g.DebugHookIdInfo = 0;
21763|  76.6k|    if (g.FrameCount != tool->LastActiveFrame + 1)
  ------------------
  |  Branch (21763:9): [True: 76.6k, False: 5]
  ------------------
21764|  76.6k|        return;
21765|       |
21766|       |    // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
21767|       |    // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
21768|      5|    const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
  ------------------
  |  Branch (21768:30): [True: 0, False: 5]
  ------------------
21769|      5|    if (tool->QueryId != query_id)
  ------------------
  |  Branch (21769:9): [True: 0, False: 5]
  ------------------
21770|      0|    {
21771|      0|        tool->QueryId = query_id;
21772|      0|        tool->StackLevel = -1;
21773|      0|        tool->Results.resize(0);
21774|      0|    }
21775|      5|    if (query_id == 0)
  ------------------
  |  Branch (21775:9): [True: 5, False: 0]
  ------------------
21776|      5|        return;
21777|       |
21778|       |    // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
21779|      0|    int stack_level = tool->StackLevel;
21780|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (21780:9): [True: 0, False: 0]
  |  Branch (21780:29): [True: 0, False: 0]
  ------------------
21781|      0|        if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
  ------------------
  |  Branch (21781:13): [True: 0, False: 0]
  |  Branch (21781:56): [True: 0, False: 0]
  ------------------
21782|      0|            tool->StackLevel++;
21783|       |
21784|       |    // Update hook
21785|      0|    stack_level = tool->StackLevel;
21786|      0|    if (stack_level == -1)
  ------------------
  |  Branch (21786:9): [True: 0, False: 0]
  ------------------
21787|      0|        g.DebugHookIdInfo = query_id;
21788|      0|    if (stack_level >= 0 && stack_level < tool->Results.Size)
  ------------------
  |  Branch (21788:9): [True: 0, False: 0]
  |  Branch (21788:29): [True: 0, False: 0]
  ------------------
21789|      0|    {
21790|      0|        g.DebugHookIdInfo = tool->Results[stack_level].ID;
21791|      0|        tool->Results[stack_level].QueryFrameCount++;
21792|      0|    }
21793|      0|}

_ZN6ImVec2C2Ev:
  283|  1.41M|    constexpr ImVec2()                      : x(0.0f), y(0.0f) { }
_ZN6ImVec4C2Ev:
  296|   433k|    constexpr ImVec4()                                        : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
_ZN6ImVec2C2Eff:
  284|  21.5M|    constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }
imgui.cpp:_ZmlRK6ImVec2f:
 2713|   502k|static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui.cpp:_ZmiRK6ImVec2S1_:
 2716|   794k|static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui.cpp:_ZplRK6ImVec2S1_:
 2715|  1.55M|static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
_ZN6ImVec4C2Effff:
  297|   879k|    constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }
_ZN16ImGuiStoragePairC2EjPv:
 2608|      3|    ImGuiStoragePair(ImGuiID _key, void* _val)  { key = _key; val_p = _val; }
_Znwm12ImNewWrapperPv:
 2049|     10|inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
_ZN15ImGuiPlatformIOC2Ev:
 3507|      1|    ImGuiPlatformIO()               { memset(this, 0, sizeof(*this)); }     // Zero clear
_ZN8ImVectorI20ImGuiPlatformMonitorEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP13ImGuiViewportEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiInputEventEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiWindowStackDataEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiColorModEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImGuiStyleModEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP6ImFontEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiFocusScopeDataEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIiEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiGroupDataEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI14ImGuiPopupDataEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiNavTreeNodeDataEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformMonitorC2Ev:
 3518|      1|    ImGuiPlatformMonitor()          { MainPos = MainSize = WorkPos = WorkSize = ImVec2(0, 0); DpiScale = 1.0f; PlatformHandle = NULL; }
_ZN12ImGuiPayloadC2Ev:
 2526|      1|    ImGuiPayload()  { Clear(); }
_ZN8ImVectorIhEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiListClipperDataEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImGuiTableTempDataEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImGuiTableEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIfEC2Ev:
 2082|      9|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI13ImDrawChannelEC2Ev:
 2082|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImGuiTabBarEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiPtrOrIndexEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI20ImGuiShrinkWidthItemEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIcEC2Ev:
 2082|     10|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN20ImGuiPlatformImeDataC2Ev:
 3528|      2|    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
_ZN8ImVectorI16ImGuiDockRequestEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI21ImGuiDockNodeSettingsEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN15ImGuiTextBufferC2Ev:
 2587|      3|    ImGuiTextBuffer()   { }
_ZN8ImVectorI20ImGuiSettingsHandlerEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16ImGuiContextHookEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiStackLevelInfoEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN13ImGuiViewportC2Ev:
 3391|      1|    ImGuiViewport()     { memset(this, 0, sizeof(*this)); }
_ZN10ImDrawDataC2Ev:
 3069|      1|    ImDrawData()    { Clear(); }
_ZN8ImVectorIP10ImDrawListEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorItE5clearEv:
 2087|      4|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 2, False: 2]
  ------------------
_ZN16ImGuiWindowClassC2Ev:
 2508|      7|    ImGuiWindowClass() { memset(this, 0, sizeof(*this)); ParentViewportId = (ImGuiID)-1; DockingAllowUnclassed = true; }
_ZN8ImVectorI16ImGuiStoragePairEC2Ev:
 2082|      7|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN10ImDrawListC2EP20ImDrawListSharedData:
 2938|      3|    ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }
_ZN8ImVectorI9ImDrawCmdEC2Ev:
 2082|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10ImDrawVertEC2Ev:
 2082|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI6ImVec2EC2Ev:
 2082|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN18ImDrawListSplitterC2Ev:
 2867|      3|    inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }
_ZN8ImVectorI6ImVec4EC2Ev:
 2082|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIPvEC2Ev:
 2082|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP6ImFontEixEi:
 2096|  76.6k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK6ImFont8IsLoadedEv:
 3312|   153k|    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
_ZN8ImVectorIP10ImDrawListE6resizeEi:
 2110|   230k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 230k]
  ------------------
_ZN8ImVectorIP10ImDrawListE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI9ImDrawCmdE8pop_backEv:
 2118|   169k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   169k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE9push_backERKS0_:
 2117|   356k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 4, False: 356k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE7reserveEi:
 2113|      4|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 4]
  |  Branch (2113:167): [True: 0, False: 4]
  ------------------
_ZNK8ImVectorI9ImDrawCmdE14_grow_capacityEi:
 2109|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 4]
  |  Branch (2109:131): [True: 4, False: 0]
  ------------------
_ZNK8ImVectorIP10ImDrawListE5emptyEv:
 2091|  76.6k|    inline bool         empty() const                       { return Size == 0; }
_ZNK8ImVectorIP11ImGuiWindowE14_grow_capacityEi:
 2109|      3|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 3]
  |  Branch (2109:131): [True: 3, False: 0]
  ------------------
_ZNK8ImVectorIP11ImGuiWindowE8containsERKS1_:
 2124|      3|    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
  ------------------
  |  Branch (2124:126): [True: 1, False: 2]
  |  Branch (2124:147): [True: 0, False: 1]
  ------------------
imgui.cpp:_ZmlRK6ImVec2S1_:
 2717|  34.0k|static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
_ZNK6ImVec2ixEm:
  286|      8|    float  operator[] (size_t idx) const    { IM_ASSERT(idx == 0 || idx == 1); return ((const float*)(const void*)(const char*)this)[idx]; }
  ------------------
  |  |   23|      8|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui.cpp:_ZmIR6ImVec2RKS_:
 2723|     18|static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
_ZN10ImDrawList10PathLineToERK6ImVec2:
 2994|  1.22M|    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
_ZN8ImVectorI6ImVec2E9push_backERKS0_:
 2117|  1.25M|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 3, False: 1.25M]
  ------------------
_ZN8ImVectorI6ImVec2E7reserveEi:
 2113|  3.13k|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      6|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 3.12k, False: 6]
  |  Branch (2113:167): [True: 2, False: 4]
  ------------------
_ZNK8ImVectorI6ImVec2E14_grow_capacityEi:
 2109|      6|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 2, False: 4]
  |  Branch (2109:131): [True: 6, False: 0]
  ------------------
_ZN10ImDrawList14PathFillConvexEj:
 2996|   181k|    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
_ZN10ImDrawList10PathStrokeEjif:
 2998|   199k|    inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
imgui.cpp:_ZpLR6ImVec2RKS_:
 2722|  1.48k|static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)        { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
_ZN8ImVectorI19ImGuiKeyRoutingDataE6resizeEi:
 2110|  76.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 76.6k]
  ------------------
_ZN8ImVectorI19ImGuiKeyRoutingDataE4swapERS1_:
 2107|  76.6k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZNK11ImFontAtlas7IsBuiltEv:
 3198|  76.6k|    bool                        IsBuilt() const             { return Fonts.Size > 0 && TexReady; } // Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
  ------------------
  |  Branch (3198:70): [True: 76.6k, False: 0]
  |  Branch (3198:88): [True: 76.6k, False: 0]
  ------------------
_ZN8ImVectorI20ImGuiPlatformMonitorE5beginEv:
 2099|  76.6k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI20ImGuiPlatformMonitorE3endEv:
 2101|  76.6k|    inline T*           end()                               { return Data + Size; }
_ZN6ImVec2ixEm:
  285|  1.97M|    float& operator[] (size_t idx)          { IM_ASSERT(idx == 0 || idx == 1); return ((float*)(void*)(char*)this)[idx]; } // We very rarely use this [] operator, so the assert overhead is fine.
  ------------------
  |  |   23|  1.97M|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN12ImGuiPayload5ClearEv:
 2527|      5|    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
_ZNK12ImGuiPayload10IsDataTypeEPKc:
 2528|      2|    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
  ------------------
  |  Branch (2528:54): [True: 2, False: 0]
  |  Branch (2528:78): [True: 2, False: 0]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE6resizeEi:
 2110|  76.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 76.6k]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP13ImGuiViewportE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZNK12ImGuiPayload9IsPreviewEv:
 2529|      1|    bool IsPreview() const                  { return Preview; }
_ZNK12ImGuiPayload10IsDeliveryEv:
 2530|      1|    bool IsDelivery() const                 { return Delivery; }
_ZN8ImVectorI16ImGuiStoragePairE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiEixEi:
 2096|    446|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIcE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZN8ImVectorItEC2Ev:
 2082|      7|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjEC2Ev:
 2082|      4|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjED2Ev:
 2085|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2085:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIjE6resizeEi:
 2110|   247k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 2, False: 247k]
  ------------------
_ZN8ImVectorIjE7reserveEi:
 2113|      6|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      6|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 6]
  |  Branch (2113:167): [True: 0, False: 6]
  ------------------
_ZNK8ImVectorIjE14_grow_capacityEi:
 2109|      6|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 6]
  |  Branch (2109:131): [True: 4, False: 2]
  ------------------
_ZN8ImVectorIjE5clearEv:
 2087|      4|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      4|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 4, False: 0]
  ------------------
_ZN8ImVectorItEixEi:
 2096|    608|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    608|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowEC2Ev:
 2082|      6|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIP14ImGuiViewportPEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI15ImGuiInputEventE9push_backERKS0_:
 2117|  56.7k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 16, False: 56.7k]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE7reserveEi:
 2113|     16|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|     16|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|     14|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 16]
  |  Branch (2113:167): [True: 14, False: 2]
  ------------------
_ZNK8ImVectorI15ImGuiInputEventE14_grow_capacityEi:
 2109|     16|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 14, False: 2]
  |  Branch (2109:131): [True: 16, False: 0]
  ------------------
_ZN8ImVectorItE6resizeEi:
 2110|  1.10M|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 27, False: 1.10M]
  ------------------
_ZNK8ImVectorItE14_grow_capacityEi:
 2109|     36|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 31, False: 5]
  |  Branch (2109:131): [True: 22, False: 14]
  ------------------
_ZN8ImVectorI15ImGuiInputEventEixEi:
 2096|  91.1k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|  91.1k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorI16ImGuiStoragePairE3endEv:
 2102|   170k|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorI16ImGuiStoragePairE3endEv:
 2101|      3|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI16ImGuiStoragePairE6insertEPKS0_RS2_:
 2123|      3|    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (2123:144): [True: 1, False: 2]
  |  Branch (2123:201): [True: 2, False: 1]
  ------------------
_ZNK8ImVectorI16ImGuiStoragePairE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorIcE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorIiE9push_backERKi:
 2117|  93.8k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 93.8k]
  ------------------
_ZN8ImVectorIiE7reserveEi:
 2113|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 2]
  |  Branch (2113:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorIiE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE9push_backERKS0_:
 2117|  76.6k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 76.6k]
  ------------------
_ZN8ImVectorI13ImGuiColorModE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiColorModE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiColorModE4backEv:
 2105|  76.6k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiColorModE8pop_backEv:
 2118|  76.6k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE9push_backERKS0_:
 2117|  76.6k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 76.6k]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI13ImGuiStyleModE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI13ImGuiStyleModE4backEv:
 2105|  76.6k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI13ImGuiStyleModE8pop_backEv:
 2118|  76.6k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  76.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE5beginEv:
 2099|   383k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP14ImGuiViewportPE3endEv:
 2101|   383k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorIiED2Ev:
 2085|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2085:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE9push_backERKS1_:
 2117|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP14ImGuiViewportPE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIcE6resizeEiRKc:
 2111|  3.07k|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (2111:67): [True: 1, False: 0]
  |  Branch (2111:127): [True: 1, False: 0]
  |  Branch (2111:163): [True: 3.07k, False: 1]
  ------------------
_ZN8ImVectorIP13ImGuiViewportE9push_backERKS1_:
 2117|  76.6k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 76.6k]
  ------------------
_ZN8ImVectorIP14ImGuiViewportPEixEi:
 2096|   707k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   707k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI6ImVec2E5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorI13ImDrawChannelE5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 0, False: 2]
  ------------------
_ZN8ImVectorI16ImGuiContextHookE5beginEv:
 2099|   460k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI16ImGuiContextHookE3endEv:
 2101|   460k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI15ImGuiOldColumnsEC2Ev:
 2082|      3|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorIjE9push_backERKj:
 2117|  16.9k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 4, False: 16.9k]
  ------------------
_ZN8ImVectorIfE5clearEv:
 2087|      6|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 0, False: 6]
  ------------------
_ZN8ImVectorItE7reserveEi:
 2113|     37|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|     37|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|     31|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 37]
  |  Branch (2113:167): [True: 31, False: 6]
  ------------------
_ZN8ImVectorI10ImDrawVertE7reserveEi:
 2113|     25|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|     25|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|     21|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 25]
  |  Branch (2113:167): [True: 21, False: 4]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE6resizeEi:
 2110|   153k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 153k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE5beginEv:
 2099|   323k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP11ImGuiWindowE3endEv:
 2101|   323k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorIfEixEi:
 2096|    512|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    512|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImGuiTableTempDataE5beginEv:
 2099|  76.6k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI18ImGuiTableTempDataE3endEv:
 2101|  76.6k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI20ImGuiWindowStackDataE6resizeEi:
 2110|  76.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 76.6k]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiWindowStackDataE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI14ImGuiPopupDataE6resizeEi:
 2110|  76.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 76.6k]
  ------------------
_ZN8ImVectorIiE6resizeEi:
 2110|  76.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 76.6k]
  ------------------
_ZN8ImVectorI14ImGuiGroupDataE6resizeEi:
 2110|  76.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 76.6k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE9push_backERKS1_:
 2117|   247k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 3, False: 247k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowEixEi:
 2096|   248k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   248k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI6ImVec4E4backEv:
 2105|   511k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   511k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI9ImDrawCmdE4backEv:
 2105|  16.9k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE6resizeEi:
 2110|   247k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 247k]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE7reserveEi:
 2113|  76.7k|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 76.6k, False: 4]
  |  Branch (2113:167): [True: 0, False: 4]
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4swapERS2_:
 2107|  76.6k|    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
_ZN8ImVectorIP10ImDrawListE5beginEv:
 2099|  76.6k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP10ImDrawListE3endEv:
 2101|  76.6k|    inline T*           end()                               { return Data + Size; }
_ZNK8ImVectorI20ImGuiWindowStackDataE5emptyEv:
 2091|   170k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI20ImGuiWindowStackDataE4backEv:
 2105|   357k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   357k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE9push_backERKS0_:
 2117|   170k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 170k]
  ------------------
_ZN8ImVectorI9ImDrawCmdEixEi:
 2096|   403k|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|   403k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIfE6resizeEi:
 2110|   340k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 340k]
  ------------------
_ZN8ImVectorIfE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIfE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI20ImGuiWindowStackDataE8pop_backEv:
 2118|   170k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP11ImGuiWindowE4backEv:
 2105|  10.6k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  10.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIP6ImFontE9push_backERKS1_:
 2117|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorIP6ImFontE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorIP6ImFontE4backEv:
 2105|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE4backEv:
 2105|  33.8k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  33.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIiE8pop_backEv:
 2118|  16.9k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI19ImGuiFocusScopeDataE9push_backERKS0_:
 2117|   177k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 2, False: 177k]
  ------------------
_ZN8ImVectorI19ImGuiFocusScopeDataE7reserveEi:
 2113|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 2]
  |  Branch (2113:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorI19ImGuiFocusScopeDataE14_grow_capacityEi:
 2109|      2|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 2]
  |  Branch (2109:131): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI19ImGuiFocusScopeDataE8pop_backEv:
 2118|   170k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI19ImGuiFocusScopeDataE4backEv:
 2105|  93.6k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|  93.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI19ImGuiFocusScopeDataE6resizeEi:
 2110|  7.09k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 7.09k]
  ------------------
_ZN8ImVectorIjE4backEv:
 2105|   323k|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|   323k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIjE8pop_backEv:
 2118|  16.9k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|  16.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorItE9push_backERKt:
 2117|  3.17k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 8, False: 3.16k]
  ------------------
_ZN8ImVectorI15ImGuiInputEventE5eraseEPKS0_S3_:
 2121|  9.71k|    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
  ------------------
  |  |   23|  9.71k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIhE5clearEv:
 2087|      4|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 0, False: 4]
  ------------------
_ZN8ImVectorIhE6resizeEi:
 2110|    158|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 158]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE9push_backERKS0_:
 2117|      3|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 2]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI20ImGuiSettingsHandlerE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI20ImGuiSettingsHandlerE5beginEv:
 2099|      2|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI20ImGuiSettingsHandlerE3endEv:
 2101|      2|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI16ImGuiDockRequestE5beginEv:
 2099|   153k|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI16ImGuiDockRequestE3endEv:
 2101|   153k|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI16ImGuiDockRequestE6resizeEi:
 2110|  76.6k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 76.6k]
  ------------------
_ZN8ImVectorIP6ImFontE5beginEv:
 2099|      1|    inline T*           begin()                             { return Data; }
_ZN8ImVectorIP6ImFontE3endEv:
 2101|      1|    inline T*           end()                               { return Data + Size; }
_ZN9ImDrawCmdC2Ev:
 2821|   356k|    ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed
_ZN18ImDrawListSplitter5ClearEv:
 2869|   170k|    inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame
_ZN21ImFontAtlasCustomRectC2Ev:
 3145|      2|    ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
_ZNK21ImFontAtlasCustomRect8IsPackedEv:
 3146|      2|    bool IsPacked() const           { return X != 0xFFFF; }
_ZN11ImFontAtlas20GetCustomRectByIndexEi:
 3232|      2|    ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectEixEi:
 2096|     16|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     16|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui_draw.cpp:_ZmlRK6ImVec4S1_:
 2730|      1|static inline ImVec4  operator*(const ImVec4& lhs, const ImVec4& rhs)   { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }
imgui_draw.cpp:_ZplRK6ImVec2S1_:
 2715|   851k|static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui_draw.cpp:_ZmlRK6ImVec2f:
 2713|   510k|static inline ImVec2  operator*(const ImVec2& lhs, const float rhs)     { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
imgui_draw.cpp:_ZmiRK6ImVec2S1_:
 2716|   212k|static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
imgui_draw.cpp:_ZmlRK6ImVec2S1_:
 2717|    128|static inline ImVec2  operator*(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
_ZN8ImVectorI18ImFontBuildSrcDataEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildDstDataEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI18ImFontBuildSrcDataE6resizeEi:
 2110|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE6resizeEi:
 2110|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI18ImFontBuildDstDataE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZNK8ImVectorI18ImFontBuildSrcDataE13size_in_bytesEv:
 2093|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZNK8ImVectorI18ImFontBuildDstDataE13size_in_bytesEv:
 2093|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI18ImFontBuildSrcDataEixEi:
 2096|      7|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      7|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI12ImFontConfigEixEi:
 2096|      4|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      4|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataEixEi:
 2096|      3|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      3|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZNK8ImVectorIjE5emptyEv:
 2091|      1|    inline bool         empty() const                       { return Size == 0; }
_ZNK8ImVectorIjE5beginEv:
 2100|      1|    inline const T*     begin() const                       { return Data; }
_ZNK8ImVectorIjE3endEv:
 2102|      1|    inline const T*     end() const                         { return Data + Size; }
_ZN8ImVectorI18ImFontBuildDstDataE5clearEv:
 2087|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI16stbtt_packedcharE6resizeEi:
 2110|      1|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI16stbtt_packedcharE13size_in_bytesEv:
 2093|      1|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI16stbtt_packedcharEixEi:
 2096|      1|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI10stbrp_rectE5clearEv:
 2087|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE14clear_destructEv:
 2089|      2|    inline void         clear_destruct()                    { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.
  ------------------
  |  Branch (2089:79): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataE5clearEv:
 2087|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI16stbtt_packedcharED2Ev:
 2085|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2085:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI18ImFontBuildDstDataED2Ev:
 2085|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2085:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI18ImFontBuildSrcDataED2Ev:
 2085|      1|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2085:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI9ImDrawCmdE6resizeEi:
 2110|   170k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 170k]
  ------------------
_ZN8ImVectorI10ImDrawVertE6resizeEi:
 2110|  1.01M|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 24, False: 1.01M]
  ------------------
_ZNK8ImVectorI10ImDrawVertE14_grow_capacityEi:
 2109|     24|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 21, False: 3]
  |  Branch (2109:131): [True: 15, False: 9]
  ------------------
_ZN8ImVectorI6ImVec4E6resizeEi:
 2110|   170k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 170k]
  ------------------
_ZN8ImVectorI6ImVec4E7reserveEi:
 2113|      4|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 4]
  |  Branch (2113:167): [True: 0, False: 4]
  ------------------
_ZNK8ImVectorI6ImVec4E14_grow_capacityEi:
 2109|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 4]
  |  Branch (2109:131): [True: 4, False: 0]
  ------------------
_ZN8ImVectorIPvE6resizeEi:
 2110|   170k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 0, False: 170k]
  ------------------
_ZN8ImVectorIPvE7reserveEi:
 2113|      4|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      4|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 4]
  |  Branch (2113:167): [True: 0, False: 4]
  ------------------
_ZNK8ImVectorIPvE14_grow_capacityEi:
 2109|      4|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 4]
  |  Branch (2109:131): [True: 4, False: 0]
  ------------------
_ZN8ImVectorI6ImVec2E6resizeEi:
 2110|   245k|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 3, False: 245k]
  ------------------
_ZN8ImVectorI9ImDrawCmdE5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI10ImDrawVertE5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorIPvE5clearEv:
 2087|      2|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      2|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI6ImVec4E9push_backERKS0_:
 2117|   340k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 4, False: 340k]
  ------------------
_ZN8ImVectorI6ImVec4E8pop_backEv:
 2118|   170k|    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorIPvE9push_backERKS0_:
 2117|   170k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 4, False: 170k]
  ------------------
_ZN8ImVectorI6ImVec2E15reserve_discardEi:
 2114|   381k|    inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
                  inline void         reserve_discard(int new_capacity)   { if (new_capacity <= Capacity) return; if (Data) IM_FREE(Data); Data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }
  ------------------
  |  | 2051|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
  |  Branch (2114:67): [True: 381k, False: 2]
  |  Branch (2114:105): [True: 1, False: 1]
  ------------------
_ZN8ImVectorIP10ImDrawListE9push_backERKS1_:
 2117|  92.8k|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 92.8k]
  ------------------
_ZNK8ImVectorItE5emptyEv:
 2091|  6.37k|    inline bool         empty() const                       { return Size == 0; }
_ZN8ImVectorI21ImFontAtlasCustomRectEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigEC2Ev:
 2082|      1|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI12ImFontConfigE5beginEv:
 2099|      2|    inline T*           begin()                             { return Data; }
_ZN8ImVectorI12ImFontConfigE3endEv:
 2101|      2|    inline T*           end()                               { return Data + Size; }
_ZN8ImVectorI12ImFontConfigE9push_backERKS0_:
 2117|      1|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI12ImFontConfigE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI12ImFontConfigE4backEv:
 2105|      1|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE9push_backERKS0_:
 2117|      2|    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
  ------------------
  |  Branch (2117:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI21ImFontAtlasCustomRectE7reserveEi:
 2113|      1|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 1]
  |  Branch (2113:167): [True: 0, False: 1]
  ------------------
_ZNK8ImVectorI21ImFontAtlasCustomRectE14_grow_capacityEi:
 2109|      1|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 1]
  |  Branch (2109:131): [True: 1, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI10stbrp_rectED2Ev:
 2085|      2|    inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2085:67): [True: 1, False: 1]
  ------------------
_ZN8ImVectorI10stbrp_rectE6resizeEi:
 2110|      2|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 2, False: 0]
  ------------------
_ZN8ImVectorI10stbrp_rectE7reserveEi:
 2113|      2|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|      2|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 2]
  |  Branch (2113:167): [True: 0, False: 2]
  ------------------
_ZNK8ImVectorI10stbrp_rectE14_grow_capacityEi:
 2109|      2|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 0, False: 2]
  |  Branch (2109:131): [True: 1, False: 1]
  ------------------
_ZNK8ImVectorI10stbrp_rectE13size_in_bytesEv:
 2093|      2|    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }
_ZN8ImVectorI10stbrp_rectEixEi:
 2096|     20|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|     20|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphEC2Ev:
 2082|      2|    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }
_ZN8ImVectorI11ImFontGlyphE5clearEv:
 2087|      1|    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2087:67): [True: 0, False: 1]
  ------------------
_ZN8ImVectorI11ImFontGlyphEixEi:
 2096|    669|    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }
  ------------------
  |  |   23|    669|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE4backEv:
 2105|    225|    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }
  ------------------
  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN8ImVectorI11ImFontGlyphE6resizeEi:
 2110|    224|    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
  ------------------
  |  Branch (2110:67): [True: 10, False: 214]
  ------------------
_ZN8ImVectorI11ImFontGlyphE7reserveEi:
 2113|     10|    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2051|     10|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
                  inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }
  ------------------
  |  | 2052|      9|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
  |  Branch (2113:67): [True: 0, False: 10]
  |  Branch (2113:167): [True: 9, False: 1]
  ------------------
_ZNK8ImVectorI11ImFontGlyphE14_grow_capacityEi:
 2109|     10|    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
  ------------------
  |  Branch (2109:82): [True: 9, False: 1]
  |  Branch (2109:131): [True: 10, False: 0]
  ------------------
_ZN8ImVectorIfE6resizeEiRKf:
 2111|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (2111:67): [True: 1, False: 0]
  |  Branch (2111:127): [True: 1, False: 0]
  |  Branch (2111:163): [True: 256, False: 1]
  ------------------
_ZN8ImVectorItE6resizeEiRKt:
 2111|    257|    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
  ------------------
  |  Branch (2111:67): [True: 1, False: 0]
  |  Branch (2111:127): [True: 1, False: 0]
  |  Branch (2111:163): [True: 256, False: 1]
  ------------------
imgui_widgets.cpp:_ZplRK6ImVec2S1_:
 2715|   170k|static inline ImVec2  operator+(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
imgui_widgets.cpp:_ZmiRK6ImVec2S1_:
 2716|      3|static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

_ZN5ImGui15StyleColorsDarkEP10ImGuiStyle:
  177|      1|{
  178|      1|    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
  ------------------
  |  Branch (178:25): [True: 1, False: 0]
  ------------------
  179|      1|    ImVec4* colors = style->Colors;
  180|       |
  181|      1|    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
  182|      1|    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
  183|      1|    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
  184|      1|    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  185|      1|    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
  186|      1|    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
  187|      1|    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  188|      1|    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
  189|      1|    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  190|      1|    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  191|      1|    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
  192|      1|    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
  193|      1|    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
  194|      1|    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
  195|      1|    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
  196|      1|    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
  197|      1|    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
  198|      1|    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
  199|      1|    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  200|      1|    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
  201|      1|    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  202|      1|    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
  203|      1|    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  204|      1|    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
  205|      1|    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
  206|      1|    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
  207|      1|    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  208|      1|    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
  209|      1|    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
  210|      1|    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
  211|      1|    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
  212|      1|    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
  213|      1|    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
  214|      1|    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
  215|      1|    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
  216|      1|    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
  217|      1|    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];
  218|      1|    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
  219|      1|    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);
  220|      1|    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
  221|      1|    colors[ImGuiCol_DockingPreview]         = colors[ImGuiCol_HeaderActive] * ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
  222|      1|    colors[ImGuiCol_DockingEmptyBg]         = ImVec4(0.20f, 0.20f, 0.20f, 1.00f);
  223|      1|    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
  224|      1|    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
  225|      1|    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
  226|      1|    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
  227|      1|    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
  228|      1|    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
  229|      1|    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
  230|      1|    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
  231|      1|    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
  232|      1|    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
  233|      1|    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
  234|      1|    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
  235|      1|    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
  236|      1|    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
  237|      1|    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
  238|      1|}
_ZN20ImDrawListSharedDataC2Ev:
  374|      1|{
  375|      1|    memset(this, 0, sizeof(*this));
  376|     49|    for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
  ------------------
  |  |   93|     49|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (376:21): [True: 48, False: 1]
  ------------------
  377|     48|    {
  378|     48|        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |  275|     48|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
  ------------------
  |  |   93|     48|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  379|     48|        ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  454|     48|#define ImCos(X)            cosf(X)
  ------------------
                      ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
  ------------------
  |  |  455|     48|#define ImSin(X)            sinf(X)
  ------------------
  380|     48|    }
  381|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  774|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  454|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  382|      1|}
_ZN20ImDrawListSharedData29SetCircleTessellationMaxErrorEf:
  385|  76.6k|{
  386|  76.6k|    if (CircleSegmentMaxError == max_error)
  ------------------
  |  Branch (386:9): [True: 76.6k, False: 1]
  ------------------
  387|  76.6k|        return;
  388|       |
  389|      1|    IM_ASSERT(max_error > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  390|      1|    CircleSegmentMaxError = max_error;
  391|     65|    for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
  ------------------
  |  |   93|     65|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (391:21): [True: 64, False: 1]
  ------------------
  392|     64|    {
  393|     64|        const float radius = (float)i;
  394|     64|        CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  771|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  768|     63|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  769|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  770|     63|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
                      CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
  ------------------
  |  |  781|      1|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      1|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (394:41): [True: 63, False: 1]
  ------------------
  395|     64|    }
  396|      1|    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
  ------------------
  |  |  774|      1|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
  |  |  ------------------
  |  |  |  |  454|      1|#define ImCos(X)            cosf(X)
  |  |  ------------------
  ------------------
  397|      1|}
_ZN10ImDrawList17_ResetForNewFrameEv:
  402|   170k|{
  403|       |    // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
  404|   170k|    IM_STATIC_ASSERT(offsetof(ImDrawCmd, ClipRect) == 0);
  ------------------
  |  |  257|   170k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  405|   170k|    IM_STATIC_ASSERT(offsetof(ImDrawCmd, TextureId) == sizeof(ImVec4));
  ------------------
  |  |  257|   170k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  406|   170k|    IM_STATIC_ASSERT(offsetof(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
  ------------------
  |  |  257|   170k|#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
  ------------------
  407|   170k|    if (_Splitter._Count > 1)
  ------------------
  |  Branch (407:9): [True: 0, False: 170k]
  ------------------
  408|      0|        _Splitter.Merge(this);
  409|       |
  410|   170k|    CmdBuffer.resize(0);
  411|   170k|    IdxBuffer.resize(0);
  412|   170k|    VtxBuffer.resize(0);
  413|   170k|    Flags = _Data->InitialFlags;
  414|   170k|    memset(&_CmdHeader, 0, sizeof(_CmdHeader));
  415|   170k|    _VtxCurrentIdx = 0;
  416|   170k|    _VtxWritePtr = NULL;
  417|   170k|    _IdxWritePtr = NULL;
  418|   170k|    _ClipRectStack.resize(0);
  419|   170k|    _TextureIdStack.resize(0);
  420|   170k|    _Path.resize(0);
  421|   170k|    _Splitter.Clear();
  422|   170k|    CmdBuffer.push_back(ImDrawCmd());
  423|   170k|    _FringeScale = 1.0f;
  424|   170k|}
_ZN10ImDrawList16_ClearFreeMemoryEv:
  427|      2|{
  428|      2|    CmdBuffer.clear();
  429|      2|    IdxBuffer.clear();
  430|      2|    VtxBuffer.clear();
  431|      2|    Flags = ImDrawListFlags_None;
  432|      2|    _VtxCurrentIdx = 0;
  433|      2|    _VtxWritePtr = NULL;
  434|      2|    _IdxWritePtr = NULL;
  435|      2|    _ClipRectStack.clear();
  436|      2|    _TextureIdStack.clear();
  437|      2|    _Path.clear();
  438|      2|    _Splitter.ClearFreeMemory();
  439|      2|}
_ZN10ImDrawList10AddDrawCmdEv:
  452|   186k|{
  453|   186k|    ImDrawCmd draw_cmd;
  454|   186k|    draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
  455|   186k|    draw_cmd.TextureId = _CmdHeader.TextureId;
  456|   186k|    draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
  457|   186k|    draw_cmd.IdxOffset = IdxBuffer.Size;
  458|       |
  459|   186k|    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
  ------------------
  |  |   23|   186k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  460|   186k|    CmdBuffer.push_back(draw_cmd);
  461|   186k|}
_ZN10ImDrawList17_PopUnusedDrawCmdEv:
  466|  92.8k|{
  467|   126k|    while (CmdBuffer.Size > 0)
  ------------------
  |  Branch (467:12): [True: 126k, False: 0]
  ------------------
  468|   126k|    {
  469|   126k|        ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  470|   126k|        if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
  ------------------
  |  Branch (470:13): [True: 92.8k, False: 33.1k]
  |  Branch (470:41): [True: 0, False: 33.1k]
  ------------------
  471|  92.8k|            return;// break;
  472|  33.1k|        CmdBuffer.pop_back();
  473|  33.1k|    }
  474|  92.8k|}
_ZN10ImDrawList18_OnChangedClipRectEv:
  514|   511k|{
  515|       |    // If current command is used with different settings we need to add a new command
  516|   511k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  263|   511k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   511k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  517|   511k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  518|   511k|    if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
  ------------------
  |  Branch (518:9): [True: 186k, False: 324k]
  |  Branch (518:37): [True: 186k, False: 0]
  ------------------
  519|   186k|    {
  520|   186k|        AddDrawCmd();
  521|   186k|        return;
  522|   186k|    }
  523|   324k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|   324k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  524|       |
  525|       |    // Try to merge with previous command if it matches, else use current command
  526|   324k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  527|   324k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  494|   136k|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  493|   136k|#define ImDrawCmd_HeaderSize                            (offsetof(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  496|   460k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (496:57): [True: 136k, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (527:9): [True: 324k, False: 0]
  |  Branch (527:37): [True: 136k, False: 188k]
  |  Branch (527:59): [True: 136k, False: 5]
  |  Branch (527:170): [True: 136k, False: 0]
  ------------------
  528|   136k|    {
  529|   136k|        CmdBuffer.pop_back();
  530|   136k|        return;
  531|   136k|    }
  532|       |
  533|   188k|    curr_cmd->ClipRect = _CmdHeader.ClipRect;
  534|   188k|}
_ZN10ImDrawList19_OnChangedTextureIDEv:
  537|   170k|{
  538|       |    // If current command is used with different settings we need to add a new command
  539|   170k|    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
  ------------------
  |  |  263|   170k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  540|   170k|    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  541|   170k|    if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
  ------------------
  |  Branch (541:9): [True: 0, False: 170k]
  |  Branch (541:37): [True: 0, False: 0]
  ------------------
  542|      0|    {
  543|      0|        AddDrawCmd();
  544|      0|        return;
  545|      0|    }
  546|   170k|    IM_ASSERT(curr_cmd->UserCallback == NULL);
  ------------------
  |  |   23|   170k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  547|       |
  548|       |    // Try to merge with previous command if it matches, else use current command
  549|   170k|    ImDrawCmd* prev_cmd = curr_cmd - 1;
  550|   170k|    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  494|      0|#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
  |  |  ------------------
  |  |  |  |  493|      0|#define ImDrawCmd_HeaderSize                            (offsetof(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
  |  |  ------------------
  ------------------
                  if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
  ------------------
  |  |  496|   170k|#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)
  |  |  ------------------
  |  |  |  Branch (496:57): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (550:9): [True: 170k, False: 0]
  |  Branch (550:37): [True: 0, False: 170k]
  |  Branch (550:59): [True: 0, False: 0]
  |  Branch (550:170): [True: 0, False: 0]
  ------------------
  551|      0|    {
  552|      0|        CmdBuffer.pop_back();
  553|      0|        return;
  554|      0|    }
  555|       |
  556|   170k|    curr_cmd->TextureId = _CmdHeader.TextureId;
  557|   170k|}
_ZNK10ImDrawList27_CalcCircleAutoSegmentCountEf:
  576|  74.9k|{
  577|       |    // Automatic segment count
  578|  74.9k|    const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy
  579|  74.9k|    if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
  ------------------
  |  |   93|  74.9k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (579:9): [True: 74.9k, False: 0]
  |  Branch (579:28): [True: 74.9k, False: 0]
  ------------------
  580|  74.9k|        return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
  581|      0|    else
  582|      0|        return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
  ------------------
  |  |  771|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  768|      0|#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  769|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
  |  |  ------------------
  |  |               #define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
  |  |  ------------------
  |  |  |  |  770|      0|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  |  |  ------------------
  ------------------
  583|  74.9k|}
_ZN10ImDrawList12PushClipRectERK6ImVec2S2_b:
  587|   340k|{
  588|   340k|    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
  589|   340k|    if (intersect_with_current_clip_rect)
  ------------------
  |  Branch (589:9): [True: 170k, False: 170k]
  ------------------
  590|   170k|    {
  591|   170k|        ImVec4 current = _CmdHeader.ClipRect;
  592|   170k|        if (cr.x < current.x) cr.x = current.x;
  ------------------
  |  Branch (592:13): [True: 0, False: 170k]
  ------------------
  593|   170k|        if (cr.y < current.y) cr.y = current.y;
  ------------------
  |  Branch (593:13): [True: 0, False: 170k]
  ------------------
  594|   170k|        if (cr.z > current.z) cr.z = current.z;
  ------------------
  |  Branch (594:13): [True: 0, False: 170k]
  ------------------
  595|   170k|        if (cr.w > current.w) cr.w = current.w;
  ------------------
  |  Branch (595:13): [True: 0, False: 170k]
  ------------------
  596|   170k|    }
  597|   340k|    cr.z = ImMax(cr.x, cr.z);
  598|   340k|    cr.w = ImMax(cr.y, cr.w);
  599|       |
  600|   340k|    _ClipRectStack.push_back(cr);
  601|   340k|    _CmdHeader.ClipRect = cr;
  602|   340k|    _OnChangedClipRect();
  603|   340k|}
_ZN10ImDrawList11PopClipRectEv:
  611|   170k|{
  612|   170k|    _ClipRectStack.pop_back();
  613|   170k|    _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
  ------------------
  |  Branch (613:27): [True: 0, False: 170k]
  ------------------
  614|   170k|    _OnChangedClipRect();
  615|   170k|}
_ZN10ImDrawList13PushTextureIDEPv:
  618|   170k|{
  619|   170k|    _TextureIdStack.push_back(texture_id);
  620|   170k|    _CmdHeader.TextureId = texture_id;
  621|   170k|    _OnChangedTextureID();
  622|   170k|}
_ZN10ImDrawList11PrimReserveEii:
  635|   847k|{
  636|       |    // Large mesh support (when enabled)
  637|   847k|    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
  ------------------
  |  |  263|   847k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   847k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  638|   847k|    if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (638:9): [Folded - Ignored]
  |  Branch (638:35): [True: 0, False: 847k]
  |  Branch (638:80): [True: 0, False: 0]
  ------------------
  639|      0|    {
  640|       |        // FIXME: In theory we should be testing that vtx_count <64k here.
  641|       |        // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
  642|       |        // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
  643|      0|        _CmdHeader.VtxOffset = VtxBuffer.Size;
  644|      0|        _OnChangedVtxOffset();
  645|      0|    }
  646|       |
  647|   847k|    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
  648|   847k|    draw_cmd->ElemCount += idx_count;
  649|       |
  650|   847k|    int vtx_buffer_old_size = VtxBuffer.Size;
  651|   847k|    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
  652|   847k|    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;
  653|       |
  654|   847k|    int idx_buffer_old_size = IdxBuffer.Size;
  655|   847k|    IdxBuffer.resize(idx_buffer_old_size + idx_count);
  656|   847k|    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
  657|   847k|}
_ZN10ImDrawList8PrimRectERK6ImVec2S2_j:
  672|   294k|{
  673|   294k|    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
  674|   294k|    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
  675|   294k|    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
  676|   294k|    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
  677|   294k|    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
  678|   294k|    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
  679|   294k|    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
  680|   294k|    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
  681|   294k|    _VtxWritePtr += 4;
  682|   294k|    _VtxCurrentIdx += 4;
  683|   294k|    _IdxWritePtr += 6;
  684|   294k|}
_ZN10ImDrawList11AddPolylineEPK6ImVec2ijif:
  725|   199k|{
  726|   199k|    if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|   199k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (726:9): [True: 0, False: 199k]
  |  Branch (726:29): [True: 0, False: 199k]
  ------------------
  727|      0|        return;
  728|       |
  729|   199k|    const bool closed = (flags & ImDrawFlags_Closed) != 0;
  730|   199k|    const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
  731|   199k|    const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
  ------------------
  |  Branch (731:23): [True: 187k, False: 12.6k]
  ------------------
  732|   199k|    const bool thick_line = (thickness > _FringeScale);
  733|       |
  734|   199k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (734:9): [True: 199k, False: 0]
  ------------------
  735|   199k|    {
  736|       |        // Anti-aliased stroke
  737|   199k|        const float AA_SIZE = _FringeScale;
  738|   199k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2750|   199k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  739|       |
  740|       |        // Thicknesses <1.0 should behave like thickness 1.0
  741|   199k|        thickness = ImMax(thickness, 1.0f);
  742|   199k|        const int integer_thickness = (int)thickness;
  743|   199k|        const float fractional_thickness = thickness - integer_thickness;
  744|       |
  745|       |        // Do we want to draw this line using a texture?
  746|       |        // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
  747|       |        // - If AA_SIZE is not 1.0f we cannot use the texture path.
  748|   199k|        const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);
  ------------------
  |  | 2786|   199k|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (748:34): [True: 199k, False: 0]
  |  Branch (748:86): [True: 199k, False: 0]
  |  Branch (748:143): [True: 199k, False: 0]
  |  Branch (748:181): [True: 199k, False: 0]
  ------------------
  749|       |
  750|       |        // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
  751|   199k|        IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
  ------------------
  |  |  263|   199k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|   199k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
  752|       |
  753|   199k|        const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
  ------------------
  |  Branch (753:31): [True: 199k, False: 0]
  |  Branch (753:60): [True: 0, False: 0]
  ------------------
  754|   199k|        const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
  ------------------
  |  Branch (754:31): [True: 199k, False: 0]
  |  Branch (754:67): [True: 0, False: 0]
  ------------------
  755|   199k|        PrimReserve(idx_count, vtx_count);
  756|       |
  757|       |        // Temporary buffer
  758|       |        // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
  759|   199k|        _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
  ------------------
  |  Branch (759:60): [True: 199k, False: 0]
  |  Branch (759:75): [True: 0, False: 0]
  ------------------
  760|   199k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
  761|   199k|        ImVec2* temp_points = temp_normals + points_count;
  762|       |
  763|       |        // Calculate normals (tangents) for each line segment
  764|  1.01M|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (764:26): [True: 815k, False: 199k]
  ------------------
  765|   815k|        {
  766|   815k|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (766:28): [True: 187k, False: 628k]
  ------------------
  767|   815k|            float dx = points[i2].x - points[i1].x;
  768|   815k|            float dy = points[i2].y - points[i1].y;
  769|   815k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  718|   815k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (718:77): [True: 815k, False: 16]
  |  |  ------------------
  ------------------
  770|   815k|            temp_normals[i1].x = dy;
  771|   815k|            temp_normals[i1].y = -dx;
  772|   815k|        }
  773|   199k|        if (!closed)
  ------------------
  |  Branch (773:13): [True: 12.6k, False: 187k]
  ------------------
  774|  12.6k|            temp_normals[points_count - 1] = temp_normals[points_count - 2];
  775|       |
  776|       |        // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
  777|   199k|        if (use_texture || !thick_line)
  ------------------
  |  Branch (777:13): [True: 199k, False: 0]
  |  Branch (777:28): [True: 0, False: 0]
  ------------------
  778|   199k|        {
  779|       |            // [PATH 1] Texture-based lines (thick or non-thick)
  780|       |            // [PATH 2] Non texture-based lines (non-thick)
  781|       |
  782|       |            // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
  783|       |            // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
  784|       |            //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
  785|       |            // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
  786|       |            //   allow scaling geometry while preserving one-screen-pixel AA fringe).
  787|   199k|            const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;
  ------------------
  |  Branch (787:42): [True: 199k, False: 0]
  ------------------
  788|       |
  789|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  790|   199k|            if (!closed)
  ------------------
  |  Branch (790:17): [True: 12.6k, False: 187k]
  ------------------
  791|  12.6k|            {
  792|  12.6k|                temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
  793|  12.6k|                temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
  794|  12.6k|                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
  795|  12.6k|                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
  796|  12.6k|            }
  797|       |
  798|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  799|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  800|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  801|   199k|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  802|  1.01M|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (802:30): [True: 815k, False: 199k]
  ------------------
  803|   815k|            {
  804|   815k|                const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
  ------------------
  |  Branch (804:32): [True: 187k, False: 628k]
  ------------------
  805|   815k|                const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment
  ------------------
  |  Branch (805:43): [True: 187k, False: 628k]
  |  Branch (805:98): [True: 628k, False: 0]
  ------------------
  806|       |
  807|       |                // Average normals
  808|   815k|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  809|   815k|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  810|   815k|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  720|   815k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  719|   815k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  719|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (720:77): [True: 815k, False: 0]
  |  |  |  Branch (720:127): [True: 0, False: 815k]
  |  |  ------------------
  ------------------
  811|   815k|                dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
  812|   815k|                dm_y *= half_draw_size;
  813|       |
  814|       |                // Add temporary vertexes for the outer edges
  815|   815k|                ImVec2* out_vtx = &temp_points[i2 * 2];
  816|   815k|                out_vtx[0].x = points[i2].x + dm_x;
  817|   815k|                out_vtx[0].y = points[i2].y + dm_y;
  818|   815k|                out_vtx[1].x = points[i2].x - dm_x;
  819|   815k|                out_vtx[1].y = points[i2].y - dm_y;
  820|       |
  821|   815k|                if (use_texture)
  ------------------
  |  Branch (821:21): [True: 815k, False: 0]
  ------------------
  822|   815k|                {
  823|       |                    // Add indices for two triangles
  824|   815k|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
  825|   815k|                    _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
  826|   815k|                    _IdxWritePtr += 6;
  827|   815k|                }
  828|      0|                else
  829|      0|                {
  830|       |                    // Add indexes for four triangles
  831|      0|                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
  832|      0|                    _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
  833|      0|                    _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
  834|      0|                    _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
  835|      0|                    _IdxWritePtr += 12;
  836|      0|                }
  837|       |
  838|   815k|                idx1 = idx2;
  839|   815k|            }
  840|       |
  841|       |            // Add vertexes for each point on the line
  842|   199k|            if (use_texture)
  ------------------
  |  Branch (842:17): [True: 199k, False: 0]
  ------------------
  843|   199k|            {
  844|       |                // If we're using textures we only need to emit the left/right edge vertices
  845|   199k|                ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
  846|       |                /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
  847|       |                {
  848|       |                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
  849|       |                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
  850|       |                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
  851|       |                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
  852|       |                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
  853|       |                }*/
  854|   199k|                ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
  855|   199k|                ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
  856|  1.02M|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (856:33): [True: 828k, False: 199k]
  ------------------
  857|   828k|                {
  858|   828k|                    _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
  859|   828k|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
  860|   828k|                    _VtxWritePtr += 2;
  861|   828k|                }
  862|   199k|            }
  863|      0|            else
  864|      0|            {
  865|       |                // If we're not using a texture, we need the center vertex as well
  866|      0|                for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (866:33): [True: 0, False: 0]
  ------------------
  867|      0|                {
  868|      0|                    _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
  869|      0|                    _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge
  870|      0|                    _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge
  871|      0|                    _VtxWritePtr += 3;
  872|      0|                }
  873|      0|            }
  874|   199k|        }
  875|      0|        else
  876|      0|        {
  877|       |            // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
  878|      0|            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
  879|       |
  880|       |            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
  881|      0|            if (!closed)
  ------------------
  |  Branch (881:17): [True: 0, False: 0]
  ------------------
  882|      0|            {
  883|      0|                const int points_last = points_count - 1;
  884|      0|                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
  885|      0|                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
  886|      0|                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
  887|      0|                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
  888|      0|                temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  889|      0|                temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
  890|      0|                temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
  891|      0|                temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
  892|      0|            }
  893|       |
  894|       |            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
  895|       |            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
  896|       |            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
  897|      0|            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
  898|      0|            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
  ------------------
  |  Branch (898:30): [True: 0, False: 0]
  ------------------
  899|      0|            {
  900|      0|                const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
  ------------------
  |  Branch (900:32): [True: 0, False: 0]
  ------------------
  901|      0|                const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment
  ------------------
  |  Branch (901:43): [True: 0, False: 0]
  ------------------
  902|       |
  903|       |                // Average normals
  904|      0|                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
  905|      0|                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
  906|      0|                IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  720|      0|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  719|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  719|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (720:77): [True: 0, False: 0]
  |  |  |  Branch (720:127): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  907|      0|                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
  908|      0|                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
  909|      0|                float dm_in_x = dm_x * half_inner_thickness;
  910|      0|                float dm_in_y = dm_y * half_inner_thickness;
  911|       |
  912|       |                // Add temporary vertices
  913|      0|                ImVec2* out_vtx = &temp_points[i2 * 4];
  914|      0|                out_vtx[0].x = points[i2].x + dm_out_x;
  915|      0|                out_vtx[0].y = points[i2].y + dm_out_y;
  916|      0|                out_vtx[1].x = points[i2].x + dm_in_x;
  917|      0|                out_vtx[1].y = points[i2].y + dm_in_y;
  918|      0|                out_vtx[2].x = points[i2].x - dm_in_x;
  919|      0|                out_vtx[2].y = points[i2].y - dm_in_y;
  920|      0|                out_vtx[3].x = points[i2].x - dm_out_x;
  921|      0|                out_vtx[3].y = points[i2].y - dm_out_y;
  922|       |
  923|       |                // Add indexes
  924|      0|                _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);
  925|      0|                _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);
  926|      0|                _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);
  927|      0|                _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
  928|      0|                _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
  929|      0|                _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
  930|      0|                _IdxWritePtr += 18;
  931|       |
  932|      0|                idx1 = idx2;
  933|      0|            }
  934|       |
  935|       |            // Add vertices
  936|      0|            for (int i = 0; i < points_count; i++)
  ------------------
  |  Branch (936:29): [True: 0, False: 0]
  ------------------
  937|      0|            {
  938|      0|                _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
  939|      0|                _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  940|      0|                _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  941|      0|                _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
  942|      0|                _VtxWritePtr += 4;
  943|      0|            }
  944|      0|        }
  945|   199k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
  946|   199k|    }
  947|      0|    else
  948|      0|    {
  949|       |        // [PATH 4] Non texture-based, Non anti-aliased lines
  950|      0|        const int idx_count = count * 6;
  951|      0|        const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
  952|      0|        PrimReserve(idx_count, vtx_count);
  953|       |
  954|      0|        for (int i1 = 0; i1 < count; i1++)
  ------------------
  |  Branch (954:26): [True: 0, False: 0]
  ------------------
  955|      0|        {
  956|      0|            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
  ------------------
  |  Branch (956:28): [True: 0, False: 0]
  ------------------
  957|      0|            const ImVec2& p1 = points[i1];
  958|      0|            const ImVec2& p2 = points[i2];
  959|       |
  960|      0|            float dx = p2.x - p1.x;
  961|      0|            float dy = p2.y - p1.y;
  962|      0|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  718|      0|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (718:77): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  963|      0|            dx *= (thickness * 0.5f);
  964|      0|            dy *= (thickness * 0.5f);
  965|       |
  966|      0|            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;
  967|      0|            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
  968|      0|            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
  969|      0|            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;
  970|      0|            _VtxWritePtr += 4;
  971|       |
  972|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
  973|      0|            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
  974|      0|            _IdxWritePtr += 6;
  975|      0|            _VtxCurrentIdx += 4;
  976|      0|        }
  977|      0|    }
  978|   199k|}
_ZN10ImDrawList19AddConvexPolyFilledEPK6ImVec2ij:
  983|   181k|{
  984|   181k|    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|   181k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (984:9): [True: 0, False: 181k]
  |  Branch (984:29): [True: 0, False: 181k]
  ------------------
  985|      0|        return;
  986|       |
  987|   181k|    const ImVec2 uv = _Data->TexUvWhitePixel;
  988|       |
  989|   181k|    if (Flags & ImDrawListFlags_AntiAliasedFill)
  ------------------
  |  Branch (989:9): [True: 181k, False: 0]
  ------------------
  990|   181k|    {
  991|       |        // Anti-aliased Fill
  992|   181k|        const float AA_SIZE = _FringeScale;
  993|   181k|        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
  ------------------
  |  | 2750|   181k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  994|   181k|        const int idx_count = (points_count - 2)*3 + points_count * 6;
  995|   181k|        const int vtx_count = (points_count * 2);
  996|   181k|        PrimReserve(idx_count, vtx_count);
  997|       |
  998|       |        // Add indexes for fill
  999|   181k|        unsigned int vtx_inner_idx = _VtxCurrentIdx;
 1000|   181k|        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
 1001|   409k|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (1001:25): [True: 228k, False: 181k]
  ------------------
 1002|   228k|        {
 1003|   228k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
 1004|   228k|            _IdxWritePtr += 3;
 1005|   228k|        }
 1006|       |
 1007|       |        // Compute normals
 1008|   181k|        _Data->TempBuffer.reserve_discard(points_count);
 1009|   181k|        ImVec2* temp_normals = _Data->TempBuffer.Data;
 1010|   772k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1010:49): [True: 591k, False: 181k]
  ------------------
 1011|   591k|        {
 1012|   591k|            const ImVec2& p0 = points[i0];
 1013|   591k|            const ImVec2& p1 = points[i1];
 1014|   591k|            float dx = p1.x - p0.x;
 1015|   591k|            float dy = p1.y - p0.y;
 1016|   591k|            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
  ------------------
  |  |  718|   591k|#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
  |  |  ------------------
  |  |  |  Branch (718:77): [True: 591k, False: 0]
  |  |  ------------------
  ------------------
 1017|   591k|            temp_normals[i0].x = dy;
 1018|   591k|            temp_normals[i0].y = -dx;
 1019|   591k|        }
 1020|       |
 1021|   772k|        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
  ------------------
  |  Branch (1021:49): [True: 591k, False: 181k]
  ------------------
 1022|   591k|        {
 1023|       |            // Average normals
 1024|   591k|            const ImVec2& n0 = temp_normals[i0];
 1025|   591k|            const ImVec2& n1 = temp_normals[i1];
 1026|   591k|            float dm_x = (n0.x + n1.x) * 0.5f;
 1027|   591k|            float dm_y = (n0.y + n1.y) * 0.5f;
 1028|   591k|            IM_FIXNORMAL2F(dm_x, dm_y);
  ------------------
  |  |  720|   591k|#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  719|   591k|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |               #define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0
  |  |  ------------------
  |  |  |  |  719|      0|#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
  |  |  ------------------
  |  |  |  Branch (720:77): [True: 591k, False: 0]
  |  |  |  Branch (720:127): [True: 0, False: 591k]
  |  |  ------------------
  ------------------
 1029|   591k|            dm_x *= AA_SIZE * 0.5f;
 1030|   591k|            dm_y *= AA_SIZE * 0.5f;
 1031|       |
 1032|       |            // Add vertices
 1033|   591k|            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
 1034|   591k|            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
 1035|   591k|            _VtxWritePtr += 2;
 1036|       |
 1037|       |            // Add indexes for fringes
 1038|   591k|            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
 1039|   591k|            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
 1040|   591k|            _IdxWritePtr += 6;
 1041|   591k|        }
 1042|   181k|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1043|   181k|    }
 1044|      0|    else
 1045|      0|    {
 1046|       |        // Non Anti-aliased Fill
 1047|      0|        const int idx_count = (points_count - 2)*3;
 1048|      0|        const int vtx_count = points_count;
 1049|      0|        PrimReserve(idx_count, vtx_count);
 1050|      0|        for (int i = 0; i < vtx_count; i++)
  ------------------
  |  Branch (1050:25): [True: 0, False: 0]
  ------------------
 1051|      0|        {
 1052|      0|            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
 1053|      0|            _VtxWritePtr++;
 1054|      0|        }
 1055|      0|        for (int i = 2; i < points_count; i++)
  ------------------
  |  Branch (1055:25): [True: 0, False: 0]
  ------------------
 1056|      0|        {
 1057|      0|            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
 1058|      0|            _IdxWritePtr += 3;
 1059|      0|        }
 1060|      0|        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
 1061|      0|    }
 1062|   181k|}
_ZN10ImDrawList16_PathArcToFastExERK6ImVec2fiii:
 1065|  74.9k|{
 1066|  74.9k|    if (radius < 0.5f)
  ------------------
  |  Branch (1066:9): [True: 0, False: 74.9k]
  ------------------
 1067|      0|    {
 1068|      0|        _Path.push_back(center);
 1069|      0|        return;
 1070|      0|    }
 1071|       |
 1072|       |    // Calculate arc auto segment step size
 1073|  74.9k|    if (a_step <= 0)
  ------------------
  |  Branch (1073:9): [True: 74.9k, False: 0]
  ------------------
 1074|  74.9k|        a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);
  ------------------
  |  |  781|  74.9k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|  74.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1075|       |
 1076|       |    // Make sure we never do steps larger than one quarter of the circle
 1077|  74.9k|    a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);
  ------------------
  |  |  779|  74.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  ------------------
 1078|       |
 1079|  74.9k|    const int sample_range = ImAbs(a_max_sample - a_min_sample);
 1080|  74.9k|    const int a_next_step = a_step;
 1081|       |
 1082|  74.9k|    int samples = sample_range + 1;
 1083|  74.9k|    bool extra_max_sample = false;
 1084|  74.9k|    if (a_step > 1)
  ------------------
  |  Branch (1084:9): [True: 74.9k, False: 0]
  ------------------
 1085|  74.9k|    {
 1086|  74.9k|        samples            = sample_range / a_step + 1;
 1087|  74.9k|        const int overstep = sample_range % a_step;
 1088|       |
 1089|  74.9k|        if (overstep > 0)
  ------------------
  |  Branch (1089:13): [True: 56, False: 74.8k]
  ------------------
 1090|     56|        {
 1091|     56|            extra_max_sample = true;
 1092|     56|            samples++;
 1093|       |
 1094|       |            // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
 1095|       |            // distribute first step range evenly between them by reducing first step size.
 1096|     56|            if (sample_range > 0)
  ------------------
  |  Branch (1096:17): [True: 56, False: 0]
  ------------------
 1097|     56|                a_step -= (a_step - overstep) / 2;
 1098|     56|        }
 1099|  74.9k|    }
 1100|       |
 1101|  74.9k|    _Path.resize(_Path.Size + samples);
 1102|  74.9k|    ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);
 1103|       |
 1104|  74.9k|    int sample_index = a_min_sample;
 1105|  74.9k|    if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  781|  74.9k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|  74.9k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1105:9): [True: 0, False: 74.9k]
  |  Branch (1105:29): [True: 0, False: 74.9k]
  ------------------
 1106|      0|    {
 1107|      0|        sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1108|      0|        if (sample_index < 0)
  ------------------
  |  Branch (1108:13): [True: 0, False: 0]
  ------------------
 1109|      0|            sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1110|      0|    }
 1111|       |
 1112|  74.9k|    if (a_max_sample >= a_min_sample)
  ------------------
  |  Branch (1112:9): [True: 74.9k, False: 0]
  ------------------
 1113|  74.9k|    {
 1114|   241k|        for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
  ------------------
  |  Branch (1114:36): [True: 166k, False: 74.9k]
  ------------------
 1115|   166k|        {
 1116|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1117|   166k|            if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
  ------------------
  |  |  781|   166k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|   166k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
  |  Branch (1117:17): [True: 18.8k, False: 147k]
  ------------------
 1118|  18.8k|                sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|  18.8k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|  18.8k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1119|       |
 1120|   166k|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1121|   166k|            out_ptr->x = center.x + s.x * radius;
 1122|   166k|            out_ptr->y = center.y + s.y * radius;
 1123|   166k|            out_ptr++;
 1124|   166k|        }
 1125|  74.9k|    }
 1126|      0|    else
 1127|      0|    {
 1128|      0|        for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
  ------------------
  |  Branch (1128:36): [True: 0, False: 0]
  ------------------
 1129|      0|        {
 1130|       |            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
 1131|      0|            if (sample_index < 0)
  ------------------
  |  Branch (1131:17): [True: 0, False: 0]
  ------------------
 1132|      0|                sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1133|       |
 1134|      0|            const ImVec2 s = _Data->ArcFastVtx[sample_index];
 1135|      0|            out_ptr->x = center.x + s.x * radius;
 1136|      0|            out_ptr->y = center.y + s.y * radius;
 1137|      0|            out_ptr++;
 1138|      0|        }
 1139|      0|    }
 1140|       |
 1141|  74.9k|    if (extra_max_sample)
  ------------------
  |  Branch (1141:9): [True: 56, False: 74.8k]
  ------------------
 1142|     56|    {
 1143|     56|        int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|     56|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|     56|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1144|     56|        if (normalized_max_sample < 0)
  ------------------
  |  Branch (1144:13): [True: 0, False: 56]
  ------------------
 1145|      0|            normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1146|       |
 1147|     56|        const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];
 1148|     56|        out_ptr->x = center.x + s.x * radius;
 1149|     56|        out_ptr->y = center.y + s.y * radius;
 1150|     56|        out_ptr++;
 1151|     56|    }
 1152|       |
 1153|  74.9k|    IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
  ------------------
  |  |  263|  74.9k|#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  |   23|  74.9k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  ------------------
 1154|  74.9k|}
_ZN10ImDrawList11_PathArcToNERK6ImVec2fffi:
 1157|  3.12k|{
 1158|  3.12k|    if (radius < 0.5f)
  ------------------
  |  Branch (1158:9): [True: 0, False: 3.12k]
  ------------------
 1159|      0|    {
 1160|      0|        _Path.push_back(center);
 1161|      0|        return;
 1162|      0|    }
 1163|       |
 1164|       |    // Note that we are adding a point at both a_min and a_max.
 1165|       |    // If you are trying to draw a full closed circle you don't want the overlapping points!
 1166|  3.12k|    _Path.reserve(_Path.Size + (num_segments + 1));
 1167|  15.6k|    for (int i = 0; i <= num_segments; i++)
  ------------------
  |  Branch (1167:21): [True: 12.5k, False: 3.12k]
  ------------------
 1168|  12.5k|    {
 1169|  12.5k|        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
 1170|  12.5k|        _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  454|  12.5k|#define ImCos(X)            cosf(X)
  ------------------
                      _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
  ------------------
  |  |  455|  12.5k|#define ImSin(X)            sinf(X)
  ------------------
 1171|  12.5k|    }
 1172|  3.12k|}
_ZN10ImDrawList13PathArcToFastERK6ImVec2fii:
 1176|  91.7k|{
 1177|  91.7k|    if (radius < 0.5f)
  ------------------
  |  Branch (1177:9): [True: 17.0k, False: 74.7k]
  ------------------
 1178|  17.0k|    {
 1179|  17.0k|        _Path.push_back(center);
 1180|  17.0k|        return;
 1181|  17.0k|    }
 1182|  74.7k|    _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  781|  74.7k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|  74.7k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                  _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
  ------------------
  |  |  781|  74.7k|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|  74.7k|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1183|  74.7k|}
_ZN10ImDrawList9PathArcToERK6ImVec2fffi:
 1186|  3.16k|{
 1187|  3.16k|    if (radius < 0.5f)
  ------------------
  |  Branch (1187:9): [True: 36, False: 3.12k]
  ------------------
 1188|     36|    {
 1189|     36|        _Path.push_back(center);
 1190|     36|        return;
 1191|     36|    }
 1192|       |
 1193|  3.12k|    if (num_segments > 0)
  ------------------
  |  Branch (1193:9): [True: 3.12k, False: 0]
  ------------------
 1194|  3.12k|    {
 1195|  3.12k|        _PathArcToN(center, radius, a_min, a_max, num_segments);
 1196|  3.12k|        return;
 1197|  3.12k|    }
 1198|       |
 1199|       |    // Automatic segment count
 1200|      0|    if (radius <= _Data->ArcFastRadiusCutoff)
  ------------------
  |  Branch (1200:9): [True: 0, False: 0]
  ------------------
 1201|      0|    {
 1202|      0|        const bool a_is_reverse = a_max < a_min;
 1203|       |
 1204|       |        // We are going to use precomputed values for mid samples.
 1205|       |        // Determine first and last sample in lookup table that belong to the arc.
 1206|      0|        const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
  ------------------
  |  |  275|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1207|      0|        const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
                      const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);
  ------------------
  |  |  275|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1208|       |
 1209|      0|        const int a_min_sample = a_is_reverse ? (int)ImFloor(a_min_sample_f) : (int)ImCeil(a_min_sample_f);
  ------------------
  |  |  459|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1209:34): [True: 0, False: 0]
  ------------------
 1210|      0|        const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloor(a_max_sample_f);
  ------------------
  |  |  459|      0|#define ImCeil(X)           ceilf(X)
  ------------------
  |  Branch (1210:34): [True: 0, False: 0]
  ------------------
 1211|      0|        const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);
  ------------------
  |  Branch (1211:35): [True: 0, False: 0]
  ------------------
 1212|       |
 1213|      0|        const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  275|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1214|      0|        const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  275|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
                      const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
  ------------------
  |  |  781|      0|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|      0|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1215|      0|        const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;
 1216|      0|        const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;
 1217|       |
 1218|      0|        _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));
  ------------------
  |  Branch (1218:58): [True: 0, False: 0]
  |  Branch (1218:83): [True: 0, False: 0]
  ------------------
 1219|      0|        if (a_emit_start)
  ------------------
  |  Branch (1219:13): [True: 0, False: 0]
  ------------------
 1220|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  454|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
  ------------------
  |  |  455|      0|#define ImSin(X)            sinf(X)
  ------------------
 1221|      0|        if (a_mid_samples > 0)
  ------------------
  |  Branch (1221:13): [True: 0, False: 0]
  ------------------
 1222|      0|            _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
 1223|      0|        if (a_emit_end)
  ------------------
  |  Branch (1223:13): [True: 0, False: 0]
  ------------------
 1224|      0|            _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  454|      0|#define ImCos(X)            cosf(X)
  ------------------
                          _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
  ------------------
  |  |  455|      0|#define ImSin(X)            sinf(X)
  ------------------
 1225|      0|    }
 1226|      0|    else
 1227|      0|    {
 1228|      0|        const float arc_length = ImAbs(a_max - a_min);
 1229|      0|        const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
 1230|      0|        const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  459|      0|#define ImCeil(X)           ceilf(X)
  ------------------
                      const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
  ------------------
  |  |  275|      0|#define IM_PI                           3.14159265358979323846f
  ------------------
 1231|      0|        _PathArcToN(center, radius, a_min, a_max, arc_segment_count);
 1232|      0|    }
 1233|      0|}
_ZN10ImDrawList8PathRectERK6ImVec2S2_fi:
 1375|   194k|{
 1376|   194k|    if (rounding >= 0.5f)
  ------------------
  |  Branch (1376:9): [True: 23.4k, False: 171k]
  ------------------
 1377|  23.4k|    {
 1378|  23.4k|        flags = FixRectCornerFlags(flags);
 1379|  23.4k|        rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);
  ------------------
  |  |  451|  23.4k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1379:57): [True: 23.4k, False: 0]
  |  Branch (1379:131): [True: 0, False: 0]
  ------------------
 1380|  23.4k|        rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);
  ------------------
  |  |  451|  23.4k|#define ImFabs(X)           fabsf(X)
  ------------------
  |  Branch (1380:57): [True: 23.4k, False: 0]
  |  Branch (1380:133): [True: 0, False: 0]
  ------------------
 1381|  23.4k|    }
 1382|   194k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1382:9): [True: 176k, False: 18.6k]
  |  Branch (1382:28): [True: 0, False: 18.6k]
  ------------------
 1383|   176k|    {
 1384|   176k|        PathLineTo(a);
 1385|   176k|        PathLineTo(ImVec2(b.x, a.y));
 1386|   176k|        PathLineTo(b);
 1387|   176k|        PathLineTo(ImVec2(a.x, b.y));
 1388|   176k|    }
 1389|  18.6k|    else
 1390|  18.6k|    {
 1391|  18.6k|        const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;
  ------------------
  |  Branch (1391:35): [True: 18.6k, False: 0]
  ------------------
 1392|  18.6k|        const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
  ------------------
  |  Branch (1392:35): [True: 18.6k, False: 0]
  ------------------
 1393|  18.6k|        const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
  ------------------
  |  Branch (1393:35): [True: 18.6k, False: 0]
  ------------------
 1394|  18.6k|        const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
  ------------------
  |  Branch (1394:35): [True: 18.6k, False: 0]
  ------------------
 1395|  18.6k|        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
 1396|  18.6k|        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
 1397|  18.6k|        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
 1398|  18.6k|        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
 1399|  18.6k|    }
 1400|   194k|}
_ZN10ImDrawList7AddLineERK6ImVec2S2_jf:
 1403|  12.6k|{
 1404|  12.6k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|  12.6k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1404:9): [True: 0, False: 12.6k]
  ------------------
 1405|      0|        return;
 1406|  12.6k|    PathLineTo(p1 + ImVec2(0.5f, 0.5f));
 1407|  12.6k|    PathLineTo(p2 + ImVec2(0.5f, 0.5f));
 1408|  12.6k|    PathStroke(col, 0, thickness);
 1409|  12.6k|}
_ZN10ImDrawList7AddRectERK6ImVec2S2_jfif:
 1414|   246k|{
 1415|   246k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|   246k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1415:9): [True: 59.7k, False: 187k]
  ------------------
 1416|  59.7k|        return;
 1417|   187k|    if (Flags & ImDrawListFlags_AntiAliasedLines)
  ------------------
  |  Branch (1417:9): [True: 187k, False: 0]
  ------------------
 1418|   187k|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
 1419|      0|    else
 1420|      0|        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
 1421|   187k|    PathStroke(col, ImDrawFlags_Closed, thickness);
 1422|   187k|}
_ZN10ImDrawList13AddRectFilledERK6ImVec2S2_jfi:
 1425|   302k|{
 1426|   302k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|   302k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1426:9): [True: 0, False: 302k]
  ------------------
 1427|      0|        return;
 1428|   302k|    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
  ------------------
  |  Branch (1428:9): [True: 294k, False: 7.65k]
  |  Branch (1428:28): [True: 0, False: 7.65k]
  ------------------
 1429|   294k|    {
 1430|   294k|        PrimReserve(6, 4);
 1431|   294k|        PrimRect(p_min, p_max, col);
 1432|   294k|    }
 1433|  7.65k|    else
 1434|  7.65k|    {
 1435|  7.65k|        PathRect(p_min, p_max, rounding, flags);
 1436|  7.65k|        PathFillConvex(col);
 1437|  7.65k|    }
 1438|   302k|}
_ZN10ImDrawList17AddTriangleFilledERK6ImVec2S2_S2_j:
 1492|   153k|{
 1493|   153k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|   153k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1493:9): [True: 0, False: 153k]
  ------------------
 1494|      0|        return;
 1495|       |
 1496|   153k|    PathLineTo(p1);
 1497|   153k|    PathLineTo(p2);
 1498|   153k|    PathLineTo(p3);
 1499|   153k|    PathFillConvex(col);
 1500|   153k|}
_ZN10ImDrawList15AddCircleFilledERK6ImVec2fji:
 1527|  3.35k|{
 1528|  3.35k|    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
  ------------------
  |  | 2750|  3.35k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1528:9): [True: 0, False: 3.35k]
  |  Branch (1528:41): [True: 0, False: 3.35k]
  ------------------
 1529|      0|        return;
 1530|       |
 1531|  3.35k|    if (num_segments <= 0)
  ------------------
  |  Branch (1531:9): [True: 228, False: 3.12k]
  ------------------
 1532|    228|    {
 1533|       |        // Use arc with automatic segment count
 1534|    228|        _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
  ------------------
  |  |  781|    228|#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.
  |  |  ------------------
  |  |  |  |  779|    228|#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
  |  |  ------------------
  ------------------
 1535|    228|        _Path.Size--;
 1536|    228|    }
 1537|  3.12k|    else
 1538|  3.12k|    {
 1539|       |        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
 1540|  3.12k|        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
  ------------------
  |  |  770|  3.12k|#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
  ------------------
 1541|       |
 1542|       |        // Because we are filling a closed shape we remove 1 from the count of segments/points
 1543|  3.12k|        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
  ------------------
  |  |  275|  3.12k|#define IM_PI                           3.14159265358979323846f
  ------------------
 1544|  3.12k|        PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
 1545|  3.12k|    }
 1546|       |
 1547|  3.35k|    PathFillConvex(col);
 1548|  3.35k|}
_ZN10ImDrawList7AddTextEPK6ImFontfRK6ImVec2jPKcS7_fPK6ImVec4:
 1626|   239k|{
 1627|   239k|    if ((col & IM_COL32_A_MASK) == 0)
  ------------------
  |  | 2750|   239k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
  |  Branch (1627:9): [True: 0, False: 239k]
  ------------------
 1628|      0|        return;
 1629|       |
 1630|       |    // Accept null ranges
 1631|   239k|    if (text_begin == text_end || text_begin[0] == 0)
  ------------------
  |  Branch (1631:9): [True: 0, False: 239k]
  |  Branch (1631:35): [True: 0, False: 239k]
  ------------------
 1632|      0|        return;
 1633|   239k|    if (text_end == NULL)
  ------------------
  |  Branch (1633:9): [True: 86.2k, False: 153k]
  ------------------
 1634|  86.2k|        text_end = text_begin + strlen(text_begin);
 1635|       |
 1636|       |    // Pull default font/size from the shared ImDrawListSharedData instance
 1637|   239k|    if (font == NULL)
  ------------------
  |  Branch (1637:9): [True: 239k, False: 0]
  ------------------
 1638|   239k|        font = _Data->Font;
 1639|   239k|    if (font_size == 0.0f)
  ------------------
  |  Branch (1639:9): [True: 239k, False: 0]
  ------------------
 1640|   239k|        font_size = _Data->FontSize;
 1641|       |
 1642|   239k|    IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
  ------------------
  |  |   23|   239k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1643|       |
 1644|   239k|    ImVec4 clip_rect = _CmdHeader.ClipRect;
 1645|   239k|    if (cpu_fine_clip_rect)
  ------------------
  |  Branch (1645:9): [True: 76.6k, False: 162k]
  ------------------
 1646|  76.6k|    {
 1647|  76.6k|        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
 1648|  76.6k|        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
 1649|  76.6k|        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
 1650|  76.6k|        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
 1651|  76.6k|    }
 1652|   239k|    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
 1653|   239k|}
_ZN10ImDrawList7AddTextERK6ImVec2jPKcS4_:
 1656|  86.2k|{
 1657|  86.2k|    AddText(NULL, 0.0f, pos, col, text_begin, text_end);
 1658|  86.2k|}
_ZN18ImDrawListSplitter15ClearFreeMemoryEv:
 2036|      2|{
 2037|      2|    for (int i = 0; i < _Channels.Size; i++)
  ------------------
  |  Branch (2037:21): [True: 0, False: 2]
  ------------------
 2038|      0|    {
 2039|      0|        if (i == _Current)
  ------------------
  |  Branch (2039:13): [True: 0, False: 0]
  ------------------
 2040|      0|            memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
 2041|      0|        _Channels[i]._CmdBuffer.clear();
 2042|      0|        _Channels[i]._IdxBuffer.clear();
 2043|      0|    }
 2044|      2|    _Current = 0;
 2045|      2|    _Count = 1;
 2046|      2|    _Channels.clear();
 2047|      2|}
_ZN10ImDrawData5ClearEv:
 2179|      1|{
 2180|      1|    Valid = false;
 2181|      1|    CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
 2182|      1|    CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
 2183|      1|    DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);
 2184|      1|    OwnerViewport = NULL;
 2185|      1|}
_ZN5ImGui23AddDrawListToDrawDataExEP10ImDrawDataP8ImVectorIP10ImDrawListES4_:
 2190|  93.6k|{
 2191|  93.6k|    if (draw_list->CmdBuffer.Size == 0)
  ------------------
  |  Branch (2191:9): [True: 0, False: 93.6k]
  ------------------
 2192|      0|        return;
 2193|  93.6k|    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
  ------------------
  |  Branch (2193:9): [True: 60.5k, False: 33.1k]
  |  Branch (2193:43): [True: 751, False: 59.7k]
  |  Branch (2193:85): [True: 751, False: 0]
  ------------------
 2194|    751|        return;
 2195|       |
 2196|       |    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
 2197|       |    // May trigger for you if you are using PrimXXX functions incorrectly.
 2198|  92.8k|    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  92.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2199|  92.8k|    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
  ------------------
  |  |   23|  92.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2200|  92.8k|    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
  ------------------
  |  Branch (2200:9): [True: 92.8k, False: 0]
  ------------------
 2201|  92.8k|        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
  ------------------
  |  |   23|  92.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2202|       |
 2203|       |    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
 2204|       |    // If this assert triggers because you are drawing lots of stuff manually:
 2205|       |    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
 2206|       |    //   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
 2207|       |    // - If you want large meshes with more than 64K vertices, you can either:
 2208|       |    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
 2209|       |    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
 2210|       |    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
 2211|       |    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
 2212|       |    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
 2213|       |    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
 2214|       |    //       Your own engine or render API may use different parameters or function calls to specify index sizes.
 2215|       |    //       2 and 4 bytes indices are generally supported by most graphics API.
 2216|       |    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
 2217|       |    //   the 64K limit to split your draw commands in multiple draw lists.
 2218|  92.8k|    if (sizeof(ImDrawIdx) == 2)
  ------------------
  |  Branch (2218:9): [Folded - Ignored]
  ------------------
 2219|  92.8k|        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");
  ------------------
  |  |   23|  92.8k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2220|       |
 2221|       |    // Add to output list + records state in ImDrawData
 2222|  92.8k|    out_list->push_back(draw_list);
 2223|  92.8k|    draw_data->CmdListsCount++;
 2224|  92.8k|    draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
 2225|  92.8k|    draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
 2226|  92.8k|}
_ZN12ImFontConfigC2Ev:
 2330|      1|{
 2331|      1|    memset(this, 0, sizeof(*this));
 2332|      1|    FontDataOwnedByAtlas = true;
 2333|      1|    OversampleH = 2;
 2334|      1|    OversampleV = 1;
 2335|      1|    GlyphMaxAdvanceX = FLT_MAX;
 2336|      1|    RasterizerMultiply = 1.0f;
 2337|      1|    RasterizerDensity = 1.0f;
 2338|      1|    EllipsisChar = (ImWchar)-1;
 2339|      1|}
_ZN11ImFontAtlasC2Ev:
 2396|      1|{
 2397|      1|    memset(this, 0, sizeof(*this));
 2398|      1|    TexGlyphPadding = 1;
 2399|      1|    PackIdMouseCursors = PackIdLines = -1;
 2400|      1|}
_ZN11ImFontAtlas12ClearTexDataEv:
 2432|      2|{
 2433|      2|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2434|      2|    if (TexPixelsAlpha8)
  ------------------
  |  Branch (2434:9): [True: 0, False: 2]
  ------------------
 2435|      0|        IM_FREE(TexPixelsAlpha8);
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2436|      2|    if (TexPixelsRGBA32)
  ------------------
  |  Branch (2436:9): [True: 0, False: 2]
  ------------------
 2437|      0|        IM_FREE(TexPixelsRGBA32);
  ------------------
  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2438|      2|    TexPixelsAlpha8 = NULL;
 2439|      2|    TexPixelsRGBA32 = NULL;
 2440|      2|    TexPixelsUseColors = false;
 2441|       |    // Important: we leave TexReady untouched
 2442|      2|}
_ZN11ImFontAtlas18GetTexDataAsAlpha8EPPhPiS2_S2_:
 2459|      1|{
 2460|       |    // Build atlas on demand
 2461|      1|    if (TexPixelsAlpha8 == NULL)
  ------------------
  |  Branch (2461:9): [True: 1, False: 0]
  ------------------
 2462|      1|        Build();
 2463|       |
 2464|      1|    *out_pixels = TexPixelsAlpha8;
 2465|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2465:9): [True: 0, False: 1]
  ------------------
 2466|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2466:9): [True: 0, False: 1]
  ------------------
 2467|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
  ------------------
  |  Branch (2467:9): [True: 0, False: 1]
  ------------------
 2468|      1|}
_ZN11ImFontAtlas18GetTexDataAsRGBA32EPPhPiS2_S2_:
 2471|      1|{
 2472|       |    // Convert to RGBA32 format on demand
 2473|       |    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
 2474|      1|    if (!TexPixelsRGBA32)
  ------------------
  |  Branch (2474:9): [True: 1, False: 0]
  ------------------
 2475|      1|    {
 2476|      1|        unsigned char* pixels = NULL;
 2477|      1|        GetTexDataAsAlpha8(&pixels, NULL, NULL);
 2478|      1|        if (pixels)
  ------------------
  |  Branch (2478:13): [True: 1, False: 0]
  ------------------
 2479|      1|        {
 2480|      1|            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2481|      1|            const unsigned char* src = pixels;
 2482|      1|            unsigned int* dst = TexPixelsRGBA32;
 2483|  32.7k|            for (int n = TexWidth * TexHeight; n > 0; n--)
  ------------------
  |  Branch (2483:48): [True: 32.7k, False: 1]
  ------------------
 2484|  32.7k|                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
  ------------------
  |  | 2753|  32.7k|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2749|  32.7k|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2748|  32.7k|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2747|  32.7k|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2746|  32.7k|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 2485|      1|        }
 2486|      1|    }
 2487|       |
 2488|      1|    *out_pixels = (unsigned char*)TexPixelsRGBA32;
 2489|      1|    if (out_width) *out_width = TexWidth;
  ------------------
  |  Branch (2489:9): [True: 1, False: 0]
  ------------------
 2490|      1|    if (out_height) *out_height = TexHeight;
  ------------------
  |  Branch (2490:9): [True: 1, False: 0]
  ------------------
 2491|      1|    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
  ------------------
  |  Branch (2491:9): [True: 0, False: 1]
  ------------------
 2492|      1|}
_ZN11ImFontAtlas7AddFontEPK12ImFontConfig:
 2495|      1|{
 2496|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2497|      1|    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2498|      1|    IM_ASSERT(font_cfg->SizePixels > 0.0f);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2499|       |
 2500|       |    // Create new font
 2501|      1|    if (!font_cfg->MergeMode)
  ------------------
  |  Branch (2501:9): [True: 1, False: 0]
  ------------------
 2502|      1|        Fonts.push_back(IM_NEW(ImFont));
  ------------------
  |  | 2054|      1|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
 2503|      0|    else
 2504|      1|        IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2505|       |
 2506|      1|    ConfigData.push_back(*font_cfg);
 2507|      1|    ImFontConfig& new_font_cfg = ConfigData.back();
 2508|      1|    if (new_font_cfg.DstFont == NULL)
  ------------------
  |  Branch (2508:9): [True: 1, False: 0]
  ------------------
 2509|      1|        new_font_cfg.DstFont = Fonts.back();
 2510|      1|    if (!new_font_cfg.FontDataOwnedByAtlas)
  ------------------
  |  Branch (2510:9): [True: 0, False: 1]
  ------------------
 2511|      0|    {
 2512|      0|        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
  ------------------
  |  | 2051|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2513|      0|        new_font_cfg.FontDataOwnedByAtlas = true;
 2514|      0|        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
 2515|      0|    }
 2516|       |
 2517|      1|    if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (2517:9): [True: 1, False: 0]
  ------------------
 2518|      1|        new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;
 2519|       |
 2520|      1|    ImFontAtlasUpdateConfigDataPointers(this);
 2521|       |
 2522|       |    // Invalidate texture
 2523|      1|    TexReady = false;
 2524|      1|    ClearTexData();
 2525|      1|    return new_font_cfg.DstFont;
 2526|      1|}
_ZN11ImFontAtlas14AddFontDefaultEPK12ImFontConfig:
 2546|      1|{
 2547|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2547:29): [True: 0, False: 1]
  ------------------
 2548|      1|    if (!font_cfg_template)
  ------------------
  |  Branch (2548:9): [True: 1, False: 0]
  ------------------
 2549|      1|    {
 2550|      1|        font_cfg.OversampleH = font_cfg.OversampleV = 1;
 2551|      1|        font_cfg.PixelSnapH = true;
 2552|      1|    }
 2553|      1|    if (font_cfg.SizePixels <= 0.0f)
  ------------------
  |  Branch (2553:9): [True: 1, False: 0]
  ------------------
 2554|      1|        font_cfg.SizePixels = 13.0f * 1.0f;
 2555|      1|    if (font_cfg.Name[0] == '\0')
  ------------------
  |  Branch (2555:9): [True: 1, False: 0]
  ------------------
 2556|      1|        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);
  ------------------
  |  |   93|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 2557|      1|    font_cfg.EllipsisChar = (ImWchar)0x0085;
 2558|      1|    font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units
  ------------------
  |  |  287|      1|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 2559|       |
 2560|      1|    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
 2561|      1|    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
  ------------------
  |  Branch (2561:35): [True: 0, False: 1]
  ------------------
 2562|      1|    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);
 2563|      1|    return font;
 2564|      1|}
_ZN11ImFontAtlas20AddFontFromMemoryTTFEPvifPK12ImFontConfigPKt:
 2589|      1|{
 2590|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2591|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2591:29): [True: 1, False: 0]
  ------------------
 2592|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2593|      1|    IM_ASSERT(font_data_size > 100 && "Incorrect value for font_data_size!"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2594|      1|    font_cfg.FontData = font_data;
 2595|      1|    font_cfg.FontDataSize = font_data_size;
 2596|      1|    font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
  ------------------
  |  Branch (2596:27): [True: 1, False: 0]
  ------------------
 2597|      1|    if (glyph_ranges)
  ------------------
  |  Branch (2597:9): [True: 1, False: 0]
  ------------------
 2598|      1|        font_cfg.GlyphRanges = glyph_ranges;
 2599|      1|    return AddFont(&font_cfg);
 2600|      1|}
_ZN11ImFontAtlas30AddFontFromMemoryCompressedTTFEPKvifPK12ImFontConfigPKt:
 2603|      1|{
 2604|      1|    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
 2605|      1|    unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2606|      1|    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
 2607|       |
 2608|      1|    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
  ------------------
  |  Branch (2608:29): [True: 1, False: 0]
  ------------------
 2609|      1|    IM_ASSERT(font_cfg.FontData == NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2610|      1|    font_cfg.FontDataOwnedByAtlas = true;
 2611|      1|    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
 2612|      1|}
_ZN11ImFontAtlas36AddFontFromMemoryCompressedBase85TTFEPKcfPK12ImFontConfigPKt:
 2615|      1|{
 2616|      1|    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
 2617|      1|    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2618|      1|    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
 2619|      1|    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
 2620|      1|    IM_FREE(compressed_ttf);
  ------------------
  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  ------------------
 2621|      1|    return font;
 2622|      1|}
_ZN11ImFontAtlas20AddCustomRectRegularEii:
 2625|      2|{
 2626|      2|    IM_ASSERT(width > 0 && width <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2627|      2|    IM_ASSERT(height > 0 && height <= 0xFFFF);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2628|      2|    ImFontAtlasCustomRect r;
 2629|      2|    r.Width = (unsigned short)width;
 2630|      2|    r.Height = (unsigned short)height;
 2631|      2|    CustomRects.push_back(r);
 2632|      2|    return CustomRects.Size - 1; // Return index
 2633|      2|}
_ZN11ImFontAtlas5BuildEv:
 2684|      1|{
 2685|      1|    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2686|       |
 2687|       |    // Default font is none are specified
 2688|      1|    if (ConfigData.Size == 0)
  ------------------
  |  Branch (2688:9): [True: 1, False: 0]
  ------------------
 2689|      1|        AddFontDefault();
 2690|       |
 2691|       |    // Select builder
 2692|       |    // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
 2693|       |    //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
 2694|       |    //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
 2695|       |    //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
 2696|      1|    const ImFontBuilderIO* builder_io = FontBuilderIO;
 2697|      1|    if (builder_io == NULL)
  ------------------
  |  Branch (2697:9): [True: 1, False: 0]
  ------------------
 2698|      1|    {
 2699|       |#ifdef IMGUI_ENABLE_FREETYPE
 2700|       |        builder_io = ImGuiFreeType::GetBuilderForFreeType();
 2701|       |#elif defined(IMGUI_ENABLE_STB_TRUETYPE)
 2702|       |        builder_io = ImFontAtlasGetBuilderForStbTruetype();
 2703|       |#else
 2704|       |        IM_ASSERT(0); // Invalid Build function
 2705|       |#endif
 2706|      1|    }
 2707|       |
 2708|       |    // Build
 2709|      1|    return builder_io->FontBuilder_Build(this);
 2710|      1|}
_Z35ImFontAtlasGetBuilderForStbTruetypev:
 3032|      1|{
 3033|      1|    static ImFontBuilderIO io;
 3034|      1|    io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
 3035|      1|    return &io;
 3036|      1|}
_Z35ImFontAtlasUpdateConfigDataPointersP11ImFontAtlas:
 3041|      1|{
 3042|      1|    for (ImFontConfig& font_cfg : atlas->ConfigData)
  ------------------
  |  Branch (3042:33): [True: 1, False: 1]
  ------------------
 3043|      1|    {
 3044|      1|        ImFont* font = font_cfg.DstFont;
 3045|      1|        if (!font_cfg.MergeMode)
  ------------------
  |  Branch (3045:13): [True: 1, False: 0]
  ------------------
 3046|      1|        {
 3047|      1|            font->ConfigData = &font_cfg;
 3048|      1|            font->ConfigDataCount = 0;
 3049|      1|        }
 3050|      1|        font->ConfigDataCount++;
 3051|      1|    }
 3052|      1|}
_Z25ImFontAtlasBuildSetupFontP11ImFontAtlasP6ImFontP12ImFontConfigff:
 3055|      1|{
 3056|      1|    if (!font_config->MergeMode)
  ------------------
  |  Branch (3056:9): [True: 1, False: 0]
  ------------------
 3057|      1|    {
 3058|      1|        font->ClearOutputData();
 3059|      1|        font->FontSize = font_config->SizePixels;
 3060|      1|        IM_ASSERT(font->ConfigData == font_config);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3061|      1|        font->ContainerAtlas = atlas;
 3062|      1|        font->Ascent = ascent;
 3063|      1|        font->Descent = descent;
 3064|      1|    }
 3065|      1|}
_Z31ImFontAtlasBuildPackCustomRectsP11ImFontAtlasPv:
 3068|      1|{
 3069|      1|    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
 3070|      1|    IM_ASSERT(pack_context != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3071|       |
 3072|      1|    ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
 3073|      1|    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3074|      1|#ifdef __GNUC__
 3075|      1|    if (user_rects.Size < 1) { __builtin_unreachable(); } // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)
  ------------------
  |  Branch (3075:9): [True: 0, False: 1]
  ------------------
 3076|      1|#endif
 3077|       |
 3078|      1|    ImVector<stbrp_rect> pack_rects;
 3079|      1|    pack_rects.resize(user_rects.Size);
 3080|      1|    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
 3081|      3|    for (int i = 0; i < user_rects.Size; i++)
  ------------------
  |  Branch (3081:21): [True: 2, False: 1]
  ------------------
 3082|      2|    {
 3083|      2|        pack_rects[i].w = user_rects[i].Width;
 3084|      2|        pack_rects[i].h = user_rects[i].Height;
 3085|      2|    }
 3086|      1|    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
 3087|      3|    for (int i = 0; i < pack_rects.Size; i++)
  ------------------
  |  Branch (3087:21): [True: 2, False: 1]
  ------------------
 3088|      2|        if (pack_rects[i].was_packed)
  ------------------
  |  Branch (3088:13): [True: 2, False: 0]
  ------------------
 3089|      2|        {
 3090|      2|            user_rects[i].X = (unsigned short)pack_rects[i].x;
 3091|      2|            user_rects[i].Y = (unsigned short)pack_rects[i].y;
 3092|      2|            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3093|      2|            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
 3094|      2|        }
 3095|      1|}
_Z40ImFontAtlasBuildRender8bppRectFromStringP11ImFontAtlasiiiiPKcch:
 3098|      2|{
 3099|      2|    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3100|      2|    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
  ------------------
  |  |   23|      2|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3101|      2|    unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
 3102|     56|    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
  ------------------
  |  Branch (3102:25): [True: 54, False: 2]
  ------------------
 3103|  6.64k|        for (int off_x = 0; off_x < w; off_x++)
  ------------------
  |  Branch (3103:29): [True: 6.58k, False: 54]
  ------------------
 3104|  6.58k|            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
  ------------------
  |  Branch (3104:32): [True: 1.12k, False: 5.46k]
  ------------------
 3105|      2|}
_Z20ImFontAtlasBuildInitP11ImFontAtlas:
 3210|      1|{
 3211|       |    // Round font size
 3212|       |    // - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
 3213|       |    // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
 3214|       |    // - We may support it better later and remove this rounding.
 3215|      1|    for (ImFontConfig& cfg : atlas->ConfigData)
  ------------------
  |  Branch (3215:28): [True: 1, False: 1]
  ------------------
 3216|      1|       cfg.SizePixels = ImTrunc(cfg.SizePixels);
 3217|       |
 3218|       |    // Register texture region for mouse cursors or standard white pixels
 3219|      1|    if (atlas->PackIdMouseCursors < 0)
  ------------------
  |  Branch (3219:9): [True: 1, False: 0]
  ------------------
 3220|      1|    {
 3221|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (3221:13): [True: 1, False: 0]
  ------------------
 3222|      1|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
 3223|      0|        else
 3224|      0|            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
 3225|      1|    }
 3226|       |
 3227|       |    // Register texture region for thick lines
 3228|       |    // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
 3229|      1|    if (atlas->PackIdLines < 0)
  ------------------
  |  Branch (3229:9): [True: 1, False: 0]
  ------------------
 3230|      1|    {
 3231|      1|        if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
  ------------------
  |  Branch (3231:13): [True: 1, False: 0]
  ------------------
 3232|      1|            atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2786|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
                          atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
  ------------------
  |  | 2786|      1|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
 3233|      1|    }
 3234|      1|}
_Z22ImFontAtlasBuildFinishP11ImFontAtlas:
 3238|      1|{
 3239|       |    // Render into our custom data blocks
 3240|      1|    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3241|      1|    ImFontAtlasBuildRenderDefaultTexData(atlas);
 3242|      1|    ImFontAtlasBuildRenderLinesTexData(atlas);
 3243|       |
 3244|       |    // Register custom rectangle glyphs
 3245|      3|    for (int i = 0; i < atlas->CustomRects.Size; i++)
  ------------------
  |  Branch (3245:21): [True: 2, False: 1]
  ------------------
 3246|      2|    {
 3247|      2|        const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
 3248|      2|        if (r->Font == NULL || r->GlyphID == 0)
  ------------------
  |  Branch (3248:13): [True: 2, False: 0]
  |  Branch (3248:32): [True: 0, False: 0]
  ------------------
 3249|      2|            continue;
 3250|       |
 3251|       |        // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
 3252|      0|        IM_ASSERT(r->Font->ContainerAtlas == atlas);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3253|      0|        ImVec2 uv0, uv1;
 3254|      0|        atlas->CalcCustomRectUV(r, &uv0, &uv1);
 3255|      0|        r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
 3256|      0|    }
 3257|       |
 3258|       |    // Build all fonts lookup tables
 3259|      1|    for (ImFont* font : atlas->Fonts)
  ------------------
  |  Branch (3259:23): [True: 1, False: 1]
  ------------------
 3260|      1|        if (font->DirtyLookupTables)
  ------------------
  |  Branch (3260:13): [True: 1, False: 0]
  ------------------
 3261|      1|            font->BuildLookupTable();
 3262|       |
 3263|      1|    atlas->TexReady = true;
 3264|      1|}
_ZN11ImFontAtlas21GetGlyphRangesDefaultEv:
 3268|      1|{
 3269|      1|    static const ImWchar ranges[] =
 3270|      1|    {
 3271|      1|        0x0020, 0x00FF, // Basic Latin + Latin Supplement
 3272|      1|        0,
 3273|      1|    };
 3274|      1|    return &ranges[0];
 3275|      1|}
_ZN6ImFontC2Ev:
 3574|      2|{
 3575|      2|    FontSize = 0.0f;
 3576|      2|    FallbackAdvanceX = 0.0f;
 3577|      2|    FallbackChar = (ImWchar)-1;
 3578|      2|    EllipsisChar = (ImWchar)-1;
 3579|      2|    EllipsisWidth = EllipsisCharStep = 0.0f;
 3580|      2|    EllipsisCharCount = 0;
 3581|      2|    FallbackGlyph = NULL;
 3582|      2|    ContainerAtlas = NULL;
 3583|      2|    ConfigData = NULL;
 3584|      2|    ConfigDataCount = 0;
 3585|      2|    DirtyLookupTables = false;
 3586|      2|    Scale = 1.0f;
 3587|      2|    Ascent = Descent = 0.0f;
 3588|      2|    MetricsTotalSurface = 0;
 3589|      2|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3590|      2|}
_ZN6ImFont15ClearOutputDataEv:
 3598|      1|{
 3599|      1|    FontSize = 0.0f;
 3600|      1|    FallbackAdvanceX = 0.0f;
 3601|      1|    Glyphs.clear();
 3602|      1|    IndexAdvanceX.clear();
 3603|      1|    IndexLookup.clear();
 3604|      1|    FallbackGlyph = NULL;
 3605|      1|    ContainerAtlas = NULL;
 3606|      1|    DirtyLookupTables = true;
 3607|      1|    Ascent = Descent = 0.0f;
 3608|      1|    MetricsTotalSurface = 0;
 3609|      1|}
_ZN6ImFont16BuildLookupTableEv:
 3620|      1|{
 3621|      1|    int max_codepoint = 0;
 3622|    224|    for (int i = 0; i != Glyphs.Size; i++)
  ------------------
  |  Branch (3622:21): [True: 223, False: 1]
  ------------------
 3623|    223|        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);
 3624|       |
 3625|       |    // Build lookup table
 3626|      1|    IM_ASSERT(Glyphs.Size > 0 && "Font has not loaded glyph!");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3627|      1|    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3628|      1|    IndexAdvanceX.clear();
 3629|      1|    IndexLookup.clear();
 3630|      1|    DirtyLookupTables = false;
 3631|      1|    memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));
 3632|      1|    GrowIndex(max_codepoint + 1);
 3633|    224|    for (int i = 0; i < Glyphs.Size; i++)
  ------------------
  |  Branch (3633:21): [True: 223, False: 1]
  ------------------
 3634|    223|    {
 3635|    223|        int codepoint = (int)Glyphs[i].Codepoint;
 3636|    223|        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
 3637|    223|        IndexLookup[codepoint] = (ImWchar)i;
 3638|       |
 3639|       |        // Mark 4K page as used
 3640|    223|        const int page_n = codepoint / 4096;
 3641|    223|        Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
 3642|    223|    }
 3643|       |
 3644|       |    // Create a glyph to handle TAB
 3645|       |    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
 3646|      1|    if (FindGlyph((ImWchar)' '))
  ------------------
  |  Branch (3646:9): [True: 1, False: 0]
  ------------------
 3647|      1|    {
 3648|      1|        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
  ------------------
  |  Branch (3648:13): [True: 1, False: 0]
  ------------------
 3649|      1|            Glyphs.resize(Glyphs.Size + 1);
 3650|      1|        ImFontGlyph& tab_glyph = Glyphs.back();
 3651|      1|        tab_glyph = *FindGlyph((ImWchar)' ');
 3652|      1|        tab_glyph.Codepoint = '\t';
 3653|      1|        tab_glyph.AdvanceX *= IM_TABSIZE;
  ------------------
  |  |  282|      1|#define IM_TABSIZE                      (4)
  ------------------
 3654|      1|        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
 3655|      1|        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);
 3656|      1|    }
 3657|       |
 3658|       |    // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
 3659|      1|    SetGlyphVisible((ImWchar)' ', false);
 3660|      1|    SetGlyphVisible((ImWchar)'\t', false);
 3661|       |
 3662|       |    // Setup Fallback character
 3663|      1|    const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
  ------------------
  |  | 2538|      1|#define IM_UNICODE_CODEPOINT_INVALID 0xFFFD     // Invalid Unicode code point (standard value).
  ------------------
 3664|      1|    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3665|      1|    if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3665:9): [True: 1, False: 0]
  ------------------
 3666|      1|    {
 3667|      1|        FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
  ------------------
  |  |   93|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3668|      1|        FallbackGlyph = FindGlyphNoFallback(FallbackChar);
 3669|      1|        if (FallbackGlyph == NULL)
  ------------------
  |  Branch (3669:13): [True: 0, False: 1]
  ------------------
 3670|      0|        {
 3671|      0|            FallbackGlyph = &Glyphs.back();
 3672|      0|            FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
 3673|      0|        }
 3674|      1|    }
 3675|      1|    FallbackAdvanceX = FallbackGlyph->AdvanceX;
 3676|    257|    for (int i = 0; i < max_codepoint + 1; i++)
  ------------------
  |  Branch (3676:21): [True: 256, False: 1]
  ------------------
 3677|    256|        if (IndexAdvanceX[i] < 0.0f)
  ------------------
  |  Branch (3677:13): [True: 32, False: 224]
  ------------------
 3678|     32|            IndexAdvanceX[i] = FallbackAdvanceX;
 3679|       |
 3680|       |    // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
 3681|       |    // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
 3682|       |    // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
 3683|      1|    const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };
 3684|      1|    const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
 3685|      1|    if (EllipsisChar == (ImWchar)-1)
  ------------------
  |  Branch (3685:9): [True: 0, False: 1]
  ------------------
 3686|      0|        EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
  ------------------
  |  |   93|      0|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3687|      1|    const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
  ------------------
  |  |   93|      1|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
 3688|      1|    if (EllipsisChar != (ImWchar)-1)
  ------------------
  |  Branch (3688:9): [True: 1, False: 0]
  ------------------
 3689|      1|    {
 3690|      1|        EllipsisCharCount = 1;
 3691|      1|        EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
 3692|      1|    }
 3693|      0|    else if (dot_char != (ImWchar)-1)
  ------------------
  |  Branch (3693:14): [True: 0, False: 0]
  ------------------
 3694|      0|    {
 3695|      0|        const ImFontGlyph* glyph = FindGlyph(dot_char);
 3696|      0|        EllipsisChar = dot_char;
 3697|      0|        EllipsisCharCount = 3;
 3698|      0|        EllipsisCharStep = (glyph->X1 - glyph->X0) + 1.0f;
 3699|      0|        EllipsisWidth = EllipsisCharStep * 3.0f - 1.0f;
 3700|      0|    }
 3701|      1|}
_ZN6ImFont15SetGlyphVisibleEtb:
 3717|      2|{
 3718|      2|    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))
  ------------------
  |  Branch (3718:22): [True: 2, False: 0]
  ------------------
 3719|      2|        glyph->Visible = visible ? 1 : 0;
  ------------------
  |  Branch (3719:26): [True: 0, False: 2]
  ------------------
 3720|      2|}
_ZN6ImFont9GrowIndexEi:
 3723|      1|{
 3724|      1|    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3725|      1|    if (new_size <= IndexLookup.Size)
  ------------------
  |  Branch (3725:9): [True: 0, False: 1]
  ------------------
 3726|      0|        return;
 3727|      1|    IndexAdvanceX.resize(new_size, -1.0f);
 3728|      1|    IndexLookup.resize(new_size, (ImWchar)-1);
 3729|      1|}
_ZN6ImFont8AddGlyphEPK12ImFontConfigtfffffffff:
 3735|    223|{
 3736|    223|    if (cfg != NULL)
  ------------------
  |  Branch (3736:9): [True: 223, False: 0]
  ------------------
 3737|    223|    {
 3738|       |        // Clamp & recenter if needed
 3739|    223|        const float advance_x_original = advance_x;
 3740|    223|        advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
 3741|    223|        if (advance_x != advance_x_original)
  ------------------
  |  Branch (3741:13): [True: 0, False: 223]
  ------------------
 3742|      0|        {
 3743|      0|            float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
  ------------------
  |  Branch (3743:32): [True: 0, False: 0]
  ------------------
 3744|      0|            x0 += char_off_x;
 3745|      0|            x1 += char_off_x;
 3746|      0|        }
 3747|       |
 3748|       |        // Snap to pixel
 3749|    223|        if (cfg->PixelSnapH)
  ------------------
  |  Branch (3749:13): [True: 223, False: 0]
  ------------------
 3750|    223|            advance_x = IM_ROUND(advance_x);
  ------------------
  |  |  288|    223|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 3751|       |
 3752|       |        // Bake spacing
 3753|    223|        advance_x += cfg->GlyphExtraSpacing.x;
 3754|    223|    }
 3755|       |
 3756|    223|    Glyphs.resize(Glyphs.Size + 1);
 3757|    223|    ImFontGlyph& glyph = Glyphs.back();
 3758|    223|    glyph.Codepoint = (unsigned int)codepoint;
 3759|    223|    glyph.Visible = (x0 != x1) && (y0 != y1);
  ------------------
  |  Branch (3759:21): [True: 214, False: 9]
  |  Branch (3759:35): [True: 214, False: 0]
  ------------------
 3760|    223|    glyph.Colored = false;
 3761|    223|    glyph.X0 = x0;
 3762|    223|    glyph.Y0 = y0;
 3763|    223|    glyph.X1 = x1;
 3764|    223|    glyph.Y1 = y1;
 3765|    223|    glyph.U0 = u0;
 3766|    223|    glyph.V0 = v0;
 3767|    223|    glyph.U1 = u1;
 3768|    223|    glyph.V1 = v1;
 3769|    223|    glyph.AdvanceX = advance_x;
 3770|       |
 3771|       |    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
 3772|       |    // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
 3773|    223|    float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
 3774|    223|    DirtyLookupTables = true;
 3775|    223|    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
 3776|    223|}
_ZNK6ImFont9FindGlyphEt:
 3794|  1.35M|{
 3795|  1.35M|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3795:9): [True: 12.8k, False: 1.34M]
  ------------------
 3796|  12.8k|        return FallbackGlyph;
 3797|  1.34M|    const ImWchar i = IndexLookup.Data[c];
 3798|  1.34M|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3798:9): [True: 1.08k, False: 1.34M]
  ------------------
 3799|  1.08k|        return FallbackGlyph;
 3800|  1.34M|    return &Glyphs.Data[i];
 3801|  1.34M|}
_ZNK6ImFont19FindGlyphNoFallbackEt:
 3804|      5|{
 3805|      5|    if (c >= (size_t)IndexLookup.Size)
  ------------------
  |  Branch (3805:9): [True: 2, False: 3]
  ------------------
 3806|      2|        return NULL;
 3807|      3|    const ImWchar i = IndexLookup.Data[c];
 3808|      3|    if (i == (ImWchar)-1)
  ------------------
  |  Branch (3808:9): [True: 0, False: 3]
  ------------------
 3809|      0|        return NULL;
 3810|      3|    return &Glyphs.Data[i];
 3811|      3|}
_ZNK6ImFont13CalcTextSizeAEfffPKcS1_PS1_:
 3925|  1.59M|{
 3926|  1.59M|    if (!text_end)
  ------------------
  |  Branch (3926:9): [True: 1.43M, False: 153k]
  ------------------
 3927|  1.43M|        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.
 3928|       |
 3929|  1.59M|    const float line_height = size;
 3930|  1.59M|    const float scale = size / FontSize;
 3931|       |
 3932|  1.59M|    ImVec2 text_size = ImVec2(0, 0);
 3933|  1.59M|    float line_width = 0.0f;
 3934|       |
 3935|  1.59M|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 3936|  1.59M|    const char* word_wrap_eol = NULL;
 3937|       |
 3938|  1.59M|    const char* s = text_begin;
 3939|  4.44M|    while (s < text_end)
  ------------------
  |  Branch (3939:12): [True: 2.85M, False: 1.59M]
  ------------------
 3940|  2.85M|    {
 3941|  2.85M|        if (word_wrap_enabled)
  ------------------
  |  Branch (3941:13): [True: 0, False: 2.85M]
  ------------------
 3942|      0|        {
 3943|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 3944|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (3944:17): [True: 0, False: 0]
  ------------------
 3945|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
 3946|       |
 3947|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (3947:17): [True: 0, False: 0]
  ------------------
 3948|      0|            {
 3949|      0|                if (text_size.x < line_width)
  ------------------
  |  Branch (3949:21): [True: 0, False: 0]
  ------------------
 3950|      0|                    text_size.x = line_width;
 3951|      0|                text_size.y += line_height;
 3952|      0|                line_width = 0.0f;
 3953|      0|                word_wrap_eol = NULL;
 3954|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 3955|      0|                continue;
 3956|      0|            }
 3957|      0|        }
 3958|       |
 3959|       |        // Decode and advance source
 3960|  2.85M|        const char* prev_s = s;
 3961|  2.85M|        unsigned int c = (unsigned int)*s;
 3962|  2.85M|        if (c < 0x80)
  ------------------
  |  Branch (3962:13): [True: 2.63M, False: 220k]
  ------------------
 3963|  2.63M|            s += 1;
 3964|   220k|        else
 3965|   220k|            s += ImTextCharFromUtf8(&c, s, text_end);
 3966|       |
 3967|  2.85M|        if (c < 32)
  ------------------
  |  Branch (3967:13): [True: 23.9k, False: 2.82M]
  ------------------
 3968|  23.9k|        {
 3969|  23.9k|            if (c == '\n')
  ------------------
  |  Branch (3969:17): [True: 0, False: 23.9k]
  ------------------
 3970|      0|            {
 3971|      0|                text_size.x = ImMax(text_size.x, line_width);
 3972|      0|                text_size.y += line_height;
 3973|      0|                line_width = 0.0f;
 3974|      0|                continue;
 3975|      0|            }
 3976|  23.9k|            if (c == '\r')
  ------------------
  |  Branch (3976:17): [True: 1.15k, False: 22.7k]
  ------------------
 3977|  1.15k|                continue;
 3978|  23.9k|        }
 3979|       |
 3980|  2.85M|        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;
  ------------------
  |  Branch (3980:35): [True: 2.67M, False: 171k]
  ------------------
 3981|  2.85M|        if (line_width + char_width >= max_width)
  ------------------
  |  Branch (3981:13): [True: 0, False: 2.85M]
  ------------------
 3982|      0|        {
 3983|      0|            s = prev_s;
 3984|      0|            break;
 3985|      0|        }
 3986|       |
 3987|  2.85M|        line_width += char_width;
 3988|  2.85M|    }
 3989|       |
 3990|  1.59M|    if (text_size.x < line_width)
  ------------------
  |  Branch (3990:9): [True: 1.59M, False: 1.15k]
  ------------------
 3991|  1.59M|        text_size.x = line_width;
 3992|       |
 3993|  1.59M|    if (line_width > 0 || text_size.y == 0.0f)
  ------------------
  |  Branch (3993:9): [True: 1.59M, False: 1.15k]
  |  Branch (3993:27): [True: 1.15k, False: 0]
  ------------------
 3994|  1.59M|        text_size.y += line_height;
 3995|       |
 3996|  1.59M|    if (remaining)
  ------------------
  |  Branch (3996:9): [True: 0, False: 1.59M]
  ------------------
 3997|      0|        *remaining = s;
 3998|       |
 3999|  1.59M|    return text_size;
 4000|  1.59M|}
_ZNK6ImFont10RenderTextEP10ImDrawListfRK6ImVec2jRK6ImVec4PKcS9_fb:
 4019|   239k|{
 4020|   239k|    if (!text_end)
  ------------------
  |  Branch (4020:9): [True: 0, False: 239k]
  ------------------
 4021|      0|        text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.
 4022|       |
 4023|       |    // Align to be pixel perfect
 4024|   239k|    float x = IM_TRUNC(pos.x);
  ------------------
  |  |  287|   239k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 4025|   239k|    float y = IM_TRUNC(pos.y);
  ------------------
  |  |  287|   239k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
 4026|   239k|    if (y > clip_rect.w)
  ------------------
  |  Branch (4026:9): [True: 67.9k, False: 171k]
  ------------------
 4027|  67.9k|        return;
 4028|       |
 4029|   171k|    const float start_x = x;
 4030|   171k|    const float scale = size / FontSize;
 4031|   171k|    const float line_height = FontSize * scale;
 4032|   171k|    const bool word_wrap_enabled = (wrap_width > 0.0f);
 4033|       |
 4034|       |    // Fast-forward to first visible line
 4035|   171k|    const char* s = text_begin;
 4036|   171k|    if (y + line_height < clip_rect.y)
  ------------------
  |  Branch (4036:9): [True: 0, False: 171k]
  ------------------
 4037|      0|        while (y + line_height < clip_rect.y && s < text_end)
  ------------------
  |  Branch (4037:16): [True: 0, False: 0]
  |  Branch (4037:49): [True: 0, False: 0]
  ------------------
 4038|      0|        {
 4039|      0|            const char* line_end = (const char*)memchr(s, '\n', text_end - s);
 4040|      0|            if (word_wrap_enabled)
  ------------------
  |  Branch (4040:17): [True: 0, False: 0]
  ------------------
 4041|      0|            {
 4042|       |                // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
 4043|       |                // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
 4044|       |                // However it is still better than nothing performing the fast-forward!
 4045|      0|                s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);
  ------------------
  |  Branch (4045:53): [True: 0, False: 0]
  ------------------
 4046|      0|                s = CalcWordWrapNextLineStartA(s, text_end);
 4047|      0|            }
 4048|      0|            else
 4049|      0|            {
 4050|      0|                s = line_end ? line_end + 1 : text_end;
  ------------------
  |  Branch (4050:21): [True: 0, False: 0]
  ------------------
 4051|      0|            }
 4052|      0|            y += line_height;
 4053|      0|        }
 4054|       |
 4055|       |    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
 4056|       |    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
 4057|   171k|    if (text_end - s > 10000 && !word_wrap_enabled)
  ------------------
  |  Branch (4057:9): [True: 1, False: 171k]
  |  Branch (4057:33): [True: 1, False: 0]
  ------------------
 4058|      1|    {
 4059|      1|        const char* s_end = s;
 4060|      1|        float y_end = y;
 4061|      1|        while (y_end < clip_rect.w && s_end < text_end)
  ------------------
  |  Branch (4061:16): [True: 0, False: 1]
  |  Branch (4061:39): [True: 0, False: 0]
  ------------------
 4062|      0|        {
 4063|      0|            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
 4064|      0|            s_end = s_end ? s_end + 1 : text_end;
  ------------------
  |  Branch (4064:21): [True: 0, False: 0]
  ------------------
 4065|      0|            y_end += line_height;
 4066|      0|        }
 4067|      1|        text_end = s_end;
 4068|      1|    }
 4069|   171k|    if (s == text_end)
  ------------------
  |  Branch (4069:9): [True: 1, False: 171k]
  ------------------
 4070|      1|        return;
 4071|       |
 4072|       |    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
 4073|   171k|    const int vtx_count_max = (int)(text_end - s) * 4;
 4074|   171k|    const int idx_count_max = (int)(text_end - s) * 6;
 4075|   171k|    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
 4076|   171k|    draw_list->PrimReserve(idx_count_max, vtx_count_max);
 4077|   171k|    ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;
 4078|   171k|    ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
 4079|   171k|    unsigned int vtx_index = draw_list->_VtxCurrentIdx;
 4080|       |
 4081|   171k|    const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
  ------------------
  |  | 2750|   171k|#define IM_COL32_A_MASK     0xFF000000
  ------------------
 4082|   171k|    const char* word_wrap_eol = NULL;
 4083|       |
 4084|  1.53M|    while (s < text_end)
  ------------------
  |  Branch (4084:12): [True: 1.35M, False: 171k]
  ------------------
 4085|  1.35M|    {
 4086|  1.35M|        if (word_wrap_enabled)
  ------------------
  |  Branch (4086:13): [True: 0, False: 1.35M]
  ------------------
 4087|      0|        {
 4088|       |            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
 4089|      0|            if (!word_wrap_eol)
  ------------------
  |  Branch (4089:17): [True: 0, False: 0]
  ------------------
 4090|      0|                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - start_x));
 4091|       |
 4092|      0|            if (s >= word_wrap_eol)
  ------------------
  |  Branch (4092:17): [True: 0, False: 0]
  ------------------
 4093|      0|            {
 4094|      0|                x = start_x;
 4095|      0|                y += line_height;
 4096|      0|                if (y > clip_rect.w)
  ------------------
  |  Branch (4096:21): [True: 0, False: 0]
  ------------------
 4097|      0|                    break; // break out of main loop
 4098|      0|                word_wrap_eol = NULL;
 4099|      0|                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
 4100|      0|                continue;
 4101|      0|            }
 4102|      0|        }
 4103|       |
 4104|       |        // Decode and advance source
 4105|  1.35M|        unsigned int c = (unsigned int)*s;
 4106|  1.35M|        if (c < 0x80)
  ------------------
  |  Branch (4106:13): [True: 1.33M, False: 23.4k]
  ------------------
 4107|  1.33M|            s += 1;
 4108|  23.4k|        else
 4109|  23.4k|            s += ImTextCharFromUtf8(&c, s, text_end);
 4110|       |
 4111|  1.35M|        if (c < 32)
  ------------------
  |  Branch (4111:13): [True: 1.12k, False: 1.35M]
  ------------------
 4112|  1.12k|        {
 4113|  1.12k|            if (c == '\n')
  ------------------
  |  Branch (4113:17): [True: 0, False: 1.12k]
  ------------------
 4114|      0|            {
 4115|      0|                x = start_x;
 4116|      0|                y += line_height;
 4117|      0|                if (y > clip_rect.w)
  ------------------
  |  Branch (4117:21): [True: 0, False: 0]
  ------------------
 4118|      0|                    break; // break out of main loop
 4119|      0|                continue;
 4120|      0|            }
 4121|  1.12k|            if (c == '\r')
  ------------------
  |  Branch (4121:17): [True: 146, False: 981]
  ------------------
 4122|    146|                continue;
 4123|  1.12k|        }
 4124|       |
 4125|  1.35M|        const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
 4126|  1.35M|        if (glyph == NULL)
  ------------------
  |  Branch (4126:13): [True: 0, False: 1.35M]
  ------------------
 4127|      0|            continue;
 4128|       |
 4129|  1.35M|        float char_width = glyph->AdvanceX * scale;
 4130|  1.35M|        if (glyph->Visible)
  ------------------
  |  Branch (4130:13): [True: 1.26M, False: 93.2k]
  ------------------
 4131|  1.26M|        {
 4132|       |            // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
 4133|  1.26M|            float x1 = x + glyph->X0 * scale;
 4134|  1.26M|            float x2 = x + glyph->X1 * scale;
 4135|  1.26M|            float y1 = y + glyph->Y0 * scale;
 4136|  1.26M|            float y2 = y + glyph->Y1 * scale;
 4137|  1.26M|            if (x1 <= clip_rect.z && x2 >= clip_rect.x)
  ------------------
  |  Branch (4137:17): [True: 502k, False: 763k]
  |  Branch (4137:38): [True: 460k, False: 41.5k]
  ------------------
 4138|   460k|            {
 4139|       |                // Render a character
 4140|   460k|                float u1 = glyph->U0;
 4141|   460k|                float v1 = glyph->V0;
 4142|   460k|                float u2 = glyph->U1;
 4143|   460k|                float v2 = glyph->V1;
 4144|       |
 4145|       |                // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
 4146|   460k|                if (cpu_fine_clip)
  ------------------
  |  Branch (4146:21): [True: 76.6k, False: 384k]
  ------------------
 4147|  76.6k|                {
 4148|  76.6k|                    if (x1 < clip_rect.x)
  ------------------
  |  Branch (4148:25): [True: 0, False: 76.6k]
  ------------------
 4149|      0|                    {
 4150|      0|                        u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
 4151|      0|                        x1 = clip_rect.x;
 4152|      0|                    }
 4153|  76.6k|                    if (y1 < clip_rect.y)
  ------------------
  |  Branch (4153:25): [True: 139, False: 76.5k]
  ------------------
 4154|    139|                    {
 4155|    139|                        v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
 4156|    139|                        y1 = clip_rect.y;
 4157|    139|                    }
 4158|  76.6k|                    if (x2 > clip_rect.z)
  ------------------
  |  Branch (4158:25): [True: 76.6k, False: 0]
  ------------------
 4159|  76.6k|                    {
 4160|  76.6k|                        u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
 4161|  76.6k|                        x2 = clip_rect.z;
 4162|  76.6k|                    }
 4163|  76.6k|                    if (y2 > clip_rect.w)
  ------------------
  |  Branch (4163:25): [True: 0, False: 76.6k]
  ------------------
 4164|      0|                    {
 4165|      0|                        v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
 4166|      0|                        y2 = clip_rect.w;
 4167|      0|                    }
 4168|  76.6k|                    if (y1 >= y2)
  ------------------
  |  Branch (4168:25): [True: 139, False: 76.5k]
  ------------------
 4169|    139|                    {
 4170|    139|                        x += char_width;
 4171|    139|                        continue;
 4172|    139|                    }
 4173|  76.6k|                }
 4174|       |
 4175|       |                // Support for untinted glyphs
 4176|   460k|                ImU32 glyph_col = glyph->Colored ? col_untinted : col;
  ------------------
  |  Branch (4176:35): [True: 0, False: 460k]
  ------------------
 4177|       |
 4178|       |                // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
 4179|   460k|                {
 4180|   460k|                    vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
 4181|   460k|                    vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
 4182|   460k|                    vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
 4183|   460k|                    vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
 4184|   460k|                    idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);
 4185|   460k|                    idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
 4186|   460k|                    vtx_write += 4;
 4187|   460k|                    vtx_index += 4;
 4188|   460k|                    idx_write += 6;
 4189|   460k|                }
 4190|   460k|            }
 4191|  1.26M|        }
 4192|  1.35M|        x += char_width;
 4193|  1.35M|    }
 4194|       |
 4195|       |    // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
 4196|   171k|    draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
 4197|   171k|    draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
 4198|   171k|    draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
 4199|   171k|    draw_list->_VtxWritePtr = vtx_write;
 4200|   171k|    draw_list->_IdxWritePtr = idx_write;
 4201|   171k|    draw_list->_VtxCurrentIdx = vtx_index;
 4202|   171k|}
_ZN5ImGui11RenderArrowEP10ImDrawList6ImVec2j8ImGuiDirf:
 4222|   153k|{
 4223|   153k|    const float h = draw_list->_Data->FontSize * 1.00f;
 4224|   153k|    float r = h * 0.40f * scale;
 4225|   153k|    ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);
 4226|       |
 4227|   153k|    ImVec2 a, b, c;
 4228|   153k|    switch (dir)
  ------------------
  |  Branch (4228:13): [True: 0, False: 153k]
  ------------------
 4229|   153k|    {
 4230|      0|    case ImGuiDir_Up:
  ------------------
  |  Branch (4230:5): [True: 0, False: 153k]
  ------------------
 4231|  93.6k|    case ImGuiDir_Down:
  ------------------
  |  Branch (4231:5): [True: 93.6k, False: 59.7k]
  ------------------
 4232|  93.6k|        if (dir == ImGuiDir_Up) r = -r;
  ------------------
  |  Branch (4232:13): [True: 0, False: 93.6k]
  ------------------
 4233|  93.6k|        a = ImVec2(+0.000f, +0.750f) * r;
 4234|  93.6k|        b = ImVec2(-0.866f, -0.750f) * r;
 4235|  93.6k|        c = ImVec2(+0.866f, -0.750f) * r;
 4236|  93.6k|        break;
 4237|      0|    case ImGuiDir_Left:
  ------------------
  |  Branch (4237:5): [True: 0, False: 153k]
  ------------------
 4238|  59.7k|    case ImGuiDir_Right:
  ------------------
  |  Branch (4238:5): [True: 59.7k, False: 93.6k]
  ------------------
 4239|  59.7k|        if (dir == ImGuiDir_Left) r = -r;
  ------------------
  |  Branch (4239:13): [True: 0, False: 59.7k]
  ------------------
 4240|  59.7k|        a = ImVec2(+0.750f, +0.000f) * r;
 4241|  59.7k|        b = ImVec2(-0.750f, +0.866f) * r;
 4242|  59.7k|        c = ImVec2(-0.750f, -0.866f) * r;
 4243|  59.7k|        break;
 4244|      0|    case ImGuiDir_None:
  ------------------
  |  Branch (4244:5): [True: 0, False: 153k]
  ------------------
 4245|      0|    case ImGuiDir_COUNT:
  ------------------
  |  Branch (4245:5): [True: 0, False: 153k]
  ------------------
 4246|      0|        IM_ASSERT(0);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4247|      0|        break;
 4248|   153k|    }
 4249|   153k|    draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
 4250|   153k|}
imgui_draw.cpp:_ZL18FixRectCornerFlagsi:
 1351|  23.4k|{
 1352|       |    /*
 1353|       |    IM_STATIC_ASSERT(ImDrawFlags_RoundCornersTopLeft == (1 << 4));
 1354|       |#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
 1355|       |    // Obsoleted in 1.82 (from February 2021). This code was stripped/simplified and mostly commented in 1.90 (from September 2023)
 1356|       |    // - Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
 1357|       |    if (flags == ~0)                    { return ImDrawFlags_RoundCornersAll; }
 1358|       |    // - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations). Read details in older version of this code.
 1359|       |    if (flags >= 0x01 && flags <= 0x0F) { return (flags << 4); }
 1360|       |    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
 1361|       |#endif
 1362|       |    */
 1363|       |    // If this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
 1364|       |    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway.
 1365|       |    // See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in "API BREAKING CHANGES" section.
 1366|  23.4k|    IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");
  ------------------
  |  |   23|  23.4k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 1367|       |
 1368|  23.4k|    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
  ------------------
  |  Branch (1368:9): [True: 23.4k, False: 0]
  ------------------
 1369|  23.4k|        flags |= ImDrawFlags_RoundCornersAll;
 1370|       |
 1371|  23.4k|    return flags;
 1372|  23.4k|}
imgui_draw.cpp:_ZL8Decode85PKhPh:
 2534|      1|{
 2535|  2.39k|    while (*src)
  ------------------
  |  Branch (2535:12): [True: 2.39k, False: 1]
  ------------------
 2536|  2.39k|    {
 2537|  2.39k|        unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
 2538|  2.39k|        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
 2539|  2.39k|        src += 5;
 2540|  2.39k|        dst += 4;
 2541|  2.39k|    }
 2542|      1|}
imgui_draw.cpp:_ZL12Decode85Bytec:
 2532|  11.9k|static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
  ------------------
  |  Branch (2532:86): [True: 3.28k, False: 8.70k]
  ------------------
imgui_draw.cpp:_ZL31ImFontAtlasBuildWithStbTruetypeP11ImFontAtlas:
 2769|      1|{
 2770|      1|    IM_ASSERT(atlas->ConfigData.Size > 0);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2771|       |
 2772|      1|    ImFontAtlasBuildInit(atlas);
 2773|       |
 2774|       |    // Clear atlas
 2775|      1|    atlas->TexID = (ImTextureID)NULL;
 2776|      1|    atlas->TexWidth = atlas->TexHeight = 0;
 2777|      1|    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
 2778|      1|    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
 2779|      1|    atlas->ClearTexData();
 2780|       |
 2781|       |    // Temporary storage for building
 2782|      1|    ImVector<ImFontBuildSrcData> src_tmp_array;
 2783|      1|    ImVector<ImFontBuildDstData> dst_tmp_array;
 2784|      1|    src_tmp_array.resize(atlas->ConfigData.Size);
 2785|      1|    dst_tmp_array.resize(atlas->Fonts.Size);
 2786|      1|    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
 2787|      1|    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());
 2788|       |
 2789|       |    // 1. Initialize font loading structure, check font data validity
 2790|      2|    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
  ------------------
  |  Branch (2790:25): [True: 1, False: 1]
  ------------------
 2791|      1|    {
 2792|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2793|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2794|      1|        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2795|       |
 2796|       |        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
 2797|      1|        src_tmp.DstIndex = -1;
 2798|      2|        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
  ------------------
  |  Branch (2798:32): [True: 1, False: 1]
  |  Branch (2798:64): [True: 1, False: 0]
  ------------------
 2799|      1|            if (cfg.DstFont == atlas->Fonts[output_i])
  ------------------
  |  Branch (2799:17): [True: 1, False: 0]
  ------------------
 2800|      1|                src_tmp.DstIndex = output_i;
 2801|      1|        if (src_tmp.DstIndex == -1)
  ------------------
  |  Branch (2801:13): [True: 0, False: 1]
  ------------------
 2802|      0|        {
 2803|      0|            IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2804|      0|            return false;
 2805|      0|        }
 2806|       |        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
 2807|      1|        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
 2808|      1|        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2809|      1|        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
  ------------------
  |  Branch (2809:13): [True: 0, False: 1]
  ------------------
 2810|      0|        {
 2811|      0|            IM_ASSERT(0 && "stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.");
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2812|      0|            return false;
 2813|      0|        }
 2814|       |
 2815|       |        // Measure highest codepoints
 2816|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2817|      1|        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
  ------------------
  |  Branch (2817:29): [True: 1, False: 0]
  ------------------
 2818|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2818:60): [True: 1, False: 1]
  |  Branch (2818:76): [True: 1, False: 0]
  ------------------
 2819|      1|        {
 2820|       |            // Check for valid range. This may also help detect *some* dangling pointers, because a common
 2821|       |            // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent.
 2822|      1|            IM_ASSERT(src_range[0] <= src_range[1]);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2823|      1|            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
 2824|      1|        }
 2825|      1|        dst_tmp.SrcCount++;
 2826|      1|        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
 2827|      1|    }
 2828|       |
 2829|       |    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
 2830|      1|    int total_glyphs_count = 0;
 2831|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2831:25): [True: 1, False: 1]
  ------------------
 2832|      1|    {
 2833|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2834|      1|        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
 2835|      1|        src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
 2836|      1|        if (dst_tmp.GlyphsSet.Storage.empty())
  ------------------
  |  Branch (2836:13): [True: 1, False: 0]
  ------------------
 2837|      1|            dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);
 2838|       |
 2839|      2|        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
  ------------------
  |  Branch (2839:60): [True: 1, False: 1]
  |  Branch (2839:76): [True: 1, False: 0]
  ------------------
 2840|    225|            for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
  ------------------
  |  Branch (2840:57): [True: 224, False: 1]
  ------------------
 2841|    224|            {
 2842|    224|                if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
  ------------------
  |  Branch (2842:21): [True: 0, False: 224]
  ------------------
 2843|      0|                    continue;
 2844|    224|                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
  ------------------
  |  Branch (2844:21): [True: 1, False: 223]
  ------------------
 2845|      1|                    continue;
 2846|       |
 2847|       |                // Add to avail set/counters
 2848|    223|                src_tmp.GlyphsCount++;
 2849|    223|                dst_tmp.GlyphsCount++;
 2850|    223|                src_tmp.GlyphsSet.SetBit(codepoint);
 2851|    223|                dst_tmp.GlyphsSet.SetBit(codepoint);
 2852|    223|                total_glyphs_count++;
 2853|    223|            }
 2854|      1|    }
 2855|       |
 2856|       |    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
 2857|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2857:25): [True: 1, False: 1]
  ------------------
 2858|      1|    {
 2859|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2860|      1|        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
 2861|      1|        UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
 2862|      1|        src_tmp.GlyphsSet.Clear();
 2863|      1|        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2864|      1|    }
 2865|      2|    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
  ------------------
  |  Branch (2865:25): [True: 1, False: 1]
  ------------------
 2866|      1|        dst_tmp_array[dst_i].GlyphsSet.Clear();
 2867|      1|    dst_tmp_array.clear();
 2868|       |
 2869|       |    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
 2870|       |    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
 2871|      1|    ImVector<stbrp_rect> buf_rects;
 2872|      1|    ImVector<stbtt_packedchar> buf_packedchars;
 2873|      1|    buf_rects.resize(total_glyphs_count);
 2874|      1|    buf_packedchars.resize(total_glyphs_count);
 2875|      1|    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
 2876|      1|    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());
 2877|       |
 2878|       |    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
 2879|      1|    int total_surface = 0;
 2880|      1|    int buf_rects_out_n = 0;
 2881|      1|    int buf_packedchars_out_n = 0;
 2882|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2882:25): [True: 1, False: 1]
  ------------------
 2883|      1|    {
 2884|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2885|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2885:13): [True: 0, False: 1]
  ------------------
 2886|      0|            continue;
 2887|       |
 2888|      1|        src_tmp.Rects = &buf_rects[buf_rects_out_n];
 2889|      1|        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
 2890|      1|        buf_rects_out_n += src_tmp.GlyphsCount;
 2891|      1|        buf_packedchars_out_n += src_tmp.GlyphsCount;
 2892|       |
 2893|       |        // Convert our ranges in the format stb_truetype wants
 2894|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2895|      1|        src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;
 2896|      1|        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
 2897|      1|        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
 2898|      1|        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
 2899|      1|        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
 2900|      1|        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;
 2901|      1|        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;
 2902|       |
 2903|       |        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
 2904|      1|        const float scale = (cfg.SizePixels > 0.0f) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);
  ------------------
  |  Branch (2904:29): [True: 1, False: 0]
  ------------------
 2905|      1|        const int padding = atlas->TexGlyphPadding;
 2906|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
  ------------------
  |  Branch (2906:31): [True: 223, False: 1]
  ------------------
 2907|    223|        {
 2908|    223|            int x0, y0, x1, y1;
 2909|    223|            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
 2910|    223|            IM_ASSERT(glyph_index_in_font != 0);
  ------------------
  |  |   23|    223|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2911|    223|            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);
 2912|    223|            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);
 2913|    223|            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);
 2914|    223|            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
 2915|    223|        }
 2916|      1|    }
 2917|       |
 2918|       |    // We need a width for the skyline algorithm, any width!
 2919|       |    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
 2920|       |    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
 2921|      1|    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
  ------------------
  |  |  452|      1|#define ImSqrt(X)           sqrtf(X)
  ------------------
 2922|      1|    atlas->TexHeight = 0;
 2923|      1|    if (atlas->TexDesiredWidth > 0)
  ------------------
  |  Branch (2923:9): [True: 0, False: 1]
  ------------------
 2924|      0|        atlas->TexWidth = atlas->TexDesiredWidth;
 2925|      1|    else
 2926|      1|        atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;
  ------------------
  |  Branch (2926:27): [True: 0, False: 1]
  |  Branch (2926:66): [True: 0, False: 1]
  |  Branch (2926:105): [True: 0, False: 1]
  ------------------
 2927|       |
 2928|       |    // 5. Start packing
 2929|       |    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
 2930|      1|    const int TEX_HEIGHT_MAX = 1024 * 32;
 2931|      1|    stbtt_pack_context spc = {};
 2932|      1|    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);
 2933|      1|    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);
 2934|       |
 2935|       |    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
 2936|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2936:25): [True: 1, False: 1]
  ------------------
 2937|      1|    {
 2938|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2939|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2939:13): [True: 0, False: 1]
  ------------------
 2940|      0|            continue;
 2941|       |
 2942|      1|        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);
 2943|       |
 2944|       |        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
 2945|       |        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
 2946|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (2946:31): [True: 223, False: 1]
  ------------------
 2947|    223|            if (src_tmp.Rects[glyph_i].was_packed)
  ------------------
  |  Branch (2947:17): [True: 223, False: 0]
  ------------------
 2948|    223|                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
 2949|      1|    }
 2950|       |
 2951|       |    // 7. Allocate texture
 2952|      1|    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
  ------------------
  |  Branch (2952:24): [True: 0, False: 1]
  ------------------
 2953|      1|    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
 2954|      1|    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
  ------------------
  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  ------------------
 2955|      1|    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
 2956|      1|    spc.pixels = atlas->TexPixelsAlpha8;
 2957|      1|    spc.height = atlas->TexHeight;
 2958|       |
 2959|       |    // 8. Render/rasterize font characters into the texture
 2960|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2960:25): [True: 1, False: 1]
  ------------------
 2961|      1|    {
 2962|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2963|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2964|      1|        if (src_tmp.GlyphsCount == 0)
  ------------------
  |  Branch (2964:13): [True: 0, False: 1]
  ------------------
 2965|      0|            continue;
 2966|       |
 2967|      1|        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);
 2968|       |
 2969|       |        // Apply multiply operator
 2970|      1|        if (cfg.RasterizerMultiply != 1.0f)
  ------------------
  |  Branch (2970:13): [True: 0, False: 1]
  ------------------
 2971|      0|        {
 2972|      0|            unsigned char multiply_table[256];
 2973|      0|            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
 2974|      0|            stbrp_rect* r = &src_tmp.Rects[0];
 2975|      0|            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
  ------------------
  |  Branch (2975:35): [True: 0, False: 0]
  ------------------
 2976|      0|                if (r->was_packed)
  ------------------
  |  Branch (2976:21): [True: 0, False: 0]
  ------------------
 2977|      0|                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
 2978|      0|        }
 2979|      1|        src_tmp.Rects = NULL;
 2980|      1|    }
 2981|       |
 2982|       |    // End packing
 2983|      1|    stbtt_PackEnd(&spc);
 2984|      1|    buf_rects.clear();
 2985|       |
 2986|       |    // 9. Setup ImFont and glyphs for runtime
 2987|      2|    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
  ------------------
  |  Branch (2987:25): [True: 1, False: 1]
  ------------------
 2988|      1|    {
 2989|       |        // When merging fonts with MergeMode=true:
 2990|       |        // - We can have multiple input fonts writing into a same destination font.
 2991|       |        // - dst_font->ConfigData is != from cfg which is our source configuration.
 2992|      1|        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
 2993|      1|        ImFontConfig& cfg = atlas->ConfigData[src_i];
 2994|      1|        ImFont* dst_font = cfg.DstFont;
 2995|       |
 2996|      1|        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
 2997|      1|        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
 2998|      1|        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);
 2999|       |
 3000|      1|        const float ascent = ImCeil(unscaled_ascent * font_scale);
  ------------------
  |  |  459|      1|#define ImCeil(X)           ceilf(X)
  ------------------
 3001|      1|        const float descent = ImFloor(unscaled_descent * font_scale);
 3002|      1|        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
 3003|      1|        const float font_off_x = cfg.GlyphOffset.x;
 3004|      1|        const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);
  ------------------
  |  |  288|      1|#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //
  ------------------
 3005|       |
 3006|      1|        const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;
 3007|       |
 3008|    224|        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
  ------------------
  |  Branch (3008:31): [True: 223, False: 1]
  ------------------
 3009|    223|        {
 3010|       |            // Register glyph
 3011|    223|            const int codepoint = src_tmp.GlyphsList[glyph_i];
 3012|    223|            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
 3013|    223|            stbtt_aligned_quad q;
 3014|    223|            float unused_x = 0.0f, unused_y = 0.0f;
 3015|    223|            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
 3016|    223|            float x0 = q.x0 * inv_rasterization_scale + font_off_x;
 3017|    223|            float y0 = q.y0 * inv_rasterization_scale + font_off_y;
 3018|    223|            float x1 = q.x1 * inv_rasterization_scale + font_off_x;
 3019|    223|            float y1 = q.y1 * inv_rasterization_scale + font_off_y;
 3020|    223|            dst_font->AddGlyph(&cfg, (ImWchar)codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale);
 3021|    223|        }
 3022|      1|    }
 3023|       |
 3024|       |    // Cleanup
 3025|      1|    src_tmp_array.clear_destruct();
 3026|       |
 3027|      1|    ImFontAtlasBuildFinish(atlas);
 3028|      1|    return true;
 3029|      1|}
imgui_draw.cpp:_ZL30UnpackBitVectorToFlatIndexListPK11ImBitVectorP8ImVectorIiE:
 2757|      1|{
 2758|      1|    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 2759|      1|    const ImU32* it_begin = in->Storage.begin();
 2760|      1|    const ImU32* it_end = in->Storage.end();
 2761|      9|    for (const ImU32* it = it_begin; it < it_end; it++)
  ------------------
  |  Branch (2761:38): [True: 8, False: 1]
  ------------------
 2762|      8|        if (ImU32 entries_32 = *it)
  ------------------
  |  Branch (2762:19): [True: 7, False: 1]
  ------------------
 2763|    231|            for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
  ------------------
  |  Branch (2763:35): [True: 224, False: 7]
  ------------------
 2764|    224|                if (entries_32 & ((ImU32)1 << bit_n))
  ------------------
  |  Branch (2764:21): [True: 223, False: 1]
  ------------------
 2765|    223|                    out->push_back((int)(((it - it_begin) << 5) + bit_n));
 2766|      1|}
imgui_draw.cpp:_ZL36ImFontAtlasBuildRenderDefaultTexDataP11ImFontAtlas:
 3118|      1|{
 3119|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
 3120|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3121|       |
 3122|      1|    const int w = atlas->TexWidth;
 3123|      1|    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
  ------------------
  |  Branch (3123:9): [True: 1, False: 0]
  ------------------
 3124|      1|    {
 3125|       |        // Render/copy pixels
 3126|      1|        IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3127|      1|        const int x_for_white = r->X;
 3128|      1|        const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
 3129|      1|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (3129:13): [True: 1, False: 0]
  ------------------
 3130|      1|        {
 3131|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
 3132|      1|            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
 3133|      1|        }
 3134|      0|        else
 3135|      0|        {
 3136|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
  ------------------
  |  | 2754|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3137|      0|            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
  ------------------
  |  | 2754|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3138|      0|        }
 3139|      1|    }
 3140|      0|    else
 3141|      0|    {
 3142|       |        // Render 4 white pixels
 3143|      0|        IM_ASSERT(r->Width == 2 && r->Height == 2);
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3144|      0|        const int offset = (int)r->X + (int)r->Y * w;
 3145|      0|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (3145:13): [True: 0, False: 0]
  ------------------
 3146|      0|        {
 3147|      0|            atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
 3148|      0|        }
 3149|      0|        else
 3150|      0|        {
 3151|      0|            atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
  ------------------
  |  | 2754|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3152|      0|        }
 3153|      0|    }
 3154|      1|    atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
 3155|      1|}
imgui_draw.cpp:_ZL34ImFontAtlasBuildRenderLinesTexDataP11ImFontAtlas:
 3158|      1|{
 3159|      1|    if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
  ------------------
  |  Branch (3159:9): [True: 0, False: 1]
  ------------------
 3160|      0|        return;
 3161|       |
 3162|       |    // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
 3163|      1|    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
 3164|      1|    IM_ASSERT(r->IsPacked());
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3165|     65|    for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
  ------------------
  |  | 2786|     65|#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX     (63)
  ------------------
  |  Branch (3165:30): [True: 64, False: 1]
  ------------------
 3166|     64|    {
 3167|       |        // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
 3168|     64|        unsigned int y = n;
 3169|     64|        unsigned int line_width = n;
 3170|     64|        unsigned int pad_left = (r->Width - line_width) / 2;
 3171|     64|        unsigned int pad_right = r->Width - (pad_left + line_width);
 3172|       |
 3173|       |        // Write each slice
 3174|     64|        IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
  ------------------
  |  |   23|     64|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 3175|     64|        if (atlas->TexPixelsAlpha8 != NULL)
  ------------------
  |  Branch (3175:13): [True: 64, False: 0]
  ------------------
 3176|     64|        {
 3177|     64|            unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
 3178|  1.12k|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (3178:38): [True: 1.05k, False: 64]
  ------------------
 3179|  1.05k|                *(write_ptr + i) = 0x00;
 3180|       |
 3181|  2.08k|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (3181:38): [True: 2.01k, False: 64]
  ------------------
 3182|  2.01k|                *(write_ptr + pad_left + i) = 0xFF;
 3183|       |
 3184|  1.15k|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (3184:38): [True: 1.08k, False: 64]
  ------------------
 3185|  1.08k|                *(write_ptr + pad_left + line_width + i) = 0x00;
 3186|     64|        }
 3187|      0|        else
 3188|      0|        {
 3189|      0|            unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
 3190|      0|            for (unsigned int i = 0; i < pad_left; i++)
  ------------------
  |  Branch (3190:38): [True: 0, False: 0]
  ------------------
 3191|      0|                *(write_ptr + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 3192|       |
 3193|      0|            for (unsigned int i = 0; i < line_width; i++)
  ------------------
  |  Branch (3193:38): [True: 0, False: 0]
  ------------------
 3194|      0|                *(write_ptr + pad_left + i) = IM_COL32_WHITE;
  ------------------
  |  | 2754|      0|#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
  |  |  ------------------
  |  |  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  |  |  ------------------
  |  |  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  |  |  ------------------
  |  |  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3195|       |
 3196|      0|            for (unsigned int i = 0; i < pad_right; i++)
  ------------------
  |  Branch (3196:38): [True: 0, False: 0]
  ------------------
 3197|      0|                *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
  ------------------
  |  | 2753|      0|#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2749|      0|#define IM_COL32_A_SHIFT    24
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2748|      0|#define IM_COL32_B_SHIFT    16
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2747|      0|#define IM_COL32_G_SHIFT    8
  |  |  ------------------
  |  |               #define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
  |  |  ------------------
  |  |  |  | 2746|      0|#define IM_COL32_R_SHIFT    0
  |  |  ------------------
  ------------------
 3198|      0|        }
 3199|       |
 3200|       |        // Calculate UVs for this line
 3201|     64|        ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
 3202|     64|        ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
 3203|     64|        float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
 3204|     64|        atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
 3205|     64|    }
 3206|      1|}
imgui_draw.cpp:_ZL22FindFirstExistingGlyphP6ImFontPKti:
 3612|      2|{
 3613|      3|    for (int n = 0; n < candidate_chars_count; n++)
  ------------------
  |  Branch (3613:21): [True: 3, False: 0]
  ------------------
 3614|      3|        if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
  ------------------
  |  Branch (3614:13): [True: 2, False: 1]
  ------------------
 3615|      2|            return candidate_chars[n];
 3616|      0|    return (ImWchar)-1;
 3617|      2|}
imgui_draw.cpp:_ZL21stb_decompress_lengthPKh:
 4441|      2|{
 4442|      2|    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
 4443|      2|}
imgui_draw.cpp:_ZL14stb_decompressPhPKhj:
 4519|      1|{
 4520|      1|    if (stb__in4(0) != 0x57bC0000) return 0;
  ------------------
  |  | 4468|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4467|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4466|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4520:9): [True: 0, False: 1]
  ------------------
 4521|      1|    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
  ------------------
  |  | 4468|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4467|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4466|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4521:9): [True: 0, False: 1]
  ------------------
 4522|      1|    const unsigned int olen = stb_decompress_length(i);
 4523|      1|    stb__barrier_in_b = i;
 4524|      1|    stb__barrier_out_e = output + olen;
 4525|      1|    stb__barrier_out_b = output;
 4526|      1|    i += 16;
 4527|       |
 4528|      1|    stb__dout = output;
 4529|  2.98k|    for (;;) {
 4530|  2.98k|        const unsigned char *old_i = i;
 4531|  2.98k|        i = stb_decompress_token(i);
 4532|  2.98k|        if (i == old_i) {
  ------------------
  |  Branch (4532:13): [True: 1, False: 2.98k]
  ------------------
 4533|      1|            if (*i == 0x05 && i[1] == 0xfa) {
  ------------------
  |  Branch (4533:17): [True: 1, False: 0]
  |  Branch (4533:31): [True: 1, False: 0]
  ------------------
 4534|      1|                IM_ASSERT(stb__dout == output + olen);
  ------------------
  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4535|      1|                if (stb__dout != output + olen) return 0;
  ------------------
  |  Branch (4535:21): [True: 0, False: 1]
  ------------------
 4536|      1|                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
  ------------------
  |  | 4468|      1|#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))
  |  |  ------------------
  |  |  |  | 4467|      1|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  |  |  ------------------
  |  |  |  |  |  | 4466|      1|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4536:21): [True: 0, False: 1]
  ------------------
 4537|      0|                    return 0;
 4538|      1|                return olen;
 4539|      1|            } else {
 4540|      0|                IM_ASSERT(0); /* NOTREACHED */
  ------------------
  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4541|      0|                return 0;
 4542|      0|            }
 4543|      1|        }
 4544|  2.98k|        IM_ASSERT(stb__dout <= output + olen);
  ------------------
  |  |   23|  2.98k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4545|  2.98k|        if (stb__dout > output + olen)
  ------------------
  |  Branch (4545:13): [True: 0, False: 2.98k]
  ------------------
 4546|      0|            return 0;
 4547|  2.98k|    }
 4548|      1|}
imgui_draw.cpp:_ZL20stb_decompress_tokenPKh:
 4471|  2.98k|{
 4472|  2.98k|    if (*i >= 0x20) { // use fewer if's for cases that expand small
  ------------------
  |  Branch (4472:9): [True: 2.86k, False: 119]
  ------------------
 4473|  2.86k|        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
  ------------------
  |  Branch (4473:13): [True: 818, False: 2.04k]
  ------------------
 4474|  2.04k|        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
  ------------------
  |  | 4466|  1.39k|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4474:18): [True: 1.39k, False: 653]
  ------------------
 4475|    653|        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
 4476|  2.86k|    } else { // more ifs for cases that expand large, since overhead is amortized
 4477|    119|        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
  ------------------
  |  | 4467|    111|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4466|    111|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4477:13): [True: 111, False: 8]
  ------------------
 4478|      8|        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4467|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4466|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
  ------------------
  |  | 4466|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4478:18): [True: 0, False: 8]
  ------------------
 4479|      8|        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4466|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
  ------------------
  |  | 4466|      7|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4479:18): [True: 7, False: 1]
  ------------------
 4480|      1|        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4466|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
                      else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
  ------------------
  |  | 4466|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4480:18): [True: 0, False: 1]
  ------------------
 4481|      1|        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
  ------------------
  |  | 4467|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4466|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
  |  Branch (4481:18): [True: 0, False: 1]
  ------------------
 4482|      1|        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4467|      0|#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
  |  |  ------------------
  |  |  |  | 4466|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  |  |  ------------------
  ------------------
                      else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
  ------------------
  |  | 4466|      0|#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
  ------------------
  |  Branch (4482:18): [True: 0, False: 1]
  ------------------
 4483|    119|    }
 4484|  2.98k|    return i;
 4485|  2.98k|}
imgui_draw.cpp:_ZL10stb__matchPKhj:
 4449|  2.32k|{
 4450|       |    // INVERSE of memmove... write each byte before copying the next...
 4451|  2.32k|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|  2.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4452|  2.32k|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (4452:9): [True: 0, False: 2.32k]
  ------------------
 4453|  2.32k|    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (4453:9): [True: 0, False: 2.32k]
  ------------------
 4454|  40.8k|    while (length--) *stb__dout++ = *data++;
  ------------------
  |  Branch (4454:12): [True: 38.5k, False: 2.32k]
  ------------------
 4455|  2.32k|}
imgui_draw.cpp:_ZL8stb__litPKhj:
 4458|    660|{
 4459|    660|    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
  ------------------
  |  |   23|    660|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
 4460|    660|    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
  ------------------
  |  Branch (4460:9): [True: 0, False: 660]
  ------------------
 4461|    660|    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
  ------------------
  |  Branch (4461:9): [True: 0, False: 660]
  ------------------
 4462|    660|    memcpy(stb__dout, data, length);
 4463|    660|    stb__dout += length;
 4464|    660|}
imgui_draw.cpp:_ZL11stb_adler32jPhj:
 4488|      1|{
 4489|      1|    const unsigned long ADLER_MOD = 65521;
 4490|      1|    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
 4491|      1|    unsigned long blocklen = buflen % 5552;
 4492|       |
 4493|      1|    unsigned long i;
 4494|      9|    while (buflen) {
  ------------------
  |  Branch (4494:12): [True: 8, False: 1]
  ------------------
 4495|  5.15k|        for (i=0; i + 7 < blocklen; i += 8) {
  ------------------
  |  Branch (4495:19): [True: 5.15k, False: 8]
  ------------------
 4496|  5.15k|            s1 += buffer[0], s2 += s1;
 4497|  5.15k|            s1 += buffer[1], s2 += s1;
 4498|  5.15k|            s1 += buffer[2], s2 += s1;
 4499|  5.15k|            s1 += buffer[3], s2 += s1;
 4500|  5.15k|            s1 += buffer[4], s2 += s1;
 4501|  5.15k|            s1 += buffer[5], s2 += s1;
 4502|  5.15k|            s1 += buffer[6], s2 += s1;
 4503|  5.15k|            s1 += buffer[7], s2 += s1;
 4504|       |
 4505|  5.15k|            buffer += 8;
 4506|  5.15k|        }
 4507|       |
 4508|      8|        for (; i < blocklen; ++i)
  ------------------
  |  Branch (4508:16): [True: 0, False: 8]
  ------------------
 4509|      0|            s1 += *buffer++, s2 += s1;
 4510|       |
 4511|      8|        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
 4512|      8|        buflen -= blocklen;
 4513|      8|        blocklen = 5552;
 4514|      8|    }
 4515|      1|    return (unsigned int)(s2 << 16) + (unsigned int)s1;
 4516|      1|}
imgui_draw.cpp:_ZL37GetDefaultCompressedFontDataTTFBase85v:
 4651|      1|{
 4652|      1|    return proggy_clean_ttf_compressed_data_base85;
 4653|      1|}

imgui.cpp:_ZL7ImTruncRK6ImVec2:
  497|   170k|static inline ImVec2 ImTrunc(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }
imgui.cpp:_ZL7ImTruncf:
  496|   511k|static inline float  ImTrunc(float f)                                           { return (float)(int)(f); }
_ZN15ImGuiInputEventC2Ev:
 1429|  30.5k|    ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }
_ZN5ImGui10IsMouseKeyE8ImGuiKey:
 3479|  1.92M|    inline bool             IsMouseKey(ImGuiKey key)                    { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END; }
  ------------------
  |  | 1365|  3.84M|#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)
  ------------------
                  inline bool             IsMouseKey(ImGuiKey key)                    { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END; }
  ------------------
  |  | 1366|   137k|#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)
  ------------------
  |  Branch (3479:82): [True: 137k, False: 1.78M]
  |  Branch (3479:113): [True: 87.4k, False: 49.9k]
  ------------------
_ZN5ImGui15IsNamedKeyOrModE8ImGuiKey:
 3475|   222k|    inline bool             IsNamedKeyOrMod(ImGuiKey key)               { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super; }
  ------------------
  |  Branch (3475:83): [True: 222k, False: 0]
  |  Branch (3475:117): [True: 220k, False: 2.50k]
  |  Branch (3475:149): [True: 0, False: 2.50k]
  |  Branch (3475:173): [True: 0, False: 2.50k]
  |  Branch (3475:198): [True: 2.50k, False: 0]
  |  Branch (3475:221): [True: 0, False: 0]
  ------------------
_ZN5ImGui10IsAliasKeyE8ImGuiKey:
 3480|   554k|    inline bool             IsAliasKey(ImGuiKey key)                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1367|  1.10M|#define ImGuiKey_Aliases_BEGIN          (ImGuiKey_Mouse_BEGIN)
  |  |  ------------------
  |  |  |  | 1365|   554k|#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)
  |  |  ------------------
  ------------------
                  inline bool             IsAliasKey(ImGuiKey key)                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
  ------------------
  |  | 1368|   536k|#define ImGuiKey_Aliases_END            (ImGuiKey_Mouse_END)
  |  |  ------------------
  |  |  |  | 1366|   536k|#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)
  |  |  ------------------
  ------------------
  |  Branch (3480:82): [True: 536k, False: 17.6k]
  |  Branch (3480:115): [True: 536k, False: 0]
  ------------------
_ZN5ImGui12IsGamepadKeyE8ImGuiKey:
 3478|  16.4k|    inline bool             IsGamepadKey(ImGuiKey key)                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1363|  32.8k|#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
  ------------------
                  inline bool             IsGamepadKey(ImGuiKey key)                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
  ------------------
  |  | 1364|    238|#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
  ------------------
  |  Branch (3478:82): [True: 238, False: 16.1k]
  |  Branch (3478:115): [True: 238, False: 0]
  ------------------
_ZN5ImGui10IsNamedKeyE8ImGuiKey:
 3474|  2.31M|    inline bool             IsNamedKey(ImGuiKey key)                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }
  ------------------
  |  Branch (3474:82): [True: 2.31M, False: 20]
  |  Branch (3474:116): [True: 2.31M, False: 23]
  ------------------
imgui.cpp:_ZL7ImFloorf:
  498|   807k|static inline float  ImFloor(float f)                                           { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (498:99): [True: 789k, False: 17.8k]
  |  Branch (498:109): [True: 16.2k, False: 1.58k]
  ------------------
imgui.cpp:_ZL11ImLengthSqrRK6ImVec2:
  493|   195k|static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }
imgui.cpp:_ZL10ImSaturatef:
  492|  4.54M|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (492:90): [True: 0, False: 4.54M]
  |  Branch (492:110): [True: 0, False: 4.54M]
  ------------------
imgui.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  372|  93.6k|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (372:147): [True: 0, False: 93.6k]
  ------------------
_ZNK16ImGuiDataVarInfo9GetVarPtrEPv:
  825|   153k|    void* GetVarPtr(void* parent) const { return (void*)((unsigned char*)parent + Offset); }
_ZN13ImGuiStyleModC2Ei6ImVec2:
 1058|  76.6k|    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
_ZN6ImRect8ClipWithERKS_:
  572|   464k|    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
imgui.cpp:_ZL5ImMinRK6ImVec2S1_:
  486|   464k|static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (486:97): [True: 462k, False: 2.88k]
  |  Branch (486:128): [True: 459k, False: 4.90k]
  ------------------
_ZN6ImRect6ExpandERK6ImVec2:
  568|  8.01k|    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
_ZNK6ImRect8ContainsERKS_:
  562|    360|    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
  ------------------
  |  Branch (562:62): [True: 360, False: 0]
  |  Branch (562:82): [True: 360, False: 0]
  |  Branch (562:102): [True: 355, False: 5]
  |  Branch (562:122): [True: 355, False: 0]
  ------------------
_ZNK14ImGuiViewportP11GetMainRectEv:
 1934|   346k|    ImRect  GetMainRect() const         { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK6ImRect8OverlapsERKS_:
  564|   302k|    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
  ------------------
  |  Branch (564:62): [True: 301k, False: 710]
  |  Branch (564:82): [True: 287k, False: 14.0k]
  |  Branch (564:102): [True: 287k, False: 442]
  |  Branch (564:122): [True: 286k, False: 254]
  ------------------
_ZN6ImRectC2ERK6ImVec2S2_:
  548|  1.23M|    constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}
_ZN12ImGuiContextC2EP11ImFontAtlas:
 2472|      1|    {
 2473|      1|        IO.Ctx = this;
 2474|      1|        InputTextState.Ctx = this;
 2475|       |
 2476|      1|        Initialized = false;
 2477|      1|        ConfigFlagsCurrFrame = ConfigFlagsLastFrame = ImGuiConfigFlags_None;
 2478|      1|        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
  ------------------
  |  Branch (2478:35): [True: 0, False: 1]
  ------------------
 2479|      1|        Font = NULL;
 2480|      1|        FontSize = FontBaseSize = CurrentDpiScale = 0.0f;
 2481|      1|        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
  ------------------
  |  | 2054|      2|#define IM_NEW(_TYPE)                       new(ImNewWrapper(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
  ------------------
  |  Branch (2481:20): [True: 0, False: 1]
  ------------------
 2482|      1|        Time = 0.0f;
 2483|      1|        FrameCount = 0;
 2484|      1|        FrameCountEnded = FrameCountPlatformEnded = FrameCountRendered = -1;
 2485|      1|        WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
 2486|      1|        GcCompactAll = false;
 2487|      1|        TestEngineHookItems = false;
 2488|      1|        TestEngine = NULL;
 2489|      1|        memset(ContextName, 0, sizeof(ContextName));
 2490|       |
 2491|      1|        InputEventsNextMouseSource = ImGuiMouseSource_Mouse;
 2492|      1|        InputEventsNextEventId = 1;
 2493|       |
 2494|      1|        WindowsActiveCount = 0;
 2495|      1|        CurrentWindow = NULL;
 2496|      1|        HoveredWindow = NULL;
 2497|      1|        HoveredWindowUnderMovingWindow = NULL;
 2498|      1|        HoveredWindowBeforeClear = NULL;
 2499|      1|        MovingWindow = NULL;
 2500|      1|        WheelingWindow = NULL;
 2501|      1|        WheelingWindowStartFrame = WheelingWindowScrolledFrame = -1;
 2502|      1|        WheelingWindowReleaseTimer = 0.0f;
 2503|       |
 2504|      1|        DebugHookIdInfo = 0;
 2505|      1|        HoveredId = HoveredIdPreviousFrame = 0;
 2506|      1|        HoveredIdAllowOverlap = false;
 2507|      1|        HoveredIdIsDisabled = false;
 2508|      1|        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
 2509|      1|        ItemUnclipByLog = false;
 2510|      1|        ActiveId = 0;
 2511|      1|        ActiveIdIsAlive = 0;
 2512|      1|        ActiveIdTimer = 0.0f;
 2513|      1|        ActiveIdIsJustActivated = false;
 2514|      1|        ActiveIdAllowOverlap = false;
 2515|      1|        ActiveIdNoClearOnFocusLoss = false;
 2516|      1|        ActiveIdHasBeenPressedBefore = false;
 2517|      1|        ActiveIdHasBeenEditedBefore = false;
 2518|      1|        ActiveIdHasBeenEditedThisFrame = false;
 2519|      1|        ActiveIdFromShortcut = false;
 2520|      1|        ActiveIdClickOffset = ImVec2(-1, -1);
 2521|      1|        ActiveIdWindow = NULL;
 2522|      1|        ActiveIdSource = ImGuiInputSource_None;
 2523|      1|        ActiveIdMouseButton = -1;
 2524|      1|        ActiveIdPreviousFrame = 0;
 2525|      1|        ActiveIdPreviousFrameIsAlive = false;
 2526|      1|        ActiveIdPreviousFrameHasBeenEditedBefore = false;
 2527|      1|        ActiveIdPreviousFrameWindow = NULL;
 2528|      1|        LastActiveId = 0;
 2529|      1|        LastActiveIdTimer = 0.0f;
 2530|       |
 2531|      1|        LastKeyboardKeyPressTime = LastKeyModsChangeTime = LastKeyModsChangeFromNoneTime = -1.0;
 2532|       |
 2533|      1|        ActiveIdUsingNavDirMask = 0x00;
 2534|      1|        ActiveIdUsingAllKeyboardKeys = false;
 2535|       |#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
 2536|       |        ActiveIdUsingNavInputMask = 0x00;
 2537|       |#endif
 2538|       |
 2539|      1|        CurrentFocusScopeId = 0;
 2540|      1|        CurrentItemFlags = ImGuiItemFlags_None;
 2541|      1|        DebugShowGroupRects = false;
 2542|       |
 2543|      1|        CurrentViewport = NULL;
 2544|      1|        MouseViewport = MouseLastHoveredViewport = NULL;
 2545|      1|        PlatformLastFocusedViewportId = 0;
 2546|      1|        ViewportCreatedCount = PlatformWindowsCreatedCount = 0;
 2547|      1|        ViewportFocusedStampCount = 0;
 2548|       |
 2549|      1|        NavWindow = NULL;
 2550|      1|        NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = 0;
 2551|      1|        NavLayer = ImGuiNavLayer_Main;
 2552|      1|        NavNextActivateId = 0;
 2553|      1|        NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
 2554|      1|        NavHighlightActivatedId = 0;
 2555|      1|        NavHighlightActivatedTimer = 0.0f;
 2556|      1|        NavInputSource = ImGuiInputSource_Keyboard;
 2557|      1|        NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
  ------------------
  |  | 1736|      1|#define ImGuiSelectionUserData_Invalid        ((ImGuiSelectionUserData)-1)
  ------------------
 2558|      1|        NavIdIsAlive = false;
 2559|      1|        NavMousePosDirty = false;
 2560|      1|        NavDisableHighlight = true;
 2561|      1|        NavDisableMouseHover = false;
 2562|       |
 2563|      1|        NavAnyRequest = false;
 2564|      1|        NavInitRequest = false;
 2565|      1|        NavInitRequestFromMove = false;
 2566|      1|        NavMoveSubmitted = false;
 2567|      1|        NavMoveScoringItems = false;
 2568|      1|        NavMoveForwardToNextFrame = false;
 2569|      1|        NavMoveFlags = ImGuiNavMoveFlags_None;
 2570|      1|        NavMoveScrollFlags = ImGuiScrollFlags_None;
 2571|      1|        NavMoveKeyMods = ImGuiMod_None;
 2572|      1|        NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
 2573|      1|        NavScoringDebugCount = 0;
 2574|      1|        NavTabbingDir = 0;
 2575|      1|        NavTabbingCounter = 0;
 2576|       |
 2577|      1|        NavJustMovedFromFocusScopeId = NavJustMovedToId = NavJustMovedToFocusScopeId = 0;
 2578|      1|        NavJustMovedToKeyMods = ImGuiMod_None;
 2579|      1|        NavJustMovedToIsTabbing = false;
 2580|      1|        NavJustMovedToHasSelectionData = false;
 2581|       |
 2582|       |        // All platforms use Ctrl+Tab but Ctrl<>Super are swapped on Mac...
 2583|       |        // FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..
 2584|      1|        ConfigNavWindowingKeyNext = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiKey_Tab);
  ------------------
  |  Branch (2584:37): [True: 0, False: 1]
  ------------------
 2585|      1|        ConfigNavWindowingKeyPrev = IO.ConfigMacOSXBehaviors ? (ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab) : (ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab);
  ------------------
  |  Branch (2585:37): [True: 0, False: 1]
  ------------------
 2586|      1|        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
 2587|      1|        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
 2588|      1|        NavWindowingToggleLayer = false;
 2589|      1|        NavWindowingToggleKey = ImGuiKey_None;
 2590|       |
 2591|      1|        DimBgRatio = 0.0f;
 2592|       |
 2593|      1|        DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
 2594|      1|        DragDropSourceFlags = ImGuiDragDropFlags_None;
 2595|      1|        DragDropSourceFrameCount = -1;
 2596|      1|        DragDropMouseButton = -1;
 2597|      1|        DragDropTargetId = 0;
 2598|      1|        DragDropAcceptFlags = ImGuiDragDropFlags_None;
 2599|      1|        DragDropAcceptIdCurrRectSurface = 0.0f;
 2600|      1|        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
 2601|      1|        DragDropAcceptFrameCount = -1;
 2602|      1|        DragDropHoldJustPressedId = 0;
 2603|      1|        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));
 2604|       |
 2605|      1|        ClipperTempDataStacked = 0;
 2606|       |
 2607|      1|        CurrentTable = NULL;
 2608|      1|        TablesTempDataStacked = 0;
 2609|      1|        CurrentTabBar = NULL;
 2610|       |
 2611|      1|        HoverItemDelayId = HoverItemDelayIdPreviousFrame = HoverItemUnlockedStationaryId = HoverWindowUnlockedStationaryId = 0;
 2612|      1|        HoverItemDelayTimer = HoverItemDelayClearTimer = 0.0f;
 2613|       |
 2614|      1|        MouseCursor = ImGuiMouseCursor_Arrow;
 2615|      1|        MouseStationaryTimer = 0.0f;
 2616|       |
 2617|      1|        TempInputId = 0;
 2618|      1|        memset(&DataTypeZeroValue, 0, sizeof(DataTypeZeroValue));
 2619|      1|        BeginMenuDepth = BeginComboDepth = 0;
 2620|      1|        ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
 2621|      1|        ColorEditCurrentID = ColorEditSavedID = 0;
 2622|      1|        ColorEditSavedHue = ColorEditSavedSat = 0.0f;
 2623|      1|        ColorEditSavedColor = 0;
 2624|      1|        WindowResizeRelativeMode = false;
 2625|      1|        ScrollbarSeekMode = 0;
 2626|      1|        ScrollbarClickDeltaToGrabCenter = 0.0f;
 2627|      1|        SliderGrabClickOffset = 0.0f;
 2628|      1|        SliderCurrentAccum = 0.0f;
 2629|      1|        SliderCurrentAccumDirty = false;
 2630|      1|        DragCurrentAccumDirty = false;
 2631|      1|        DragCurrentAccum = 0.0f;
 2632|      1|        DragSpeedDefaultRatio = 1.0f / 100.0f;
 2633|      1|        DisabledAlphaBackup = 0.0f;
 2634|      1|        DisabledStackSize = 0;
 2635|      1|        LockMarkEdited = 0;
 2636|      1|        TooltipOverrideCount = 0;
 2637|       |
 2638|      1|        PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
 2639|      1|        PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission
 2640|      1|        PlatformImeViewport = 0;
 2641|       |
 2642|      1|        DockNodeWindowMenuHandler = NULL;
 2643|       |
 2644|      1|        SettingsLoaded = false;
 2645|      1|        SettingsDirtyTimer = 0.0f;
 2646|      1|        HookIdNext = 0;
 2647|       |
 2648|      1|        memset(LocalizationTable, 0, sizeof(LocalizationTable));
 2649|       |
 2650|      1|        LogEnabled = false;
 2651|      1|        LogType = ImGuiLogType_None;
 2652|      1|        LogNextPrefix = LogNextSuffix = NULL;
 2653|      1|        LogFile = NULL;
 2654|      1|        LogLinePosY = FLT_MAX;
 2655|      1|        LogLineFirstItem = false;
 2656|      1|        LogDepthRef = 0;
 2657|      1|        LogDepthToExpand = LogDepthToExpandDefault = 2;
 2658|       |
 2659|      1|        DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
 2660|      1|        DebugLocateId = 0;
 2661|      1|        DebugLogAutoDisableFlags = ImGuiDebugLogFlags_None;
 2662|      1|        DebugLogAutoDisableFrames = 0;
 2663|      1|        DebugLocateFrames = 0;
 2664|      1|        DebugBeginReturnValueCullDepth = -1;
 2665|      1|        DebugItemPickerActive = false;
 2666|      1|        DebugItemPickerMouseButton = ImGuiMouseButton_Left;
 2667|      1|        DebugItemPickerBreakId = 0;
 2668|      1|        DebugFlashStyleColorTime = 0.0f;
 2669|      1|        DebugFlashStyleColorIdx = ImGuiCol_COUNT;
 2670|      1|        DebugHoveredDockNode = NULL;
 2671|       |
 2672|       |        // Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations
 2673|      1|        DebugBreakInWindow = 0;
 2674|      1|        DebugBreakInTable = 0;
 2675|      1|        DebugBreakInLocateId = false;
 2676|      1|        DebugBreakKeyChord = ImGuiKey_Pause;
 2677|      1|        DebugBreakInShortcutRouting = ImGuiKey_None;
 2678|       |
 2679|      1|        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
 2680|      1|        FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
 2681|      1|        FramerateSecPerFrameAccum = 0.0f;
 2682|      1|        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
 2683|      1|        memset(TempKeychordName, 0, sizeof(TempKeychordName));
 2684|      1|    }
_ZN10ImBitArrayILi154ELin512EEC2Ev:
  608|      1|    ImBitArray()                                { ClearAllBits(); }
_ZN10ImBitArrayILi154ELin512EE12ClearAllBitsEv:
  609|      1|    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }
_ZN17ImGuiKeyOwnerDataC2Ev:
 1473|    154|    ImGuiKeyOwnerData()             { OwnerCurr = OwnerNext = ImGuiKeyOwner_NoOwner; LockThisFrame = LockUntilRelease = false; }
  ------------------
  |  | 1434|    154|#define ImGuiKeyOwner_NoOwner       ((ImGuiID)-1)   // Require key to have no owner.
  ------------------
_ZN20ImGuiKeyRoutingTableC2Ev:
 1460|      1|    ImGuiKeyRoutingTable()          { Clear(); }
_ZN17ImGuiNextItemDataC2Ev:
 1253|      1|    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); SelectionUserData = -1; }
_ZN17ImGuiLastItemDataC2Ev:
 1270|   170k|    ImGuiLastItemData()     { memset(this, 0, sizeof(*this)); }
_ZN19ImGuiNextWindowDataC2Ev:
 1223|      1|    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiNavItemDataC2Ev:
 1627|      5|    ImGuiNavItemData()  { Clear(); }
_ZN6ImPoolI10ImGuiTableEC2Ev:
  694|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN6ImPoolI11ImGuiTabBarEC2Ev:
  694|      1|    ImPool()    { FreeIdx = AliveCount = 0; }
_ZN19ImGuiInputTextStateC2Ev:
 1142|      1|    ImGuiInputTextState()                   { memset(this, 0, sizeof(*this)); }
_ZN30ImGuiInputTextDeactivatedStateC2Ev:
 1116|      1|    ImGuiInputTextDeactivatedState()    { memset(this, 0, sizeof(*this)); }
_ZN21ImGuiComboPreviewDataC2Ev:
 1071|      1|    ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }
_ZN22ImGuiTypingSelectStateC2Ev:
 1671|      1|    ImGuiTypingSelectState() { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiDockContextC2Ev:
 1889|      1|    ImGuiDockContext()              { memset(this, 0, sizeof(*this)); }
_ZN16ImGuiIDStackToolC2Ev:
 2088|      1|    ImGuiIDStackTool()      { memset(this, 0, sizeof(*this)); CopyToClipboardLastTime = -FLT_MAX; }
_ZN19ImGuiDebugAllocInfoC2Ev:
 2046|      1|    ImGuiDebugAllocInfo() { memset(this, 0, sizeof(*this)); }
_ZN20ImGuiSettingsHandlerC2Ev:
 1977|      3|    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
_ZN14ImGuiViewportPC2Ev:
 1924|      1|    ImGuiViewportP()                    { Window = NULL; Idx = -1; LastFrameActive = BgFgDrawListsLastFrame[0] = BgFgDrawListsLastFrame[1] = LastFocusedStampCount = -1; LastNameHash = 0; Alpha = LastAlpha = 1.0f; LastFocusedHadNavWindow = false; PlatformMonitor = -1; BgFgDrawLists[0] = BgFgDrawLists[1] = NULL; LastPlatformPos = LastPlatformSize = LastRendererSize = ImVec2(FLT_MAX, FLT_MAX); }
_ZN17ImDrawDataBuilderC2Ev:
  813|      1|    ImDrawDataBuilder()                     { memset(this, 0, sizeof(*this)); }
_ZN20ImGuiKeyRoutingTable5ClearEv:
 1461|    155|    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Index); n++) Index[n] = -1; Entries.clear(); EntriesNext.clear(); }
  ------------------
  |  |   93|    155|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (1461:55): [True: 154, False: 1]
  ------------------
_ZN6ImVec1C2Ev:
  527|      9|    constexpr ImVec1()         : x(0.0f) { }
_ZN16ImGuiMenuColumnsC2Ev:
 1104|      3|    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }
_ZN6ImRectC2Ev:
  547|   765k|    constexpr ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}
_ZN8ImVec2ihC2Ev:
  535|      6|    constexpr ImVec2ih()                           : x(0), y(0) {}
_ZN14ImGuiViewportP14UpdateWorkRectEv:
 1931|   153k|    void    UpdateWorkRect()            { WorkPos = CalcWorkRectPos(WorkOffsetMin); WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax); } // Update public fields
_ZNK14ImGuiViewportP15CalcWorkRectPosERK6ImVec2:
 1929|   153k|    ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }
_ZNK14ImGuiViewportP16CalcWorkRectSizeERK6ImVec2S2_:
 1930|   153k|    ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }
_ZNK11ImGuiWindow12TitleBarRectEv:
 2886|   383k|    ImRect      TitleBarRect() const    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight)); }
_ZNK6ImRect8ContainsERK6ImVec2:
  561|    530|    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
  ------------------
  |  Branch (561:62): [True: 530, False: 0]
  |  Branch (561:82): [True: 207, False: 323]
  |  Branch (561:102): [True: 207, False: 0]
  |  Branch (561:122): [True: 207, False: 0]
  ------------------
imgui.cpp:_ZL5ImMaxRK6ImVec2S1_:
  487|  1.22M|static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
  ------------------
  |  Branch (487:97): [True: 959k, False: 263k]
  |  Branch (487:129): [True: 961k, False: 261k]
  ------------------
_ZN6ImRect3AddERKS_:
  566|   153k|    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
  ------------------
  |  Branch (566:59): [True: 153k, False: 68]
  |  Branch (566:97): [True: 153k, False: 65]
  |  Branch (566:135): [True: 153k, False: 68]
  |  Branch (566:173): [True: 153k, False: 68]
  ------------------
_ZNK6ImRect6ToVec4Ev:
  576|  76.6k|    ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }
_ZN5ImGui14GetDefaultFontEv:
 3309|  76.6k|    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }
  ------------------
  |  Branch (3309:82): [True: 0, False: 76.6k]
  ------------------
_ZN5ImGui16GetCurrentWindowEv:
 3274|   830k|    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
_ZN6ImRectC2ERK6ImVec4:
  549|   681k|    constexpr ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}
_ZNK6ImRect15ContainsWithPadERK6ImVec2S2_:
  563|   549k|    bool        ContainsWithPad(const ImVec2& p, const ImVec2& pad) const { return p.x >= Min.x - pad.x && p.y >= Min.y - pad.y && p.x < Max.x + pad.x && p.y < Max.y + pad.y; }
  ------------------
  |  Branch (563:84): [True: 193k, False: 355k]
  |  Branch (563:108): [True: 60.9k, False: 132k]
  |  Branch (563:132): [True: 15.4k, False: 45.4k]
  |  Branch (563:155): [True: 9.36k, False: 6.05k]
  ------------------
_ZNK6ImRect7GetSizeEv:
  553|   170k|    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
imgui.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  480|    252|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (480:90): [True: 0, False: 252]
  |  Branch (480:106): [True: 0, False: 252]
  ------------------
_ZN15ImGuiStackSizesC2Ev:
 1295|   170k|    ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }
_ZNK11ImGuiWindow4RectEv:
 2884|   273k|    ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
_ZNK14ImGuiViewportP11GetWorkRectEv:
 1935|   170k|    ImRect  GetWorkRect() const         { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }
_ZNK6ImRect8GetWidthEv:
  554|   363k|    float       GetWidth() const                    { return Max.x - Min.x; }
_ZNK6ImRect9GetHeightEv:
  555|   361k|    float       GetHeight() const                   { return Max.y - Min.y; }
imgui.cpp:_ZL6ImLerpRK6ImVec2S1_S1_:
  490|  50.9k|static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
_ZN6ImRect12ClipWithFullERKS_:
  573|   170k|    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
_ZN19ImGuiNextWindowData10ClearFlagsEv:
 1224|   170k|    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }
_ZN6ImRectC2Effff:
  550|  1.59M|    constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}
_ZNK11ImGuiWindow12CalcFontSizeEv:
 2885|   271k|    float       CalcFontSize() const    { ImGuiContext& g = *Ctx; float scale = g.FontBaseSize * FontWindowScale * FontDpiScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }
  ------------------
  |  Branch (2885:134): [True: 23.4k, False: 248k]
  ------------------
imgui.cpp:_ZL14ImIsPowerOfTwoi:
  379|   247k|static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
  ------------------
  |  Branch (379:66): [True: 247k, False: 0]
  |  Branch (379:76): [True: 247k, False: 0]
  ------------------
_ZN5ImGui20GetCurrentWindowReadEv:
 3273|  30.1k|    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
_ZN5ImGui18WindowRectAbsToRelEP11ImGuiWindowRK6ImRect:
 3290|    813|    inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }
_ZN5ImGui8IsModKeyE8ImGuiKey:
 3481|   306k|    inline bool             IsModKey(ImGuiKey key)                      { return key >= ImGuiKey_LeftCtrl && key <= ImGuiKey_RightSuper; }
  ------------------
  |  Branch (3481:82): [True: 0, False: 306k]
  |  Branch (3481:110): [True: 0, False: 0]
  ------------------
_ZN5ImGui25ConvertSingleModFlagToKeyE8ImGuiKey:
 3484|   616k|    {
 3485|   616k|        if (key == ImGuiMod_Ctrl) return ImGuiKey_ReservedForModCtrl;
  ------------------
  |  Branch (3485:13): [True: 153k, False: 462k]
  ------------------
 3486|   462k|        if (key == ImGuiMod_Shift) return ImGuiKey_ReservedForModShift;
  ------------------
  |  Branch (3486:13): [True: 153k, False: 309k]
  ------------------
 3487|   309k|        if (key == ImGuiMod_Alt) return ImGuiKey_ReservedForModAlt;
  ------------------
  |  Branch (3487:13): [True: 155k, False: 153k]
  ------------------
 3488|   153k|        if (key == ImGuiMod_Super) return ImGuiKey_ReservedForModSuper;
  ------------------
  |  Branch (3488:13): [True: 153k, False: 0]
  ------------------
 3489|      0|        return key;
 3490|   153k|    }
_ZN5ImGui10GetKeyDataE8ImGuiKey:
 3493|  2.08M|    inline ImGuiKeyData*    GetKeyData(ImGuiKey key)                                    { ImGuiContext& g = *GImGui; return GetKeyData(&g, key); }
_ZN5ImGui16MouseButtonToKeyEi:
 3495|   383k|    inline ImGuiKey         MouseButtonToKey(ImGuiMouseButton button)                   { IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT); return (ImGuiKey)(ImGuiKey_MouseLeft + button); }
  ------------------
  |  |   23|   383k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_ZN5ImGui13IsKeyboardKeyE8ImGuiKey:
 3477|  11.9k|    inline bool             IsKeyboardKey(ImGuiKey key)                 { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END; }
  ------------------
  |  | 1361|  23.8k|#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
  ------------------
                  inline bool             IsKeyboardKey(ImGuiKey key)                 { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END; }
  ------------------
  |  | 1362|  11.9k|#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
  ------------------
  |  Branch (3477:82): [True: 11.9k, False: 0]
  |  Branch (3477:116): [True: 4.93k, False: 7.01k]
  ------------------
imgui.cpp:_ZL7ImFloorRK6ImVec2:
  499|  57.8k|static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2(ImFloor(v.x), ImFloor(v.y)); }
imgui.cpp:_ZL26ImExponentialMovingAverageffi:
  506|    894|static inline float  ImExponentialMovingAverage(float avg, float sample, int n) { avg -= avg / n; avg += sample / n; return avg; }
imgui.cpp:_ZL5ImAbsf:
  465|    895|static inline float  ImAbs(float x)             { return fabsf(x); }
_ZN5ImGui15GetKeyOwnerDataEP12ImGuiContext8ImGuiKey:
 3521|   213k|    inline ImGuiKeyOwnerData* GetKeyOwnerData(ImGuiContext* ctx, ImGuiKey key)          { if (key & ImGuiMod_Mask_) key = ConvertSingleModFlagToKey(key); IM_ASSERT(IsNamedKey(key)); return &ctx->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN]; }
  ------------------
  |  |   23|   213k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  |  Branch (3521:95): [True: 2.50k, False: 211k]
  ------------------
imgui.cpp:_ZL7ImClampRK6ImVec2S1_S1_:
  488|   664k|static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2&mn, const ImVec2&mx) { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
  ------------------
  |  Branch (488:97): [True: 125k, False: 538k]
  |  Branch (488:119): [True: 232, False: 538k]
  |  Branch (488:146): [True: 13.1k, False: 651k]
  |  Branch (488:168): [True: 884, False: 650k]
  ------------------
_ZN16ImGuiNavItemData5ClearEv:
 1628|  2.03k|    void Clear()        { Window = NULL; ID = FocusScopeId = 0; InFlags = 0; SelectionUserData = -1; DistBox = DistCenter = DistAxial = FLT_MAX; }
_ZN5ImGui21IsActiveIdUsingNavDirE8ImGuiDir:
 3503|  30.0k|    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }
_ZN6ImRect10TranslateYEf:
  571|  7.57k|    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
_ZN5ImGui18WindowRectRelToAbsEP11ImGuiWindowRK6ImRect:
 3291|  7.56k|    inline ImRect           WindowRectRelToAbs(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y); }
_ZNK6ImRect9GetCenterEv:
  552|    556|    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
_ZNK13ImChunkStreamI19ImGuiWindowSettingsE5emptyEv:
  726|      1|    bool    empty() const               { return Buf.Size == 0; }
_ZN14ImGuiViewportP17ClearRequestFlagsEv:
 1926|  76.6k|    void    ClearRequestFlags()         { PlatformRequestClose = PlatformRequestMove = PlatformRequestResize = false; }
_ZNK6ImRect10IsInvertedEv:
  575|  15.0k|    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
  ------------------
  |  Branch (575:62): [True: 0, False: 15.0k]
  |  Branch (575:79): [True: 0, False: 15.0k]
  ------------------
_ZN6ImRect3AddERK6ImVec2:
  565|   153k|    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }
  ------------------
  |  Branch (565:59): [True: 76.6k, False: 76.6k]
  |  Branch (565:97): [True: 76.6k, False: 76.6k]
  |  Branch (565:135): [True: 153k, False: 0]
  |  Branch (565:173): [True: 153k, False: 0]
  ------------------
imgui.cpp:_ZL5ImMinIfET_S0_S0_:
  478|   374k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (478:90): [True: 33.5k, False: 341k]
  ------------------
imgui.cpp:_ZL5ImMaxIfET_S0_S0_:
  479|  4.23M|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (479:90): [True: 3.17M, False: 1.05M]
  ------------------
imgui.cpp:_ZL5ImMinIiET_S0_S0_:
  478|  88.1k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (478:90): [True: 59, False: 88.0k]
  ------------------
imgui.cpp:_ZL6ImSwapIfEvRT_S1_:
  482|  50.8k|template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
_ZN10ImBitArrayILi154ELin512EE6SetBitEi:
  612|     64|    void            SetBit(int n)               { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(Storage, n); }
  ------------------
  |  |   23|     64|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
_Z16ImBitArraySetBitPji:
  586|  7.55k|inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }
_ZN10ImBitArrayILi154ELi0EEC2Ev:
  608|  76.6k|    ImBitArray()                                { ClearAllBits(); }
_ZN10ImBitArrayILi154ELi0EE12ClearAllBitsEv:
  609|  76.6k|    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }
_ZNK10ImBitArrayILi154ELi0EE7TestBitEi:
  611|  7.71k|    bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
  ------------------
  |  |   23|  7.71k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
  ------------------
  |  |  580|  7.71k|#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
  ------------------
_ZN10ImBitArrayILi154ELi0EE6SetBitEi:
  612|  7.04k|    void            SetBit(int n)               { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(Storage, n); }
  ------------------
  |  |   23|  7.04k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui.cpp:_ZL6ImLerpIfET_S0_S0_f:
  481|    640|template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }
_ZN13ImChunkStreamI19ImGuiWindowSettingsE5beginEv:
  729|      2|    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }
  ------------------
  |  Branch (729:66): [True: 2, False: 0]
  ------------------
_ZN11ImBitVector6CreateEi:
  623|      2|    void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
_ZN11ImBitVector5ClearEv:
  624|      2|    void            Clear()                     { Storage.clear(); }
_ZNK11ImBitVector7TestBitEi:
  625|    224|    bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }
  ------------------
  |  |   23|    224|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
                  bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }
  ------------------
  |  |  580|    224|#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
  ------------------
_ZN11ImBitVector6SetBitEi:
  626|    446|    void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }
  ------------------
  |  |   23|    446|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
imgui_draw.cpp:_ZL6ImLerpRK6ImVec4S1_f:
  491|      4|static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
imgui_draw.cpp:_ZL7ImRsqrtf:
  470|  1.40M|static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }
imgui_draw.cpp:_ZL5ImAbsi:
  464|  74.9k|static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }
  ------------------
  |  Branch (464:58): [True: 0, False: 74.9k]
  ------------------
imgui_draw.cpp:_ZL7ImFloorf:
  498|  1.28k|static inline float  ImFloor(float f)                                           { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
  ------------------
  |  Branch (498:99): [True: 648, False: 637]
  |  Branch (498:109): [True: 636, False: 1]
  ------------------
imgui_draw.cpp:_ZL17ImUpperPowerOfTwoi:
  381|      1|static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
imgui_draw.cpp:_ZL7ImQsortPvmmPFiPKvS1_E:
  372|      4|static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
  ------------------
  |  Branch (372:147): [True: 4, False: 0]
  ------------------
imgui_draw.cpp:_ZL7ImTruncf:
  496|      1|static inline float  ImTrunc(float f)                                           { return (float)(int)(f); }
imgui_draw.cpp:_ZL5ImMinIfET_S0_S0_:
  478|   200k|template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
  ------------------
  |  Branch (478:90): [True: 31.9k, False: 168k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIfET_S0_S0_:
  479|  1.03M|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (479:90): [True: 286k, False: 748k]
  ------------------
imgui_draw.cpp:_ZL7ImClampIiET_S0_S0_S0_:
  480|  78.1k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (480:90): [True: 0, False: 78.1k]
  |  Branch (480:106): [True: 0, False: 78.1k]
  ------------------
imgui_draw.cpp:_ZL5ImMaxIiET_S0_S0_:
  479|    450|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (479:90): [True: 223, False: 227]
  ------------------
imgui_draw.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  480|    223|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (480:90): [True: 0, False: 223]
  |  Branch (480:106): [True: 0, False: 223]
  ------------------
imgui_widgets.cpp:_ZL10ImSaturatef:
  492|  10.5k|static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
  ------------------
  |  Branch (492:90): [True: 2.22k, False: 8.33k]
  |  Branch (492:110): [True: 0, False: 8.33k]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIfET_S0_S0_:
  479|  34.6k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (479:90): [True: 25.3k, False: 9.31k]
  ------------------
imgui_widgets.cpp:_ZL7ImClampIfET_S0_S0_S0_:
  480|  22.9k|template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
  ------------------
  |  Branch (480:90): [True: 5.42k, False: 17.5k]
  |  Branch (480:106): [True: 6.49k, False: 11.0k]
  ------------------
imgui_widgets.cpp:_ZL5ImMaxIxET_S0_S0_:
  479|  30.6k|template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
  ------------------
  |  Branch (479:90): [True: 21.8k, False: 8.79k]
  ------------------
imgui_widgets.cpp:_ZL6ImLerpIfET_S0_S0_f:
  481|  15.3k|template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }

_ZN5ImGui31TableSettingsAddSettingsHandlerEv:
 3811|      1|{
 3812|      1|    ImGuiSettingsHandler ini_handler;
 3813|      1|    ini_handler.TypeName = "Table";
 3814|      1|    ini_handler.TypeHash = ImHashStr("Table");
 3815|      1|    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
 3816|      1|    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
 3817|      1|    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
 3818|      1|    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
 3819|      1|    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
 3820|      1|    AddSettingsHandler(&ini_handler);
 3821|      1|}

_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i:
  485|   262k|{
  486|   262k|    ImGuiContext& g = *GImGui;
  487|   262k|    ImGuiWindow* window = GetCurrentWindow();
  488|       |
  489|       |    // Default only reacts to left mouse button
  490|   262k|    if ((flags & ImGuiButtonFlags_MouseButtonMask_) == 0)
  ------------------
  |  Branch (490:9): [True: 262k, False: 0]
  ------------------
  491|   262k|        flags |= ImGuiButtonFlags_MouseButtonLeft;
  492|       |
  493|       |    // Default behavior requires click + release inside bounding box
  494|   262k|    if ((flags & ImGuiButtonFlags_PressedOnMask_) == 0)
  ------------------
  |  Branch (494:9): [True: 262k, False: 0]
  ------------------
  495|   262k|        flags |= ImGuiButtonFlags_PressedOnDefault_;
  496|       |
  497|       |    // Default behavior inherited from item flags
  498|       |    // Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check that.
  499|   262k|    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);
  ------------------
  |  Branch (499:34): [True: 262k, False: 0]
  ------------------
  500|   262k|    if (flags & ImGuiButtonFlags_AllowOverlap)
  ------------------
  |  Branch (500:9): [True: 0, False: 262k]
  ------------------
  501|      0|        item_flags |= ImGuiItemFlags_AllowOverlap;
  502|   262k|    if (flags & ImGuiButtonFlags_Repeat)
  ------------------
  |  Branch (502:9): [True: 0, False: 262k]
  ------------------
  503|      0|        item_flags |= ImGuiItemFlags_ButtonRepeat;
  504|       |
  505|   262k|    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
  506|   262k|    const bool flatten_hovered_children = (flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredWindow && g.HoveredWindow->RootWindowDockTree == window->RootWindowDockTree;
  ------------------
  |  Branch (506:43): [True: 101k, False: 161k]
  |  Branch (506:89): [True: 2.68k, False: 98.9k]
  |  Branch (506:108): [True: 2.68k, False: 0]
  ------------------
  507|   262k|    if (flatten_hovered_children)
  ------------------
  |  Branch (507:9): [True: 2.68k, False: 260k]
  ------------------
  508|  2.68k|        g.HoveredWindow = window;
  509|       |
  510|       |#ifdef IMGUI_ENABLE_TEST_ENGINE
  511|       |    // Alternate registration spot, for when caller didn't use ItemAdd()
  512|       |    if (g.LastItemData.ID != id)
  513|       |        IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, NULL);
  514|       |#endif
  515|       |
  516|   262k|    bool pressed = false;
  517|   262k|    bool hovered = ItemHoverable(bb, id, item_flags);
  518|       |
  519|       |    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
  520|   262k|    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
  ------------------
  |  Branch (520:9): [True: 1.31k, False: 261k]
  |  Branch (520:29): [True: 0, False: 1.31k]
  |  Branch (520:81): [True: 0, False: 0]
  ------------------
  521|      0|        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
  ------------------
  |  Branch (521:13): [True: 0, False: 0]
  ------------------
  522|      0|        {
  523|      0|            hovered = true;
  524|      0|            SetHoveredID(id);
  525|      0|            if (g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER)
  ------------------
  |  Branch (525:17): [True: 0, False: 0]
  |  Branch (525:85): [True: 0, False: 0]
  ------------------
  526|      0|            {
  527|      0|                pressed = true;
  528|      0|                g.DragDropHoldJustPressedId = id;
  529|      0|                FocusWindow(window);
  530|      0|            }
  531|      0|        }
  532|       |
  533|   262k|    if (flatten_hovered_children)
  ------------------
  |  Branch (533:9): [True: 2.68k, False: 260k]
  ------------------
  534|  2.68k|        g.HoveredWindow = backup_hovered_window;
  535|       |
  536|       |    // Mouse handling
  537|   262k|    const ImGuiID test_owner_id = (flags & ImGuiButtonFlags_NoTestKeyOwner) ? ImGuiKeyOwner_Any : id;
  ------------------
  |  | 1433|      0|#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
  ------------------
  |  Branch (537:35): [True: 0, False: 262k]
  ------------------
  538|   262k|    if (hovered)
  ------------------
  |  Branch (538:9): [True: 134, False: 262k]
  ------------------
  539|    134|    {
  540|    134|        IM_ASSERT(id != 0); // Lazily check inside rare path.
  ------------------
  |  |   23|    134|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  541|       |
  542|       |        // Poll mouse buttons
  543|       |        // - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
  544|       |        // - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
  545|    134|        int mouse_button_clicked = -1;
  546|    134|        int mouse_button_released = -1;
  547|    536|        for (int button = 0; button < 3; button++)
  ------------------
  |  Branch (547:30): [True: 402, False: 134]
  ------------------
  548|    402|            if (flags & (ImGuiButtonFlags_MouseButtonLeft << button)) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
  ------------------
  |  Branch (548:17): [True: 134, False: 268]
  ------------------
  549|    134|            {
  550|    134|                if (IsMouseClicked(button, ImGuiInputFlags_None, test_owner_id) && mouse_button_clicked == -1) { mouse_button_clicked = button; }
  ------------------
  |  Branch (550:21): [True: 3, False: 131]
  |  Branch (550:84): [True: 3, False: 0]
  ------------------
  551|    134|                if (IsMouseReleased(button, test_owner_id) && mouse_button_released == -1) { mouse_button_released = button; }
  ------------------
  |  Branch (551:21): [True: 1, False: 133]
  |  Branch (551:63): [True: 1, False: 0]
  ------------------
  552|    134|            }
  553|       |
  554|       |        // Process initial action
  555|    134|        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
  ------------------
  |  Branch (555:13): [True: 134, False: 0]
  |  Branch (555:60): [True: 0, False: 0]
  |  Branch (555:77): [True: 0, False: 0]
  |  Branch (555:95): [True: 0, False: 0]
  ------------------
  556|    134|        {
  557|    134|            if (mouse_button_clicked != -1 && g.ActiveId != id)
  ------------------
  |  Branch (557:17): [True: 3, False: 131]
  |  Branch (557:47): [True: 3, False: 0]
  ------------------
  558|      3|            {
  559|      3|                if (!(flags & ImGuiButtonFlags_NoSetKeyOwner))
  ------------------
  |  Branch (559:21): [True: 3, False: 0]
  ------------------
  560|      3|                    SetKeyOwner(MouseButtonToKey(mouse_button_clicked), id);
  561|      3|                if (flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))
  ------------------
  |  Branch (561:21): [True: 3, False: 0]
  ------------------
  562|      3|                {
  563|      3|                    SetActiveID(id, window);
  564|      3|                    g.ActiveIdMouseButton = mouse_button_clicked;
  565|      3|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (565:25): [True: 0, False: 3]
  ------------------
  566|      0|                        SetFocusID(id, window);
  567|      3|                    FocusWindow(window);
  568|      3|                }
  569|      3|                if ((flags & ImGuiButtonFlags_PressedOnClick) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseClickedCount[mouse_button_clicked] == 2))
  ------------------
  |  Branch (569:21): [True: 0, False: 3]
  |  Branch (569:67): [True: 0, False: 3]
  |  Branch (569:118): [True: 0, False: 0]
  ------------------
  570|      0|                {
  571|      0|                    pressed = true;
  572|      0|                    if (flags & ImGuiButtonFlags_NoHoldingActiveId)
  ------------------
  |  Branch (572:25): [True: 0, False: 0]
  ------------------
  573|      0|                        ClearActiveID();
  574|      0|                    else
  575|      0|                        SetActiveID(id, window); // Hold on ID
  576|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (576:25): [True: 0, False: 0]
  ------------------
  577|      0|                        SetFocusID(id, window);
  578|      0|                    g.ActiveIdMouseButton = mouse_button_clicked;
  579|      0|                    FocusWindow(window);
  580|      0|                }
  581|      3|            }
  582|    134|            if (flags & ImGuiButtonFlags_PressedOnRelease)
  ------------------
  |  Branch (582:17): [True: 0, False: 134]
  ------------------
  583|      0|            {
  584|      0|                if (mouse_button_released != -1)
  ------------------
  |  Branch (584:21): [True: 0, False: 0]
  ------------------
  585|      0|                {
  586|      0|                    const bool has_repeated_at_least_once = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
  ------------------
  |  Branch (586:61): [True: 0, False: 0]
  |  Branch (586:107): [True: 0, False: 0]
  ------------------
  587|      0|                    if (!has_repeated_at_least_once)
  ------------------
  |  Branch (587:25): [True: 0, False: 0]
  ------------------
  588|      0|                        pressed = true;
  589|      0|                    if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (589:25): [True: 0, False: 0]
  ------------------
  590|      0|                        SetFocusID(id, window);
  591|      0|                    ClearActiveID();
  592|      0|                }
  593|      0|            }
  594|       |
  595|       |            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
  596|       |            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
  597|    134|            if (g.ActiveId == id && (item_flags & ImGuiItemFlags_ButtonRepeat))
  ------------------
  |  Branch (597:17): [True: 4, False: 130]
  |  Branch (597:37): [True: 0, False: 4]
  ------------------
  598|      0|                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0f && IsMouseClicked(g.ActiveIdMouseButton, ImGuiInputFlags_Repeat, test_owner_id))
  ------------------
  |  Branch (598:21): [True: 0, False: 0]
  |  Branch (598:77): [True: 0, False: 0]
  ------------------
  599|      0|                    pressed = true;
  600|    134|        }
  601|       |
  602|    134|        if (pressed)
  ------------------
  |  Branch (602:13): [True: 0, False: 134]
  ------------------
  603|      0|            g.NavDisableHighlight = true;
  604|    134|    }
  605|       |
  606|       |    // Gamepad/Keyboard handling
  607|       |    // We report navigated and navigation-activated items as hovered but we don't set g.HoveredId to not interfere with mouse.
  608|   262k|    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover)
  ------------------
  |  Branch (608:9): [True: 402, False: 262k]
  |  Branch (608:26): [True: 383, False: 19]
  |  Branch (608:52): [True: 206, False: 177]
  ------------------
  609|    206|        if (!(flags & ImGuiButtonFlags_NoHoveredOnFocus))
  ------------------
  |  Branch (609:13): [True: 206, False: 0]
  ------------------
  610|    206|            hovered = true;
  611|   262k|    if (g.NavActivateDownId == id)
  ------------------
  |  Branch (611:9): [True: 15, False: 262k]
  ------------------
  612|     15|    {
  613|     15|        bool nav_activated_by_code = (g.NavActivateId == id);
  614|     15|        bool nav_activated_by_inputs = (g.NavActivatePressedId == id);
  615|     15|        if (!nav_activated_by_inputs && (item_flags & ImGuiItemFlags_ButtonRepeat))
  ------------------
  |  Branch (615:13): [True: 14, False: 1]
  |  Branch (615:41): [True: 0, False: 14]
  ------------------
  616|      0|        {
  617|       |            // Avoid pressing multiple keys from triggering excessive amount of repeat events
  618|      0|            const ImGuiKeyData* key1 = GetKeyData(ImGuiKey_Space);
  619|      0|            const ImGuiKeyData* key2 = GetKeyData(ImGuiKey_Enter);
  620|      0|            const ImGuiKeyData* key3 = GetKeyData(ImGuiKey_NavGamepadActivate);
  ------------------
  |  | 1375|      0|#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
  ------------------
  621|      0|            const float t1 = ImMax(ImMax(key1->DownDuration, key2->DownDuration), key3->DownDuration);
  622|      0|            nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
  623|      0|        }
  624|     15|        if (nav_activated_by_code || nav_activated_by_inputs)
  ------------------
  |  Branch (624:13): [True: 1, False: 14]
  |  Branch (624:38): [True: 0, False: 14]
  ------------------
  625|      1|        {
  626|       |            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
  627|      1|            pressed = true;
  628|      1|            SetActiveID(id, window);
  629|      1|            g.ActiveIdSource = g.NavInputSource;
  630|      1|            if (!(flags & ImGuiButtonFlags_NoNavFocus) && !(g.NavActivateFlags & ImGuiActivateFlags_FromShortcut))
  ------------------
  |  Branch (630:17): [True: 1, False: 0]
  |  Branch (630:59): [True: 1, False: 0]
  ------------------
  631|      1|                SetFocusID(id, window);
  632|      1|            if (g.NavActivateFlags & ImGuiActivateFlags_FromShortcut)
  ------------------
  |  Branch (632:17): [True: 0, False: 1]
  ------------------
  633|      0|                g.ActiveIdFromShortcut = true;
  634|      1|        }
  635|     15|    }
  636|       |
  637|       |    // Process while held
  638|   262k|    bool held = false;
  639|   262k|    if (g.ActiveId == id)
  ------------------
  |  Branch (639:9): [True: 5, False: 262k]
  ------------------
  640|      5|    {
  641|      5|        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
  ------------------
  |  Branch (641:13): [True: 4, False: 1]
  ------------------
  642|      4|        {
  643|      4|            if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (643:17): [True: 3, False: 1]
  ------------------
  644|      3|                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
  645|       |
  646|      4|            const int mouse_button = g.ActiveIdMouseButton;
  647|      4|            if (mouse_button == -1)
  ------------------
  |  Branch (647:17): [True: 0, False: 4]
  ------------------
  648|      0|            {
  649|       |                // Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g. #6304).
  650|      0|                ClearActiveID();
  651|      0|            }
  652|      4|            else if (IsMouseDown(mouse_button, test_owner_id))
  ------------------
  |  Branch (652:22): [True: 4, False: 0]
  ------------------
  653|      4|            {
  654|      4|                held = true;
  655|      4|            }
  656|      0|            else
  657|      0|            {
  658|      0|                bool release_in = hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) != 0;
  ------------------
  |  Branch (658:35): [True: 0, False: 0]
  |  Branch (658:46): [True: 0, False: 0]
  ------------------
  659|      0|                bool release_anywhere = (flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
  660|      0|                if ((release_in || release_anywhere) && !g.DragDropActive)
  ------------------
  |  Branch (660:22): [True: 0, False: 0]
  |  Branch (660:36): [True: 0, False: 0]
  |  Branch (660:57): [True: 0, False: 0]
  ------------------
  661|      0|                {
  662|       |                    // Report as pressed when releasing the mouse (this is the most common path)
  663|      0|                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2;
  ------------------
  |  Branch (663:52): [True: 0, False: 0]
  |  Branch (663:103): [True: 0, False: 0]
  |  Branch (663:139): [True: 0, False: 0]
  ------------------
  664|      0|                    bool is_repeating_already = (item_flags & ImGuiItemFlags_ButtonRepeat) && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
  ------------------
  |  Branch (664:49): [True: 0, False: 0]
  |  Branch (664:95): [True: 0, False: 0]
  ------------------
  665|      0|                    bool is_button_avail_or_owned = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id);
  666|      0|                    if (!is_double_click_release && !is_repeating_already && is_button_avail_or_owned)
  ------------------
  |  Branch (666:25): [True: 0, False: 0]
  |  Branch (666:53): [True: 0, False: 0]
  |  Branch (666:78): [True: 0, False: 0]
  ------------------
  667|      0|                        pressed = true;
  668|      0|                }
  669|      0|                ClearActiveID();
  670|      0|            }
  671|      4|            if (!(flags & ImGuiButtonFlags_NoNavFocus))
  ------------------
  |  Branch (671:17): [True: 0, False: 4]
  ------------------
  672|      0|                g.NavDisableHighlight = true;
  673|      4|        }
  674|      1|        else if (g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad)
  ------------------
  |  Branch (674:18): [True: 1, False: 0]
  |  Branch (674:67): [True: 0, False: 0]
  ------------------
  675|      1|        {
  676|       |            // When activated using Nav, we hold on the ActiveID until activation button is released
  677|      1|            if (g.NavActivateDownId == id)
  ------------------
  |  Branch (677:17): [True: 1, False: 0]
  ------------------
  678|      1|                held = true; // hovered == true not true as we are already likely hovered on direct activation.
  679|      0|            else
  680|      0|                ClearActiveID();
  681|      1|        }
  682|      5|        if (pressed)
  ------------------
  |  Branch (682:13): [True: 1, False: 4]
  ------------------
  683|      1|            g.ActiveIdHasBeenPressedBefore = true;
  684|      5|    }
  685|       |
  686|       |    // Activation highlight (this may be a remote activation)
  687|   262k|    if (g.NavHighlightActivatedId == id)
  ------------------
  |  Branch (687:9): [True: 6, False: 262k]
  ------------------
  688|      6|        hovered = true;
  689|       |
  690|   262k|    if (out_hovered) *out_hovered = hovered;
  ------------------
  |  Branch (690:9): [True: 262k, False: 0]
  ------------------
  691|   262k|    if (out_held) *out_held = held;
  ------------------
  |  Branch (691:9): [True: 262k, False: 0]
  ------------------
  692|       |
  693|   262k|    return pressed;
  694|   262k|}
_ZN5ImGui14CollapseButtonEjRK6ImVec2P13ImGuiDockNode:
  854|   153k|{
  855|   153k|    ImGuiContext& g = *GImGui;
  856|   153k|    ImGuiWindow* window = g.CurrentWindow;
  857|       |
  858|   153k|    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize));
  859|   153k|    bool is_clipped = !ItemAdd(bb, id);
  860|   153k|    bool hovered, held;
  861|   153k|    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);
  862|   153k|    if (is_clipped)
  ------------------
  |  Branch (862:9): [True: 0, False: 153k]
  ------------------
  863|      0|        return pressed;
  864|       |
  865|       |    // Render
  866|       |    //bool is_dock_menu = (window->DockNodeAsHost && !window->Collapsed);
  867|   153k|    ImU32 bg_col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
  ------------------
  |  Branch (867:33): [True: 1, False: 153k]
  |  Branch (867:41): [True: 1, False: 0]
  |  Branch (867:76): [True: 227, False: 153k]
  ------------------
  868|   153k|    ImU32 text_col = GetColorU32(ImGuiCol_Text);
  869|   153k|    if (hovered || held)
  ------------------
  |  Branch (869:9): [True: 228, False: 153k]
  |  Branch (869:20): [True: 0, False: 153k]
  ------------------
  870|    228|        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, bg_col);
  871|       |
  872|   153k|    if (dock_node)
  ------------------
  |  Branch (872:9): [True: 0, False: 153k]
  ------------------
  873|      0|        RenderArrowDockMenu(window->DrawList, bb.Min, g.FontSize, text_col);
  874|   153k|    else
  875|   153k|        RenderArrow(window->DrawList, bb.Min, text_col, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);
  ------------------
  |  Branch (875:57): [True: 59.7k, False: 93.6k]
  ------------------
  876|       |
  877|       |    // Switch to moving the window after mouse is moved beyond the initial drag threshold
  878|   153k|    if (IsItemActive() && IsMouseDragging(0))
  ------------------
  |  Branch (878:9): [True: 1, False: 153k]
  |  Branch (878:27): [True: 0, False: 1]
  ------------------
  879|      0|        StartMouseMovingWindowOrNode(window, dock_node, true); // Undock from window/collapse menu button
  880|       |
  881|   153k|    return pressed;
  882|   153k|}
_ZN5ImGui20GetWindowScrollbarIDEP11ImGuiWindow9ImGuiAxis:
  885|  34.6k|{
  886|  34.6k|    return window->GetID(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
  ------------------
  |  Branch (886:26): [True: 16.9k, False: 17.6k]
  ------------------
  887|  34.6k|}
_ZN5ImGui22GetWindowScrollbarRectEP11ImGuiWindow9ImGuiAxis:
  891|  34.6k|{
  892|  34.6k|    const ImRect outer_rect = window->Rect();
  893|  34.6k|    const ImRect inner_rect = window->InnerRect;
  894|  34.6k|    const float border_size = window->WindowBorderSize;
  895|  34.6k|    const float scrollbar_size = window->ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
  896|  34.6k|    IM_ASSERT(scrollbar_size > 0.0f);
  ------------------
  |  |   23|  34.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  897|  34.6k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (897:9): [True: 16.9k, False: 17.6k]
  ------------------
  898|  16.9k|        return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x - border_size, outer_rect.Max.y - border_size);
  899|  17.6k|    else
  900|  17.6k|        return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x - border_size, inner_rect.Max.y - border_size);
  901|  34.6k|}
_ZN5ImGui9ScrollbarE9ImGuiAxis:
  904|  34.6k|{
  905|  34.6k|    ImGuiContext& g = *GImGui;
  906|  34.6k|    ImGuiWindow* window = g.CurrentWindow;
  907|  34.6k|    const ImGuiID id = GetWindowScrollbarID(window, axis);
  908|       |
  909|       |    // Calculate scrollbar bounding box
  910|  34.6k|    ImRect bb = GetWindowScrollbarRect(window, axis);
  911|  34.6k|    ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;
  912|  34.6k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (912:9): [True: 16.9k, False: 17.6k]
  ------------------
  913|  16.9k|    {
  914|  16.9k|        rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;
  915|  16.9k|        if (!window->ScrollbarY)
  ------------------
  |  Branch (915:13): [True: 827, False: 16.1k]
  ------------------
  916|    827|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  917|  16.9k|    }
  918|  17.6k|    else
  919|  17.6k|    {
  920|  17.6k|        if ((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar))
  ------------------
  |  Branch (920:13): [True: 16.1k, False: 1.55k]
  |  Branch (920:62): [True: 16.1k, False: 0]
  ------------------
  921|  16.1k|            rounding_corners |= ImDrawFlags_RoundCornersTopRight;
  922|  17.6k|        if (!window->ScrollbarX)
  ------------------
  |  Branch (922:13): [True: 1.55k, False: 16.1k]
  ------------------
  923|  1.55k|            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
  924|  17.6k|    }
  925|  34.6k|    float size_visible = window->InnerRect.Max[axis] - window->InnerRect.Min[axis];
  926|  34.6k|    float size_contents = window->ContentSize[axis] + window->WindowPadding[axis] * 2.0f;
  927|  34.6k|    ImS64 scroll = (ImS64)window->Scroll[axis];
  928|  34.6k|    ScrollbarEx(bb, id, axis, &scroll, (ImS64)size_visible, (ImS64)size_contents, rounding_corners);
  929|  34.6k|    window->Scroll[axis] = (float)scroll;
  930|  34.6k|}
_ZN5ImGui11ScrollbarExERK6ImRectj9ImGuiAxisPxxxi:
  939|  34.6k|{
  940|  34.6k|    ImGuiContext& g = *GImGui;
  941|  34.6k|    ImGuiWindow* window = g.CurrentWindow;
  942|  34.6k|    if (window->SkipItems)
  ------------------
  |  Branch (942:9): [True: 0, False: 34.6k]
  ------------------
  943|      0|        return false;
  944|       |
  945|  34.6k|    const float bb_frame_width = bb_frame.GetWidth();
  946|  34.6k|    const float bb_frame_height = bb_frame.GetHeight();
  947|  34.6k|    if (bb_frame_width <= 0.0f || bb_frame_height <= 0.0f)
  ------------------
  |  Branch (947:9): [True: 12.1k, False: 22.5k]
  |  Branch (947:35): [True: 12.5k, False: 9.91k]
  ------------------
  948|  24.7k|        return false;
  949|       |
  950|       |    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
  951|  9.91k|    float alpha = 1.0f;
  952|  9.91k|    if ((axis == ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0f)
  ------------------
  |  Branch (952:9): [True: 5.08k, False: 4.82k]
  |  Branch (952:34): [True: 2.90k, False: 2.18k]
  ------------------
  953|  2.90k|        alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));
  954|  9.91k|    if (alpha <= 0.0f)
  ------------------
  |  Branch (954:9): [True: 2.25k, False: 7.65k]
  ------------------
  955|  2.25k|        return false;
  956|       |
  957|  7.65k|    const ImGuiStyle& style = g.Style;
  958|  7.65k|    const bool allow_interaction = (alpha >= 1.0f);
  959|       |
  960|  7.65k|    ImRect bb = bb_frame;
  961|  7.65k|    bb.Expand(ImVec2(-ImClamp(IM_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  287|  7.65k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
                  bb.Expand(ImVec2(-ImClamp(IM_TRUNC((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_TRUNC((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));
  ------------------
  |  |  287|  7.65k|#define IM_TRUNC(_VAL)                  ((float)(int)(_VAL))                                    // ImTrunc() is not inlined in MSVC debug builds
  ------------------
  962|       |
  963|       |    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
  964|  7.65k|    const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();
  ------------------
  |  Branch (964:36): [True: 4.82k, False: 2.82k]
  ------------------
  965|       |
  966|       |    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
  967|       |    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
  968|  7.65k|    IM_ASSERT(ImMax(size_contents_v, size_visible_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
  ------------------
  |  |   23|  7.65k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  ------------------
  969|  7.65k|    const ImS64 win_size_v = ImMax(ImMax(size_contents_v, size_visible_v), (ImS64)1);
  970|  7.65k|    const float grab_h_pixels = ImClamp(scrollbar_size_v * ((float)size_visible_v / (float)win_size_v), style.GrabMinSize, scrollbar_size_v);
  971|  7.65k|    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;
  972|       |
  973|       |    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
  974|  7.65k|    bool held = false;
  975|  7.65k|    bool hovered = false;
  976|  7.65k|    ItemAdd(bb_frame, id, NULL, ImGuiItemFlags_NoNav);
  977|  7.65k|    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);
  978|       |
  979|  7.65k|    const ImS64 scroll_max = ImMax((ImS64)1, size_contents_v - size_visible_v);
  980|  7.65k|    float scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
  981|  7.65k|    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
  982|  7.65k|    if (held && allow_interaction && grab_h_norm < 1.0f)
  ------------------
  |  Branch (982:9): [True: 0, False: 7.65k]
  |  Branch (982:17): [True: 0, False: 0]
  |  Branch (982:38): [True: 0, False: 0]
  ------------------
  983|      0|    {
  984|      0|        const float scrollbar_pos_v = bb.Min[axis];
  985|      0|        const float mouse_pos_v = g.IO.MousePos[axis];
  986|       |
  987|       |        // Click position in scrollbar normalized space (0.0f->1.0f)
  988|      0|        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
  989|       |
  990|      0|        const int held_dir = (clicked_v_norm < grab_v_norm) ? -1 : (clicked_v_norm > grab_v_norm + grab_h_norm) ? +1 : 0;
  ------------------
  |  Branch (990:30): [True: 0, False: 0]
  |  Branch (990:68): [True: 0, False: 0]
  ------------------
  991|      0|        if (g.ActiveIdIsJustActivated)
  ------------------
  |  Branch (991:13): [True: 0, False: 0]
  ------------------
  992|      0|        {
  993|       |            // On initial click calculate the distance between mouse and the center of the grab
  994|      0|            g.ScrollbarSeekMode = (short)held_dir;
  995|      0|            g.ScrollbarClickDeltaToGrabCenter = (g.ScrollbarSeekMode == 0.0f) ? clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f : 0.0f;
  ------------------
  |  Branch (995:49): [True: 0, False: 0]
  ------------------
  996|      0|        }
  997|       |
  998|       |        // Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
  999|       |        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
 1000|      0|        if (g.ScrollbarSeekMode == 0)
  ------------------
  |  Branch (1000:13): [True: 0, False: 0]
  ------------------
 1001|      0|        {
 1002|       |            // Absolute seeking
 1003|      0|            const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
 1004|      0|            *p_scroll_v = (ImS64)(scroll_v_norm * scroll_max);
 1005|      0|        }
 1006|      0|        else
 1007|      0|        {
 1008|       |            // Page by page
 1009|      0|            if (IsMouseClicked(ImGuiMouseButton_Left, ImGuiInputFlags_Repeat) && held_dir == g.ScrollbarSeekMode)
  ------------------
  |  Branch (1009:17): [True: 0, False: 0]
  |  Branch (1009:82): [True: 0, False: 0]
  ------------------
 1010|      0|            {
 1011|      0|                float page_dir = (g.ScrollbarSeekMode > 0.0f) ? +1.0f : -1.0f;
  ------------------
  |  Branch (1011:34): [True: 0, False: 0]
  ------------------
 1012|      0|                *p_scroll_v = ImClamp(*p_scroll_v + (ImS64)(page_dir * size_visible_v), (ImS64)0, scroll_max);
 1013|      0|            }
 1014|      0|        }
 1015|       |
 1016|       |        // Update values for rendering
 1017|      0|        scroll_ratio = ImSaturate((float)*p_scroll_v / (float)scroll_max);
 1018|      0|        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
 1019|       |
 1020|       |        // Update distance to grab now that we have seek'ed and saturated
 1021|       |        //if (seek_absolute)
 1022|       |        //    g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
 1023|      0|    }
 1024|       |
 1025|       |    // Render
 1026|  7.65k|    const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);
 1027|  7.65k|    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
  ------------------
  |  Branch (1027:40): [True: 0, False: 7.65k]
  |  Branch (1027:78): [True: 0, False: 7.65k]
  ------------------
 1028|  7.65k|    window->DrawList->AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window->WindowRounding, flags);
 1029|  7.65k|    ImRect grab_rect;
 1030|  7.65k|    if (axis == ImGuiAxis_X)
  ------------------
  |  Branch (1030:9): [True: 4.82k, False: 2.82k]
  ------------------
 1031|  4.82k|        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);
 1032|  2.82k|    else
 1033|  2.82k|        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
 1034|  7.65k|    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
 1035|       |
 1036|  7.65k|    return held;
 1037|  9.91k|}
_ZN5ImGui5DummyERK6ImVec2:
 1398|  16.9k|{
 1399|  16.9k|    ImGuiWindow* window = GetCurrentWindow();
 1400|  16.9k|    if (window->SkipItems)
  ------------------
  |  Branch (1400:9): [True: 11, False: 16.9k]
  ------------------
 1401|     11|        return;
 1402|       |
 1403|  16.9k|    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
 1404|  16.9k|    ItemSize(size);
 1405|  16.9k|    ItemAdd(bb, 0);
 1406|  16.9k|}
_ZN16ImGuiMenuColumns6UpdateEfb:
 7299|   170k|{
 7300|   170k|    if (window_reappearing)
  ------------------
  |  Branch (7300:9): [True: 4, False: 170k]
  ------------------
 7301|      4|        memset(Widths, 0, sizeof(Widths));
 7302|   170k|    Spacing = (ImU16)spacing;
 7303|   170k|    CalcNextTotalWidth(true);
 7304|   170k|    memset(Widths, 0, sizeof(Widths));
 7305|   170k|    TotalWidth = NextTotalWidth;
 7306|   170k|    NextTotalWidth = 0;
 7307|   170k|}
_ZN16ImGuiMenuColumns18CalcNextTotalWidthEb:
 7310|   170k|{
 7311|   170k|    ImU16 offset = 0;
 7312|   170k|    bool want_spacing = false;
 7313|   851k|    for (int i = 0; i < IM_ARRAYSIZE(Widths); i++)
  ------------------
  |  |   93|   851k|#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR) / sizeof(*(_ARR))))     // Size of a static C-style array. Don't use on pointers!
  ------------------
  |  Branch (7313:21): [True: 681k, False: 170k]
  ------------------
 7314|   681k|    {
 7315|   681k|        ImU16 width = Widths[i];
 7316|   681k|        if (want_spacing && width > 0)
  ------------------
  |  Branch (7316:13): [True: 0, False: 681k]
  |  Branch (7316:29): [True: 0, False: 0]
  ------------------
 7317|      0|            offset += Spacing;
 7318|   681k|        want_spacing |= (width > 0);
 7319|   681k|        if (update_offsets)
  ------------------
  |  Branch (7319:13): [True: 681k, False: 0]
  ------------------
 7320|   681k|        {
 7321|   681k|            if (i == 1) { OffsetLabel = offset; }
  ------------------
  |  Branch (7321:17): [True: 170k, False: 511k]
  ------------------
 7322|   681k|            if (i == 2) { OffsetShortcut = offset; }
  ------------------
  |  Branch (7322:17): [True: 170k, False: 511k]
  ------------------
 7323|   681k|            if (i == 3) { OffsetMark = offset; }
  ------------------
  |  Branch (7323:17): [True: 170k, False: 511k]
  ------------------
 7324|   681k|        }
 7325|   681k|        offset += width;
 7326|   681k|    }
 7327|   170k|    NextTotalWidth = offset;
 7328|   170k|}

imgui_draw.cpp:_ZL17stbrp_init_targetP13stbrp_contextiiP10stbrp_nodei:
  266|      1|{
  267|      1|   int i;
  268|       |
  269|    511|   for (i=0; i < num_nodes-1; ++i)
  ------------------
  |  Branch (269:14): [True: 510, False: 1]
  ------------------
  270|    510|      nodes[i].next = &nodes[i+1];
  271|      1|   nodes[i].next = NULL;
  272|      1|   context->init_mode = STBRP__INIT_skyline;
  273|      1|   context->heuristic = STBRP_HEURISTIC_Skyline_default;
  274|      1|   context->free_head = &nodes[0];
  275|      1|   context->active_head = &context->extra[0];
  276|      1|   context->width = width;
  277|      1|   context->height = height;
  278|      1|   context->num_nodes = num_nodes;
  279|      1|   stbrp_setup_allow_out_of_mem(context, 0);
  280|       |
  281|       |   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
  282|      1|   context->extra[0].x = 0;
  283|      1|   context->extra[0].y = 0;
  284|      1|   context->extra[0].next = &context->extra[1];
  285|      1|   context->extra[1].x = (stbrp_coord) width;
  286|      1|   context->extra[1].y = (1<<30);
  287|      1|   context->extra[1].next = NULL;
  288|      1|}
imgui_draw.cpp:_ZL28stbrp_setup_allow_out_of_memP13stbrp_contexti:
  246|      1|{
  247|      1|   if (allow_out_of_mem)
  ------------------
  |  Branch (247:8): [True: 0, False: 1]
  ------------------
  248|       |      // if it's ok to run out of memory, then don't bother aligning them;
  249|       |      // this gives better packing, but may fail due to OOM (even though
  250|       |      // the rectangles easily fit). @TODO a smarter approach would be to only
  251|       |      // quantize once we've hit OOM, then we could get rid of this parameter.
  252|      0|      context->align = 1;
  253|      1|   else {
  254|       |      // if it's not ok to run out of memory, then quantize the widths
  255|       |      // so that num_nodes is always enough nodes.
  256|       |      //
  257|       |      // I.e. num_nodes * align >= width
  258|       |      //                  align >= width / num_nodes
  259|       |      //                  align = ceil(width/num_nodes)
  260|       |
  261|      1|      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
  262|      1|   }
  263|      1|}
imgui_draw.cpp:_ZL16stbrp_pack_rectsP13stbrp_contextP10stbrp_recti:
  547|      2|{
  548|      2|   int i, all_rects_packed = 1;
  549|       |
  550|       |   // we use the 'was_packed' field internally to allow sorting/unsorting
  551|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (551:14): [True: 225, False: 2]
  ------------------
  552|    225|      rects[i].was_packed = i;
  553|    225|   }
  554|       |
  555|       |   // sort according to heuristic
  556|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);
  ------------------
  |  |  120|      2|#define STBRP_SORT          ImQsort
  ------------------
  557|       |
  558|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (558:14): [True: 225, False: 2]
  ------------------
  559|    225|      if (rects[i].w == 0 || rects[i].h == 0) {
  ------------------
  |  Branch (559:11): [True: 0, False: 225]
  |  Branch (559:30): [True: 0, False: 225]
  ------------------
  560|      0|         rects[i].x = rects[i].y = 0;  // empty rect needs no space
  561|    225|      } else {
  562|    225|         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
  563|    225|         if (fr.prev_link) {
  ------------------
  |  Branch (563:14): [True: 225, False: 0]
  ------------------
  564|    225|            rects[i].x = (stbrp_coord) fr.x;
  565|    225|            rects[i].y = (stbrp_coord) fr.y;
  566|    225|         } else {
  567|      0|            rects[i].x = rects[i].y = STBRP__MAXVAL;
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  568|      0|         }
  569|    225|      }
  570|    225|   }
  571|       |
  572|       |   // unsort
  573|      2|   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);
  ------------------
  |  |  120|      2|#define STBRP_SORT          ImQsort
  ------------------
  574|       |
  575|       |   // set was_packed flags and all_rects_packed status
  576|    227|   for (i=0; i < num_rects; ++i) {
  ------------------
  |  Branch (576:14): [True: 225, False: 2]
  ------------------
  577|    225|      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|    450|#define STBRP__MAXVAL  0x7fffffff
  ------------------
                    rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
  ------------------
  |  |   91|      0|#define STBRP__MAXVAL  0x7fffffff
  ------------------
  |  Branch (577:31): [True: 0, False: 225]
  |  Branch (577:62): [True: 0, False: 0]
  ------------------
  578|    225|      if (!rects[i].was_packed)
  ------------------
  |  Branch (578:11): [True: 0, False: 225]
  ------------------
  579|      0|         all_rects_packed = 0;
  580|    225|   }
  581|       |
  582|       |   // return the all_rects_packed status
  583|      2|   return all_rects_packed;
  584|      2|}
imgui_draw.cpp:_ZL19rect_height_comparePKvS0_:
  529|  1.40k|{
  530|  1.40k|   const stbrp_rect *p = (const stbrp_rect *) a;
  531|  1.40k|   const stbrp_rect *q = (const stbrp_rect *) b;
  532|  1.40k|   if (p->h > q->h)
  ------------------
  |  Branch (532:8): [True: 224, False: 1.17k]
  ------------------
  533|    224|      return -1;
  534|  1.17k|   if (p->h < q->h)
  ------------------
  |  Branch (534:8): [True: 383, False: 795]
  ------------------
  535|    383|      return  1;
  536|    795|   return (p->w > q->w) ? -1 : (p->w < q->w);
  ------------------
  |  Branch (536:11): [True: 97, False: 698]
  ------------------
  537|  1.17k|}
imgui_draw.cpp:_ZL29stbrp__skyline_pack_rectangleP13stbrp_contextii:
  450|    225|{
  451|       |   // find best position according to heuristic
  452|    225|   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
  453|    225|   stbrp_node *node, *cur;
  454|       |
  455|       |   // bail if:
  456|       |   //    1. it failed
  457|       |   //    2. the best node doesn't fit (we don't always check this)
  458|       |   //    3. we're out of memory
  459|    225|   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
  ------------------
  |  Branch (459:8): [True: 0, False: 225]
  |  Branch (459:33): [True: 0, False: 225]
  |  Branch (459:69): [True: 0, False: 225]
  ------------------
  460|      0|      res.prev_link = NULL;
  461|      0|      return res;
  462|      0|   }
  463|       |
  464|       |   // on success, create new node
  465|    225|   node = context->free_head;
  466|    225|   node->x = (stbrp_coord) res.x;
  467|    225|   node->y = (stbrp_coord) (res.y + height);
  468|       |
  469|    225|   context->free_head = node->next;
  470|       |
  471|       |   // insert the new node into the right starting point, and
  472|       |   // let 'cur' point to the remaining nodes needing to be
  473|       |   // stiched back in
  474|       |
  475|    225|   cur = *res.prev_link;
  476|    225|   if (cur->x < res.x) {
  ------------------
  |  Branch (476:8): [True: 0, False: 225]
  ------------------
  477|       |      // preserve the existing one, so start testing with the next one
  478|      0|      stbrp_node *next = cur->next;
  479|      0|      cur->next = node;
  480|      0|      cur = next;
  481|    225|   } else {
  482|    225|      *res.prev_link = node;
  483|    225|   }
  484|       |
  485|       |   // from here, traverse cur and free the nodes, until we get to one
  486|       |   // that shouldn't be freed
  487|    361|   while (cur->next && cur->next->x <= res.x + width) {
  ------------------
  |  Branch (487:11): [True: 358, False: 3]
  |  Branch (487:24): [True: 136, False: 222]
  ------------------
  488|    136|      stbrp_node *next = cur->next;
  489|       |      // move the current node to the free list
  490|    136|      cur->next = context->free_head;
  491|    136|      context->free_head = cur;
  492|    136|      cur = next;
  493|    136|   }
  494|       |
  495|       |   // stitch the list back in
  496|    225|   node->next = cur;
  497|       |
  498|    225|   if (cur->x < res.x + width)
  ------------------
  |  Branch (498:8): [True: 177, False: 48]
  ------------------
  499|    177|      cur->x = (stbrp_coord) (res.x + width);
  500|       |
  501|       |#ifdef _DEBUG
  502|       |   cur = context->active_head;
  503|       |   while (cur->x < context->width) {
  504|       |      STBRP_ASSERT(cur->x < cur->next->x);
  505|       |      cur = cur->next;
  506|       |   }
  507|       |   STBRP_ASSERT(cur->next == NULL);
  508|       |
  509|       |   {
  510|       |      int count=0;
  511|       |      cur = context->active_head;
  512|       |      while (cur) {
  513|       |         cur = cur->next;
  514|       |         ++count;
  515|       |      }
  516|       |      cur = context->free_head;
  517|       |      while (cur) {
  518|       |         cur = cur->next;
  519|       |         ++count;
  520|       |      }
  521|       |      STBRP_ASSERT(count == context->num_nodes+2);
  522|       |   }
  523|       |#endif
  524|       |
  525|    225|   return res;
  526|    225|}
imgui_draw.cpp:_ZL28stbrp__skyline_find_best_posP13stbrp_contextii:
  348|    225|{
  349|    225|   int best_waste = (1<<30), best_x, best_y = (1 << 30);
  350|    225|   stbrp__findresult fr;
  351|    225|   stbrp_node **prev, *node, *tail, **best = NULL;
  352|       |
  353|       |   // align to multiple of c->align
  354|    225|   width = (width + c->align - 1);
  355|    225|   width -= width % c->align;
  356|    225|   STBRP_ASSERT(width % c->align == 0);
  ------------------
  |  |  119|    225|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|    225|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (119:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  357|       |
  358|       |   // if it can't possibly fit, bail immediately
  359|    225|   if (width > c->width || height > c->height) {
  ------------------
  |  Branch (359:8): [True: 0, False: 225]
  |  Branch (359:28): [True: 0, False: 225]
  ------------------
  360|      0|      fr.prev_link = NULL;
  361|      0|      fr.x = fr.y = 0;
  362|      0|      return fr;
  363|      0|   }
  364|       |
  365|    225|   node = c->active_head;
  366|    225|   prev = &c->active_head;
  367|  11.9k|   while (node->x + width <= c->width) {
  ------------------
  |  Branch (367:11): [True: 11.7k, False: 225]
  ------------------
  368|  11.7k|      int y,waste;
  369|  11.7k|      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
  370|  11.7k|      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
  ------------------
  |  Branch (370:11): [True: 11.7k, False: 0]
  ------------------
  371|       |         // bottom left
  372|  11.7k|         if (y < best_y) {
  ------------------
  |  Branch (372:14): [True: 1.03k, False: 10.7k]
  ------------------
  373|  1.03k|            best_y = y;
  374|  1.03k|            best = prev;
  375|  1.03k|         }
  376|  11.7k|      } else {
  377|       |         // best-fit
  378|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (378:14): [True: 0, False: 0]
  ------------------
  379|       |            // can only use it if it first vertically
  380|      0|            if (y < best_y || (y == best_y && waste < best_waste)) {
  ------------------
  |  Branch (380:17): [True: 0, False: 0]
  |  Branch (380:32): [True: 0, False: 0]
  |  Branch (380:47): [True: 0, False: 0]
  ------------------
  381|      0|               best_y = y;
  382|      0|               best_waste = waste;
  383|      0|               best = prev;
  384|      0|            }
  385|      0|         }
  386|      0|      }
  387|  11.7k|      prev = &node->next;
  388|  11.7k|      node = node->next;
  389|  11.7k|   }
  390|       |
  391|    225|   best_x = (best == NULL) ? 0 : (*best)->x;
  ------------------
  |  Branch (391:13): [True: 0, False: 225]
  ------------------
  392|       |
  393|       |   // if doing best-fit (BF), we also have to try aligning right edge to each node position
  394|       |   //
  395|       |   // e.g, if fitting
  396|       |   //
  397|       |   //     ____________________
  398|       |   //    |____________________|
  399|       |   //
  400|       |   //            into
  401|       |   //
  402|       |   //   |                         |
  403|       |   //   |             ____________|
  404|       |   //   |____________|
  405|       |   //
  406|       |   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
  407|       |   //
  408|       |   // This makes BF take about 2x the time
  409|       |
  410|    225|   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
  ------------------
  |  Branch (410:8): [True: 0, False: 225]
  ------------------
  411|      0|      tail = c->active_head;
  412|      0|      node = c->active_head;
  413|      0|      prev = &c->active_head;
  414|       |      // find first node that's admissible
  415|      0|      while (tail->x < width)
  ------------------
  |  Branch (415:14): [True: 0, False: 0]
  ------------------
  416|      0|         tail = tail->next;
  417|      0|      while (tail) {
  ------------------
  |  Branch (417:14): [True: 0, False: 0]
  ------------------
  418|      0|         int xpos = tail->x - width;
  419|      0|         int y,waste;
  420|      0|         STBRP_ASSERT(xpos >= 0);
  ------------------
  |  |  119|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (119:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  421|       |         // find the left position that matches this
  422|      0|         while (node->next->x <= xpos) {
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|            prev = &node->next;
  424|      0|            node = node->next;
  425|      0|         }
  426|      0|         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
  ------------------
  |  |  119|      0|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (119:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  427|      0|         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
  428|      0|         if (y + height <= c->height) {
  ------------------
  |  Branch (428:14): [True: 0, False: 0]
  ------------------
  429|      0|            if (y <= best_y) {
  ------------------
  |  Branch (429:17): [True: 0, False: 0]
  ------------------
  430|      0|               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
  ------------------
  |  Branch (430:20): [True: 0, False: 0]
  |  Branch (430:34): [True: 0, False: 0]
  |  Branch (430:57): [True: 0, False: 0]
  |  Branch (430:78): [True: 0, False: 0]
  ------------------
  431|      0|                  best_x = xpos;
  432|       |                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
  433|      0|                  best_y = y;
  434|      0|                  best_waste = waste;
  435|      0|                  best = prev;
  436|      0|               }
  437|      0|            }
  438|      0|         }
  439|      0|         tail = tail->next;
  440|      0|      }
  441|      0|   }
  442|       |
  443|    225|   fr.prev_link = best;
  444|    225|   fr.x = best_x;
  445|    225|   fr.y = best_y;
  446|    225|   return fr;
  447|    225|}
imgui_draw.cpp:_ZL25stbrp__skyline_find_min_yP13stbrp_contextP10stbrp_nodeiiPi:
  292|  11.7k|{
  293|  11.7k|   stbrp_node *node = first;
  294|  11.7k|   int x1 = x0 + width;
  295|  11.7k|   int min_y, visited_width, waste_area;
  296|       |
  297|  11.7k|   STBRP__NOTUSED(c);
  ------------------
  |  |  224|  11.7k|#define STBRP__NOTUSED(v)  (void)sizeof(v)
  ------------------
  298|       |
  299|  11.7k|   STBRP_ASSERT(first->x <= x0);
  ------------------
  |  |  119|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (119:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  300|       |
  301|       |   #if 0
  302|       |   // skip in case we're past the node
  303|       |   while (node->next->x <= x0)
  304|       |      ++node;
  305|       |   #else
  306|  11.7k|   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
  ------------------
  |  |  119|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (119:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  307|  11.7k|   #endif
  308|       |
  309|  11.7k|   STBRP_ASSERT(node->x <= x0);
  ------------------
  |  |  119|  11.7k|#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
  |  |  ------------------
  |  |  |  |   23|  11.7k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (119:57): [Folded - Ignored]
  |  |  ------------------
  ------------------
  310|       |
  311|  11.7k|   min_y = 0;
  312|  11.7k|   waste_area = 0;
  313|  11.7k|   visited_width = 0;
  314|  26.9k|   while (node->x < x1) {
  ------------------
  |  Branch (314:11): [True: 15.1k, False: 11.7k]
  ------------------
  315|  15.1k|      if (node->y > min_y) {
  ------------------
  |  Branch (315:11): [True: 11.9k, False: 3.19k]
  ------------------
  316|       |         // raise min_y higher.
  317|       |         // we've accounted for all waste up to min_y,
  318|       |         // but we'll now add more waste for everything we've visted
  319|  11.9k|         waste_area += visited_width * (node->y - min_y);
  320|  11.9k|         min_y = node->y;
  321|       |         // the first time through, visited_width might be reduced
  322|  11.9k|         if (node->x < x0)
  ------------------
  |  Branch (322:14): [True: 0, False: 11.9k]
  ------------------
  323|      0|            visited_width += node->next->x - x0;
  324|  11.9k|         else
  325|  11.9k|            visited_width += node->next->x - node->x;
  326|  11.9k|      } else {
  327|       |         // add waste area
  328|  3.19k|         int under_width = node->next->x - node->x;
  329|  3.19k|         if (under_width + visited_width > width)
  ------------------
  |  Branch (329:14): [True: 2.55k, False: 636]
  ------------------
  330|  2.55k|            under_width = width - visited_width;
  331|  3.19k|         waste_area += under_width * (min_y - node->y);
  332|  3.19k|         visited_width += under_width;
  333|  3.19k|      }
  334|  15.1k|      node = node->next;
  335|  15.1k|   }
  336|       |
  337|  11.7k|   *pwaste = waste_area;
  338|  11.7k|   return min_y;
  339|  11.7k|}
imgui_draw.cpp:_ZL19rect_original_orderPKvS0_:
  540|  1.33k|{
  541|  1.33k|   const stbrp_rect *p = (const stbrp_rect *) a;
  542|  1.33k|   const stbrp_rect *q = (const stbrp_rect *) b;
  543|  1.33k|   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
  ------------------
  |  Branch (543:11): [True: 722, False: 616]
  ------------------
  544|  1.33k|}

imgui_draw.cpp:_ZL27stbtt_GetFontOffsetForIndexPKhi:
 4951|      1|{
 4952|      1|   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
 4953|      1|}
imgui_draw.cpp:_ZL36stbtt_GetFontOffsetForIndex_internalPhi:
 1325|      1|{
 1326|       |   // if it's just a font, there's only one valid index
 1327|      1|   if (stbtt__isfont(font_collection))
  ------------------
  |  Branch (1327:8): [True: 1, False: 0]
  ------------------
 1328|      1|      return index == 0 ? 0 : -1;
  ------------------
  |  Branch (1328:14): [True: 1, False: 0]
  ------------------
 1329|       |
 1330|       |   // check if it's a TTC
 1331|      0|   if (stbtt_tag(font_collection, "ttcf")) {
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1332|       |      // version 1?
 1333|      0|      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
  ------------------
  |  Branch (1333:11): [True: 0, False: 0]
  |  Branch (1333:55): [True: 0, False: 0]
  ------------------
 1334|      0|         stbtt_int32 n = ttLONG(font_collection+8);
 1335|      0|         if (index >= n)
  ------------------
  |  Branch (1335:14): [True: 0, False: 0]
  ------------------
 1336|      0|            return -1;
 1337|      0|         return ttULONG(font_collection+12+index*4);
 1338|      0|      }
 1339|      0|   }
 1340|      0|   return -1;
 1341|      0|}
imgui_draw.cpp:_ZL13stbtt__isfontPh:
 1300|      1|{
 1301|       |   // check the version number
 1302|      1|   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1303|      1|   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1304|      1|   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
  ------------------
  |  | 1297|      1|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 1]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1305|      1|   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
  ------------------
  |  | 1296|      1|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  ------------------
  |  |  |  Branch (1296:36): [True: 1, False: 0]
  |  |  |  Branch (1296:54): [True: 1, False: 0]
  |  |  |  Branch (1296:72): [True: 1, False: 0]
  |  |  |  Branch (1296:90): [True: 1, False: 0]
  |  |  ------------------
  ------------------
 1306|      0|   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
  ------------------
  |  | 1297|      0|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|      0|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:54): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:72): [True: 0, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1307|      0|   return 0;
 1308|      0|}
imgui_draw.cpp:_ZL7ttULONGPh:
 1293|      9|static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
imgui_draw.cpp:_ZL14stbtt_InitFontP14stbtt_fontinfoPKhi:
 4961|      1|{
 4962|      1|   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
 4963|      1|}
imgui_draw.cpp:_ZL23stbtt_InitFont_internalP14stbtt_fontinfoPhi:
 1389|      1|{
 1390|      1|   stbtt_uint32 cmap, t;
 1391|      1|   stbtt_int32 i,numTables;
 1392|       |
 1393|      1|   info->data = data;
 1394|      1|   info->fontstart = fontstart;
 1395|      1|   info->cff = stbtt__new_buf(NULL, 0);
 1396|       |
 1397|      1|   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
 1398|      1|   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
 1399|      1|   info->head = stbtt__find_table(data, fontstart, "head"); // required
 1400|      1|   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
 1401|      1|   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
 1402|      1|   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
 1403|      1|   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
 1404|      1|   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required
 1405|       |
 1406|      1|   if (!cmap || !info->head || !info->hhea || !info->hmtx)
  ------------------
  |  Branch (1406:8): [True: 0, False: 1]
  |  Branch (1406:17): [True: 0, False: 1]
  |  Branch (1406:32): [True: 0, False: 1]
  |  Branch (1406:47): [True: 0, False: 1]
  ------------------
 1407|      0|      return 0;
 1408|      1|   if (info->glyf) {
  ------------------
  |  Branch (1408:8): [True: 1, False: 0]
  ------------------
 1409|       |      // required for truetype
 1410|      1|      if (!info->loca) return 0;
  ------------------
  |  Branch (1410:11): [True: 0, False: 1]
  ------------------
 1411|      1|   } else {
 1412|       |      // initialization for CFF / Type2 fonts (OTF)
 1413|      0|      stbtt__buf b, topdict, topdictidx;
 1414|      0|      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
 1415|      0|      stbtt_uint32 cff;
 1416|       |
 1417|      0|      cff = stbtt__find_table(data, fontstart, "CFF ");
 1418|      0|      if (!cff) return 0;
  ------------------
  |  Branch (1418:11): [True: 0, False: 0]
  ------------------
 1419|       |
 1420|      0|      info->fontdicts = stbtt__new_buf(NULL, 0);
 1421|      0|      info->fdselect = stbtt__new_buf(NULL, 0);
 1422|       |
 1423|       |      // @TODO this should use size from table (not 512MB)
 1424|      0|      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
 1425|      0|      b = info->cff;
 1426|       |
 1427|       |      // read the header
 1428|      0|      stbtt__buf_skip(&b, 2);
 1429|      0|      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize
 1430|       |
 1431|       |      // @TODO the name INDEX could list multiple fonts,
 1432|       |      // but we just use the first one.
 1433|      0|      stbtt__cff_get_index(&b);  // name INDEX
 1434|      0|      topdictidx = stbtt__cff_get_index(&b);
 1435|      0|      topdict = stbtt__cff_index_get(topdictidx, 0);
 1436|      0|      stbtt__cff_get_index(&b);  // string INDEX
 1437|      0|      info->gsubrs = stbtt__cff_get_index(&b);
 1438|       |
 1439|      0|      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
 1440|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
 1441|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
 1442|      0|      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
 1443|      0|      info->subrs = stbtt__get_subrs(b, topdict);
 1444|       |
 1445|       |      // we only support Type 2 charstrings
 1446|      0|      if (cstype != 2) return 0;
  ------------------
  |  Branch (1446:11): [True: 0, False: 0]
  ------------------
 1447|      0|      if (charstrings == 0) return 0;
  ------------------
  |  Branch (1447:11): [True: 0, False: 0]
  ------------------
 1448|       |
 1449|      0|      if (fdarrayoff) {
  ------------------
  |  Branch (1449:11): [True: 0, False: 0]
  ------------------
 1450|       |         // looks like a CID font
 1451|      0|         if (!fdselectoff) return 0;
  ------------------
  |  Branch (1451:14): [True: 0, False: 0]
  ------------------
 1452|      0|         stbtt__buf_seek(&b, fdarrayoff);
 1453|      0|         info->fontdicts = stbtt__cff_get_index(&b);
 1454|      0|         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
 1455|      0|      }
 1456|       |
 1457|      0|      stbtt__buf_seek(&b, charstrings);
 1458|      0|      info->charstrings = stbtt__cff_get_index(&b);
 1459|      0|   }
 1460|       |
 1461|      1|   t = stbtt__find_table(data, fontstart, "maxp");
 1462|      1|   if (t)
  ------------------
  |  Branch (1462:8): [True: 1, False: 0]
  ------------------
 1463|      1|      info->numGlyphs = ttUSHORT(data+t+4);
 1464|      0|   else
 1465|      0|      info->numGlyphs = 0xffff;
 1466|       |
 1467|      1|   info->svg = -1;
 1468|       |
 1469|       |   // find a cmap encoding table we understand *now* to avoid searching
 1470|       |   // later. (todo: could make this installable)
 1471|       |   // the same regardless of glyph.
 1472|      1|   numTables = ttUSHORT(data + cmap + 2);
 1473|      1|   info->index_map = 0;
 1474|      4|   for (i=0; i < numTables; ++i) {
  ------------------
  |  Branch (1474:14): [True: 3, False: 1]
  ------------------
 1475|      3|      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
 1476|       |      // find an encoding we understand:
 1477|      3|      switch(ttUSHORT(data+encoding_record)) {
  ------------------
  |  Branch (1477:14): [True: 1, False: 2]
  ------------------
 1478|      1|         case STBTT_PLATFORM_ID_MICROSOFT:
  ------------------
  |  Branch (1478:10): [True: 1, False: 2]
  ------------------
 1479|      1|            switch (ttUSHORT(data+encoding_record+2)) {
  ------------------
  |  Branch (1479:21): [True: 0, False: 1]
  ------------------
 1480|      1|               case STBTT_MS_EID_UNICODE_BMP:
  ------------------
  |  Branch (1480:16): [True: 1, False: 0]
  ------------------
 1481|      1|               case STBTT_MS_EID_UNICODE_FULL:
  ------------------
  |  Branch (1481:16): [True: 0, False: 1]
  ------------------
 1482|       |                  // MS/Unicode
 1483|      1|                  info->index_map = cmap + ttULONG(data+encoding_record+4);
 1484|      1|                  break;
 1485|      1|            }
 1486|      1|            break;
 1487|      1|        case STBTT_PLATFORM_ID_UNICODE:
  ------------------
  |  Branch (1487:9): [True: 1, False: 2]
  ------------------
 1488|       |            // Mac/iOS has these
 1489|       |            // all the encodingIDs are unicode, so we don't bother to check it
 1490|      1|            info->index_map = cmap + ttULONG(data+encoding_record+4);
 1491|      1|            break;
 1492|      3|      }
 1493|      3|   }
 1494|      1|   if (info->index_map == 0)
  ------------------
  |  Branch (1494:8): [True: 0, False: 1]
  ------------------
 1495|      0|      return 0;
 1496|       |
 1497|      1|   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
 1498|      1|   return 1;
 1499|      1|}
imgui_draw.cpp:_ZL14stbtt__new_bufPKvm:
 1174|      1|{
 1175|      1|   stbtt__buf r;
 1176|      1|   STBTT_assert(size < 0x40000000);
  ------------------
  |  |  135|      1|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      1|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1177|      1|   r.data = (stbtt_uint8*) p;
 1178|      1|   r.size = (int) size;
 1179|      1|   r.cursor = 0;
 1180|      1|   return r;
 1181|      1|}
imgui_draw.cpp:_ZL17stbtt__find_tablePhjPKc:
 1312|      9|{
 1313|      9|   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
 1314|      9|   stbtt_uint32 tabledir = fontstart + 12;
 1315|      9|   stbtt_int32 i;
 1316|     67|   for (i=0; i < num_tables; ++i) {
  ------------------
  |  Branch (1316:14): [True: 65, False: 2]
  ------------------
 1317|     65|      stbtt_uint32 loc = tabledir + 16*i;
 1318|     65|      if (stbtt_tag(data+loc+0, tag))
  ------------------
  |  | 1297|     65|#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])
  |  |  ------------------
  |  |  |  | 1296|     65|#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (1296:36): [True: 10, False: 55]
  |  |  |  |  |  Branch (1296:54): [True: 7, False: 3]
  |  |  |  |  |  Branch (1296:72): [True: 7, False: 0]
  |  |  |  |  |  Branch (1296:90): [True: 7, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1319|      7|         return ttULONG(data+loc+8);
 1320|     65|   }
 1321|      2|   return 0;
 1322|      9|}
imgui_draw.cpp:_ZL8ttUSHORTPh:
 1291|  12.9k|static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL20stbtt_FindGlyphIndexPK14stbtt_fontinfoi:
 1502|    670|{
 1503|    670|   stbtt_uint8 *data = info->data;
 1504|    670|   stbtt_uint32 index_map = info->index_map;
 1505|       |
 1506|    670|   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
 1507|    670|   if (format == 0) { // apple byte encoding
  ------------------
  |  Branch (1507:8): [True: 0, False: 670]
  ------------------
 1508|      0|      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
 1509|      0|      if (unicode_codepoint < bytes-6)
  ------------------
  |  Branch (1509:11): [True: 0, False: 0]
  ------------------
 1510|      0|         return ttBYTE(data + index_map + 6 + unicode_codepoint);
  ------------------
  |  | 1287|      0|#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
  ------------------
 1511|      0|      return 0;
 1512|    670|   } else if (format == 6) {
  ------------------
  |  Branch (1512:15): [True: 0, False: 670]
  ------------------
 1513|      0|      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
 1514|      0|      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
 1515|      0|      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
  ------------------
  |  Branch (1515:11): [True: 0, False: 0]
  |  Branch (1515:56): [True: 0, False: 0]
  ------------------
 1516|      0|         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
 1517|      0|      return 0;
 1518|    670|   } else if (format == 2) {
  ------------------
  |  Branch (1518:15): [True: 0, False: 670]
  ------------------
 1519|      0|      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1520|      0|      return 0;
 1521|    670|   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
  ------------------
  |  Branch (1521:15): [True: 670, False: 0]
  ------------------
 1522|    670|      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
 1523|    670|      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
 1524|    670|      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
 1525|    670|      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;
 1526|       |
 1527|       |      // do a binary search of the segments
 1528|    670|      stbtt_uint32 endCount = index_map + 14;
 1529|    670|      stbtt_uint32 search = endCount;
 1530|       |
 1531|    670|      if (unicode_codepoint > 0xffff)
  ------------------
  |  Branch (1531:11): [True: 0, False: 670]
  ------------------
 1532|      0|         return 0;
 1533|       |
 1534|       |      // they lie from endCount .. endCount + segCount
 1535|       |      // but searchRange is the nearest power of two, so...
 1536|    670|      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
  ------------------
  |  Branch (1536:11): [True: 385, False: 285]
  ------------------
 1537|    385|         search += rangeShift*2;
 1538|       |
 1539|       |      // now decrement to bias correctly to find smallest
 1540|    670|      search -= 2;
 1541|  2.01k|      while (entrySelector) {
  ------------------
  |  Branch (1541:14): [True: 1.34k, False: 670]
  ------------------
 1542|  1.34k|         stbtt_uint16 end;
 1543|  1.34k|         searchRange >>= 1;
 1544|  1.34k|         end = ttUSHORT(data + search + searchRange*2);
 1545|  1.34k|         if (unicode_codepoint > end)
  ------------------
  |  Branch (1545:14): [True: 382, False: 958]
  ------------------
 1546|    382|            search += searchRange*2;
 1547|  1.34k|         --entrySelector;
 1548|  1.34k|      }
 1549|    670|      search += 2;
 1550|       |
 1551|    670|      {
 1552|    670|         stbtt_uint16 offset, start, last;
 1553|    670|         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);
 1554|       |
 1555|    670|         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
 1556|    670|         last = ttUSHORT(data + endCount + 2*item);
 1557|    670|         if (unicode_codepoint < start || unicode_codepoint > last)
  ------------------
  |  Branch (1557:14): [True: 1, False: 669]
  |  Branch (1557:43): [True: 0, False: 669]
  ------------------
 1558|      1|            return 0;
 1559|       |
 1560|    669|         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
 1561|    669|         if (offset == 0)
  ------------------
  |  Branch (1561:14): [True: 669, False: 0]
  ------------------
 1562|    669|            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));
 1563|       |
 1564|      0|         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
 1565|    669|      }
 1566|    669|   } else if (format == 12 || format == 13) {
  ------------------
  |  Branch (1566:15): [True: 0, False: 0]
  |  Branch (1566:31): [True: 0, False: 0]
  ------------------
 1567|      0|      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
 1568|      0|      stbtt_int32 low,high;
 1569|      0|      low = 0; high = (stbtt_int32)ngroups;
 1570|       |      // Binary search the right group.
 1571|      0|      while (low < high) {
  ------------------
  |  Branch (1571:14): [True: 0, False: 0]
  ------------------
 1572|      0|         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
 1573|      0|         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
 1574|      0|         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
 1575|      0|         if ((stbtt_uint32) unicode_codepoint < start_char)
  ------------------
  |  Branch (1575:14): [True: 0, False: 0]
  ------------------
 1576|      0|            high = mid;
 1577|      0|         else if ((stbtt_uint32) unicode_codepoint > end_char)
  ------------------
  |  Branch (1577:19): [True: 0, False: 0]
  ------------------
 1578|      0|            low = mid+1;
 1579|      0|         else {
 1580|      0|            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
 1581|      0|            if (format == 12)
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|               return start_glyph + unicode_codepoint-start_char;
 1583|      0|            else // format == 13
 1584|      0|               return start_glyph;
 1585|      0|         }
 1586|      0|      }
 1587|      0|      return 0; // not found
 1588|      0|   }
 1589|       |   // @TODO
 1590|      0|   STBTT_assert(0);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1591|      0|   return 0;
 1592|    670|}
imgui_draw.cpp:_ZL7ttSHORTPh:
 1292|  3.90k|static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
imgui_draw.cpp:_ZL25stbtt_ScaleForPixelHeightPK14stbtt_fontinfof:
 2666|      3|{
 2667|      3|   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
 2668|      3|   return (float) height / fheight;
 2669|      3|}
imgui_draw.cpp:_ZL31stbtt_GetGlyphBitmapBoxSubpixelPK14stbtt_fontinfoiffffPiS2_S2_S2_:
 2727|    669|{
 2728|    669|   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
 2729|    669|   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
  ------------------
  |  Branch (2729:8): [True: 27, False: 642]
  ------------------
 2730|       |      // e.g. space character
 2731|     27|      if (ix0) *ix0 = 0;
  ------------------
  |  Branch (2731:11): [True: 27, False: 0]
  ------------------
 2732|     27|      if (iy0) *iy0 = 0;
  ------------------
  |  Branch (2732:11): [True: 27, False: 0]
  ------------------
 2733|     27|      if (ix1) *ix1 = 0;
  ------------------
  |  Branch (2733:11): [True: 18, False: 9]
  ------------------
 2734|     27|      if (iy1) *iy1 = 0;
  ------------------
  |  Branch (2734:11): [True: 18, False: 9]
  ------------------
 2735|    642|   } else {
 2736|       |      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
 2737|    642|      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
  ------------------
  |  |  140|    642|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
  |  Branch (2737:11): [True: 642, False: 0]
  ------------------
 2738|    642|      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
  ------------------
  |  |  140|    642|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
  |  Branch (2738:11): [True: 642, False: 0]
  ------------------
 2739|    642|      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
  ------------------
  |  |  141|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  459|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2739:11): [True: 428, False: 214]
  ------------------
 2740|    642|      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
  ------------------
  |  |  141|    428|#define STBTT_iceil(x)      ((int)ImCeil(x))
  |  |  ------------------
  |  |  |  |  459|    428|#define ImCeil(X)           ceilf(X)
  |  |  ------------------
  ------------------
  |  Branch (2740:11): [True: 428, False: 214]
  ------------------
 2741|    642|   }
 2742|    669|}
imgui_draw.cpp:_ZL17stbtt_GetGlyphBoxPK14stbtt_fontinfoiPiS2_S2_S2_:
 1631|    669|{
 1632|    669|   if (info->cff.size) {
  ------------------
  |  Branch (1632:8): [True: 0, False: 669]
  ------------------
 1633|      0|      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
 1634|    669|   } else {
 1635|    669|      int g = stbtt__GetGlyfOffset(info, glyph_index);
 1636|    669|      if (g < 0) return 0;
  ------------------
  |  Branch (1636:11): [True: 27, False: 642]
  ------------------
 1637|       |
 1638|    642|      if (x0) *x0 = ttSHORT(info->data + g + 2);
  ------------------
  |  Branch (1638:11): [True: 642, False: 0]
  ------------------
 1639|    642|      if (y0) *y0 = ttSHORT(info->data + g + 4);
  ------------------
  |  Branch (1639:11): [True: 642, False: 0]
  ------------------
 1640|    642|      if (x1) *x1 = ttSHORT(info->data + g + 6);
  ------------------
  |  Branch (1640:11): [True: 642, False: 0]
  ------------------
 1641|    642|      if (y1) *y1 = ttSHORT(info->data + g + 8);
  ------------------
  |  Branch (1641:11): [True: 642, False: 0]
  ------------------
 1642|    642|   }
 1643|    642|   return 1;
 1644|    669|}
imgui_draw.cpp:_ZL15stbtt_setvertexP12stbtt_vertexhiiii:
 1600|  15.8k|{
 1601|  15.8k|   v->type = type;
 1602|  15.8k|   v->x = (stbtt_int16) x;
 1603|  15.8k|   v->y = (stbtt_int16) y;
 1604|  15.8k|   v->cx = (stbtt_int16) cx;
 1605|  15.8k|   v->cy = (stbtt_int16) cy;
 1606|  15.8k|}
imgui_draw.cpp:_ZL20stbtt__GetGlyfOffsetPK14stbtt_fontinfoi:
 1609|    892|{
 1610|    892|   int g1,g2;
 1611|       |
 1612|    892|   STBTT_assert(!info->cff.size);
  ------------------
  |  |  135|    892|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|    892|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1613|       |
 1614|    892|   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
  ------------------
  |  Branch (1614:8): [True: 0, False: 892]
  ------------------
 1615|    892|   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format
  ------------------
  |  Branch (1615:8): [True: 0, False: 892]
  ------------------
 1616|       |
 1617|    892|   if (info->indexToLocFormat == 0) {
  ------------------
  |  Branch (1617:8): [True: 892, False: 0]
  ------------------
 1618|    892|      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
 1619|    892|      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
 1620|    892|   } else {
 1621|      0|      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
 1622|      0|      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
 1623|      0|   }
 1624|       |
 1625|    892|   return g1==g2 ? -1 : g1; // if length is 0, return -1
  ------------------
  |  Branch (1625:11): [True: 36, False: 856]
  ------------------
 1626|    892|}
imgui_draw.cpp:_ZL15stbtt_PackBeginP18stbtt_pack_contextPhiiiiPv:
 3966|      1|{
 3967|      1|   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
  ------------------
  |  |  133|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3968|      1|   int            num_nodes = pw - padding;
 3969|      1|   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);
  ------------------
  |  |  133|      1|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|      1|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3970|       |
 3971|      1|   if (context == NULL || nodes == NULL) {
  ------------------
  |  Branch (3971:8): [True: 0, False: 1]
  |  Branch (3971:27): [True: 0, False: 1]
  ------------------
 3972|      0|      if (context != NULL) STBTT_free(context, alloc_context);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3972:11): [True: 0, False: 0]
  ------------------
 3973|      0|      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (3973:11): [True: 0, False: 0]
  ------------------
 3974|      0|      return 0;
 3975|      0|   }
 3976|       |
 3977|      1|   spc->user_allocator_context = alloc_context;
 3978|      1|   spc->width = pw;
 3979|      1|   spc->height = ph;
 3980|      1|   spc->pixels = pixels;
 3981|      1|   spc->pack_info = context;
 3982|      1|   spc->nodes = nodes;
 3983|      1|   spc->padding = padding;
 3984|      1|   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
  ------------------
  |  Branch (3984:27): [True: 0, False: 1]
  ------------------
 3985|      1|   spc->h_oversample = 1;
 3986|      1|   spc->v_oversample = 1;
 3987|      1|   spc->skip_missing = 0;
 3988|       |
 3989|      1|   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);
 3990|       |
 3991|      1|   if (pixels)
  ------------------
  |  Branch (3991:8): [True: 0, False: 1]
  ------------------
 3992|      0|      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
  ------------------
  |  |  493|      0|   #define STBTT_memset       memset
  ------------------
 3993|       |
 3994|      1|   return 1;
 3995|      1|}
imgui_draw.cpp:_ZL35stbtt_PackFontRangesRenderIntoRectsP18stbtt_pack_contextPK14stbtt_fontinfoP16stbtt_pack_rangeiP10stbrp_rect:
 4217|      1|{
 4218|      1|   int i,j,k, missing_glyph = -1, return_value = 1;
 4219|       |
 4220|       |   // save current values
 4221|      1|   int old_h_over = spc->h_oversample;
 4222|      1|   int old_v_over = spc->v_oversample;
 4223|       |
 4224|      1|   k = 0;
 4225|      2|   for (i=0; i < num_ranges; ++i) {
  ------------------
  |  Branch (4225:14): [True: 1, False: 1]
  ------------------
 4226|      1|      float fh = ranges[i].font_size;
 4227|      1|      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
  ------------------
  |  Branch (4227:21): [True: 1, False: 0]
  ------------------
 4228|      1|      float recip_h,recip_v,sub_x,sub_y;
 4229|      1|      spc->h_oversample = ranges[i].h_oversample;
 4230|      1|      spc->v_oversample = ranges[i].v_oversample;
 4231|      1|      recip_h = 1.0f / spc->h_oversample;
 4232|      1|      recip_v = 1.0f / spc->v_oversample;
 4233|      1|      sub_x = stbtt__oversample_shift(spc->h_oversample);
 4234|      1|      sub_y = stbtt__oversample_shift(spc->v_oversample);
 4235|    224|      for (j=0; j < ranges[i].num_chars; ++j) {
  ------------------
  |  Branch (4235:17): [True: 223, False: 1]
  ------------------
 4236|    223|         stbrp_rect *r = &rects[k];
 4237|    223|         if (r->was_packed && r->w != 0 && r->h != 0) {
  ------------------
  |  Branch (4237:14): [True: 223, False: 0]
  |  Branch (4237:31): [True: 223, False: 0]
  |  Branch (4237:44): [True: 223, False: 0]
  ------------------
 4238|    223|            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
 4239|    223|            int advance, lsb, x0,y0,x1,y1;
 4240|    223|            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
  ------------------
  |  Branch (4240:29): [True: 0, False: 223]
  ------------------
 4241|    223|            int glyph = stbtt_FindGlyphIndex(info, codepoint);
 4242|    223|            stbrp_coord pad = (stbrp_coord) spc->padding;
 4243|       |
 4244|       |            // pad on left and top
 4245|    223|            r->x += pad;
 4246|    223|            r->y += pad;
 4247|    223|            r->w -= pad;
 4248|    223|            r->h -= pad;
 4249|    223|            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
 4250|    223|            stbtt_GetGlyphBitmapBox(info, glyph,
 4251|    223|                                    scale * spc->h_oversample,
 4252|    223|                                    scale * spc->v_oversample,
 4253|    223|                                    &x0,&y0,&x1,&y1);
 4254|    223|            stbtt_MakeGlyphBitmapSubpixel(info,
 4255|    223|                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4256|    223|                                          r->w - spc->h_oversample+1,
 4257|    223|                                          r->h - spc->v_oversample+1,
 4258|    223|                                          spc->stride_in_bytes,
 4259|    223|                                          scale * spc->h_oversample,
 4260|    223|                                          scale * spc->v_oversample,
 4261|    223|                                          0,0,
 4262|    223|                                          glyph);
 4263|       |
 4264|    223|            if (spc->h_oversample > 1)
  ------------------
  |  Branch (4264:17): [True: 0, False: 223]
  ------------------
 4265|      0|               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4266|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4267|      0|                                  spc->h_oversample);
 4268|       |
 4269|    223|            if (spc->v_oversample > 1)
  ------------------
  |  Branch (4269:17): [True: 0, False: 223]
  ------------------
 4270|      0|               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
 4271|      0|                                  r->w, r->h, spc->stride_in_bytes,
 4272|      0|                                  spc->v_oversample);
 4273|       |
 4274|    223|            bc->x0       = (stbtt_int16)  r->x;
 4275|    223|            bc->y0       = (stbtt_int16)  r->y;
 4276|    223|            bc->x1       = (stbtt_int16) (r->x + r->w);
 4277|    223|            bc->y1       = (stbtt_int16) (r->y + r->h);
 4278|    223|            bc->xadvance =                scale * advance;
 4279|    223|            bc->xoff     =       (float)  x0 * recip_h + sub_x;
 4280|    223|            bc->yoff     =       (float)  y0 * recip_v + sub_y;
 4281|    223|            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
 4282|    223|            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
 4283|       |
 4284|    223|            if (glyph == 0)
  ------------------
  |  Branch (4284:17): [True: 0, False: 223]
  ------------------
 4285|      0|               missing_glyph = j;
 4286|    223|         } else if (spc->skip_missing) {
  ------------------
  |  Branch (4286:21): [True: 0, False: 0]
  ------------------
 4287|      0|            return_value = 0;
 4288|      0|         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
  ------------------
  |  Branch (4288:21): [True: 0, False: 0]
  |  Branch (4288:38): [True: 0, False: 0]
  |  Branch (4288:51): [True: 0, False: 0]
  |  Branch (4288:64): [True: 0, False: 0]
  ------------------
 4289|      0|            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
 4290|      0|         } else {
 4291|      0|            return_value = 0; // if any fail, report failure
 4292|      0|         }
 4293|       |
 4294|    223|         ++k;
 4295|    223|      }
 4296|      1|   }
 4297|       |
 4298|       |   // restore original values
 4299|      1|   spc->h_oversample = old_h_over;
 4300|      1|   spc->v_oversample = old_v_over;
 4301|       |
 4302|      1|   return return_value;
 4303|      1|}
imgui_draw.cpp:_ZL23stbtt__oversample_shifti:
 4145|      2|{
 4146|      2|   if (!oversample)
  ------------------
  |  Branch (4146:8): [True: 0, False: 2]
  ------------------
 4147|      0|      return 0.0f;
 4148|       |
 4149|       |   // The prefilter is a box filter of width "oversample",
 4150|       |   // which shifts phase by (oversample - 1)/2 pixels in
 4151|       |   // oversampled space. We want to shift in the opposite
 4152|       |   // direction to counter this.
 4153|      2|   return (float)-(oversample - 1) / (2.0f * (float)oversample);
 4154|      2|}
imgui_draw.cpp:_ZL22stbtt_GetGlyphHMetricsPK14stbtt_fontinfoiPiS2_:
 2311|    223|{
 2312|    223|   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
 2313|    223|   if (glyph_index < numOfLongHorMetrics) {
  ------------------
  |  Branch (2313:8): [True: 0, False: 223]
  ------------------
 2314|      0|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
  ------------------
  |  Branch (2314:11): [True: 0, False: 0]
  ------------------
 2315|      0|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
  ------------------
  |  Branch (2315:11): [True: 0, False: 0]
  ------------------
 2316|    223|   } else {
 2317|    223|      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
  ------------------
  |  Branch (2317:11): [True: 223, False: 0]
  ------------------
 2318|    223|      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
  ------------------
  |  Branch (2318:11): [True: 223, False: 0]
  ------------------
 2319|    223|   }
 2320|    223|}
imgui_draw.cpp:_ZL23stbtt_GetGlyphBitmapBoxPK14stbtt_fontinfoiffPiS2_S2_S2_:
 2745|    223|{
 2746|    223|   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
 2747|    223|}
imgui_draw.cpp:_ZL29stbtt_MakeGlyphBitmapSubpixelPK14stbtt_fontinfoPhiiiffffi:
 3767|    223|{
 3768|    223|   int ix0,iy0;
 3769|    223|   stbtt_vertex *vertices;
 3770|    223|   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
 3771|    223|   stbtt__bitmap gbm;
 3772|       |
 3773|    223|   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
 3774|    223|   gbm.pixels = output;
 3775|    223|   gbm.w = out_w;
 3776|    223|   gbm.h = out_h;
 3777|    223|   gbm.stride = out_stride;
 3778|       |
 3779|    223|   if (gbm.w && gbm.h)
  ------------------
  |  Branch (3779:8): [True: 214, False: 9]
  |  Branch (3779:17): [True: 214, False: 0]
  ------------------
 3780|    214|      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);
 3781|       |
 3782|    223|   STBTT_free(vertices, info->userdata);
  ------------------
  |  |  134|    223|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|    223|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3783|    223|}
imgui_draw.cpp:_ZL19stbtt_GetGlyphShapePK14stbtt_fontinfoiPP12stbtt_vertex:
 2303|    223|{
 2304|    223|   if (!info->cff.size)
  ------------------
  |  Branch (2304:8): [True: 223, False: 0]
  ------------------
 2305|    223|      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
 2306|      0|   else
 2307|      0|      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
 2308|    223|}
imgui_draw.cpp:_ZL22stbtt__GetGlyphShapeTTPK14stbtt_fontinfoiPP12stbtt_vertex:
 1680|    223|{
 1681|    223|   stbtt_int16 numberOfContours;
 1682|    223|   stbtt_uint8 *endPtsOfContours;
 1683|    223|   stbtt_uint8 *data = info->data;
 1684|    223|   stbtt_vertex *vertices=0;
 1685|    223|   int num_vertices=0;
 1686|    223|   int g = stbtt__GetGlyfOffset(info, glyph_index);
 1687|       |
 1688|    223|   *pvertices = NULL;
 1689|       |
 1690|    223|   if (g < 0) return 0;
  ------------------
  |  Branch (1690:8): [True: 9, False: 214]
  ------------------
 1691|       |
 1692|    214|   numberOfContours = ttSHORT(data + g);
 1693|       |
 1694|    214|   if (numberOfContours > 0) {
  ------------------
  |  Branch (1694:8): [True: 214, False: 0]
  ------------------
 1695|    214|      stbtt_uint8 flags=0,flagcount;
 1696|    214|      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
 1697|    214|      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
 1698|    214|      stbtt_uint8 *points;
 1699|    214|      endPtsOfContours = (data + g + 10);
 1700|    214|      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
 1701|    214|      points = data + g + 10 + numberOfContours * 2 + 2 + ins;
 1702|       |
 1703|    214|      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);
 1704|       |
 1705|    214|      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
 1706|    214|      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
  ------------------
  |  |  133|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1707|    214|      if (vertices == 0)
  ------------------
  |  Branch (1707:11): [True: 0, False: 214]
  ------------------
 1708|      0|         return 0;
 1709|       |
 1710|    214|      next_move = 0;
 1711|    214|      flagcount=0;
 1712|       |
 1713|       |      // in first pass, we load uninterpreted data into the allocated array
 1714|       |      // above, shifted to the end of the array so we won't overwrite it when
 1715|       |      // we create our final data starting from the front
 1716|       |
 1717|    214|      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
 1718|       |
 1719|       |      // first load flags
 1720|       |
 1721|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1721:17): [True: 12.6k, False: 214]
  ------------------
 1722|  12.6k|         if (flagcount == 0) {
  ------------------
  |  Branch (1722:14): [True: 12.5k, False: 63]
  ------------------
 1723|  12.5k|            flags = *points++;
 1724|  12.5k|            if (flags & 8)
  ------------------
  |  Branch (1724:17): [True: 63, False: 12.5k]
  ------------------
 1725|     63|               flagcount = *points++;
 1726|  12.5k|         } else
 1727|     63|            --flagcount;
 1728|  12.6k|         vertices[off+i].type = flags;
 1729|  12.6k|      }
 1730|       |
 1731|       |      // now load x coordinates
 1732|    214|      x=0;
 1733|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1733:17): [True: 12.6k, False: 214]
  ------------------
 1734|  12.6k|         flags = vertices[off+i].type;
 1735|  12.6k|         if (flags & 2) {
  ------------------
  |  Branch (1735:14): [True: 3.76k, False: 8.87k]
  ------------------
 1736|  3.76k|            stbtt_int16 dx = *points++;
 1737|  3.76k|            x += (flags & 16) ? dx : -dx; // ???
  ------------------
  |  Branch (1737:18): [True: 3.41k, False: 350]
  ------------------
 1738|  8.87k|         } else {
 1739|  8.87k|            if (!(flags & 16)) {
  ------------------
  |  Branch (1739:17): [True: 1.56k, False: 7.30k]
  ------------------
 1740|  1.56k|               x = x + (stbtt_int16) (points[0]*256 + points[1]);
 1741|  1.56k|               points += 2;
 1742|  1.56k|            }
 1743|  8.87k|         }
 1744|  12.6k|         vertices[off+i].x = (stbtt_int16) x;
 1745|  12.6k|      }
 1746|       |
 1747|       |      // now load y coordinates
 1748|    214|      y=0;
 1749|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1749:17): [True: 12.6k, False: 214]
  ------------------
 1750|  12.6k|         flags = vertices[off+i].type;
 1751|  12.6k|         if (flags & 4) {
  ------------------
  |  Branch (1751:14): [True: 7.59k, False: 5.04k]
  ------------------
 1752|  7.59k|            stbtt_int16 dy = *points++;
 1753|  7.59k|            y += (flags & 32) ? dy : -dy; // ???
  ------------------
  |  Branch (1753:18): [True: 3.16k, False: 4.43k]
  ------------------
 1754|  7.59k|         } else {
 1755|  5.04k|            if (!(flags & 32)) {
  ------------------
  |  Branch (1755:17): [True: 273, False: 4.77k]
  ------------------
 1756|    273|               y = y + (stbtt_int16) (points[0]*256 + points[1]);
 1757|    273|               points += 2;
 1758|    273|            }
 1759|  5.04k|         }
 1760|  12.6k|         vertices[off+i].y = (stbtt_int16) y;
 1761|  12.6k|      }
 1762|       |
 1763|       |      // now convert them to our format
 1764|    214|      num_vertices=0;
 1765|    214|      sx = sy = cx = cy = scx = scy = 0;
 1766|  12.8k|      for (i=0; i < n; ++i) {
  ------------------
  |  Branch (1766:17): [True: 12.6k, False: 214]
  ------------------
 1767|  12.6k|         flags = vertices[off+i].type;
 1768|  12.6k|         x     = (stbtt_int16) vertices[off+i].x;
 1769|  12.6k|         y     = (stbtt_int16) vertices[off+i].y;
 1770|       |
 1771|  12.6k|         if (next_move == i) {
  ------------------
  |  Branch (1771:14): [True: 3.16k, False: 9.48k]
  ------------------
 1772|  3.16k|            if (i != 0)
  ------------------
  |  Branch (1772:17): [True: 2.94k, False: 214]
  ------------------
 1773|  2.94k|               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1774|       |
 1775|       |            // now start the new one
 1776|  3.16k|            start_off = !(flags & 1);
 1777|  3.16k|            if (start_off) {
  ------------------
  |  Branch (1777:17): [True: 0, False: 3.16k]
  ------------------
 1778|       |               // if we start off with an off-curve point, then when we need to find a point on the curve
 1779|       |               // where we can start, and we need to save some state for when we wraparound.
 1780|      0|               scx = x;
 1781|      0|               scy = y;
 1782|      0|               if (!(vertices[off+i+1].type & 1)) {
  ------------------
  |  Branch (1782:20): [True: 0, False: 0]
  ------------------
 1783|       |                  // next point is also a curve point, so interpolate an on-point curve
 1784|      0|                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
 1785|      0|                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
 1786|      0|               } else {
 1787|       |                  // otherwise just use the next point as our start point
 1788|      0|                  sx = (stbtt_int32) vertices[off+i+1].x;
 1789|      0|                  sy = (stbtt_int32) vertices[off+i+1].y;
 1790|      0|                  ++i; // we're using point i+1 as the starting point, so skip it
 1791|      0|               }
 1792|  3.16k|            } else {
 1793|  3.16k|               sx = x;
 1794|  3.16k|               sy = y;
 1795|  3.16k|            }
 1796|  3.16k|            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
 1797|  3.16k|            was_off = 0;
 1798|  3.16k|            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
 1799|  3.16k|            ++j;
 1800|  9.48k|         } else {
 1801|  9.48k|            if (!(flags & 1)) { // if it's a curve
  ------------------
  |  Branch (1801:17): [True: 0, False: 9.48k]
  ------------------
 1802|      0|               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
  ------------------
  |  Branch (1802:20): [True: 0, False: 0]
  ------------------
 1803|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
 1804|      0|               cx = x;
 1805|      0|               cy = y;
 1806|      0|               was_off = 1;
 1807|  9.48k|            } else {
 1808|  9.48k|               if (was_off)
  ------------------
  |  Branch (1808:20): [True: 0, False: 9.48k]
  ------------------
 1809|      0|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
 1810|  9.48k|               else
 1811|  9.48k|                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
 1812|  9.48k|               was_off = 0;
 1813|  9.48k|            }
 1814|  9.48k|         }
 1815|  12.6k|      }
 1816|    214|      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
 1817|    214|   } else if (numberOfContours < 0) {
  ------------------
  |  Branch (1817:15): [True: 0, False: 0]
  ------------------
 1818|       |      // Compound shapes.
 1819|      0|      int more = 1;
 1820|      0|      stbtt_uint8 *comp = data + g + 10;
 1821|      0|      num_vertices = 0;
 1822|      0|      vertices = 0;
 1823|      0|      while (more) {
  ------------------
  |  Branch (1823:14): [True: 0, False: 0]
  ------------------
 1824|      0|         stbtt_uint16 flags, gidx;
 1825|      0|         int comp_num_verts = 0, i;
 1826|      0|         stbtt_vertex *comp_verts = 0, *tmp = 0;
 1827|      0|         float mtx[6] = {1,0,0,1,0,0}, m, n;
 1828|       |
 1829|      0|         flags = ttSHORT(comp); comp+=2;
 1830|      0|         gidx = ttSHORT(comp); comp+=2;
 1831|       |
 1832|      0|         if (flags & 2) { // XY values
  ------------------
  |  Branch (1832:14): [True: 0, False: 0]
  ------------------
 1833|      0|            if (flags & 1) { // shorts
  ------------------
  |  Branch (1833:17): [True: 0, False: 0]
  ------------------
 1834|      0|               mtx[4] = ttSHORT(comp); comp+=2;
 1835|      0|               mtx[5] = ttSHORT(comp); comp+=2;
 1836|      0|            } else {
 1837|      0|               mtx[4] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1838|      0|               mtx[5] = ttCHAR(comp); comp+=1;
  ------------------
  |  | 1288|      0|#define ttCHAR(p)     (* (stbtt_int8 *) (p))
  ------------------
 1839|      0|            }
 1840|      0|         }
 1841|      0|         else {
 1842|       |            // @TODO handle matching point
 1843|      0|            STBTT_assert(0);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 1844|      0|         }
 1845|      0|         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
  ------------------
  |  Branch (1845:14): [True: 0, False: 0]
  ------------------
 1846|      0|            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1847|      0|            mtx[1] = mtx[2] = 0;
 1848|      0|         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
  ------------------
  |  Branch (1848:21): [True: 0, False: 0]
  ------------------
 1849|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1850|      0|            mtx[1] = mtx[2] = 0;
 1851|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1852|      0|         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
  ------------------
  |  Branch (1852:21): [True: 0, False: 0]
  ------------------
 1853|      0|            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
 1854|      0|            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
 1855|      0|            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
 1856|      0|            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
 1857|      0|         }
 1858|       |
 1859|       |         // Find transformation scales.
 1860|      0|         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
  ------------------
  |  |  137|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  452|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1861|      0|         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);
  ------------------
  |  |  137|      0|#define STBTT_sqrt(x)       ImSqrt(x)
  |  |  ------------------
  |  |  |  |  452|      0|#define ImSqrt(X)           sqrtf(X)
  |  |  ------------------
  ------------------
 1862|       |
 1863|       |         // Get indexed glyph.
 1864|      0|         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
 1865|      0|         if (comp_num_verts > 0) {
  ------------------
  |  Branch (1865:14): [True: 0, False: 0]
  ------------------
 1866|       |            // Transform vertices.
 1867|      0|            for (i = 0; i < comp_num_verts; ++i) {
  ------------------
  |  Branch (1867:25): [True: 0, False: 0]
  ------------------
 1868|      0|               stbtt_vertex* v = &comp_verts[i];
 1869|      0|               stbtt_vertex_type x,y;
  ------------------
  |  |  839|      0|   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
  ------------------
 1870|      0|               x=v->x; y=v->y;
 1871|      0|               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1872|      0|               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1873|      0|               x=v->cx; y=v->cy;
 1874|      0|               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
 1875|      0|               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
 1876|      0|            }
 1877|       |            // Append vertices.
 1878|      0|            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
  ------------------
  |  |  133|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 1879|      0|            if (!tmp) {
  ------------------
  |  Branch (1879:17): [True: 0, False: 0]
  ------------------
 1880|      0|               if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1880:20): [True: 0, False: 0]
  ------------------
 1881|      0|               if (comp_verts) STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1881:20): [True: 0, False: 0]
  ------------------
 1882|      0|               return 0;
 1883|      0|            }
 1884|      0|            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
  |  Branch (1884:17): [True: 0, False: 0]
  |  Branch (1884:37): [True: 0, False: 0]
  ------------------
 1885|      0|            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
  ------------------
  |  |  492|      0|   #define STBTT_memcpy       memcpy
  ------------------
 1886|      0|            if (vertices) STBTT_free(vertices, info->userdata);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
  |  Branch (1886:17): [True: 0, False: 0]
  ------------------
 1887|      0|            vertices = tmp;
 1888|      0|            STBTT_free(comp_verts, info->userdata);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 1889|      0|            num_vertices += comp_num_verts;
 1890|      0|         }
 1891|       |         // More components ?
 1892|      0|         more = flags & (1<<5);
 1893|      0|      }
 1894|      0|   } else {
 1895|       |      // numberOfCounters == 0, do nothing
 1896|      0|   }
 1897|       |
 1898|    214|   *pvertices = vertices;
 1899|    214|   return num_vertices;
 1900|    214|}
imgui_draw.cpp:_ZL18stbtt__close_shapeP12stbtt_vertexiiiiiiiii:
 1665|  3.16k|{
 1666|  3.16k|   if (start_off) {
  ------------------
  |  Branch (1666:8): [True: 0, False: 3.16k]
  ------------------
 1667|      0|      if (was_off)
  ------------------
  |  Branch (1667:11): [True: 0, False: 0]
  ------------------
 1668|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
 1669|      0|      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
 1670|  3.16k|   } else {
 1671|  3.16k|      if (was_off)
  ------------------
  |  Branch (1671:11): [True: 0, False: 3.16k]
  ------------------
 1672|      0|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
 1673|  3.16k|      else
 1674|  3.16k|         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
 1675|  3.16k|   }
 1676|  3.16k|   return num_vertices;
 1677|  3.16k|}
imgui_draw.cpp:_ZL15stbtt_RasterizeP13stbtt__bitmapfP12stbtt_vertexiffffiiiPv:
 3704|    214|{
 3705|    214|   float scale            = scale_x > scale_y ? scale_y : scale_x;
  ------------------
  |  Branch (3705:29): [True: 0, False: 214]
  ------------------
 3706|    214|   int winding_count      = 0;
 3707|    214|   int *winding_lengths   = NULL;
 3708|    214|   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
 3709|    214|   if (windings) {
  ------------------
  |  Branch (3709:8): [True: 214, False: 0]
  ------------------
 3710|    214|      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
 3711|    214|      STBTT_free(winding_lengths, userdata);
  ------------------
  |  |  134|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3712|    214|      STBTT_free(windings, userdata);
  ------------------
  |  |  134|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3713|    214|   }
 3714|    214|}
imgui_draw.cpp:_ZL19stbtt_FlattenCurvesP12stbtt_vertexifPPiS1_Pv:
 3627|    214|{
 3628|    214|   stbtt__point *points=0;
 3629|    214|   int num_points=0;
 3630|       |
 3631|    214|   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
 3632|    214|   int i,n=0,start=0, pass;
 3633|       |
 3634|       |   // count how many "moves" there are to get the contour count
 3635|  16.0k|   for (i=0; i < num_verts; ++i)
  ------------------
  |  Branch (3635:14): [True: 15.8k, False: 214]
  ------------------
 3636|  15.8k|      if (vertices[i].type == STBTT_vmove)
  ------------------
  |  Branch (3636:11): [True: 3.16k, False: 12.6k]
  ------------------
 3637|  3.16k|         ++n;
 3638|       |
 3639|    214|   *num_contours = n;
 3640|    214|   if (n == 0) return 0;
  ------------------
  |  Branch (3640:8): [True: 0, False: 214]
  ------------------
 3641|       |
 3642|    214|   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);
  ------------------
  |  |  133|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3643|       |
 3644|    214|   if (*contour_lengths == 0) {
  ------------------
  |  Branch (3644:8): [True: 0, False: 214]
  ------------------
 3645|      0|      *num_contours = 0;
 3646|      0|      return 0;
 3647|      0|   }
 3648|       |
 3649|       |   // make two passes through the points so we don't need to realloc
 3650|    642|   for (pass=0; pass < 2; ++pass) {
  ------------------
  |  Branch (3650:17): [True: 428, False: 214]
  ------------------
 3651|    428|      float x=0,y=0;
 3652|    428|      if (pass == 1) {
  ------------------
  |  Branch (3652:11): [True: 214, False: 214]
  ------------------
 3653|    214|         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
  ------------------
  |  |  133|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3654|    214|         if (points == NULL) goto error;
  ------------------
  |  Branch (3654:14): [True: 0, False: 214]
  ------------------
 3655|    214|      }
 3656|    428|      num_points = 0;
 3657|    428|      n= -1;
 3658|  32.0k|      for (i=0; i < num_verts; ++i) {
  ------------------
  |  Branch (3658:17): [True: 31.6k, False: 428]
  ------------------
 3659|  31.6k|         switch (vertices[i].type) {
  ------------------
  |  Branch (3659:18): [True: 0, False: 31.6k]
  ------------------
 3660|  6.32k|            case STBTT_vmove:
  ------------------
  |  Branch (3660:13): [True: 6.32k, False: 25.2k]
  ------------------
 3661|       |               // start the next contour
 3662|  6.32k|               if (n >= 0)
  ------------------
  |  Branch (3662:20): [True: 5.89k, False: 428]
  ------------------
 3663|  5.89k|                  (*contour_lengths)[n] = num_points - start;
 3664|  6.32k|               ++n;
 3665|  6.32k|               start = num_points;
 3666|       |
 3667|  6.32k|               x = vertices[i].x, y = vertices[i].y;
 3668|  6.32k|               stbtt__add_point(points, num_points++, x,y);
 3669|  6.32k|               break;
 3670|  25.2k|            case STBTT_vline:
  ------------------
  |  Branch (3670:13): [True: 25.2k, False: 6.32k]
  ------------------
 3671|  25.2k|               x = vertices[i].x, y = vertices[i].y;
 3672|  25.2k|               stbtt__add_point(points, num_points++, x, y);
 3673|  25.2k|               break;
 3674|      0|            case STBTT_vcurve:
  ------------------
  |  Branch (3674:13): [True: 0, False: 31.6k]
  ------------------
 3675|      0|               stbtt__tesselate_curve(points, &num_points, x,y,
 3676|      0|                                        vertices[i].cx, vertices[i].cy,
 3677|      0|                                        vertices[i].x,  vertices[i].y,
 3678|      0|                                        objspace_flatness_squared, 0);
 3679|      0|               x = vertices[i].x, y = vertices[i].y;
 3680|      0|               break;
 3681|      0|            case STBTT_vcubic:
  ------------------
  |  Branch (3681:13): [True: 0, False: 31.6k]
  ------------------
 3682|      0|               stbtt__tesselate_cubic(points, &num_points, x,y,
 3683|      0|                                        vertices[i].cx, vertices[i].cy,
 3684|      0|                                        vertices[i].cx1, vertices[i].cy1,
 3685|      0|                                        vertices[i].x,  vertices[i].y,
 3686|      0|                                        objspace_flatness_squared, 0);
 3687|      0|               x = vertices[i].x, y = vertices[i].y;
 3688|      0|               break;
 3689|  31.6k|         }
 3690|  31.6k|      }
 3691|    428|      (*contour_lengths)[n] = num_points - start;
 3692|    428|   }
 3693|       |
 3694|    214|   return points;
 3695|      0|error:
 3696|      0|   STBTT_free(points, userdata);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3697|      0|   STBTT_free(*contour_lengths, userdata);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3698|      0|   *contour_lengths = 0;
 3699|      0|   *num_contours = 0;
 3700|      0|   return NULL;
 3701|    214|}
imgui_draw.cpp:_ZL16stbtt__add_pointP12stbtt__pointiff:
 3556|  31.6k|{
 3557|  31.6k|   if (!points) return; // during first pass, it's unallocated
  ------------------
  |  Branch (3557:8): [True: 15.8k, False: 15.8k]
  ------------------
 3558|  15.8k|   points[n].x = x;
 3559|  15.8k|   points[n].y = y;
 3560|  15.8k|}
imgui_draw.cpp:_ZL16stbtt__rasterizeP13stbtt__bitmapP12stbtt__pointPiiffffiiiPv:
 3499|    214|{
 3500|    214|   float y_scale_inv = invert ? -scale_y : scale_y;
  ------------------
  |  Branch (3500:24): [True: 214, False: 0]
  ------------------
 3501|    214|   stbtt__edge *e;
 3502|    214|   int n,i,j,k,m;
 3503|       |#if STBTT_RASTERIZER_VERSION == 1
 3504|       |   int vsubsample = result->h < 8 ? 15 : 5;
 3505|       |#elif STBTT_RASTERIZER_VERSION == 2
 3506|       |   int vsubsample = 1;
 3507|       |#else
 3508|       |   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
 3509|       |#endif
 3510|       |   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
 3511|       |
 3512|       |   // now we have to blow out the windings into explicit edge lists
 3513|    214|   n = 0;
 3514|  3.37k|   for (i=0; i < windings; ++i)
  ------------------
  |  Branch (3514:14): [True: 3.16k, False: 214]
  ------------------
 3515|  3.16k|      n += wcount[i];
 3516|       |
 3517|    214|   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
  ------------------
  |  |  133|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3518|    214|   if (e == 0) return;
  ------------------
  |  Branch (3518:8): [True: 0, False: 214]
  ------------------
 3519|    214|   n = 0;
 3520|       |
 3521|    214|   m=0;
 3522|  3.37k|   for (i=0; i < windings; ++i) {
  ------------------
  |  Branch (3522:14): [True: 3.16k, False: 214]
  ------------------
 3523|  3.16k|      stbtt__point *p = pts + m;
 3524|  3.16k|      m += wcount[i];
 3525|  3.16k|      j = wcount[i]-1;
 3526|  18.9k|      for (k=0; k < wcount[i]; j=k++) {
  ------------------
  |  Branch (3526:17): [True: 15.8k, False: 3.16k]
  ------------------
 3527|  15.8k|         int a=k,b=j;
 3528|       |         // skip the edge if horizontal
 3529|  15.8k|         if (p[j].y == p[k].y)
  ------------------
  |  Branch (3529:14): [True: 9.48k, False: 6.32k]
  ------------------
 3530|  9.48k|            continue;
 3531|       |         // add edge from j to k to the list
 3532|  6.32k|         e[n].invert = 0;
 3533|  6.32k|         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
  ------------------
  |  Branch (3533:14): [True: 6.32k, False: 0]
  |  Branch (3533:14): [True: 3.16k, False: 3.16k]
  ------------------
 3534|  3.16k|            e[n].invert = 1;
 3535|  3.16k|            a=j,b=k;
 3536|  3.16k|         }
 3537|  6.32k|         e[n].x0 = p[a].x * scale_x + shift_x;
 3538|  6.32k|         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
 3539|  6.32k|         e[n].x1 = p[b].x * scale_x + shift_x;
 3540|  6.32k|         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
 3541|  6.32k|         ++n;
 3542|  6.32k|      }
 3543|  3.16k|   }
 3544|       |
 3545|       |   // now sort the edges by their highest point (should snap to integer, and then by x)
 3546|       |   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
 3547|    214|   stbtt__sort_edges(e, n);
 3548|       |
 3549|       |   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
 3550|    214|   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);
 3551|       |
 3552|    214|   STBTT_free(e, userdata);
  ------------------
  |  |  134|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3553|    214|}
imgui_draw.cpp:_ZL17stbtt__sort_edgesP11stbtt__edgei:
 3488|    214|{
 3489|    214|   stbtt__sort_edges_quicksort(p, n);
 3490|    214|   stbtt__sort_edges_ins_sort(p, n);
 3491|    214|}
imgui_draw.cpp:_ZL27stbtt__sort_edges_quicksortP11stbtt__edgei:
 3426|    862|{
 3427|       |   /* threshold for transitioning to insertion sort */
 3428|  1.51k|   while (n > 12) {
  ------------------
  |  Branch (3428:11): [True: 648, False: 862]
  ------------------
 3429|    648|      stbtt__edge t;
 3430|    648|      int c01,c12,c,m,i,j;
 3431|       |
 3432|       |      /* compute median of three */
 3433|    648|      m = n >> 1;
 3434|    648|      c01 = STBTT__COMPARE(&p[0],&p[m]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3435|    648|      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
  ------------------
  |  | 3405|    648|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3436|       |      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
 3437|    648|      if (c01 != c12) {
  ------------------
  |  Branch (3437:11): [True: 249, False: 399]
  ------------------
 3438|       |         /* otherwise, we'll need to swap something else to middle */
 3439|    249|         int z;
 3440|    249|         c = STBTT__COMPARE(&p[0],&p[n-1]);
  ------------------
  |  | 3405|    249|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3441|       |         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
 3442|       |         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
 3443|    249|         z = (c == c12) ? 0 : n-1;
  ------------------
  |  Branch (3443:14): [True: 6, False: 243]
  ------------------
 3444|    249|         t = p[z];
 3445|    249|         p[z] = p[m];
 3446|    249|         p[m] = t;
 3447|    249|      }
 3448|       |      /* now p[m] is the median-of-three */
 3449|       |      /* swap it to the beginning so it won't move around */
 3450|    648|      t = p[0];
 3451|    648|      p[0] = p[m];
 3452|    648|      p[m] = t;
 3453|       |
 3454|       |      /* partition loop */
 3455|    648|      i=1;
 3456|    648|      j=n-1;
 3457|  1.98k|      for(;;) {
 3458|       |         /* handling of equality is crucial here */
 3459|       |         /* for sentinels & efficiency with duplicates */
 3460|  8.69k|         for (;;++i) {
 3461|  8.69k|            if (!STBTT__COMPARE(&p[i], &p[0])) break;
  ------------------
  |  | 3405|  8.69k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3461:17): [True: 1.98k, False: 6.71k]
  ------------------
 3462|  8.69k|         }
 3463|  5.67k|         for (;;--j) {
 3464|  5.67k|            if (!STBTT__COMPARE(&p[0], &p[j])) break;
  ------------------
  |  | 3405|  5.67k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
  |  Branch (3464:17): [True: 1.98k, False: 3.69k]
  ------------------
 3465|  5.67k|         }
 3466|       |         /* make sure we haven't crossed */
 3467|  1.98k|         if (i >= j) break;
  ------------------
  |  Branch (3467:14): [True: 648, False: 1.33k]
  ------------------
 3468|  1.33k|         t = p[i];
 3469|  1.33k|         p[i] = p[j];
 3470|  1.33k|         p[j] = t;
 3471|       |
 3472|  1.33k|         ++i;
 3473|  1.33k|         --j;
 3474|  1.33k|      }
 3475|       |      /* recurse on smaller side, iterate on larger */
 3476|    648|      if (j < (n-i)) {
  ------------------
  |  Branch (3476:11): [True: 199, False: 449]
  ------------------
 3477|    199|         stbtt__sort_edges_quicksort(p,j);
 3478|    199|         p = p+i;
 3479|    199|         n = n-i;
 3480|    449|      } else {
 3481|    449|         stbtt__sort_edges_quicksort(p+i, n-i);
 3482|    449|         n = j;
 3483|    449|      }
 3484|    648|   }
 3485|    862|}
imgui_draw.cpp:_ZL26stbtt__sort_edges_ins_sortP11stbtt__edgei:
 3408|    214|{
 3409|    214|   int i,j;
 3410|  6.32k|   for (i=1; i < n; ++i) {
  ------------------
  |  Branch (3410:14): [True: 6.10k, False: 214]
  ------------------
 3411|  6.10k|      stbtt__edge t = p[i], *a = &t;
 3412|  6.10k|      j = i;
 3413|  11.1k|      while (j > 0) {
  ------------------
  |  Branch (3413:14): [True: 10.9k, False: 177]
  ------------------
 3414|  10.9k|         stbtt__edge *b = &p[j-1];
 3415|  10.9k|         int c = STBTT__COMPARE(a,b);
  ------------------
  |  | 3405|  10.9k|#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)
  ------------------
 3416|  10.9k|         if (!c) break;
  ------------------
  |  Branch (3416:14): [True: 5.93k, False: 5.04k]
  ------------------
 3417|  5.04k|         p[j] = p[j-1];
 3418|  5.04k|         --j;
 3419|  5.04k|      }
 3420|  6.10k|      if (i != j)
  ------------------
  |  Branch (3420:11): [True: 2.86k, False: 3.23k]
  ------------------
 3421|  2.86k|         p[j] = t;
 3422|  6.10k|   }
 3423|    214|}
imgui_draw.cpp:_ZL29stbtt__rasterize_sorted_edgesP13stbtt__bitmapP11stbtt__edgeiiiiPv:
 3306|    214|{
 3307|    214|   stbtt__hheap hh = { 0, 0, 0 };
 3308|    214|   stbtt__active_edge *active = NULL;
 3309|    214|   int y,j=0, i;
 3310|    214|   float scanline_data[129], *scanline, *scanline2;
 3311|       |
 3312|    214|   STBTT__NOTUSED(vsubsample);
  ------------------
  |  | 1130|    214|#define STBTT__NOTUSED(v)  (void)sizeof(v)
  ------------------
 3313|       |
 3314|    214|   if (result->w > 64)
  ------------------
  |  Branch (3314:8): [True: 0, False: 214]
  ------------------
 3315|      0|      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
  ------------------
  |  |  133|      0|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|      0|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 3316|    214|   else
 3317|    214|      scanline = scanline_data;
 3318|       |
 3319|    214|   scanline2 = scanline + result->w;
 3320|       |
 3321|    214|   y = off_y;
 3322|    214|   e[n].y0 = (float) (off_y + result->h) + 1;
 3323|       |
 3324|  1.83k|   while (j < result->h) {
  ------------------
  |  Branch (3324:11): [True: 1.61k, False: 214]
  ------------------
 3325|       |      // find center of pixel for this scanline
 3326|  1.61k|      float scan_y_top    = y + 0.0f;
 3327|  1.61k|      float scan_y_bottom = y + 1.0f;
 3328|  1.61k|      stbtt__active_edge **step = &active;
 3329|       |
 3330|  1.61k|      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3331|  1.61k|      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));
  ------------------
  |  |  493|  1.61k|   #define STBTT_memset       memset
  ------------------
 3332|       |
 3333|       |      // update all active edges;
 3334|       |      // remove all active edges that terminate before the top of this scanline
 3335|  12.1k|      while (*step) {
  ------------------
  |  Branch (3335:14): [True: 10.5k, False: 1.61k]
  ------------------
 3336|  10.5k|         stbtt__active_edge * z = *step;
 3337|  10.5k|         if (z->ey <= scan_y_top) {
  ------------------
  |  Branch (3337:14): [True: 5.20k, False: 5.36k]
  ------------------
 3338|  5.20k|            *step = z->next; // delete from list
 3339|  5.20k|            STBTT_assert(z->direction);
  ------------------
  |  |  135|  5.20k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  5.20k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3340|  5.20k|            z->direction = 0;
 3341|  5.20k|            stbtt__hheap_free(&hh, z);
 3342|  5.36k|         } else {
 3343|  5.36k|            step = &((*step)->next); // advance through list
 3344|  5.36k|         }
 3345|  10.5k|      }
 3346|       |
 3347|       |      // insert all edges that start before the bottom of this scanline
 3348|  7.94k|      while (e->y0 <= scan_y_bottom) {
  ------------------
  |  Branch (3348:14): [True: 6.32k, False: 1.61k]
  ------------------
 3349|  6.32k|         if (e->y0 != e->y1) {
  ------------------
  |  Branch (3349:14): [True: 6.32k, False: 0]
  ------------------
 3350|  6.32k|            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
 3351|  6.32k|            if (z != NULL) {
  ------------------
  |  Branch (3351:17): [True: 6.32k, False: 0]
  ------------------
 3352|  6.32k|               if (j == 0 && off_y != 0) {
  ------------------
  |  Branch (3352:20): [True: 1.60k, False: 4.72k]
  |  Branch (3352:30): [True: 1.58k, False: 20]
  ------------------
 3353|  1.58k|                  if (z->ey < scan_y_top) {
  ------------------
  |  Branch (3353:23): [True: 0, False: 1.58k]
  ------------------
 3354|       |                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
 3355|      0|                     z->ey = scan_y_top;
 3356|      0|                  }
 3357|  1.58k|               }
 3358|  6.32k|               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
  ------------------
  |  |  135|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3359|       |               // insert at front
 3360|  6.32k|               z->next = active;
 3361|  6.32k|               active = z;
 3362|  6.32k|            }
 3363|  6.32k|         }
 3364|  6.32k|         ++e;
 3365|  6.32k|      }
 3366|       |
 3367|       |      // now process all active edges
 3368|  1.61k|      if (active)
  ------------------
  |  Branch (3368:11): [True: 1.61k, False: 5]
  ------------------
 3369|  1.61k|         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);
 3370|       |
 3371|  1.61k|      {
 3372|  1.61k|         float sum = 0;
 3373|  9.77k|         for (i=0; i < result->w; ++i) {
  ------------------
  |  Branch (3373:20): [True: 8.15k, False: 1.61k]
  ------------------
 3374|  8.15k|            float k;
 3375|  8.15k|            int m;
 3376|  8.15k|            sum += scanline2[i];
 3377|  8.15k|            k = scanline[i] + sum;
 3378|  8.15k|            k = (float) STBTT_fabs(k)*255 + 0.5f;
  ------------------
  |  |  139|  8.15k|#define STBTT_fabs(x)       ImFabs(x)
  |  |  ------------------
  |  |  |  |  451|  8.15k|#define ImFabs(X)           fabsf(X)
  |  |  ------------------
  ------------------
 3379|  8.15k|            m = (int) k;
 3380|  8.15k|            if (m > 255) m = 255;
  ------------------
  |  Branch (3380:17): [True: 0, False: 8.15k]
  ------------------
 3381|  8.15k|            result->pixels[j*result->stride + i] = (unsigned char) m;
 3382|  8.15k|         }
 3383|  1.61k|      }
 3384|       |      // advance all the edges
 3385|  1.61k|      step = &active;
 3386|  13.3k|      while (*step) {
  ------------------
  |  Branch (3386:14): [True: 11.6k, False: 1.61k]
  ------------------
 3387|  11.6k|         stbtt__active_edge *z = *step;
 3388|  11.6k|         z->fx += z->fdx; // advance to position for current scanline
 3389|  11.6k|         step = &((*step)->next); // advance through list
 3390|  11.6k|      }
 3391|       |
 3392|  1.61k|      ++y;
 3393|  1.61k|      ++j;
 3394|  1.61k|   }
 3395|       |
 3396|    214|   stbtt__hheap_cleanup(&hh, userdata);
 3397|       |
 3398|    214|   if (scanline != scanline_data)
  ------------------
  |  Branch (3398:8): [True: 0, False: 214]
  ------------------
 3399|      0|      STBTT_free(scanline, userdata);
  ------------------
  |  |  134|      0|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      0|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 3400|    214|}
imgui_draw.cpp:_ZL17stbtt__hheap_freeP12stbtt__hheapPv:
 2797|  5.20k|{
 2798|  5.20k|   *(void **) p = hh->first_free;
 2799|  5.20k|   hh->first_free = p;
 2800|  5.20k|}
imgui_draw.cpp:_ZL17stbtt__new_activeP12stbtt__hheapP11stbtt__edgeifPv:
 2863|  6.32k|{
 2864|  6.32k|   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
 2865|  6.32k|   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
 2866|  6.32k|   STBTT_assert(z != NULL);
  ------------------
  |  |  135|  6.32k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  6.32k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2867|       |   //STBTT_assert(e->y0 <= start_point);
 2868|  6.32k|   if (!z) return z;
  ------------------
  |  Branch (2868:8): [True: 0, False: 6.32k]
  ------------------
 2869|  6.32k|   z->fdx = dxdy;
 2870|  6.32k|   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
  ------------------
  |  Branch (2870:13): [True: 0, False: 6.32k]
  ------------------
 2871|  6.32k|   z->fx = e->x0 + dxdy * (start_point - e->y0);
 2872|  6.32k|   z->fx -= off_x;
 2873|  6.32k|   z->direction = e->invert ? 1.0f : -1.0f;
  ------------------
  |  Branch (2873:19): [True: 3.16k, False: 3.16k]
  ------------------
 2874|  6.32k|   z->sy = e->y0;
 2875|  6.32k|   z->ey = e->y1;
 2876|  6.32k|   z->next = 0;
 2877|  6.32k|   return z;
 2878|  6.32k|}
imgui_draw.cpp:_ZL18stbtt__hheap_allocP12stbtt__hheapmPv:
 2776|  6.32k|{
 2777|  6.32k|   if (hh->first_free) {
  ------------------
  |  Branch (2777:8): [True: 4.07k, False: 2.24k]
  ------------------
 2778|  4.07k|      void *p = hh->first_free;
 2779|  4.07k|      hh->first_free = * (void **) p;
 2780|  4.07k|      return p;
 2781|  4.07k|   } else {
 2782|  2.24k|      if (hh->num_remaining_in_head_chunk == 0) {
  ------------------
  |  Branch (2782:11): [True: 214, False: 2.03k]
  ------------------
 2783|    214|         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
  ------------------
  |  Branch (2783:23): [True: 0, False: 214]
  |  Branch (2783:42): [True: 214, False: 0]
  ------------------
 2784|    214|         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
  ------------------
  |  |  133|    214|#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
  |  |  ------------------
  |  |  |  | 2051|    214|#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)
  |  |  ------------------
  ------------------
 2785|    214|         if (c == NULL)
  ------------------
  |  Branch (2785:14): [True: 0, False: 214]
  ------------------
 2786|      0|            return NULL;
 2787|    214|         c->next = hh->head;
 2788|    214|         hh->head = c;
 2789|    214|         hh->num_remaining_in_head_chunk = count;
 2790|    214|      }
 2791|  2.24k|      --hh->num_remaining_in_head_chunk;
 2792|  2.24k|      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
 2793|  2.24k|   }
 2794|  6.32k|}
imgui_draw.cpp:_ZL28stbtt__fill_active_edges_newPfS_iP18stbtt__active_edgef:
 3088|  1.61k|{
 3089|  1.61k|   float y_bottom = y_top+1;
 3090|       |
 3091|  13.2k|   while (e) {
  ------------------
  |  Branch (3091:11): [True: 11.6k, False: 1.61k]
  ------------------
 3092|       |      // brute force every pixel
 3093|       |
 3094|       |      // compute intersection points with top & bottom
 3095|  11.6k|      STBTT_assert(e->ey >= y_top);
  ------------------
  |  |  135|  11.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  11.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3096|       |
 3097|  11.6k|      if (e->fdx == 0) {
  ------------------
  |  Branch (3097:11): [True: 11.6k, False: 0]
  ------------------
 3098|  11.6k|         float x0 = e->fx;
 3099|  11.6k|         if (x0 < len) {
  ------------------
  |  Branch (3099:14): [True: 10.3k, False: 1.36k]
  ------------------
 3100|  10.3k|            if (x0 >= 0) {
  ------------------
  |  Branch (3100:17): [True: 10.3k, False: 0]
  ------------------
 3101|  10.3k|               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
 3102|  10.3k|               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
 3103|  10.3k|            } else {
 3104|      0|               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
 3105|      0|            }
 3106|  10.3k|         }
 3107|  11.6k|      } else {
 3108|      0|         float x0 = e->fx;
 3109|      0|         float dx = e->fdx;
 3110|      0|         float xb = x0 + dx;
 3111|      0|         float x_top, x_bottom;
 3112|      0|         float sy0,sy1;
 3113|      0|         float dy = e->fdy;
 3114|      0|         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3115|       |
 3116|       |         // compute endpoints of line segment clipped to this scanline (if the
 3117|       |         // line segment starts on this scanline. x0 is the intersection of the
 3118|       |         // line with y_top, but that may be off the line segment.
 3119|      0|         if (e->sy > y_top) {
  ------------------
  |  Branch (3119:14): [True: 0, False: 0]
  ------------------
 3120|      0|            x_top = x0 + dx * (e->sy - y_top);
 3121|      0|            sy0 = e->sy;
 3122|      0|         } else {
 3123|      0|            x_top = x0;
 3124|      0|            sy0 = y_top;
 3125|      0|         }
 3126|      0|         if (e->ey < y_bottom) {
  ------------------
  |  Branch (3126:14): [True: 0, False: 0]
  ------------------
 3127|      0|            x_bottom = x0 + dx * (e->ey - y_top);
 3128|      0|            sy1 = e->ey;
 3129|      0|         } else {
 3130|      0|            x_bottom = xb;
 3131|      0|            sy1 = y_bottom;
 3132|      0|         }
 3133|       |
 3134|      0|         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
  ------------------
  |  Branch (3134:14): [True: 0, False: 0]
  |  Branch (3134:28): [True: 0, False: 0]
  |  Branch (3134:45): [True: 0, False: 0]
  |  Branch (3134:60): [True: 0, False: 0]
  ------------------
 3135|       |            // from here on, we don't have to range check x values
 3136|       |
 3137|      0|            if ((int) x_top == (int) x_bottom) {
  ------------------
  |  Branch (3137:17): [True: 0, False: 0]
  ------------------
 3138|      0|               float height;
 3139|       |               // simple case, only spans one pixel
 3140|      0|               int x = (int) x_top;
 3141|      0|               height = (sy1 - sy0) * e->direction;
 3142|      0|               STBTT_assert(x >= 0 && x < len);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3143|      0|               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
 3144|      0|               scanline_fill[x] += height; // everything right of this pixel is filled
 3145|      0|            } else {
 3146|      0|               int x,x1,x2;
 3147|      0|               float y_crossing, y_final, step, sign, area;
 3148|       |               // covers 2+ pixels
 3149|      0|               if (x_top > x_bottom) {
  ------------------
  |  Branch (3149:20): [True: 0, False: 0]
  ------------------
 3150|       |                  // flip scanline vertically; signed area is the same
 3151|      0|                  float t;
 3152|      0|                  sy0 = y_bottom - (sy0 - y_top);
 3153|      0|                  sy1 = y_bottom - (sy1 - y_top);
 3154|      0|                  t = sy0, sy0 = sy1, sy1 = t;
 3155|      0|                  t = x_bottom, x_bottom = x_top, x_top = t;
 3156|      0|                  dx = -dx;
 3157|      0|                  dy = -dy;
 3158|      0|                  t = x0, x0 = xb, xb = t;
 3159|      0|               }
 3160|      0|               STBTT_assert(dy >= 0);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3161|      0|               STBTT_assert(dx >= 0);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3162|       |
 3163|      0|               x1 = (int) x_top;
 3164|      0|               x2 = (int) x_bottom;
 3165|       |               // compute intersection with y axis at x1+1
 3166|      0|               y_crossing = y_top + dy * (x1+1 - x0);
 3167|       |
 3168|       |               // compute intersection with y axis at x2
 3169|      0|               y_final = y_top + dy * (x2 - x0);
 3170|       |
 3171|       |               //           x1    x_top                            x2    x_bottom
 3172|       |               //     y_top  +------|-----+------------+------------+--------|---+------------+
 3173|       |               //            |            |            |            |            |            |
 3174|       |               //            |            |            |            |            |            |
 3175|       |               //       sy0  |      Txxxxx|............|............|............|............|
 3176|       |               // y_crossing |            *xxxxx.......|............|............|............|
 3177|       |               //            |            |     xxxxx..|............|............|............|
 3178|       |               //            |            |     /-   xx*xxxx........|............|............|
 3179|       |               //            |            | dy <       |    xxxxxx..|............|............|
 3180|       |               //   y_final  |            |     \-     |          xx*xxx.........|............|
 3181|       |               //       sy1  |            |            |            |   xxxxxB...|............|
 3182|       |               //            |            |            |            |            |            |
 3183|       |               //            |            |            |            |            |            |
 3184|       |               //  y_bottom  +------------+------------+------------+------------+------------+
 3185|       |               //
 3186|       |               // goal is to measure the area covered by '.' in each pixel
 3187|       |
 3188|       |               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
 3189|       |               // @TODO: maybe test against sy1 rather than y_bottom?
 3190|      0|               if (y_crossing > y_bottom)
  ------------------
  |  Branch (3190:20): [True: 0, False: 0]
  ------------------
 3191|      0|                  y_crossing = y_bottom;
 3192|       |
 3193|      0|               sign = e->direction;
 3194|       |
 3195|       |               // area of the rectangle covered from sy0..y_crossing
 3196|      0|               area = sign * (y_crossing-sy0);
 3197|       |
 3198|       |               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
 3199|      0|               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);
 3200|       |
 3201|       |               // check if final y_crossing is blown up; no test case for this
 3202|      0|               if (y_final > y_bottom) {
  ------------------
  |  Branch (3202:20): [True: 0, False: 0]
  ------------------
 3203|      0|                  int denom = (x2 - (x1+1));
 3204|      0|                  y_final = y_bottom;
 3205|      0|                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
  ------------------
  |  Branch (3205:23): [True: 0, False: 0]
  ------------------
 3206|      0|                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
 3207|      0|                  }
 3208|      0|               }
 3209|       |
 3210|       |               // in second pixel, area covered by line segment found in first pixel
 3211|       |               // is always a rectangle 1 wide * the height of that line segment; this
 3212|       |               // is exactly what the variable 'area' stores. it also gets a contribution
 3213|       |               // from the line segment within it. the THIRD pixel will get the first
 3214|       |               // pixel's rectangle contribution, the second pixel's rectangle contribution,
 3215|       |               // and its own contribution. the 'own contribution' is the same in every pixel except
 3216|       |               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
 3217|       |               // the second pixel's contribution to the third pixel will be the
 3218|       |               // rectangle 1 wide times the height change in the second pixel, which is dy.
 3219|       |
 3220|      0|               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
 3221|       |               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
 3222|       |               // so the area advances by 'step' every time
 3223|       |
 3224|      0|               for (x = x1+1; x < x2; ++x) {
  ------------------
  |  Branch (3224:31): [True: 0, False: 0]
  ------------------
 3225|      0|                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
 3226|      0|                  area += step;
 3227|      0|               }
 3228|      0|               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3229|      0|               STBTT_assert(sy1 > y_final-0.01f);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3230|       |
 3231|       |               // area covered in the last pixel is the rectangle from all the pixels to the left,
 3232|       |               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
 3233|      0|               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);
 3234|       |
 3235|       |               // the rest of the line is filled based on the total height of the line segment in this pixel
 3236|      0|               scanline_fill[x2] += sign * (sy1-sy0);
 3237|      0|            }
 3238|      0|         } else {
 3239|       |            // if edge goes outside of box we're drawing, we require
 3240|       |            // clipping logic. since this does not match the intended use
 3241|       |            // of this library, we use a different, very slow brute
 3242|       |            // force implementation
 3243|       |            // note though that this does happen some of the time because
 3244|       |            // x_top and x_bottom can be extrapolated at the top & bottom of
 3245|       |            // the shape and actually lie outside the bounding box
 3246|      0|            int x;
 3247|      0|            for (x=0; x < len; ++x) {
  ------------------
  |  Branch (3247:23): [True: 0, False: 0]
  ------------------
 3248|       |               // cases:
 3249|       |               //
 3250|       |               // there can be up to two intersections with the pixel. any intersection
 3251|       |               // with left or right edges can be handled by splitting into two (or three)
 3252|       |               // regions. intersections with top & bottom do not necessitate case-wise logic.
 3253|       |               //
 3254|       |               // the old way of doing this found the intersections with the left & right edges,
 3255|       |               // then used some simple logic to produce up to three segments in sorted order
 3256|       |               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
 3257|       |               // across the x border, then the corresponding y position might not be distinct
 3258|       |               // from the other y segment, and it might ignored as an empty segment. to avoid
 3259|       |               // that, we need to explicitly produce segments based on x positions.
 3260|       |
 3261|       |               // rename variables to clearly-defined pairs
 3262|      0|               float y0 = y_top;
 3263|      0|               float x1 = (float) (x);
 3264|      0|               float x2 = (float) (x+1);
 3265|      0|               float x3 = xb;
 3266|      0|               float y3 = y_bottom;
 3267|       |
 3268|       |               // x = e->x + e->dx * (y-y_top)
 3269|       |               // (y-y_top) = (x - e->x) / e->dx
 3270|       |               // y = (x - e->x) / e->dx + y_top
 3271|      0|               float y1 = (x - x0) / dx + y_top;
 3272|      0|               float y2 = (x+1 - x0) / dx + y_top;
 3273|       |
 3274|      0|               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
  ------------------
  |  Branch (3274:20): [True: 0, False: 0]
  |  Branch (3274:31): [True: 0, False: 0]
  ------------------
 3275|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3276|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
 3277|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3278|      0|               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
  ------------------
  |  Branch (3278:27): [True: 0, False: 0]
  |  Branch (3278:38): [True: 0, False: 0]
  ------------------
 3279|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3280|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
 3281|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3282|      0|               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
  ------------------
  |  Branch (3282:27): [True: 0, False: 0]
  |  Branch (3282:38): [True: 0, False: 0]
  ------------------
 3283|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3284|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3285|      0|               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
  ------------------
  |  Branch (3285:27): [True: 0, False: 0]
  |  Branch (3285:38): [True: 0, False: 0]
  ------------------
 3286|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
 3287|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
 3288|      0|               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
  ------------------
  |  Branch (3288:27): [True: 0, False: 0]
  |  Branch (3288:38): [True: 0, False: 0]
  ------------------
 3289|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3290|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3291|      0|               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
  ------------------
  |  Branch (3291:27): [True: 0, False: 0]
  |  Branch (3291:38): [True: 0, False: 0]
  ------------------
 3292|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
 3293|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
 3294|      0|               } else {  // one segment
 3295|      0|                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
 3296|      0|               }
 3297|      0|            }
 3298|      0|         }
 3299|      0|      }
 3300|  11.6k|      e = e->next;
 3301|  11.6k|   }
 3302|  1.61k|}
imgui_draw.cpp:_ZL26stbtt__handle_clipped_edgePfiP18stbtt__active_edgeffff:
 3034|  20.6k|{
 3035|  20.6k|   if (y0 == y1) return;
  ------------------
  |  Branch (3035:8): [True: 0, False: 20.6k]
  ------------------
 3036|  20.6k|   STBTT_assert(y0 < y1);
  ------------------
  |  |  135|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3037|  20.6k|   STBTT_assert(e->sy <= e->ey);
  ------------------
  |  |  135|  20.6k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  20.6k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3038|  20.6k|   if (y0 > e->ey) return;
  ------------------
  |  Branch (3038:8): [True: 0, False: 20.6k]
  ------------------
 3039|  20.6k|   if (y1 < e->sy) return;
  ------------------
  |  Branch (3039:8): [True: 0, False: 20.6k]
  ------------------
 3040|  20.6k|   if (y0 < e->sy) {
  ------------------
  |  Branch (3040:8): [True: 9.44k, False: 11.1k]
  ------------------
 3041|  9.44k|      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
 3042|  9.44k|      y0 = e->sy;
 3043|  9.44k|   }
 3044|  20.6k|   if (y1 > e->ey) {
  ------------------
  |  Branch (3044:8): [True: 0, False: 20.6k]
  ------------------
 3045|      0|      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
 3046|      0|      y1 = e->ey;
 3047|      0|   }
 3048|       |
 3049|  20.6k|   if (x0 == x)
  ------------------
  |  Branch (3049:8): [True: 10.3k, False: 10.3k]
  ------------------
 3050|  10.3k|      STBTT_assert(x1 <= x+1);
  ------------------
  |  |  135|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3051|  10.3k|   else if (x0 == x+1)
  ------------------
  |  Branch (3051:13): [True: 0, False: 10.3k]
  ------------------
 3052|      0|      STBTT_assert(x1 >= x);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3053|  10.3k|   else if (x0 <= x)
  ------------------
  |  Branch (3053:13): [True: 10.3k, False: 0]
  ------------------
 3054|  10.3k|      STBTT_assert(x1 <= x);
  ------------------
  |  |  135|  10.3k|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|  10.3k|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3055|      0|   else if (x0 >= x+1)
  ------------------
  |  Branch (3055:13): [True: 0, False: 0]
  ------------------
 3056|      0|      STBTT_assert(x1 >= x+1);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3057|      0|   else
 3058|      0|      STBTT_assert(x1 >= x && x1 <= x+1);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3059|       |
 3060|  20.6k|   if (x0 <= x && x1 <= x)
  ------------------
  |  Branch (3060:8): [True: 20.6k, False: 0]
  |  Branch (3060:19): [True: 20.6k, False: 0]
  ------------------
 3061|  20.6k|      scanline[x] += e->direction * (y1-y0);
 3062|      0|   else if (x0 >= x+1 && x1 >= x+1)
  ------------------
  |  Branch (3062:13): [True: 0, False: 0]
  |  Branch (3062:26): [True: 0, False: 0]
  ------------------
 3063|      0|      ;
 3064|      0|   else {
 3065|      0|      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
  ------------------
  |  |  135|      0|#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
  |  |  ------------------
  |  |  |  |   23|      0|#define IM_ASSERT(_EXPR) PHI_ASSERT(_EXPR)
  |  |  ------------------
  |  |  |  Branch (135:56): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3066|      0|      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
 3067|      0|   }
 3068|  20.6k|}
imgui_draw.cpp:_ZL20stbtt__hheap_cleanupP12stbtt__hheapPv:
 2803|    214|{
 2804|    214|   stbtt__hheap_chunk *c = hh->head;
 2805|    428|   while (c) {
  ------------------
  |  Branch (2805:11): [True: 214, False: 214]
  ------------------
 2806|    214|      stbtt__hheap_chunk *n = c->next;
 2807|    214|      STBTT_free(c, userdata);
  ------------------
  |  |  134|    214|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|    214|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 2808|    214|      c = n;
 2809|    214|   }
 2810|    214|}
imgui_draw.cpp:_ZL13stbtt_PackEndP18stbtt_pack_context:
 3998|      1|{
 3999|      1|   STBTT_free(spc->nodes    , spc->user_allocator_context);
  ------------------
  |  |  134|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4000|      1|   STBTT_free(spc->pack_info, spc->user_allocator_context);
  ------------------
  |  |  134|      1|#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
  |  |  ------------------
  |  |  |  | 2052|      1|#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)
  |  |  ------------------
  ------------------
 4001|      1|}
imgui_draw.cpp:_ZL21stbtt_GetFontVMetricsPK14stbtt_fontinfoPiS2_S2_:
 2640|      1|{
 2641|      1|   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
  ------------------
  |  Branch (2641:8): [True: 1, False: 0]
  ------------------
 2642|      1|   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
  ------------------
  |  Branch (2642:8): [True: 1, False: 0]
  ------------------
 2643|      1|   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
  ------------------
  |  Branch (2643:8): [True: 1, False: 0]
  ------------------
 2644|      1|}
imgui_draw.cpp:_ZL19stbtt_GetPackedQuadPK16stbtt_packedchariiiPfS2_P18stbtt_aligned_quadi:
 4372|    223|{
 4373|    223|   float ipw = 1.0f / pw, iph = 1.0f / ph;
 4374|    223|   const stbtt_packedchar *b = chardata + char_index;
 4375|       |
 4376|    223|   if (align_to_integer) {
  ------------------
  |  Branch (4376:8): [True: 0, False: 223]
  ------------------
 4377|      0|      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
  ------------------
  |  |  140|      0|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
 4378|      0|      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
  ------------------
  |  |  140|      0|#define STBTT_ifloor(x)     ((int)ImFloor(x))
  ------------------
 4379|      0|      q->x0 = x;
 4380|      0|      q->y0 = y;
 4381|      0|      q->x1 = x + b->xoff2 - b->xoff;
 4382|      0|      q->y1 = y + b->yoff2 - b->yoff;
 4383|    223|   } else {
 4384|    223|      q->x0 = *xpos + b->xoff;
 4385|    223|      q->y0 = *ypos + b->yoff;
 4386|    223|      q->x1 = *xpos + b->xoff2;
 4387|    223|      q->y1 = *ypos + b->yoff2;
 4388|    223|   }
 4389|       |
 4390|    223|   q->s0 = b->x0 * ipw;
 4391|    223|   q->t0 = b->y0 * iph;
 4392|    223|   q->s1 = b->x1 * ipw;
 4393|    223|   q->t1 = b->y1 * iph;
 4394|       |
 4395|    223|   *xpos += b->xadvance;
 4396|    223|}

_Z9consume_tIN6dlxemu10CodeEditor11CoordinatesEEN3phi8optionalIT_EEPKhmRm:
  139|  6.92k|{
  140|  6.92k|    GET_T(phi::uint32_t, column);
  ------------------
  |  |   38|  6.92k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  6.92k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 12, False: 6.91k]
  |  |  ------------------
  |  |   40|  6.92k|    {                                                                                              \
  |  |   41|     12|        return {};                                                                                 \
  |  |   42|     12|    }                                                                                              \
  |  |   43|  6.92k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  141|  6.91k|    GET_T(phi::uint32_t, line);
  ------------------
  |  |   38|  6.91k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  6.91k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 8, False: 6.90k]
  |  |  ------------------
  |  |   40|  6.91k|    {                                                                                              \
  |  |   41|      8|        return {};                                                                                 \
  |  |   42|      8|    }                                                                                              \
  |  |   43|  6.91k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  142|       |
  143|  6.90k|    return dlxemu::CodeEditor::Coordinates{column, line};
  144|  6.91k|}
_Z14consume_stringPKhmRm:
  148|  30.8k|{
  149|       |    // Ensure we're not already past the available data
  150|  30.8k|    if (index >= size)
  ------------------
  |  Branch (150:9): [True: 176, False: 30.6k]
  ------------------
  151|    176|    {
  152|    176|        return false;
  153|    176|    }
  154|       |
  155|  30.6k|    const char* str_begin = reinterpret_cast<const char*>(data + index);
  156|  30.6k|    phi::size_t str_len   = 0u;
  157|       |
  158|  40.8k|    while (index < size && data[index] != '\0')
  ------------------
  |  Branch (158:12): [True: 40.7k, False: 74]
  |  Branch (158:28): [True: 10.1k, False: 30.5k]
  ------------------
  159|  10.1k|    {
  160|  10.1k|        ++index;
  161|  10.1k|        ++str_len;
  162|  10.1k|    }
  163|       |
  164|       |    // Reject too long strings
  165|  30.6k|    if (str_len > MaxStringLength)
  ------------------
  |  Branch (165:9): [True: 120, False: 30.5k]
  ------------------
  166|    120|    {
  167|    120|        return false;
  168|    120|    }
  169|       |
  170|  30.5k|    PHI_ASSERT(index <= size);
  171|       |    // Reject strings that are not null terminated
  172|  30.5k|    if (data[index - 1u] != '\0')
  ------------------
  |  Branch (172:9): [True: 2.05k, False: 28.4k]
  ------------------
  173|  2.05k|    {
  174|  2.05k|        return false;
  175|  2.05k|    }
  176|       |
  177|       |    // Move back to proper alignment
  178|  28.4k|    index += (sizeof(void*) - (index % sizeof(void*)));
  179|       |
  180|       |    // Assign string value to cache
  181|  28.4k|    cache.string = str_begin;
  182|       |
  183|  28.4k|    return true;
  184|  30.5k|}
_Z21consume_vector_stringPKhmRm:
  190|  1.09k|{
  191|  1.09k|    GET_T(phi::size_t, number_of_lines);
  ------------------
  |  |   38|  1.09k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  1.09k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 8, False: 1.09k]
  |  |  ------------------
  |  |   40|  1.09k|    {                                                                                              \
  |  |   41|      8|        return {};                                                                                 \
  |  |   42|      8|    }                                                                                              \
  |  |   43|  1.09k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  192|       |
  193|  1.09k|    if (number_of_lines >= MaxVectorSize)
  ------------------
  |  Branch (193:9): [True: 21, False: 1.07k]
  ------------------
  194|     21|    {
  195|     21|        return {};
  196|     21|    }
  197|       |
  198|  1.07k|    std::vector<std::string>& res = cache.vector_string[number_of_lines];
  199|  3.57k|    for (phi::size_t i{0u}; i < number_of_lines; ++i)
  ------------------
  |  Branch (199:29): [True: 2.52k, False: 1.05k]
  ------------------
  200|  2.52k|    {
  201|  2.52k|        if (!consume_string(data, size, index))
  ------------------
  |  Branch (201:13): [True: 17, False: 2.50k]
  ------------------
  202|     17|        {
  203|     17|            return {};
  204|     17|        }
  205|       |
  206|  2.50k|        res[i] = cache.string;
  207|  2.50k|    }
  208|       |
  209|  1.05k|    return number_of_lines;
  210|  1.07k|}
_Z13IsReservedKey8ImGuiKey:
  323|  8.83k|{
  324|  8.83k|    switch (key)
  325|  8.83k|    {
  326|      0|        case ImGuiKey_ReservedForModCtrl:
  ------------------
  |  Branch (326:9): [True: 0, False: 8.83k]
  ------------------
  327|      0|        case ImGuiKey_ReservedForModShift:
  ------------------
  |  Branch (327:9): [True: 0, False: 8.83k]
  ------------------
  328|      0|        case ImGuiKey_ReservedForModAlt:
  ------------------
  |  Branch (328:9): [True: 0, False: 8.83k]
  ------------------
  329|      0|        case ImGuiKey_ReservedForModSuper:
  ------------------
  |  Branch (329:9): [True: 0, False: 8.83k]
  ------------------
  330|      0|            return true;
  331|       |
  332|  8.83k|        default:
  ------------------
  |  Branch (332:9): [True: 8.83k, False: 0]
  ------------------
  333|  8.83k|            return false;
  334|  8.83k|    }
  335|  8.83k|}
_Z10SetupImGuiv:
  338|      1|{
  339|      1|    IMGUI_CHECKVERSION();
  340|      1|    if (GImGui != nullptr)
  ------------------
  |  Branch (340:9): [True: 0, False: 1]
  ------------------
  341|      0|    {
  342|      0|        return true;
  343|      0|    }
  344|       |
  345|      1|    if (ImGui::CreateContext() == nullptr)
  ------------------
  |  Branch (345:9): [True: 0, False: 1]
  ------------------
  346|      0|    {
  347|      0|        FUZZ_LOG("Failed to create ImGuiContext");
  ------------------
  |  |   34|      0|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  348|      0|        return false;
  349|      0|    }
  350|       |
  351|       |    // Set config
  352|      1|    ImGuiIO& io = ImGui::GetIO();
  353|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
  354|      1|    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;  // Enable Gamepad Controls
  355|      1|    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;     // Enable Docking
  356|      1|    io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; // Enable Multi-Viewport / Platform Windows
  357|       |
  358|       |    // Enforce valid display size
  359|      1|    io.DisplaySize.x = 1024.0f;
  360|      1|    io.DisplaySize.y = 768.0f;
  361|       |
  362|       |    // Enfore valid DeltaTime
  363|      1|    io.DeltaTime = 1.0f / 60.0f;
  364|       |
  365|       |    // Don't save any config
  366|      1|    io.IniFilename = nullptr;
  367|       |
  368|       |    // SetStyle
  369|      1|    ImGuiStyle& style = ImGui::GetStyle();
  370|      1|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (370:9): [True: 1, False: 0]
  ------------------
  371|      1|    {
  372|      1|        style.WindowRounding              = 0.0f;
  373|      1|        style.Colors[ImGuiCol_WindowBg].w = 1.0f;
  374|      1|    }
  375|       |
  376|       |    // Build atlas
  377|      1|    unsigned char* tex_pixels{nullptr};
  378|      1|    int            tex_w;
  379|      1|    int            tex_h;
  380|      1|    io.Fonts->GetTexDataAsRGBA32(&tex_pixels, &tex_w, &tex_h);
  381|       |
  382|      1|    return true;
  383|      1|}
_Z8EndImGuiv:
  386|  76.6k|{
  387|  76.6k|    ImGui::Render();
  388|       |
  389|  76.6k|    volatile ImDrawData* draw_data = ImGui::GetDrawData();
  390|  76.6k|    PHI_UNUSED_VARIABLE(draw_data);
  391|       |
  392|  76.6k|    ImGuiIO& io = ImGui::GetIO();
  393|       |    // Update and Render additional Platform Windows
  394|       |    // (Platform functions may change the current OpenGL context, so we save/restore it to make it easier to paste this code elsewhere.
  395|  76.6k|    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
  ------------------
  |  Branch (395:9): [True: 0, False: 76.6k]
  ------------------
  396|      0|    {
  397|      0|        ImGui::UpdatePlatformWindows();
  398|      0|        ImGui::RenderPlatformWindowsDefault();
  399|      0|    }
  400|       |
  401|  76.6k|    ImGui::EndFrame();
  402|       |
  403|       |    // Ensure frame count doesn't overflow
  404|  76.6k|    GImGui->FrameCount %= 16384;
  405|  76.6k|}
LLVMFuzzerTestOneInput:
  409|  9.87k|{
  410|  9.87k|    static bool imgui_init = SetupImGui();
  411|  9.87k|    (void)imgui_init;
  412|       |
  413|       |    // Reset some ImGui states
  414|  9.87k|    ImGui::GetIO().ClearInputKeys();
  415|  9.87k|    ImGui::GetIO().InputQueueSurrogate = 0;
  416|  9.87k|    GImGui->InputEventsQueue.resize(0u);
  417|  9.87k|    ImGui::FocusWindow(nullptr);
  418|       |
  419|  9.87k|    dlxemu::Emulator   emulator;
  420|  9.87k|    dlxemu::CodeEditor editor{&emulator};
  421|       |
  422|  9.87k|    editor.UpdatePalette();
  423|       |
  424|  9.87k|    FUZZ_LOG("Beginning execution");
  ------------------
  |  |   34|  9.87k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  425|       |
  426|   595k|    for (phi::size_t index{0u}; index < size;)
  ------------------
  |  Branch (426:33): [True: 591k, False: 4.52k]
  ------------------
  427|   591k|    {
  428|   591k|        GET_T(phi::uint32_t, function_index);
  ------------------
  |  |   38|   591k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|   591k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1.74k, False: 589k]
  |  |  ------------------
  |  |   40|   591k|    {                                                                                              \
  |  |   41|  1.74k|        return {};                                                                                 \
  |  |   42|  1.74k|    }                                                                                              \
  |  |   43|   591k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  429|       |
  430|   589k|        switch (function_index)
  ------------------
  |  Branch (430:17): [True: 325k, False: 263k]
  ------------------
  431|   589k|        {
  432|       |            // AddErrorMarker
  433|  24.4k|            case 0: {
  ------------------
  |  Branch (433:13): [True: 24.4k, False: 564k]
  ------------------
  434|  24.4k|                GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   38|  24.4k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  24.4k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 369, False: 24.0k]
  |  |  ------------------
  |  |   40|  24.4k|    {                                                                                              \
  |  |   41|    369|        return {};                                                                                 \
  |  |   42|    369|    }                                                                                              \
  |  |   43|  24.4k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  435|       |
  436|  24.0k|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (436:21): [True: 2.25k, False: 21.7k]
  ------------------
  437|  2.25k|                {
  438|  2.25k|                    return 0;
  439|  2.25k|                }
  440|  21.7k|                std::string& message = cache.string;
  441|       |
  442|  21.7k|                FUZZ_LOG("AddErrorMarker({:s}, {:s})", print_int(line_number),
  ------------------
  |  |   34|  21.7k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  443|  21.7k|                         print_string(message));
  444|       |
  445|  21.7k|                editor.AddErrorMarker(line_number, message);
  446|  21.7k|                break;
  447|  24.0k|            }
  448|       |
  449|       |            // ClearErrorMarkers
  450|  1.81k|            case 1: {
  ------------------
  |  Branch (450:13): [True: 1.81k, False: 587k]
  ------------------
  451|  1.81k|                FUZZ_LOG("ClearErrorMarkers");
  ------------------
  |  |   34|  1.81k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  452|       |
  453|  1.81k|                editor.ClearErrorMarkers();
  454|  1.81k|                break;
  455|  24.0k|            }
  456|       |
  457|       |            // SetText
  458|    965|            case 2: {
  ------------------
  |  Branch (458:13): [True: 965, False: 588k]
  ------------------
  459|    965|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (459:21): [True: 19, False: 946]
  ------------------
  460|     19|                {
  461|     19|                    return 0;
  462|     19|                }
  463|    946|                std::string& text = cache.string;
  464|       |
  465|    946|                FUZZ_LOG("SetText({:s})", print_string(text));
  ------------------
  |  |   34|    946|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  466|       |
  467|    946|                editor.SetText(text);
  468|    946|                break;
  469|    965|            }
  470|       |
  471|       |            // GetText
  472|  1.10k|            case 3: {
  ------------------
  |  Branch (472:13): [True: 1.10k, False: 588k]
  ------------------
  473|  1.10k|                FUZZ_LOG("GetText()");
  ------------------
  |  |   34|  1.10k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  474|       |
  475|  1.10k|                volatile std::string str = editor.GetText();
  476|  1.10k|                PHI_UNUSED_VARIABLE(str);
  477|  1.10k|                break;
  478|    965|            }
  479|       |
  480|       |            // SetTextLines
  481|  1.09k|            case 4: {
  ------------------
  |  Branch (481:13): [True: 1.09k, False: 588k]
  ------------------
  482|  1.09k|                auto lines_opt = consume_vector_string(data, size, index);
  483|  1.09k|                if (!lines_opt)
  ------------------
  |  Branch (483:21): [True: 46, False: 1.05k]
  ------------------
  484|     46|                {
  485|     46|                    return 0;
  486|     46|                }
  487|       |
  488|  1.05k|                const std::vector<std::string>& lines = cache.vector_string[lines_opt.value()];
  489|       |
  490|  1.05k|                FUZZ_LOG("SetTextLines({:s})", print_vector_string(lines));
  ------------------
  |  |   34|  1.05k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  491|  1.05k|                editor.SetTextLines(lines);
  492|  1.05k|                break;
  493|  1.09k|            }
  494|       |
  495|       |            // GetTextLines
  496|    446|            case 5: {
  ------------------
  |  Branch (496:13): [True: 446, False: 588k]
  ------------------
  497|    446|                FUZZ_LOG("GetTextLines()");
  ------------------
  |  |   34|    446|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  498|       |
  499|    446|                volatile std::vector<std::string> lines = editor.GetTextLines();
  500|    446|                PHI_UNUSED_VARIABLE(lines);
  501|    446|                break;
  502|  1.09k|            }
  503|       |
  504|       |            // GetSelectedText
  505|    208|            case 6: {
  ------------------
  |  Branch (505:13): [True: 208, False: 589k]
  ------------------
  506|    208|                FUZZ_LOG("GetSelectedText()");
  ------------------
  |  |   34|    208|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  507|       |
  508|    208|                volatile std::string line = editor.GetSelectedText();
  509|    208|                PHI_UNUSED_VARIABLE(line);
  510|    208|                break;
  511|  1.09k|            }
  512|       |
  513|       |            // GetCurrentLineText
  514|    188|            case 7: {
  ------------------
  |  Branch (514:13): [True: 188, False: 589k]
  ------------------
  515|    188|                FUZZ_LOG("GetCurrentLineText()");
  ------------------
  |  |   34|    188|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  516|       |
  517|    188|                volatile std::string line = editor.GetCurrentLineText();
  518|    188|                PHI_UNUSED_VARIABLE(line);
  519|    188|                break;
  520|  1.09k|            }
  521|       |
  522|       |            // SetReadOnly
  523|    364|            case 8: {
  ------------------
  |  Branch (523:13): [True: 364, False: 588k]
  ------------------
  524|    364|                GET_T(bool, read_only);
  ------------------
  |  |   38|    364|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    364|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 362]
  |  |  ------------------
  |  |   40|    364|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|    364|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  525|       |
  526|    362|                FUZZ_LOG("SetReadOnly({:s})", print_bool(read_only));
  ------------------
  |  |   34|    362|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  527|    362|                editor.SetReadOnly(read_only);
  528|    362|                break;
  529|    364|            }
  530|       |
  531|       |            // GetCursorPosition
  532|    169|            case 9: {
  ------------------
  |  Branch (532:13): [True: 169, False: 589k]
  ------------------
  533|    169|                FUZZ_LOG("GetCursorPosition()");
  ------------------
  |  |   34|    169|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  534|       |
  535|    169|                volatile dlxemu::CodeEditor::Coordinates coords = editor.GetCursorPosition();
  536|    169|                PHI_UNUSED_VARIABLE(coords);
  537|    169|                break;
  538|    364|            }
  539|       |
  540|       |            // SetCursorPosition
  541|  4.92k|            case 10: {
  ------------------
  |  Branch (541:13): [True: 4.92k, False: 584k]
  ------------------
  542|  4.92k|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   38|  4.92k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  4.92k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 12, False: 4.90k]
  |  |  ------------------
  |  |   40|  4.92k|    {                                                                                              \
  |  |   41|     12|        return {};                                                                                 \
  |  |   42|     12|    }                                                                                              \
  |  |   43|  4.92k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  543|       |
  544|  4.90k|                FUZZ_LOG("SetCursorPosition(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   34|  4.90k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  545|  4.90k|                         print_int(coords.m_Column));
  546|  4.90k|                editor.SetCursorPosition(coords);
  547|  4.90k|                break;
  548|  4.92k|            }
  549|       |
  550|       |            // SetShowWhitespaces
  551|    162|            case 11: {
  ------------------
  |  Branch (551:13): [True: 162, False: 589k]
  ------------------
  552|    162|                GET_T(bool, show_whitespaces);
  ------------------
  |  |   38|    162|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    162|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 161]
  |  |  ------------------
  |  |   40|    162|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    162|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  553|       |
  554|    161|                FUZZ_LOG("SetShowShitespaces({:s})", print_bool(show_whitespaces));
  ------------------
  |  |   34|    161|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  555|    161|                editor.SetShowWhitespaces(show_whitespaces);
  556|    161|                break;
  557|    162|            }
  558|       |
  559|       |            // SetTabSize
  560|  1.33k|            case 12: {
  ------------------
  |  Branch (560:13): [True: 1.33k, False: 587k]
  ------------------
  561|  1.33k|                GET_T(phi::uint_fast8_t, tab_size);
  ------------------
  |  |   38|  1.33k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  1.33k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 1.33k]
  |  |  ------------------
  |  |   40|  1.33k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  1.33k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  562|       |
  563|  1.33k|                FUZZ_LOG("SetTabSize({:s})", print_int(tab_size));
  ------------------
  |  |   34|  1.33k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  564|  1.33k|                editor.SetTabSize(tab_size);
  565|  1.33k|                break;
  566|  1.33k|            }
  567|       |
  568|       |            // InsertText
  569|    649|            case 13: {
  ------------------
  |  Branch (569:13): [True: 649, False: 588k]
  ------------------
  570|    649|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (570:21): [True: 15, False: 634]
  ------------------
  571|     15|                {
  572|     15|                    return 0;
  573|     15|                }
  574|       |
  575|    634|                std::string& message = cache.string;
  576|       |
  577|    634|                FUZZ_LOG("InsertText({:s})", print_string(message));
  ------------------
  |  |   34|    634|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  578|    634|                editor.InsertText(message);
  579|    634|                break;
  580|    649|            }
  581|       |
  582|       |            // MoveUp
  583|    405|            case 14: {
  ------------------
  |  Branch (583:13): [True: 405, False: 588k]
  ------------------
  584|    405|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   38|    405|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    405|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 404]
  |  |  ------------------
  |  |   40|    405|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    405|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  585|    404|                GET_T(bool, select);
  ------------------
  |  |   38|    404|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    404|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 403]
  |  |  ------------------
  |  |   40|    404|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    404|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  586|       |
  587|    403|                FUZZ_LOG("MoveUp({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   34|    403|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  588|    403|                editor.MoveUp(amount, select);
  589|    403|                break;
  590|    404|            }
  591|       |
  592|       |            // MoveDown
  593|  2.21k|            case 15: {
  ------------------
  |  Branch (593:13): [True: 2.21k, False: 587k]
  ------------------
  594|  2.21k|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   38|  2.21k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  2.21k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 2.20k]
  |  |  ------------------
  |  |   40|  2.21k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  2.21k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  595|  2.20k|                GET_T(bool, select);
  ------------------
  |  |   38|  2.20k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  2.20k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 2.20k]
  |  |  ------------------
  |  |   40|  2.20k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  2.20k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  596|       |
  597|  2.20k|                FUZZ_LOG("MoveDown({:s}, {:s})", print_int(amount), print_bool(select));
  ------------------
  |  |   34|  2.20k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  598|  2.20k|                editor.MoveDown(amount, select);
  599|  2.20k|                break;
  600|  2.20k|            }
  601|       |
  602|       |            // MoveLeft
  603|  5.21k|            case 16: {
  ------------------
  |  Branch (603:13): [True: 5.21k, False: 584k]
  ------------------
  604|  5.21k|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   38|  5.21k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  5.21k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 5.21k]
  |  |  ------------------
  |  |   40|  5.21k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  5.21k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  605|  5.21k|                GET_T(bool, select);
  ------------------
  |  |   38|  5.21k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  5.21k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 10, False: 5.20k]
  |  |  ------------------
  |  |   40|  5.21k|    {                                                                                              \
  |  |   41|     10|        return {};                                                                                 \
  |  |   42|     10|    }                                                                                              \
  |  |   43|  5.21k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  606|  5.20k|                GET_T(bool, word_mode);
  ------------------
  |  |   38|  5.20k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  5.20k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 5, False: 5.19k]
  |  |  ------------------
  |  |   40|  5.20k|    {                                                                                              \
  |  |   41|      5|        return {};                                                                                 \
  |  |   42|      5|    }                                                                                              \
  |  |   43|  5.20k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  607|       |
  608|  5.19k|                FUZZ_LOG("MoveLeft({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   34|  5.19k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  609|  5.19k|                         print_bool(word_mode));
  610|  5.19k|                editor.MoveLeft(amount, select, word_mode);
  611|  5.19k|                break;
  612|  5.20k|            }
  613|       |
  614|       |            // MoveRight
  615|    388|            case 17: {
  ------------------
  |  Branch (615:13): [True: 388, False: 588k]
  ------------------
  616|    388|                GET_T(phi::uint32_t, amount);
  ------------------
  |  |   38|    388|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    388|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 387]
  |  |  ------------------
  |  |   40|    388|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    388|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  617|    387|                GET_T(bool, select);
  ------------------
  |  |   38|    387|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    387|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 386]
  |  |  ------------------
  |  |   40|    387|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    387|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  618|    386|                GET_T(bool, word_mode);
  ------------------
  |  |   38|    386|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    386|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 385]
  |  |  ------------------
  |  |   40|    386|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    386|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  619|       |
  620|    385|                FUZZ_LOG("MoveRight({:s}, {:s}, {:s})", print_int(amount), print_bool(select),
  ------------------
  |  |   34|    385|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  621|    385|                         print_bool(word_mode));
  622|       |
  623|    385|                editor.MoveRight(amount, select, word_mode);
  624|    385|                break;
  625|    386|            }
  626|       |
  627|       |            // MoveTop
  628|  1.02k|            case 18: {
  ------------------
  |  Branch (628:13): [True: 1.02k, False: 588k]
  ------------------
  629|  1.02k|                GET_T(bool, select);
  ------------------
  |  |   38|  1.02k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  1.02k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 1.02k]
  |  |  ------------------
  |  |   40|  1.02k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  1.02k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  630|       |
  631|  1.02k|                FUZZ_LOG("MoveTop({:s})", print_bool(select));
  ------------------
  |  |   34|  1.02k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  632|  1.02k|                editor.MoveTop(select);
  633|  1.02k|                break;
  634|  1.02k|            }
  635|       |
  636|       |            // MoveBottom
  637|    577|            case 19: {
  ------------------
  |  Branch (637:13): [True: 577, False: 588k]
  ------------------
  638|    577|                GET_T(bool, select);
  ------------------
  |  |   38|    577|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    577|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 575]
  |  |  ------------------
  |  |   40|    577|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|    577|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  639|       |
  640|    575|                FUZZ_LOG("MoveBottom({:s})", print_bool(select));
  ------------------
  |  |   34|    575|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  641|    575|                editor.MoveBottom(select);
  642|    575|                break;
  643|    577|            }
  644|       |
  645|       |            // MoveHome
  646|  3.36k|            case 20: {
  ------------------
  |  Branch (646:13): [True: 3.36k, False: 585k]
  ------------------
  647|  3.36k|                GET_T(bool, select);
  ------------------
  |  |   38|  3.36k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  3.36k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 3.36k]
  |  |  ------------------
  |  |   40|  3.36k|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|  3.36k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  648|       |
  649|  3.36k|                FUZZ_LOG("MoveHome({:s})", print_bool(select));
  ------------------
  |  |   34|  3.36k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  650|  3.36k|                editor.MoveHome(select);
  651|  3.36k|                break;
  652|  3.36k|            }
  653|       |
  654|       |            // MoveEnd
  655|    532|            case 21: {
  ------------------
  |  Branch (655:13): [True: 532, False: 588k]
  ------------------
  656|    532|                GET_T(bool, select);
  ------------------
  |  |   38|    532|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    532|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 531]
  |  |  ------------------
  |  |   40|    532|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    532|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  657|       |
  658|    531|                FUZZ_LOG("MoveEnd({:s})", print_bool(select));
  ------------------
  |  |   34|    531|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  659|    531|                editor.MoveEnd(select);
  660|    531|                break;
  661|    532|            }
  662|       |
  663|       |            // SetSelectionStart
  664|    281|            case 22: {
  ------------------
  |  Branch (664:13): [True: 281, False: 588k]
  ------------------
  665|    281|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   38|    281|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    281|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 279]
  |  |  ------------------
  |  |   40|    281|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|    281|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  666|       |
  667|    279|                FUZZ_LOG("SetSelectionStart(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   34|    279|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  668|    279|                         print_int(coords.m_Column));
  669|    279|                editor.SetSelectionStart(coords);
  670|    279|                break;
  671|    281|            }
  672|       |
  673|       |            // SetSelectionEnd
  674|    490|            case 23: {
  ------------------
  |  Branch (674:13): [True: 490, False: 588k]
  ------------------
  675|    490|                GET_T(dlxemu::CodeEditor::Coordinates, coords);
  ------------------
  |  |   38|    490|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    490|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 488]
  |  |  ------------------
  |  |   40|    490|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|    490|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  676|       |
  677|    488|                FUZZ_LOG("SetSelectionEnd(Coordinates({:s}, {:s}))", print_int(coords.m_Line),
  ------------------
  |  |   34|    488|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  678|    488|                         print_int(coords.m_Column));
  679|    488|                editor.SetSelectionEnd(coords);
  680|    488|                break;
  681|    490|            }
  682|       |
  683|       |            // SetSelection
  684|    617|            case 24: {
  ------------------
  |  Branch (684:13): [True: 617, False: 588k]
  ------------------
  685|    617|                GET_T(dlxemu::CodeEditor::Coordinates, coords_start);
  ------------------
  |  |   38|    617|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    617|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 615]
  |  |  ------------------
  |  |   40|    617|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|    617|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  686|    615|                GET_T(dlxemu::CodeEditor::Coordinates, coords_end);
  ------------------
  |  |   38|    615|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    615|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 613]
  |  |  ------------------
  |  |   40|    615|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|    615|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  687|    613|                GET_T_COND(dlxemu::CodeEditor::SelectionMode, selection_mode,
  ------------------
  |  |   46|    613|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|    613|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|    613|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 2, False: 611]
  |  |  |  |  ------------------
  |  |  |  |   40|    613|    {                                                                                              \
  |  |  |  |   41|      2|        return {};                                                                                 \
  |  |  |  |   42|      2|    }                                                                                              \
  |  |  |  |   43|    613|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  1.22k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:11): [True: 611, False: 0]
  |  |  |  Branch (47:11): [True: 609, False: 2]
  |  |  ------------------
  |  |   48|    611|    {                                                                                              \
  |  |   49|      2|        return {};                                                                                 \
  |  |   50|      2|    }                                                                                              \
  |  |   51|    611|    (void)(0)
  ------------------
  688|    609|                           selection_mode >= dlxemu::CodeEditor::SelectionMode::Normal &&
  689|    609|                                   selection_mode <= dlxemu::CodeEditor::SelectionMode::Line);
  690|       |
  691|    609|                FUZZ_LOG("SetSelection(Coordinates({:s}, {:s}), Coordinates({:s}, "
  ------------------
  |  |   34|    609|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  692|    609|                         "{:s}), {:s})",
  693|    609|                         print_int(coords_start.m_Line), print_int(coords_start.m_Column),
  694|    609|                         print_int(coords_end.m_Line), print_int(coords_start.m_Column),
  695|    609|                         dlx::enum_name(selection_mode).data());
  696|    609|                editor.SetSelection(coords_start, coords_end, selection_mode);
  697|    609|                break;
  698|    611|            }
  699|       |
  700|       |            // SelectWordUnderCursor
  701|    962|            case 25: {
  ------------------
  |  Branch (701:13): [True: 962, False: 588k]
  ------------------
  702|    962|                FUZZ_LOG("SelectWordUnderCursor");
  ------------------
  |  |   34|    962|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  703|       |
  704|    962|                editor.SelectWordUnderCursor();
  705|    962|                break;
  706|    611|            }
  707|       |
  708|       |            // SelectAll
  709|    727|            case 26: {
  ------------------
  |  Branch (709:13): [True: 727, False: 588k]
  ------------------
  710|    727|                FUZZ_LOG("SelectAll");
  ------------------
  |  |   34|    727|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  711|       |
  712|    727|                editor.SelectAll();
  713|    727|                break;
  714|    611|            }
  715|       |
  716|       |            // Delete
  717|  2.12k|            case 27: {
  ------------------
  |  Branch (717:13): [True: 2.12k, False: 587k]
  ------------------
  718|  2.12k|                FUZZ_LOG("Delete");
  ------------------
  |  |   34|  2.12k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  719|       |
  720|  2.12k|                editor.Delete();
  721|  2.12k|                break;
  722|    611|            }
  723|       |
  724|       |            // Undo
  725|  1.44k|            case 28: {
  ------------------
  |  Branch (725:13): [True: 1.44k, False: 587k]
  ------------------
  726|  1.44k|                FUZZ_LOG("Undo()");
  ------------------
  |  |   34|  1.44k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  727|       |
  728|  1.44k|                editor.Undo();
  729|  1.44k|                break;
  730|    611|            }
  731|       |
  732|       |            // Redo
  733|    378|            case 29: {
  ------------------
  |  Branch (733:13): [True: 378, False: 588k]
  ------------------
  734|    378|                FUZZ_LOG("Redo()");
  ------------------
  |  |   34|    378|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  735|       |
  736|    378|                editor.Redo();
  737|    378|                break;
  738|    611|            }
  739|       |
  740|       |            // SetErrorMarkers
  741|  1.23k|            case 30: {
  ------------------
  |  Branch (741:13): [True: 1.23k, False: 588k]
  ------------------
  742|  2.47k|                GET_T_COND(phi::size_t, count, count <= MaxVectorSize);
  ------------------
  |  |   46|  1.23k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  1.23k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  1.23k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 1, False: 1.23k]
  |  |  |  |  ------------------
  |  |  |  |   40|  1.23k|    {                                                                                              \
  |  |  |  |   41|      1|        return {};                                                                                 \
  |  |  |  |   42|      1|    }                                                                                              \
  |  |  |  |   43|  1.23k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  1.23k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 4, False: 1.23k]
  |  |  ------------------
  |  |   48|  1.23k|    {                                                                                              \
  |  |   49|      4|        return {};                                                                                 \
  |  |   50|      4|    }                                                                                              \
  |  |   51|  1.23k|    (void)(0)
  ------------------
  743|       |
  744|  2.47k|                dlxemu::CodeEditor::ErrorMarkers markers;
  745|  3.77k|                for (phi::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (745:41): [True: 2.58k, False: 1.18k]
  ------------------
  746|  2.58k|                {
  747|  2.58k|                    GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   38|  2.58k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  2.58k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 29, False: 2.55k]
  |  |  ------------------
  |  |   40|  2.58k|    {                                                                                              \
  |  |   41|     29|        return {};                                                                                 \
  |  |   42|     29|    }                                                                                              \
  |  |   43|  2.58k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  748|       |
  749|  2.55k|                    if (!consume_string(data, size, index))
  ------------------
  |  Branch (749:25): [True: 20, False: 2.53k]
  ------------------
  750|     20|                    {
  751|     20|                        return 0;
  752|     20|                    }
  753|  2.53k|                    std::string& message = cache.string;
  754|       |
  755|       |                    // Add to error markers
  756|  2.53k|                    markers[line_number] = message;
  757|  2.53k|                }
  758|       |
  759|  1.18k|                FUZZ_LOG("SetErrorMarkers({:s})", print_error_markers(markers));
  ------------------
  |  |   34|  1.18k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  760|       |
  761|  1.18k|                editor.SetErrorMarkers(markers);
  762|  1.18k|                break;
  763|  2.47k|            }
  764|       |
  765|       |            // SetBreakpoints
  766|  1.61k|            case 31: {
  ------------------
  |  Branch (766:13): [True: 1.61k, False: 587k]
  ------------------
  767|  3.22k|                GET_T_COND(phi::size_t, count, count <= MaxVectorSize);
  ------------------
  |  |   46|  1.61k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  1.61k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  1.61k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 2, False: 1.61k]
  |  |  |  |  ------------------
  |  |  |  |   40|  1.61k|    {                                                                                              \
  |  |  |  |   41|      2|        return {};                                                                                 \
  |  |  |  |   42|      2|    }                                                                                              \
  |  |  |  |   43|  1.61k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  1.61k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 2, False: 1.61k]
  |  |  ------------------
  |  |   48|  1.61k|    {                                                                                              \
  |  |   49|      2|        return {};                                                                                 \
  |  |   50|      2|    }                                                                                              \
  |  |   51|  1.61k|    (void)(0)
  ------------------
  768|       |
  769|  3.22k|                dlxemu::CodeEditor::Breakpoints breakpoints;
  770|  6.94k|                for (phi::size_t i{0u}; i < count; ++i)
  ------------------
  |  Branch (770:41): [True: 5.38k, False: 1.55k]
  ------------------
  771|  5.38k|                {
  772|  5.38k|                    GET_T(phi::uint32_t, line_number);
  ------------------
  |  |   38|  5.38k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  5.38k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 55, False: 5.33k]
  |  |  ------------------
  |  |   40|  5.38k|    {                                                                                              \
  |  |   41|     55|        return {};                                                                                 \
  |  |   42|     55|    }                                                                                              \
  |  |   43|  5.38k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  773|       |
  774|  5.33k|                    breakpoints.insert(line_number);
  775|  5.33k|                }
  776|       |
  777|  1.55k|                FUZZ_LOG("SetBreakpoints({:s})", print_breakpoints(breakpoints));
  ------------------
  |  |   34|  1.55k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  778|       |
  779|  1.55k|                editor.SetBreakpoints(breakpoints);
  780|  1.55k|                break;
  781|  3.22k|            }
  782|       |
  783|       |            // Render
  784|  77.1k|            case 32: {
  ------------------
  |  Branch (784:13): [True: 77.1k, False: 512k]
  ------------------
  785|   154k|                GET_T_COND(float, x, x <= MaxSaneFloatValue && x >= 0.0f && !phi::is_nan(x));
  ------------------
  |  |   46|  77.1k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  77.1k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  77.1k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 34, False: 77.1k]
  |  |  |  |  ------------------
  |  |  |  |   40|  77.1k|    {                                                                                              \
  |  |  |  |   41|     34|        return {};                                                                                 \
  |  |  |  |   42|     34|    }                                                                                              \
  |  |  |  |   43|  77.1k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|   308k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:11): [True: 77.0k, False: 76]
  |  |  |  Branch (47:11): [True: 76.9k, False: 99]
  |  |  |  Branch (47:11): [True: 76.9k, False: 0]
  |  |  ------------------
  |  |   48|  77.1k|    {                                                                                              \
  |  |   49|    175|        return {};                                                                                 \
  |  |   50|    175|    }                                                                                              \
  |  |   51|  77.1k|    (void)(0)
  ------------------
  786|   154k|                GET_T_COND(float, y, y <= MaxSaneFloatValue && y >= 0.0f && !phi::is_nan(y));
  ------------------
  |  |   46|  76.9k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  76.9k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  76.9k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 25, False: 76.9k]
  |  |  |  |  ------------------
  |  |  |  |   40|  76.9k|    {                                                                                              \
  |  |  |  |   41|     25|        return {};                                                                                 \
  |  |  |  |   42|     25|    }                                                                                              \
  |  |  |  |   43|  76.9k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|   307k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:11): [True: 76.8k, False: 57]
  |  |  |  Branch (47:11): [True: 76.7k, False: 170]
  |  |  |  Branch (47:11): [True: 76.7k, False: 0]
  |  |  ------------------
  |  |   48|  76.9k|    {                                                                                              \
  |  |   49|    227|        return {};                                                                                 \
  |  |   50|    227|    }                                                                                              \
  |  |   51|  76.9k|    (void)(0)
  ------------------
  787|       |
  788|   153k|                ImVec2 size_vec(x, y);
  789|       |
  790|   153k|                GET_T(bool, border);
  ------------------
  |  |   38|  76.7k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  76.7k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 12, False: 76.6k]
  |  |  ------------------
  |  |   40|  76.7k|    {                                                                                              \
  |  |   41|     12|        return {};                                                                                 \
  |  |   42|     12|    }                                                                                              \
  |  |   43|  76.7k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  791|       |
  792|  76.6k|                FUZZ_LOG("Render(ImVec2({:f}, {:f}), {:s})", x, y, border ? "true" : "false");
  ------------------
  |  |   34|  76.6k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  793|       |
  794|  76.6k|                ImGui::NewFrame();
  795|  76.6k|                editor.Render(size_vec, border);
  796|  76.6k|                EndImGui();
  797|       |
  798|  76.6k|                break;
  799|   153k|            }
  800|       |
  801|       |            // EnterCharacter
  802|  29.9k|            case 33: {
  ------------------
  |  Branch (802:13): [True: 29.9k, False: 559k]
  ------------------
  803|  29.9k|                GET_T(ImWchar, character);
  ------------------
  |  |   38|  29.9k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  29.9k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 6, False: 29.9k]
  |  |  ------------------
  |  |   40|  29.9k|    {                                                                                              \
  |  |   41|      6|        return {};                                                                                 \
  |  |   42|      6|    }                                                                                              \
  |  |   43|  29.9k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  804|  29.9k|                GET_T(bool, shift);
  ------------------
  |  |   38|  29.9k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  29.9k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 37, False: 29.9k]
  |  |  ------------------
  |  |   40|  29.9k|    {                                                                                              \
  |  |   41|     37|        return {};                                                                                 \
  |  |   42|     37|    }                                                                                              \
  |  |   43|  29.9k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  805|       |
  806|  29.9k|                FUZZ_LOG("EnterCharacter({:s}, {:s})", print_char(character), print_bool(shift));
  ------------------
  |  |   34|  29.9k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  807|  29.9k|                editor.EnterCharacter(character, shift);
  808|  29.9k|                break;
  809|  29.9k|            }
  810|       |
  811|       |            // ClearText
  812|    466|            case 34: {
  ------------------
  |  Branch (812:13): [True: 466, False: 588k]
  ------------------
  813|    466|                FUZZ_LOG("ClearText()");
  ------------------
  |  |   34|    466|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  814|       |
  815|    466|                editor.ClearText();
  816|    466|                break;
  817|  29.9k|            }
  818|       |
  819|       |            // ClearSelection
  820|    833|            case 35: {
  ------------------
  |  Branch (820:13): [True: 833, False: 588k]
  ------------------
  821|    833|                FUZZ_LOG("ClearSelection");
  ------------------
  |  |   34|    833|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  822|       |
  823|    833|                editor.ClearSelection();
  824|    833|                break;
  825|  29.9k|            }
  826|       |
  827|       |            // Backspace
  828|  16.7k|            case 36: {
  ------------------
  |  Branch (828:13): [True: 16.7k, False: 572k]
  ------------------
  829|  16.7k|                FUZZ_LOG("Backspace");
  ------------------
  |  |   34|  16.7k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  830|       |
  831|  16.7k|                editor.Backspace();
  832|  16.7k|                break;
  833|  29.9k|            }
  834|       |
  835|       |            // ImGui::AddKeyEvent
  836|  1.13k|            case 37: {
  ------------------
  |  Branch (836:13): [True: 1.13k, False: 588k]
  ------------------
  837|  2.27k|                GET_T_COND(ImGuiKey, key,
  ------------------
  |  |   46|  1.13k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  1.13k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  1.13k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 1, False: 1.13k]
  |  |  |  |  ------------------
  |  |  |  |   40|  1.13k|    {                                                                                              \
  |  |  |  |   41|      1|        return {};                                                                                 \
  |  |  |  |   42|      1|    }                                                                                              \
  |  |  |  |   43|  1.13k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  4.54k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 5, False: 1.13k]
  |  |  |  Branch (47:11): [True: 1.13k, False: 4]
  |  |  |  Branch (47:11): [True: 1.13k, False: 1]
  |  |  |  Branch (47:11): [True: 1.13k, False: 0]
  |  |  ------------------
  |  |   48|  1.13k|    {                                                                                              \
  |  |   49|      5|        return {};                                                                                 \
  |  |   50|      5|    }                                                                                              \
  |  |   51|  1.13k|    (void)(0)
  ------------------
  838|  2.27k|                           ImGui::IsNamedKey(key) && !ImGui::IsAliasKey(key) &&
  839|  2.27k|                                   !IsReservedKey(key));
  840|  2.27k|                GET_T(bool, down);
  ------------------
  |  |   38|  1.13k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  1.13k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 1.13k]
  |  |  ------------------
  |  |   40|  1.13k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  1.13k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  841|       |
  842|  1.13k|                FUZZ_LOG("ImGui::GetIO().AddKeyEvent({:s}, {:s})", magic_enum::enum_name(key),
  ------------------
  |  |   34|  1.13k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  843|  1.13k|                         print_bool(down));
  844|  1.13k|                ImGui::GetIO().AddKeyEvent(key, down);
  845|       |
  846|  1.13k|                break;
  847|  2.27k|            }
  848|       |
  849|       |            // ImGui::AddKeyAnalogEvent
  850|  7.74k|            case 38: {
  ------------------
  |  Branch (850:13): [True: 7.74k, False: 581k]
  ------------------
  851|  15.4k|                GET_T_COND(ImGuiKey, key,
  ------------------
  |  |   46|  7.74k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  7.74k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  7.74k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 2, False: 7.74k]
  |  |  |  |  ------------------
  |  |  |  |   40|  7.74k|    {                                                                                              \
  |  |  |  |   41|      2|        return {};                                                                                 \
  |  |  |  |   42|      2|    }                                                                                              \
  |  |  |  |   43|  7.74k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  30.8k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 41, False: 7.70k]
  |  |  |  Branch (47:11): [True: 7.70k, False: 39]
  |  |  |  Branch (47:11): [True: 7.70k, False: 2]
  |  |  |  Branch (47:11): [True: 7.70k, False: 0]
  |  |  ------------------
  |  |   48|  7.74k|    {                                                                                              \
  |  |   49|     41|        return {};                                                                                 \
  |  |   50|     41|    }                                                                                              \
  |  |   51|  7.74k|    (void)(0)
  ------------------
  852|  15.4k|                           ImGui::IsNamedKey(key) && !ImGui::IsAliasKey(key) &&
  853|  15.4k|                                   !IsReservedKey(key));
  854|  15.4k|                GET_T(bool, down);
  ------------------
  |  |   38|  7.70k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  7.70k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 7.70k]
  |  |  ------------------
  |  |   40|  7.70k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  7.70k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  855|  7.70k|                GET_T_COND(float, value, phi::abs(value) <= MaxSaneFloatValue);
  ------------------
  |  |   46|  7.70k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  7.70k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  7.70k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 3, False: 7.69k]
  |  |  |  |  ------------------
  |  |  |  |   40|  7.70k|    {                                                                                              \
  |  |  |  |   41|      3|        return {};                                                                                 \
  |  |  |  |   42|      3|    }                                                                                              \
  |  |  |  |   43|  7.70k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  7.69k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 7, False: 7.69k]
  |  |  ------------------
  |  |   48|  7.69k|    {                                                                                              \
  |  |   49|      7|        return {};                                                                                 \
  |  |   50|      7|    }                                                                                              \
  |  |   51|  7.69k|    (void)(0)
  ------------------
  856|       |
  857|  7.69k|                FUZZ_LOG("ImGui::GetIO().AddKeyAnalogEvent({:s}, {:s}, {:f})",
  ------------------
  |  |   34|  7.69k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  858|  7.69k|                         magic_enum::enum_name(key), print_bool(down), value);
  859|  7.69k|                ImGui::GetIO().AddKeyAnalogEvent(key, down, value);
  860|       |
  861|  7.69k|                break;
  862|  7.69k|            }
  863|       |
  864|       |            // ImGui::AddMousePosEvent
  865|  5.19k|            case 39: {
  ------------------
  |  Branch (865:13): [True: 5.19k, False: 584k]
  ------------------
  866|  10.3k|                GET_T_COND(float, x, phi::abs(x) <= MaxSaneFloatValue);
  ------------------
  |  |   46|  5.19k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  5.19k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  5.19k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 5, False: 5.18k]
  |  |  |  |  ------------------
  |  |  |  |   40|  5.19k|    {                                                                                              \
  |  |  |  |   41|      5|        return {};                                                                                 \
  |  |  |  |   42|      5|    }                                                                                              \
  |  |  |  |   43|  5.19k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  5.18k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 7, False: 5.18k]
  |  |  ------------------
  |  |   48|  5.18k|    {                                                                                              \
  |  |   49|      7|        return {};                                                                                 \
  |  |   50|      7|    }                                                                                              \
  |  |   51|  5.18k|    (void)(0)
  ------------------
  867|  10.3k|                GET_T_COND(float, y, phi::abs(y) <= MaxSaneFloatValue);
  ------------------
  |  |   46|  5.18k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  5.18k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  5.18k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 5, False: 5.17k]
  |  |  |  |  ------------------
  |  |  |  |   40|  5.18k|    {                                                                                              \
  |  |  |  |   41|      5|        return {};                                                                                 \
  |  |  |  |   42|      5|    }                                                                                              \
  |  |  |  |   43|  5.18k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  5.17k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 16, False: 5.16k]
  |  |  ------------------
  |  |   48|  5.17k|    {                                                                                              \
  |  |   49|     16|        return {};                                                                                 \
  |  |   50|     16|    }                                                                                              \
  |  |   51|  5.17k|    (void)(0)
  ------------------
  868|       |
  869|  5.16k|                FUZZ_LOG("ImGui::GetIO().AddMousePosEvent({:f}, {:f})", x, y);
  ------------------
  |  |   34|  5.16k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  870|  5.16k|                ImGui::GetIO().AddMousePosEvent(x, y);
  871|       |
  872|  5.16k|                break;
  873|  5.17k|            }
  874|       |
  875|       |            // ImGui::AddMouseButtonEvent
  876|  12.6k|            case 40: {
  ------------------
  |  Branch (876:13): [True: 12.6k, False: 576k]
  ------------------
  877|  25.2k|                GET_T_COND(int, button, button >= 0 && button < ImGuiMouseButton_COUNT);
  ------------------
  |  |   46|  12.6k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  12.6k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  12.6k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 4, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |   40|  12.6k|    {                                                                                              \
  |  |  |  |   41|      4|        return {};                                                                                 \
  |  |  |  |   42|      4|    }                                                                                              \
  |  |  |  |   43|  12.6k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  25.2k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:11): [True: 12.6k, False: 19]
  |  |  |  Branch (47:11): [True: 12.6k, False: 38]
  |  |  ------------------
  |  |   48|  12.6k|    {                                                                                              \
  |  |   49|     57|        return {};                                                                                 \
  |  |   50|     57|    }                                                                                              \
  |  |   51|  12.6k|    (void)(0)
  ------------------
  878|  25.2k|                GET_T(bool, down);
  ------------------
  |  |   38|  12.6k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  12.6k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 4, False: 12.5k]
  |  |  ------------------
  |  |   40|  12.6k|    {                                                                                              \
  |  |   41|      4|        return {};                                                                                 \
  |  |   42|      4|    }                                                                                              \
  |  |   43|  12.6k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  879|       |
  880|  12.5k|                FUZZ_LOG("ImGui::GetIO().AddMouseButtonEvent({}, {:s})", button, print_bool(down));
  ------------------
  |  |   34|  12.5k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  881|  12.5k|                ImGui::GetIO().AddMouseButtonEvent(button, down);
  882|       |
  883|  12.5k|                break;
  884|  25.2k|            }
  885|       |
  886|       |            // ImGui::AddMouseWheelEvent
  887|  3.51k|            case 41: {
  ------------------
  |  Branch (887:13): [True: 3.51k, False: 585k]
  ------------------
  888|  7.01k|                GET_T_COND(float, wh_x, phi::abs(wh_x) <= MaxSaneFloatValue);
  ------------------
  |  |   46|  3.51k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  3.51k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  3.51k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 2, False: 3.50k]
  |  |  |  |  ------------------
  |  |  |  |   40|  3.51k|    {                                                                                              \
  |  |  |  |   41|      2|        return {};                                                                                 \
  |  |  |  |   42|      2|    }                                                                                              \
  |  |  |  |   43|  3.51k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  3.50k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 3, False: 3.50k]
  |  |  ------------------
  |  |   48|  3.50k|    {                                                                                              \
  |  |   49|      3|        return {};                                                                                 \
  |  |   50|      3|    }                                                                                              \
  |  |   51|  3.50k|    (void)(0)
  ------------------
  889|  7.01k|                GET_T_COND(float, wh_y, phi::abs(wh_y) <= MaxSaneFloatValue);
  ------------------
  |  |   46|  3.50k|    GET_T(type, name);                                                                             \
  |  |  ------------------
  |  |  |  |   38|  3.50k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |  |  |   39|  3.50k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (39:9): [True: 2, False: 3.50k]
  |  |  |  |  ------------------
  |  |  |  |   40|  3.50k|    {                                                                                              \
  |  |  |  |   41|      2|        return {};                                                                                 \
  |  |  |  |   42|      2|    }                                                                                              \
  |  |  |  |   43|  3.50k|    const type name = PHI_GLUE(name, _opt).value()
  |  |  ------------------
  |  |   47|  3.50k|    if (!(cond))                                                                                   \
  |  |  ------------------
  |  |  |  Branch (47:9): [True: 4, False: 3.50k]
  |  |  ------------------
  |  |   48|  3.50k|    {                                                                                              \
  |  |   49|      4|        return {};                                                                                 \
  |  |   50|      4|    }                                                                                              \
  |  |   51|  3.50k|    (void)(0)
  ------------------
  890|       |
  891|  3.50k|                FUZZ_LOG("ImGui::GetIO().AddMouseWheelEvent({:f}, {:f})", wh_x, wh_y);
  ------------------
  |  |   34|  3.50k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  892|  3.50k|                ImGui::GetIO().AddMouseWheelEvent(wh_x, wh_y);
  893|       |
  894|  3.50k|                break;
  895|  3.50k|            }
  896|       |
  897|       |            // ImGui::AddFocusEvent
  898|  3.51k|            case 42: {
  ------------------
  |  Branch (898:13): [True: 3.51k, False: 585k]
  ------------------
  899|  3.51k|                GET_T(bool, focused);
  ------------------
  |  |   38|  3.51k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  3.51k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 3.51k]
  |  |  ------------------
  |  |   40|  3.51k|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|  3.51k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  900|       |
  901|  3.51k|                FUZZ_LOG("ImGui::GetIO().AddFocusEvent({:s})", print_bool(focused));
  ------------------
  |  |   34|  3.51k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  902|  3.51k|                ImGui::GetIO().AddFocusEvent(focused);
  903|       |
  904|  3.51k|                break;
  905|  3.51k|            }
  906|       |
  907|       |            // ImGui::AddInputCharacter
  908|  4.92k|            case 43: {
  ------------------
  |  Branch (908:13): [True: 4.92k, False: 584k]
  ------------------
  909|  4.92k|                GET_T(unsigned int, character);
  ------------------
  |  |   38|  4.92k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  4.92k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 7, False: 4.91k]
  |  |  ------------------
  |  |   40|  4.92k|    {                                                                                              \
  |  |   41|      7|        return {};                                                                                 \
  |  |   42|      7|    }                                                                                              \
  |  |   43|  4.92k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  910|       |
  911|  4.91k|                FUZZ_LOG("ImGui::GetIO().AddInputCharacter({})", character);
  ------------------
  |  |   34|  4.91k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  912|  4.91k|                ImGui::GetIO().AddInputCharacter(character);
  913|       |
  914|  4.91k|                break;
  915|  4.92k|            }
  916|       |
  917|       |            // ImGui::AddInputCharacterUTF16
  918|  1.81k|            case 44: {
  ------------------
  |  Branch (918:13): [True: 1.81k, False: 587k]
  ------------------
  919|  1.81k|                GET_T(ImWchar16, character);
  ------------------
  |  |   38|  1.81k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  1.81k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 4, False: 1.80k]
  |  |  ------------------
  |  |   40|  1.81k|    {                                                                                              \
  |  |   41|      4|        return {};                                                                                 \
  |  |   42|      4|    }                                                                                              \
  |  |   43|  1.81k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  920|       |
  921|  1.80k|                FUZZ_LOG("ImGui::GetIO().AddInputCharacterUTF16({})", character);
  ------------------
  |  |   34|  1.80k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  922|  1.80k|                ImGui::GetIO().AddInputCharacterUTF16(character);
  923|       |
  924|  1.80k|                break;
  925|  1.81k|            }
  926|       |
  927|       |            // ImGui::AddInputCharactersUTF8
  928|     88|            case 45: {
  ------------------
  |  Branch (928:13): [True: 88, False: 589k]
  ------------------
  929|     88|                if (!consume_string(data, size, index))
  ------------------
  |  Branch (929:21): [True: 23, False: 65]
  ------------------
  930|     23|                {
  931|     23|                    return 0;
  932|     23|                }
  933|     65|                std::string& str = cache.string;
  934|       |
  935|     65|                FUZZ_LOG("ImGui::GetIO().AddInputCharactersUTF8({:s})", print_string(str));
  ------------------
  |  |   34|     65|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  936|     65|                ImGui::GetIO().AddInputCharactersUTF8(str.c_str());
  937|       |
  938|     65|                break;
  939|     88|            }
  940|       |
  941|       |            // Copy
  942|  9.82k|            case 46: {
  ------------------
  |  Branch (942:13): [True: 9.82k, False: 579k]
  ------------------
  943|  9.82k|                FUZZ_LOG("Copy()");
  ------------------
  |  |   34|  9.82k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  944|  9.82k|                editor.Copy();
  945|       |
  946|  9.82k|                break;
  947|     88|            }
  948|       |
  949|       |            // Cut
  950|    820|            case 47: {
  ------------------
  |  Branch (950:13): [True: 820, False: 588k]
  ------------------
  951|    820|                FUZZ_LOG("Cut()");
  ------------------
  |  |   34|    820|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  952|    820|                editor.Cut();
  953|       |
  954|    820|                break;
  955|     88|            }
  956|       |
  957|       |            // Paste
  958|  19.4k|            case 48: {
  ------------------
  |  Branch (958:13): [True: 19.4k, False: 569k]
  ------------------
  959|  19.4k|                FUZZ_LOG("Paste()");
  ------------------
  |  |   34|  19.4k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  960|  19.4k|                editor.Paste();
  961|       |
  962|  19.4k|                break;
  963|     88|            }
  964|       |
  965|       |            // SetOverwrite
  966|    779|            case 49: {
  ------------------
  |  Branch (966:13): [True: 779, False: 588k]
  ------------------
  967|    779|                GET_T(bool, overwrite);
  ------------------
  |  |   38|    779|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    779|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 778]
  |  |  ------------------
  |  |   40|    779|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    779|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  968|       |
  969|    778|                FUZZ_LOG("SetOverwrite({:s})", print_bool(overwrite));
  ------------------
  |  |   34|    778|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  970|    778|                editor.SetOverwrite(overwrite);
  971|       |
  972|    778|                break;
  973|    779|            }
  974|       |
  975|       |            // SetColorizerEnable
  976|    322|            case 50: {
  ------------------
  |  Branch (976:13): [True: 322, False: 588k]
  ------------------
  977|    322|                GET_T(bool, colorizer);
  ------------------
  |  |   38|    322|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    322|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 321]
  |  |  ------------------
  |  |   40|    322|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    322|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  978|       |
  979|    321|                FUZZ_LOG("SetColorizerEnable({:s})", print_bool(colorizer));
  ------------------
  |  |   34|    321|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  980|    321|                editor.SetColorizerEnable(colorizer);
  981|       |
  982|    321|                break;
  983|    322|            }
  984|       |
  985|       |            // RemoveBreakpoint
  986|    918|            case 51: {
  ------------------
  |  Branch (986:13): [True: 918, False: 588k]
  ------------------
  987|    918|                GET_T(phi::u32, line_number);
  ------------------
  |  |   38|    918|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|    918|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 1, False: 917]
  |  |  ------------------
  |  |   40|    918|    {                                                                                              \
  |  |   41|      1|        return {};                                                                                 \
  |  |   42|      1|    }                                                                                              \
  |  |   43|    918|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  988|       |
  989|    917|                FUZZ_LOG("RemoveBreakpoint({:s})", print_int(line_number));
  ------------------
  |  |   34|    917|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
  990|    917|                editor.RemoveBreakpoint(line_number);
  991|       |
  992|    917|                break;
  993|    918|            }
  994|       |
  995|       |            // ToggleBreakpoint
  996|  4.21k|            case 52: {
  ------------------
  |  Branch (996:13): [True: 4.21k, False: 585k]
  ------------------
  997|  4.21k|                GET_T(phi::u32, line_number);
  ------------------
  |  |   38|  4.21k|    auto PHI_GLUE(name, _opt) = consume_t<type>(data, size, index);                                \
  |  |   39|  4.21k|    if (!PHI_GLUE(name, _opt))                                                                     \
  |  |  ------------------
  |  |  |  Branch (39:9): [True: 2, False: 4.21k]
  |  |  ------------------
  |  |   40|  4.21k|    {                                                                                              \
  |  |   41|      2|        return {};                                                                                 \
  |  |   42|      2|    }                                                                                              \
  |  |   43|  4.21k|    const type name = PHI_GLUE(name, _opt).value()
  ------------------
  998|       |
  999|  4.21k|                FUZZ_LOG("ToggleBreakpoint({:s})", print_int(line_number));
  ------------------
  |  |   34|  4.21k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
 1000|  4.21k|                editor.ToggleBreakpoint(line_number);
 1001|       |
 1002|  4.21k|                break;
 1003|  4.21k|            }
 1004|   589k|        }
 1005|   589k|    }
 1006|       |
 1007|  4.52k|    FUZZ_LOG("VerifyInternalState()");
  ------------------
  |  |   34|  4.52k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
 1008|  4.52k|    editor.VerifyInternalState();
 1009|       |
 1010|  4.52k|    FUZZ_LOG("Finished execution");
  ------------------
  |  |   34|  4.52k|#    define FUZZ_LOG(...) PHI_EMPTY_MACRO()
  ------------------
 1011|       |
 1012|  4.52k|    return 0;
 1013|  9.87k|}
_ZN5Cache10InitializeEv:
   74|      2|    {
   75|      2|        Cache c;
   76|       |
   77|       |        // Resize vector args
   78|     18|        for (phi::usize i{0u}; i < MaxVectorSize; ++i)
  ------------------
  |  Branch (78:32): [True: 16, False: 2]
  ------------------
   79|     16|        {
   80|     16|            svec& vector = c.vector_string[i.unsafe()];
   81|     16|            vector.resize(i.unsafe());
   82|       |
   83|       |            // Reserve max size
   84|     16|            for (std::string& str : vector)
  ------------------
  |  Branch (84:35): [True: 56, False: 16]
  ------------------
   85|     56|            {
   86|     56|                str.reserve(MaxStringLength);
   87|     56|            }
   88|     16|        }
   89|       |
   90|      2|        c.string.reserve(MaxStringLength);
   91|       |
   92|      2|        return c;
   93|      2|    }
_Z9consume_tIjEN3phi8optionalIT_EEPKhmRm:
  113|   650k|{
  114|   650k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 2.23k, False: 648k]
  ------------------
  115|  2.23k|    {
  116|  2.23k|        return {};
  117|  2.23k|    }
  118|       |
  119|   648k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|   648k|    const phi::size_t old_index = index;
  122|   648k|    index += aligned_size<T>();
  123|       |
  124|   648k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|   648k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|   648k|        return static_cast<bool>(value);
  128|   648k|    }
  129|   648k|    else
  130|   648k|    {
  131|   648k|        return *reinterpret_cast<const T*>(data + old_index);
  132|   648k|    }
  133|   648k|}
_Z10has_x_moremmm:
  100|  1.04M|{
  101|  1.04M|    return index + x < size;
  102|  1.04M|}
_Z12aligned_sizeIjEmv:
  106|   648k|{
  107|   648k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|   648k|}
_Z9consume_tImEN3phi8optionalIT_EEPKhmRm:
  113|  3.95k|{
  114|  3.95k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 11, False: 3.94k]
  ------------------
  115|     11|    {
  116|     11|        return {};
  117|     11|    }
  118|       |
  119|  3.94k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|  3.94k|    const phi::size_t old_index = index;
  122|  3.94k|    index += aligned_size<T>();
  123|       |
  124|  3.94k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|  3.94k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|  3.94k|        return static_cast<bool>(value);
  128|  3.94k|    }
  129|  3.94k|    else
  130|  3.94k|    {
  131|  3.94k|        return *reinterpret_cast<const T*>(data + old_index);
  132|  3.94k|    }
  133|  3.94k|}
_Z12aligned_sizeImEmv:
  106|  3.94k|{
  107|  3.94k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|  3.94k|}
_Z9consume_tIbEN3phi8optionalIT_EEPKhmRm:
  113|   152k|{
  114|   152k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 86, False: 152k]
  ------------------
  115|     86|    {
  116|     86|        return {};
  117|     86|    }
  118|       |
  119|   152k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|   152k|    const phi::size_t old_index = index;
  122|   152k|    index += aligned_size<T>();
  123|       |
  124|   152k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|   152k|    {
  126|   152k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|   152k|        return static_cast<bool>(value);
  128|   152k|    }
  129|   152k|    else
  130|   152k|    {
  131|   152k|        return *reinterpret_cast<const T*>(data + old_index);
  132|   152k|    }
  133|   152k|}
_Z12aligned_sizeIbEmv:
  106|   152k|{
  107|   152k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|   152k|}
_Z9consume_tIhEN3phi8optionalIT_EEPKhmRm:
  113|  1.33k|{
  114|  1.33k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 1, False: 1.33k]
  ------------------
  115|      1|    {
  116|      1|        return {};
  117|      1|    }
  118|       |
  119|  1.33k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|  1.33k|    const phi::size_t old_index = index;
  122|  1.33k|    index += aligned_size<T>();
  123|       |
  124|  1.33k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|  1.33k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|  1.33k|        return static_cast<bool>(value);
  128|  1.33k|    }
  129|  1.33k|    else
  130|  1.33k|    {
  131|  1.33k|        return *reinterpret_cast<const T*>(data + old_index);
  132|  1.33k|    }
  133|  1.33k|}
_Z12aligned_sizeIhEmv:
  106|  1.33k|{
  107|  1.33k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|  1.33k|}
_Z9consume_tIN6dlxemu10CodeEditor13SelectionModeEEN3phi8optionalIT_EEPKhmRm:
  113|    613|{
  114|    613|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 2, False: 611]
  ------------------
  115|      2|    {
  116|      2|        return {};
  117|      2|    }
  118|       |
  119|    611|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|    611|    const phi::size_t old_index = index;
  122|    611|    index += aligned_size<T>();
  123|       |
  124|    611|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|    611|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|    611|        return static_cast<bool>(value);
  128|    611|    }
  129|    611|    else
  130|    611|    {
  131|    611|        return *reinterpret_cast<const T*>(data + old_index);
  132|    611|    }
  133|    611|}
_Z12aligned_sizeIN6dlxemu10CodeEditor13SelectionModeEEmv:
  106|    611|{
  107|    611|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|    611|}
_Z9consume_tIfEN3phi8optionalIT_EEPKhmRm:
  113|   179k|{
  114|   179k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 76, False: 179k]
  ------------------
  115|     76|    {
  116|     76|        return {};
  117|     76|    }
  118|       |
  119|   179k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|   179k|    const phi::size_t old_index = index;
  122|   179k|    index += aligned_size<T>();
  123|       |
  124|   179k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|   179k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|   179k|        return static_cast<bool>(value);
  128|   179k|    }
  129|   179k|    else
  130|   179k|    {
  131|   179k|        return *reinterpret_cast<const T*>(data + old_index);
  132|   179k|    }
  133|   179k|}
_Z12aligned_sizeIfEmv:
  106|   179k|{
  107|   179k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|   179k|}
_Z9consume_tItEN3phi8optionalIT_EEPKhmRm:
  113|  31.8k|{
  114|  31.8k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 10, False: 31.7k]
  ------------------
  115|     10|    {
  116|     10|        return {};
  117|     10|    }
  118|       |
  119|  31.7k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|  31.7k|    const phi::size_t old_index = index;
  122|  31.7k|    index += aligned_size<T>();
  123|       |
  124|  31.7k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|  31.7k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|  31.7k|        return static_cast<bool>(value);
  128|  31.7k|    }
  129|  31.7k|    else
  130|  31.7k|    {
  131|  31.7k|        return *reinterpret_cast<const T*>(data + old_index);
  132|  31.7k|    }
  133|  31.7k|}
_Z12aligned_sizeItEmv:
  106|  31.7k|{
  107|  31.7k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|  31.7k|}
_Z9consume_tI8ImGuiKeyEN3phi8optionalIT_EEPKhmRm:
  113|  8.88k|{
  114|  8.88k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 3, False: 8.88k]
  ------------------
  115|      3|    {
  116|      3|        return {};
  117|      3|    }
  118|       |
  119|  8.88k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|  8.88k|    const phi::size_t old_index = index;
  122|  8.88k|    index += aligned_size<T>();
  123|       |
  124|  8.88k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|  8.88k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|  8.88k|        return static_cast<bool>(value);
  128|  8.88k|    }
  129|  8.88k|    else
  130|  8.88k|    {
  131|  8.88k|        return *reinterpret_cast<const T*>(data + old_index);
  132|  8.88k|    }
  133|  8.88k|}
_Z12aligned_sizeI8ImGuiKeyEmv:
  106|  8.88k|{
  107|  8.88k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|  8.88k|}
_Z9consume_tIiEN3phi8optionalIT_EEPKhmRm:
  113|  12.6k|{
  114|  12.6k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 4, False: 12.6k]
  ------------------
  115|      4|    {
  116|      4|        return {};
  117|      4|    }
  118|       |
  119|  12.6k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|  12.6k|    const phi::size_t old_index = index;
  122|  12.6k|    index += aligned_size<T>();
  123|       |
  124|  12.6k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|  12.6k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|  12.6k|        return static_cast<bool>(value);
  128|  12.6k|    }
  129|  12.6k|    else
  130|  12.6k|    {
  131|  12.6k|        return *reinterpret_cast<const T*>(data + old_index);
  132|  12.6k|    }
  133|  12.6k|}
_Z12aligned_sizeIiEmv:
  106|  12.6k|{
  107|  12.6k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|  12.6k|}
_Z9consume_tIN3phi7integerIjEEENS0_8optionalIT_EEPKhmRm:
  113|  5.13k|{
  114|  5.13k|    if (!has_x_more(index, sizeof(T), size))
  ------------------
  |  Branch (114:9): [True: 3, False: 5.13k]
  ------------------
  115|      3|    {
  116|      3|        return {};
  117|      3|    }
  118|       |
  119|  5.13k|    PHI_ASSUME(index % sizeof(void*) == 0);
  120|       |
  121|  5.13k|    const phi::size_t old_index = index;
  122|  5.13k|    index += aligned_size<T>();
  123|       |
  124|  5.13k|    if constexpr (phi::is_bool_v<T>)
  ------------------
  |  Branch (124:19): [Folded - Ignored]
  ------------------
  125|      0|    {
  126|  5.13k|        phi::int8_t value = *reinterpret_cast<const phi::int8_t*>(data + old_index);
  127|  5.13k|        return static_cast<bool>(value);
  128|  5.13k|    }
  129|  5.13k|    else
  130|  5.13k|    {
  131|  5.13k|        return *reinterpret_cast<const T*>(data + old_index);
  132|  5.13k|    }
  133|  5.13k|}
_Z12aligned_sizeIN3phi7integerIjEEEmv:
  106|  5.13k|{
  107|  5.13k|    return sizeof(T) + (sizeof(void*) - sizeof(T));
  108|  5.13k|}

